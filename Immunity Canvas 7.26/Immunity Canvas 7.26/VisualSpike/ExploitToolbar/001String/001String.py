#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


import sys
import gtk
if "." not in sys.path: sys.path.append(".")
from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
    NAME = "String"
    GLADE_DIALOG = "dialog.glade2"
    filexpm = "string.ico"
    button_label = "Add String"
    button_tooltip = "Add a String to the fuzzer"
    button_private_tooltip = "Private"
    button_signal = None
    color = "#8dc7bb"
    size = 55
    NumberofXp =1
    objsize = 0
    objectcomments = None  
    fuzzeable = False
    link=False


    def __init__(self):
        VisualToolbar.__init__(self)


    def setSize(self, size):
        self.size =size

    def setArg(self,args):
        self.string = args['checkbadchar']
        try:
            tmp=self.string.decode('string_escape')
        except ValueError:
            tmp="Error parsing string!"
        self.objsize = len(tmp)
        self.fuzzeable = args['checkfuzzeable']

    def setDialog(self,dialog,xpacket,badchars,arch):
        string=dialog.get_widget('checkbadchar')
        string.set_text(self.string)
        fuzzeable = dialog.get_widget('checkfuzzeable')
        if self.fuzzeable == True:
            fuzzeable.set_active(True)
        else:
            fuzzeable.set_active(False)

        #checkrepeat.connect('toggled', self.changes,box,repeat)

    def changes(self,checkrepeat,box,repeat):
        return 
        #if checkrepeat.get_active() == True:
        #    box.show()
        #else:
        #    self.repeat="1"
        #    repeat.set_value(int(self.repeat))
        #    box.hide()
        #return


    def createPython(self):
        
        if self.fuzzeable:
            return ["spk.s_string_variable(%r)\n" % self.string.decode('string_escape') or r'([A-Z]+)\.\1']  
        else:
            return ["spk.s_string(%r)\n" % self.string.decode('string_escape')]  

    def Show(self):
        try:
            buf = "String: %s\nLength: %d bytes Fuzzable: %s" % (self.string, int(self.objsize), str(self.fuzzeable))
        except:
            buf = "String: None Length: None"
 
        return buf


    def preparedialog(self,dialog,argb,argc,badchars,arch):
        checkfuzzeable = dialog.get_widget('checkfuzzeable')
        
        if self.fuzzeable == True:
            checkfuzzeable.set_active(True)
        else:
            checkfuzzeable.set_active(False)
        #checkrepeat.connect('toggled', self.changes,box,repeat)



    def Help(self):
        return "The string buffer option allows you to place a string into your fuzzer \n\
buffer. You can select wether your string will be automatically fuzzed."


    def getSize(self):
        self.objsize = len(self.string.decode('string_escape'))
        return int(self.objsize)

    def save(self):
        savedic = {}
        savedic['string'] = self.string
        savedic['objsize'] = str(self.getSize())
        if self.objectcomments:
            savedic['comment'] = self.objectcomments.replace("\n","\\n")
        savedic['checkfuzzeable'] = self.fuzzeable
        return savedic

    def load(self,args):
        if args.has_key('string'):
            self.string = args['string']

        if args.has_key('objsize'):
            self.objsize = args['objsize']

        if args.has_key('checkfuzzeable'):
            self.fuzzeable = args['checkfuzzeable'] 


        if args.has_key('comment'):
            tmp = args['comment']
            self.objectcomments=tmp.replace("\\n","\n")
