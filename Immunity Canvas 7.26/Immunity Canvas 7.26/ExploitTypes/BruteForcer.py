#!/usr/bin/env python 

"""
BruteForcer.py - includes a generic threaded brute forcer logic.
"""

from canvasexploit import canvasexploit
from engine.config import canvas_resources_directory 
import os.path
from threading import RLock, Thread

class BruteForcer(canvasexploit):
    """
    
    """
    def __init__(self):
        canvasexploit.__init__(self)
        self.maxthreads=5
        
        #default get_next_word() is to use a wordlist and read it one line at a time
        self.wordlist=os.path.join(canvas_resources_directory,"passwords.txt")
        self.wordlist_lock=RLock()
        self.successful_guess=None  #the word that won
        return 
    
    def get_next_word(self):
        """
        Get the next word in our wordlist, we lock since readline may not be atomic.
        This code could go into some sort of auxiliary object that is more abstract later.
        
        It returns False when it is out of words.
        """
        #if a thread found one, it will set successful_guess
        if self.successful_guess:
            #so we pretend we are done.
            return False 
        
        self.wordlist_lock.acquire()
        try:
            next_word=self.wordlistfd.readline().strip()
        except EOFError:
            self.wordlist_lock.release()       
            return False 
        self.wordlist_lock.release()       
        return next_word
    
    def getArgs(self):
        self.getarg("maxthreads")
        if self.argsDict.get("wordlist"):
            #from the GUI, wordlist may be present, but blank
            self.getarg("wordlist")
        
    def brute_loop(self):
        """
        Override this with your connect/check loop.
        Don't forget to check for self.HALT!
        """
        self.log("Stub brute_loop called")
        return 
    
    def run(self):
        self.getArgs()
        
        if self.version==0:
            #get self.version set
            if not self.test():
                self.log("Please select a version - autodetect could not figure out what kind of telnetd this is")
                return 0
            
        if self.wordlist:
            self.wordlistfd=file(self.wordlist,"r")
        mythreads=[]
        
        if self.maxthreads<=0:
            self.log("Invalid maxthreads value recieved: %d"%self.maxthreads)
            return 0
        
        self.log("Starting %d threads to brute force with"%self.maxthreads)
        for i in xrange(0,self.maxthreads):
            """
            Start up a new thread for each run. These will call get_next_word as applicable.
            """
            t=Thread(target=self.brute_loop)
            t.setDaemon(True)
            t.start()
            mythreads+=[t]

        for a_thread in mythreads:
            a_thread.join()
            self.log("Thread finished")
        
        if self.successful_guess:
            self.log("Found successful word: %s"%self.successful_guess)
            return 1
        
        self.log("Exhausted brute force attempts - did not find successful word")
        return 0