#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys

from engine.config import *
from engine.features import *

from engine import CanvasConfig
import canvasengine

if "." not in sys.path:
    sys.path.append(".")

from ExploitTypes.utility import Utility

from exploitutils import *
from engine.features import *

import canvasengine

DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

Perform runtime CANVAS configuration updates.
There are two main setting categories that are supported.

First, OS detection settings:

Exploits can query the CANVAS engine's preference for their
operation. There are three choices if getremotelanguage cannot determine
the language to the level they need:

Assume a remote Windows machine is of a particular language
Assume the current target is most similar to its nearest neighbors
Don't run an exploit that does not have the information it needs

Both OS detection fallback language and OS detection mode can be
set here.

SSL MOSDEF: If enabled, CANVAS will attempt to transparently upgrade
MOSDEF callback connections from plain TCP to OpenSSL-encrypted. This
works dynamically using our Unix remote resolvers and it available
for OSX, Linux and ARM targets.

"""

DESCRIPTION             = "Set CANVAS runtime configuration options"
VERSION                 = "1.0"
PROPERTY                = {}
PROPERTY['TYPE']        = "Configuration"
NAME                    = "configuration"

# These two settings are globals in order to get around the fact
# that we have no reference to a canvasengine when dialog_update runs.

# Ideally, every runtime CANVAS setting should be accessible through
# CanvasConfig (which gets instantiated early @ CANVAS startup and can
# be accessed directly inside the module.

OSDETECT_LANG = "English"
OSDETECT_MODE = canvasengine.canvasengine.ASSUME_NO_RUN

class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)
        
        self.name           = NAME
        self.osdetect_mode  = OSDETECT_MODE
        self.osdetect_lang  = OSDETECT_LANG

        # Auto-set attributes
        self.canvas_config  = ['ssl_mosdef', 'commander', 'commander_bind_ip', 'commander_pub_port',
                               'commander_pull_port', 'operator_alias', 'operator_uuid']

        for item in self.canvas_config:
            self.__dict__[item] = CanvasConfig[item]

    def getargs(self):
        self.getarg("osdetect_mode")
        self.getarg("osdetect_lang")

        map(self.getarg, self.canvas_config)
    
    def run(self):
        """
        runs the attempt to set configuration
        """
        if not self.engine:
            self.log("No engine for this configuration module...not setting anything")
            return 0

        changes = {}
            
        global OSDETECT_LANG
        global OSDETECT_MODE

        self.getargs()
        
        self.log("Setting osdetect lang to: %s" % self.osdetect_lang)
        self.engine.osdetect_lang = OSDETECT_LANG = self.osdetect_lang
        
        self.log("Setting osdetect mode to: %s" % self.osdetect_mode)
        self.engine.osdetect_mode = OSDETECT_MODE = self.osdetect_mode

        for item in self.canvas_config:
            if CanvasConfig[item] != self.__dict__[item]:
                self.log('Setting %s to: %s' % (item, self.__dict__[item]))
                CanvasConfig[item] = self.__dict__[item]
                changes[item] = self.__dict__[item]

        # Create a new event
        if changes:
            self.engine.new_event('configuration changed', changes, 'configuration')
        
        return 1

def dialog_update(gtk, tree):
    lang_w            = tree.get_widget("osdetect_lang")
    mode_w            = tree.get_widget("osdetect_mode")
    ssl_mosdef_w      = tree.get_widget("ssl_mosdef")

    commander_label_w = tree.get_widget("commander_label")
    operator_label_w  = tree.get_widget("operator_label")
    uuid_label_w      = tree.get_widget("uuid_label")
    
    commander_bind_ip_label_w   = tree.get_widget("commander_bind_ip_label")
    commander_pub_port_label_w  = tree.get_widget("commander_pub_port_label")
    commander_pull_port_label_w = tree.get_widget("commander_pull_port_label")
    
    commander_w           = tree.get_widget("commander")
    commander_bind_ip_w   = tree.get_widget("commander_bind_ip")
    commander_pub_port_w  = tree.get_widget("commander_pub_port")
    commander_pull_port_w = tree.get_widget("commander_pull_port")
    operator_alias_w      = tree.get_widget("operator_alias")
    operator_uuid_w       = tree.get_widget("operator_uuid")

    
    langs = [l[0] for l in lang_w.get_model()]
    modes = [m[0] for m in mode_w.get_model()]

    try:
        lang_idx = langs.index(OSDETECT_LANG)
    except ValueError:
        # Should never happen
        lang_idx = -1

    try:
        mode_idx = modes.index(OSDETECT_MODE)
    except ValueError:
        mode_idx = -1

    lang_w.set_active(lang_idx)
    mode_w.set_active(mode_idx)
    
    ssl_mosdef_w.set_state(CanvasConfig["ssl_mosdef"])
    commander_w.set_text(CanvasConfig["commander"])
    commander_bind_ip_w.set_text(CanvasConfig["commander_bind_ip"])
    commander_pub_port_w.set_text(CanvasConfig["commander_pub_port"])
    commander_pull_port_w.set_text(CanvasConfig["commander_pull_port"])
    operator_alias_w.set_text(CanvasConfig["operator_alias"])
    operator_uuid_w.set_text(CanvasConfig["operator_uuid"])
    
    if not CONTROL_ENABLED:
        map(lambda x: x.set_sensitive(False),
            [commander_label_w,
             operator_label_w,
             uuid_label_w,
             commander_w,
             commander_bind_ip_label_w,
             commander_pub_port_label_w,
             commander_pull_port_label_w,
             commander_bind_ip_w,
             commander_pub_port_w,
             commander_pull_port_w,
             operator_alias_w,
             operator_uuid_w])


    
if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
