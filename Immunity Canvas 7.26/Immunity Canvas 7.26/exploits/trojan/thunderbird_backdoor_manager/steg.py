from __future__ import with_statement
import os
import sys
import itertools
import datetime
from optparse import OptionParser

imported_image = False
try:
    import Image
    imported_image = True
except ImportError:
    pass

if not imported_image:
    try:
        from PIL import Image
        imported_image = True
    except ImportError:
        pass

if not imported_image:
    raise ImportError("Python Imaging Library was not found.\n"
                      "This library is needed in order to use this tool.\n"
                      "You can get it through one of two methods:\n"
                      "1) from http://www.pythonware.com/products/pil/\n"
                      "2) (6/26/2018) - pip install pillow"
    )


    
MIN_DATA_LENGTH = 10 # we'll consider invalid data if it is less than this
    
class ImageStegger(object):
    def __init__(self, filename="", bitbase=8, logging_callback=None):
        self.filename = filename
        self.bitbase = bitbase
        self.custom_log = logging_callback
        
    def log(self, msg):
        if self.custom_log is None:
            print "[ImageStegger] - %s - %s" % (datetime.datetime.now(), msg)
        else:
            self.custom_log(msg)

    def bit_iterator_str(self, message, bitbase):
        """
        iterates over all bits in all characters in message
        We assume all characters in message are ANSI ASCII (8 bits)
        but bitbase attribute can be set to another value if needed
        """
        mask = 1
        mask <<= bitbase-1
        values = [ord(c) for c in message]
        for val in values:
            for i in xrange(bitbase): 
                # return first bit and shift left to get next one
                yield (val & mask) >> bitbase-1
                val <<= 1
                
    def bit_iterator_int(self, number, fix=8):
        mask = 1
        fix-=1
        mask <<= fix
        for i in xrange(fix+1):
            yield (number & mask) >> fix
            number <<= 1
        
    def bit_count(self, n):
        if sys.version_info[1] == 6:
            return len(bin(n))-2
        else:
            # if py2.5 
            count = 0
            while a:
                count += 1
                a >>= 1
            return count
        
    def iter_pixels(self, width, height):
        for h in xrange(height):
            for w in xrange(width):
                yield (w, h)
    
    def set_lsb(self, value, bit):
        """
        returns a new value with the least significant bit set to desired bit
        """
        # basically swaps the bit if it is not the one we need
        return value ^ 1 if ((value & 1) ^ bit) else value
    
    def extract_bits(self, values):
        """
        given a list of values it extracts all thier LSBs
        and returns the corresponding value
        """
        val = 0
        for v in values:
            val <<= 1
            bit = v & 1
            val = self.set_lsb(val, bit)
        return val
        
    def insert_data(self, data):
        try:
            im = Image.open(self.filename)
            im = im.convert("RGB")
        except:
            self.log("image %s could not be opened" % filename)
            return None
        # we first insert the message length
        # we will use 16 bits so max data length is 65535
        datalen = len(data)
        if datalen > 65535:
            self.log("Cannot insert message into image.\nMaximum message length is 65535 and your message length is %d" % datalen)
            return None
        
        width, height = im.size
        MAX_BYTES = ((width * height) - 6 / 3) # 6 will be used to store 2 bytes for length
        if datalen < MAX_BYTES:  
            done = False
            databits = itertools.chain(self.bit_iterator_int(datalen, 16), self.bit_iterator_str(data, self.bitbase))
            for pixel in self.iter_pixels(width, height):
                new_rgb = []
                for p in im.getpixel(pixel):
                    try:
                        p = self.set_lsb(p, databits.next())
                    except StopIteration:
                        # if we got this means we ended inserting all bits
                        done = True
                    new_rgb.append(p)
                im.putpixel(pixel, tuple(new_rgb))
                if done:
                    break
            steg_filename = "%s_steg.png" % os.path.splitext(self.filename)[0]
            im.save(steg_filename, "PNG")
            self.log("Steg image saved to %s" % steg_filename)
            return steg_filename
        else:
            self.log("data is too large to insert in selected image")
            return None
        
    def extract_data(self):
        """
        Extracts a message from the given filename
        databits is used to define if the message is ANSI ASCII (8 bits)
        or other encoding
        """
        data = ""
        try:
            im = Image.open(self.filename)
            im = im.convert("RGB")
        except:
            self.log("image %s could not be opened" % self.filename)
            return ""
        width, height = im.size
        values = []
        limit = 16
        datalen = 0
        
        MAX_BYTES = ((width * height) - 6 / 3)
    
        for pixel in self.iter_pixels(width, height):
            for p in im.getpixel(pixel):
                values.append(p)
                if len(values) == limit:
                    char = self.extract_bits(values)
                    if not datalen:
                        datalen = char                        
                        if datalen > MAX_BYTES:
                            return "ERROR: data lenght found is greater than max amount of possible bytes"
                        limit = self.bitbase
                    else:
                        data += unichr(char) if self.bitbase > 8 else chr(char)
                        if len(data) == datalen:
                            if datalen < MIN_DATA_LENGTH:
                                return "ERROR: data is shorter than minimum expected length\nData extracted:\n" + data
                            return data
                    del values[:]
        return data


#-------------------------------------------------------------------------------
if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option('-i', dest='insert', action='store_true',
                    help='insert data into image')
    
    parser.add_option('-e', dest='extract', action='store_true',
                    help='extract data from image')
    
    parser.add_option('--image', dest='image_filename', help='image filename')
    parser.add_option('--data', dest='data_filename', help='data filename')
    parser.add_option('--message', dest='message', help='message to encode')
    parser.add_option('--unicode', dest='unicode', action='store_true',
                    default=False, help='determines if message needs to be treated as unicode')
    
    options, args = parser.parse_args()
    bitbase = 16 if options.unicode else 8
    stegger = ImageStegger(options.image_filename, bitbase)

    if options.insert and not options.image_filename and not (options.data_filename or options.message):
        print "You must enter and image filename and data filename"
        sys.exit(-1)
    elif options.extract and not options.image_filename:
        print "You must enter the image filename"
        sys.exit(-1)
        
    elif options.insert:
        if options.data_filename:
            with open(options.data_filename, "r") as f:
                data = f.read().strip()
        else:
            data = options.message
            
        stegger.insert_data(data)
    
    elif options.extract:
        data = stegger.extract_data()
        print "Extracted data:\n%r" % data
