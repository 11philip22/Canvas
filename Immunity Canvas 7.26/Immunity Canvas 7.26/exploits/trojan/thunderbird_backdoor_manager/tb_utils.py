import os
import gtk
import socket
import timeoutsocket

from engine.config import canvas_resources_directory
from contextlib import contextmanager

MODULE_DIR                  = os.path.abspath(os.path.dirname(__file__))
BKD_RESOURCE_DIR            = os.path.abspath(os.path.join(canvas_resources_directory, "thunderbird_backdoor/"))
MAIN_GLADE_FILE             = os.path.join(MODULE_DIR, "BackdoorManager.glade2")
EMAIL_CONFIG_GLADE_FILE     = os.path.join(MODULE_DIR, "email_config_window.glade2")
INCOMING_EMAIL_GLADE_FILE   = os.path.join(MODULE_DIR, "incoming_email_window.glade2")
EMAIL_FIELDS_FILE           = os.path.join(BKD_RESOURCE_DIR, "emailfields.dat")
EMAIL_CONFIG_FILE           = os.path.join(BKD_RESOURCE_DIR, "emailconfig.dat")

DEFAULT_PADDING = 12

valid_actions = [
    "RESET" ,
    "EXECUTE",
    "GET PGP INFO",
    "GET ACCOUNT INFO",
    "SEND EMAIL",
    "OPEN URL",
    "READ SETTING",
    "CHANGE SETTING",
    "GET STATUS",
    "EXTRACT STEG DATA",
]

output_methods = [
    "NONE",
    "EMAIL",
    "URL",
]

http_methods = [
    "GET",
    "POST",
    "HEAD",
    "PUT",
    "DELETE",
    "TRACE",
    "OPTIONS",
    "CONNECT",
    "PATCH",
]

# Constants for UI widgets
SMTP_SEC_NONE = 0
SMTP_SEC_TLS  = 1
SMTP_SEC_SSL  = 2

SERVER_POP3 = 0
SERVER_IMAP = 1

# Default timeout in seconds for smtp/imap/pop3 connects
TIMEOUT = 5 

TIMEOUTSOCKET_REF = timeoutsocket.timeoutsocket
NO_TIMEOUTSOCKET  = socket._no_timeoutsocket
REAL_SOCKET        = socket._realsocket

@contextmanager
def socket_timeout(timeout):
    """
    Wrap python's 2.3+ default socket timeout mechanism
    in a with statement while ensuring this all works
    fine with timeoutsocket.

    We have to do this here because timeoutsocket timeouts
    do not work with imaplib/poplib.
    """
    socket.socket = NO_TIMEOUTSOCKET
    socket.setdefaulttimeout(timeout)
    try:
        yield
    finally:
        socket.setdefaulttimeout(None)
        socket.socket = TIMEOUTSOCKET_REF


class UI:
    def __init__(self, get_widget):
        self._get_widget = get_widget
    
    def __getattr__(self, name):
        widget = self._get_widget(name)
        if not widget:
            raise KeyError('no such widget: %s' % name)
        return widget
    
    def __setattr__(self, name, value):
        self.__dict__[name] = value
    
    def add_accelerator(self, accel, callback):
        group  = self.accelerator_group
        keyval, mod = gtk.accelerator_parse(accel)
        group.connect_group(keyval, mod, gtk.ACCEL_VISIBLE, lambda *a: callback())
    
    def append_model_data(self, model, columns, parent=None, **kwargs):
        data = [''] * len(columns)
        
        for name, value in kwargs.iteritems():
            column = columns[name]
            data[column] = value
            
        if isinstance(model, gtk.ListStore):
            return model.append(data)
        else:
            return model.append(parent, data)
    
    def update_model_data(self, model, it, columns, **kwargs):
        for name, value in kwargs.iteritems():
            column = columns[name]
            model.set_value(it, column, value)
    
    def model_iter_children(self, model, parent):
        childit = model.iter_children(parent.iter)
        while childit:
            yield childit
            childit = model.iter_next(childit)
    
    def model_iter_all_children(self, model):
        for parent in model:
            for child in self.model_iter_children(model, parent):
                yield child
    
    def model_iter_all(self, model):
        for parent in model:
            yield parent.iter
            for child in self.model_iter_children(model, parent):
                yield child
    
    def get_textview_text(self, textview):
        buf = textview.get_buffer()
        return buf.get_text(buf.get_start_iter(), buf.get_end_iter())
        
    def set_textview_text(self, textview, content):
        buf = textview.get_buffer()
        buf.set_text(content)
    
    def get_selected_row(self, view):
        model, it = view.get_selection().get_selected()
        if it:
            return model[model.get_path(it)]
    
    def get_selected_rows(self, view):
        model, paths = view.get_selection().get_selected_rows()
        return [model[path] for path in paths]
    
    def show_message(self, text, parent, icon=gtk.MESSAGE_INFO):
        dlg = gtk.MessageDialog(parent, gtk.DIALOG_DESTROY_WITH_PARENT,
            icon, gtk.BUTTONS_OK, text)
        try:
            dlg.run()
        finally:
            dlg.destroy()

    def show_warning(self, text, parent):
        self.show_message(text, parent, gtk.MESSAGE_WARNING)
    
    def show_error(self, text, parent):
        self.show_message(text, parent, gtk.MESSAGE_ERROR)
    
    def show_textview_dialog(self, title, text, parent):
        dlg = gtk.Dialog(title=title, parent=parent,
                            flags=gtk.DIALOG_DESTROY_WITH_PARENT,
                            buttons=None)
        textbuffer = gtk.TextBuffer()
        textbuffer.set_text(text.decode('utf-8', 'replace')) # safe decode to show stuff
        textview = gtk.TextView()
        textview.set_buffer(textbuffer)
        textview.set_size_request(400, 400)
        textview.set_wrap_mode(gtk.WRAP_WORD)
        textview.set_editable(False)
        textview.set_cursor_visible(True)	
        textview.set_border_window_size(gtk.TEXT_WINDOW_LEFT,0)
        textview.set_border_window_size(gtk.TEXT_WINDOW_RIGHT,0)
        textview.set_border_window_size(gtk.TEXT_WINDOW_TOP,0)
        textview.set_border_window_size(gtk.TEXT_WINDOW_BOTTOM,0)
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_border_width(1)
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.add(textview)
        dlg.vbox.pack_end(sw, True, True, 0)
        sw.show_all()
        try:
            dlg.run()
        finally:
            dlg.destroy()
        
    def scroll_textview_to_bottom(self, view):
        buffer = view.get_buffer()
        buffer.place_cursor(buffer.get_end_iter())
        view.scroll_mark_onscreen(buffer.get_insert())
    
    def scroll_treeview_to_bottom(self, view):
        model = view.get_model()
        if model:
            cnt = model.iter_n_children(None) - 1
            if cnt > -1:
                view.scroll_to_cell((cnt,))

