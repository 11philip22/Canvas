#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2010
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from exploitutils import *
from httpclientside import httpclientside
from libs import spkproxy

NAME                            = "ClientD Sample Module"
DESCRIPTION                     = "Checks browser user info, if Firefox we render a string, else redirect to google.com"
DOCUMENTATION                   = {}
VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"], ["Linux"], ["MacOSX"] ]
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.autoFind           = False


    def is_vulnerable(self, info_dict):
        """
        This method is called by ClientD itself in order to determine if it should run
        the module or not. `info_dict' is a Python dictionary filled with information
        from the target browser. The logic is that we can inspect that information here,
        looking for a specific operating system, browser or plugin.

        This method should return an integer 0 to 100 that represents how confident we are
        that the target is vulnerable. If 0, ClientD will not proceed any further with the exploit.
        """
        # Here we just return 0 because if it runs, it will succeed and
        # no other exploits will run during a js_recon run
        # Set to 100 to test me!
        return 0


    def makesploit(self, clientheader, clientbody):
        """
        This is the main method for this module. Every clientside should have this method,
        and it is going to get called by ClientD in order to construct the response
        that will be sent to the target browser.
        """
        h           = spkproxy.header('SERVER')
        b           = spkproxy.body()

        # clientheader is a dictionary that contains all headers sent by the target browser
        # here we get the user agent
        user_agent  = clientheader.getStrValue(['User-Agent'])

        self.log("[+] User agent of connecting host: %s" % user_agent)

        # Here we check to see if the browser is Firefox
        if 'firefox' in user_agent.lower():
            self.log("[+] Sending HTML")
            b.setBody("""
            <html>
            <head>
            </head>
            <body>
            <center><h1>Firefox detected!</h1></center>
            </body></html>
            """)
        else:
            self.log("[+] Redirect to Google")
            h.status = '302'
            h.addHeader('Location', 'http://www.google.com')
            h.addHeader('Content-Type', 'text/html')

        return h, b

