#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

##ImmunityHeader v1 
###############################################################################
## File       :  qualysguard.py
## Description:  Import knowledge from qualys reports and launch exploits
##               automagically against hosts/vulns found in qualys reports
##            :  
## Created_On :  Wed Oct 22nd 16:39:00 2009
## Created_By :  AlexM
## Modified_On:  Mon Jun 13 16:17:00 2011
## Modified_By:  Chris
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path:
    sys.path.append('.')

import csv, re, os, time, socket
import traceback
from exploitutils import *
from canvasexploit import canvasexploit

import canvasengine
from engine.config import canvas_root_directory
from exploitmanager import exploitmanager
from ExploitTypes.localcommand import LocalCommand
import CANVASNode
from socket import inet_aton

# GUI info
NAME                           = "Qualys Guard Importer"
DESCRIPTION                    = "Attacks hosts with exploits imported from Qualysreport"
DOCUMENTATION                  = {}
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION['Usage']         = """Supply the path to a QualysGuard 6.5 .csv formatted file"""
DOCUMENTATION['Note']          = """
!!! THIS MODULE AUTOMATICALLY EXPLOITS HOSTS !!!

Module has the following rough logic flow
1) Import hosts/tcpports/cves/os from qualys file
2) From the above, parse out CVEs which do not exist in CANVAS and are not remotes
3) For the remaining set of hosts which have remote vulns included in CANVAS, exploit those hosts
4) Print out a csv: date/time, host, cve, canvas_mod_name, worked?

"""

VERSION                        = "0.1"

PROPERTY                       = {}
PROPERTY['TYPE']               = "ImportExport"
PROPERTY['SITE']               = "Local"


class infoClass():
    #
    # Each unique hosts gets a class instatiated to it that keeps track of useful stuff
    def __init__(self):
        self.fqdn         = ""
        self.cves         = []     # ["cve1", "cve2", ...]
        self.ignored_cves = [] # ["cve1", "cve2", ...] cve's we're ignoring because we have no exploits for them
        self.tcpPorts     = [] # [int(port1), int(port2), ...]
        self.os           = ""       # String of the OS found by Qualys
        self.results      = {} # {cve : [Time_Completed, Succeded/Failed, Reason]} Did this exploit work? When did it work?

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name         = NAME
        self.csvfilename  = ""
        self.autoexploit  = False

    def getargs(self):
        self.csvfilename = self.argsDict.get("source", self.csvfilename)
        self.autoexploit = self.argsDict.get("autoexploit", self.autoexploit)
        self.log("Got csv file name of %s" % (self.csvfilename))

    def getCVEList(self):
        """
        Create a dictionary where we link CVE Numbers to CANVAS module instances
        """
        self.log("Finding CVEs for all installed modules...")
        canvasengine.registerAllModules()
        exploitmods_old = canvasengine.exploitmodsGet(False)
        bunkList = ["N/A", '', 'Unknown' , 'Unkown', 'None', 'None/SilentlyPatched']
        cveDict = {} # {str(CVE-Num): module Instance}
        skipList = 0
        for key in exploitmods_old.keys():
            try:
                exploitmods_old[key].DOCUMENTATION["CVE Name"]
                if exploitmods_old[key].DOCUMENTATION["CVE Name"] not in bunkList and exploitmods_old[key].PROPERTY['SITE']=='Remote':
                    # If it has a legitimate CVE number and it is a remote
                    cveDict[exploitmods_old[key].DOCUMENTATION["CVE Name"]] = key

            except:
                skipList += 1

        self.log("Found %d remote exploit modules with CVEs, skipped %d non-applicable modules"%(len(cveDict), skipList))
        return cveDict, exploitmods_old


    def parseCSV(self, dataList, offsetDict):
        """
        Parse out all the info we want from dataList return it in an ordered masterDict
        We're using the values from offsetDict to know where the fields we want are in our row
        offsetDict = { str(Knowledge Item) : int(field number) } i.e. {"FQDN": 7}
        """
        masterDict = {} # "hostIP" : infoClass
        self.setInfo("Parsing CSV File")
        self.log("Parsing CSV File...")

        # Populate a dictionary from our CSV file
        # dataList is readlined() from our CSV file
        
        for row in dataList:
            try:
                ip = row[0]
                if inet_aton(ip):
                    if ip not in masterDict: masterDict[ip] = infoClass()
            except:
                pass

        # Grab everything we want
        for row in dataList:
            try:
                if row[0] in masterDict.keys():
                    # If the first field on this line of the file == an IO
                    if masterDict[row[0]].fqdn == "" and row[offsetDict["FQDN"]] != "":
                        # If we don't know this value already and the value in the imported report isn't blank
                        masterDict[row[0]].fqdn = row[offsetDict["FQDN"]]
                    if masterDict[row[0]].os == "" and row[offsetDict["OS"]] != "":
                        # Same process as FQDN
                        masterDict[row[0]].os = row[offsetDict["OS"]]
                    # Sometimes we have to deal with multiple CVEs in one line, so split them out
                    temp = row[offsetDict["CVE"]].split(",")
                    for CVE in temp:
                        # Add all the CVEs from our list if we don't already know about them
                        if CVE not in masterDict[row[0]].cves:
                            masterDict[row[0]].cves.append(CVE)
                    if row[offsetDict["Port"]] != "" and  row[offsetDict["Proto"]] == "tcp":
                        # Sometimes we deal with weird stuff where TCP is set but Port is not
                        if int(row[offsetDict["Port"]]) not in masterDict[row[0]].tcpPorts:
                            # If we don't know about this TCP port already, add it
                            masterDict[row[0]].tcpPorts.append(int(row[offsetDict["Port"]]))
            except:
                pass
        #
        # Sort TCP Port Numbers right quicklike
        for host in masterDict:
            masterDict[host].tcpPorts.sort()
                
        self.log("Parse complete...")    
        self.setProgress(40)
        return masterDict

    def cullCVEFromDict(self, masterDict, cveDict):
        """
        Supply both the masterDict and the cveDict, return only CVE's in both
        """
        self.log("Culling CVEs not in CANVAS...")

        # Find all the CVE's we want to remove
        for host in masterDict:
            for cve in masterDict[host].cves:
                if cve not in cveDict.keys():
                    masterDict[host].ignored_cves.append(cve)
                    
        # Remove them
        for host in masterDict:
            for cve in masterDict[host].ignored_cves:
                masterDict[host].cves.remove(cve)

        self.setProgress(60)
        for host in masterDict:
            cves = masterDict[host].cves
            exploits = map(lambda x: (cveDict[x], x), cves)
            if cves: self.log('Host %s vulnerable to (exploit, CVEName): %s' % (host, repr(exploits)))
                         
        return masterDict

    def outputInfoIntoGUI(self, masterDict):
        """
        Add the info from masterDict to the CANVAS gui
        """
        self.log("Transfering information into GUI...")
        if len(masterDict.keys()) >= 200:
            self.log("Found greater than 200 hosts, importing may take a few moments")

        self.setInfo("Importing host information")
        node = self.argsDict["passednodes"][0]

        for host in masterDict.keys():
            newhost = node.new_host(host)
            portString = ""
            cveString = ""
            guiCount = 0 # Needed for the CANVAS GUI due to field length limits

            #
            # Add TCP Ports
            if len(masterDict[host].tcpPorts) > 0:
                for port in masterDict[host].tcpPorts:
                    if len(portString) + len(str(port)) >= 25:
                        newhost.add_to_knowledge(("TCPPorts%d"%guiCount), "%s"%portString)
                        portString = "" + str(port)
                        guiFlag = True
                        guiCount += 1
                    else:
                        portString += " " + str(port)
                        guiFlag = False
                if not guiFlag:
                    newhost.add_to_knowledge(("TCPPorts%d"%guiCount), "%s"%portString)
            else:
                newhost.add_to_knowledge("TCPPorts", "Qualys found no open ports")

            #
            # Add CVEs
            guiCount = 0
            if len(masterDict[host].cves) > 0:
                for cve in masterDict[host].cves:
                    if (len(cveString) + len(cve)) >= 50:
                        newhost.add_to_knowledge(("CVE%d:"%guiCount), "%s"%cveString)
                        cveString = "" + cve
                        guiFlag = True
                        guiCount += 1
                    else:
                        cveString += " " + cve
                        guiFlag = False
                if not guiFlag:
                    newhost.add_to_knowledge(("CVE%d:"%guiCount), "%s"%cveString)
            else:
                newhost.add_to_knowledge("CVE:", "None Found")


            # Pull in FQDN, we want to leave OS blank so CANVAS will determine the OS
            # Rather than translating between Qualys OS strings and CANVAS OS strings
            if masterDict[host].fqdn != "":
                newhost.add_to_knowledge("FQDN", masterDict[host].fqdn)
            else:
                newhost.add_to_knowledge("FQDN", "FQDN was Unresolved by Qualys")
        self.setProgress(80)
        return

    def findOffsets(self, dataList):
        """
         Automagically find the right column offsets in the .csv file
        7th row of the .csv file is always where columns are defined
        """
        offsetDict = {} # { columname : int(offset) }
        for offset in xrange(0, len(dataList[7])):
            # These are the fields we want, find their position and return it
            # Customers can specify their own fields so it makes sense to dynamically find this
            if dataList[7][offset] == "OS":
                offsetDict["OS"] = offset
            elif dataList[7][offset] == "FQDN":
                offsetDict["FQDN"] = offset
            elif dataList[7][offset] == "Port":
                offsetDict["Port"] = offset
            elif dataList[7][offset] == "Protocol":
                offsetDict["Proto"] = offset
            elif dataList[7][offset] == "CVE ID":
                offsetDict["CVE"] = offset

        for field in ["OS", "FQDN", "Port", "Proto", "CVE"]:
            # We require these fields
            if field not in offsetDict.keys():
                result = False
                return offsetDict, result, field
        return offsetDict, True, 0


    def makeCSV(self, masterDict):
        """
        Pull data out of masterDict[host_ip].results and format it for CSV output
        """
        resultsCSV = []
        resultsCSV.append(
"""
# Verified QualysGuard Results
# Provided by CANVAS v%s
Time Completed, IP, FQDN, CVE, Result, Reason
        """%canvasengine.CanvasConfig["version"])
        for host in masterDict.keys():
            if len(masterDict[host].results) > 0:
                for cve in masterDict[host].results.keys():
                    # time_completed, host, cve, succeded/failed, reason
                    resultsCSV.append(
"""
%s,%s,%s,%s,%s,%s"""%(
                        masterDict[host].results[cve][0], 
                        host, 
                        cve, 
                        masterDict[host].fqdn, 
                        masterDict[host].results[cve][1], 
                        masterDict[host].results[cve][2]))
        return resultsCSV

    def outputCSV(self, resultsCSV):
        """
        Write out the CSV to the file system
        """
        resultsCSV.append("\n")
        dirName = self.savepath = self.output(subdir="qgverify")
        fileName = self.csvfilename + "_verifyResults_%d.csv"%int(time.time())
        fd = open(os.path.join(dirName, fileName), 'wb')
        for line in resultsCSV:
            fd.write(line)
        fd.close()
        self.log("Wrote CSV file to %s"%(os.path.join(dirName, fileName)))
        return 1

    def usage(self):
        print "="*10
        print "This module verifies vulnerabilities on the remote host by attempting to exploit them"
        print "--Only use this from the CLI for testing purposes--"
        print "Usage: qgverify.py -O source:qualys.csv"
        print "="*10

    def runExploit(self, app):
        """
        run the exploit , including set up the listeners it needs for callbacks
        """       
        #we're single threaded so we can feel free to use this 
        #self.variable for the manager
        ret = self.manager.run()
        #self.exploits.append(app)

        ##Did we succeed in exploiting the box ?
        if isinstance(ret, CANVASNode.CANVASNode) or app.ISucceeded():
            devlog("autohack", "Exploit returned %s"%ret)
            self.log("Finished runExploit in autohack successfully!")
            return ret
        return None

    def setExploit(self, app, app_class, host):
        """
        Handle listeners and other fun stuff. 
        """
        app.argsDict = self.argsDict
        #Primary Node (most likely the LocalNode)
        node=self.argsDict["passednodes"][0]
        app.argsDict["passednodes"] = self.argsDict["passednodes"]
        app.argsDict["port"]= str(app.port)
        app.argsDict["autohack_state"]=self.autohack_state
        app.target = node.new_host(host)

        app.setId(self.engine.getNewListenerId())
        app.engine = self.engine
        app.setLogFunction(self.engine.exploitlog)
        app.setDebugFunction(self.engine.exploitdebuglog)
        app.setInfo(app.getInfo())
        app.setCovertness(self.engine.getCovertness())
        self.manager=exploitmanager(app, self.engine)

        return self.manager

    def verifyVulnerabilities(self, masterDict, cveDict, exploitmods_old):
        """ 
         masterDict {host_ip : infoClass(cveNum)}
         cveDict {cveNum : canvasModule}
         exploitmods_old{canvasModule : module}
         for every host, try the remote exploits we have that match the associated CVE numbers
        """

        for host in masterDict.keys():
            for cveNum in masterDict[host].cves:
                #First thing we do in every loop iteration is check to see if HALT has been called.
                if self.state == self.HALT:
                    self.log("Halting on host %s" % host)
                    return 0

                # Now we have an exploit module for each of the cves
                module = exploitmods_old[cveDict[cveNum]]

                if hasattr(module, "DESCRIPTION"):
                    description = module.DESCRIPTION #save this off
                else:
                    description = cveDict[cveNum]
                
                self.log("Trying %s (%s) " % (description, cveDict[cveNum]))
                
                try:
                    self.set_current_attack_module (module.NAME)
                    app = module.theexploit()
                    app.link(self)
                    manager = self.setExploit(app, module, host)
                    ret = self.runExploit(app)
                
                    if app.ISucceeded():
                        masterDict[host].results[cveNum] = [time.strftime('%x %X %Z'), "Verified", " "]
                    else:
                        masterDict[host].results[cveNum] = [time.strftime('%x %X %Z'), "Not Verified", "No shell returned"]
                except Exception, ex:
                    self.log('Exception while running %s: %s' % (module.NAME, traceback.format_exc()))
                    masterDict[host].results[cveNum] = [time.strftime('%x %X %Z'), "Not Verified", "No shell returned"]

            for cveNum in masterDict[host].ignored_cves:
                masterDict[host].results[cveNum] = [time.strftime('%x %X %Z'), "Not Tested", "No module in CANVAS"]
        csv = self.makeCSV(masterDict)
        return csv

    def run(self):
        dataList = []
        cveDict, exploitmods_old = self.getCVEList() 
        self.getargs()

        #
        # Try to open the file, bail if no good
        if self.csvfilename == "":
            self.log("No csv file specified")
            return 0
        try:
            csvReader = csv.reader(open(self.csvfilename, 'rb'))
        except:
            self.log("Unable to open source file")
            return 0

        self.log("Reading data into list")
        for row in csvReader:
            dataList.append(row)

        if len(dataList) == 0:
            self.log("File appears to be blank, check file...")
            return 0

        self.log("Read file in successfully")
        self.setProgress(20)

        offsetDict, result, field = self.findOffsets(dataList) # Dynamically find the column offsets
        if not result:                                         # Bail if we can't find a field    
            self.log(("Unable to find required field: %s in .csv"%field))
            self.log(("Be sure you include OS, FQDN, Port, Proto and CVE ID in reporting"))
            return 0

        masterDict = self.parseCSV(dataList, offsetDict)       # Pass dataList off for parsing
        masterDict = self.cullCVEFromDict(masterDict, cveDict) # Cull CVEs not in CANVAS
        self.outputInfoIntoGUI(masterDict)                     # Add to the GUI

        if self.autoexploit:
            resultsCSV = self.verifyVulnerabilities(masterDict, cveDict, exploitmods_old)     # Get me shells
            self.outputCSV(resultsCSV)                             # Print me out

        self.setProgress(100)
        self.setInfo("Done")
        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
