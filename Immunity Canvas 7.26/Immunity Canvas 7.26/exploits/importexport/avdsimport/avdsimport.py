#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/ for more information
import sys
if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import canvasengine
from engine import CanvasConfig

import xml.sax
import textwrap

# GUI info
NAME                            = "avdsimport"
DESCRIPTION                     = "Imports data from AVDS XML based reports"
DOCUMENTATION                   = {}
DOCUMENTATION['Vendor']         = "Beyond Security"
DOCUMENTATION['Url']            = "http://www.beyondsecurity.com/avds.html"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION['Usage']          = "Just supply an XML report from AVDS"
DOCUMENTATION['Notes']          = """

Data imported per host (if known):
- ip
- open TCP ports
- open UDP ports
- all CVEs and if appropriate their CANVAS module name

To view the results of the import, right click on your local node
then mouse over the IP of interest and select 'View all knowledge'

Tested with reports generated by: 15.65(Build 3.6.4) (July/2015)
Thanks to: Beyond Security for providing reports for testing

"""

VERSION                         = "0.1"
PROPERTY                        = {}
PROPERTY['TYPE']                = "ImportExport"
PROPERTY['SITE']                = "Local"

class avdsXMLHandler(xml.sax.handler.ContentHandler):
    """
    This class handles all the XML, if you want additional data imported you'll deal with it here
    """
    def __init__(self):
        self.__indata      = False # Use it to toggle the parser telling it we want <tag>this_data</tag>
        self.currentHost   = ""    # Which host are we working on
        self.currentTag    = ""    # Which tag are we working on -- note this doesn't track parent tags at all
        self.testDict      = {}    # testDict[TestId] = "CVE-XXXX-YYYY"
        self.hostVulns     = {}    # hostVulns[IP] = [test1, test2, test3]
        self.debug         = False # Enable if you need to see which tag data came from
        self.refChild      = False # Are we within a <Reference> tag
        self.vulnHostChild = False # Are we within a <VulnerableHost> tag
        self.vulnChild     = False # Are we within a <Vulnerability> tag
        self.hostTcp       = {}    # hostTcp[IP] = [TCP1, TCP2, TCP3]
        self.hostUdp       = {}    # hostUdp[IP] = [UDP1, UDP2, UDP3]
        self.currentTest   = {}
        self.tempPort      = None

    def startElement(self, name, attrs):
        """
        Handle new tags and data in the tag: <tag name="data"></tag>
        """
        self.currentTag = ""

        if name == "Name":
            if self.vulnHostChild:
                self.currentTag = "Name"
                self.__indata   = True

        if name == "Port":
            if self.vulnHostChild:
                self.currentTag = "Port"
                self.__indata   = True

        if name == "Proto":
            if self.vulnHostChild:
                self.currentTag = "Proto"
                self.__indata   = True

        if name == "VulnerableHost":
           self.vulnHostChild = True

        if name == "Vulnerability":
           self.vulnChild = True

        if name == "Reference":
            self.refChild = True
            self.currentTest['TestId'] = 0
            self.currentTest['URI']    = ""

        if name == "TestID":
            if self.refChild == True:
                self.currentTag = "refTestId"
                self.__indata   = True
            if self.vulnHostChild and self.vulnChild:
                self.currentTag = "vulnTestId"
                self.__indata   = True

        if name == 'URI':
            if self.refChild:
                self.currentTag = "refURI"
                self.__indata   = True

        if name == 'Type':
            if self.refChild:
                self.currentTag = 'refType'
                self.__indata   = True

        if name == "vulnerability":
            self.currentVulnId = str(attrs['id']).upper()

    def endElement(self, name):
        """
        Practically we use this to figure out one level deep tag hierarchy
        """
        # The </Reference> logic, tests can have multiple IDs and multiple CVEs :-/
        if name == "Reference":
            self.refChild = False
            if self.currentTest['Type'] == 'CVE':
                if self.debug:
                    print "Adding test: %s with CVE of %s" % (self.currentTest['TestId'], self.currentTest['URI'])
                if self.testDict.has_key(self.currentTest['TestId']):
                    self.testDict[self.currentTest['TestId']].append(self.currentTest['URI'])
                else:
                    self.testDict[self.currentTest['TestId']] = [self.currentTest['URI']]
            self.currentTest['TestId'] = 0
            self.currentTest['URI']    = ""
            self.currentTest['Type']   = ""

        if name == "VulnerableHost":
            if self.debug:
                print "Host %s is vulnerable to test %s" % (self.currentHost, self.currentTest['TestId'])               
            if self.hostVulns.has_key(self.currentHost):
                self.hostVulns[self.currentHost].append(self.currentTest['TestId'])
            else:
                self.hostVulns[self.currentHost] = [self.currentTest['TestId']]
            self.currentTag            = ""
            self.currentHost           = ""
            self.tempPort              = None
            self.vulnHostChild         = False
            self.vulnChild             = False
            self.currentTest['TestId'] = 0

    def characters(self, data):
        """
        Handle data between tags: <tag>data</tag>
        """
        if(self.__indata):
            self.__indata = False

            if (self.debug):
                print '\t\t' + self.currentTag + " - " + repr(data)
            if self.currentTag == "refTestId":
                self.currentTest['TestId'] = data
            if self.currentTag == "vulnTestId":
                self.currentTest['TestId'] = data
            if self.currentTag == "refURI":
                self.currentTest['URI'] = data
            if self.currentTag == 'refType':
                self.currentTest['Type'] = data
            if self.currentTag == "Name" and self.vulnHostChild and not self.vulnChild:
                self.currentHost = data
            if self.currentTag == "Port" and self.vulnHostChild:
                self.tempPort = int(data)
            if self.currentTag == "Proto" and self.vulnHostChild and self.tempPort:
                if data.upper() == "TCP":
                    if self.hostTcp.has_key(self.currentHost) and self.tempPort not in self.hostTcp[self.currentHost]:
                        self.hostTcp[self.currentHost].append(self.tempPort)
                    elif not self.hostTcp.has_key(self.currentHost):
                        self.hostTcp[self.currentHost] = [self.tempPort]
                elif data.upper() == "UDP":
                    if self.hostUdp.has_key(self.currentHost) and self.tempPort not in self.hostUdp[self.currentHost]:
                        self.hostUdp[self.currentHost].append(self.tempPort)
                    elif not self.hostUdp.has_key(self.currentHost):
                        self.hostUdp[self.currentHost] = [self.tempPort]
            else:
                pass

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name       = NAME
        self.filename   = ""
        self.filetype   = ""
        self.debug      = False # Debug
        self.canvasCVE  = {}    # Hold the CVE list
        self.dnsResolve = None  # This will hold the value of dnsresolve from CANVAS config

    def addToKnowledge(self, masterDict):
        """
        Pull the data parsed from the XML file into the CANVAS KB
        """
        node  = self.argsDict["passednodes"][0]
        count = 1
        total = len(masterDict.keys())

        self.dnsResolve = CanvasConfig['dnsresolve']
        self.log_info("Temporarily disabling DNS resolution")
        CanvasConfig['dnsresolve'] = False

        for host in masterDict.keys():
            self.log_info("Adding info from host: %s " % host)
            count  += 1
            newhost = node.new_host(host)


            # Import TCP/UDP ports
            if len(masterDict[host]["tcpPorts"]) == 0:
                newhost.add_to_knowledge("AVDS open TCP Ports", "None")
            else:
                newhost.add_to_knowledge("AVDS open TCP Ports", masterDict[host]["tcpPorts"])

            if len(masterDict[host]["udpPorts"]) == 0:
                newhost.add_to_knowledge("AVDS open UDP Ports", "None")
            else:
                newhost.add_to_knowledge("AVDS open UDP Ports", masterDict[host]["udpPorts"])

            # Import CVEs
            cveList = { "found"    : [],
                        "notfound" : [],
                        "nocve"    : [] }

            for cve in masterDict[host]['cves']:
                if self.canvasCVE.has_key(cve):
                    cveList["found"].append("%s -- CANVAS Module: %s" % (cve, self.canvasCVE[cve]))
                else:
                    cveList["notfound"].append("%s -- Has no corresponding CANVAS module" % cve)

            for line in sorted(cveList['found']):
                heading, module = line.split(" -- ")
                newhost.add_to_knowledge(heading, module)

            for line in sorted(cveList['notfound']):
                heading, error = line.split(" -- ")
                newhost.add_to_knowledge(heading, error)

        # Import has completed   
        self.log_info("Resetting DNS Resolver settings")
        CanvasConfig['dnsresolve'] = self.dnsResolve

        return 0

    def createImports(self, handler):
        """
        The structure of the XML file requires us to correlate everything after parsing
        """
        masterDict  = {} 
        tempCveList = []

        # Handle host -> CVE
        for ip,tests in handler.hostVulns.items():
            masterDict[ip] = {"cves"     : [], 
                              "udpPorts" : [],
                              "tcpPorts" : []}
            for test in tests:
                if handler.testDict.has_key(test):
                    for cve in handler.testDict[test]:
                        if cve not in masterDict[ip]["cves"]:
                            masterDict[ip]['cves'].append(cve)
            if handler.hostTcp.has_key(ip):
                masterDict[ip]["tcpPorts"] = sorted(handler.hostTcp[ip])
            if handler.hostUdp.has_key(ip):
                masterDict[ip]["udpPorts"] = sorted(handler.hostUdp[ip])
        return masterDict

    def parseAvdsXML(self):
        """
        Parses the customer provided AVDS XML report
        The debug info here will be helpful
        """
        parser  = xml.sax.make_parser()
        handler = avdsXMLHandler()
        parser.setContentHandler(handler)

        try:
            with open(self.filename, 'r') as avdsFile:
                parser.parse(avdsFile)
        except IOError as io_err:
            self.log_error(str(io_err))
            return -1

        self.log_info("Done parsing file")
        handler.hostCount = len(handler.hostVulns)
        self.setProgress(40)
        self.log_info("Total hosts found: %d" % handler.hostCount)

        if (handler.hostCount >= 255):
            self.log_info("255 or greater hosts detected, this will take a while to import!")
            self.setInfo("More than 255 hosts found, be patient...")

        masterDict = self.createImports(handler)

        self.addToKnowledge(masterDict)
        return 0

    def fileCheck(self):
        """
        Verify we have a sane file
        """
        try:
            with open(self.filename, 'r') as avdsFile:
                data = avdsFile.read().splitlines()
        except IOError as io_err:
            self.log_error(str(io_err))
            return False

        if "<Report>" in data[0]:
            # Annoyingly there's nothing else in the sample file to key off of :-/
            return True

        return False

    def getCVEList(self):
        """
        Return a dict where {cve number : module name}
        """
        canvasengine.registerAllModules()
        exploitmods_old = canvasengine.exploitmodsGet(False)
        bunkList        = ["N/A", '', 'Unknown' , 'Unkown', 'None', 'None/SilentlyPatched']
        cveDict         = {}
        skipList        = 0

        for key in exploitmods_old.keys():
            try:
                exploitmods_old[key].DOCUMENTATION["CVE Name"]
                if exploitmods_old[key].DOCUMENTATION["CVE Name"] not in bunkList:
                    cveDict[exploitmods_old[key].DOCUMENTATION["CVE Name"]] = key
            except:
                skipList += 1
        self.log_info("Found %d modules with CVEs, skipped %d" % (len(cveDict), skipList))
        return cveDict

    def run(self):
        self.filename = self.argsDict.get("source", self.filename)
        if self.filename == "":
            self.log_error("No filename provided")
            return -1
        if not self.fileCheck():
            # Bad file
            return -1

        self.log_info("Generating list of CANVAS CVEs...")
        self.setInfo("Generating list of CANVAS CVEs...")
        self.canvasCVE = self.getCVEList()
        self.setProgress(20)
        self.log_info("Done generating CVE list")
        self.log_info("Importing AVDS results from %s into CANVAS" % self.filename)
        self.parseAvdsXML()

        self.log_info("Module: avdsimport finished")
        self.setProgress(100)
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
