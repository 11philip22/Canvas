#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

"""
autoassess.py

Be to VulnAssess what autohack is to massattack   
"""
##TODO - output some stuff !!!

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


VERSION="1.0"
NOTES2="""
Only called via Vulnassess2.py, NOT available through the GUI as yet. Modules runs but does not display any data when invoked outside of VulnAssess2.
"""

DOCUMENTATION={}
DOCUMENTATION["NOTES"]=NOTES2

CHANGELOG="""
1.0 
Created. 28/11/08 Rich
"""

DEBUGNOTES="""
"""

PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

import sys
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import libs.canvasos as canvasos
from engine.config import canvas_resources_directory
import thread
lock=thread.allocate_lock()

DOCUMENTATION={}
DOCUMENTATION["Notes"]="TODO"


NAME="AutoAssess"
DESCRIPTION="Assess the exposure of a given box"

VERSION="0.1"

NOTES=""" 
"""

CHANGELOG="""
"""
class AutoAssesError(Exception): 
    pass

UNKNOWN = 0
WIN     = 1
UNIX    = 2

# set the SCAN version here

class null_report:
    """
    Useless report holder to supress errors
    """
    def note(self, arg, arg2):
        pass

    def newhost(self, arg):
        pass



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME        
        self.setPort(0)
        self.setHost("")
        self.setVersion(0)
        self.istest=0
        self.setVersions()
        self.localhost=""
        self.localport=0
        self.force=0
        self.progress=0
        self.setVersions()

        self.netmask="32"
        self.result=[] #list of (host,vuln) used to own it
        self.portlow=1
        self.porthigh=1100
        self.portscantype="fast"
        self.called_from_ThreadRunner2 = False
        self.portscan=1 #default to DO a portscan
        self.do_testhost=False #should we run testhost (default is NO, instead we run a list of preselected recon modules)
        self.passive_detector=None 
        self.traceroute=True # Toggle traceroute, added at customer request
        self.whereami=True # Same request as above
        self.silica=False
        self.ssid=self.tpref=""

    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatically determine version type",UNKNOWN)
        self.versions[1]=("Windows NT SP6A",WIN)
        self.versions[2]=("Windows 2000 SP1", WIN)
        self.versions[3]=("Windows 2000 SP2",WIN)
        self.versions[4]=("Windows 2000 SP3",WIN)
        self.versions[5]=("Windows 2000 SP4",WIN)
        self.versions[6]=("Windows XP SP1",WIN)
        self.versions[7]=("Windows XP SP2",WIN)
        self.versions[8]=("Windows Server 2003" ,WIN)
        self.versions[9]=("Linux",UNIX)
        self.versions[10]=("Mandrake Linux",UNIX)
        self.versions[11]=("Suse Linux", UNIX)
        self.versions[12]=("Red Hat Linux", UNIX)
        self.versions[13]=("Debian Linux", UNIX)
        self.versions[14]=("Solaris 2.6", UNIX)
        self.versions[15]=("Solaris 7", UNIX)
        self.versions[16]=("Solaris 8", UNIX)
        return 


    def run_on_host(self,target):
        """ 
            run on each IP 
            """
        host=target.interface

        self.log("Running on %s"%host)
        self.setInfo("Running on %s"%host)

        try:
            app=self.engine.getModuleExploit("osdetect")
            app.link(self)
            app.target=target
            self.set_current_attack_module("osdetect")
            ret=app.run()
            if ret:
                app.setProgress(100)
            else:
                app.setProgress(-1)
            myos=app.result
        except:
            import traceback
            traceback.print_exc(file=sys.__stdout__)
            self.log("Not determining OS - use osdetect exploit module")
            myos=canvasos.new("Unknown")


        target.add_knowledge("OS", myos,100)
        if self.portscan:
            self.set_current_attack_module("portscan")
            results=self.exploitnodes("portscan",target=target,
                                      args={"mode" : "portrange", "portlow": self.portlow, "porthigh": self.porthigh})
            results=results[0]
        else:
            results=[]
            self.log("Portscan not requested by user")
        try:
            basename=myos.basename()
        except:
            #if it's a string, take the first word
            #it should NOT be a string. So fix this too.
            devlog("osdetect", "Bug in osdetect that returned %s"%myos)
            basename=str(myos).split(" ")[0]


        self.log("Base OS for ip %s: %s"%(target.interface,basename))
        self.log("Open ports on host %s: %s"%(target.interface,results))

        #sometimes Unix has this too...(think samba)
        lanman=target.get_knowledge("Lanman",None)
        smbdomain=target.get_knowledge("SMBDomain",None)
        smbserver=target.get_knowledge("SMBServer",None)
        shareenum=target.get_knowledge("SMBShares",None)
        language=target.get_knowledge("Language", None)
        
        #we also want a PrintProvider list 
        printproviders=target.get_knowledge("PrintProviders",None)

        if self.do_testhost:
            self.log("Running testhost against it")
            result=self.exploitnodes("testhost")[0]

        #scanmodnames=file(os.path.join(canvas_resources_directory,"vulnassess.txt"),"rb").readlines()
        #scanmodnames=map(str.strip,scanmodnames)

        ##TODO - Fix so that we aren't reading a static file at all and then we can get rid of this
        ##   when used with VulnAssess2 the file is read once for all threads not once in each thread
        try:
            scanmods = canvasengine.getModules(self.exploit_modules)
        except AttributeError:
            fd=open(os.path.join(canvas_resources_directory,"vulnassess.txt"),"rb")
            self.exploit_modules=fd.readlines()
            fd.close()
            scanmods=map(str.strip,self.exploit_modules)			

        totalmods=len(scanmods)
        currentmod=1        
        self.log("Vulnerability assessment has %d modules loaded total"%totalmods)
        for module in scanmods:

            if self.state==self.HALT:
                self.log("Halted - not continuing scan")
                return 0

            self.set_current_attack_module(module)

            try:
                self.log("Property = %s Basename=%s"%(module.PROPERTY["ARCH"],basename))
                found=0
                for prop in module.PROPERTY["ARCH"]:
                    if prop[0]==basename:
                        found=1
                if not found:
                    continue
            except:
                #no property in module
                continue

            try:
                astr="Scanning with %s"%module.DESCRIPTION
            except:
                try:
                    print "Could not find a description in %s"%module.NAME
                    astr=module.NAME
                except:
                    print "Error: Module has no name?"
            self.log(astr)
            #debug
            print astr
            progress=round((currentmod*100)/totalmods)
            #print "CurrentMod %d Total Modules: %d Progress %d"%(currentmod,totalmods,progress)
            self.setProgress(progress)
            currentmod+=1
            try:
                app=module.theexploit()
            except:
                try:
                    mystr="No theexploit class in module %s"%module.DESCRIPTION
                except:
                    mystr="No theexploit class in module!"
                self.log(mystr)
                continue
            app.link(self)

            #set the defaults for exploits not using correct syntax
            defaultlist=["port","user","password","filename"]
            for i in defaultlist:
                if i in dir(app):
                    #print "FOUND: %s"%i
                    app.argsDict[i]=getattr(app,i)

            app.argsDict["passednodes"]=self.argsDict["passednodes"]
            defaultlist=["user","password","filename"]
            for i in defaultlist:
                if i in self.argsDict:
                    app.argsDict[i]=self.argsDict[i]
            app.argsDict["netmask"]="32"
            app.target=target

            #print "ArgsDict=%s"%app.argsDict
            try:
                ret=app.run()
                if ret:
                    app.setProgress(100)
                else:
                    app.setProgress(-1)
                if app.result:
                    result=app.result
                    #convert these to a string if they are a list of objects like dcedump is
                    if isinstance(result , list):
                        result=map(str, result) 
            except:
                self.log("Run returned exception: fix this.")
                import traceback
                traceback.print_exc(file=sys.stdout)
        return

    def getargs(self):
        self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).replace("/",""))
        self.host=self.target.interface
        self.portscan=int(self.argsDict.get("portscan", self.portscan))
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.getarg("do_testhost") #if we want testhost
        # Added for customer requests
        if bool(self.argsDict.get("traceroute", self.traceroute)) == False:
            self.traceroute = True
        else:
            self.traceroute = False

        if bool(self.argsDict.get("whereami", self.whereami)) == False:
            self.whereami = True
        else:
            self.whereami = False
        #silica vars
        self.ssid=self.argsDict.get("ssid", "")
        self.silica=self.argsDict.get("silica",self.silica)
        self.tpref=self.argsDict.get("tpref",self.tpref)
        return

    def run(self):
        self.getargs()        
        self.log("Netmask=%s"%self.netmask)

        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()        

        ret=self.run_on_all_alive_hosts()
        if not self.called_from_ThreadRunner2:
            self.log("Autoassess report:")
            for host, vuln, newnode in self.result:
                self.log("Used %s on %s"%(vuln,host.interface))
                self.usedvuln=vuln
            self.log("End of autoassess report")
        else:
            self.log("Autoassess finished, returning to Vulnassess2..")
        return ret 

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])



#this stuff happens.
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

