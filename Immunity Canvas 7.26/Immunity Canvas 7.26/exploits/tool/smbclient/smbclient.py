#! /usr/bin/env python
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2008
#
# http://www.immunityinc.com/CANVAS/ for more information

"""
smbclient.py
Starts up a file listener that uses this exploit as a client into a MS network
"""

import socket
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from encoder import *
from tcpexploit import tcpexploit
from SMBNode import SMBNode

from MOSDEFShellServer.SMB import SMBShellServer
from libs.newsmb.libsmb import SMBClient, SMBClientException
import libs.kerberos.ccache as cc

NAME                   = "smbclient"
VERSION                = "1.0"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

Will attempt to connect to an SMB File Share. Then from there, upload and
download and dir modules can be used on that share.

"""

PROPERTY                     = {}
VERSION                      = "1.0"
DESCRIPTION                  = "smbclient"
DOCUMENTATION['Date public'] = "10/10/2010"
DOCUMENTATION['Notes']       = "An SMB client"
PROPERTY['TYPE']             = "Tools"
PROPERTY['SITE']             = "Remote"
PROPERTY['ARCH']             = [ ["Windows"] ]
PROPERTY['VERSION']          = [ "2000", "XP", "2003", "Vista", "7", "2008" ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.filename     = u'C$'
        self.domain       = ''
        self.host         = ""
        self.port         = 445
        self.version      = 0
        self.user         = u'Administrator'
        self.name         = NAME
        self.ccache_file  = None
        self.use_kerberos = False

    def getargs(self):
        self.host        = self.target.interface
        self.user        = self.argsDict.get("user", self.user)
        self.password    = self.argsDict.get("password", self.password)
        self.filename    = self.argsDict.get("filename", self.filename)
        self.domain      = self.argsDict.get("domain", self.domain)
        self.port        = int(self.argsDict.get("port", self.port))
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)

    def getsocket(self):
        if ':' in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()

    def test(self):
        """
        Connect to the target and spawn a vfs-shell if we get a connection
        """
        self.getargs()
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running" %\
                    (NAME, self.host, self.port, self.covertness))

        s = self.getsocket()
        sockaddr = (self.host, self.port)

        try:
            s.connect(sockaddr)
        except:
            self.log('Could not connect to %s:%d' % sockaddr)
            return 0

        self.log_info(u"Using domain=%s user=%s, password %s" % (self.domain, self.user, self.password))
        smbobj = SMBClient(s, username=self.user, password=self.password, domain=self.domain)
        smbobj.is_unicode = True

        try:
            smbobj.negotiate()
            smbobj.session_setup()
            self.log_info("Trying treeconnect_AndX on share %s" % self.filename)
            smbobj.tree_connect(self.filename)
            self.log_info("Connected to share %s" % self.filename)
        except SMBClientException, ex:
            self.log_error('Error during SMB operations: %s' % ex)
            return 0

        try:
            smbobj.logoff()
        except:
            pass

        return 1


    def check_ccache_file(self):
        try:

            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def run(self):
        """
        Connect to the target and spawn a vfs-shell if we get a connection
        """
        self.result = []
        self.getargs()

        self.log_info("%s running against %s:%d covertness: %d" %\
                (NAME, self.host, self.port, self.covertness))
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running" %\
                (NAME, self.host, self.port, self.covertness))
        self.log_info(u"Using domain=%s user=%s, password %s" %\
                (self.domain, self.user, self.password))

        # Sanity check: the ccache credentials
        if self.ccache_file:
            if not self.check_ccache_file():
                self.log_error('%s doesn\'t seem to be a valid ccache file for user %s' % (self.ccache_file, '@'.join([self.user,self.domain])))
                return 0
            else:
                self.use_kerberos = True
                self.log_info("Using kerberos authentication with credentials %s" % self.ccache_file)
        else:
            self.log_info("Using NTLM authentication")

        connected = False

        for p in set([self.port, 445]):
            s = self.getsocket()
            sockaddr = (self.host, p)
            try:
                s.connect(sockaddr)
                connected = True
                self.port = p
                break
            except:
                self.log_error("Could not connect to %s:%d" % sockaddr)

        if not connected:
            return 0

        retry = False

        if self.use_kerberos:
            smbobj = SMBClient(s, self.user, self.password, self.domain, kerberos_db=self.ccache_file, use_krb5=True)
        else:
            smbobj = SMBClient(s, self.user, self.password, self.domain)

        try:
            smbobj.negotiate()
            smbobj.session_setup()
        except SMBClientException, ex:
            self.log_error('Error during SMB session setup: %s' % ex)
            retry = True

        if retry == False:
            self.nlog("Successfully connected to %s:%d" % (self.host, self.port))
            self.log_info(u"Trying treeconnect_AndX on share %s" % self.filename)
            try:
                smbobj.tree_connect(self.filename)
            except SMBClientException, ex:
                self.log_error(u'treeconnect_AndX on share %s failed: %s' % (self.filename, ex))
                retry = True

        if retry:
            if self.port != 445:
                self.log_info('Retrying with port 445')
                self.port = 445
                try:
                    s = self.getsocket()
                    sockaddr = (self.host, self.port)
                    s.connect(sockaddr)
                except:
                    return 0

                if self.use_kerberos:
                    smbobj = SMBClient(s, username=self.user,
                                       password=self.password,
                                       domain=self.domain,
                                       kerberos_db=self.ccache_file,
                                       use_krb5=True)
                else:
                    smbobj = SMBClient(s, username=self.user,
                                       password=self.password,
                                       domain=self.domain)

                try:
                    smbobj.negotiate()
                    smbobj.session_setup()
                    smbobj.tree_connect(self.filename)
                except SMBClientException, ex:
                    self.log_error(u'Failed to connect to share: %s' % ex)
                    return 0
            else:
                self.log_info('Exhausted retry options, could not connect to share!')
                return 0

        self.log(u"Connected to share %s" % self.filename)

        try:
            smbobj.check_directory(u'\\')
            self.log_info("Checkdirectory \\ passed...")
            self.log_info("Directory listings enabled")
        except SMBClientException, ex:
            self.log_info("Do not have permissions to check directory on share: %s" % ex)
            self.log_info("Directory listings disabled")

        node            = SMBNode(self.host)
        node.parentnode = self.argsDict["passednodes"][0]
        newshell        = SMBShellServer(smbobj, node, self.host, self.logfunction)
        self.setInfo("%s attacking %s:%d (Covertness:%d) - done" %\
                     (NAME, self.host, self.port, self.covertness))
        self.result = [node]
        return node

    def displayVersions(self):
        print "0 - SMBClient v1.0"

if __name__ == '__main__':
    print "Running CANVAS " + NAME + " version " + VERSION
    app         = theexploit()
    ret         = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
