#! /usr/bin/env python

#we need to display a nice little mini icon of the screen in the CANVAS gui! (kinda
#like VMware does...) PyGTK has support for raw data like this, if we want to use
#their routines

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import uuid

from exploitutils import *
from internal import *
from canvaserror import *

from ExploitTypes.localcommand import LocalCommand

NAME                   = "wlanlist"
DESCRIPTION            = "Lists the wireless networks on a given node"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
"""

VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['SITE']       = "Local"
PROPERTY['TYPE']       = "Commands"
PROPERTY['ARCH']       = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """ 

This module will list information about all wireless networks for a given node.

The information listed is
+ ESSID
+ Signal Quality
+ Security Type
+ Authentication Type
+ Cipher Algorithm

Currently, this module only works on win32 nodes.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.node   = None
        self.result = []
        self.name   = NAME
    
    def auth_algo(self, number):
        if number == 1:
            return "802.11 OPEN"
        elif number == 2:
            return "802.11 SHARED KEY"
        elif number == 3:
            return "WPA"
        elif number == 4:
            return "WPA_PSK"
        elif number == 5:
            return "WPA_NONE"
        elif number == 6:
            return "RSNA"
        elif number == 7:
            return "RSNA_PSK"
        else:
            return "Unknown algorithm!"
        
    def ciph_algo(self, number):
        if number == 0:
            return "NONE"
        elif number == 1:
            return "WEP with a 40-bit cipher key"
        elif number == 2:
            return "TKIP"
        elif number == 4:
            return "AES-CCMP"
        elif number == 5:
            return "WEP with a 104-bit cipher key"
        elif number == 256:
            return "WPA use group key cipher suite"
        elif number == 257:
            return "WEP with any length key"
        else:
            return "Unknown algorithm!"
        
    def WlanOpenHandle(self, node, dwClientVersion=2):
        code = """
        #import "IMPORT_TYPE", "wlanapi.dll|WlanOpenHandle" as "WlanOpenHandle"
        #import "IMPORT_TYPE", "kernel32.dll|GetLastError" as "GetLastError"
        
        #import "local", "sendint" as "sendint"
        #import "int", "dwClientVersion" as "dwClientVersion"
        
        void main()
        {
            int ret;
            int pdwNegotiatedVersion;
            int phClientHandle;
            int error;
            
            phClientHandle = 0;
            ret = WlanOpenHandle(dwClientVersion, NULL, &pdwNegotiatedVersion, &phClientHandle);
            error = GetLastError();
            sendint(ret);
            if (ret != 0) {
                sendint(error);
            }
            else {
                sendint(phClientHandle);
            }
        }
        """
        vars = {}
        vars["dwClientVersion"] = dwClientVersion
        code = code.replace('IMPORT_TYPE', 'local' if node.nodetype == "win64Node" else "remote")
        ret = node.shell.runCode(code, vars)
        if ret != 0:
            err = node.shell.readint()
            success = False
            return err, success
        response = node.shell.readint()
        self.log('handle: %d' % response)
        success = True
        return response, success
    
    def WlanEnumInterfaces(self, hClientHandle, node):
        """
        Enumarate all interfaces of wireless
        """        
        code = """
        #import "IMPORT_TYPE", "wlanapi.dll|WlanEnumInterfaces" as "WlanEnumInterfaces"
        #import "IMPORT_TYPE", "kernel32.dll|GetLastError" as "GetLastError"
        
        #import "local", "sendint" as "sendint"
        #import "local", "sendstring" as "sendstring"
        #import "local", "sendunistring2self" as "sendunistring2self"
        #import "local", "senddata2self" as "senddata2self"
        #import "int", "hClientHandle" as "hClientHandle"
        
        struct GUID {
            char data[16];
        };
        
        struct WLAN_INTERFACE_INFO {
            struct GUID InterfaceGuid;
            char strInterfaceDescription[512];
            int isState;
        };
        
        struct WLAN_INTERFACE_INFO_LIST {
            unsigned int dwNumberOfItems;
            unsigned int dwIndex;
            struct WLAN_INTERFACE_INFO InterfaceInfo;
        };
        
        void main(){
            int ret;
            int error;
            int i;
            char * p;
            struct GUID * guid;
            struct WLAN_INTERFACE_INFO * ppInterface;
            struct WLAN_INTERFACE_INFO_LIST * ppInterfaceList;
            
            sendint(hClientHandle);
            
            ret = WlanEnumInterfaces(hClientHandle, NULL, &ppInterfaceList);
            error = GetLastError();
            sendint(ret);
            if (ret != 0) {
                sendint(error);
            }
            else {
                i = 0;
                ppInterfaceList->dwIndex = 0;
                sendint(ppInterfaceList->dwNumberOfItems);
                sendint(ppInterfaceList->dwIndex);
                
                // XXX: do manual offsetting to bypass MOSDEF struct headaches
                ppInterface = ppInterfaceList->InterfaceInfo;
                while (i < ppInterfaceList->dwNumberOfItems) {
                    sendunistring2self(ppInterface->strInterfaceDescription);
                    guid = ppInterface->InterfaceGuid;
                    senddata2self(guid->data, 16);
                    i = i+1;
                    // to prevent cast index mismatches
                    p = ppInterface;
                    ppInterface = p + 532; // sizeof(struct WLAN_INTERFACE_INFO)
                }
            }
        }
        """
        vars = {}
        vars["hClientHandle"] = hClientHandle
        code = code.replace('IMPORT_TYPE', 'local' if node.nodetype == "win64Node" else "remote")
        hand = node.shell.runCode(code, vars)
        ret = node.shell.readint()
                
        if ret != 0:
            value = node.shell.readint()
            self.log("Error: %d"%value)
        else:
            value = []
            num = node.shell.readint() # Number of Interfaces
            self.log('Number of interfaces: %d' % num)
            
            if num == 0:
                self.log("Remote end doesnt have any wireless interface\n")
                return value
            
            num2 = node.shell.readint() # index

            for i in range(0, num):
                desc = node.shell.read_uni_string() # Desciption
                self.log("description: %s"%desc)
                guid = uuid.UUID(bytes=node.shell.readblock())
                
                print_guid = str(guid).split("-")
                data1 = ''
                for char in intel_order(int(print_guid[0],16)):
                    char = hex(ord(char))
                    if char != '0x0':
                        data1 += char[2:]
                
                data2 = ''
                for char in intel_order(int(print_guid[1], 16)):
                    char = hex(ord(char))
                    if char != '0x0':
                        data2 += char[2:]
                    
                data3 = ''
                for char in intel_order(int(print_guid[2], 16)):
                    char = hex(ord(char))
                    if char != '0x0':
                        data3 += char[2:]                    
                    
                data4 = print_guid[3] + '-' + print_guid[4]
                
                print_guid = '{%s-%s-%s-%s}'%(data1, data2, data3, data4)
                
                self.log("GUID: %s"%print_guid)
                
                value.append((str(guid),print_guid))
        return value
    
    def WlanGetAvailableNetworkList(self, handler, guid, node, dwFlags=1):
        """
        Enumerate all available networks for a given guid wireless
        """
        code = """
        #import "IMPORT_TYPE", "wlanapi.dll|WlanGetAvailableNetworkList" as "WlanGetAvailableNetworkList"
        #import "IMPORT_TYPE", "kernel32.dll|GetLastError" as "GetLastError"
        
        #import "local", "sendint" as "sendint"
        #import "local", "sendstring" as "sendstring"
        #import "local", "sendunistring2self" as "sendunistring2self"
        #import "local", "senddata2self" as "senddata2self"
        #import "local", "malloc" as "malloc"
        #import "local", "memcpy" as "memcpy"
        #import "int", "handler" as "handler"
        #import "string", "rawguid" as "rawguid"
        #import "int", "dwFlags" as "dwFlags"
        
        struct GUID {
            char data[16];
        };
        
        struct DOT11_SSID {
            int uSSIDLength;
            char ucSSID[32];
        };
        
        struct WLAN_AVAILABLE_NETWORK {
            char strProfileName[512];
            struct DOT11_SSID dot11Ssid;
            int dot11BssType;
            int uNumberOfBssids;
            int bNetworkConnectable;
            int wlanNotConnectableReason;
            int uNumberOfPhyTypes;
            int dot11PhyTypes[8];
            int bMorePhyTypes;
            int wlanSignalQuality;
            int bSecurityEnabled;
            int dot11DefaultAuthAlgorithm;
            int dot11DefaultCipherAlgorithm;
            int dwFlags;
            int dwReserved;        
        };
        
        struct WLAN_AVAILABLE_NETWORK_LIST {
            int dwNumberOfItems;
            int dwIndex;
            struct WLAN_AVAILABLE_NETWORK Network;        
        };
        
        void main() {
            int ret;
            int error;
            char * p;
            int i;
            struct GUID guid;
            struct DOT11_SSID *pDot11Ssid;
            struct WLAN_AVAILABLE_NETWORK * availableNetwork;
            struct WLAN_AVAILABLE_NETWORK_LIST * ppAvailableNetworkList;
            
            memcpy(guid.data, rawguid, 16);
            ret = WlanGetAvailableNetworkList(handler, &guid, dwFlags, NULL, &ppAvailableNetworkList);
            
            error = GetLastError();
            sendint(ret);
            if (ret != 0){
                sendint(error);
            }
            else {
                i = 0;
                sendint(ppAvailableNetworkList->dwNumberOfItems);
                availableNetwork = ppAvailableNetworkList->Network;
                while (i < ppAvailableNetworkList->dwNumberOfItems) {
                    pDot11Ssid = availableNetwork->dot11Ssid;
                    senddata2self(pDot11Ssid->ucSSID, pDot11Ssid->uSSIDLength);
                    sendint(availableNetwork->wlanSignalQuality);
                    sendint(availableNetwork->bNetworkConnectable);
                    sendint(availableNetwork->bSecurityEnabled);
                    sendint(availableNetwork->dot11DefaultAuthAlgorithm);
                    sendint(availableNetwork->dot11DefaultCipherAlgorithm);
                    p = availableNetwork;
                    p = p + 628;
                    availableNetwork = p;
                    i = i + 1;
                }
            }
        }
        
        """
        vars = {}
        vars["handler"] = handler
        vars["rawguid"] = uuid.UUID(guid).bytes
        vars["dwFlags"] = dwFlags
        code = code.replace('IMPORT_TYPE', 'local' if node.nodetype == "win64Node" else "remote")
        ret = node.shell.runCode(code, vars)
        if ret != 0:
            value = node.shell.readint()
            self.log("Error: %d\n"%value)
        else:
            value = []
            num = node.shell.readint()
            for i in range(0, num):
                ucssid = node.shell.readblock()
                signalquality = node.shell.readint()
                connectable = node.shell.readint()
                issecurity = node.shell.readint()
                authalgo = node.shell.readint()
                cipheralgo = node.shell.readint()
                value.append((ucssid, signalquality, connectable, issecurity, authalgo, cipheralgo))
        return value

    def run(self):
        self.host = self.target.interface
        self.setInfo("%s (in progress)"%(NAME))
        
        rv = 0

        for node in self.argsDict["passednodes"]:
            if node.nodetype in ['win32Node', 'win64Node']:
                handler, success = self.WlanOpenHandle(node)
                
                if not success:
                    self.log("An error has occurred: WlanOpenHandle()")
                    continue
                
                guids = self.WlanEnumInterfaces(handler, node)
                
                for guid in guids:
                    wlanlist = self.WlanGetAvailableNetworkList(handler, guid[0], node)
                    
                    self.log("Listing discovered wlans for GUID %s\n" % guid[1])
                    
                    for wlan in wlanlist:
                        self.log("ESSID: %s\n" % wlan[0])
                        self.log("SignalQuality: %d\n" % wlan[1])
                        self.log("Is connectable?: %s\n" % bool(wlan[2]))
                        self.log("Have any security?: %s\n" % bool(wlan[3]))
                        self.log("Authentication algorithm: %s\n" % self.auth_algo(wlan[4]))
                        self.log("Cipher algorithm: %s\n" % self.ciph_algo(wlan[5]))
                        self.log("\n")
                        
                # XXX
                #node.shell.WlanCloseHandle(handler)
                rv = 1
                
            else:
                self.log("Node of type %s not supported yet." % node.nodetype)
            
        self.setInfo("%s - done" % (NAME))
        return rv

if __name__=="__main__":
    print "You can't run this from the commandline, sorry"
