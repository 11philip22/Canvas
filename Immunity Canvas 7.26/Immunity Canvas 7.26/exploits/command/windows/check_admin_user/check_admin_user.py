#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import math
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

from WindowsConstants import TOKEN_QUERY, TOKEN_DUPLICATE, TokenElevationType, TokenLinkedToken, SecurityIdentification, TokenElevationTypeLimited

import canvasengine

NAME                   = "check_admin_user"
DESCRIPTION            = "Check whether the current user is a member of the Administrator group"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

This tool will help you determine whether you're running as a user who is an administrator.
It simply checks whether the user you're running as is in the 'Administrators' group.
Technical note: for those interested, when a program is run from a low-privileged
                (read: not in the "Administrators" group) account

Tests for this module are detailed inside of getintegritylevel.py, as that module depends on this one
"""
VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.supportedNodeTypes = ["win32Node", "win64Node"]

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getintegritylevel - " + msg)
        self.setProgress(percent)

    def get_code(self, node, vista_or_greater):
        v = {"vista_or_greater" : vista_or_greater}

        code = """
        #import "IMPORT_TYPE","advapi32.dll|GetTokenInformation" as "GetTokenInformation"
        #import "IMPORT_TYPE","advapi32.dll|DuplicateToken" as "DuplicateToken"
        #import "IMPORT_TYPE","advapi32.dll|CheckTokenMembership" as "CheckTokenMembership"
        #import "IMPORT_TYPE","advapi32.dll|CreateWellKnownSid" as "CreateWellKnownSid"
        #import "IMPORT_TYPE","kernel32.dll|GetCurrentProcess" as "GetCurrentProcess"
        #import "IMPORT_TYPE","kernel32.dll|GetLastError" as "GetLastError"
        #import "IMPORT_TYPE","kernel32.dll|OpenProcess" as "OpenProcess"
        #import "IMPORT_TYPE","kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE","advapi32.dll|OpenProcessToken" as "OpenProcessToken"

        #import "local", "SEND_RETURN" as "SEND_RETURN"
        #import "local", "free" as "free"
        #import "local", "malloc" as "malloc"
        #import "local", "memset" as "memset"

        #import "int", "vista_or_greater" as "vista_or_greater"

        void main(){
        HANDLE proc_handle;
        HANDLE token_handle;
        HANDLE *psec_token_handle;
        HANDLE final_token_handle;
        int size_token_handle;

        int length_needed;
        int ret;


        int elev_type;
        int size;

        char * padmin_sid;
        int in_admin_group;

        proc_handle = GetCurrentProcess();

        ret = OpenProcessToken(proc_handle, TOKEN_QUERY_AND_DUPLICATE, &token_handle);
        if (ret == 0){
           SEND_RETURN(0xffffff0);
           return;
        }

        psec_token_handle = 0;
        final_token_handle = 0;



        if (vista_or_greater){
          ret = GetTokenInformation(token_handle, TOKEN_ELEVATION_TYPE, &elev_type, 4, &size);
          if (ret == 0){
            CloseHandle(token_handle);
            SEND_RETURN(0xffffff1);
            return;
          }

          if (elev_type == TE_TYPE_LIMITED){
            ret = GetTokenInformation(token_handle, TOKEN_LINKED_TOKEN, 0, 0, &size_token_handle);

            if (ret == 0){
              psec_token_handle = malloc(size_token_handle);
              memset(psec_token_handle, 0, size_token_handle);
            }

            ret = GetTokenInformation(token_handle, TOKEN_LINKED_TOKEN, psec_token_handle, size_token_handle, &size_token_handle);
            if (ret == 0){
               free(psec_token_handle);
               psec_token_handle = 0;
               //CloseHandle(token_handle);
               //SEND_RETURN(0xffffff2);
               //return;
            }
          }
        }

        if (psec_token_handle != 0){
           final_token_handle = *psec_token_handle;
        }

        if (final_token_handle == 0){
           ret = DuplicateToken(token_handle, SECURITY_IDENTIFICATION, &final_token_handle);
           if (ret == 0){
               CloseHandle(token_handle);
               SEND_RETURN(0xffffff3);
               return;
            }
        }

        // SECURITY_MAX_SID_SIZE is 68 as of 2/16/2017
        padmin_sid = malloc(68);
        size = 68;

        // WindowsBuiltinAdministratorsSid = 26
        ret = CreateWellKnownSid(26, 0, padmin_sid, &size);

        if (ret == 0){
          CloseHandle(token_handle);
          CloseHandle(final_token_handle);
          free(padmin_sid);
          SEND_RETURN(0xffffff3);
          return;
        }

        ret = CheckTokenMembership(final_token_handle, padmin_sid, &in_admin_group);
        if (ret == 0){
          CloseHandle(token_handle);
          CloseHandle(final_token_handle);
          free(padmin_sid);
          SEND_RETURN(0xffffff4);
          return;
        }

        CloseHandle(token_handle);
        CloseHandle(final_token_handle);
        free(padmin_sid);
        SEND_RETURN(in_admin_group);
        return;
        }

        """.replace("IMPORT_TYPE", node.shell.import_type).replace("TOKEN_QUERY_AND_DUPLICATE", str(TOKEN_QUERY|TOKEN_DUPLICATE)).replace("SEND_RETURN", node.shell.send_return).replace("HANDLE", node.shell.handle_type).replace("TE_TYPE_LIMITED", str(TokenElevationTypeLimited)).replace("TOKEN_ELEVATION_TYPE", str(TokenElevationType)).replace("TOKEN_LINKED_TOKEN", str(TokenLinkedToken)).replace("SECURITY_IDENTIFICATION", str(SecurityIdentification))

        return (code, v)

    def run(self):
        self.setInfo("%s" % NAME)
        node = self.argsDict["passednodes"][0]
        percent = 0
        increase = int(math.ceil(100 / len(self.argsDict["passednodes"])))
        are_admins = []

        for (index, node) in enumerate(self.argsDict["passednodes"]):
            if node.nodetype not in self.supportedNodeTypes:
                logging.error("Cannot run check_admin_user on a non-Windows MOSDEF node")
                are_admins.append(None)
            else:
                whoami_string = node.shell.whoami()
                return_value = None

                if isinstance(whoami_string, str):
                    user_name_parts = whoami_string.split("\\")
                    user_name = user_name_parts[-1]

                    output = node.shell.runcommand("net user %s" % user_name)

                    if "The user name could not be found" not in output:
                        for line in output.splitlines():
                            if line.startswith("Local Group Memberships"):
                                return_value = "Administrators" in line
                                break
                    else:
                        # This code unfortunately no longer works if you're a normal admin user
                        # on Windows 10 unless you're running elevated. If that is not the case,
                        # your token will not be in the Administrator group by default *even if
                        # you are an administrator as listed in "net user"*

                        vista_or_greater = node.shell.os_major_geq(6)

                        (code, v) = self.get_code(node, vista_or_greater)

                        node.shell.clearfunctioncache()
                        message = node.shell.compile(code, v)
                        node.shell.sendrequest(message)
                        x = node.shell.read_return()
                        node.shell.leave()

                        if x >= 0xffffff0 and x <= 0xfffffff:
                            pass
                        else:
                            return_value = True if x == 1 else False

                else:
                    logging.error("(%s) unable to get current user's name" % (str(node.getname())))

                are_admins.append(return_value)

                if return_value == True:
                    logging.warning("Node (%s) is running as user in Administrator group!" % (str(node.getname())))
                elif return_value == False:
                    logging.warning("Node (%s) is NOT running as user in Administrator group." % (str(node.getname())))
                else:
                    logging.error("Could not determine whether user of current node (%s) is in Administrator group" % (str(node.getname())))

                percent += increase
                self.set_progr("processed node %d (%s)" % ((index + 1),str(node.getname())), percent)

        self.result = are_admins
        self.setInfo("%s - done (success: %s)" % (NAME, self.result))

        return 1


if __name__=="__main__":
    logging.warning("This module should be used only from within CANVAS")
