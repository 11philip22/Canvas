#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import math
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand


import canvasengine

NAME                   = "get_token_info"
DESCRIPTION            = "Gets information about the current user such as privileges and groups"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
"""

VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.supportedNodeTypes = ["win32Node", "win64Node"]
        self.privileges = {}

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("get_token_info - " + msg)
        self.setProgress(percent)

    def get_tokens(self, node, arch):
        token_handles = []

        base_path = os.path.dirname(__file__)

        code = None
        with open(os.path.join(base_path, "Resources", "dump_tokens.c"), "rb") as handle:
            code = handle.read()
        # NN: this must take into account 64 vs 32 bit
        if arch == 'X86':
            code = code.replace("IMPORT_TYPE", "remote").replace("HANDLE_TYPE", "long").replace("POINTER_TYPE", "char *")
        elif arch == 'X64':
            code = code.replace("IMPORT_TYPE", "local").replace("HANDLE_TYPE", "long long").replace("POINTER_TYPE", "char *")

        node.shell.clearfunctioncache()

        vars = {}
        request = node.shell.compile(code,vars)
        logging.info("Done compiling code")
        logging.info("Sending code")

        node.shell.sendrequest(request)
        # logging.info("Found our own process?")
        # pid = None

        # while pid != 0xffffffff:
        #     pid = node.shell.readint()
        #     logging.info("found pid:%08x" % pid)

        handle_value = None

        while handle_value != 0xffffffff:
            handle_value = node.shell.readint()
            if handle_value != 0xffffffff:
                handle_type = node.shell.read_uni_string()

                if "token" in handle_type.lower():
                    token_handles.append(handle_value)

                logging.debug("Handle value:0x%08x of type %s" % (handle_value, handle_type))


        logging.info("Done dumping tokens")
        # logging.info("done reading PIDs...")
        node.shell.leave()
        return token_handles

    def get_privileges(self, node, arch, token_handle_type="process"):
        base_path = os.path.dirname(__file__)

        code = None
        with open(os.path.join(base_path, "Resources", "dump_privs.c"), "rb") as handle:
            code = handle.read()

        # NN: this must take into account 64 vs 32 bit
        if arch == 'X86':
            code = code.replace("IMPORT_TYPE", "remote").replace("HANDLE", "int")
        elif arch == 'X64':
            code = code.replace("IMPORT_TYPE", "local").replace("HANDLE", "long long")

        node.shell.clearfunctioncache()

        vars = {}
        if token_handle_type == "process":
            logging.info("Dumping privileges for the primary/process token")
            vars["input_token_handle"] = 0
        elif token_handle_type == "thread":
            logging.info("Dumping privileges for the current thread's token")
            vars["input_token_handle"] = 1
        else:
            logging.info("Dumping privileges for handle number 0x%08x" % token_handle_type)
            vars["input_token_handle"] = token_handle_type

        request = node.shell.compile(code,vars)
        logging.info("Done compiling code")
        logging.info("Sending code")

        node.shell.sendrequest(request)

        logging.info("Reading initial return")
        initial_ret = node.shell.readint()

        if initial_ret == 0xffffffff:
            logging.error("Unable to obtain %s handle with TOKEN_QUERY privilege!" % token_handle_type)
            node.shell.leave()
            return None
        elif initial_ret == 0:
            logging.error("Unable to obtain list of privileges")
            node.shell.leave()
            return None
        else:
            logging.info("Reading in a list of %d privileges" % initial_ret)
            privileges = {}
            privilege_count = initial_ret
            # privilege_count = node.shell.readint()
            for i in range(0, privilege_count):
                # get the name / identifier
                data_type = node.shell.readint()

                logging.info("Got privilege type: %d" % data_type)

                priv_name = None
                if data_type == 1:
                    priv_name = node.shell.readstring()
                    logging.info("Got privilege string: %s" % priv_name)
                elif data_type == 2:
                    low_part = node.shell.readint()
                    logging.debug("Got privilege low part: %08x" % low_part)
                    high_part = node.shell.readint()
                    logging.debug("Got privilege high part: %08x" % high_part)
                    priv_name = "%064x" % (high_part<<32 & low_part)

                # Get the attributes (if it's enabled or not)
                attributes = node.shell.readint()
                logging.info("Attributes: %08x" % attributes)

                privileges[priv_name] = True if attributes & 2 else False
        node.shell.leave()
        logging.info("Privilege dictionary: " + str(privileges))
        return privileges

    def run(self):
        self.setInfo("%s" % NAME)
        node = self.argsDict["passednodes"][0]
        percent = 0
        increase = int(math.ceil(100 / len(self.argsDict["passednodes"])))

        for (index, node) in enumerate(self.argsDict["passednodes"]):
            if node.nodetype not in self.supportedNodeTypes:
                logging.error("Cannot run get_token_info on a non-Windows MOSDEF node")
            else:
                # logging.info("os version info:" + str(node.shell.os_version_info()))
                node_privs = {}
                self.privileges[node] = node_privs
                token_types = ["process", "thread"]
                arch = 'X86' if node.nodetype == 'win32Node' else 'X64'
                token_types.extend(self.get_tokens(node, arch))

                for token_type in token_types:
                    current_privs = self.get_privileges(node, arch, token_handle_type=token_type)
                    if current_privs == None:
                        logging.error("Unable to get privileges for node (%s) / %s" % (node, token_type if isinstance(token_type,str) else ("0x%08x" % token_type)))
                    node_privs[token_type] = current_privs

                percent += increase
                self.set_progr("Processed node %d (%s)" % ((index + 1),str(node.getname())), percent)

        # self.result = are_admins
        self.setInfo("%s - done (success: %s)" % (NAME, self.result))

        return all(self.result)


if __name__=="__main__":
    logging.warning("This module should be used only from within CANVAS")
