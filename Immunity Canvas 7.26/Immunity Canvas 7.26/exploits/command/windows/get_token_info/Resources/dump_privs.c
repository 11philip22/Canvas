#import "IMPORT_TYPE","kernel32.dll|GetCurrentProcess" as "GetCurrentProcess"
#import "IMPORT_TYPE","advapi32.dll|OpenProcessToken" as "OpenProcessToken"
#import "IMPORT_TYPE","advapi32.dll|GetTokenInformation" as "GetTokenInformation"
#import "IMPORT_TYPE","advapi32.dll|LookupPrivilegeNameA" as "LookupPrivilegeNameA"
#import "IMPORT_TYPE","advapi32.dll|OpenThreadToken" as "OpenThreadToken"
#import "IMPORT_TYPE","kernel32.dll|GetCurrentThread" as "GetCurrentThread"

#import "local", "sendint" as "sendint"
#import "local", "sendstring" as "sendstring"
#import "local", "free" as "free"
#import "local", "malloc" as "malloc"
#import "local", "debug" as "debug"

#import "HANDLE", "input_token_handle" as "input_token_handle"

struct LUID_AND_ATTRIBUTES {
  // LUID  Luid;
  int LowPart;
  int HighPart;
  // end LUID
  int Attributes;
}; 

struct TOKEN_PRIVILEGES {
  int PrivilegeCount;
};

// TOKEN_INFORMATION_CLASS.TokenPrivileges = 3
void main()
{
  struct TOKEN_PRIVILEGES * token_privileges;
  int token_priv_size;
  int ret;
  int j;
  int * luid_ptr;
  int len_privname;
  char * buf_privname;
  HANDLE token_handle;

  if (input_token_handle == 0){
    ret = OpenProcessToken(GetCurrentProcess(), 8, &token_handle);
    if (ret == 0){
      sendint(0xffffffff);
      return;
    }
  }
  if (input_token_handle == 1){
    ret = OpenThreadToken(GetCurrentThread(), 8, 0, &token_handle);
    if (ret == 0){
      sendint(0xffffffff);
      return;
    }
  } else {
    if (input_token_handle != 0){
      token_handle = input_token_handle;
    }
  }

  token_priv_size = 0;

  ret = GetTokenInformation(token_handle, 3, 0, 0, &token_priv_size);
  // we get a zero return value for this function but token_priv_size 
  // will be set
  if (ret == 0){
    
    token_privileges = malloc(token_priv_size);
    ret = 0;
    ret = GetTokenInformation(token_handle, 3, token_privileges, token_priv_size, &token_priv_size);

    if (ret == 0){
      free(token_privileges);
      sendint(0);
      return;
    }

    luid_ptr = token_privileges+1;
    
    sendint(token_privileges->PrivilegeCount);
    
    for(j=0; j<token_privileges->PrivilegeCount; j = j+1){
      len_privname = 0;
      ret = LookupPrivilegeNameA(0, luid_ptr, 0, &len_privname);

      // GetLastError() likely returns ERROR_INSUFFICIENT_BUFFER here
      if (ret == 0){

                  buf_privname = malloc(len_privname);
                  ret = LookupPrivilegeNameA(0,luid_ptr,buf_privname,&len_privname);
                  // if we can resolve the name of the privilege
                  // send it
                  if (ret != 0) {
                     sendint(1);
                     sendstring(buf_privname);
                     free(buf_privname);
                  } else {
                     // if we can't send the string, send the LUID itself
                     sendint(2);
                     // LowPart
                     sendint(luid_ptr[0]);
                     // HighPart
                     sendint(luid_ptr[1]);
                     free(buf_privname);
                  }
                  // send the attributes - this denotes whether the
                  //  privilege is enabled
                  sendint(luid_ptr[2]);
        
               }
      luid_ptr = luid_ptr + 3;
               
    }
  } else {
    sendint(0);
  }
}
