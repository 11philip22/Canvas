#! /usr/bin/env python

#we need to display a nice little mini icon of the screen in the CANVAS gui! (kinda
#like VMware does...) PyGTK has support for raw data like this, if we want to use
#their routines

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import logging
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from internal import *
from canvaserror import *

from ExploitTypes.localcommand import LocalCommand

NAME                   = "get_installed_software"
DESCRIPTION            = "Obtain a list of installed software"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
"""

VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['SITE']       = "Local"
PROPERTY['TYPE']       = "Commands"
PROPERTY['ARCH']       = [ ["Windows"] ]
PROPERTY['VERSION']    = ["Vista", "7", '2008', '2012', "8.1", "10"]

DOCUMENTATION['Notes'] = """

This module will create a file in Sessions/<host identifier>/InstalledSoftware/installedsoftware.txt with a list of the installed software as well as the respective versions.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.node   = None
        self.result = []
        self.name   = NAME
        self.basepath = ""
        self.savefile = "installedsoftware.txt"

    def get_installed_software(self, node):
        output = node.shell.runcommand("wmic /output:stdout product get name,version")

        # initialize persistent storage
        save_path = self.output(ip=node.get_interesting_interface(), subdir="InstalledSoftware")
        save_loc = os.path.join(save_path, self.savefile)
        fd = open(save_loc, "a")

        logging.warning("Installed programs:")
        logging.info("-"*50)
        fd.write("-"*50)

        for (index, line) in enumerate(output.split("\n")):
            if index != 0:
                delimit_index = line.find("        ")

                if delimit_index != -1:
                    name, version = (line[:delimit_index].strip(" \r\n"), line[delimit_index:].strip(" \r\n"))

                    program_line = "name:%s, version:%s" % (name,version)

                    fd.write(program_line + "\n")
                    logging.info(program_line)

        logging.info("-"*50)

        fd.write("-"*50)
        fd.close()

    def run(self):
        self.host = self.target.interface
        self.setInfo("%s (in progress)"%(NAME))

        success = False

        for node in self.argsDict["passednodes"]:
            if node.nodetype == 'win32Node' or node.nodetype == "win64Node":
                ver = node.shell.GetVersionEx()
                ver = ver[1]

                if ver["Major Version"] >= 6:
                    self.get_installed_software(node)
                    success = True
                else:
                    logging.error("OS major version < 6. WMIC application not available")

            else:
                self.log("Node of type %s not supported yet" % node.nodetype)

        self.setInfo("%s - done" % (NAME))
        return success

if __name__== "__main__":
    print "You can't run this from the commandline, sorry"
