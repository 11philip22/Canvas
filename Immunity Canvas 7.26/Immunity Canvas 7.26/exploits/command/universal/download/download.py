#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from canvaserror import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import canvasengine
import time

NAME                = "download"
DESCRIPTION         = "Download file. Uses first selected node."
DOCUMENTATION       = {}
VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Remote"
PROPERTY['ARCH']    = [ ["Windows", "All"], ["Unix", "All"] ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result             = ""
        self.name               = NAME
        self.source             = "/doesnotexist"

    def run(self):
        results     = []
        rv          = 0
        source      = self.argsDict.get("source",self.source).strip()

        ##Sanity Check
        if len(source) == 0:
            ##Now source has been given to grab
            msg = "No source file given to download."
            self.log(msg)
            self.result = msg
            self.setInfo("%s - done (failed: %s)"%(NAME, msg))
            return 0

        for node in self.argsDict["passednodes"]:

            ##Only use on nodetypes that are capable of downloads, localnode is excluded cuz that makes no sense
            if "VFS" not in node.capabilities or "localnode" in node.capabilities:

                e = "%s node type not supported by this module"%node.nodetype
                self.log(e)
                results.append((False, e))
                continue

            outputdir      = self.engine.create_new_session_output_dir(node.get_interesting_interface(), 'downloaded_files')

            self.setInfo("%s (in progress)" % (NAME))

            try:
                os.stat(outputdir)
            except OSError:
                self.log("Could not find %s so creating it" % outputdir)
                try:
                    os.mkdir(outputdir)
                except (OSError, IOError), i:
                    e           = "Failed to create output directory %s: %s" % (outputdir, str(i))
                    self.result = e
                    rv          = 0
                    self.log(e)
                    self.setInfo("%s - done (failed: %s)"%(NAME, self.result))
                    return rv

            ##Has a none qualified path been given?
            if source.rfind("/") == -1 and source.rfind("\\") == -1:

                ##If so current working directory needs to be prepended
                if node.nodetype == "UnixShellNode":
                    cwd = node.runcommand("pwd")
                else:
                    cwd = node.getcwd()

                ## sanitize for return/newlines
                cwd = cwd.replace('\r', '')
                cwd = cwd.replace('\n', '')

                ##Concat the paths with correct seperator
                if cwd.rfind("/") == -1:
                    source = cwd + "\\" + source #win32
                else:
                    source = cwd + "/" + source  #*nix

            ##replace path seperators with '_'
            directory = os.path.join(outputdir,source.replace("/","_").replace("\\","_"))
            ##remove any ':' that are present as this confuses windows as an alternate data stream
            directory = directory.replace(":","")

            ##Actually do the download
            self.log("Downloading %s on node %s to %s"%(source,node.getname(), directory))
            try:
                r = node.download(source, directory )
                results.append((True, str(r)))
                self.log(r)
            except NodeCommandError, i:
                e = "Failed to download on node %s: %s" % (node.getname(), i)
                self.log(e)
                results.append((False, e))

        self.result = ", ".join([x[1] for x in results])

        if all([z[0] for z in results]):
            rv = 1
            self.setInfo("%s - done (success)"%(NAME))
        else:
            rv = 0
            self.setInfo("%s - done (failed: %s)"%(NAME, self.result))

        self.log("Download finished")
        return rv

