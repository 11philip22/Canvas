#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
from exploitutils import *
import time

from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
import libs.newsmb.libdcerpc as libdcerpc
import libs.newsmb.epmap_ng as epmap
import canvasengine

NAME = 'Windows Service Pack Detection'
DESCRIPTION = 'Windows Service Pack Detection'
DOCUMENTATION = {}
DOCUMENTATION['Notes'] = ''
PROPERTY = {}
PROPERTY['TYPE'] = 'Recon'
PROPERTY['SITE'] = 'Remote'

VERSION = '1.1'

NOTES = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 135
        self.name = NAME
        self.UUID = u'e1af8308-5d1f-11c9-91a4-08002b14a0fa'
        self.opnum = 0
        self.baseos = ''
        self.servicepack = []
        return

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        return 

    def test(self):
        self.getArgs()
        self.log('SPDetect test running on port %s' % self.port)
        binding = u"ncacn_ip_tcp:%s[%d]" % (self.host, self.port)
        res = False
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        try:
            dce = epmap.EPTClient(self.host)
            res = dce.bind()
            if not res:
                raise libdcerpc.DCERPCException('no reason')
        except libdcerpc.DCERPCException:
            self.log("Could not bind to the MSRPC epmapper")
            return 0
        self.log('Connection to the MSRPC epmapper successful')
        return 1

    def runDetect(self, known_os=None):
        self.getArgs()
        self.log('Running Service Pack detection routines on %s:%s' % (self.host,
                                                                       self.port))
        self.log('SP Detection starting')
        if not known_os:
            known_os = self.target.get_knowledge('OS')
            if not known_os:
                self.exploitnodes("osdetect")
                known_os = self.target.get_knowledge('OS')
                if not known_os:
                    return 'Unknown'
            self.baseos = known_os.known
        else:
            #we were passed in a canvasos object
            self.baseos = known_os
        self.servicepack = self.baseos.servicepack
        if len(self.servicepack) == 1:
            #if we found just one, let's put it in there!
            self.baseos.servicepack = self.servicepack[0]
        self.result = self.servicepack
        return self.servicepack

    def run(self):
        self.getArgs()
        self.log('Running SPDetect on %s:%s' % (self.host, self.port))
        self.setInfo('%s attacking %s:%s' % (NAME, self.host, self.port))
        ret = self.runDetect()
        self.log('Service Pack: %s' % ret)
        self.setInfo('%s attacking %s:%s (done)' % (NAME, self.host, self.port))
        return 1

    def usage(self):
        print 'Usage: '+ sys.argv[0] + ' [ -T ] -t target [ -p port ]'

if __name__ == '__main__':
    print 'Running CANVAS ' + NAME + ' version ' + VERSION
    app=theexploit()
    ret=standard_callback_commandline(app)
