#! /usr/bin/env python

"""
ipfingerprint.py 

Conducts UDP/TCP/ICMP fingerprinting

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import socket
import getopt
import sys

if "." not in sys.path:
    sys.path.append(".")

from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine
import localsniffer

#TODO: FIX THESE
DOCUMENTATION={}
DESCRIPTION="Gathers data needed for IP Fingerprinting from a remote host"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NAME="ipfingerprint"


from sniffer import sender
from sniffer import packetConstructor
from sniffer import packetParser
from sniffer import get_ethernet_header
from sniffer import r_TCPFLAGS

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)

        self.name=NAME
        self.host_results={}
        self.closed_udp_port=0
        self.udpfromport=53
        self.iterations=4
        return

    def icmp_unreachable_callback(self, parser):
        """
        Recieves icmp unreachable messages from our target

        TODO: move IP_TTL check to here, and calculate the initial TTL
        by adding the (STARTTTL-RESULTTTL) in the UDP packet to the one in the IP packet
        """
        devlog("ipfingerprint", "Callback got triggered for icmp port unreachable")
        data=parser.attribs["icmpdata"]
        self.host_results["icmp_error_quote_len"]=len(data)
        devlog("ipfingerprint", "Got icmp error quote length of %d"%len(data))
        #IP TOTAL LENGTH FIELD
        self.host_results["icmp_error_ip_total_length"]=str2int16(data[6:])
        devlog("ipfingerprint", "Got ip total length of %d"%self.host_results["icmp_error_ip_total_length"])


        #IPID
        if len(data)>=10:
            self.host_results["ip_id"]=str2int16(data[8:])
        #todo:
        #3BITS FLAGS and OFFSET FIELDS
        if len(data)>=12:
            self.host_results["flagsandoffset"]=str2int16(data[10:])

        #Start TTL
        #Calculate by looking at the TTL of our UDP/IP packet
        if len(data)>=12:
            devlog("ipfingerprint","Data[12]=%d ip_ttl=%d"%(ord(data[12]),parser.attribs["ip_ttl"]))
            calced_ttl=parser.attribs["ip_ttl"]+64-ord(data[12])
            devlog("ipfingerprint","Found calced ttl: %d"%calced_ttl)
            self.host_results["start_ip_ttl"]=calced_ttl 

        #IP HEADER CHECKSUM
        if len(data)>=17:
            if str2int16(data[15:])==0:
                null_ip_checksum=1
            else:
                null_ip_checksum=0
            self.host_results["null_ip_checksum"]=null_ip_checksum


        #UDP HEADER CHECKSUM


        if len(data)>=33:
            if str2int16(data[31:])==0:
                null_udp_checksum=1
            else:
                null_udp_checksum=0
            self.host_results["null_udp_checksum"]=null_udp_checksum

        #Differentiated Services Field (One byte)
        if len(data)>=6:
            self.host_results["DSF"]=ord(data[5])

        return

    def send_udp_packet(self):
        """
        Sends a UDP packet to a closed UDP port with some IP flags set.
        This triggers an ICMP message, ideally, and we then examine
        the result to set some of our variables. 

        1) This packet has 300 bytes of "data".
        """
        self.log("Sending UDP packet to %s:%d to elicit ICMP response"%(self.host, self.closed_udp_port))
        mysender=sender(target=self.host, iface=self.iface)
        udppacker=packetConstructor()
        udp_data="A"*300
        udppacker.UDP(self.source,self.host,self.udpfromport,self.closed_udp_port,udp_data)
        udpdata=udppacker.get() 
        ippacker=packetConstructor()
        #set DF flag here
        #flags is set as a 16 bit number...
        ippacker.IP(self.source, self.host, udpdata, ipid=0x7788, flags=0x4000)
        ipdata=ippacker.get()

        #now send the data across the wire - need to prepend the ethernet header, of course
        mysender.send(self.eth_header+ipdata,"IP")

        return 

    def send_echo_request_packet(self):
        """
        Sends a ICMP ECHO REQUEST packet with a non-zero code 
        field.

        Also send a non-default TOS field.
        """
        icmppacker=packetConstructor()
        icmppacker.ICMP_ECHO_REQUEST(self.source,self.host,0,0,code=1, tos=0xfe)
        data=self.eth_header + icmppacker.get()

        mysender=sender(target=self.host, iface=self.iface)
        mysender.send(data,"IP")
        return 

    def icmp_echo_response_callback(self, parser):
        """
        Used after icmp echo response is sent out
        """
        code=parser.attribs["icmpcode"]
        self.host_results["icmp_code"]=code
        tos=parser.attribs["ip_differentiatedServicesField"]
        self.host_results["tos"]=tos
        return 

    def icmpscan(self):
        """
        Sends a raw UDP/IP packet to elicit an ICMP response, then gets data from that response
        """
        #ICMP Error Message Return Size
        #needs a closed UDP Port
        #setup sniffer to listen for ICMP messages of type 3
        openfs="icmpsource(%s) icmpcode(3)"%(self.host)
        devlog("ipfingerprint", "ICMP Sniffer String: %s"%openfs)
        #print "self.port_callback=%s"%self.port_callback

        #self.engine.register_sniffer_callback(self.icmp_unreachable_callback,openfs)
        ssnif = self.start_sniffer(self.icmp_unreachable_callback, openfs)
        self.run_one_test(self.send_udp_packet, "icmp_error_quote_len")
        #unregister our handler
        self.stop_sniffer(ssnif, self.icmp_unreachable_callback)

        #self.engine.unregister_sniffer_callback(self.icmp_unreachable_callback)

        return 

    def start_sniffer(self, func, filterstr):
        if hasattr(self, "engine") and hasattr(self.engine, "localsniffer") and hasattr(self.engine.localsniffer, "running") and self.engine.localsniffer.running():
            ssnif = self.engine.localsniffer
        else:
            ssnif = localsniffer.localsniffer()
            ssnif.start()

        ssnif.registercallback(func, filterstr)
        return ssnif


    def stop_sniffer(self, snif, func):
        snif.unregistercallback(func)
        if self.argsDict.get("silica",False):
            snif.shutdown()
            del(snif)
        return

    def tcp_response_callback(self, parser):
        devlog("ipfingerprint", "Got TCP Response Callback!: %x"%parser.attribs["tcp_flags"])
        dest_port=parser.attribs["tcp_dest_port"]
        if dest_port!=self.tcp_local_port:
            devlog("ipfingerprint", "TCP Dest Port %d was not our port!"%dest_port)
            return 
        devlog("ipfingerprint", "Dest port was %d"%dest_port)
        if parser.attribs["tcp_flags"] & 0x12 == 0x12: #syn+ack
            self.host_results["syn_ack_window"]=parser.attribs["tcp_window"]
            #this value will be somewhere NEAR the start TTL. 
            self.host_results["tcp_ip_ttl"]=parser.attribs["ip_ttl"]
        return 

    def send_tcp_request_packet(self):
        tcp_dest_port=self.tcp_dest_port
        mysender=sender(target=self.host, iface=self.iface)
        tcppacker=packetConstructor()
        ippacker=packetConstructor()

        flags="SYN"
        tcppacker.TCP(self.source,self.host,flags, self.tcp_local_port, tcp_dest_port, "")
        tcpdata=tcppacker.get() 
        ippacker=packetConstructor()
        #set DF flag here
        #flags is set as a 16 bit number...
        ippacker.IP(self.source, self.host, tcpdata, protocol="TCP", ipid=0x7788, flags=0x4000)
        ipdata=ippacker.get()

        #now send the data across the wire - need to prepend the ethernet header, of course
        mysender.send(self.eth_header+ipdata,"IP")
        return 

    def run_one_test(self, function, needed_field):
        """
        Runs one test a number of times to account for packet loss
        """
        #need eth_header to do IP raw sockets
        self.eth_header = get_ethernet_header(self.host, self.iface)
        if self.eth_header=="":
            self.log("Ethernet header did not get displayed properly - exiting")
            self.log("This can happen if you are on the same subnet as your target, and you do not have them in the ARP cache")
            self.log("Try pinging your target and trying again")
            return 0

        for i in xrange(0,self.iterations):
            if self.host_results.get(needed_field)!=None:
                self.log("Got %s Reply back!"%needed_field)
                return True 
            function()
            time.sleep(1)
        return False


    def tcp_ecn_callback(self, parser):
        """
        We sent out a request with CWR and ECN flags set, now we examine the response
        """
        devlog("ipfingerprint", "Got TCP ECN Response Callback!: %x"%parser.attribs["tcp_flags"])
        flags=parser.attribs["tcp_flags"]
        if flags & 0x12 == 0x12: #syn+ack
            ecn = flags & r_TCPFLAGS["ECN"]
            cng = flags & r_TCPFLAGS["CNG"]
            #mini-bit-flags conversion thing below
            result=0
            if ecn:
                result = 1
            if cng:
                result += 2

            #check ECN flags and return a different number for each setting
            self.host_results["tcp_ecn"]=result
        return 

    def send_tcp_ecn(self):
        """
        Explicit congestion notification test on open TCP socket
        """
        self.log("Sending TCP ECN attempt to port %d from port %d"%(self.tcp_dest_port, self.tcp_local_port))
        tcp_dest_port=self.tcp_dest_port
        mysender=sender(target=self.host, iface=self.iface)
        tcppacker=packetConstructor()
        ippacker=packetConstructor()

        flags="SYN ECN CNG"
        tcppacker.TCP(self.source,self.host,flags, self.tcp_local_port, tcp_dest_port, "")
        tcpdata=tcppacker.get() 
        ippacker=packetConstructor()
        #set DF flag here
        #flags is set as a 16 bit number...
        ippacker.IP(self.source, self.host, tcpdata, protocol="TCP", ipid=0x7789, flags=0x0000)
        ipdata=ippacker.get()

        #now send the data across the wire - need to prepend the ethernet header, of course
        mysender.send(self.eth_header+ipdata,"IP")
        return 

    def tcpscan(self):
        """
        Sends a TCP packet to an open port to get some options
        """
        self.tcp_local_port=random.randint(1025,65535)
        self.log("TCP Local Port: %s"%self.tcp_local_port)
        openfs="ipsource(%s) ipdest(%s) tcp_dest_port(%d)"%(self.host, self.source, self.tcp_local_port)
        #self.engine.register_sniffer_callback(self.tcp_response_callback,openfs)
        ssnif = self.start_sniffer(self.tcp_response_callback, openfs)
        #check to see if we know about open ports
        knowl = self.target.get_knowledge("TCPPORTS")
        if not knowl:
            #no known open ports, pick all of these to see
            dest_ports=[445, 80, 25, 23, 22]
            if self.known_open_ports:
                self.log("Adding user-supplied known open ports %s"%self.known_open_ports)
                for port in self.known_open_ports:
                    if int(port) not in dest_ports:
                        dest_ports.append(int(port))

        else:
            #pick the first open port
            dest_ports=[knowl.known[0]]
        self.log("TCP Scan using open port list of %r"%dest_ports)
        #ok, so now we iterate through all the ports
        for tcp_dest_port in dest_ports:
            self.tcp_dest_port=tcp_dest_port
            ret=self.run_one_test(self.send_tcp_request_packet, "syn_ack_window")
            if ret:
                break 
        self.stop_sniffer(ssnif, self.tcp_response_callback)   
        #self.engine.unregister_sniffer_callback(self.tcp_response_callback)
        if self.host_results.get("syn_ack_window"):
            #we did find an open port...
            #new source port will avoid confusion in the tests
            self.tcp_local_port=random.randint(1025,65535)
            openfs="ipsource(%s) ipdest(%s) tcp_dest_port(%d)"%(self.host, self.source, self.tcp_local_port)
            self.log("ECN FS: %s"%openfs)
            ssnif = self.start_sniffer(self.tcp_ecn_callback, openfs)
            #self.engine.register_sniffer_callback(self.tcp_ecn_callback,openfs)
            #pick a new random port
            self.run_one_test(self.send_tcp_ecn, "tcp_ecn")
            #self.engine.unregister_sniffer_callback(self.tcp_ecn_callback)
            self.stop_sniffer(ssnif, self.tcp_ecn_callback)
        else:
            self.log("No open port for TCP_ECN test")
        return 

    def getargs(self):
        self.node=self.argsDict["passednodes"][0]
        self.host=self.target.interface
        self.iface = self.argsDict.get("iface", None)
        self.source=self.argsDict.get("source",get_source_ip(self.host))
        self.getarg("closed_udp_port")
        self.known_open_ports = self.argsDict.get("known_open_ports",None)

        if self.known_open_ports:
            if self.known_open_ports == "eg. 21,22,80,443":
                self.known_open_ports = None
            else:
                self.known_open_ports = self.known_open_ports.split(",")

        if self.closed_udp_port==0:
            #automatically get a closed UDP port from host_knowledge
            closed_udp_ports=self.target.get_knowledge("CLOSEDUDPPORTS")
            if not closed_udp_ports:
                #use default closed udp port
                self.closed_udp_port=5454
            else:
                #use the first one in the list
                self.closed_udp_port=closed_udp_ports.known[0]
        self.log("Using closed udp port: %d"%self.closed_udp_port)
        return 

    def run(self):
        """
        runs the attempt to grab information
        """
        self.getargs()

        if not self.can_scanrand(target = self.target.interface):
            self.log("IP Fingerprinting needs raw socket capabilities")
            return 0

        self.icmpscan()
        self.tcpscan()
        #Print out the response from our host that we've calculated
        self.log("Got result: %r"%self.host_results)
        self.target.add_knowledge("IPDATA",self.host_results,100)

        self.result=self.host_results
        return 1

if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
