#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

#author: sinan.eren@immunityinc.com

import sys

if "." not in sys.path: sys.path.append(".")

import os
import socket
import select
import time
import libs.ctelnetlib as ctelnetlib

from exploitutils import *
import canvasengine

from tcpexploit import tcpexploit

DESCRIPTION="Telnet Banner Grabber (used for osdetect)"
VERSION="1.0"
NAME="telnetbanner"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"


from libs.addressdb import SolarisAddress
solDict={}
solDict[-2]="Solaris" #unknown Solaris telnet banner
solDict[6]="2.6"
for i in range(7,11):
    solDict[i]="%d"%i

from libs import canvasos

class theexploit(tcpexploit, SolarisAddress):
    """Basic telnet banner grabber
    s = TelnetBannerGrabber("192.168.10.1", 23)
    if s.run().find("SunOS 5.8") != -1:
        blah
    or instead something more specific
    if s.get_solaris_rel() == 8:
        blah
    """

    def __init__(self, host="localhost", port=23):
        tcpexploit.__init__(self)
        SolarisAddress.__init__(self)
        self.host = host
        self.port = port
        self.data=""
        self.results=""
        self.nologin=False 
        self.name=NAME        
        return

    def getargs(self):
        self.host=self.target.interface
        self.getarg("port")
        self.getarg("nologin")
        return 
    
    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        sck = self.gettcpsock()
        sck.set_timeout(10)

        try:            
            if self.nologin == False:
                self.log("Connecting to %s:%d to grab telnet banner"%(self.host,self.port))
                self.tn = ctelnetlib.Telnet()
                print (self.host, self.port)
                try:
                    sck.connect( (self.host, self.port))
                except:
                    return 0

                self.tn.sock = sck
                self.tn.write("\n\n\n\n")

                self.log("Looking for login:")
                try:
                    self.data = str(self.tn.read_until("ogin:", 8))
                except:
                    self.log("Telnet connection closed before we saw login...")
                    self.data=""
                self.log("Done looking: %s"%prettyprint(self.data))

                # We skip the login check for ssh and other banner grabbing stuff
                if self.data.find("ogin:") < 0:
                    count = 10
                    while count:
                        #try 10 times
                        try:
                            tmp = self.tn.read_eager()
                        except EOFError, msg:
                            self.log("Got error: %s"%msg)
                            break 
                        #print tmp
                        if tmp:
                            self.data += tmp
                        count -= 1

                    self.log("Data=%s"%self.data)
            else:
                self.log("Connecting to %s:%d to grab banner"%(self.host,self.port))
                try:
                    sck.set_timeout(10) # fix don't wait forever
                    sck.connect((self.host, self.port))
                except:
                    print "Connect failed"

                while True:
                    try:
                        tdat = sck.recv(1024)
                    except:
                        break
                    self.data += tdat


        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            self.log("Communication failure with %s:%d" % (self.host, self.port))
            self.setInfo("%s attacking %s:%d - done (failure)"%(NAME,self.host,self.port))

            return 0

        self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        self.log("Done grabbing banner data (%s:%d)=%s"%(self.host, self.port, self.data))
        self.result=self.data

        if self.nologin == False:
            if self.data.count("ogin:"):
                #self.log("login: prompt found on port.")
                return 1
            else:
                self.log("WARNING: no login prompt found on port.")
                if self.result!="":
                    self.setProgress(100)
                    return 1
        else:
            #we didn't even try to log in
            if self.result!="":
                self.setProgress(100)
                return 1
            
        #NO BANNER WAS RETURNED
        self.setProgress(-1)
        return 0

    def get_os(self):

        ret = self.run()
        if ret == 0:
            return False 
        buf=self.result
        indx = buf.find("SunOS")
        self.log("Buf=%s"%buf)

        if buf.find("SunOS")!=-1:
            indx = buf.find("5.")
            if indx != -1:
                rel = buf[indx:indx+len("5.x")]
                #print rel
                rel=self.rel_normalize(rel)
                myos=canvasos.canvasos("Solaris")
                myos.version=solDict[rel]
                return myos
            else:
                self.log("Remote OS seems to be Solaris but unable to determine release number.")
                return canvasos.canvasos("Solaris") #we don't know the version

        elif buf.find("HP JetDirect")!=-1:
            myos=canvasos.canvasos("Embedded")
            myos.version="HP JetDirect"
            if "password" in buf:
                myos.notes="(Does have password protection on telnet port)"
            else:
                myos.notes="(Does not have password protection on telnet port)"
            return myos

        elif buf.find("RICOH Maintenance Shell")!=-1:
            #Login with admin
            myos=canvasos.canvasos("Embedded")
            myos.version="RICOH Printer"
            return myos

        elif buf.find("MontaVista(R) Linux(R)")!=-1:
            myos=canvasos.canvasos("Embedded")
            verloc = buf.index("MontaVista")
            vers = buf[verloc:]
            try:
                vers = vers[:vers.index("\r\n\r\n")]
            except IndexError:
                vers = vers.split("\n")[0]
            myos.version=vers
            return myos

        elif buf.find("Please type [Return] two times, to initialize telnet configuration")!=-1:
            myos=canvasos.canvasos("Embedded")
            myos.version="HP JetDirect Printer"
            return myos

        elif buf.find("Red Hat Linux release 7.2 (Enigma)") != -1:
            myos = canvasos.canvasos("Linux")
            myos.version = "Red Hat 7.2 (Enigma)"
            return myos

        elif buf.find("Red Hat Linux release 6.2 (Zoot)") != -1:
            myos = canvasos.canvasos("Linux")
            myos.version = "Red Hat 6.2 (Zoot)"
            return myos

        elif buf.count("AV2 Control Console"):
            myos=canvasos.canvasos("Linux")
            myos.version="XPanel"
            return myos
    
        #XXX: this is essentially wrong, but we'll fix it later
        # Add netopia and optimize code
        for ban in [ "AIX", "Cisco", "Netopia", "Belkin" ]:
            if ban in buf:
                myos=canvasos.canvasos(ban)
                return myos
    
        #if we get here, no OS found
        self.log("Unable to determine release, not enough information on telnet banner.")
        return None


if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

