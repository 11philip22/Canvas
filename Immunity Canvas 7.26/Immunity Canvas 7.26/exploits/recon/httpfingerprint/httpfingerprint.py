#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *
from canvasexploit import canvasexploit


NAME="httpfingerprint"
DESCRIPTION="Fingerprint an HTTP Server"

DOCUMENTATION={}
DOCUMENTATION["Notes"]=""""

This tool fingerprints HTTP servers by sending a request to them
and examining the Server: line in the response.

This technique can of course be fooled by someone manually changing 
their server line, or by complex web application setups that go through
multiple layers and have misleading Server: lines.

"""

TODO="""

"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"


from libs.spkproxy import *

class http_server:
    "A class that defines an http server type"
    def __init__(self,server="",version="",extentions=[]):
        self.server=server
        self.version=version
        self.extentions=extentions

        
    def __str__(self):
        return self.server
    
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=None
        self.name=NAME
        self.port=80
        self.ssl=0
        self.basepath="/"
        return

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("basepath")
        return 
    
    def test(self):
        self.getArgs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            return 0
        return 1

    def run(self):
        self.setInfo("%s"%(NAME))
        self.getArgs()
        
        self.log("Server: %s:%d"%(self.host,self.port))
        if self.ssl:
            start="https://"
        else:
            start="http://"

        #we use resolved_from here to make it work with virtualhosts!
        resolved_from=self.argsDict.get("resolved_from")
        if not resolved_from:
            resolved_from=self.target.resolved_from
        fullpath=start+resolved_from+":"+str(self.port)+self.basepath
        self.log("Fullpath=%s"%fullpath)
        UA=UserAgent(fullpath)
        worked=False 
        try:
            args=""
            result=UA.GET(args, entireresponse=True)
            worked=True 
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            result=""
        self.log("GET Result=%s"%result)
        
        server=""
        serverindex=result.find("Server: ")
        if serverindex!=-1:
            #we found a server
            serverindex+=8
            serverresult=result[serverindex:]
            index=serverresult.find("\r\n")
            if index!=-1:
                server=serverresult[:index]
        if server:
            self.target.add_to_knowledge("HTTP",(self.port,str(server)))
            self.log("Serverline: %s"%server)
            
        if result and "No server there" not in result:
            self.log("Trying to get list of allowed verbs on that basepath")
            try:
                args=""
                options_result=UA.OPTIONS()
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                options_result=""
            self.log("OPTIONS Result: %s"%options_result)
        self.result=result 
        if worked:
            #succeeded
            self.setProgress(100)
        else:           
            #failed
            self.setProgress(-1)
            
        return worked  


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
