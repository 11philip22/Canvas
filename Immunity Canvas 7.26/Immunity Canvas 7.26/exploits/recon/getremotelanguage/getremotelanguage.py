#! /usr/bin/env python

"""
getremotelanguage.py (Gets the "language pack" of a remote Windows machine)

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import socket
import getopt
import sys

if "." not in sys.path:
    sys.path.append(".")


from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine
import libs.canvasos as canvasos

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """ This module gets the remote language pack of a Windows system. It does
this by requesting a list of shares from that system, and then comparing the comment fields with
known comment fields. By default a Windows system will have ADMIN$, C$, and IPC$ shared out, so
we can look at all of them to narrow it down.

Other methods currently used include:
   o 404 handlers
   o Print providers (from getprintprovider)
   o Usernames (from userenum)
   
"""
DOCUMENTATION["Date public"]    = "10/1/2006"
DOCUMENTATION["Date partners"]  = "9/28/2006"
DESCRIPTION                     = "Get the language pack of a remote Windows machine"
VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Recon"
PROPERTY['SITE']                = "Remote"

NAME                            ="get remote language"

def constrainlist(alist,validkeys):
    """
    Intersection of the two lists is valid
    """
    tmp=[]
    for a in validkeys:
        if a in alist:
            tmp+=[a]
    return tmp

#for 404 check
import libs.spkproxy as spkproxy

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)        
        self.name       = NAME
        self.host       = ""
        self.user       = ""
        self.password   = ""
        self.forgetfull = 0 #default is to cache results
   
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("forgetfull") #set to 1 to forget our cached results

    def language_from_404(self, guessedlanguages):
        """
        Simple language detection technique where we go to a not-known
        page on IIS and look for the standard 404 message in Korean, etc
        
        This also does SSL, if it can't find port 80
        """
        url="http://%s/get404.htm"%self.host
        self.log("Looking at webserver 404 values")
        data=""
        try:
            # XXX: check for 501 closed port .. so we don't do unnecessary connects ..
            sslOpen = True
            httpOpen = True

            for hostname in ["localhost", self.host, self.target.resolved_from]:
                for protocol in [ "http", "https" ]:
                    if sslOpen == False and httpOpen == False:
                        break

                    self.log("Using Hostname: %s"%hostname)
                    fd = spkproxy.urlopen(protocol+"://"+self.host+"/get404.html",exploit=self, hostname=hostname, entireresponse=True) 
                    header = fd.read()

                    # 501 fake indicates connect error ...
                    if header.upper().count("501 NO SERVER THERE"):
                        if protocol == "http":
                            httpOpen = False
                            continue
                        else:
                            sslOpen = False
                            continue

                    header=header[:5000] #also includes body, so we'll do some truncation
                    self.log("Web header=%s"%header)
                    
                    if header.count("404"):
                        data=header 
                        break

                if sslOpen == False and httpOpen == False:
                    break
        except:
            self.log("Exception in HTTP header check ... continuing")
            #import traceback
            #traceback.print_exc(file=sys.stderr)

        if not data:
            self.log("Failed to get a 404 message")
            return guessedlanguages 
        
        self.log("Data: %s" % prettyprint(data))
        langDict={"\xc1\xa4\xba\xb8:<br>": ["Korean"], 
                  "\x8f\xda\x8d\xd7<br>": ["Japanese"], 
                  "the information": ["English"]}
        #looking for english here again, but we need a complete list!
        langDict["Make sure that the Web site address displayed"]=["English"]
        for key in langDict.keys():
            if key in data:
                guessedlanguages=constrainlist(guessedlanguages,langDict[key])
        return guessedlanguages

    def language_from_pp(self,guessedlanguages):
        """
        This function calls the getprintprovider module and uses the
        information returned to narrow down the list of languages possible
        """
        pps=self.exploitnodes("getprintproviders")[0]
        self.log(u"pps = %s" % pps)

        if pps == None or len(pps)==0:
            self.log("Failed to get print providers")
            return guessedlanguages
        
        commentDict={}
        #if there are collisions then commentDict[blah]=[lang1,lang2], see?
        commentDict[binstring(" 52 00 65 00 6d 00 6f 00 74 00 65 00 20 00 50 00 72 00 69 00 6e 00 74 00 65 00 72 00 73 00 00 00 ")]=["English","Arabic","Hebrew"]
        commentDict[binstring(" 49 00 6d 00 70 00 72 00 69 00 6d 00 61 00 6e 00 74 00 65 00 73 00 20 00 64 00 69 00 73 00 74 00 61 00 6e 00 74 00 65 00 73 00 00 00 ")]=["French"]
        commentDict[binstring(" 49 00 6d 00 70 00 72 00 65 00 73 00 6f 00 72 00 61 00 73 00 20 00 72 00 65 00 6d 00 6f 00 74 00 61 00 73 00 00 00 ")]=["Spanish"]
        commentDict[binstring(" 1f 04 40 04 38 04 3d 04 42 04 35 04 40 04 4b 04 20 00 43 04 34 04 30 04 3b 04 35 04 3d 04 3d 04 3e 04 33 04 3e 04 20 00 34 04 3e 04 41 04 42 04 43 04 3f 04 30 04 00 00 ")]=["Russian"]
        commentDict[binstring(" 4d 00 69 00 63 00 72 00 6f 00 73 00 6f 00 66 00 74 00 20 00 57 00 69 00 6e 00 64 00 6f 00 77 00 73 00 2d 00 4e 00 65 00 74 00 7a 00 77 00 65 00 72 00 6b 00 00 00 ")]=["German"]
        commentDict['R\x00e\x00m\x00o\x00t\x00e\x00d\x00r\x00u\x00c\x00k\x00e\x00r\x00\x00\x00']=['German']
        commentDict[binstring(" 45 00 78 00 74 00 65 00 72 00 6e 00 65 00 20 00 70 00 72 00 69 00 6e 00 74 00 65 00 72 00 73 00 00 00 ")]=["Dutch"]
        commentDict[binstring(" 53 00 74 00 61 00 6d 00 70 00 61 00 6e 00 74 00 69 00 20 00 72 00 65 00 6d 00 6f 00 74 00 65 00 00 00 ")]=["Italian"]
        commentDict[binstring(" 5a 00 64 00 61 00 6c 00 6e 00 65 00 20 00 64 00 72 00 75 00 6b 00 61 00 72 00 6b 00 69 00 00 00 ")]=["Polish"]
        commentDict[binstring(" ea 30 e2 30 fc 30 c8 30 20 00 d7 30 ea 30 f3 30 bf 30 00 00 ")]=["Japanese"]
        commentDict[binstring(" d0 c6 a9 ac 20 00 04 d5 b0 b9 30 d1 00 00 ")]=["Korean"]
        commentDict[binstring(" dc 8f 0b 7a 53 62 70 53 3a 67 00 00 ")]=["Simplified Chinese"]
        commentDict[binstring(" 60 90 ef 7a 70 53 68 88 5f 6a 00 00 ")]=["Traditional Chinese"]
        commentDict[binstring(" 55 00 7a 00 61 00 6b 00 20 00 59 00 61 00 7a 00 31 01 63 00 31 01 6c 00 61 00 72 00 00 00 ")]=["Turkish"]
        commentDict[binstring(" 54 00 e1 00 76 00 6f 00 6c 00 69 00 20 00 6e 00 79 00 6f 00 6d 00 74 00 61 00 74 00 f3 00 6b 00 00 00 ")]=["Hungarian"]
        commentDict[binstring(" 56 00 7a 00 64 00 e1 00 6c 00 65 00 6e 00 e9 00 20 00 74 00 69 00 73 00 6b 00 e1 00 72 00 6e 00 79 00 00 00 ")]=["Czech"]
        commentDict[binstring(" 45 00 6b 00 73 00 74 00 65 00 72 00 6e 00 65 00 20 00 73 00 6b 00 72 00 69 00 76 00 65 00 72 00 65 00 00 00 ")]=["Norwegian"]
        commentDict[binstring(" 46 00 6a 00 e4 00 72 00 72 00 73 00 6b 00 72 00 69 00 76 00 61 00 72 00 65 00 00 00 ")]=["Swedish"]
        commentDict[binstring(" 91 03 c0 03 bf 03 bc 03 b1 03 ba 03 c1 03 c5 03 c3 03 bc 03 ad 03 bd 03 bf 03 b9 03 20 00 b5 03 ba 03 c4 03 c5 03 c0 03 c9 03 c4 03 ad 03 c2 03 00 00 ")]=["Greek"]
        commentDict[binstring(" 46 00 6a 00 65 00 72 00 6e 00 70 00 72 00 69 00 6e 00 74 00 65 00 72 00 65 00 00 00 ")]=["Danish"]
        commentDict[binstring(" 45 00 74 00 e4 00 74 00 75 00 6c 00 6f 00 73 00 74 00 69 00 6d 00 65 00 74 00 00 00 ")]=["Finnish"]

        for pp in pps:
            #name, description, comment
            comment=pp[2].encode('UTF-16LE') + '\x00\x00'
            langs=commentDict.get(comment,None)
            if not langs:
                continue
            #self.log(guessedlanguages)
            #self.log(langs)
            guessedlanguages=constrainlist(guessedlanguages,langs)
        return guessedlanguages
    
    def language_from_users(self, guessedlanguages):
        """
        Grab remote users - on Windows XP SP2 we will only be able to get logged in users 
        Then use this information to guess the language pack 
        """
        results=self.exploitnodes("userenum",args={"startrid": 512, "endrid": 514})
        if results in [None, [] ] :
            self.log("Could not get remote users")
            return guessedlanguages
        results=results[0] #only one node
        #this is a list of userenumu.user objects
        for user in results:
            if user.rid:
                self.log("%d: %s -> %s"%(user.rid,prettyprint(user.username),hexify(user.username) ) )     
        english={ 513: "\x44\x00\x6f\x00\x6d\x00\x61\x00\x69\x00\x6e\x00\x20\x00\x55\x00\x73\x00\x65\x00\x72\x00\x73\x00"}
        japanese={513: "\x6a\x30\x57\x30" }
            
        return guessedlanguages
        
    def language_from_shares(self, guessedlanguages):
        """
        A method of using the share name comments internationalization to determine language packs
        c.f. Kostya
        """
        #otherwise get the remote shares first
        results=self.exploitnodes("shareenum")
        #self.log("Results: %s"%results)
        if results in [None, []]:
            self.log("No shares found!")
            self.setInfo("No shares found!")
            return guessedlanguages

        commentIPCdict={}
        #also korean
        english=binstring("52 00 65 00 6d 00 6f 00 74 00 65 00 20 00 49 00 50 00 43 00 00 00")
        spanish=binstring("49 00 50 00 43 00 20 00 72 00 65 00 6d 00 6f 00 74 00 61 00 00 00")
        dutch=binstring("45 00 78 00 74 00 65 00 72 00 6e 00 65 00 20 00 49 00 50 00 43 00 00 00 ")
        tradchinese=binstring("60 90 ef 7a 20 00 49 00 50 00 43 00 00 00")
        simplchinese=binstring("dc 8f 0b 7a 20 00 49 00 50 00 43 00 00 00")
        commentIPCdict[english]=["English", "Arabic", "Hebrew", "Japanese", "Korean"]
        commentIPCdict[spanish]=["Spanish"]
        commentIPCdict[dutch]=["Dutch"]
        commentIPCdict[tradchinese]=["Traditional Chinese"]
        commentIPCdict[simplchinese]=["Simplified Chinese"]
        commentIPCdict["\x52\x00\x65\x00\x6d\x00\x6f\x00\x74\x00\x65\x00\x2d\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["German"]
        commentIPCdict["\x49\x00\x50\x00\x43\x00\x20\x00\x64\x00\x69\x00\x73\x00\x74\x00\x61\x00\x6e\x00\x74\x00\x00\x00"]=["French"]
        commentIPCdict["\x23\x04\x34\x04\x30\x04\x3b\x04\x35\x04\x3d\x04\x3d\x04\x4b\x04\x39\x04\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Russian"]
        commentIPCdict["\x49\x00\x50\x00\x43\x00\x20\x00\x72\x00\x65\x00\x6d\x00\x6f\x00\x74\x00\x6f\x00\x00\x00"]=["Italian","Portuguese"]
        commentIPCdict["\x46\x00\x6a\x00\xe4\x00\x72\x00\x72\x00\x2d\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Swedish"]
        commentIPCdict["\x45\x00\x6b\x00\x73\x00\x74\x00\x65\x00\x72\x00\x6e\x00\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Norwegian"]
        commentIPCdict["\x46\x00\x6a\x00\x65\x00\x72\x00\x6e\x00\x2d\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Danish"]
        commentIPCdict["\x56\x00\x7a\x00\x64\x00\xe1\x00\x6c\x00\x65\x00\x6e\x00\xfd\x00\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Czech"]
        commentIPCdict["\x5a\x00\x64\x00\x61\x00\x6c\x00\x6e\x00\x65\x00\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Polish"]
        commentIPCdict["\x54\x00\xe1\x00\x76\x00\x6f\x00\x6c\x00\x69\x00\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Hungarian"]
        commentIPCdict["\x55\x00\x7a\x00\x61\x00\x6b\x00\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Turkish"]
        commentIPCdict["\x45\x00\x74\x00\xe4\x00\x2d\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Finnish"]
        commentIPCdict["\x91\x03\xc0\x03\xbf\x03\xbc\x03\xb1\x03\xba\x03\xc1\x03\xc5\x03\xc3\x03\xbc\x03\xad\x03\xbd\x03\xbf\x03\x20\x00\x49\x00\x50\x00\x43\x00\x00\x00"]=["Greek"]


        #not used right now
        admindict={}
        spanish=binstring("41 00 64 00 6d 00 69 00 6e 00 20 00 72 00 65 00 6d 00 6f 00 74 00 61 00 00 00 ")
        dutch=binstring("42 00 65 00 68 00 65 00 65 00 72 00 20 00 6f 00 70 00 20 00 61 00 66 00 73 00 74 00 61 00 6e 00 64 00 00 00 ")
        tradchinese=binstring("60 90 ef 7a a1 7b 06 74 00 00")
        simplchinese=binstring("dc 8f 0b 7a a1 7b 06 74 00 00")
        korean=binstring("52 00 65 00 6d 00 6f 00 74 00 65 00 20 00 41 00 64 00 6d 00 69 00 6e 00 00 00 ")
        
        #comment dictionary for C$...
        commentCdict={}
        english=binstring("44 00 65 00 66 00 61 00 75 00 6c 00 74 00 20 00 73 00 68 00 61 00 72 00 65 00 00 00")
        spanish=binstring("52 00 65 00 63 00 75 00 72 00 73 00 6f 00 20 00 70 00 72 00 65 00 64 00 65 00 74 00 65 00 72 00 6d 00 69 00 6e 00 61 00 64 00 6f 00 00 00 ")
        dutch=binstring("53 00 74 00 61 00 6e 00 64 00 61 00 61 00 72 00 64 00 73 00 68 00 61 00 72 00 65 00 00 00 ")
        tradchinese=binstring("10 98 2d 8a 71 51 28 75 00 00 ")
        simplchinese=binstring("d8 9e a4 8b 71 51 ab 4e 00 00 ")
        commentCdict[english]=["English", "Arabic", "Hebrew", "Japanese", "Korean"]
        commentCdict[spanish]=["Spanish"]
        commentCdict[dutch]=["Dutch"]
        commentCdict[tradchinese]=["Traditional Chinese"]
        commentCdict[simplchinese]=["Simplified Chinese"]
        commentCdict["\x50\x00\x61\x00\x72\x00\x74\x00\x61\x00\x67\x00\x65\x00\x20\x00\x70\x00\x61\x00\x72\x00\x20\x00\x64\x00\xe9\x00\x66\x00\x61\x00\x75\x00\x74\x00\x00\x00"]=["French"]
        commentCdict["\x21\x04\x42\x04\x30\x04\x3d\x04\x34\x04\x30\x04\x40\x04\x42\x04\x3d\x04\x4b\x04\x39\x04\x20\x00\x3e\x04\x31\x04\x49\x04\x38\x04\x39\x04\x20\x00\x40\x04\x35\x04\x41\x04\x43\x04\x40\x04\x41\x04\x00\x00"]=["Russian"]
        commentCdict["\x43\x00\x6f\x00\x6e\x00\x64\x00\x69\x00\x76\x00\x69\x00\x73\x00\x69\x00\x6f\x00\x6e\x00\x65\x00\x20\x00\x70\x00\x72\x00\x65\x00\x64\x00\x65\x00\x66\x00\x69\x00\x6e\x00\x69\x00\x74\x00\x61\x00\x00\x00"]=["Italian"]
        commentCdict["\x53\x00\x74\x00\x61\x00\x6e\x00\x64\x00\x61\x00\x72\x00\x64\x00\x66\x00\x72\x00\x65\x00\x69\x00\x67\x00\x61\x00\x62\x00\x65\x00\x00\x00"]=["German"]
        commentCdict["\x50\x00\x61\x00\x72\x00\x74\x00\x69\x00\x6c\x00\x68\x00\x61\x00\x20\x00\x70\x00\x72\x00\x65\x00\x64\x00\x65\x00\x66\x00\x69\x00\x6e\x00\x69\x00\x64\x00\x61\x00\x00\x00"]=["Portuguese"]
        commentCdict["\x41\x00\x6c\x00\x61\x00\x70\x00\xe9\x00\x72\x00\x74\x00\x65\x00\x6c\x00\x6d\x00\x65\x00\x7a\x00\x65\x00\x74\x00\x74\x00\x20\x00\x6d\x00\x65\x00\x67\x00\x6f\x00\x73\x00\x7a\x00\x74\x00\xe1\x00\x73\x00\x00\x00"]=["Hungarian"]
        commentCdict["\x44\x00\x6f\x00\x6d\x00\x79\x00\x5b\x01\x6c\x00\x6e\x00\x79\x00\x20\x00\x75\x00\x64\x00\x7a\x00\x69\x00\x61\x00\x42\x01\x00\x00"]=["Polish"]
        commentCdict["\x53\x00\x74\x00\x61\x00\x6e\x00\x64\x00\x61\x00\x72\x00\x64\x00\x72\x00\x65\x00\x73\x00\x75\x00\x72\x00\x73\x00\x00\x00"]=["Swedish"]
        commentCdict["\x44\x00\x65\x00\x6c\x00\x74\x00\x20\x00\x73\x00\x74\x00\x61\x00\x6e\x00\x64\x00\x61\x00\x72\x00\x64\x00\x72\x00\x65\x00\x73\x00\x73\x00\x75\x00\x72\x00\x73\x00\x00\x00"]=["Norwegian"]
        commentCdict["\x4f\x00\x6c\x00\x65\x00\x74\x00\x75\x00\x73\x00\x72\x00\x65\x00\x73\x00\x75\x00\x72\x00\x73\x00\x73\x00\x69\x00\x20\x00\x28\x00\x6a\x00\x61\x00\x65\x00\x74\x00\x74\x00\x75\x00\x29\x00\x00\x00"]=["Finnish"]
        commentCdict["\x56\x00\xfd\x00\x63\x00\x68\x00\x6f\x00\x7a\x00\xed\x00\x20\x00\x73\x00\x64\x00\xed\x00\x6c\x00\x65\x00\x6e\x00\xe1\x00\x20\x00\x70\x00\x6f\x00\x6c\x00\x6f\x00\x7e\x01\x6b\x00\x61\x00\x00\x00"]=["Czech"]
        commentCdict["\x53\x00\x74\x00\x61\x00\x6e\x00\x64\x00\x61\x00\x72\x00\x64\x00\x73\x00\x68\x00\x61\x00\x72\x00\x65\x00\x00\x00"]=["Danish"]
        commentCdict["\xa0\x03\xc1\x03\xbf\x03\xb5\x03\xc0\x03\xb9\x03\xbb\x03\xb5\x03\xb3\x03\xbc\x03\xad\x03\xbd\x03\xb7\x03\x20\x00\xba\x03\xbf\x03\xb9\x03\xbd\x03\xae\x03\x20\x00\xc7\x03\xc1\x03\xae\x03\xc3\x03\xb7\x03\x00\x00"]=["Greek"]
        commentCdict["\x56\x00\x61\x00\x72\x00\x73\x00\x61\x00\x79\x00\x31\x01\x6c\x00\x61\x00\x6e\x00\x20\x00\x64\x00\x65\x00\x1f\x01\x65\x00\x72\x00\x00\x00"]=["Turkish"]

        for share in results[0]:
            self.log("Sharename=%s" % prettyprint(share.sharename))
            #look at IPC$ share first
            comment=share.comment
            for languageDetector in [("I\x00P\x00C\x00$\x00\x00\x00", commentIPCdict), ("C\x00$\x00\x00\x00",commentCdict)]:
                if (share.sharename.encode('UTF-16LE') + '\x00\x00') == languageDetector[0]:
                    self.log(u"%s Comment: %s" % (share.sharename, prettyprint(comment)))
                    encoded_comment = comment.encode('UTF-16LE') + '\x00\x00'
                    if encoded_comment in languageDetector[1].keys():
                        constrainTo = languageDetector[1][encoded_comment]
                        devlog("getremotelanguage","Constraining to: %s" % constrainTo)
                        guessedlanguages=constrainlist(guessedlanguages, constrainTo)

        
        return guessedlanguages

    def run(self):
        """
        runs the attempt to grab information
        """
        self.getArgs()
        self.setInfo("%s running against %s"%(NAME,self.host))
        if not self.forgetfull:
            kprim = self.target.get_knowledge("Language")
            #first check to see if we've already run this check!
            if kprim != None:
                #should we also if len(kprim)==1 ?
                self.result = kprim.known
                self.log("Already have Language in our knowledge tree - using %s"%self.result)
                return 1

        if self.state==self.HALT:
            return 0

        guessedlanguages=canvasos.win32languages[:]
        #first guess the language from a share comment
        guessedlanguages=self.language_from_shares(guessedlanguages)
        self.log("Guessed Languages Now: %s"%guessedlanguages)

        if self.state==self.HALT:
            return 0

        
        #next use IIS 404 pages
        if len(guessedlanguages) > 1:
            guessedlanguages=self.language_from_404(guessedlanguages)
            self.log("Guessed Languages Now: %s"%guessedlanguages)

            
        if self.state==self.HALT:
            return 0

        #next use print providers
        if len(guessedlanguages) > 1:
            if self.has_named_pipes(self.target):
                guessedlanguages=self.language_from_pp(guessedlanguages)
                self.log("Guessed Languages Now: %s"%guessedlanguages)

        if self.state==self.HALT:
            return 0
            
        if len(guessedlanguages) > 1:
            guessedlanguages=self.language_from_users(guessedlanguages)
            self.log("Guessed Languages Now: %s"%guessedlanguages)
        #next use WMI
        #next use SNMP
        #next use HP Insight Manager
        #next use etc, etc.
        
        self.setInfo("%s returned: %s"%(NAME, guessedlanguages))
        self.log("Guessed languages: %s"%guessedlanguages)
        self.target.add_knowledge("Language",guessedlanguages,100)

        self.new_event("remote language", {
            "remote_ip": str(self.target.interface),
            "language": guessedlanguages,
            })
        
        self.result=guessedlanguages
        if len(self.result)>1:
            self.log("Could not narrow language down to just one...")
            return 0
        return 1
        
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
