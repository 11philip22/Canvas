#! /usr/bin/env python
"""
scanner.py
Just scans the box

TODO: 

1. After host's are implemented, we need to be able to apply attributes to
them with a certainty level, then apply a fuzzy-logic to determine what OS it
is.
   
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="TestHost"
VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import os,getopt
import sys
if "." not in sys.path: sys.path.append(".")

import timeoutsocket
import socket
from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import time
from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

DOCUMENTATION={}
DOCUMENTATION["USAGE"]="The host entry can take in a network as well (192.168.1.0/24)"
DOCUMENTATION["Note"]="This only scans alive hosts."
NAME="Scanner"
DESCRIPTION="Scan the box for exploitability."
VERSION="0.1"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"
NOTES=""" 

"""
CHANGELOG="""

"""

from hostKnowledge import *

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.vulns          = []
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.istest         = 0
        self.setVersions()
        self.shellcode      = "A"
        self.localhost      = ""
        self.localport      = 0
        self.ssl            = 0
        self.doshell        = 1
        self.force          = 0
        self.name           = NAME
        self.netmask        = "32"
        #we set this to false so scanner doesn't run exploits 
        self.autohack_state =False 

    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """
        host=target.interface
        self.log("Running on %s"%host)
        exploitmods = canvasengine.exploitmodsGet()
        try:
            app=self.engine.getModuleExploit("osdetect")
            app.link(self)
            app.target=target
            app.run()
            myos=app.result
        except:
            import traceback
            traceback.print_exc(file=sys.__stdout__)
            self.log("Not determining OS - use osdetect exploit module")
            myos="Unknown"
            
            target.add_knowledge("OS", myos,100)

        totalmods=len(exploitmods)
        currentmod=1
        for module in exploitmods.values():
            if self.state==self.HALT:
                self.log("Halted.")
                self.setInfo("%s - (halted)"%NAME)
                return 0
            try:
                str="Scanning with %s"%module.DESCRIPTION
            except:
                try:
                    print "Could not find a description in %s"%module.NAME
                    str=module.NAME
                except:
                    print "Error: Module has no name?"
            self.log(str)
            #debug
            print str
            progress=round((currentmod*100)/totalmods)
            #print "CurrentMod %d Total Modules: %d Progress %d"%(currentmod,totalmods,progress)
            self.setProgress(progress)
            currentmod+=1
            try:
                app=module.theexploit()
            except:
                try:
                    mystr="No theexploit class in module %s"%module.DESCRIPTION
                except:
                    mystr="No theexploit class in module!"
                self.log(mystr)
                continue
            app.link(self)

            #set the defaults for exploits not using correct syntax
            defaultlist=["port","user","password","filename"]
            for i in defaultlist:
                if i in dir(app):
                    #print "FOUND: %s"%i
                    app.argsDict[i]=getattr(app,i)

            app.argsDict["passednodes"]=self.argsDict["passednodes"]
            app.argsDict["autohack_state"]=self.autohack_state
            defaultlist=["user","password","filename"]
            for i in defaultlist:
                if i in self.argsDict:
                    app.argsDict[i]=self.argsDict[i]
            app.target=target
            #print "ArgsDict=%s"%app.argsDict
            try:
                if app.test():
                    self.log("Module %s said host %s is potentially vulnerable"%(module.NAME,host))
                    self.vulns.append((host,module.NAME,module))
                    fromhost="127.0.0.1" #hard coded for now
                    #if self.engine:
                    #    self.engine.registerPotentialVuln(fromhost,host,module.__name__,module.DESCRIPTION)
                else:
                    #import traceback
                    #traceback.print_exc(file=sys.stdout)                        
                    self.log("Module %s said host %s is not potentially vulnerable"%(module.NAME,host))
            except:
                self.log("Test returned exception: fix this.")
                import traceback
                traceback.print_exc(file=sys.stdout)
        return
    
    def run(self):
        self.host=self.target.interface
        self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).split(".")[0])
        self.setInfo("Scanning %s"%(self.host))
        self.log("Interface=%s"%self.host)
        self.log("Netmask=%s"%self.netmask)
        self.vulns=[] #clear it
        #print ips

        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()
            
        self.run_on_all_alive_hosts()

        self.result=""
        self.log("-"*80)
        self.log("Printing all vulnerabilities found!")
        for v in self.vulns:
            self.log("Host: %s Vuln: %s"%(v[0],v[1]))
            self.result+="Vuln: %s\n"%(v[1])
        self.log("-"*80)
        self.setInfo("Scanning %s (done)"%(self.host))
        return 1
        
    
    def setVersions(self):
        self.versions={}
        #version array: name eip fp readable
        self.versions[1]=("All", None)
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
def usage():
    app = theexploit()
    print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
    app.displayVersions()

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
