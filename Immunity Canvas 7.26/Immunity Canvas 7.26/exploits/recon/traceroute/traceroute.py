#! /usr/bin/env python

# simple CANVAS traceroute utility
# v0.1

# XXX: these are just skeleton functions for now
# XXX: depending on how fancy we want to get :>

# TODO:
# - TCP SYN traceroute to port 80
#
# DONE:
# - UDP out / ICMP in basic traceroute

import sys
import time
import time

# construct/de-construct IP headers
class IPHeader:
    def __init__(self):
        return

# construct/de-construct TCP packets
class TCPacket(IPHeader):
    def __init__(self):
        IPHeader.__init__(self)
        return

# construct/de-construct UDP packets
class UDPacket(IPHeader):
    def __init__(self):
        IPHeader.__init__(self)
        return

# construct/de-construct ICMP packets
class ICMPacket(IPHeader):
    def __init__(self):
        IPHeader.__init__(self)
        return

# make available functions needed for a Traceroute
class UDPTraceroute(UDPacket, ICMPacket):
    def __init__(self, parent):
        import socket

        UDPacket.__init__(self)
        ICMPacket.__init__(self)

        self.target = "www.immunityinc.com"
        self.hopHost = ""
        self.maxHops = 30
        self.maxTry = 3
        self.maxLoop = 3
        self.sendSock = None
        self.recvSock = None
        self.srPort = 60423 # some random unlikely port val
        self.timeOut = 500 # ms
        self.parent=parent
        self.log=self.parent.log
        return

    # open/bind the sockets needed
    def initSockets(self):
        try:
            self.sendSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
            self.recvSock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
        except socket.error:
            return False

        # set the receive timeouts to something manageable
        if "win32" in sys.platform.lower():
            self.recvSock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, 500)
        if "linux" in sys.platform.lower():
            self.recvSock.settimeout(self.timeOut/100)
        # bind the ICMP socket for TIME_EXCEEDED/HOST_UNREACHABLE recvs
        self.recvSock.bind(("", self.srPort))
        return True 

    # close the sockets
    def closeSockets(self):
        self.sendSock.close()
        self.recvSock.close()
        return

    # dump a packet of a specific TTL on the wire
    def dumpPacket(self, ttl):
        # set sendSock TTL
        self.sendSock.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)
        # dump the BS ttl packet on the wire to the target host
        self.sendSock.sendto('', (self.target, self.srPort))
        return

    # parse a UDP or ICMP packet for wanted type/fields
    def parsePacket(self, raw):
        return

    # receive and return a packet type
    def recvPacket(self):
        # recv ICMP packet
        try:
            data, addr = self.recvSock.recvfrom(512)
        except:
            #print "[X] ICMP receive timed out ..."
            data = None
            addr = ('*', None)
        # if this is the same as targetHost, means we have a full route :>
        self.hopHost = addr[0]
        #print "[X] ICMP data dump:"
        #for c in data:
        #    print "%.2X"%ord(c),
        return data, addr

    # trace a route, return a list of hops
    def traceroute(self, host):

        ttl = 1
        route = []
        roundtrip = 0

        self.target = socket.gethostbyname(host)
        self.hopHost = "127.0.0.1"

        ret=self.initSockets()
        if not ret:
            return False
        
        # prevent looping on same ip
        noLoopHost = ''
        loopCount = 0
        
        while ttl <= self.maxHops:
            #self.initSockets() # XXX: debugging

            addedHop = False
            endRoute = False
            noLoopHost = self.hopHost
            
            for i in range(0, self.maxTry):
                self.log("Hop %d (try: %d)"% (ttl, i))

                # should give the CPU time on UNIX, but not on my box :(
                startTime = time.time()
                self.dumpPacket(ttl)

                data, addr = self.recvPacket() # this updates self.hopHost
                if noLoopHost == self.hopHost:
                    loopCount += 1
                    if loopCount == self.maxLoop:
                        print "Preventing traceroute loop"
                        endRoute = True
                        addedHop = True
                        break
                        #raise Exception, 'traceroute loop !'
                
                self.log(' ' + addr[0] + ' ')
                endTime = time.time()
                totaltime = (endTime - startTime) * 1000
                self.log("%4.4f ms\n"% totaltime)

                if addr[0] != '*':
                    route.append(addr[0])
                    # if hop == end of route, we're done ..
                    if addr[0] == self.target:
                        endRoute = True
                    addedHop = True
                    break

            if addedHop == False:
                print "[!] unknown hop !"
                route.append('*') # unknown hop
            if endRoute == True:
                print "[!] end of route reached ..."
                break
            ttl += 1
            #self.closeSockets() # XXX: debugging

        # done, clean up and return route list
        self.closeSockets()
        return route

# make available functions needed for a Traceroute
class TCPTraceroute(TCPacket, ICMPacket):
    def __init__(self, parent):
        import socket

        TCPacket.__init__(self)
        ICMPacket.__init__(self)

        self.target = "www.immunityinc.com"
        self.hopHost = ""
        self.maxHops = 30
        self.maxTry = 3
        self.maxLoop = 3
        self.sendSock = None
        self.recvSock = None
        self.srPort = 60423 # some random unlikely port val
        self.timeOut = 500 # ms

        self.endTCPRoute = False
        self.parent=parent
        self.log=self.parent.log
        return

    # open/bind the sockets needed
    def initSockets(self):
        """
        Returns true if successful
        """
        try:
            self.recvSock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
        except socket.error:
            self.log("Traceroute needs to be run as root under Linux")
            return False 

        # set the receive timeouts to something manageable
        if "win32" in sys.platform.lower():
            self.recvSock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, 500)
        if "linux" in sys.platform.lower():
            self.recvSock.settimeout(self.timeOut/100)
        # bind the ICMP socket for TIME_EXCEEDED/HOST_UNREACHABLE recvs
        self.recvSock.bind(("", self.srPort))
        return True 

    # close the sockets
    def closeSockets(self):
        self.recvSock.close()
        return

    # dump a packet of a specific TTL on the wire
    def dumpPacket(self, ttl):
        self.sendSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
        self.sendSock.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)
        self.sendSock.settimeout(self.timeOut/100)
        # dump the BS TCP SYN ttl packet on the wire to the target host
        hop = False
        try:
            self.sendSock.connect((self.target, 80))
        # except socket.error, e:
        except Exception, e:
                        
            if e[0] == 113:
                #print "[X] got no route to host error .. likely a hop :>"
                hop = True
            elif e[0] == 111:
                # connection refuse end of route (remain as False) 
                pass
            elif e[1] == 115:
                # a Timeout() exception has been raised, set a hop to
                # true so the TTL will get incremented and carry on
                hop = True
            else:
                import traceback
                traceback.print_exc(file=sys.stdout)
                raise Exception, e

        if hop == False:
            
            # if something else than 113 .. we found our host
            self.endTCPRoute = True

        self.sendSock.close()
        return

    # parse a UDP or ICMP packet for wanted type/fields
    def parsePacket(self, raw):
        return

    # receive and return a packet type
    def recvPacket(self):
        # if at end of route, return fake results (success!)
        if self.endTCPRoute == True:
            return "", (self.target, None)

        # recv ICMP packet
        try:
            data, addr = self.recvSock.recvfrom(512)
        except:
            #print "[X] ICMP receive timed out ..."
            data = None
            addr = ('*', None)
        # if this is the same as targetHost, means we have a full route :>
        self.hopHost = addr[0]
        #print "[X] ICMP data dump:"
        #for c in data:
        #    print "%.2X"%ord(c),
        return data, addr

    # trace a route, return a list of hops
    def traceroute(self, host):

        ttl = 1
        route = []
        roundtrip = 0
        try:
            self.target = socket.gethostbyname(host)
        except socket.gaierror:
            self.log("Traceroute: No address associated with hostname: %s"%host)

        self.hopHost = "127.0.0.1"

        ret=self.initSockets()
        if not ret:
            return False 
        
        noLoopHost = ''
        loopCount = 0
        
        while ttl <= self.maxHops:
            #self.initSockets() # XXX: debugging

            addedHop = False
            endRoute = False
            noLoopHost = self.hopHost
            
            for i in range(0, self.maxTry):
                sys.stderr.write("[!] hop %d (try: %d)"% (ttl, i))

                # should give the CPU time on UNIX, but not on my box :(
                startTime = time.time()
                try:
                    self.dumpPacket(ttl)
                except:
                    print "Failed retrieving TTL value"
                    break

                data, addr = self.recvPacket() # this updates self.hopHost
                if noLoopHost == self.hopHost:
                    loopCount += 1
                    if loopCount == self.maxLoop:
                        print "Preventing traceroute loop !"
                        endRoute = True
                        addedHop = True
                        break
                        #raise Exception, 'traceroute loop !'
                
                self.log(' ' + addr[0] + ' ')
                endTime = time.time()
                totaltime = (endTime - startTime) * 1000
                self.log("%4.4f ms\n"% totaltime)

                if addr[0] != '*':
                    route.append(addr[0])
                    # if hop == end of route, we're done ..
                    if addr[0] == self.target:
                        endRoute = True
                    addedHop = True
                    break

            if addedHop == False:
                print "[!] unknown hop !"
                route.append('*') # unknown hop
            if endRoute == True:
                print "[!] end of route reached ..."
                break
            ttl += 1
            #self.closeSockets() # XXX: debugging

        # done, clean up and return route list
        self.closeSockets()

        return route

# main CANVAS module code

import sys
if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit

NAME = "CANVAS Traceroute"
DESCRIPTION = "CANVAS Traceroute"
DOCUMENTATION = {}
VERSION = "1.0"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.mode = "TCP"
        return

    def getArgs(self):
        self.node = self.argsDict["passednodes"][0]

        # From the dialog
        self.mode = self.argsDict.get("scan_mode_value", self.mode)
        # or passed in by other modules.
        self.mode = self.argsDict.get("mode", self.mode)
        self.host= self.argsDict.get("host", self.target.interface)

    def usage(self):
        print "Usage: traceroute -t <host>"
    
    def checkLocalSegment(self, node, dst_ip):
        """ check if an ip is on the local segment for any of a node's interfaces """
        
        # XXX: eventually this needs to check the routing table for more complex subnetting layouts
        # XXX: but right now we just check if the mask is on the same subnet .. and if it is we skip it
        src_ips = node.interfaces.all_ips()
        for src_ip in src_ips:
            print "[X] checking %s against %s"% (src_ip, dst_ip)
            # XXX: only deals with 32 bit addresses
            try:
                src_mask = struct.unpack('>L', socket.inet_aton(src_ip))[0]
                dst_mask = struct.unpack('>L', socket.inet_aton(dst_ip))[0]
                if (src_mask & 0xffffff00) == (dst_mask & 0xffffff00):
                    print "[X] traceroute target seems to be on local network segment for node .. skipping traceroute .."
                    return True
            except socket.error, i:
                # Catches the exception when we inet_aton an ipv6 addr
                print "[X] Caught socket error: %s" % i
                
        return False
        
    # for external modules using this one ..
    def get_trace_class(self, mode):
        if 'TCP' in mode.upper():
            return TCPTraceroute(self)
        else:
            return UDPTraceroute(self)

    def run(self):

        self.getArgs()
        
        self.setInfo("%s (in progress)"%(NAME))
        for node in self.argsDict["passednodes"]:
            self.log("Tracerouting from node %s to %s" % (node.getname(), self.host))
            
            if self.checkLocalSegment(node, self.host) == True:
                hops = [self.target.interface]
            
            elif node.nodetype=="LocalNode" and node.hasRawSocks():
                self.log("Taking advantage of our raw sockets to do fast %s traceroute" % self.mode)
                if self.mode == "TCP":
                    CANVASRoute = TCPTraceroute(self)
                if self.mode == "UDP":
                    CANVASRoute = UDPTraceroute(self)

                # Traceroute class returns an orderered list of route hops
                hops = CANVASRoute.traceroute(self.host)
                if hops == False:
                    self.log("Could not run traceroute...not root?")
                    continue
                
            # XXX: move these to their own functions .. don't like big blobs of parsing code in main()
            else:
                self.log("No raw socket support on this node")
                if "Win32 Shell" in node.capabilities:
                    self.log("Using Win32 traceroute")
                    win32=True 
                    command="tracert -d %s"%self.host
                elif "Unix Shell" in node.capabilities:
                    self.log("Using Unix-style traceroute")
                    win32=False 
                    command="PATH=$PATH:/usr/sbin/:/sbin/ traceroute -n %s"%self.host
                else:
                    self.log("Don't know how to handle this Node: %s"%str(node.capabilities))
                    continue
                self.log("Command=%s"%command)
                self.log("Note: This may take a while.")
                ret=self.exploitnodes("runcommand",nodes=[node], args={"command": command})
                data=ret[0]
                hops=[]
                
                if win32:
                    #UNTESTED
                    lines = data.split("\n")
                    if len(lines)<=4:
                        self.log("Not enough data in Win32 tracert return")
                    else:
                        #got enough data, at least
                        lines=lines[4:]
                    for line in lines:
                        line=line.strip() #no spaces on front
                        if line=="": continue
                        if line.count("*")==3: continue
                        if line.count("Destination host unreachable"): continue
                        if line.count("tracing"): continue
                        if line.count("Trace complete"): continue #we're done
                        #otherwise last two are either hostname [ip] or just ip
                        #we need to make all "  " -> " " here first...
                        line=no_double_spaces(line)
                        line=line.split(" ")[7:]
                        if len(line)>1:
                            hostname=line[0]
                            ip=line[1].replace("[","").replace("]","")
                        else:
                            try:
                                ip=line[0]
                            except IndexError:
                                ip=None  #failed to parse properly!
                                
                        if ip!=None:
                            hops+=[ip]

                elif "Unix Shell" in node.capabilities:
                    #unix (aka linux) parsing
                    lines = data.split("\n")
                    if len(lines) > 1:                    
                        for line in lines[1:]: # Skip first line, which is target info, eg "66.175.114.214 (66.175.114.214), 30 hops max, 40 byte packets"
                            #ignore the MLPLS lines because we don't know what they are
                            if "MPLS" in line: continue
                            #ignore failures
                            if "* * *" in line: continue
                            #get rid of annoying header whitespace
                            line=line.strip()
                            #print "Line: %s"%line 
                            if len(line.split(" "))<=2:
                                continue
                            host=line.split(" ")[2]
                            hops+=[host]


            if len(hops) == 0:
                self.setInfo("%s - done (failed)"%(NAME))
                return 0

            else:

                trl = ""
                # print the route
                self.log("Resolving route ...")
                i = 1
    
                for hop in hops:
                    self.node.add_host(hop)
    
                    # Save some time and do not resolve local ips
                    if check_reserved(hop):
                        resolved = "Local IP"
                    else:
                        try:
                            resolved = socket.gethostbyaddr(hop)[0]
                        except:
                            resolved = "Unknown host"
    
                    self.log("%2d.\t"%i + hop + "\t(" + resolved + ")")
                    trl += "%2d.\t"%i + hop + "\t(" + resolved + ")\n"
                    i += 1
    
                self.target.replace_knowledge("TraceList",trl,100)
                self.result = hops

        self.setInfo("%s - done (success)"%(NAME))
        return 1

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
