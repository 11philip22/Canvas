#! /usr/bin/env python
"""
dcedump.py

dumps the data from the dce-rpc portmapper and returns the results
"""


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation
NAME="dcedump"

import getopt
import sys
if "." not in sys.path:
    sys.path.append(".")

import socket
from tcpexploit import tcpexploit
import canvasengine
import libs.newsmb.libdcerpc as libdcerpc
import libs.newsmb.epmap as epmap_ng
from libs.newsmb.epmap_ng import EPTClient, EPTHandle
from exploitutils import *

DOCUMENTATION = {}
DOCUMENTATION["Notes"] = """

The module runs a quick endpoint map dump. Uses port 135. This can be used to
determine the MSRPC (aka DCERPC) services listening on a remote machine. These
services can be on a named pipe or HTTP/TCP/UDP endpoint.

From this information you can manually determine whether a remote machine
is running IIS or another service, and can often determine which version of
Windows (or Samba) that machine is running.

"""

DESCRIPTION = "DCE Dumper"
VERSION = "1.0"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = ["All"]
NOTES="""

"""
CHANGELOG="""

"""

# Usage from another exploit:
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getEndpointbyUUID(self.UUID)
#
# For an protocol specific endpoint (You can, brute force if the UUID is not found with dcedump)
#
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getHTTPEndpoint()


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(135)
        self.setHost("")
        self.name = NAME
        self.user = ""
        self.password = ""
        self.domain = ""
        self.EPM = None
        self.UUID = ("e1af8308-5d1f-11c9-91a4-08002b14a0fa", "3.0")

    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.setPort(self.port)
        self.user = self.argsDict.get("user", self.user)
        self.password = self.argsDict.get("password", self.password)
        self.domain = self.argsDict.get("domain", self.domain)

    def tryConnect(self):
        bindlist = [ u'ncacn_np:%s[\\epmapper]' % self.host, "ncacn_ip_tcp:%s[%d]" % (self.host, self.port) ]
        for binding in bindlist:
            res = False
            auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
            auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
            if self.covertness >= 2:
                self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

            frag_level = None
            if self.covertness >= 5 and self.covertness < 11:
                self.log('Crypto + moderate SMB fragmentation')
                frag_level = 1
            elif self.covertness == 11:
                self.log('Crypto + MAX fragmentation')
                frag_level = 2

            try:
                self.EPM = EPTClient(self.host)
                self.EPM.set_credentials(username=self.user, password=self.password, domain=self.domain)
                res = self.EPM.bind()
                if res:
                    return True
                else:
                    raise libdcerpc.DCERPCException('no reason')
            except libdcerpc.DCERPCException, msg:
                self.log("Could not connect: %s" % msg)
                continue

            return False

    def test(self):
        self.getargs()
        self.log("Testing dcedump with user:password:domain=%s:%s:%s" % (self.user, self.password, self.password))
        if not self.tryConnect():
            return False

        self.log("Could bind to the epmapper")
        return True

    def run(self):
        self.result = None
        self.getargs()
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running" % (NAME, self.host,
                                                                       self.port,
                                                                       self.covertness))

        self.log("Running dcedump against  %s:%d" % (self.host, self.port))
        self.log("Running dcedump with user:password:domain=%s:%s:%s" % (self.user, self.password, self.domain))
        self.log("EPMapperDump: %s:%d Covertness:%d" % (self.host, self.port,
                                                        self.covertness))

        if not self.tryConnect():
            self.setInfo("%s attacking %s:%d (Covertness:%d) - done (failed"
                         % (NAME, self.host, self.port, self.covertness))
            return 0

        entries = self.EPM.ept_lookup()
        result = self.EPM.convert_entries(entries)

        if result in [None, []]:
            self.log("Nothing listening on that port or bind error, sorry")
            self.setInfo("%s attacking %s:%d (Covertness:%d) - done (failed)"
                         % (NAME, self.host, self.port, self.covertness))
            return 0

        result = map(lambda x: EPTHandle(x), result)
        ##Do the fancy data view stuff - call up to the method in canvasexploit that will do this for us
        c = []

        for e_h in result:
            self.log(e_h.getinfo())
            c.append([e_h.getinfo()])
        self.do_data_view(col_title=["DCEDUMP"], data=c)

        ##Rich mod TODO - need to functionalise this up into canvas exploit, use as a factory
        #if hasattr(self,  "dataviewcolumnsfunction") and hasattr(self, "dataviewinfofunction"):
            #col_title = ["DCEDUMP"]
            #self.DataViewColumns(col_title)
            #c = []

            #for e_h in result:
                #self.log(e_h.getinfo())

                #l = [e_h.getinfo()]
                #c.append(l)

                #self.result=result
            #self.DataViewInfo(c)

        self.result = result
        self.setInfo("%s attacking %s:%d (Covertness:%d) - done (success)" %
                     (NAME, self.host, self.port, self.covertness))
        return 1

    def getResults(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        if not self.tryConnect():
            return []

        return map(lambda x: EPTHandle(x), self.myDCE.dump())


    def getEndpointbyUUID(self, UUID):
        kprim = self.target.get_knowledge(UUID)
        if kprim:
            return kprim.known
        else:
            result = self.getResults()
            if not result:
                result=[] #no result is really no []
            map=[]
            for e_h in result:
                if e_h.isUUID(UUID):
                    tag = e_h.getendpoint(self.host)
                    if tag:
                        map.append(tag)
            self.target.add_knowledge(UUID, map, 100)

            return map
        return []

    def getProtoEndpoint(self, proto):
        proto=proto.lower()
        if proto == "tcp":
            return self.getTCPEndpoint()
        elif proto == "udp":
            return self.getUDPEndpoint()
        elif proto == "http":
            return self.getHTTPEndpoint()
        elif proto == "np":
            return self.getNPEndpoint()
        return []

    def getTCPEndpoint(self):
        kprim = self.target.get_knowledge("ncacn_ip_tcp")

        if kprim:
            return kprim.known
        else:
            result = self.getResults()

            map=[]
            for e_h in result:
                if e_h.isTCP():
                    map.append(e_h.getendpoint(self.host))
            self.target.add_knowledge("ncacn_ip_tcp", map, 100)

    def getUDPEndpoint(self):
        kprim = self.target.get_knowledge("ncacn_ip_udp")
        if kprim:
            return kprim.known
        else:
            result = self.getResults()
            map=[]
            for e_h in result:
                if e_h.isTCP():
                    map.append(e_h.getendpoint(self.host))
            self.target.add_knowledge("ncacn_ip_udp", map, 100)

    def getNPEndpoint(self):
        kprim = self.target.get_knowledge("ncacn_np")
        if kprim:
            return kprim.known
        else:
            result = self.getResults()
            map=[]
            for e_h in result:
                if e_h.isNP():
                    map.append(e_h.getendpoint(self.host))
            self.target.add_knowledge("ncacn_np", map, 100)

    def getHTTPEndpoint(self):
        kprim = self.target.get_knowledge("ncacn_http")
        if kprim:
            return kprim.known
        else:
            result = self.getResults()
            map=[]
            for e_h in result:
                if e_h.isHTTP():
                    map.append(e_h.getendpoint(self.host))
            self.target.add_knowledge("ncacn_http", map, 100)


if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
