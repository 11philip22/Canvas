#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
if '.' not in sys.path: sys.path.append('.')

from canvasexploit import canvasexploit
from exploitutils import *
from MOSDEF.mosdefutils import hexprint
import libs.newsmb.svcctl as svcctl

# GUI info
NAME          = 'Windows EnumServices'
DESCRIPTION   = 'Windows Remote Services Enumeration'
DOCUMENTATION = {}
DOCUMENTATION["Notes"] = """
This module will attempt to make MSRPC calls in order to retrieve the
list of services available on the remote machine (via the service
control manager). This is possible to do without authentication
against Windows 2000 SP4 (pre-Update Rollup) and is a valuable
part of your recon against these systems. You may see anti-virus
programs, HIDS, or other secondary protection layers via this module.

This module will list all the services available on a remote machine using a
named pipe that allows anonymous access. This will work against 2000 up to and
including SP4, but was fixed in Update Rollup 1 for SP4. Above that (UR1, XP),
a username and password will be needed.

"""
DOCUMENTATION['Date public']      = ''
DOCUMENTATION['References']       = ''
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = ''
VERSION                           = '2.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Recon'
PROPERTY['SITE']                  = 'Remote'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['2000', 'XP', '2003','2008']
NAME                              = DESCRIPTION
NOTES = """
"""

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name             = NAME
        self.host             = ''
        self.user             = u''
        self.password         = u''
        self.domain           = u''
        self.mySVC            = None
        self.datasize         = 0
        self.servicesdata     = ''
        self.autoversion      = 1
        self.port             = 445
        self.needsNoShellcode = True

    def getArgs(self):
        self.user     = self.argsDict.get('user', self.user)
        self.password = self.argsDict.get('password', self.password)
        self.domain   = self.argsDict.get("domain", self.domain)
        self.host     = self.target.interface

    def ServicesConnect(self):
        try:
            self.mySVC = svcctl.SVCCTLClient(self.host)
            self.mySVC.set_credentials(username=self.user, password=self.password, domain=self.domain)
            if not self.mySVC.bind():
                self.log('bind() failed.')
                return False
            else:
                self.log('Connected!')
                return True
        except Exception, msg:
            self.log(msg)
            self.log('Could not connect to remote server - service is not running or the host is firewalled.')
            return False

    def OpenSCManager(self):
        try:
            self.mySVC.open_manager()
            return True
        except Exception, msg:
            self.log('Failed to open service manager')
            self.log(msg)
            return False

    def CloseSCManager(self):
        try:
            self.mySVC.close_manager()
            return True
        except Exception, msg:
            self.log('Failed to close service manager')
            self.log(msg)
            return False

    def EnumServicesStatus(self):
        try:
            self.services = self.mySVC.get_services()
            return True
        except Exception, msg:
            self.log(msg)
            return False

    def parseServicesData(self, serviceslist):

        for service in self.services:
            name = service['ServiceName']
            displayname = service['DisplayName']
            self.log("Service found: %s:%s" % (prettyprint(name), prettyprint(displayname)))
            serviceslist[name] = displayname
        return serviceslist

    def run(self):
        self.setInfo('%s' % (NAME))
        self.getArgs()
        self.result = []
        node = self.argsDict['passednodes'][0]
        serviceslist = {}
        if node.islocal(self.host) and 'win32api' in node.capabilities:
            pass #TODO
        else:
            ret = self.ServicesConnect()
            if not ret:
                self.log('Could not open Services Endpoint!')
                self.result = serviceslist
                return 0

            self.log('Opened Services Endpoint')
            self.log('Opening Services Manager')

            ret = self.OpenSCManager()
            if not ret:
                self.log('Could not get a Service Manager handle')
                self.result = serviceslist
                return 0

            self.log('Enumerating Services')
            ret = self.EnumServicesStatus()
            if not ret:
                self.log('Could not enumerate services')
                return 0

            self.log('Closing Services Manager')
            ret = self.CloseSCManager()
            if not ret:
                self.log('Warning: Could not close services manager')

            self.log('Parsing Services Information')
            self.parseServicesData(serviceslist)

        self.result = serviceslist
        self.log('Number of services: %s' % len(serviceslist))
        self.target.replace_knowledge('services', serviceslist, 100)
        self.setInfo('%s - done (success: %s)' % (NAME, '%d services found' % len(serviceslist)))
        return 1

if __name__=='__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
