#! /usr/bin/env python

"""
smtp_fingerprint.py (sends requests and returns an smtp object
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import socket
import getopt
import sys

if "." not in sys.path:
    sys.path.append(".")



from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine

#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION["Notes"]="""

This module sends a series of malformed requests to the SMTP server in order
to find out the version of the SMTP server or Anti-Virus SMTP gateway. 

This module is used by the smtp_mass_scan (which takes a search query and
returns a list of mail servers).

Commandline Usage Example: dave@dave-maxtor ~/new/CANVAS $
exploits/smtp_fingerprint/smtp_fingerprint.py -t www.immunityinc.com -O
try_hard:1

The try_hard argument above will automatically get the mail exchanger for
your given host name. (i.e. mail.immunityinc.com in the above command).

"""
#DOCUMENTATION["Date public"]="00/00/0000"
#DOCUMENTATION["CERT Advisory"]=""
#DOCUMENTATION["CVE Name"]=""
#DOCUMENTATION["References"]=""

DESCRIPTION="Fingerprints SMTP servers by sending various requests"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NAME="SMTP Fingerprinter"

import os 

class smtp_recognizer(object):
    """
    This object stores information related to a particular kind of mail server
    and counts how many of the fingerprints for this mail server matched.
    We also store the hostname of the mail server.
    """

    def __init__(self, name):
        self.responsedict={}
        self.found=0
        self.version=""
        self.name=name
        self.banner=""
        self.mx_host=None #a.mx.immunityinc.com for example
        self.banner_string="" 
        self.gateway=None
        return 

    def get_banner(self, banner):
        """
        For the SMTP Banner
        """
        self.banner=banner
        if self.banner_string and self.banner_string in banner:
            self.found+=1
        if "Symantec" in banner:
            self.gateway="Symantec Mail Gateway"
        if "*****" in banner:
            self.gateway="PIX"
        return 
    
    def check_response(self, request, response):
        """
        request is a tuple of strings we send to the server followed by \r\n
        response is the last response
        """
        keylist=self.responsedict.get(request)
        if keylist==None:
            #this is not something we are looking for
            return 
        if type(keylist)==type(""): #just a string, not a list
            keylist=[keylist]
        #print "Keylist= %s"%keylist #for debug
        for key in keylist:
            if key and key in response:
                #matched our response
                print "%s: Matched %s -> %s"%(self.name,str(key), str(response)) #for debug
                self.found+=1
        return 
    
    def __str__(self):
        if self.gateway:
            gateway=" Gateway: %s"%self.gateway
        else:
            gateway=""
        return self.name+" "+self.version+gateway+" Banner: "+self.banner
    
#anything that needs special casing goes here
class viruswall(smtp_recognizer):
    """
    Special case class to handle versioning
    """
    def __init__(self):
        smtp_recognizer.__init__(self, "Trend Micro Interscan VirusWall")
        self.responsedict[("HELO fo","MAIL FROM: fo@fo@fo",)]="501 Syntax error"  #special case - see check_response()
        self.responsedict[("HELO fo","MAIL FROM: fo@hotmail.com","RCPT TO: fo@fo@fo@fo")]=["501 Syntax error in parameters scanning \"TO\"", "Invalid recipient address" ]
        #commented out - looks too much like an attack!
        #self.responsedict[("HELO "+"A"*6000,)]="Line too long."
        self.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]=["...Unbalanced < or >","illegal character(s) in domain string"]
        self.responsedict[("HELP noop",)]="Does nothing"
        self.responsedict[("HELP rset",)]="-Reset's SMTP state"
        
        return 

    def check_response(self, request, response):
        if request==("HELO fo","MAIL FROM: fo@fo@fo"):
            if "501 Syntax error in parameters scanning \"FROM\"" in response:
                self.version="6.0"
                self.found += 1
            if "illegal character(s) in domain string" in response:
                self.version="5.5"
                self.found+=1
        else:
            smtp_recognizer.check_response(self, request, response)
        return 
    
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name=NAME
        self.port=25
        self.banner=None 
        self.try_hard=0 #try to get MX if we cannot connect
        return

    def init_recognizers(self):
        gordano=smtp_recognizer("Gordano")
        gordano.responsedict[("HELP rset",)]="Gordano"
        gordano.responsedict[("HELP noop",)]="Gordano"
        #gordano.responsedict[("HELO "+"A"*6000,)]="Hostname is too long." #looks too much like an attack
        winwebmail=smtp_recognizer("winwebmail")
        winwebmail.responsedict[("HELP noop",)]="http://www.winwebmail.net"
        winwebmail.responsedict[("HELP rset",)]="http://www.winwebmail.net"
        postfix=smtp_recognizer("Postfix")
        postfix.responsedict[("HELP rset",)]="Error: command not recognized"
        postfix.responsedict[("HELO fo","MAIL FROM: fo@hotmail.com","RCPT TO: fo@fo@fo@fo")]="Recipient address rejected: need fully-qualified address"
        postfix.responsedict[('HELO fo', 'MAIL FROM: <fo@hotmail.com')]="Bad sender address syntax"
        communigate=smtp_recognizer("CommuniGate")
        communigate.responsedict[("HELP rset",)]="Stalker Software, Inc."
        communigate.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]="Incorrect Address Format"
        exim=smtp_recognizer("Exim")
        exim.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]="'>' missing at end of address"
        
        sendmail=smtp_recognizer("Sendmail")
        sendmail.responsedict[("HELP noop",)]="Do nothing."
        sendmail.responsedict[("HELP rset",)]="Resets the system."
        sendmail.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]="Unbalanced '<'"

        mailenable=smtp_recognizer("MailEnable")
        mailenable.responsedict[("HELP noop",)]="Help:->Supported Commands:"
        qmail=smtp_recognizer("Qmail")
        qmail.responsedict[("HELP noop",)]="netqmail home page: http://qmail.org/netqmail"
        qmail.responsedict[("HELO fo","MAIL FROM: fo@fo@fo",)]="250 ok"  
        exchange=smtp_recognizer("Exchange") #need a lot of work here for versioning
        exchange.responsedict[("HELP noop",)]=[
            "HELO EHLO STARTTLS RCPT DATA RSET MAIL QUIT HELP AUTH BDAT",
            "HELO EHLO STARTTLS RCPT DATA RSET MAIL QUIT HELP AUTH TURN ETRN BDAT VRFY" #version 6.0.3790.1830
            ]
        exchange.responsedict[ ('HELO fo', 'MAIL FROM: fo@fo@fo') ] = "5.5.4 Invalid Address"
        
        qpsmtp=smtp_recognizer("qpsmtp")
        qpsmtp.responsedict[("HELP rset",)]="This is qpsmtpd"
        qpsmtp.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]="could not parse your mail from command"

        barracuda=smtp_recognizer("Barracuda")
        barracuda.responsedict[("HELO fo","MAIL FROM: <fo@hotmail.com")]="Requested action not taken: mailbox name not allowed"
        barracuda.responsedict[("HELP rset",)]="Reset MAIL->RCPT->DATA transaction."
        
        self.recognizers=[viruswall(), gordano,winwebmail, postfix, communigate, sendmail, mailenable, exim, qmail,exchange]
        self.recognizers+=[qpsmtp, barracuda]
        # self.recognizers=[exchange] #for debug
        return 

    def getargs(self):
        self.port=int(self.argsDict.get('port', self.port))
        self.host=self.target.interface
        self.getarg("try_hard")

        return 
    
    def smtp_connect(self):
        sock=self.gettcpsock()
        sock.set_timeout(20) #these are slow servers!
        try:
            sock.connect((self.host, self.port))
        except:
            self.log("Could not connect to SMTP server")
            return None 
        #self.log("Waiting for banner")
        try:
            data=sock.recv(5000)
        except timeoutsocket.Timeout:
            self.log("No banner from SMTP?!?")
            sock.close()
            return None #error, so no socket 
        except:
            self.log("Connection died...")
            return None 
        self.banner=data 
        return sock 
    
    def send_request(self, requests):
        """
        Returns as a string our last response or "No response", etc
        """
        sock=self.smtp_connect()
        if not sock:
            self.log("Could not connect!")
            return "Could not connect"
        data=""
        for req in requests:
            try:
                sock.sendall(req+"\r\n")
            except:
                sock.close()
                return "Could not send data"
            try:
                data=sock.recv(5000)
            except:
                sock.close()
                return "Did not get any data"
        sock.close()
        return data 
            
    def run(self):
        """
        runs the attempt to grab information
        """
        self.getargs()
        sleeptime=0
        self.setInfo("SMTP Fingerprinter scanning %s"%self.host)
        self.init_recognizers()
        
        if self.try_hard:
            self.log("Trying hard to find an MX")
            #for use from the commandline - we look for whatever MX we can find.
            hostlist=split_host(self.target.resolved_from)
            self.log("Hostlist = %s"%hostlist)
            for host in hostlist:
                host=get_mx(host)
                if not host:
                    #self.log("Could not find mx")
                    continue
                self.log("Now using host: %s"%host )
                self.host=host
                break 

        #first check banner and make sure we can connect
        ret=self.smtp_connect()
        if not ret:
            self.log("Cannot connect to host %s:%d"%(self.host, self.port))
            return 0
        self.log("Got banner: %s"%self.banner)
        for rec in self.recognizers:
            rec.get_banner(self.banner)
        if "Symantec" in self.banner:
            sleeptime=60
        time.sleep(sleeptime)
        all_requests=[]
        #here we make a list of all the request tuples we want to send
        for rec in self.recognizers:
            all_requests+=rec.responsedict.keys() 
        all_requests=uniqlist(all_requests) 
        
        for requests in all_requests:
            self.log("Sending %s"%str(requests)[:100])
            response=self.send_request(requests)
            self.log("Response: %s"%response)
            for rec in self.recognizers:
                rec.check_response(requests, response)
            time.sleep(sleeptime)
        max=0
        max_rec=None 
        for rec in self.recognizers:
            if rec.found>max:
                max=rec.found
                max_rec=rec
                #print "MAX: %s"%max_rec.name

        self.log("Banner: %s"%self.banner)
        if max_rec:
            self.log("We found: %s version %s"%(max_rec.name, max_rec.version))
            self.log("Total score is %d out of %d"%(max, len(max_rec.responsedict.keys())))
            ret=1
            max_rec.mx_host=self.host #store this so we know what server we scanned
            self.result=max_rec
        else:
            self.log("No MTA or Gateway recognized for banner: %s!"%self.banner)
            ret=0
            self.result=None
            
        if self.result:
            self.setInfo("SMTP Fingerprinter scanned %s -> %s"%(self.host, self.result))
        else:
            self.setInfo("SMTP Fingerprinter scanned %s -> (Not known: %s)"%(self.host, self.banner))
        return ret 
            
    
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
