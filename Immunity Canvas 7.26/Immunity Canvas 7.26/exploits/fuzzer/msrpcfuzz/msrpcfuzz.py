#! /usr/bin/env python

"""
msrpcfuzz.py - an MSRPC fuzzer that uses the 3com ndr.py for marshalling

exploits/msrpcfuzz/msrpcfuzz.py -t 192.168.172.128 -O filename:fuzzers/idl/winxp/ipsecsvc.dll.idl 

"""

NOTES="""
On Win2k SP0 finds:
llssrv 
scesrv (???)
srvsvc (ms06_040)
mstask (???)
lsasrv (ms04_011)
"""

import traceback
import sys
if "." not in sys.path:
    sys.path.append('.')
import os , dircache
#from libs.dcemarshall import *
from libs.pymsrpc import parse
from libs.pymsrpc.tests.debug import print_hex, dump_ndr
from libs.pymsrpc.ndr import *
import libs.pymsrpc.ndr as ndr
import time

import msrpc
from exploitutils import *
from fuzzers.spike import *

from libs.pymsrpc.parse import parse_idl

def get_tcp_port(UUID,target):
    """
    Returns an integer on success, None on failure
    """
    log("Mapping %s on %s"%(UUID,target))
    port=msrpc.epmappertotcp(UUID,target) #from msrpc.py
    log("Found port %s"%port)
    return port

def log(msg):
    #fuzzer logger :>
    print "[F] %s"%msg

from msrpcexploit import *



NAME="msrpcfuzz"
DESCRIPTION="Fuzzer for MSRPC Endpoints"
DOCUMENTATION={}
DOCUMENTATION["Repeatability"]="Infinite - fuzzer"
DOCUMENTATION["Date public"] = "N/A"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Fuzzers"
PROPERTY['ARCH'] = [ ["Windows"] ]


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.idl=None
        self.myspike=spike()
        #use small stringset, for speed
        #or not, for lots of strings.
        self.string_set="small"
        self.myspike.init_spike_variables(stringset=small_string_set)
        self.user="Administrator"
        self.password="immunity"
        #integer fuzz is supremely slow, sorry. You get these sizeof * struct things and they just become huge.
        self.do_integer_fuzz=False
        #true when we want the NDR parser to get fuzz data and be updated
        self.fuzzing=True 
        self.default_strings=["DefaultString","","\\\\127.0.0.1\\","localhost","Administrator","A"*1024]
        self.default_ints=[1,0,-1,2,500,1024,10000]
        self.default_int=self.default_ints[0]
        self.default_string=self.default_strings[0]
        self.specificpipe=""
        self.filename=""
        self.needsNoShellcode=1
        self.do_context_handle_grab=False

        return 

    def getargs(self):
        self.host=self.target.interface

        self.getarg("filename")
        self.getarg("host")
        self.getarg("user")
        self.getarg("password")
        self.getarg("do_integer_fuzz")
        self.getarg("do_context_handle_grab")
        self.getarg("specificpipe")
        self.getarg("string_set")
        if self.string_set=="large":
            self.myspike.init_spike_variables()
        return 
    
    def get_fuzz_int(self):
        ret=self.myspike.get_int()
        if self.myspike.current_int==self.myspike.max_fuzz_int:
            self.myspike.current_int=0
            self.log("current_int == max_fuzz_int -> done with element")
            self.done_with_element=True
        return ret

    def get_fuzz_string(self):
        ret=self.myspike.get_string()
        if self.myspike.current_string==self.myspike.max_fuzz_string:
            self.myspike.current_string=0
            self.log("current_string == max_fuzz_string -> done with element")
            self.done_with_element=True
        return ret
    
    def buildConnectionList(self):
        return self.buildTCPConnectionList()
    
    def buildTCPConnectionList(self):
        """
        Specify endpoints for the attack
        """
        if self.connectionList!=[]:
            return self.connectionList 
        if self.port==0:
            #else generate
            self.connectionList=[]
            self.searchifids()
            
            if self.connectionList==[]:
                host=self.host
                pipes=["epmapper","browser","srvsvc","spoolss","wkssvc","dfssvc","locator"]
                pipes+=["AudioSrv","atsvc","cert","Ctx_Winstation_API_Service","dnsserver","DAV RPC SERVICE"]
                pipes+=["eventlog","HydraLsPipe","keysvc","llsrpc","lsarpc","msgsvc","nddeapi"]
                pipes+=["netlogon","ntsvcs","plugplay","policyagent","ipsec"]
                pipes+=["ProfMapApi","protected_storage","ROUTER"]
                pipes+=["samr","scerpc","SECLOGON","SfcApi","ssdpsrv"]
                pipes+=["svcctl","tapsrv","trkwks","W32TIME","W32TIME_ALT"]
                pipes+=["winlogonrpc","winreg","winspipe","pgpserv"]
                if self.specificpipe:
                    pipes=[self.specificpipe]
                for pipe in pipes:
                    self.connectionList+=['ncacn_np:%s[\\%s]'%(host,pipe)]
                self.connectionList+=['ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                                     'ncacn_ip_tcp:%s[445]'%(host),\
                                     'ncacn_ip_tcp:%s[1025]'%(host),\
                                     'ncacn_ip_tcp:%s[1026]'%(host),\
                                     'ncacn_ip_tcp:%s[1027]'%(host),\
                                     'ncacn_ip_tcp:%s[1028]'%(host)]
            else:
                self.log("Found self.connectionlist=%s"%self.connectionList)
        else:
            #user specified
            if self.namedpipe:
                if self.port in [139,445]:
                    self.connectionList += ["ncacn_np:%s[%s]"% (self.host,self.namedpipe)]                    
                else:
                    #tcp, I assume
                    self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,self.port)]
        return self.connectionList

    def get_fuzz_data(self, element):
        """
        We get a ndr object passed to us and we tell it what its data should be
        """
        if self.current_element> self.total_elements:
            self.total_elements=self.current_element

        string_fuzz_types=[ndr_string,ndr_wstring_nonconformant,ndr_wstring, ndr_string_nonconformant]
        #print "get_fuzz_data: %d"%self.current_element

        if not self.fuzzing:
            #if we're not fuzzing, we return a default object
            if type(element) in string_fuzz_types:
                #default string goes here
                #data="A"*2048 #long string
                #data="\\\\127.0.0.2\\" #unc path
                data=self.default_string
            elif type(element) == ndr_long:
                data=self.default_int #default int

            return data
        
        data=element.data 

        if self.fuzznum==self.current_element:
            self.ran_get_fuzz_data=True
            self.log("[*] Fuzznum reached %d/%d"%(self.fuzznum,self.total_elements))
            if type(element) in string_fuzz_types:
                if self.second_serialize:
                    data=self.myspike.last_got_string
                else:
                    data=self.get_fuzz_string()
                self.log("[*] Fuzzing string element(%d) [%d:%d]: %s"%(len(data),self.myspike.current_string,self.myspike.max_fuzz_string,prettyprint(data)[:100]))
            #I added this flag because we usually don't want to 
            #fuzz integers - it slows things down a LOT
            elif type(element) == ndr_long and self.do_integer_fuzz:
                if self.second_serialize:
                    data=self.myspike.last_got_integer
                else:
                    data=self.get_fuzz_int()
                self.log("[*] Fuzzing Integer Element [%d:%d]: %d"%(self.myspike.current_int, self.myspike.max_fuzz_int,self.myspike.last_got_integer)                )
            else:
                #don't need to fuzz this element. Not sure what it is.
                self.log("Don't need to fuzz this element - not sure what it is.")
                self.done_with_element=True
                self.next_fuzz_element=0
        else:
            self.max_fuzznum=False 
            #set it back to default
            if type(element) in string_fuzz_types:
                #default string goes here
                #data="A"*2048 #long string
                #data="\\\\127.0.0.2\\" #unc path
                data=self.default_string
                #if we're the next fuzz element, let's remember that so we can skip to us next.
                if self.next_fuzz_element==0 and self.current_element>self.fuzznum:
                    self.next_fuzz_element=self.current_element
                
            elif type(element) == ndr_long:
                data=self.default_int #default int
                #if we're the next fuzz element, let's remember that
                if self.do_integer_fuzz and self.next_fuzz_element==0 and self.current_element>self.fuzznum:
                    self.next_fuzz_element=self.current_element
        self.current_element+=1
        #self.log("Exit get_fuzz_data")
        return data 

    def get_context_handle(self, default_string, default_int, opcode, uuid):
        """
        Sends the request to get a context handle
        """
        self.mydce=None
            
        self.fuzzing=False #no fuzzing during this part
        old_default_int=self.default_int
        old_default_string=self.default_string
        ret="" #failure string
        self.default_string=default_string
        self.default_int=default_int
        self.log("[*] Trying to get context handle with default string: %s:%d from opcode %d"%(default_string,default_int, opcode.opnum))
        testpack=""
        for element in opcode.elements:
            try:
                testpack += element.serialize()
            except:
                self.log("[*] Serialization bug! Look into this later")
                continue

        request = opcode.serialize()
                        
        mydce=msrpc.DCE(uuid.ifid, uuid.version, self.connectionList)
        mydce.setUsername(self.user)
        mydce.setPassword(self.password)

        self.log("[*] Connecting to ifid: %s"%uuid.ifid)
        try:
            mydce.connect()
        except msrpc.DCEException, msg:
            self.log("[*] Couldn't connect to ifid %s!"%uuid.ifid)
            self.log("[*] During context_handle finding - this should never happen")
            self.log("[*] Killed service! %s with opcode %s"%(uuid.ifid, opcode.opnum))
            time.sleep(50)
            return ret
        
        self.log("[*] Connected")
        self.log("[*] Sending %s [opcode: %d]" % (uuid.ifid, opcode.opnum))
        self.log("[*] Length of request [%s]" % len(request)  )
        #self.log("[*] Request: %s"%print_hex(request))
        try:
            ret=mydce.call(opcode.opnum, request, response=1)
            self.log("[*] Sent - got ret")
        except msrpc.DCEException, msg:
            self.log("[*] DCE Exception: %s"%str(msg))
            return ""
        #otherwise, we got a response!
        recvbuffer=None
        if ret:
            recvbuffer=msrpc.get_all_stubs(ret)
        else:
            self.log("[*] No response received?")
        if recvbuffer:
            self.log("[*] Received [%s]" % print_hex(recvbuffer))
            if len(recvbuffer)<4:
                self.log("[*] Did not get enough data?!?")
                return ""
            rpcerror = struct.unpack("<L", recvbuffer[:4])[0]
            if rpcerror!=0: #RPC SUCCESS
                self.log("[*] Not successful at getting context handle with %s:%d"%(default_string, default_int))
                return ""
            if len(recvbuffer)>=24:
                context_handle = recvbuffer[:20]
                ret=context_handle
                self.mydce=mydce
                
        self.default_string=old_default_string
        self.default_int=old_default_int
        self.fuzzing=True 
        return ret 
        
    def try_to_get_context_handle(self, uuid):
        #using the current UUID, make requests until we get a context handle
        #and then store how we did that so that subsequent
        #fuzzing attempts can use it before running their fuzz request
        
        #first we set this to false since we are not fuzzing and 
        #don't want to update that data

        ret=False
        for opcode in uuid.opcodes:
            if not isinstance(opcode.out, ndr_context_handle):
                continue
            for default_int in self.default_ints:
                self.log("[*] Using default_int: %d"%default_int)
                self.default_int=default_int
                for default_string in self.default_strings:
                    self.default_string=default_string
                    context_handle=self.get_context_handle(default_string,default_int,opcode,uuid)
                    if context_handle:
                        self.log("[*] Context handle found!")
                        self.get_context_handle_opcode=(default_int, default_string, opcode)
                        ret=True
                        #for testing
                        #time.sleep(50)
                        break
                if ret:
                    break
            if ret:
                break 

        #reset these values
        self.default_int=self.default_ints[0]
        self.default_string=self.default_strings[0]

        return ret
        
    def reset_fuzzer(self):
        self.myspike.current_fuzz_variable=0
        self.myspike.current_string=0
        self.myspike.current_int=0
        return 

    def run(self):
        self.getargs()
        filename=self.filename
        if os.path.isdir(filename):
            self.log("Directory")
            idlfiles=dircache.listdir(filename)
        else:
            self.log("Just one file: %s"%filename)
            idlfiles=[filename]
        self.log("IdlFiles: %s"%idlfiles)
        for idlfilename in idlfiles:
            self.log( "Filename: %s"%idlfilename)
            if not idlfilename.count(".idl") and len(idlfiles)>1:
                continue
            try:
                idl = parse_idl(filename+"/"+idlfilename)
            except:
                try:
                    idl=parse_idl(idlfilename)
                except:
                    self.log("Failed to parse %s"%idlfilename)
                    import traceback
                    traceback.print_exc(file=sys.stderr)
                    continue
        
            if not idl:
                self.log("[!] idl parsing problem.")
                continue
            self.idl=idl
            self.log("Parsed IDL")
            self.run_on_idl()
        self.log("Done Fuzzing")
        return 

    def run_on_idl(self):
        """
        Set self.idl and then call this from run()
        """
        rpc=None
        send=True
        opnum=None #None is default
        context_handle=None #None is default
        DEBUG=False 
        idl=self.idl
        host=self.host
        skip_to_ifid="" #"" is default
        start_fuzznum=None #None is default
        
        #set the NDR fuzzer object
        ndr.g_fuzz_object=self
        #default strings 
        for self.default_string in self.default_strings:
            self.log("Set default string to %s"%repr(self.default_string))
            #default integers
            for self.default_int in self.default_ints:
                self.log("Set default integer to 0x%2.2x"%self.default_int)
        
                for uuid in idl:
                    self.UUID=uuid.ifid
                    if skip_to_ifid and not self.UUID==skip_to_ifid:
                        continue
                    if skip_to_ifid:
                        skip_to_ifid=""
                        
                    self.version=uuid.version
                    self.buildConnectionList()
                    self.log("Connectionlist=%s"%self.connectionList)
                    self.log("Connecting as %s:%s"%(self.user, self.password))
                    self.done_with_ifid=False 
                    #we'll set below variable when we find out that we both need
                    #a context handle, and know how to get one (using try_to_get_context_handle())
                    self.get_context_handle_opcode=None 
        
                    # We loop through all the opcodes for each uuid the parser gave us             
                    for opcode in uuid.opcodes:
                        self.log("Opcode: %s. Default int: %s Default String: %s"%(str(opcode.opnum), self.default_int, repr(self.default_string)))
                        self.did_connect=False
                        if self.done_with_ifid==True:
                            break 
                        #skip some opnums if needed
                        if opnum!=None:
                            if opcode.opnum != opnum:
                                continue
                            opnum=None #reset since we've skipped to it
                            
                        if len(opcode.elements)==0:
                            self.log("Not doing opcode %d, no elements"%opcode.opnum)
                            continue
                        self.opcode=opcode
                        self.done_with_opcode=False                 
                        #fuzznum is which variable to fuzz
                        if start_fuzznum!=None:
                            fuzznum=start_fuzznum
                            start_fuzznum=None
                        else:
                            fuzznum=0
                        self.max_fuzznum=False
                        self.next_fuzz_element=None #set to 0 to initialize search, set to a number for the next fuzz number

                        while not self.max_fuzznum:
                            self.log("Doing fuzznum: %d"%fuzznum)
                            #here we skip to the next element we're fuzzing if we found one!
                            if self.next_fuzz_element:
                                self.log("[*] Skipping to next fuzz element: %d"%self.next_fuzz_element)
                                fuzznum=self.next_fuzz_element
                                self.next_fuzz_element=None 
                            #this will be true if we did not find anything to fuzz in this opcode!
                            if self.next_fuzz_element==0:
                                self.log("[*] Nothing left to fuzz on this opcode!")
                                self.done_with_opcode=True 
                                
                            self.fuzznum=fuzznum
                            fuzznum+=1
                            self.done_with_element=False
                            self.total_elements=0
                            if self.done_with_opcode:
                                break 
                            #reset our fuzzer
                            self.reset_fuzzer()
                            while not self.done_with_element:
                                self.log("Doing element fuzz")
                                #first we connect
                                mydce=msrpc.DCE(uuid.ifid, uuid.version, self.connectionList)
                                mydce.setUsername(self.user)
                                mydce.setPassword(self.password)
        
                                self.log("[*] Connecting to ifid: %s"%uuid.ifid)
                                try:
                                    mydce.connect()
                                except msrpc.DCEException, msg:
                                    self.log("[*] Couldn't connect to ifid %s!"%uuid.ifid)
                                    self.done_with_opcode=True
                                    self.done_with_element=True
                                    self.done_with_ifid=True
                                    if self.did_connect:
                                        self.log("[*] Killed service! %s with opcode %s"%(uuid.ifid, opcode.opnum))
                                        time.sleep(50)
                                    break
                                self.did_connect=True 
                                
                                self.log("[*] Connected")
                                    
                                self.log("  opcode: %x elements: [%02d]" % (opcode.opnum, len(opcode.elements)))
                                
                                testpack = ""    
                                request = ""
                                
                                if self.get_context_handle_opcode:
                                    self.log("Getting context handle")
                                    default_int, default_string, context_opcode = self.get_context_handle_opcode
                                    context_handle=self.get_context_handle(default_string, default_int, context_opcode, uuid)
                                    self.log("Setting context handle to %s"%repr(context_handle))
                                    opcode.set_context_handle(context_handle)
                                    mydce=self.mydce #reset this to the same connection we had before when we were getting a context handle
                                    
                                #set our flag so we know it's there.
                                #if we for whatever reason don't have any string elements to fuzz
                                #then this will get us out of the loop
                                self.ran_get_fuzz_data=False
                                
                                self.current_element=0
                                self.second_serialize=False 
                                # Again I have to pass twice because of union dependencies
                                for element in opcode.elements:
                                    if DEBUG:
                                        dump_ndr(element)
                                    try:
                                        #self.log("DEBUG: element.serialize called on %s"%str(element))
                                        testpack += element.serialize()
                                    except:
                                        self.log("[*] Serialization bug! Look into this later")
                                        self.done_with_opcode=True
                                        self.done_with_element=True
                                        break
                                #self.log("DEBUG: Done with pass 1")
                                if self.done_with_element:
                                    self.log("Done with this element...")
                                    continue
                                #reset current_element?    
                                # This is all you do to serialize the data for the wire    
                                #self.log("Serializing a second time")
                                self.second_serialize=True 
                                self.current_element=0
                                request += opcode.serialize()
                                #self.log("Done with pass 2")
                                if len(request)!=len(testpack):
                                    self.log("[*] Length of testpack %d length of request %d"%(len(testpack),len(request)))
                                #self.log("Done serializing"
                                
                                if not self.ran_get_fuzz_data:
                                    #nothing to fuzz!
                                    self.log("[*] Nothing to fuzz on this opcode!")
                                    self.done_with_element=True
                                    self.done_with_opcode=True
                                    
                                
                                self.log("[*] Sending %s [opcode: %d]" % (uuid.ifid, opcode.opnum))
                                self.log("[*] Length of Fuzz Request [%s]" % len(request)  )
                                #self.log("[*] Request: %s"%print_hex(request))
                                try:
                                    ret=mydce.call(opcode.opnum, request, response=1)
                                    self.log("[*] Sent - got ret")
                                except msrpc.DCEException, msg:
                                    self.log("[*] Sent - got exception")
                                    if str(msg).count("1c00001a"):
                                        self.log("[*] Need a context handle!")
                                        #this is a tricky thing
                                        #we essentially need to go into the uuid and find 
                                        #the routine we can use to get the context handle
                                        #of course, this may require calling it with some sort
                                        #of valid argument, which we can't do
                                        #but we'll try
                                        if self.get_context_handle_opcode==False:
                                            self.log("[*] Need context handle, but can't get one")
                                            self.done_with_element=True 
                                            self.done_with_opcode=True 

                                            
                                        elif self.get_context_handle_opcode!=None:
                                            #in this case, we already had a context handle, 
                                            #so we're failing even WITH a context handle, so we bail
                                            self.log("[*] Failing even with context handle - bail")
                                            self.done_with_element=True 
                                            self.done_with_opcode=True 
                                        else:
                                            if self.do_context_handle_grab:
                                                self.log("[*] Trying to get context handle function")
                                                #we didn't have a context handle. So let's try to figure out how to get one
                                                if not self.try_to_get_context_handle(uuid):
                                                    self.log("[*] We tried, but failed to get a valid context handle!")
                                                    #set this so we don't try again
                                                    self.get_context_handle_opcode=False
                                                    self.done_with_element=True 
                                                    self.done_with_opcode=True 
                                        continue
                                    elif str(msg).count("6f7"):
                                        self.log("[*] Bad marshaller?")
                                        #not sure if I want this next line...
                                        self.done_with_element=True
                                        continue
                                    elif str(msg).count("received 5"):
                                        self.log("[*] Bad authentication")
                                        self.done_with_element=True
                                        self.done_with_opcode=True
                                        continue
                                    elif str(msg).count("Broken pipe"):
                                        self.log("[*] Broken pipe")
                                        continue
                                    elif str(msg).count("unpack requires a string argument of length"):
                                        self.log("[*] SMB error: %s"%msg)
                                        #essentially we are a size_is and we're sending huge amounts of data...no need to continue this.
                                        self.done_with_element=True
                                        continue
                                    elif str(msg).count("A failed packet received 1c00001b"):
                                        self.log("[*] Found memory leak vulnerability!")
                                        self.done_with_element=True
                                    elif str(msg).count("1c010003"):
                                        self.log("[*] No such interface, sorry")
                                        self.done_with_ifid=True
                                        self.done_with_element=True
                                        self.done_with_opcode=True
                                        continue
                                    elif str(msg).count("1c010002") or str(msg).count("c002002e"):
                                        self.log("[*] opcode is > than implemented opcodes!")
                                        self.done_with_ifid=True
                                        self.done_with_element=True
                                        self.done_with_opcode=True
                                        continue
                                    elif str(msg).count("1c000006"):
                                        self.log("[*] nca_s_fault_invalid_tag")
                                        #who knows?
                                        continue
                                    elif str(msg).count("1c000007"):
                                        self.log("[*] Invalid bound error")
                                        self.done_with_element=True
                                        continue
                                    elif str(msg).count("1c000017"):
                                        self.log("[*] Pipe Discipline fault")
                                        continue
                                    elif str(msg).count("timeout"):
                                        self.log("[*] Timeout on RECV - sitting in exception in debugger?")
                                        continue
                                    elif str(msg).count("Connection reset by peer"):
                                        self.log("[*] Connection reset by peer - very strange. Did someone kill the process?")
                                        continue
                                    else:
                                        self.log("msg: %s"%msg)
                                        raise
                                
                                recvbuffer=None
                                if ret:
                                    recvbuffer=msrpc.get_all_stubs(ret)
                                else:
                                    self.log("[*] No response received?")
                                if recvbuffer:
                                    self.log("[*] Received [%s]" % print_hex(recvbuffer))
    
                        
if __name__=="__main__":
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
