#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information

import gtk
from toolbar import VisualToolbar
from MOSDEF import mosdef
from exploitutils import *

#get devlog()
from internal import *

class Toolobject(VisualToolbar):
  NAME = "Jump"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "jump.ico"
  button_label = "Add Jump"
  button_tooltip = "Add Jump to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#ff9090"
  size = 40
  type = "random"
  boxargs={}
  object=None
  NumberofXp =1
  objectlist=[]
  jump=None
  index= None
  model= None
  offset=0
  offsetsize=0
  objsize = 0
  objectcomments = None
  objdict={}
  objpos={}
  tmp = None
  link = False
  
    
  
  def __init__(self):
    VisualToolbar.__init__(self)
    self.badchars=""

  def setSize(self, size):
    self.size =size
    
  def setArg(self,args): 
    if args.has_key('object'):
      self.object = args['object']
    
  def Show(self):
    
    if self.object != None:
      #return "Jump to: %s" % (self.object , str(self.objectlist[self.index-1].getNumber()))
      try:
        
        #self.getOffset()
        return "Jump to: %s\noffset: %s Size: %d" % (self.object,str(self.offsetsize), int(self.objsize))
        #print "offset: %s" %str(self.offsetsize)
        #return "Jump to: %s" % self.object 
      except:
        return "Jump to: %s Size: %d" % (self.object, int(self.objsize))
    else:
      return "Select where to jump"
    
  
  def Help(self):
    hlpstr="""The jump buffer option allows you to set a relative jmp instruction to a
different place in your buffer. This is useful in situations where
certain parts of your buffer get damaged or overwritten and you need to
skip those bad bytes when that part your buffer gets executed."

In x86, jumps are either two bytes or five bytes. A short jump of less than 127 bytes distance
will be a two byte jump. Anything larger will be five bytes. All jumps are relative jumps
and VisualSploit will calculate their value for you. 
    """
    return hlpstr

  def getOffset(self):
    """getoffset will calculate the jump offset to the chosen object"""
    #we need to know where the jump is now
    self.offsetsize=0
    xpacketobjs = [ r[3] for r in self.model ]
    
    for a in xpacketobjs:
      try:
        if a == self: 
          self.jump = a
        elif a == self.objectlist[self.index-1] :
          self.dest = a
      except:
        pass
      
    platform = self.getMOSDEFPlatform()
    try:
      if xpacketobjs.index(self.jump) > xpacketobjs.index(self.dest):
        #backwards offset
        calcoffset = xpacketobjs[xpacketobjs.index(self.dest) :xpacketobjs.index(self.jump)]
        #we now have a list of all the objects between ourselves and our target
        for a in calcoffset:
          size=a.getSize()
          devlog("jmp", "Found size of a=%s"%size)
          self.offsetsize -= size
        devlog("jmp", "Total offset=%s"%self.offsetsize)
        
        #now calculate the size of our instruction and subtract that too
        tmp = len(mosdef.assemble("jmp $%d" % self.offsetsize, platform))
        devlog("jmp", "Now subtracting %d from that to account for opcode size"%tmp)
        self.offsetsize -= tmp
        if tmp != len(mosdef.assemble("jmp $%d" % self.offsetsize, platform)):
            self.offsetsize -= len(mosdef.assemble("jmp $%d" % self.offsetsize, platform)) + tmp
        devlog("jmp", "Final offset is %d"%self.offsetsize)
      else:
        calcoffset = xpacketobjs[xpacketobjs.index(self.jump)+1:xpacketobjs.index(self.dest)]

        # calculating a FORWARD offset
        for a in calcoffset:
          self.offsetsize += int(a.getSize())
      #here we set the self.offset, which used to be an integer
      #to the opcodes for the jmp that we wanted to do.
      #which is strange. Not to mention it's never used in this
      #class. Where is it used? I'll comment it out for now.
      #self.offset = mosdef.assemble("jmp $%d" %self.offsetsize, platform)
      asm="jmp $%d"%self.offsetsize
      data= mosdef.assemble(asm, platform)
      self.objsize = len( data )
      if hasbadchar(data, self.badchars):
        self.log("Warning: our jump (%s) has a bad character!"%asm)
      devlog("jmp", "Jump is now: %s"%prettyhexprint(data))
    except:
      #import traceback,sys
      #traceback.print_exc(file=sys.stdout)
      print "Nothing to jump to..."
      return 
    
  def setDialog(self,widget,xpacket,badchars,arch):
    self.badchars=badchars
    hboxprepareobjs = widget.get_widget("vbox1") 
    model = xpacket.get_model()
    #if the setdialog is called from a loaded object
    self.model = model
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text('Where to jump?')
    xpacketobjs = [ r[3] for r in model ]
    self.objectlist=[]
    i=0
    for a in xpacketobjs:
      self.objectlist.append(a)
      #if a.NAME != "Jump":
      objname = a.NAME+" #%s" %str(a.getNumber())
      self.objdict[objname]=a
      i=i+1
      self.objpos[objname]=i
      prepareobjs.append_text(objname)
      prepareobjs.connect('changed', self.changeobjs)
    try:    
      pos=self.objpos[self.object]
      prepareobjs.set_active(int(pos))  
    except:
      prepareobjs.set_active(0)
    #self.boxargs['object'].split(" ")[0]
    
    #try:
    #  prepareobjs.set_active(xpacketobjs.index(self.boxargs['object'])+1)
    #except:
    # prepareobjs.set_active(0)  
    
      
  def preparedialog(self,widget,platlist,xpacket,badchars,arch):
    hboxprepareobjs = widget.get_widget("vbox1") 
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text('Where to jump?')
    prepareobjs.set_active(0)
    self.model = xpacket.get_model()
    xpacketobjs = [ r[3] for r in self.model ]
    self.objectlist=[]
    i=0
    for a in xpacketobjs:
      self.objectlist.append(a)
      if a.NAME == "Jump" and a.NAME != None:
        self.myjump=a
      objname = a.NAME+" #%s" %str(a.getNumber())
      self.objdict[objname]=a
      i=i+1
      self.objpos[objname]=i
      prepareobjs.append_text(objname)
    try:
      pos=self.objpos[self.object]
      prepareobjs.set_active(int(pos))  
    except:
      prepareobjs.set_active(0)
    prepareobjs.connect('changed', self.changeobjs)
  
  def changeobjs(self, combobox):
    try:
      self.tmp.setLink(False,None)
    except:
      pass
    model = combobox.get_model()
    self.index = combobox.get_active()
    self.boxargs['object']=model[self.index][0]
    self.setArg(self.boxargs)
    try:
      self.objdict[self.object].setLink(True,self)
      self.tmp = self.objdict[self.object]
    except:
      pass
    return
  
  

  def createPython(self):
    return ['buf+=mosdef.assemble(\"jmp $%d\", \"X86\")\n' % int(self.offsetsize)]
  
  
  def save(self):
    savedic={}
    savedic['object']=self.object
    savedic['offset']=self.offsetsize
    savedic['objectsize']=self.objsize
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    return savedic
    
  
  def load(self,args):
   if args.has_key('object'):
      self.object = args['object']
      
   if args.has_key('offset'):
     self.offsetsize = args['offset']
  
   if args.has_key('objectsize'):
     self.objsize= args['objectsize']
   
   if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
  

