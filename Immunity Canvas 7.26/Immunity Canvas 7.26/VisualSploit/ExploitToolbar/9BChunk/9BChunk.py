#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
  NAME = "Busy Chunk"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "bchunk.ico"
  button_label = "Add Busy Chunk"
  button_tooltip = "Add a Busy Chunk to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#31ce6f"
  size = 45
  type = "random"
  NumberofXp =1
  objsize = 4
  objectcomments = None
  link=False
  version=0

  
  def __init__(self):
    VisualToolbar.__init__(self)
    self.bc_size     = 0
    self.bc_psize    = 0
    self.bc_segndx   = 0
    self.bc_unused   = 0
    self.bc_smalltag = 0
    self.bc_flags    = 0

    self._FLAGS={"busy":0x1, "extrapresent":0x2, "fill":0x4, "valloc":0x8,\
                 "lastentry":0x10, "flag1": 0x20, "flag2":0x40, "flag3":0x80}

  def setSize(self, size):
    self.size =size
        
  def setFlags(self, args):
    for a in self._FLAGS.keys():
          pass

  def setArg(self,args):
    if args.has_key('size'):
       if args['size'] != "0x" and args['size'] != "": 
          self.bc_size     = int(args['size'],16)
    if args.has_key('psize'):
       if args['psize'] != "0x" and args['psize'] != "": 
          self.bc_psize    = int(args['psize'],16)
    if args.has_key('segndx'):
       if args['segndx'] != "0x" and args['segndx'] != "": 
          self.bc_segndx   = int(args['segndx'],16)
    if args.has_key('unused'):
       if args['unused'] != "0x" and args['unused'] != "": 
          self.bc_unused   = int(args['unused'],16)
    if args.has_key('smalltag'):
       if args['smalltag'] != "0x" and args['smalltag'] != "": 
          self.bc_smalltag = int(args['smalltag'],16)
    self.loadFlags(args)
    self.objsize=8
  
  def setDialog(self,dialog,xpacket,badchars,arch):
    wid = dialog.get_widget('size')
    wid.set_text('0x%04x' % self.bc_size )
    wid = dialog.get_widget('psize')
    wid.set_text('0x%04x' % self.bc_psize )
    wid = dialog.get_widget('segndx')
    wid.set_text('0x%02x' % self.bc_segndx)
    wid = dialog.get_widget('unused')
    wid.set_text('0x%02x' % self.bc_unused)
    wid = dialog.get_widget('smalltag')
    wid.set_text('0x%02x' % self.bc_smalltag)
    
    for k in self._FLAGS.keys():
         wid = dialog.get_widget(k)
         if self._FLAGS[k] & self.bc_flags:
            wid.set_active(True)
         else: 
            wid.set_active(False)
  
  def createRaw(self):
    return "\\x%02x"*8 % ( self.bc_size & 0xff,self.bc_size >> 8, self.bc_psize &0xff, self.bc_psize >>8,\
                           self.bc_segndx, self.bc_flags,self.bc_unused, self.bc_smalltag)

  def Show(self):
    return "Size:      0x%04x (0x%08x) PSize:      0x%04x (0x%08x)\n"\
           "Segndx: 0x%02x                            Flags:      0x%02x\n"\
           "Unused: 0x%02x                           SmallTag: 0x%02x\nRaw buffer: %s" %\
        (self.bc_size, self.bc_size*8, self.bc_psize, self.bc_psize*8,\
         self.bc_segndx, self.bc_flags, self.bc_unused, self.bc_smalltag, self.createRaw())
  
  def Help(self):
    helpstr="""Busy Chunk:

    This object is mainly used for MSRPC based exploits, and it 
    represent the stucture of memory dinamically allocated.

    Args:
    
    Size: size of the chunk (word)
    PrevSize: Size of the previous chunk (word)
    Segndx: 1 byte
    Chunk Flags
    Unused: 1 byte
    SmallTagNdx: 1 byte """
    return helpstr


  def createPython(self):
    return ["buf+= '%s'\n" % self.createRaw()]
  
  
  def save(self):
    savedic={}
    savedic['size']     = self.bc_size
    savedic['psize']    = self.bc_psize
    savedic['segndx']   = self.bc_segndx
    savedic['unused']   = self.bc_unused  
    savedic['smalltag'] = self.bc_smalltag
    savedic['flags']    = self.bc_flags
    savedic['objsize']  = self.objsize
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    return savedic
 
  def loadFlags(self, args):
    self.bc_flags = 0
    for k in self._FLAGS.keys():
       if args.has_key(k):
          if args[k] == True:
             self.bc_flags |= self._FLAGS[k]
  
  def load(self,args):
    if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
    if args.has_key('size'):
       self.bc_size     = int(args['size'])
    if args.has_key('psize'):
       self.bc_psize    = int(args['psize'])
    if args.has_key('segndx'):
       self.bc_segndx   = int(args['segndx'])
    if args.has_key('unused'):
       self.bc_unused   = int(args['unused'])
    if args.has_key('smalltag'):
       self.bc_smalltag = int(args['smalltag'])
    if args.has_key('flags'):
       self.bc_flags = int(args['flags'])

  def getDefaultTarget(self):
    return self.value
  
  def setVersion(self,default):
    self.version=default
  
