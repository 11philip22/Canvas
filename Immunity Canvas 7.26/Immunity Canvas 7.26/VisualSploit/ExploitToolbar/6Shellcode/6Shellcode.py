#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information


import gtk
from toolbar import VisualToolbar
from MOSDEF import mosdef
from vswin32shellcode import Win32Shellcode
from exploitutils import hasbadchar

#mostly for devlog()
from internal import *
from exploitutils import *

class Toolobject(VisualToolbar):
  NAME = "Shellcode"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "shellcode.ico"
  button_label = "Add shellcode"
  button_tooltip = "Add a shellcode to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#f7de00"
  size = 40
  boxargs={}
  code=""
  createsh=""
  type = "random"
  NumberofXp =1
  buf=[]
  objsize=0
  code_text=[]
  socket =0x00000000
  receive =0x00000000
  connect =0x00000000
  knownDict={}
  knownDict['MYWIN']=[socket,connect,receive]
  objectcomments = None
  link=False
  
  def __init__(self):
    VisualToolbar.__init__(self)
    self.shellcode = None
    self.offset_length=0 #our FindOffset shellcode length (in bytes)
    self.knownDict={} #empty at first
    self.start_character=0
    self.finish_character=256
    return 
  
  def setSize(self, size):
    self.size =size
    
  def setArg(self,args):
    print "ARGS: %s"%repr(args)
    if args.has_key('code'):
      self.code = args['code']

    if args.has_key('socket'):
      self.socket = args['socket']
    
    if args.has_key('connect'):
      self.connect = args['connect']
    
    if args.has_key('receive'):
      self.receive = args['receive']
    
    if self.receive and self.socket and self.connect:
      self.knownDict["MYWIN"]=[int(self.socket,16),int(self.connect,16),int(self.receive,16)]
    
    if args.has_key('createsh'):
      self.createsh = args['createsh']

    if "offset_length" in args:
      #print "Setting offset_length from dialog box!"
      self.offset_length=args["offset_length"]

    if "start_character" in args:
      self.start_character=int(args["start_character"])
    if "finish_character" in args:
      self.finish_character=int(args["finish_character"])

    #we use args2 here to not overwrite args dictionary in our incoming arguments
    args2={}
    args2["offset_length"]=self.offset_length
    args2["start_character"]=self.start_character
    args2["finish_character"]=self.finish_character
    self.shellcode = Win32Shellcode(self.badchar,self.knownDict,args2)
    
    self.code_text = self.shellcode.createPython(self.code)    
    self.objsize = self.shellcode.getShellcodeSize()
    
    return 
  
  def Show(self):
    return "%s\nSize: %d" % (self.code,int(self.objsize))
  
  def Help(self):
    if self.code and self.code != "Select Shellcode":
      if self.code == "Debug":
        return "a payload of interrupt instructions that will be caught in a\n\
debugger. You can use this to verify your exploit is working without\n\
actually using a full payload.\nSize: 1 byte."
      elif self.code =="Win32Shellcode":
        return "Standard Win32 callback shellcode.\nAproximate Size: 740 bytes "
      elif self.code == "Win32ThreadCallbackShellcode":
        return "Win32 callback shellcode that uses createthread.\nAproximate Size: 770 bytes "
      elif self.code == "Win32Peek":
        return "basic Win32 socket recycling payload that PEEKS on the sockets to see which one belongs to us.\nAproximated Size: 350 bytes."
      elif self.code == "KnownWin32Shellcode":
        return "a payload that uses predefined values for certain \n\
functions, resulting in a smaller payload. Service Pack specific.\nAproximate Size: 120 bytes"
      elif self.code == "TestShellcode":
        return "This is a shellcode that emits a pattern useful for testing for bad characters. You should see 01\\x01A02\\x02A...."
      elif self.code == "HeapSafeInject":
        return "a payload that injects itself into another process for \n\
situations where your target process is very unstable.\nAproximate Size: 1200 bytes."
      elif self.code == "SmallWin32Shellcode":
        return "a payload that uses ordinals instead of function hashing, resulting in a smaller payload.\nAproximated Size: 330 bytes."
      else:
        return "Help for this shellcode %s" %self.code
    elif self.code == "Select Shellcode":
      return "To get help, please select a shellcode and then click the question mark"
    else:
      return "To get help, please select a shellcode and then click the question mark"
  
  def setDialog(self,widget,xpacket,badchar,arch):
    self.badchar=badchar
    self.widget=widget
    badchar_table=self.widget.get_widget('badchar_table')
    offset_shellcode_table=self.widget.get_widget('offset_shellcode_table')

    if self.socket:
      socket=widget.get_widget('socket')
      socket.set_text(self.socket)
    if self.connect:
      connect=widget.get_widget('connect')
      connect.set_text(self.connect)
    if self.receive:
      receive=widget.get_widget('receive')
      receive.set_text(self.receive)
    self.arch = arch
    devlog("shellcode", "Badchars: %s" % prettyprint(badchar))
    hboxprepareobjs = widget.get_widget("hbox4") 
    model = xpacket.get_model()
    #if the setdialog is called from a loaded object
    self.model = model
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text('Select Shellcode')
    try:
      prepareobjs.set_active(self.object.index(self.boxargs['object'])+1)
    except: 
      prepareobjs.set_active(0)
    
    if arch == "Win32":
      # XXX: setear badchar aca tambien
      #badchar = "\x00\n"
      args={}
      args["offset_length"]=self.offset_length
      self.shellcode = Win32Shellcode(badchar,self.knownDict,args)
      
      for a in self.shellcode.getShellcodes():
        prepareobjs.append_text(a)
    #elif arch == "Linux":
    #  for a in self.Linux_dicc:
    #    prepareobjs.append_text(a)
      
    prepareobjs.connect('changed', self.changeobjs)    

    shellcodes=dict(map(lambda x: (x[1][0],x[0]),enumerate(prepareobjs.get_model())))
    prepareobjs.set_active(shellcodes.get(self.code,0))

    self.changeobjs(prepareobjs)
    return 
  
  def preparedialog(self,widget,platlist,xpacket,badchar,arch):
    self.widget=widget  
    self.badchar=badchar
    badchar_table=self.widget.get_widget('badchar_table')
    offset_shellcode_table=self.widget.get_widget('offset_shellcode_table')
    
    if self.socket:
      socket=widget.get_widget('socket')
      socket.set_text(self.socket)
    if self.connect:
      connect=widget.get_widget('connect')
      connect.set_text(self.connect)
    if self.receive:
      receive=widget.get_widget('receive')
      receive.set_text(self.receive)
    self.arch = arch
    devlog("shellcode", "Badchars: %s" % prettyprint(badchar))
    hboxprepareobjs = widget.get_widget("hbox4") 
    model = xpacket.get_model()
    #if the setdialog is called from a loaded object
    self.model = model
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text('Select Shellcode')
    try:
      prepareobjs.set_active(self.object.index(self.boxargs['object'])+1)
    except:
      prepareobjs.set_active(0)
    
    
    if arch == "Win32":
      #badchar = "\x00\n" 
      if not self.shellcode:
        args={}
        args["offset_length"]=self.offset_length
        self.shellcode = Win32Shellcode(badchar,self.knownDict, args)
      for a in self.shellcode.getShellcodes():
        prepareobjs.append_text(a)
        
    #elif arch == "Linux":
    #  for a in self.Linux_dicc:
    #    prepareobjs.append_text(a)
      
    prepareobjs.connect('changed', self.changeobjs)
    badchar_table.hide()
    offset_shellcode_table.hide()
    return 
      
  def createPython(self):
    return self.code_text + ["return self.shellcode\n"]
 
  def changeobjs(self, combobox):
    model = combobox.get_model()
    self.index = combobox.get_active()
    
    #here are the three tables we use to display options for different "shellcodes"
    knownbox=self.widget.get_widget('knownbox')
    badchar_table=self.widget.get_widget('badchar_table')
    offset_shellcode_table=self.widget.get_widget('offset_shellcode_table')
    
    self.boxargs['code']=model[self.index][0]
    self.boxargs['createsh']= model[self.index][0] #       self.win32_dicc[model[self.index][0]]
    if self.boxargs['code'] == "KnownWin32Shellcode":
      knownbox.show()
      socket=self.widget.get_widget('socket')
      socket.connect('changed', self.changedEntry)
      connect=self.widget.get_widget('connect')
      connect.connect('changed', self.changedEntry)
      receive=self.widget.get_widget('receive')
      receive.connect('changed', self.changedEntry)
    else:
      knownbox.hide()

    #second case is FindOffset
    if self.boxargs['code'] == "FindOffset":
      offset_shellcode_table.show()
      offset_length_widget=self.widget.get_widget("offset_length")
      offset_length_widget.set_value(self.offset_length)
      offset_length_widget.connect('changed', self.changedEntry)
    else:
      offset_shellcode_table.hide()
      
    #third case is TestShellcode
    if self.boxargs['code'] == "TestShellcode":
      #for finding bad characters - has a start and finish
      badchar_table.show()
      start_character_widget=self.widget.get_widget("start_character")
      start_character_widget.set_value(self.start_character)
      finish_character_widget=self.widget.get_widget("finish_character")
      start_character_widget.connect('changed', self.changedEntry)
      finish_character_widget.set_value(self.finish_character)
      finish_character_widget.connect('changed', self.changedEntry)
    else:
      badchar_table.hide()
      
    self.setArg(self.boxargs)
    return
 
  def changedEntry(self,knownvalue):
    """we always need to get knownvalues
    """
    print "ChangedEntry knownvalue=%s"%knownvalue.get_name()
    if knownvalue.get_name() == 'socket':
      self.socket=knownvalue.get_text()
    elif knownvalue.get_name() == 'connect':
      self.connect=knownvalue.get_text()
    elif knownvalue.get_name() == 'receive':
      self.receive=knownvalue.get_text()
    elif knownvalue.get_name() == 'offset_length':
      self.offset_length=knownvalue.get_value()
      #print "Self.offset_length=%d"%self.offset_length
    elif knownvalue.get_name() == 'start_character':
      self.start_character=knownvalue.get_value()
    elif knownvalue.get_name() == 'finish_character':
      self.finish_character=knownvalue.get_value()
    #this is not the best way to do it, but knownshellcode has a very particular usage
    try:
      self.knownDict["MYWIN"]=[int(self.socket,16),int(self.connect,16),int(self.receive,16)]
      #at this moment, we can create knownshellcode, and ONLY at this moment
      #set all args here
    except:
      pass 
    
    #unfortunately, we recreate our shellcode every time we "change" anything!?!?
    try:
      args={}
      args["offset_length"]=self.offset_length
      args["start_character"]=self.start_character
      args["finish_character"]=self.finish_character
      self.shellcode = Win32Shellcode(self.badchar,self.knownDict, args)
    except:
      pass
    
    return 
    
    
    

  
  def save(self):
    savedic={}
    savedic['code']=self.code
    savedic['createsh']=self.createsh
    savedic['objectsize']=self.objsize
    savedic['offset_length']=self.offset_length
    savedic["start_character"]=self.start_character
    savedic["finish_character"]=self.finish_character
    if self.socket:
      savedic['socket']=self.socket
    if self.connect:    
      savedic['connect']=self.connect
    if self.receive:
      savedic['receive']=self.receive
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    
    return savedic
    
 
  
  def load(self,args):
    if args.has_key('socket'):
      self.socket = args['socket']
    
    if args.has_key('connect'):
      self.connect = args['connect']
    
    if args.has_key('receive'):
      self.receive = args['receive']
    
    if self.receive and self.socket and self.connect:
      self.knownDict["MYWIN"]=[int(self.socket,16),int(self.connect,16),int(self.receive,16)]
      
    if args.has_key('code'):
      self.code = args['code']
      
    if args.has_key('createsh'):
      self.createsh = args['createsh']
        
    if args.has_key('objectsize'):
      self.objsize= args['objectsize']
      
    if args.has_key('arch'):
      self.arch= args['arch']
    
    if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
    
    if args.has_key('offset_length'):
      self.offset_length=int(args['offset_length'])
    
    self.start_character=int(args.get("start_character",0))
    self.finish_character=int(args.get("finish_character",256))
    
    if self.arch == "Win32":
      args2={}
      args2["offset_length"]=self.offset_length
      args2["start_character"]=self.start_character
      args2["finish_character"]=self.finish_character
      
      self.shellcode = Win32Shellcode(args['badchars'],self.knownDict,args2)
      self.code_text = self.shellcode.createPython(self.code)    
      self.objsize = self.shellcode.getShellcodeSize()


  
