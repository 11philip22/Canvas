#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information

import gtk
from toolbar import VisualToolbar
from MOSDEF import mosdef
from gettext import gettext as N_

class Toolobject(VisualToolbar):
  NAME = "Pad2Length"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "pad2length.ico"
  button_label = "Add Padding"
  button_tooltip = "Add Pad to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#B3E718"
  size = 40
  type = "random"
  boxargs={}
  NumberofXp =1
  index= 0
  model= None
  offset=0
  padbytes=0
  buffer=0
  objsize = 0
  objectcomments = None
  bufdic={}
  topad=0
  bufsize=0
  link=False
  
    
  
  def __init__(self):
    VisualToolbar.__init__(self)


  def setSize(self, size):
    self.size =size
    
  def setArg(self,args):  
    if args.has_key('buffer'):
      self.buffer = args['buffer']
    if args.has_key('padbytes'):
      self.padbytes = args['padbytes']
    
    
  
    
  
  def Show(self):
    if self.topad < 0:
      self.topad=0
    if self.buffer != None:
      try:
        return "PAD Buffer %s TO: %d BYTES\nPad Size: %s bytes" % (self.bufdic[self.buffer], int(self.padbytes),self.topad)
      except:
        return N_("Select buffer to pad")
    else:
      return N_("Select buffer to pad")
    
  
  def Help(self):
    hlpstr="""This object takes in another buffer and
pads it to a certain length and includes it in another buffer. This
is essential because our shellcode will be a different size potentially
every time it is created.
    """
    return hlpstr

  def getPad(self):
    """how many bytes to pad"""
    self.bufsize=0
    try:
      model=self.xpacketlist[int(self.bufdic[self.buffer])-1].get_model()
      for a in model:
        self.bufsize+=a[3].getSize()
      self.topad = int(self.padbytes) - self.bufsize
      self.objsize=self.padbytes
    except: 
      pass
      
  
  
  def setDialog(self,widget,xpacket,badchars,arch):
    padbytes=widget.get_widget('padbytes')
    padbytes.set_value(float(self.padbytes))
    hboxprepareobjs = widget.get_widget("vbox1") 
    #if the setdialog is called from a loaded object
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text(N_('Buffer to pad?'))
    i=0
    for a in self.xpacketlist:
      if i==self.xpacketlist.index(xpacket):
        pass
      else:
        self.bufdic[N_("Buffer %s") %str(self.xpacketlist.index(a)+1)]= "%s" %str(self.xpacketlist.index(a)+1)
        prepareobjs.append_text(N_("Buffer %s") %str(self.xpacketlist.index(a)+1))
        prepareobjs.connect('changed', self.changeobjs,widget)
      i=i+1
    try:    
      pos = self.index
    except:
      pos=0
    prepareobjs.set_active(int(pos))  
    #self.boxargs['object'].split(" ")[0]
    
    #try:
    #  prepareobjs.set_active(xpacketobjs.index(self.boxargs['object'])+1)
    #except:
    # prepareobjs.set_active(0)  
    
      
  def preparedialog(self,widget,platlist,xpacket,badchars,arch):
    padbytes=widget.get_widget('padbytes')
    padbytes.set_value(self.padbytes)
    hboxprepareobjs = widget.get_widget("vbox1") 
    prepareobjs = gtk.combo_box_new_text()
    hboxprepareobjs.pack_start(prepareobjs,expand=True, padding=0)
    prepareobjs.show()
    prepareobjs.append_text(N_('Buffer to pad?'))
    prepareobjs.set_active(0)
    i=0
    for a in self.xpacketlist:
      if i==self.xpacketlist.index(xpacket):
        pass
      else:
        self.bufdic[N_("Buffer %s") %str(self.xpacketlist.index(a)+1)]= "%s" %str(self.xpacketlist.index(a)+1)
        prepareobjs.append_text(N_("Buffer %s") %str(self.xpacketlist.index(a)+1))
        prepareobjs.connect('changed', self.changeobjs,widget)
      i=i+1
    try:
      pos=self.index
    except:
      pos=0
    prepareobjs.set_active(int(pos))  
    
  def changeobjs(self, combobox,widget):
        #try:
        #  self.tmp.setLink(False,None)
        #except:
        #  pass
        model = combobox.get_model()
        self.index = combobox.get_active()
        self.boxargs['buffer']=model[self.index][0]
        self.setArg(self.boxargs)
        padbytes=widget.get_widget("padbytes")
        self.getPad()
        padbytes.set_range(self.bufsize, 999999)
        if self.padbytes < self.bufsize:
          padbytes.set_value(self.bufsize)
        return
      
  def getBuffer(self):
    return self.buffer

  def createPython(self):
    buf=[]
    buf.append('temp=self.createxPacket%s()\n' %(str(self.bufdic[self.buffer])))
    buf.append('buf+=temp\n')
    buf.append('buf+="A" * (%s-len(temp)) #padding %s bytes\n' % (self.padbytes,str(self.topad)))
    return buf
  
  
  def save(self):
    savedic={}
    buf=""
    for a in self.bufdic.keys():
      buf+=self.bufdic[a]+":"+a+"|"
    savedic['bufdic']=buf
    savedic['index']=self.index
    savedic['buffer']=self.buffer
    savedic['topad']=self.topad
    savedic['padbytes']=self.padbytes
    self.objsize=self.padbytes
    savedic['bufsize']=self.bufsize
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    return savedic
    
  
  def load(self,args):
  
   if args.has_key('bufdic'):
     values=args['bufdic'].split("|")
     for a in values[:-1]:
       t=a.split(":")
       self.bufdic[t[1]]=t[0]
   if args.has_key('index'):
     self.index = args['index']
  
   if args.has_key('buffer'):
     self.buffer=args['buffer']
      
   if args.has_key('topad'):
     self.topad = args['topad']
  
   if args.has_key('padbytes'):
     self.padbytes = args['padbytes']
     self.objsize=self.padbytes
   
   if args.has_key('bufsize'):
     self.bufsize = args['bufsize']
   
   if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
  
