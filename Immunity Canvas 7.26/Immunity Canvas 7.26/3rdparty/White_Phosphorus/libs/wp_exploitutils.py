
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################

"""
wp_exploitutils.py
"""

CHANGELOG="""

"""
######################################################################################

import os,getopt
import sys
from struct import *
from exploitutils import *

import time

######################################################################################
# Functions for finding badchars and max length etc
###################################################################################### 

######################################################################################
# wp_badchars
###################################################################################### 
def wp_badchartest(start=0,end=255,badchars=""):
    """
    Calls down to exploitutils.badchartest()
    used for generating strings to test for bad characters
    Generates strings such as:
    \x00\x01\x02...\xff that won't contain any characters in badchars argument, which should
    be a string (from self.badchars, typically).
    """
    return badchartest(start,end,badchars)



######################################################################################
# Functions to test if target is vulnerable
######################################################################################

######################################################################################
# Function to check if port is open
######################################################################################
def wp_isPortOpen(self,host,port):
    self.log("WP> Checking for open port %s:%d"%(host,port))
    s=self.gettcpsock()
    try:
        s.connect((host, port))
    except:
        self.log("WP> Port was closed")
        return 0
    s.close()
    self.log("WP> Port was open!")
    return 1
        
######################################################################################
# Banner checking
######################################################################################        
def wp_bannerchecktest(self,host,port,bannersDict,datasize=1000,sendstr=None,sleeptime=0.5,ssl=0):
    """
    Useful routine to look for a banner in our returned data and set our version
    Modified to allow setting the host:port
    """
    self.log("WP> Checking banner at %s:%s"%(host,port))
    s=self.gettcpsock()
    try:
        s.connect((host, port))
        if ssl:
            self.ssl=1
        if sendstr:
            self.log("WP> Sending %s"%sendstr)
            self.websend(s,sendstr)
        time.sleep(sleeptime)
        data=self.webrecv(s,datasize)
        self.log("WP> Received: %s"%prettyprint(data))
    except:
        #import traceback
        #traceback.print_exc(file=sys.stdout)
        self.log("WP> No connection could be established")
        return 0
    for key in bannersDict:
        if key in data:
            #self.version=bannersDict[key]
            #self.log("WP> Banner matched vulnerable targetversion %s: %s"%(self.version,self.versions[self.version][0]))
            self.log("WP> Banner matched vulnerable target")
            return 1
    self.log("WP> Banner did not match vulnerable target")
    return 0        
    
######################################################################################
# wp_ftplogin
######################################################################################     
def wp_ftplogin(self):
    """
    Connects to a remote FTP server and logs in returns socket if successful
    otherwise 0
    """
    s=self.gettcpsock()
    try:
        self.log("WP> Connecting to target: %s:%d"%(self.host,self.port))
        s.connect((self.host, self.port))
    except:
        self.log("WP> No connection could be established")
        self.result_error=self.ERR_COULD_NOT_CONNECT
        return 0
    try:
        data=s.recv(5000)
    except timeoutsocket.Timeout:
        data=""
    self.log("WP> FTP Banner: %s"%prettyprint(data))
    self.log("WP> Sending: USER %s"%self.user)
    
    s.sendall("USER %s\r\n"%self.user)
    try:
        data=s.recv(5000)
    except:
        self.log("WP> No USER response")
        return 0
    self.log("WP> FTP Response: %s"%prettyprint(data))
    
    self.log("WP> Sending: PASS %s"%self.password)
    s.sendall("PASS %s\r\n"%self.password)
    try:
        data=s.recv(5000)
    except:
        self.log("WP> No PASS response")
        return 0
    self.log("WP> FTP Response: %s"%prettyprint(data))
    if "530" in data:
        self.log("WP> Login failed.")
        self.result_error=self.ERR_NO_LOGIN
        return 0
    #sucess, return socket
    return s     

######################################################################################
# Random string generators
###################################################################################### 
    
def wp_randomstring(length,badchars=""):
    """
    used for generating random strings 
    """
    ret=""
    import random
    
    for x in range(0,length):
        c = random.choice("ABCDEFGHIJKLMNOPQRSTUVWYXZabcdefghijklmnopqrstuvwxyz")
        if c not in badchars:
            ret+=c
    return ret        


######################################################################################
# Random nop generator
###################################################################################### 

def wp_randomnops(length, badchars=""):
    """
    used for generating random nop slides 
    """
    import random
    ret=""
    #nops = [
        #"\x27","\x2f","\x37","\x3f","\x40","\x41","\x42","\x43","\x44",
        #"\x45","\x46","\x47","\x48","\x4a","\x4b","\x4c","\x4d","\x4e",
        #"\x4f","\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57",
        #"\x58","\x59","\x5a","\x5b","\x5d","\x5e","\x5f","\x60","\x90",
        #"\x91","\x92","\x93","\x95","\x96","\x97","\x98","\x99","\x9b",
        #"\x9c","\x9e","\x9f","\xf5","\xf8","\xf9","\xfc"]
        
    nops = [
        "\x27","\x2f","\x37","\x3f","\x40","\x41","\x42","\x43",
        "\x46","\x47","\x48","\x4a","\x4b","\x4e",
        "\x4f","\x90","\x91","\x92","\x93","\x95","\x96","\x97","\x98",
        "\x99","\x9b","\x9e","\x9f","\xf5","\xf8","\xf9","\xfc"]        

    while len(ret) < length:
        c = random.choice(nops)
        if c not in badchars:
            ret+=c
    return ret    

######################################################################################
# wp_insertdata
###################################################################################### 

def wp_insertdata(data,location,insert):
    return data[:location] + insert + data[location+len(insert):]
	    
######################################################################################
# wp_urluencode
###################################################################################### 

def wp_urluencode(data):
    """
    Automatically adjust to the correct length
    """
    if len(data) % 2:
            data += 'A'
    return urluencode(data)      
    
######################################################################################
# wp_browserinfo
###################################################################################### 

def wp_browserinfo(useragent):
    """
    Attempts to return the browser and OS version from an IE userstring
    """
    browser=""
    osversion = ""

    # find Firefox
    if "Firefox" in useragent:
        start = useragent.find("Firefox")
        end = useragent.find(" ",start)
        if end > 0:
            browser = useragent[start:end]
        else:
            browser = useragent[start:]
    #IE
    elif "MSIE" in useragent:
        start = useragent.find("MSIE")
        end = useragent.find(";",start)
        if end > 0:
            browser = useragent[start:end]
        else:
            browser = useragent[start:]            
    # Chrome
    elif "MSIE" in useragent:
        start = useragent.find("Chrome")
        end = useragent.find(" ",start)
        if end > 0:
            browser = useragent[start:end]
        else:
            browser = useragent[start:]                        
    # Safari            
    elif "Safari" in useragent:
        start = useragent.find("Version")
        end = useragent.find(" ",start)
        if end > 0:
            browser = "Safari " + useragent[start:end]
        else:
            browser = "Safari " + useragent[start:]    
    # Other            
    else:
        browser = "Unknown"

    # Operating system  
    if "Windows 2000 5.0" in useragent:
            osversion = "Windows 2000"
    if "Windows NT 5.1" in useragent:
            osversion = "Windows XP"
    if "Windows NT 5.2" in useragent:
            osversion = "Windows 2003"
    if "Windows NT 6.0" in useragent:
            osversion = "Windows Vista"
    if "Windows NT 6.1" in useragent:
            osversion = "Windows 7"
            
            
    return browser,osversion
        
        
######################################################################################        
# wp_dumpShellcode
###################################################################################### 

def wp_dumpShellcode(s):
    # Convert shellcode to string & dump to CANVAS/shellcode.txt
    #
    # Place shellcode.txt in ID directory, run module, locate shellcode in memory, 
    # !cmpmem -a <sc addr> -f shellcode.txt
    
    sc = prettyhexprint(s, len(s))
        
    fd=file(wp_outputpath('shellcode.txt'),'wb+')
    fd.write(sc)
    fd.close()
    return        
    
######################################################################################
# wp_filepath
###################################################################################### 
    
def wp_outputpath(filename):
    # Builds a path for a WP exploit module output file
    # will also create any sub directories required
    
    from engine.config import canvas_root_directory
    
    basepath = canvas_root_directory + "/3rdparty/White_Phosphorus/output"
    retpath = basepath + "/" + filename
    
    d = os.path.dirname(retpath)
    if not os.path.exists(d):
        os.makedirs(d)
    
    return retpath