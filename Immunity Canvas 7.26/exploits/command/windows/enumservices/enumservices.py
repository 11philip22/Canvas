#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME                    = "enumservices"
DESCRIPTION             = "Gets the services and their state"
VERSION                 = "1.0"

DOCUMENTATION           = {}
DOCUMENTATION["Note"]   = "This module gets the services and their state. Currently only works on Win32 and requires Admin, of course"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['SITE']        = "Local"
PROPERTY['ARCH']        = [ ["Unix"], ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = {}
        self.name   = NAME

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))

        for node in self.argsDict["passednodes"]:
            type = node.nodetype
            if "win32api" in node.capabilities:
                manager = node.shell.OpenSCManager()
                if manager == 0:
                    self.log("Couldn't open the SC Manager!")
                else:
                    self.log("SCManager handle=%x" % manager)
                    ret,val = node.shell.EnumServicesStatusEx(manager)
                    if ret == 0:
                        self.log("Error reading services: GetLastError()=%x" % val)
                    else:
                        self.log("Read %d services on node %s" % (len(val),node.getname()))
                        self.log("Services (name, displayname, state, pid)")
                        for service in val:
                            name,displayname,state,pid=service
                            self.log(" %s [ % 25s ] %d % 5d" % (name,displayname,state,pid))
                        self.result[node.getname()]=val
                    node.shell.CloseServiceHandle(manager)

            elif "Unix Shell" or "osx" in node.capabilities:
                try:
                    services = node.runcommand("initctl list | grep start/running")

                except (ValueError, NodeCommandError), info:
                    self.log("Error!")
                    rv = 0
                    msg = "failed"

                self.log("List of services running:\n")
                services = services.split("\n")
                for service in services:
                    self.log("\t%s\n" % service)

            else:
                self.log("Node of type %s not supported yet." % type)
                pass

        self.setInfo("%s - (finished)" % (NAME))
        return 1

