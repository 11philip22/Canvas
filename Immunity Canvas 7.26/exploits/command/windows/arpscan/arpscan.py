#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

from ExploitTypes.localcommand import LocalCommand

NAME                    = "arpscan"
DESCRIPTION             = "Finds all the hosts on the local network interfaces using an brute force arp scan"
VERSION                 = "1.0"

DOCUMENTATION           = {}
DOCUMENTATION["Notes"]  = "Currently only available on win32api compatable nodes. Does about 2 IP's a second."
DOCUMENTATION["Other"]  = "To add more MAC headers to sniffer.py: http://standards.ieee.org/regauth/oui/index.shtml"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['SITE']        = "Local"
PROPERTY['ARCH']        = [ ["Windows"] ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name   = NAME

    def connect_to_host(self, t_host, t_port):  # useless function ?
        s = self.gettcpsock()
        s.set_timeout(0.1)
        try:
            if self.socknode.nodetype in ["win32Node", "win64Node"]:
                s.set_timeout(0)
                ret = s.connect_timeout((t_host, t_port))
            else:
                ret = s.connect((t_host, t_port))
        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            return 0
        if ret == -1:
            return 0
        return s

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        node    = self.argsDict["passednodes"][0]
        app     = self.engine.getModuleExploit("addhost")
        app.link(self)

        if "win32api" not in node.capabilities:
            logging.info("This module needs a node with win32api capabilities.")
            return 0

        for ifc in node.interfaces.children:
            name    = ifc.interface
            ip      = ifc.ip
            netmask = bits(~ifc.netmask)
            if netmask < 24:
                logging.info("netmask is %d, so we'll cut it down to a class C" % netmask)
                netmask = 24

            logging.info("Doing: %s (%s/%d)" % (ifc.interface, ifc.ip, netmask))
            
            if ip == "127.0.0.1":
                logging.info("Not scanning localhost")
                continue

            connection = node.shell.connection
            if hasattr(connection, 'set_timeout') and hasattr(connection, 'get_timeout'):
                old_timeout = connection.get_timeout()
                connection.set_timeout(None)
                hosts = node.shell.slowarpscan(ip, netmask)
                connection.set_timeout(old_timeout)
            else:
                hosts = node.shell.slowarpscan(ip, netmask)  # possibly trigger timeout exception

            for host in hosts:
                app.argsDict["host"] = host[0]  # (host,mac addr) pair
                app.run()                       # add this host to our list
                target  = node.get_known_host(host[0])
                frommac = host[1]
                target.add_knowledge("MACADDRESS", hexprint(frommac), 100)
                from db.oui import MACresolve
                compname = MACresolve(frommac[:3])
                if compname:
                    logging.info("Host found %s: From MAC=%s (%s)" % (host[0],hexprint(frommac), compname))
                    target.add_knowledge("MACNAME", compname, 100)
                else:
                    logging.info("Host found %s: From MAC=%s (unknown vendor)" % (host[0],hexprint(frommac)))

        self.setInfo("%s - done (success: %s)"%(NAME,self.result))
        return 1

if __name__=="__main__":
    print "This is only used by Win32Nodes/Win64Nodes. You want to use the arpscanner module."
