#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from encoder import addencoder
from shellcode import win32shell

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import canvasengine
from canvasengine import socket_save_list

import time
from MOSDEF import mosdef

NAME                   = "getfileversion"
DESCRIPTION            = "Get file version info from a file."
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
This is supposed to be used in conjuction with get_installed_updates to
try to get the best exploit for the current system.
"""
VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

#all sorts of defines come from here
from win32MosdefShellServer import *

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result=""
        self.name=NAME
        self.filetoprocess="c:\\windows\\system32\\win32k.sys"
        self.knowledge_name = 'get_file_version'
        self.supportedNodeTypes = ["win32Node", "win64Node"]

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getfileversion - "+msg)
        self.setProgress(percent)
        return

    def run(self):
        self.setInfo("%s"%(NAME))
        node=self.argsDict["passednodes"][0]
        self.filetoprocess=self.argsDict.get("filetoprocess",self.filetoprocess)
        self.filetoprocess=self.filetoprocess.lower()

        #many local exploits will try to get version of kernel, cach
        host=node.get_known_host("127.0.0.1") #always exists.
        knowncontainer = host.get_knowledge(self.knowledge_name)
        if knowncontainer:
            savedinfo = knowncontainer.known
            if self.filetoprocess in savedinfo:
                self.result = savedinfo[self.filetoprocess]
                self.setInfo("%s - done (success: %s)"%(NAME,self.result))
                return 1

        shell=node.shell

        ntype = node.nodetype

        handleMosdef = ""
        importLocation = ""

        # *** CODE ***
        vars = {}

        vars['libname']=self.filetoprocess

        if ntype in ["win32Node",]:
            handleMosdef = "int"
            importLocation = "remote"

        elif ntype in ["win64Node",]:
            handleMosdef = "long long"
            importLocation = "local"

        #we dont support any other node
        else:
            self.log("Node not supported")
            return 0

        self.log('[+] Retrieving version of %s' % (self.filetoprocess))

        code = """
        #import "IMPORT_LOCATION", "Version.dll|GetFileVersionInfoA" as "GetFileVersionInfoA"
        #import "IMPORT_LOCATION", "Version.dll|GetFileVersionInfoSizeA" as "GetFileVersionInfoSizeA"
        #import "IMPORT_LOCATION", "Version.dll|VerQueryValueA" as "VerQueryValueA"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"
        #import "local", "malloc" as "malloc"
        #import "local", "free" as "free"

        #import "string", "libname" as "libname"
        """

        code +=  """
        struct VS_FIXEDFILEINFO{
          int dwSignature;
          int dwStrucVersion;
          int dwFileVersionMS;
          int dwFileVersionLS;
          int dwProductVersionMS;
          int dwProductVersionLS;
          int dwFileFlagsMask;
          int dwFileFlags;
          int dwFileOS;
          int dwFileType;
          int dwFileSubtype;
          int dwFileDateMS;
          int dwFileDateLS;
        };

        void main()
        {
          HANDLE libhandle;
          int datalen;
          char *data;
          int ret;
          struct VS_FIXEDFILEINFO *pFileInfo;

          //first we get the size
          datalen = GetFileVersionInfoSizeA( libname, &libhandle );

          if (datalen == 0){
            sendint(0xffffff0);
            return;
          }

          data = malloc (datalen);

          ret = GetFileVersionInfoA(libname, libhandle, datalen, data);
          if(ret == 0){
            sendint(0xffffff1);
            free(data);
            return;
          }
          ret = VerQueryValueA(data, "\\", &pFileInfo, &datalen);
          if(ret == 0){
            sendint(0xffffff2);
            free(data);
            return;
          }
          sendint(1);
          sendint(pFileInfo->dwFileVersionMS);
          sendint(pFileInfo->dwFileVersionLS);
          free(data);
        }
        """
        code = code.replace("IMPORT_LOCATION", importLocation)
        code = code.replace("HANDLE", handleMosdef)
        shell.clearfunctioncache()
        request=shell.compile(code,vars)
        shell.sendrequest(request)

        ret = shell.readint()
        if   ret == 0xffffff0:
            self.log('[EE] getfileversion module failed (wrong path?)')
        elif ret == 0xffffff1:
            self.log('[EE] getfileversion module failed at getting fileversioninfo')
        elif ret == 0xffffff2:
            self.log('[EE] getfileversion module failed failed at querying values')

        # Get file version number now
        if ret == 1:
            fileversionms = shell.readint()
            fileversionls = shell.readint()
            shell.leave()
            self.result = (fileversionms >> 16, fileversionms & 0xffff, fileversionls >> 16, fileversionls & 0xffff)
            #cache
            if knowncontainer:
                savedinfo[self.filetoprocess] = self.result
            else:
                savedinfo = {}
                savedinfo[self.filetoprocess] = self.result
            host.add_knowledge(self.knowledge_name, savedinfo, 100)
            self.log('[ii] %s has version %s' % (self.filetoprocess, '.'.join(map(str,self.result)) ) )
            self.setInfo("%s - done (success: %s)"%(NAME,self.result))
            return ret
        shell.leave()
        return 0

if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
