#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  reg_loggedon.py
## Description:
##            :
## Created_On :  Wed Nov 18 CET 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'RegLoggedOn - Loggedon users on a Windows server'
DESCRIPTION                     = 'Display users logged on a Windows server using the registry'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['7', '2003', '2008', '2012']

CHANGELOG = """
"""

DOCUMENTATION['NOTES']          = """
This is only the first implementation, an improved one will follow in our next
releases. It currently displays both:

    - The users currently connected (similar to psloggedon)
    - The users that where connected at some point

Note:
    - We need to add the date of the last login
    - If a user was able to get connected on an AD, then it has admin rights.

Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2012 R2 (amd64)
    - Windows Server 2012 R2 (amd64)

To run the module from command line:
python exploits/command/windows/reg_loggedon/reg_loggedon.py \
    -t 192.168.0.1 \
    -Ouser:administrator \
    -Opassword:barbar123! \
    -Odomain:IMMU2.COM
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.winreg as wreg
import libs.newsmb.lsarpc as lsa

SOFTWARE_KEY = 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList'

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.port         = 445
        self.version      = 0
        #self.ccache_file  = None


    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.version = self.argsDict.get('version', self.version)

    def get_sids_from_hku(self):

        self.winreg = wreg.WINREGClient(self.target.interface)
        self.winreg.set_credentials(self.user, self.password, self.domain)
        if not self.winreg.bind():
            logging.error("Authentication failed or host is down")
            return None

        hkey = self.winreg.open_key(predefinedkey='HKEY_USERS')
        key = self.winreg.open_key(hkey, keyname='')
        informations = self.winreg.query_information(handle=key)
        # For each entry, we attempt to dir list subentries
        sids = []
        for i in xrange(informations['nbr_keys']):
            entry_name = self.winreg.enum_key(key, i)['name']
            if entry_name.upper() == '.DEFAULT':
                continue
            if entry_name.upper() == 'S-1-5-18':
                continue
            if entry_name.upper() == 'S-1-5-19':
                continue
            if entry_name.upper() == 'S-1-5-20':
                continue
            if entry_name.lower().find('_classes') >0:
                continue
            sids += [ entry_name ]
        self.winreg.close_key(key)
        self.winreg.close_key(hkey)
        return sids

    def get_sids_from_locale_machine(self):

        try:
            self.winreg = wreg.WINREGClient(self.target.interface)
            self.winreg.set_credentials(self.user, self.password, self.domain)
            if not self.winreg.bind():
                logging.error("Authentication failed or host is down")
                return None

            hkey = self.winreg.open_local_machine()
            key = self.winreg.open_key(hkey, keyname=SOFTWARE_KEY)
            informations = self.winreg.query_information(handle=key)

            # For each entry, we attempt to dir list subentries
            sids = []
            for i in xrange(informations['nbr_keys']):
                entry_name = self.winreg.enum_key(key, i)['name']
                if entry_name.upper() == '.DEFAULT':
                    continue
                if entry_name.upper() == 'S-1-5-18':
                    continue
                if entry_name.upper() == 'S-1-5-19':
                    continue
                if entry_name.upper() == 'S-1-5-20':
                    continue
                if entry_name.lower().find('_classes') >0:
                    continue
                sids += [ entry_name ]
            self.winreg.close_key(key)
            self.winreg.close_key(hkey)
            return sids
        except Exception as e:
            logging.error("%s", str(e))
            return None

    def get_names_from_sids(self, sid_list):

        res = []
        lsaobj = lsa.LSAClient(self.target.interface)
        lsaobj.set_credentials(self.user, self.password, self.domain)
        if not lsaobj.bind():
            self.log_error("Connection to LSA pipe failed")
            return None

        try:
            names, domains = lsaobj.lookup_sids_with_domains(sid_list)
        except lsa.LSALookUpSidsException as e:
            self.log_error('LSALookUpSids() failed with unknown error: %s' % str(e))
            return None
        else:
            for name in names:
                if name['Type'] == lsa.SIDTYPEUSER:
                    username = name['Name'].decode('UTF-16LE').encode('ascii')
                    domain_sid = '-'.join(name['Sid'].split('-')[:-1])
                    for dom in domains:
                        if dom['Sid'] == domain_sid:
                            username = '\\'.join([dom['Name'], username])
                            break
                    res += [ '\t%s' % username ]
            return res

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target.interface,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None
        myos = app.result
        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
        return isWindows

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]

        if node.islocal(self.target.interface):
            logging.error("Local execution is not supported yet")
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.target.interface)
            if self.isWindows is None:
                logging.error("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        current_sids = self.get_sids_from_hku()
        if not current_sids:
            return 0

        past_sids = self.get_sids_from_locale_machine()

        names = self.get_names_from_sids(current_sids)
        if not names:
            return 0
        else:
            logging.warning('Users <currently> logged on locally:')
            for name in names:
                logging.info(name)

        if past_sids:
            names = self.get_names_from_sids(past_sids)
            if not names:
                return 0
            else:
                logging.warning('Users <previously> logged on locally:')
                for name in names:
                    logging.info(name)

        self.setInfo("%s - done (success)" % (NAME))
        return 1

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
