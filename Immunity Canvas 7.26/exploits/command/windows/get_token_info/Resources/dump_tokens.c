#import "IMPORT_TYPE","ntdll.dll|NtQuerySystemInformation" as "NtQuerySystemInformation"
#import "IMPORT_TYPE","ntdll.dll|NtQueryObject" as "NtQueryObject"
#import "IMPORT_TYPE","kernel32.dll|GetCurrentProcessId" as "GetCurrentProcessId"
#import "local", "sendint" as "sendint"
#import "local", "sendunistring2self" as "sendunistring2self"
#import "local", "malloc" as "malloc"
#import "local", "free" as "free"
#import "local", "debug" as "debug"

struct SYSTEM_HANDLE
{
	int dwProcessId;
	char  bObjectType;
	char  bFlags;
	short  wValue;
	POINTER_TYPE pAddress;
	int GrantedAccess;
};

struct SYSTEM_HANDLE_INFORMATION
{
	int dwCount;
	struct SYSTEM_HANDLE Handles[1];
}; 

struct LARGE_INTEGER {
  int HighPart;
  int LowPart;
};

struct UNICODE_STRING {
  short Length;
  short MaximumLength;
  char  *Buffer;
};

struct VM_COUNTERS {
  int PeakVirtualSize;
  int VirtualSize;
  int PageFaultCount;
  int PeakWorkingSetSize;
  int WorkingSetSize;
  int QuotaPeakPagedPoolUsage;
  int QuotaPagedPoolUsage;
  int QuotaPeakNonPagedPoolUsage;
  int QuotaNonPagedPoolUsage;
  int PagefileUsage;
  int PeakPagefileUsage;
  int PrivatePageCount;
};

struct CLIENT_ID {
  HANDLE_TYPE UniqueProcess;
  HANDLE_TYPE UniqueThread;
}; // struct CLIENT_ID

struct SYSTEM_THREAD {
  struct LARGE_INTEGER KernelTime;
  struct LARGE_INTEGER UserTime;
  struct LARGE_INTEGER CreateTime;
  int WaitTime;
  char * StartAddress;
  struct CLIENT_ID ClientId;
  int Priority;
  int BasePriority;
  int ContextSwitchCount;
  int State;
  int WaitReason;
}; // SYSTEM_THREAD

struct IO_COUNTERS {
  unsigned long long ReadOperationCount;
  unsigned long long WriteOperationCount;
  unsigned long long OtherOperationCount;
  unsigned long long ReadTransferCount;
  unsigned long long WriteTransferCount;
  unsigned long long OtherTransferCount;
};

struct SYSTEM_PROCESS_INFORMATION {
  int                   NextEntryOffset;
  int                   NumberOfThreads;
  struct LARGE_INTEGER           Reserved[3];
  struct LARGE_INTEGER           CreateTime;
  struct LARGE_INTEGER           UserTime;
  struct LARGE_INTEGER           KernelTime;
  struct UNICODE_STRING          ImageName;
  int                     BasePriority;
  HANDLE_TYPE                  ProcessId;
  HANDLE_TYPE                  InheritedFromProcessId;
  int                   HandleCount;
  int                   Reserved2[2];
  int                   PrivatePageCount;
  struct VM_COUNTERS             VirtualMemoryCounters;
  struct IO_COUNTERS             IoCounters;
  struct SYSTEM_THREAD           Threads[0];
};


int memcmp(char *s1, char *s2, int n) {
  unsigned char *p1;
  unsigned char *p2;
  p1 = s1;
  p2 = s2;
  int d;

  if (n){
    while (n > 0){
      p1 = p1 + 1;
      p2 = p2 + 1;
      d = *p1 - *p2;
      if (d != 0){
        return -1;
      }
      n = n - 1;
    }
  }
  return 0;
}

int is_token(HANDLE_TYPE handle){
  int return_value;
  int size;
  struct UNICODE_STRING * p_handle_info;
  int token_matches;
  token_matches = -1;  
  
  p_handle_info = 0;
  size = 0;

  // OBJECT_INFORMATION_CLASS.ObjectTypeInformation = 2
  return_value = NtQueryObject(handle, 2, 0, size, &size);
  
  while (return_value == 0xc0000004){
    if (p_handle_info != 0){
      free(p_handle_info);
    }

    p_handle_info = malloc(size);

    return_value = NtQueryObject(handle, 2, p_handle_info, size, &size);
  }

  if (p_handle_info != 0){
    sendint(handle);
    sendunistring2self(p_handle_info->Buffer);
    if (p_handle_info->Buffer[0] == 'T'){
      debug();
      return_value = 1;
    } else{
      return_value = 0;
    }
  }

  free(p_handle_info);

  return return_value;
}



// SystemProcessInformation = 5
// STATUS_INFO_LENGTH_MISMATCH = 0xc0000004

void main(){
  int return_value;
  int pi_size;
  HANDLE_TYPE process_id;
  struct SYSTEM_PROCESS_INFORMATION * pi;
  char * pointer_pi;
  struct SYSTEM_PROCESS_INFORMATION * current_pi;
  int i;
  int current_handle;

  // Get our own process ID
  process_id = GetCurrentProcessId();
  
  pi_size = 0;
  return_value = NtQuerySystemInformation(5,
                                          0,
                                          pi_size,
                                          &pi_size);
  pi = malloc(pi_size);
  return_value = NtQuerySystemInformation(5,
                                          pi,
                                          pi_size,
                                          &pi_size);

  // STATUS_SUCCESS == 0
  while (return_value == 0xc0000004){
    if (pi != 0){
      free(pi);
    }
    
    pi = malloc(pi_size);
    
    return_value = NtQuerySystemInformation(5,
                                            pi,
                                            pi_size,
                                            &pi_size);

  }

  current_pi = pi;
  
  while (current_pi != 0){
    // sendint(current_pi->ProcessId);
    if (current_pi->ProcessId == process_id){
      current_handle = 0;
      // sendint(1);
      for(i = 0; i < current_pi->HandleCount; i = i + 1){
        current_handle = i+1;
        current_handle = current_handle*4;
        
        if (is_token(current_handle) == 1){
          // sendint(current_handle);
        }
      }
      break;
    }
    
    if (current_pi->NextEntryOffset != 0){
      pointer_pi = current_pi;
      pointer_pi = pointer_pi + current_pi->NextEntryOffset;
      current_pi = pointer_pi;
    } else {
      current_pi = 0;
    }
  }

  sendint(0xffffffff);
  
  free(pi);
  return;
}
