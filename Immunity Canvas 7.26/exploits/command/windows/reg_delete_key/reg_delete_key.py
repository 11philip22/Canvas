#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  reg_delete_key.py
## Description:
##            :
## Created_On :  Fri Nov 20 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'RegDeleteKey - Remote Registry delete key'
DESCRIPTION                     = 'Delete a key in the Windows registry'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008', '2012']

CHANGELOG = """
"""

DOCUMENTATION['NOTES']          = """
If the current key has values, this will not prevent the deletion. However if
there exist subkeys, an ACCESS DENIED will be triggered. The user is requested
to remove the subkeys before!

Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows Server 2012 R2 (amd64)

To run the module from command line:
python ./exploits/command/windows/reg_delete_key/reg_delete_key.py \
    -t 192.168.0.1 \
    -Oroot_key:HKEY_CLASSES_ROOT \
    -Osub_key:TEST_123456 \
    -Ouser:administrator \
    -Opassword:barbar123!
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.winreg as wreg
from libs.newsmb.winreg import build_permission_string

root_keys = [
              'HKEY_CLASSES_ROOT',
              'HKEY_LOCAL_MACHINE',
              'HKEY_CURRENT_USER',
              'HKEY_USERS',
              'HKEY_PERFORMANCE_DATA',
              'HKEY_CURRENT_CONFIG'
            ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.root_key     = 'HKEY_CLASSES_ROOT'
        self.sub_key      = '\\'
        self.port         = 445
        self.version      = 0
        #self.ccache_file  = None

    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.root_key = self.argsDict.get('root_key', self.root_key)
        self.sub_key = self.argsDict.get('sub_key', self.sub_key)
        self.version = self.argsDict.get('version', self.version)

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target.interface,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None
        myos = app.result
        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
        return isWindows

    def delete_key(self, hsubkey):
        """
        This function will remove a specific key.
        If the key has subkeys, the deletion will not be possible and an access
        denied is instead triggered.
        """
        try:

            try:
                self.winreg.delete_key(hsubkey, keyname=self.sub_key)
            except wreg.WINREGBaseRegDeleteKeyException as e:
                if e.status == wreg.ERROR_FILE_NOT_FOUND:
                    logging.error("The key \'%s\\%s\' does not exist" % (self.root_key, self.sub_key))
                    return False
                elif e.status == wreg.ERROR_ACCESS_DENIED:
                    logging.error("The key \'%s\\%s\' couldn't be deleted: access denied" % (self.root_key, self.sub_key))
                else:
                    logging.error("The key \'%s\\%s\' couldn't be deleted (error=%s)" % (self.root_key, self.sub_key. e.status))
            else:
                logging.info("The value \'%s\\%s\' was successfully deleted" % (self.root_key, self.sub_key))
                return True

        except Exception as e:
            logging.error('%s', str(e))
            return False


    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]

        if node.islocal(self.target.interface):
            logging.error("Local execution is not supported yet")
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.target.interface)
            if self.isWindows is None:
                logging.error("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # Did we provide a valid root_key?
        if self.root_key in [0, 1, 2, 3, 4, 5]:
            self.root_key = root_keys[self.root_key]

        if self.root_key in ['0','1','2','3', '4', '5']:
            self.root_key = root_keys[int(self.root_key)]

        if self.root_key not in root_keys:
            logging.error("The key \'%s\' is either invalid or unhandled" % self.root_key)
            return 0

        # Then we bind() to the register named pipe
        self.winreg = wreg.WINREGClient(self.target.interface)
        self.winreg.set_credentials(self.user, self.password, self.domain)
        if not self.winreg.bind():
            logging.error("Authentication failed or host is down")
            return 0

        # At this point we need to open the root key if we can
        try:
            if self.root_key == 'HKEY_CLASSES_ROOT':
                hrootkey = self.winreg.open_classes_root()
            elif self.root_key == 'HKEY_LOCAL_MACHINE':
                hrootkey = self.winreg.open_local_machine()
            elif self.root_key == 'HKEY_CURRENT_USER':
                hrootkey = self.winreg.open_current_user()
            elif self.root_key == 'HKEY_USERS':
                hrootkey = self.winreg.open_users()
            elif self.root_key == 'HKEY_PERFORMANCE_DATA':
                hrootkey = self.winreg.open_performance_data()
            elif self.root_key == 'HKEY_CURRENT_CONFIG':
                hrootkey = self.winreg.open_current_config()
            else:
                # Should never raise!
                raise RuntimeError, "Wrong key"
        except Exception as e:
            logging.error('Failed to open the key \'%s\' with current credentials' % self.root_key)
            return 0

        # Now let's filter/modify the subkey
        # If nothing is provided, we need a minimum
        if self.sub_key == '':
            logging.info('Assuming \ subkey.')
        else:
            # We also need to sanitize the subkey parameter
            self.sub_key = self.sub_key.replace('/', '\\')
            self.sub_key = self.sub_key.lstrip('\\')
            self.sub_key = self.sub_key.rstrip('\\')

        logging.info("Requested deletion of key \'%s\\%s\'" % (self.root_key, self.sub_key))
        ret = self.delete_key(hrootkey)
        # Whatever the result, we close the handle
        self.winreg.close_key(hrootkey)
        # Time to say goodbye
        if not ret:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0
        else:
            self.setInfo("%s - done (success)" % (NAME))
            return 1

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
