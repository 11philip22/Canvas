#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import math
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from WindowsConstants import accessDict, keyDict

import canvasengine

NAME                   = "getintegritylevel"
DESCRIPTION            = "Get current process integrity level"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
This exploit will help determine whether a UAC-bypass exploit is necessary to debug system processes once an admin account is compromised.

NOTES:
- if this tool tells you that you have true administrator privileges but you can't inject into LSASS,
  it may be the case that the user disabled UAC but then forgot to reboot.
- you may have to RevertToSelf() before actually running at the IL that this utility finds!
  This is because the thread's current token may be different from the process' current token.
- if you obtain a medium IL, it is not certain that you do not have unlimited privileges.
  This is the level shown even when UAC is disabled. However, this is only the case with Windows 7
  (see: https://dfir-blog.com/2015/10/24/protecting-windows-networks-uac/ )


Scenarios
True  - an extra exploit is needed to gain full administrator privileges
False - no other exploit is needed to gain full administrator privileges

(the sanity check is whether or not you're able to debug LSASS)

#1 launched from user named "Administrator" (expected answer: True)
#2 launched from user in "Administrator" group un-elevated (expected answer: False)
#3 launched from user in "Administrator" group using 'run-as-administrator' (expected answer: True)
#4 launched from 'standard' account un-elevated (expected answer: False)
#5 launched from 'standard' account using 'run-as-administrator' (expected answer: True)
#6 launched from exploit known to yield NT AUTHORITY\SYSTEM privileges

NOTE: test #1 is not done for Win10 because it doesn't contain the default Administrator account.

Tested on:
OS name            MOSDEF ILs tested
------------------------------------------
Windows 10 64 bit    - 2 / 3 / 4 / 5 / 6 (using ms16_111)
Windows 8  32 bit    - 1 / 2 / 3 / 4 / 5 / 6 (using ms16_111)
Windows 7  32 bit    - 1 / 2 / 3 / 4 / 5 / 6 (using atmfd_pool_buffer_underflow)
"""
VERSION                = "1.0"

PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Windows"] ]

class RegReadFailure(Exception):
    pass

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.supportedNodeTypes = ["win32Node", "win64Node"]

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getintegritylevel - " + msg)
        self.setProgress(percent)

    def get_uac_enabled(self, node):
        handle = node.shell.RegOpenKeyEx("HKEY_LOCAL_MACHINE",
                                         "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                                         "KEY_READ")

        if handle != 0:
            (ret, data_type, data) = node.shell.RegQueryValueEx(handle, "EnableLUA")
            node.shell.RegCloseKey(handle)

            # success
            if ret == 1:
                return any([byte != "\x00" for byte in data])

        raise RegReadFailure()

    def run(self):
        self.setInfo("%s" % (NAME))
        node = self.argsDict["passednodes"][0]
        percent = 0
        increase = int(math.ceil(100 / len(self.argsDict["passednodes"])))
        integrity_levels = []

        app = self.engine.getModuleExploit("check_admin_user")
        app.link(self)
        app.argsDict = self.argsDict
        app.run()

        administrator_access = app.result

        for (index, (node, is_admin)) in enumerate(zip(self.argsDict["passednodes"], administrator_access)):
            if node.nodetype not in self.supportedNodeTypes:
                logging.error("Cannot run getintegritylevel on a non-Windows MOSDEF node")
                integrity_levels.append(None)
            else:
                uac_enabled = True

                try:
                    uac_enabled = self.get_uac_enabled(node)
                except RegReadFailure:
                    logging.error("Unable to determine whether UAC is turned on, assuming it is")

                message = ["node (%s):" % (str(node.getname()),),]
                message.append("UAC enabled -> [%s]" % str(uac_enabled))

                x = node.shell.get_integrity_level()

                logging.info("Node's current integrity level: %s" % str(x))
                high_il = x in ["high", "system"]

                admin_format = "admin user -> [%s]"
                admin_user = str(is_admin) if is_admin in [True, False] else "UNKNOWN"

                message.append(admin_format % (admin_user))

                il_format = "high-il/elevated token -> [%s]"
                message.append(il_format % high_il)

                if is_admin and high_il:
                    message.append("=> you have *true* admin privileges")

                if uac_enabled:
                    if is_admin and not high_il:
                        message.append("=> you need a UAC bypass")

                if not uac_enabled:
                    if is_admin and not high_il:
                        message.append("=> you have *true* admin privileges")

                if not is_admin:
                    message.append("=> you need to use a privilege escalation exploit")

                logging.warning(" ".join(message))
                integrity_levels.append((x, is_admin))
                percent += increase

                self.set_progr("Processed node %d (%s)" % ((index + 1), node.getname()), percent)

        self.result = integrity_levels
        self.setInfo("%s - done (success: %s)" % (NAME, self.result))

        return 1


if __name__=="__main__":
    logging.info("This module should be used only from within CANVAS")
