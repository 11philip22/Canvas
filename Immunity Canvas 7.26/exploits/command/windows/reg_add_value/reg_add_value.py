#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  reg_add_value.py
## Description:
##            :
## Created_On :  Fri Nov 20 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'RegAddValue - Remote Registry add value'
DESCRIPTION                     = 'Add a value in the Windows registry for a specific key'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008', '2012']

CHANGELOG = """
"""

DOCUMENTATION['NOTES']          = """
Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows Server 2012 R2 (amd64)

To run the module from command line (creation of "hello" as the SZ type):
python ./exploits/command/windows/reg_add_value/reg_add_value.py \
    -t 192.168.0.1 \
    -Oroot_key:HKEY_CLASSES_ROOT \
    -Osub_key:TEST_123456 \
    -Ouser:administrator \
    -Opassword:barbar123! \
    -Oval_type:1 \
    -Oval_data:hello
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.winreg as wreg
from libs.newsmb.winreg import build_permission_string

root_keys = [
              'HKEY_CLASSES_ROOT',
              'HKEY_LOCAL_MACHINE',
              'HKEY_CURRENT_USER',
              'HKEY_USERS',
              'HKEY_PERFORMANCE_DATA',
              'HKEY_CURRENT_CONFIG'
            ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.root_key     = 'HKEY_CLASSES_ROOT'
        self.sub_key      = '\\'
        self.val_name     = 'test'
        self.val_type     = wreg.REG_DWORD
        self.val_data     = '\x00\x00\x00\x00'
        self.port         = 445
        self.version      = 0
        self.overwrite    = False
        self.create_key    = False
        #self.ccache_file  = None

    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.root_key = self.argsDict.get('root_key', self.root_key)
        self.sub_key = self.argsDict.get('sub_key', self.sub_key)
        self.version = self.argsDict.get('version', self.version)
        self.overwrite = bool(self.argsDict.get('overwrite', self.overwrite))
        self.create_key = bool(self.argsDict.get('create_key', self.create_key))
        self.val_name = self.argsDict.get('val_name', self.val_name)
        self.val_data = self.argsDict.get('val_data', self.val_data)
        self.val_type = self.argsDict.get('val_type', self.val_type)

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target.interface,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None
        myos = app.result
        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
        return isWindows

    def _set_value(self, hsubkey, value_data):
        """
        Backend function for set_value(). It actually does the job.
        """
        try:
            self.winreg.set_value(hsubkey, v_name=self.val_name, v_type=self.val_type, v_value=value_data)
        except wreg.WINREGBaseRegSetValueException as e:
            if e.status == wreg.ERROR_ACCESS_DENIED:
                logging.error("Cannot set value \'%s\\%s\\%s\' with the current credentials: access denied" % (self.root_key, self.sub_key, self.val_name))
                return False
            else:
                logging.error("Cannot set value \'%s\\%s\\%s\': unexpected error (%s)" % (self.root_key, self.sub_key, self.val_name, e.status))
                return False
        else:
            logging.info("The value \'%s\\%s\\%s\' was successfully created" % (self.root_key, self.sub_key, self.val_name))
            return True

    def set_value(self, hsubkey, value_data):
        """
        This function is a wrapper around _set_value.
        It's job is to ensure that _set_value() can be called in the appropriate
        conditions.
        """
        try:

            # Do we already have a value set?
            res = self.winreg.query_information(handle=hsubkey)
            value_exists=False
            for i in xrange(res['nbr_values']):
                try:
                    res2 = self.winreg.enum_value(hsubkey,
                                         i,
                                         valnamelen=res['max_value_namelen'],
                                         valbufsize=res['max_value_len'])
                    if res2['name'].lower() == self.val_name.lower():
                        value_exists = True
                        break
                except wreg.WINREGBaseRegEnumValueException as e:
                    if e.status == wreg.ERROR_NO_MORE_ITEMS:
                        break

            # If the value doesn't exist, then we just create it
            if not value_exists:
                return self._set_value(hsubkey, value_data)

            # However it may already exist
            if not self.overwrite:
                # If we do not have the overwrite flag turned on, we give up.
                logging.error("The value \'%s\' already exists. Use the \'overwrite\' option if you are sure of what you do" % (self.val_name))
                return False

            logging.info("The value \'%s\\%s\\%s\' exists and will be overwritten" % (self.root_key, self.sub_key, self.val_name))

            # At this point, we have to delete the value first
            try:
                self.winreg.delete_value(hsubkey, v_name=self.val_name)
            except wreg.WINREGBaseRegDeleteValueException:
                logging.error("The value \'%s\\%s\\%s\' couldn't be deleted" % (self.root_key, self.sub_key, self.val_name))
                return False
            else:
                return self._set_value(hsubkey, value_data)

        except Exception as e:
            logging.error('%s', str(e))
            return False

    def create_subkey(self, hrootkey):
        """
        Handles the creation of the subkey if it does not exist yet.
        """
        try:
            key = self.winreg.create_key(hrootkey, keyname=self.sub_key)
        except wreg.WINREGBaseRegCreateKeyException as e:
            return False
        else:
            return True

    def open_or_create_subkey(self, hrootkey):
        """
        This function opens the subkey.
        Note: It cannot (yet) handle the creation of the key if it doesn't exist
        and if the user forces it. As such, the key MUST exist (for now).
        """
        try:

            access  = wreg.READ_CONTROL
            access |= wreg.KEY_QUERY_VALUE
            access |= wreg.KEY_SET_VALUE
            access |= wreg.KEY_NOTIFY
            access |= wreg.KEY_ENUMERATE_SUB_KEYS
            access |= wreg.ACCESS_SYSTEM_SECURITY

            # First open the subkey
            try:
                hsubkey = self.winreg.open_subkey(hrootkey, keyname=self.sub_key, access=access)
            except wreg.WINREGBaseRegOpenKeyException as e:
                if e.status == wreg.ERROR_ACCESS_DENIED:
                    logging.error("Cannot open key \'%s\\%s\' with the current credentials: access denied" % (self.root_key, self.sub_key))
                    return False, None
                if e.status == wreg.ERROR_FILE_NOT_FOUND:
                    logging.error("The key \'%s\\%s\' doesn't exist" % (self.root_key, self.sub_key))
                    # If we did not set the create_key flag, it's over.'
                    if not self.create_key:
                        logging.info('You may want to run again the module with the \'create_key\' flag set')
                        return False, None
                    # If we did however, we need to create the key
                    else:
                        logging.info('Attempting to create it...')
                        if self.create_subkey(hrootkey):
                            # OK it worked, so let's recall this function.
                            # wreg.ERROR_FILE_NOT_FOUND will not be triggered anymore.
                            logging.info("The key \'%s\\%s\' was succesfully created" % (self.root_key, self.sub_key))
                            return self.open_or_create_subkey(hrootkey)
                        else:
                            logging.error("Cannot create key \'%s\\%s\' with the current credentials" % (self.root_key, self.sub_key))
                            return False, None
                else:
                    logging.error("Cannot open key \'%s\\%s\': unexpected error (%s)" % (self.root_key, self.sub_key, e.status))
                    return False, None
            else:
                return True, hsubkey

        except Exception as e:
            logging.error('%s', str(e))
            return False, None

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]

        if node.islocal(self.target.interface):
            logging.error("Local execution is not supported yet")
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.target.interface)
            if self.isWindows is None:
                logging.error("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # Did we provide a valid type?
        # First we check if it is an integer
        try:
            t = int(self.val_type)
        except Exception:
            logging.error('The registry type %s is not a valid number' % self.val_type)
            return 0
        else:
            self.val_type = t
        # Then we check if it is a recognized one.
        if not wreg.is_valid_registry_type(self.val_type):
            logging.error('Invalid registry type: %s' % self.val_type)
            return 0
        # Finally we need to see if we support this type
        str_type = wreg.convert_type_to_string(self.val_type)
        if self.val_type not in [ wreg.REG_BINARY,
                                  wreg.REG_DWORD_LITTLE_ENDIAN,
                                  wreg.REG_DWORD_BIG_ENDIAN,
                                  wreg.REG_QWORD,
                                  wreg.REG_SZ]:
            logging.error('At the moment we do not support registry type: %s' % str_type)
            return 0

        # Did we provide a valid root_key?
        if self.root_key in [0, 1, 2, 3, 4, 5]:
            self.root_key = root_keys[self.root_key]

        if self.root_key in ['0','1','2','3', '4', '5']:
            self.root_key = root_keys[int(self.root_key)]

        if self.root_key not in root_keys:
            logging.error("The key \'%s\' is either invalid or unhandled" % self.root_key)
            return 0

        # Then we bind() to the register named pipe
        self.winreg = wreg.WINREGClient(self.target.interface)
        self.winreg.set_credentials(self.user, self.password, self.domain)
        if not self.winreg.bind():
            logging.error("Authentication failed or host is down")
            return 0

        # At this point we need to open the root key if we can
        try:
            if self.root_key == 'HKEY_CLASSES_ROOT':
                hrootkey = self.winreg.open_classes_root()
            elif self.root_key == 'HKEY_LOCAL_MACHINE':
                hrootkey = self.winreg.open_local_machine()
            elif self.root_key == 'HKEY_CURRENT_USER':
                hrootkey = self.winreg.open_current_user()
            elif self.root_key == 'HKEY_USERS':
                hrootkey = self.winreg.open_users()
            elif self.root_key == 'HKEY_PERFORMANCE_DATA':
                hrootkey = self.winreg.open_performance_data()
            elif self.root_key == 'HKEY_CURRENT_CONFIG':
                hrootkey = self.winreg.open_current_config()
            else:
                # Should never raise!
                raise RuntimeError, "Wrong key"
        except Exception as e:
            logging.error('Failed to open the key \'%s\' with current credentials' % self.root_key)
            return 0

        # Now let's filter/modify the subkey
        # If nothing is provided, we need a minimum
        if self.sub_key == '':
            logging.info('Assuming \ subkey')
        else:
            # We also need to sanitize the subkey parameter
            self.sub_key = self.sub_key.replace('/', '\\')
            self.sub_key = self.sub_key.lstrip('\\')
            self.sub_key = self.sub_key.rstrip('\\')

        # Now we need to open the key
        ret, hsubkey = self.open_or_create_subkey(hrootkey)
        if not ret:
            self.winreg.close_key(hrootkey)
            return 0

        # Now we convert the data into a form that can used by the API
        value_data = wreg.convert_value_from_string(self.val_type, self.val_data)
        if value_data is None:
            logging.error('%s cannot be converted to type %s' % (self.val_data,str_type))
            return 0

        logging.info("Requested creation of \'%s\\%s\\%s\' as \'%s\' type" % (self.root_key, self.sub_key, self.val_name, str_type))
        ret = self.set_value(hsubkey, value_data)

        # Whatever the result, we close the handles
        self.winreg.close_key(hsubkey)
        self.winreg.close_key(hrootkey)
        # Time to say goodbye
        if not ret:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0
        else:
            self.setInfo("%s - done (success)" % (NAME))
            return 1

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
