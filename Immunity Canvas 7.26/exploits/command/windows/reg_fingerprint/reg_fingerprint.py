#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  reg_fingerprint.py
## Description:
##            :
## Created_On :  Fri Nov 20 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'RegFingerprint - Remote Registry OS version'
DESCRIPTION                     = 'Fingerprint the target system through Windows registry'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Commands'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['NT', '2000', 'XP', 'Vista', '7', '2003', '2008', '2012']

CHANGELOG = """
"""

DOCUMENTATION['NOTES']          = """
Tested against:
    - Windows Server 2003 R2 (x86)
    - Windows Server 2012 R2 (amd64)

To run the module from command line:
python ./exploits/command/windows/reg_fingerprint/reg_fingerprint.py \
    -t 192.168.0.1 \
    -Ouser:administrator \
    -Opassword:barbar123!
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.winreg as wreg
from libs.newsmb.winreg import build_permission_string

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.root_key     = 'HKEY_LOCAL_MACHINE'
        self.sub_key      = 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'
        self.port         = 445
        self.version      = 0
        self.values       = ['ProductName',
                             'CurrentVersion',
                             'CurrentType',
                             'CSDVersion',
                             'CSDBuildNumber',
                             'SystemRoot',
                             'ProductId',
                             'SoftwareType',
                             'CurrentBuild',
                             'EditionID',
                             'BuildLab',
                             'BuildLabEx']
        #self.ccache_file  = None

    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.version = self.argsDict.get('version', self.version)

    def is_alive_with_smb(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target.interface,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def testOS(self, target_ip):
        isWindows = True

        logging.info('Attempting to fingerprint %s' % target_ip)
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        app.target.interface = target_ip
        app.argsDict["smb"]                 = True
        app.argsDict["http"]                = False # not needed
        app.argsDict["ssh"]                 = False # not needed
        app.argsDict["mdns"]                = False # not needed
        app.argsDict["ntp"]                 = False # not needed
        app.argsDict["ftp"]                 = False # not needed
        app.argsDict["smtp"]                = False # not needed
        app.argsDict["dtspcd"]              = False # not needed
        app.argsDict["ipfi"]                = False # not needed
        app.argsDict["telnet"]              = False # not needed
        app.argsDict["nolanguagedetect"]    = True  # not needed
        if app.run() == 0:
            logging.info('Automatic detection failed')
            return None
        myos = app.result
        # Detection of the OS is straightforward
        if myos.base != 'Windows':
            logging.info("A non-Windows host has been detected")
            isWindows = False
        return isWindows

    def open_key(self, hrootkey):
        """
        This function will open a specific key.
        """
        try:

            try:
                hsubkey = self.winreg.open_key(hrootkey, keyname=self.sub_key)
            except wreg.WINREGBaseRegOpenKeyException as e:
                print e
                if e.status == wreg.ERROR_ACCESS_DENIED:
                    logging.error("The key \'%s\\%s\' couldn't be open: access denied" % (self.root_key, self.sub_key))
                    return False, None
                else:
                    logging.error("The key \'%s\\%s\' couldn't be open (error=%s)" % (self.root_key, self.sub_key. e.status))
            else:
                logging.info("The key \'%s\\%s\' was successfully open" % (self.root_key, self.sub_key))
                return True, hsubkey

        except Exception as e:
            logging.error('%s', str(e))
            return False, None

    def get_values(self, hsubkey):
        """
        This function fetches a set of specific values at a known location.
        Depending on the system targeted, the name of these values may change.
        """

        # Do we already have a value set?
        res = self.winreg.query_information(handle=hsubkey)
        values = {}
        for i in xrange(res['nbr_values']):
            try:
                val_obj = self.winreg.enum_value(hsubkey,
                                     i,
                                     valnamelen=res['max_value_namelen'],
                                     valbufsize=res['max_value_len'])

                for val_name in self.values:
                    if val_obj['name'].lower() == val_name.lower():
                        values[val_name] = wreg.convert_value_to_string(val_obj['type'],
                                                                        val_obj['value'])[:-1]
                        continue
            except wreg.WINREGBaseRegEnumValueException as e:
                if e.status == wreg.ERROR_NO_MORE_ITEMS:
                    break
        return values

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]

        if node.islocal(self.target.interface):
            logging.error("Local execution is not supported yet")
            return 0

        # First of all, let's check that the target is alive. Since we will be
        # using tcp/445 for service upload/creation, a tcp connect is fair check.
        # Note: However we should also in another version consider the case of SMB over UDP.
        if not self.is_alive_with_smb():
            logging.info("Target doesn't have SMB exposed. Bailing")
            return 0

        # If automatic was selected, we need to know if the remote host is windows
        # We may also need to run the test nonetheless if we need the architecture
        # Note: Obviously we could also own unix target integrated in the AD but
        # we won't support this case.
        if self.version == 0:
            logging.info("Fingerprinting our target")
            self.isWindows = self.testOS(self.target.interface)
            if self.isWindows is None:
                logging.error("OS detection failed. You may rerun the exploit forcing Windows")
                return 0
            else:
                if self.isWindows == False:
                    logging.error('Not a Windows target. Aborting')
                    return 0

        # Then we bind() to the register named pipe
        self.winreg = wreg.WINREGClient(self.target.interface)
        self.winreg.set_credentials(self.user, self.password, self.domain)
        if not self.winreg.bind():
            logging.error("Authentication failed or host is down")
            return 0

        # At this point we need to open the root key if we can
        try:
            hrootkey = self.winreg.open_local_machine()
        except Exception as e:
            logging.error('Failed to open the key \'%s\' with current credentials' % self.root_key)
            return 0

        logging.info("Opening key \'%s\\%s\'" % (self.root_key, self.sub_key))
        ret, hsubkey = self.open_key(hrootkey)
        if ret:
            results = self.get_values(hsubkey)
            for x in results:
                logging.info("%s: %s" % (x, results[x]))

        # We close the handles if populated
        if hsubkey:
            self.winreg.close_key(hsubkey)
        if hrootkey:
            self.winreg.close_key(hrootkey)
        # Time to say goodbye
        if not ret:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0
        else:
            self.setInfo("%s - done (success)" % (NAME))
            return 1

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
