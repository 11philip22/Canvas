#! /usr/bin/env python
"""
VulnAssess.py


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="VulnAssess"
VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.

Added toggles for whereami/traceroute at customer request alexm@ 8/14/08
"""

DEBUGNOTES="""

"""

import os
import sys
sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import time

from hostKnowledge import *
from engine.config import canvas_resources_directory

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host do an osdetect which generates an os basename
			 Portscan each alive host from 1-1100
			 If port 88 is open and os is Windows, then it is a domain server, so note that.
			 If port 1433 is open, it is a SQL Server, so note that.
			 If port 80 is open, it is a web server, so note that.
3. For each exploit in our exploit modules list, check to see which ones match that 
basename and run their test function
4. For each exploit in an explicit internal list, if the basename matches, run
the exploit and see if we get in. If so, drop a file, and disconnect.
5. Write a little report about it using our reporting module
"""

DOCUMENTATION["Todo"]="""
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""


NAME="VulnAssess"
DESCRIPTION="Safe Vulnerability Assessment Tool"
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Tools"
GTK2_DIALOG="dialog.glade2"
NOTES=""" 

"""



class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)
		self.vulns=[]
		self.setPort(0)
		self.setHost("")
		self.setVersion(1)
		self.istest=0
		self.setVersions()
		self.shellcode="A"
		self.localhost=""
		self.localport=0
		self.ssl=0
		self.doshell=1
		self.force=0
		self.name=NAME
		self.netmask="32"
		self.portscan=1 #default is do a portscan
		self.autohack_state=False 
		self.portlow=1
		self.porthigh=1200
		self.silica_flag=False
		self.ssid=""
		self.do_testhost=False #should we run testhost (default is NO, instead we run a list of preselected recon modules)
		self.passive_detector=None 
		self.traceroute=True # Toggle traceroute, added at customer request
		self.whereami=True # Same request as above
		return


	def getargs(self):
		self.host=self.target.interface
		self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).split(".")[0])
		self.portscan=int(self.argsDict.get("portscan",self.portscan))
		self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
		self.getarg("do_testhost") #if we want testhost
		# Added for customer requests
		if bool(self.argsDict.get("traceroute", self.traceroute)) == False:
			self.traceroute = True
		else:
			self.traceroute = False

		if bool(self.argsDict.get("whereami", self.whereami)) == False:
			self.whereami = True
		else:
			self.whereami = False
		#silica vars
		self.ssid=self.argsDict.get("ssid", "")
		self.silica_flag=self.argsDict.get("silica_flag",self.silica_flag)


	def finish(self):
		return 



	def process_thread_results(self, status_q, end_of_run_marker):
		"""
		This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
		what they are up to via a q to the ThreadTracker, The ThreadTracker then does some
		sanitization and spits stuff back down a status q to us.

		This means that we can sit in a loop and read from the same q for all the targets in
		our range and do stuff like reporting based on what we see coming back.

		Data comes back in the form of:
			 [Thread Object to which this status relate] , [status marker] ,[data]

		*REMEBER* this is one queue for ALL threads, not one for each!
		"""
		#TODO **** Change to a register handlers model .....
		while 1:
			tr2_obj, status, data=status_q.get()

			if status == end_of_run_marker:
				##ALL threads have completed so now more status/results to process
				tr2_obj.join()
				break

			# elif status == "newhost":
			# 	self.report.newhost(data) #data == target

			# elif status == "note":
			# 	self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str

			# elif status == "extras":
			# 	self.report.add_extras(data) #data == str

			# elif status == "failure":
			# 	self.report.report_failure(data) #data == target

			# elif status == "killed":
			# 	self.report.report_failure(data[0]) #data == target
			# 	self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
			# elif status=="error":
			# 	self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
			
			elif status=="dead":
				##Skip hosts that are not alive
				pass

			elif status == "exception":
				print data


		self.log("All results gathered")

	def run(self):
	
		self.getargs()
		self.log("Interface=%s"%self.host)
		self.log("Netmask=%s"%self.netmask)
		self.log("Maxthreads for VulnAssess: %d"%self.maxthreads)
		self.log("Whereami set to: %s"%self.whereami)
		self.log("Traceroute set to: %s"%self.traceroute)
		
		self.localips=[]
		for node in self.argsDict.get("passednodes",[]):
			self.localips+=node.getallips()

		self.vulns=[] #clear it

		try:
			if not canvasengine.registeredallmodules:
				canvasengine.registerAllModules()
				
			##Get the list of modules that we want autohack to run through (this will be made not static in future)
			fd=open(os.path.join(canvas_resources_directory,"vulnassess.txt"),"rb")
			self.exploit_modules=fd.readlines()
			fd.close()
			self.exploit_modules=map(str.strip,self.exploit_modules)			

			self.node=self.argsDict["passednodes"][0]
			dothreads = "threads" in self.node.capabilities
			if not dothreads:
				self.log("Warning: not using threads because select node does not support threading, resetting maxthreads to 1.")
				self.maxthreads=1


			self.setInfo("[VulnAssess2] Scanning network: %s/%s"%(self.host, self.netmask))
			self.setProgress(5)

			# Run whereami to note where we're running from
			# Added toggle for customer 8/14/08
			if self.whereami == True:
				app=self.engine.getModuleExploit("whereami")
				app.link(self)
				ret=app.run()
			else:
				self.log("Whereami set to off, proceding")

			self.run_threaded_on_alive_hosts(e_module="autoassess")
				
			# if self.silica_flag:
			# 	tdate = time.time()
			# 	filename = "VA_Report_%s_%s_%s.html"%(self.ssid,self.host,tdate)
			# 	sr = reporting.SilicaReport('VulnAssess2', self.ssid)
			# 	data = sr.create_silica_report()
			# else:
			# 	filename="Vulnassess2_report_%s_%s.html"%(self.host,self.netmask)
			# 	data=self.report.generate_vulnassess_html()


			self.setInfo("VulnAssess2 scanning %s (done)"%(self.host))
			self.finish()

		except:
			self.finish()
			raise #this will raise the exception again 

		return 1

	def setVersions(self):
		self.versions={}

		self.versions[1]=("All", None)


	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])


def usage():
	app = theexploit()
	print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
	app.displayVersions()

#this stuff happens.
if __name__ == '__main__':
	print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
	app = theexploit()
	ret=standard_callback_commandline(app)

