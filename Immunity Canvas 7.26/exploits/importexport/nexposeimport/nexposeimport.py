#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/ for more information
import sys
if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import canvasengine
from engine import CanvasConfig

import xml.sax
import textwrap

# GUI info
NAME                            = "nexposeimport"
DESCRIPTION                     = "Imports data from Nexpose XML reports into CANVAS"
DOCUMENTATION                   = {}
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION['Usage']          = "Just supply an XML report from Nexpose"
DOCUMENTATION['Credit']         = "Module requested and beta tested by Justin Vaicaro"
DOCUMENTATION['Notes']          = """

Data imported per host (if known):
- ip
- fqdn
- open TCP ports
- open UDP ports
- the top probability OS guess
- all CVEs and if appropriate their CANVAS module name

Tested with reports generated by:
Nexpose Enterprise v5.13.0 , April/2015

To view the results of the import, right click on your local node then mouse over
the IP of interest and select 'View all knowledge'


NOTE: This module is in beta, we expect there will be some bugs. Obviously at
Immunity we're not Rapid7 customers so we don't have access to Nexpose
to generate scans. The module works with our set of test scans very
reliably. Any CANVAS customers who are able to try to import scans of
under 1000 hosts and report back on any bugs they may run into would
help make the module better for everyone.
"""

VERSION                         = "0.1"
PROPERTY                        = {}
PROPERTY['TYPE']                = "ImportExport"
PROPERTY['SITE']                = "Local"


class infoClass():
    """
    Hold the parsed information, this class is instantiated per host within nexposeXMLHandler.masterDict[ip]
    """
    def __init__(self):
        self.cves             = []        # List of all CVE's
        self.tcpPorts         = []        # [135, 139, 445, ...]
        self.udpPorts         = []        # [123, 161, ...]
        self.fqdn             = "Unknown" #
        self.osGuess          = []        # A list of tuples (float(confidence_score), "os_string")
        self.testIds          = []        # CVE's are associated to hosts through 'tests'

class nexposeXMLHandler(xml.sax.handler.ContentHandler):
    """
    This class handles all the XML, if you want additional data imported you'll deal with it here
    """
    def __init__(self):
        self.__indata      = False # Use it to toggle the parser telling it we want <tag>this_data</tag>
        self.currentHost   = ""    # Which host are we working on
        self.currentTag    = ""    # Which tag are we working on -- note this doesn't track parent tags at all
        self.masterDict    = {}    # This will store everything we want from the parsed session
        self.debug         = False # Enable if you need to see which tag data came from
        self.hostCount     = 0     # Count number of hosts
        self.vulns         = {}    # The <vulnerability> tag is referenced by <test> so we have to match one to the other
        self.inVuln        = False # We have to track state a bit
        self.currentVulnId = ""    # Track which <vulnerability id="x"> we are in

    def startElement(self, name, attrs):
        """
        Handle new tags and data in the tag: <tag name="data"></tag>
        """
        self.currentTag = ""

        if name == "node":
            # This defines the host we're looking at
            self.hostCount += 1
            try:
                #print "\t" + str(attrs['name'])
                self.currentHost = str(attrs['address'])
                self.masterDict[self.currentHost] = infoClass()
            except Exception, e:
                print "\t" + "Unable to find name/ip"
                print "Exception was: %s" % e
            #self.log_info("Found host: %s" % self.currentHost)

        if name == "name":
            # Grab FQDN
            self.currentTag = "name"
            self.__indata   = True

        if name == "os":
            # Operating system guesses
            # We go through this parsing pain so we don't get strings like "Linux Linux Linux 80%"
            self.currentTag = "os"
            deviceClass     = ""
            vendor          = ""
            product         = ""
            family          = ""
            version         = ""
            certainty       = ""
            os              = ""

            # These should always exist
            certainty = float(attrs['certainty'])
            product   = str(attrs['product'])

            if attrs.has_key('version'):
                version = str(attrs['version'])
            if attrs.has_key("family"):
                family = str(attrs['family'])
            if attrs.has_key("product"):
                product = str(attrs['product'])
            if attrs.has_key("vendor"):
                vendor = str(attrs['vendor'])
            if attrs.has_key("device-class"):
                deviceClass = str(attrs['device-class'])

            if vendor != product:
                os = " ".join([vendor, deviceClass, product, version])
            else:
                os = " ".join([vendor, deviceClass, version])

            self.masterDict[self.currentHost].osGuess.append((certainty, os))

        if name == "endpoint":
            # Open ports
            self.currentTag = "endpoint"
            proto           = str(attrs['protocol'])
            status          = str(attrs['status'])
            port            = str(attrs['port'])

            if proto == "tcp" and status == "open":
                if port not in self.masterDict[self.currentHost].tcpPorts:
                    self.masterDict[self.currentHost].tcpPorts.append(port)
            elif proto == "udp" and status == "open":
                if port not in self.masterDict[self.currentHost].udpPorts:
                    self.masterDict[self.currentHost].udpPorts.append(port)

        if name == "reference":
            # Where we grab CVEs
            self.currentTag = "reference"
            source          = str(attrs['source'])
            if source == "CVE":
                self.__indata = True

        if name == "test":
            # Some vulns have straight up reference tags and CVEs
            # other vulns have 'tests' which we then have to match to a definition
            # which occurs at the end of the XML file :-/
            self.currentTag = "test"

            if attrs.has_key('id'):
                _id = str(attrs['id']).upper()
                if _id not in self.masterDict[self.currentHost].testIds:
                    self.masterDict[self.currentHost].testIds.append(_id)

        if name == "vulnerability":
            self.currentVulnId = str(attrs['id']).upper()

    def endElement(self, name):
        """
        Practically we use this to figure out one level deep tag hierarchy
        """
        if name == "vulnerability":
            self.currentVulnId = ""

    def characters(self, data):
        """
        Handle data between tags: <tag>data</tag>
        """
        if(self.__indata):
            self.__indata = False

            if (self.debug):
                print '\t\t' + self.currentTag + " - " + repr(data)
            if self.currentTag == "reference" and self.currentVulnId != "":
                cve = data
                self.vulns[self.currentVulnId] = cve
            elif self.currentTag == "name":
                self.masterDict[self.currentHost].fqdn = data
            else:
                pass

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name       = NAME
        self.filename   = ""
        self.filetype   = ""
        self.debug      = False # Debug (see parseDotNessus() and dotNessusXML.characters())
        self.canvasCVE  = {}    # Hold the CVE list
        self.dnsResolve = None  # This will hold the value of dnsresolve from CANVAS config

    def addToKnowledge(self, handler):
        """
        Pull the data parsed from the XML file into the CANVAS KB
        """
        node  = self.argsDict["passednodes"][0]
        count = 1
        total = len(handler.masterDict.keys())

        self.dnsResolve = CanvasConfig['dnsresolve']
        self.log_info("Temporarily disabling DNS resolution")
        CanvasConfig['dnsresolve'] = False

        for host in handler.masterDict.keys():
            self.log_info("Adding info from host: %s " % host)
            count  += 1
            newhost = node.new_host(host)
            newhost.add_to_knowledge("Nexpose FQDN", handler.masterDict[host].fqdn)

            # Import operating system
            try:
                osTup = sorted(handler.masterDict[host].osGuess, key=lambda tup: float(tup[0]), reverse=True)[0]
                newhost.add_to_knowledge("Nexpose OS", "OS: %s , Confidence: %s" % (osTup[1], osTup[0]*100))
            except IndexError as e:
                # No OS guess
                pass

            # Import TCP/UDP ports
            if len(handler.masterDict[host].tcpPorts) == 0:
                newhost.add_to_knowledge("Nexpose open TCP Ports", "None")
            else:
                newhost.add_to_knowledge("Nexpose open TCP Ports", handler.masterDict[host].tcpPorts)

            if len(handler.masterDict[host].udpPorts) == 0:
                newhost.add_to_knowledge("Nexpose Open UDP Ports", "None")
            else:
                newhost.add_to_knowledge("Nexpose open UDP Ports", handler.masterDict[host].udpPorts)

            # Import CVEs
            cveList = { "found"    : [],
                        "notfound" : [],
                        "nocve"    : [] }

            for testId in handler.masterDict[host].testIds:
                if handler.vulns.has_key(testId):
                    cveNum = handler.vulns[testId]
                    if self.canvasCVE.has_key(cveNum):
                        cveList["found"].append("%s -- CANVAS Module: %s" % (cveNum, self.canvasCVE[cveNum]))
                    else:
                        cveList["notfound"].append("%s -- Has no corresponding CANVAS module" % cveNum)
                else:
                    cveList["nocve"].append("No CVE for %s" % testId)

            for line in sorted(cveList['found']):
                heading, module = line.split(" -- ")
                newhost.add_to_knowledge(heading, module)

            for line in sorted(cveList['notfound']):
                heading, error = line.split(" -- ")
                newhost.add_to_knowledge(heading, error)

            if len(cveList['nocve']) > 0:
                for x in xrange(0, len(cveList['nocve'])):
                    # Each key in the KB's key/value pair has to be unique so we solve it simply
                    newhost.add_to_knowledge("Nexpose Test %d" % x, cveList['nocve'][x])

        # Import has completed   
        self.log_info("Resetting DNS Resolver settings")
        CanvasConfig['dnsresolve'] = self.dnsResolve

        return 0

    def parseNexposeXML(self):
        """
        Parsers the customer provided Nexpose XML report
        The debug info here will be helpful
        """
        parser  = xml.sax.make_parser()
        handler = nexposeXMLHandler()
        parser.setContentHandler(handler)

        try:
            with open(self.filename, 'r') as nexposeFile:
                parser.parse(nexposeFile)
        except IOError as io_err:
            self.log_error(str(io_err))
            return -1

        self.log_info("Done parsing file")
        self.setProgress(40)
        self.log_info("Total hosts found: %d" % handler.hostCount)

        if (handler.hostCount >= 255):
            self.log_info("255 or greater hosts detected, this will take a while to import!")
            self.setInfo("More than 255 hosts found, be patient...")

        self.addToKnowledge(handler)
        return 0

    def fileCheck(self):
        """
        Verify we have a sane file
        """
        try:
            with open(self.filename, 'r') as nexposeFile:
                data = nexposeFile.read().splitlines()
        except IOError as io_err:
            self.log_error(str(io_err))
            return False

        if data[0] != """<NexposeReport version="2.0">""":
            self.log_error("Unsupported Nexpose report version: %s" % data[0])
            self.log_error("Please send a sanitized .xml to support@immunityinc.com")
        elif data[-1] != """</NexposeReport>""":
            self.log_error("Report file does not end with </NexposeReport>, corrupted file?")
        else:
            return True

        return False

    def getCVEList(self):
        """
        Return a dict where {cve number : module name}
        """
        canvasengine.registerAllModules()
        exploitmods_old = canvasengine.exploitmodsGet(False)
        bunkList        = ["N/A", '', 'Unknown' , 'Unkown', 'None', 'None/SilentlyPatched']
        cveDict         = {}
        skipList        = 0

        for key in exploitmods_old.keys():
            try:
                exploitmods_old[key].DOCUMENTATION["CVE Name"]
                if exploitmods_old[key].DOCUMENTATION["CVE Name"] not in bunkList:
                    cveDict[exploitmods_old[key].DOCUMENTATION["CVE Name"]] = key
            except:
                skipList += 1
        self.log_info("Found %d modules with CVEs, skipped %d" % (len(cveDict), skipList))
        return cveDict

    def run(self):
        self.filename = self.argsDict.get("source", self.filename)
        if self.filename == "":
            self.log_error("No filename provided")
            return -1
        if not self.fileCheck():
            # Bad file
            return -1

        self.log_info("Generating list of CANVAS CVEs...")
        self.setInfo("Generating list of CANVAS CVEs...")
        self.canvasCVE = self.getCVEList()
        self.setProgress(20)
        self.log_info("Done generating CVE list")
        self.log_info("Importing Nexpose results from %s into CANVAS" % self.filename)
        self.parseNexposeXML()

        self.log_info("Module: nexposeimport finished")
        self.setProgress(100)
        return 1


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
