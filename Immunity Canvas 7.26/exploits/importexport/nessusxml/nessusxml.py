
#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information
import sys
if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand
import canvasengine
import xml.sax
from engine import CanvasConfig


# GUI info
NAME                            = "nessusxml"
DESCRIPTION                     = "Imports data from Nessus into CANVAS"
DOCUMENTATION                   = {}
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION['Usage']          = "Supply a .nessus file to import"
DOCUMENTATION['Notes']          = """

Data imported:
- Hosts
- TCP Ports
- UDP Ports
- Operating System
- FQDN
- CVEs and if applicable their corresponding CANVAS modules

Tested with reports from: 
- Nessus Cloud 6.3

Report formats currently supported:
- Nessus >= 4.4 : .nessus (really an XML file)

"""

VERSION                         = "0.4"
PROPERTY                        = {}
PROPERTY['TYPE']                = "ImportExport"
PROPERTY['SITE']                = "Local"


class info():
    """
    Hold the parsed information, this class is instantiated in nessus4xml in a dict where each host is the key
    """
    def __init__(self):
        self.operatingSystem  = "Unknown"  # A lot of varience in this string, nessus -> CANVAS mapping will be difficult
        self.hostIp           = ""         # Nessus typically differentiates hosts by IP, sometimes this is populated anyway
        self.cves             = []         # List of all CVE's
        self.tcpPorts         = []         #
        self.udpPorts         = []         #
        self.fqdn             = "Unknown"  #

class dotNessusXML(xml.sax.handler.ContentHandler):
    """
    This class handles all the XML, if you want additional data imported you'll deal with it here
    """
    def __init__(self):
        self.__indata    = False  # Use it to toggle the parser telling it we want the data for this tag
        self.currentHost = ""     # Which host are we working on
        self.currentTag  = ""     # Which tag are we working on
        self.masterDict  = {}     # This will store everything we want from the parsed session
        self.debug       = False  # Enable if you need to see which tag data came from
        self.hostCount   = 0      # Count number of hosts

    def startElement(self, name, attrs):
        """
        Handle new tags and data in the tag: <tag name="data"></tag>
        """

        self.currentTag = ""

        if name == "ReportHost":
            self.hostCount += 1
            try:
                self.currentHost                  = str(attrs['name'])
                self.masterDict[self.currentHost] = info()
            except Exception, e:
                print "\t" + "Unable to find name/ip"
                print "Exception was: %s" % e

        if name == "tag":
            try:
                name = str(attrs['name'])
            except Exception, e:
                name = "Error"
                print "Error parsing tag"
                print "Exception was: %s" % e
            if name == "host-ip":
                self.currentTag = "host_ip"   # How to process the data
                self.__indata   = True        # Flag for processing by dotNessusXML.characters()
            elif name == "operating-system":
                self.currentTag = "operating-system"
                self.__indata   = True
            elif name == "host-fqdn":
                self.currentTag = "host_fqdn"
                self.__indata   = True
        else:
            pass

        if name == "ReportItem":
            try:
                port  = int(attrs['port'])
                proto = str(attrs['protocol'])
            except Exception, e:
                self.log_error("Unable to parse ReportItem tag")
                self.log_error("Exception was: %s" % e)
            if proto == "tcp":
                if port not in self.masterDict[self.currentHost].tcpPorts and port != 0:
                    self.masterDict[self.currentHost].tcpPorts.append(port)
            elif proto == "udp":
                if port not in self.masterDict[self.currentHost].udpPorts and port != 0:
                    self.masterDict[self.currentHost].udpPorts.append(port)

        if name == "cve":
            self.currentTag = "cve"
            self.__indata   = True

    def endElement(self, name):
        """
        Uncomment this for debugging the XML parsing
        """
        #print 'End element:', name
        pass

    def characters(self, data):
        """
        Handle data between tags: <tag>data</tag>
        """
        if (self.__indata):
            self.__indata = False
            if (self.debug):
                print '\t\t' + self.currentTag + " - " + repr(data)

            if self.currentTag == "operating-system":
                self.masterDict[self.currentHost].operatingSystem = data
            elif self.currentTag == "cve":
                if data not in self.masterDict[self.currentHost].cves:
                    self.masterDict[self.currentHost].cves.append(data)
                elif self.currentTag == "host_ip":
                    self.masterDict[self.currentHost].hostIp = data
            elif self.currentTag == "host_fqdn":
                self.masterDict[self.currentHost].fqdn = data
            else:
                pass

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name       = NAME
        self.fileName   = ""
        self.fileType   = "Unknown" # 
        self.debug      = False     # Debug -- see: dotNessusXML.characters()
        self.canvasCVE  = {}        # Hold the CVE list
        self.dnsResolve = None      # Hold the value for dnsresolve in canvas config

    def importDotNessus(self, masterDict):
        """
        Pull the data parsed from self.parseDotNessus() into the CANVAS KB
        """
        node  = self.argsDict["passednodes"][0]
        count = 1
        total = len(masterDict.keys())

        self.dnsResolve = CanvasConfig['dnsresolve']
        self.log_info("Temporarily disabling DNS resolution")
        CanvasConfig['dnsresolve'] = False

        for host in masterDict.keys():
            self.log_info("Adding host %d (%s) of %d" % (count, host, total))
            self.setInfo("Adding host %d (%s) of %d" % (count, host, total))
            count   += 1

            newhost = node.new_host(host)
            newhost.add_to_knowledge("Nessus OS", masterDict[host].operatingSystem)
            newhost.add_to_knowledge("Nessus FQDN", masterDict[host].fqdn)
    
            #TCP Ports
            if len(masterDict[host].tcpPorts) == 0:
                newhost.add_to_knowledge("Nessus TCP Ports", ["None"])
            else:
                newhost.add_to_knowledge("Nessus TCP Ports", masterDict[host].tcpPorts)

            #UDP Ports
            if len(masterDict[host].udpPorts) == 0:
                newhost.add_to_knowledge("Nessus UDP Ports", ["None"])
            else:
                newhost.add_to_knowledge("Nessus UDP Ports", masterDict[host].udpPorts)

            #CVE Numbers
            cveList = sorted(masterDict[host].cves)
            cves_found = []
            for cve in cveList:
                key = "Nessus discovered %s" % cve
                if cve in self.canvasCVE.keys():
                    value = "CANVAS Module: %s" % self.canvasCVE[cve]
                    cves_found.append(self.canvasCVE[cve])
                else:
                    value = "No corresponding CANVAS module"
                newhost.add_to_knowledge(key, value)

            if len(cves_found) != 0:
                self.log_info("%s is vulnerable to the following exploits: %s" % (str(host), repr(cves_found)))

        self.log_info("Resetting DNS Resolver settings")
        CanvasConfig['dnsresolve'] = self.dnsResolve

    def parseDotNessus(self):
        """
        Uses the nessus4xml class as a XML parsing handler
        The debug info here will be helpful
        """
        parser  = xml.sax.make_parser()
        handler = dotNessusXML()
        parser.setContentHandler(handler)
        
        try: 
            self.log_info("Parsing file")
            self.setInfo("Parsing file")
            with open(self.fileName, 'r') as reportFile:
                parser.parse(reportFile)
        except IOError as io_err:
            self.log_error(str(io_err))
            return -1

        self.log_info("Done parsing file")
        self.setProgress(40)
        self.log_info("Total hosts found: %d" % handler.hostCount)
        if (handler.hostCount >= 255):
            self.log_info("!! 255 or greater hosts detected, this will take a while to import !!")

        if (self.debug):
            # This will print all the parsed data to stdout
            for host in handler.masterDict.keys():
                handler.masterDict[host].tcpPorts.sort()
                handler.masterDict[host].udpPorts.sort()
                handler.masterDict[host].cves.sort()
                print host
                print "\tOperating System: " + handler.masterDict[host].operatingSystem
                print "\tHost IP: "+ handler.masterDict[host].hostIp
                print "\tHost FQDN: "+ handler.masterDict[host].fqdn
                tcpPorts = ""
                for port in handler.masterDict[host].tcpPorts:
                    tcpPorts += str(port) + ","
                print "\tTCP Ports: %s"%tcpPorts[0:-1]
                udpPorts = ""
                for port in handler.masterDict[host].udpPorts:
                    udpPorts += str(port) + ","
                print "\tUDP Ports: %s"%udpPorts[0:-1]
                cves = ""
                for cve in handler.masterDict[host].cves:
                    cves += cve + ","
                print "\tCVEs: %s"%cves[0:-1]
                print "----------"

        self.importDotNessus(handler.masterDict)

    def findFileType(self):
        """
        Determine the file type we're dealing with
        """
        try:
            with open(self.fileName, 'r') as reportFile:
                firstLine = reportFile.readline()
        except Exception,e:
            self.log_error("Unable to open file %s, exiting ..." % self.fileName)
            self.log_error("Exception was: %s" % e)
            return -1
        if firstLine.find("|||") != -1:
            return "nessus3-nbe"
        elif firstLine.find("|") != -1:
            return "nessus3-nsr"
        elif firstLine.find("<?xml") != -1:
            return ".nessus"
        else:
            return -1

    def getCVEList(self):
        """
        Return a dict where {cve number : module name}
        """
        canvasengine.registerAllModules()
        exploitmods_old = canvasengine.exploitmodsGet(False)
        bunkList        = ["N/A", '', 'Unknown' , 'Unkown', 'None', 'None/SilentlyPatched'] # Catches instances where the cve number value is non-standard
        cveDict         = {}
        skipList        = 0

        for key in exploitmods_old.keys():
            try:
                exploitmods_old[key].DOCUMENTATION["CVE Name"]
                if exploitmods_old[key].DOCUMENTATION["CVE Name"] not in bunkList:
                    cveDict[exploitmods_old[key].DOCUMENTATION["CVE Name"]] = key
            except:
                skipList += 1
        self.log_info("Found %d modules with CVEs, skipped %d" % (len(cveDict), skipList))
        return cveDict


    def usage(self):
        print "="*10
        print "This module imports information from a Nessus scan into the CANVAS GUI."
        print "Usage: nessusxml.py -O source:myscan.nessus"
        print "\t-O source:<filename to import>"
        print "="*10

    def run(self):
        self.fileName = self.argsDict.get("source", self.fileName)

        if self.fileName == "":
            self.log_error("No filename provided")
            self.usage()
            return -1

        self.fileType = self.findFileType() # Initial parsing of file
        if self.fileType == -1:
            self.log_error("Error determining file type, please provided a .nessus file")
            return -1

        self.log_info("Generating list of CANVAS CVEs")
        self.setInfo("Generating list of CANVAS CVEs")
        self.canvasCVE = self.getCVEList()
        self.setProgress(20)
        self.log_info("Importing %s scan" % (self.fileName))

        if self.fileType == ".nessus":
            ret = self.parseDotNessus()
            if ret == -1:
                self.log_info("Unable to continue, exiting module ...")
                return -1
        elif self.fileType == "Unknown":
            self.log_info("Could not determine file type, exiting...")

        self.setInfo("Done")
        self.log_info("nessusxml finished")
        self.setProgress(100)
        return 1


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
