#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


# CANVAS Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path: sys.path.append(".")

import socket
import timeoutsocket
import time
import select

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor

# GUI info
NAME="Portsweep"
DESCRIPTION="Scans for one port on many hosts"
DOCUMENTATION={}
DOCUMENTATION["Notes"] = "This is a scanrand-like portsweeping module\nthat uses a sniffer and raw socket sender\nto do extremely fast portscanning"
DOCUMENTATION["Callback"]="Make sure you have the callback set to the right IP! Otherwise the TCP checksum will be incorrect and all the packets will be dropped..."
DOCUMENTATION["From Port"]="Is only used when doing SYN scanning (root+linux)"
DOCUMENTATION["Snort"]="May trigger: [**] [1:504:7] MISC source port 53 to <1024 [**]"
DOCUMENTATION["Windows"]="For XP, this link is helpful: http://support.microsoft.com/kb/314053"
DOCUMENTATION["XPSP2"]="This module will not work from XPSP2 - it will miss hosts due to their connection limiting. There is a TCPIP.SYS patch you can apply, but we don't recommend it. Use Linux"
DOCUMENTATION["Notes"]="If postHTTP variable is set, we will do an HTTP fingerprint on any hosts we find"
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

For commandline, you'll want to use -O source:SOURCEIP to avoid bad checksums

"""

CHANGELOG="""
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done = 0
        self.port=53 
        self.fromport=53 #if fromport is 0 we randomize it
        self.closedhosts=[]
        self.openhosts=[]
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=60
        self.result=self.openhosts
        #source=self.engine.get_callback_interface().ip
        self.source="127.0.0.1"
        self.netmask="32"
        self.postHTTP=False

        return
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("TCP Connect Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def port_callback(self,parser):
        devlog("portsweep", "Callback got triggered for portsweep")
        host=parser.attribs["ipsource"]
        #print "parser.attribs=%s"%parser.attribs
        flags=parser.attribs["tcpflags"]
        #print "flags=%s"%flags
        if "SYN" in flags and "ACK" in flags:
            self.openhosts+=[host]
            self.log("Found open host:port %s:%d"%(host,self.port))
        elif "RST" in flags and "ACK" in flags:
            self.closedhosts+=[host]
            self.log("Found closed host:port %s:%d"%(host,self.port))          
        return

    def C_isOpen(self, host, port):
        s=self.gettcpsock()
        s.set_timeout(self.timeout)
        try:
            self.log("Probing host %s:%s"%(host,port))
            s.connect( (host, port))
        except socket.error, msg:
            self.log("Error: %s"%msg)
            if str(msg).count("No route to host"):
                return -1
            return 0
        except timeoutsocket.Timeout:
            return -1
        s.close()
        return 1
    
    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """
        host=target.interface

        if self.state==self.HALT:
            return 
        
        if self.doscanrand:
            mysender=sender(target=host)
            mpacker=packetConstructor()
            #self.port is really self.fromport here
            #print "source=%s dest=%s"%(source,dest)
            mpacker.TCP(self.source,host,["SYN"],self.fromport,self.port,"")
            mysender.sendto(mpacker.get(),"TCP",(host,0))
            #if you don't sleep, you'll miss some ports. 
            time.sleep(0.01)
            
        else:
            ret=self.C_isOpen(host, self.port)
            if ret==1:
                self.log("Found %s port %d open"%(host,self.port))
                self.openhosts.append(host)

            elif ret==0:
                self.log("Found %s port %d closed"%(host,self.port))
                self.closedhosts.append(host)                
                
        return

    def getargs(self):
        self.host=self.target.interface
        self.timeout=float(self.argsDict.get("timeout",self.timeout))
        self.source=self.argsDict.get("source",self.engine.get_callback_interface(self.host))
        self.netmask=self.argsDict.get("netmask",self.netmask)
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.fromport=int(self.argsDict.get("fromport",self.fromport))
        self.port=int(self.argsDict.get("port",self.port))
        self.getarg("postHTTP")
        
        return 
    
    def run(self):        
        self.getargs()
        
        if isinstance(self.netmask, str):
            self.netmask=int(self.netmask.replace("/",""))
            
        self.setInfo("Portsweeping %s/%s port %s from %s"%(self.host,self.netmask,self.port,self.fromport))
        self.log("Portsweeping %s/%s port %s from %s"%(self.host,self.netmask,self.port,self.fromport))
        self.node=self.argsDict["passednodes"][0]
        self.log("Timeout=%s"%self.timeout)
        self.doscanrand=0

        
        if self.can_scanrand(target = self.host):
            if not self.engine.sniffer_isactive():
                self.log("sniffer not active")
                self.setInfo("Portsweep: Not running as root - sniffer not active")
            else:
                self.doscanrand=1
                #openfs="tcpsource(%s) tcpdest(%s)"%(self.port,self.fromport)
                openfs="tcpsport(%s) tcpdport(%s)"%(self.port,self.fromport)
                #print "self.port_callback=%s"%self.port_callback
                self.engine.register_sniffer_callback(self.port_callback,openfs)
        
        dothreads = "threads" in self.node.capabilities

        #we don't do threads if we're a silica
        if self.argsDict.get("silica",False):
            dothreads=True
            
        self.run_on_all_possible_hosts(threads=dothreads)
        if dothreads:
            self.log("Recovering from threads")
            time.sleep(2)
        

        self.openhosts=uniquelist(self.openhosts)
        self.closedhosts=uniquelist(self.closedhosts)
        #print "Closed: %s"%self.closedports
        self.log("Hosts with open ports %s: %s"%(self.port,self.openhosts))
        self.log("Hosts with closed ports %s: %s"%(self.port,self.closedhosts))
        
        for host in self.openhosts:
            if(host != self.host):
                newhost=self.node.add_host(host)
                newhost.add_to_knowledge("TCPPORTS",[self.port])
            if self.postHTTP:
                newhost=self.node.add_host(host)
                httpscan=self.engine.getModuleExploit("httpfingerprint")
                httpscan.link(self)
                httpscan.target=newhost
                httpscan.port=self.port
                self.log("Running httpscan on %s"%host)
                httpscan.run()
        
        for host in self.closedhosts:
            if(host != self.host):
                self.node.add_host(host)

        if self.doscanrand:
            self.engine.unregister_sniffer_callback(self.port_callback)
        self.log("All done")            
        return 1

    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])


    #def usage(self):
    #    import sys
    #    #print "Usage: %s -t host -l localhost [-c covertness]"% sys.argv[0],
    #    self.displayVersions()

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    
