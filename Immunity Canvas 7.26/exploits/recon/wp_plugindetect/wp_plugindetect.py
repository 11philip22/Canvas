#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2013
#http://www.immunityinc.com/CANVAS/ for more information
from __future__ import division
import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *
from canvasexploit import canvasexploit

import urllib2
from urlparse import urlparse
import httplib
import re
import difflib
import random
import json
import string

NAME                           = "wp_plugindetect"
DESCRIPTION                    = "Find all visible plugins"

DOCUMENTATION                  = {}
DOCUMENTATION["VENDOR"]        = "Wordpress"
DOCUMENTATION["References"]    = "http://www.wordpress.org/"
DOCUMENTATION["Repeatability"] = "Infinite"

VERSION                        = "1.0"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Recon"
PROPERTY['SITE']               = "Remote"

from contextlib import contextmanager
from libs.spkproxy import *

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.found_plugins = []
        self.result = None
        self.name = NAME
        self.port = 80
        self.ssl = 0
        self.full_analysis = 0
        self.randomize = 0
        self.basepath = "/"
        self.cookies = ""
        self.timeout = 60
        self.page404 = []
        self.top_plugins = {'Akismet': 'akismet',
                            'Yoast SEO': 'wordpress-seo',
                            'Contact Form 7': 'contact-form-7',
                            'Jetpack by WordPress.com': 'jetpack',
                            'Wordfence Security': 'wordfence',
                            'NextGEN Gallery by Photocrati': 'nextgen-gallery',
                            'MailPoet Newsletters': 'wysija-newsletters',
                            'All in One SEO Pack': 'all-in-one-seo-pack',
                            'WP Super Cache': 'wp-super-cache',
                            'WordPress Importer': 'wordpress-importer',
                            'Google XML Sitemaps': 'google-sitemap-generator',
                            'iThemes Security': 'better-wp-security',
                            'WooCommerce': 'woocommerce',
                            'Meta Slider': 'ml-slider',
                            'Fast Secure Contact Form': 'si-contact-form',
                            'WP-Optimize': 'wp-optimize',
                            'InfiniteWP - Client': 'iwp-client',
                            'WordPress Social Sharing Optimization (WPSSO)': 'wpsso',
                            'WPtouch Mobile Plugin': 'wptouch',
                            'NextGEN Facebook (NGFB)': 'nextgen-facebook',
                            'Captcha by BestWebSoft': 'captcha',
                            'W3 Total Cache': 'w3-total-cache',
                            'Shareaholic | share buttons, analytics, related content': 'shareaholic',
                            'MailChimp': 'mailchimp',
                            'MailChimp for WordPress': 'mailchimp-for-wp',
                            'Anti-Malware Security and Brute-Force Firewall': 'gotmls',
                            'UpdraftPlus - Backup/restoration': 'updraftplus',
                            'TinyMCE Advanced': 'tinymce-advanced',
                            'Broken Link Checker': 'broken-link-checker',
                            'Contact Form by BestWebSoft': 'contact-form-plugin',
                            'Shortcodes Ultimate': 'shortcodes-ultimate',
                            'Ninja Forms': 'ninja-forms',
                            'All In One WP Security': 'all-in-one-wp-security-and-firewall',
                            'WP Statistics': 'wp-statistics',
                            'Page Builder by SiteOrigin': 'siteorigin-panels',
                            'Google Analytics by MonsterInsights': 'google-analytics-for-wordpress',
                            'WP Google Maps': 'wp-google-maps',
                            'Really Simple CAPTCHA': 'really-simple-captcha',
                            'YouTube': 'youtube-embed-plus',
                            'WP-PageNavi': 'wp-pagenavi',
                            'Breadcrumb NavXT': 'breadcrumb-navxt',
                            'Advanced Custom Fields': 'advanced-custom-fields',
                            'All-in-One Event Calendar by Time.ly': 'all-in-one-event-calendar',
                            'Google Analytics Dashboard for WP': 'google-analytics-dashboard-for-wp',
                            'Regenerate Thumbnails': 'regenerate-thumbnails',
                            'User Role Editor': 'user-role-editor',
                            'Newsletter': 'newsletter',
                            'BuddyPress': 'buddypress',
                            'Sucuri Security - Auditing, Malware Scanner and Hardening': 'sucuri-scanner',
                            'The Events Calendar': 'the-events-calendar',
                            'Black Studio TinyMCE Widget': 'black-studio-tinymce-widget',
                            'Redirection': 'redirection',
                            'WP-DB-Backup': 'wp-db-backup',
                            'WP Mail SMTP': 'wp-mail-smtp',
                            'Image Widget': 'image-widget',
                            'BackWPup - Wordpress Backup Plugin': 'backwpup',
                            'WP Smush - Image Optimization': 'wp-smushit',
                            'TablePress': 'tablepress',
                            'Google Analyticator': 'google-analyticator',
                            'Contact Form DB': 'contact-form-7-to-database-extension',
                            'The Events Calendar': 'the-events-calendar',
                            'WP Maintenance Mode': 'wp-maintenance-mode',
                            'Formidable Forms': 'formidable',
                            'Post Types Order': 'post-types-order',
                            'Duplicate Post': 'duplicate-post',
                            'Hello Dolly': 'hello.php',
                            'Disable Comments': 'disable-comments',
                            'WP Multibyte Patch': 'wp-multibyte-patch',
                            'Clef Two-Factor Authentication': 'wpclef',
                            'Duplicator': 'duplicator',
                            'bbpress': 'bbpress'}
        return

    def getArgs(self):
        self.getarg("host")
        self.getarg("port")
        self.getarg("basepath")
        self.getarg("cookies")
        self.getarg("timeout")
        self.getarg("ssl")
        self.getarg("full_analysis")
        return

    def progress_bar(self, i):
        if i == 0:
            return "[          ] 0%"
        elif i == 14:
            self.setProgress(20)
            return "[==        ] 20%"
        elif i == 28:
            self.setProgress(40)
            return "[====      ] 40%"
        elif i == 35:
            self.setProgress(50)
            return "[=====     ] 50%"
        elif i == 49:
            self.setProgress(70)
            return "[=======   ] 70%"
        elif i == 63:
            self.setProgress(90)
            return "[========= ] 90%"
        return ""

    def createURL(self):
        """
        Logic to make a URL out of user input
        """
        if self.ssl:
            self.scheme = "https://"
        else:
            self.scheme = "http://"

        resolved_from=self.argsDict.get("resolved_from")
        if not resolved_from:
            resolved_from = self.host
        self.dif_port = ""
        if self.port == 80 or self.port == 443:
            dif_port = ":" + str(self.port)
        url = self.scheme + resolved_from + self.dif_port + self.basepath

        return url

    # Check custom 404 pages
    def check_404(self, urlBase, depth=0):
        invalid_url = urlBase
        if depth == 0:
            invalid_url += ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16)) + "/"
        elif depth > 2:
            self.page404 = []
            return
        req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36',
                   'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
        if self.cookies:
            headers['Cookie'] = self.cookies
        with no_timeout_socket():
            try:
                req.request("GET", invalid_url, headers=headers)
                url_404 = req.getresponse()
            except:
                return
            if url_404.status == 200:
                list_404 = []
                list_404.append(url_404.read())
                self.page404 += list_404
                return
            elif url_404.status in [301, 302, 305, 307]:
                try:
                    self.check_404(urlparse(url_404.getheader('location')).path, depth=depth+1)
                except:
                    return

    def test_wordpress(self, urlBase):
        """
        Check for the expected root directory structure in a Wordpress install
        This should be a reasonable test for the presence of Wordpress
        """
        with no_timeout_socket():
            self.log_info("Checking if provided URL is available")
            # Perform a sanity check
            req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36',
                       'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
            if self.cookies:
                headers['Cookie'] = self.cookies
            try:
                req.request("GET", urlparse(urlBase).path, headers=headers)
                res = req.getresponse()
                url_available = res.read()

            except Exception as e:
                self.log_error("Failed to fetch %s, check URL" % urlBase)
                sys.exit(1)
            self.log_info("Got URL")

            self.check_404(urlBase)

            # Is Wordpress present?
            self.log_info("Checking root directory structure")
            dirList = ["wp-admin", "wp-content", "wp-includes"]
            count = 0
            for d in dirList:
                url = urlBase + d + "/"
                try:
                    req.request("GET", urlparse(url).path, headers=headers)
                    res = req.getresponse()
                    resp = res.read()
                    count += 1

                except Exception as e:
                    self.log_error("Didn't find %s" % d)
                if res.status != 200:
                    count -= 1
                    self.log_error("Didn't find %s" % d)

            self.log_info("Check for admin-ajax.php")
            url = urlBase + "wp-admin/admin-ajax.php"
            admin_ajax = False
            try:
                req.request("GET", urlparse(url).path, headers=headers)
                res = req.getresponse()
                resp = res.read()
                admin_ajax = True
            except:
                self.log_error("Didn't find admin-ajax.php")
            if res.status != 200:
                admin_ajax = False
                self.log_error("Didn't find admin-ajax.php")

            if count / float(len(dirList)) > .6 or admin_ajax: # Allows for wp-includes or wp-content to be secured
                self.log_info("Found Wordpress")
                return True
            else:
                self.log_info("Last check")
                self.log_info("Checking if wp-admin, wp-content or wp-includes are in another place")
                dirs = re.findall("(src=|http://|https://)([^\n]*?)(wp-admin|wp-content|wp-includes)", url_available)
                hostname = self.host[4:self.host.rfind(".")] if self.host.startswith("www.") else self.host[:self.host.rfind(".")]
                dirs = [(host, d) for _, host, d in dirs if hostname in host or re.match("['|\"](.|/)wp-content", host)]
                if len(dirs) > 0:
                    self.log_info("Found Wordpress")
                    return True
                else:
                    self.log_error("Did not find Wordpress. It is possible that wp-includes, wp-content, and wp-admin have been secured.")
                    sys.exit(1)

    def find_plugins(self, url_base):
        self.log_info("Searching plugins")
        # TODO: Read wp-admin/admin-ajax.php
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36'}
        if self.cookies:
            headers['Cookie'] = self.cookies
        with no_timeout_socket():
            try:
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                req.request("GET", self.basepath, headers = headers)
                response = req.getresponse()
                code = response.status
                html = response.read()
            except:
                self.log_error("Server error")
                sys.exit(1)

        self.redir = 0
        if code == 301 or code == 302:
            self.log_error("The site is redirecting to another location, please try with the new location")
            self.log_info("We will try to reach wordpress directories in this site")
            self.redir = 1

        curr_plugins = re.findall('(src=|http://|https://|href=)([^\n]*?)plugins/(.+?)/', html)
        hostname = self.host[4:self.host.rfind(".")] if self.host.startswith("www.") else self.host[:self.host.rfind(".")]
        l = []
        l.append(self.scheme + self.host)
        curr_plugins = [plugins for _,host,plugins in curr_plugins if difflib.get_close_matches(host, l) or re.match("['|\"](.|/)wp-content", host) or hostname in host]
        curr_plugins = list(set(curr_plugins))

        self.found_plugins = self.found_plugins + curr_plugins

        for name, plugin in self.top_plugins.iteritems():
            if plugin in curr_plugins:
                self.found_plugins.append(name)
                self.found_plugins.remove(plugin)

        self.log_info("Searching plugins directory")
        # Path where all plugins lies
        path = ""
        if len(self.found_plugins) >= 1:
            if self.found_plugins[0] in self.top_plugins:
                pattern = re.compile(".*(src=|http://|https://|href=)([^\n]*?)/plugins/" + self.top_plugins[self.found_plugins[0]] + ".*", re.DOTALL)
            else:
                pattern = re.compile(".*(src=|http://|https://|href=)([^\n]*?)/plugins/" + self.found_plugins[0] + ".*", re.DOTALL)
            path_groups = re.match(pattern, html)
            if path_groups:
                path = path_groups.group(2)
                if path[0] == "'" or path[0] == "\"":
                    path = path[1:]

        if not path:
            path = url_base + "wp-content"

        url_parse = urlparse(path)
        if not path.startswith("http"):
            scheme = path_groups.group(1)
            if not hostname in path:
                p = url_parse.path
                host_to = url_parse.netloc if url_parse.netloc else self.host
                if self.ssl:
                    path = "https://" + host_to + p
                else:
                    path = "http://" + host_to + p
            elif hostname in path:
                if self.ssl:
                    path = "https://" + url_parse.netloc + self.dif_port + url_parse.path
                else:
                    path = "http://" + url_parse.netloc + self.dif_port + url_parse.path
            else:
                path = scheme + url_parse.netloc + self.dif_port + url_parse.path

        self.log_info("Searching for more plugins")
        i = 0
        self.check_404(urlparse(path).path + '/plugins/')
        with no_timeout_socket():

            for item, value in self.top_plugins.items():
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                progress = self.progress_bar(i)
                if progress:
                    self.log_info("%s" % progress)

                url = path + '/plugins/' + value
                path2 = urlparse(path).path + '/plugins/' + value + "/"

                response = self.send_req(req, path2, headers)
                if not response:
                    self.log_error("Invalid code or server error from %s" % url)
                    continue
                html, code = response

                if not self.check_isvalid(html, code, item):
                    req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                    path2 = path2 + "readme.txt"
                    response = self.send_req(req, path2, headers)
                    if not response:
                        self.log_error("Invalid code or server error from %s" % url)
                        continue
                    html, code = response
                    self.check_isvalid(html, code, item)
                i += 1
        if self.full_analysis:
            self.check_versions(urlparse(path).path, headers)

    def send_req(self, req, path, headers):
        try:
            req.request("GET", path, headers = headers)
            response = req.getresponse()
            code = response.status
            html = response.read()
        except:
            code = -1
            html = ""
            return None
        if code in [301, 302, 305, 307]:
            return self.resolve_redir(req, response, headers)
        return html, code

    def resolve_redir(self, req, response, headers, depth=0, netloc=None):
        if not netloc:
            netloc = self.host
        if depth <= 2:
            if req.host != netloc:
                req = httplib.HTTPSConnection(netloc) if self.ssl else httplib.HTTPConnection(netloc)
            try:
                req.request("GET", urlparse(response.getheader('location')).path, headers = headers)
                response = req.getresponse()
                code = response.status
                html = response.read()
                if code in [301, 302, 305, 307]:
                    self.resolve_redir(req, response, headers, depth+1, urlparse(response.getheader('location')).netloc)
                else:
                    return html, code
            except:
                code = -1
                html = ""
                return None
        return html, code

    def check_isvalid(self, html, code, item):
        aux_list = []
        aux_list.append(html)
        if self.redir and (code == 403 or code == 200) and not difflib.get_close_matches(aux_list[0], self.page404):
            self.log_info("%s Found" % item)
            self.found_plugins.append(item)
            return True
        elif not self.redir and code not in [404,408,400,500,503,-1] and not difflib.get_close_matches(aux_list[0], self.page404):
            self.log_info("%s Found" % item)
            self.found_plugins.append(item)
            return True
        return False

    def check_versions(self, path, headers):
        version_list = []
        with no_timeout_socket():
            for plugin in self.found_plugins:
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                latest = self.get_latest(plugin)
                if plugin in self.top_plugins:
                    path2 = path + '/plugins/' + self.top_plugins[plugin] + '/readme.txt'
                else:
                    path2 = path + '/plugins/' + plugin + '/readme.txt'
                resp = self.send_req(req, path2, headers)
                if not resp:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                html, code = resp
                if not "Stable tag" in html:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                pattern = re.compile(".*Stable tag:(.+?)(\r|\n)", re.DOTALL)
                groups = re.match(pattern, html)
                if not groups:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                version = groups.group(1).replace(" ", "")
                version_list.append((plugin, version, latest))
            self.found_plugins = version_list
            return

    def get_latest(self, plugin):
        if plugin in self.top_plugins:
            plugin = self.top_plugins[plugin]
        req = httplib.HTTPConnection("api.wordpress.org")
        req.request("GET", "/plugins/info/1.0/" + plugin + ".json")
        resp = req.getresponse()
        if not resp:
            return "Unable to determine"
        html = resp.read()
        if html == "null":
            return "Unable to determine"
        try:
            info = json.loads(html)
        except:
            return "Unable to determine"
        return info["version"]

    def prettyprint(self):
        self.found_plugins.insert(0, ("     Plugin", "     Current version", "     Latest version"))
        remap = zip(*self.found_plugins)
        max_len = max(map(len,remap[0]))
        max_len2 = max(map(len,remap[1]))
        max_len3 = max(map(len,remap[2]))
        string = ""
        for (plugin, curr_version, latest_version) in self.found_plugins:
            string += ("%*s | %*s | %*s\n" % (-max_len, plugin, -max_len2, curr_version, -max_len3, latest_version))
        self.log_info("\n%s" % string)

    def run(self):
        self.getArgs()
        url_base = self.createURL()
        self.test_wordpress(url_base)
        self.find_plugins(url_base)
        self.found_plugins = list(set(self.found_plugins))
        self.log_info("The following %d plugins were found:\n" % len(self.found_plugins))
        if self.full_analysis:
            self.prettyprint()
        else:
            self.log_info(self.found_plugins)
        return True

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)