#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


# CANVAS Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path:
    sys.path.append(".")

import socket
import timeoutsocket
import time

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor

# GUI info
NAME="UDPsweep"
DESCRIPTION="Scans for one port on many hosts - reports hosts that have the port closed"
DOCUMENTATION={}
DOCUMENTATION["Notes"] = "Quicky UDP portsweeper"
DOCUMENTATION["Callback"]="Make sure you have the callback set to the right IP!"
DOCUMENTATION["From Port"]="Is only used when doing sniff-scanning"
DOCUMENTATION["Snort"]="May trigger: [**] [1:504:7] MISC source port 53 to <1024 [**]"

VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

For commandline, you'll want to use -O source:SOURCEIP to avoid bad checksums

"""

CHANGELOG="""
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done = 0
        self.port=53000 
        self.fromport=53 #if fromport is 0 we randomize it
        self.closedhosts=[]
        self.openhosts=[]
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=0.5
        self.result=self.openhosts
        #source=self.engine.get_callback_interface().ip
        self.source="127.0.0.1"
        self.netmask="32"

        return
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("UDP Connect+Send Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def port_callback(self,parser):
        host=parser.attribs["ipsource"]
        #print "parser.attribs=%s"%parser.attribs
        flags=parser.attribs["tcpflags"]
        #print "flags=%s"%flags
        if "SYN" in flags and "ACK" in flags:
            self.openhosts+=[host]
            self.log("Found open host:port %s:%d"%(host,self.port))
        elif "RST" in flags:
            self.closedhosts+=[host]
            self.log("Found closed host:port %s:%d"%(host,self.port))            
        return

    def C_isClosed(self, host, port, proto="udp"):
        """
        Connects (default is UDP) to a port and sends a letter A and then 
        sees if we get an exception - if so, port is closed.
        """
        if proto.lower()=="udp":
            s=self.getudpsock()
        elif proto.lower()=="tcp":
            s=self.gettcpsock()
            
        s.set_timeout(self.timeout)
        try:
            #print "Sending one byte to %s:%s"%(host,port)
            s.connect( (host, port))
            s.send("A")
            s.recv(1)
        except socket.error:
            #print "socket error!"
            return 1
        except timeoutsocket.Timeout:
            #print "timeout"
            return 0
        #print "nothing!"
        s.close()
        return 0
    
    
    def run_on_host(self,target,source=None):
        """
        runs once on each host that is alive in the netrange
        
        we do the get_callback_interface here because doing it only once for a
        large netblock means we might miss the fact that we crossed
        interfaces...
        
        """
        if not source:
            source=self.engine.get_callback_interface(target=target.interface)
            
        host=target.interface
        #no scanrand for now
        if 0 and self.doscanrand:
            mysender=sender(target=host)
            mpacker=packetConstructor()
            #self.port is really self.fromport here
            #print "source=%s dest=%s"%(source,dest)
            mpacker.TCP(source,host,["SYN"],self.fromport,self.port,"")
            mysender.sendto(mpacker.get(),"TCP",(host,0))
            #if you don't sleep, you'll miss some ports. 
            time.sleep(0.05)
            
        else:
            ret=self.C_isClosed(host, self.port)
            if ret==1:
                self.log("Found %s port %d closed"%(host,self.port))
                self.closedhosts.append(host)
                
        return
    
    def run(self):
        self.host=self.target.interface
        if self.host=="127.0.0.1":
            self.log("We can't do a udpsweep on the local network because every host will appear to be alive")
            return 0
        
        self.timeout=float(self.argsDict.get("timeout",self.timeout))
        self.source=self.argsDict.get("source",self.engine.get_callback_interface().ip)
        self.netmask=self.argsDict.get("netmask",self.netmask).replace("/","")
        self.fromport=int(self.argsDict.get("fromport",self.fromport))
        self.port=int(self.argsDict.get("port",self.port))
        self.setInfo("UDP portsweeping %s/%s port %s from %s"%(self.host,self.netmask,self.port,self.fromport))
        self.node=self.argsDict["passednodes"][0]
        self.log("Timout=%s"%self.timeout)
        self.doscanrand=0
        
        if self.can_scanrand(target = self.host):
            if not self.engine.sniffer_isactive():
                self.log("sniffer not active")
                self.setInfo("UDPScan: Not Running as root - sniffer not active")
            else:
                self.doscanrand=1
                openfs="tcpsport(%s) tcpdport(%s)"%(self.port,self.fromport)
                #print "self.port_callback=%s"%self.port_callback
                self.engine.register_sniffer_callback(self.port_callback,openfs)        
        
        threads= "threads" in self.argsDict["passednodes"][0].capabilities
        
        self.run_on_all_possible_hosts(threads=threads)
        if threads:
            self.log("Sleeping 5 seconds to recover")
            time.sleep(5)
        self.openhosts=uniquelist(self.openhosts)
        #print "Closed: %s"%self.closedports
        self.log("Open hosts found on port %s: %s"%(self.port,self.openhosts))
        self.log("Closed hosts found on port %s: %s"%(self.port,self.closedhosts))
        
        for host in self.closedhosts:
            newhost=self.node.add_host(host)
            newhost.add_to_knowledge("CLOSEDUDPPORTS",[self.port])
            
        if self.doscanrand:
            self.engine.unregister_sniffer_callback(self.port_callback)
            
        self.setInfo("UDP portsweeping %s/%s port %s found %d hosts"%(self.host, self.netmask, self.port, len(self.closedhosts)))    
        self.log("UDP Portsweep finished")
        return 1

    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])


    #def usage(self):
    #    import sys
    #    #print "Usage: %s -t host -l localhost [-c covertness]"% sys.argv[0],
    #    self.displayVersions()

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    
