#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
TODO : Add a test for packet loss and automatically adjust the number of iterations
to adjust for that.
"""
# CANVAS UDP Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path: sys.path.append(".")

import socket
import timeoutsocket
import time
import select

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor
from sniffer import packetParser

# GUI info
NAME="UDP Portscan "
VERSION="1.0"
DESCRIPTION="Scans for open UDP Ports"
DOCUMENTATION={}
DOCUMENTATION["Notes"]=""" UDP Portscanning typically works by sending UDP
packets to different ports on your target and waiting for ICMP Port
Unreachable to come back. Future UDP scanners would have a list of ports which
they know how to elicit real responses from, of course, but we're not there
yet with this scanner.

This kind of scanner does have the potential for errors. There's really two
places where UDP scanning can have errors due to packet loss. One is in the
sending of UDP packets - you might be sending so fast that they get dropped.
Or they might be getting dropped randomly by overloaded network equipment
somewhere.

Likewise, the ICMP messages coming back to you can be dropped anywhere along
the way. So each port is tested multiple times to ensure that things are
working properly.

"""

VERSION="1.0"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

"""

CHANGELOG="""
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done = 0
        self.port=53 
        self.fromport=53 #if fromport is 0 we randomize it
        self.closedports={}
        self.closedhosts=[]
        self.openhosts=[]
        self.openports=[]
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=60
        self.result=self.openhosts
        #source=self.engine.get_callback_interface().ip
        self.source="127.0.0.1"
        self.netmask="32"
        self.postHTTP=False
        self.portlist=None 
        self.startport=1
        self.endport=65536 #+1 really
        self.iterations=10 
        self.sleeptime=0.001 #between packets
        self.runwithoutsniffer = 0 # adding a new method that will rely on socket errors to determine port status
        return
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("UDP Connect Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def port_callback(self,parser):
        devlog("udpportscan", "Callback got triggered for udpportscan")
        data=parser.attribs["icmpdata"]
        if len(data)<28:
            return 
        from_port=str2int16(data[26:28])
        devlog("udpportscan","From port ICMP Reset found: %d"%from_port)
        self.closedports[from_port]=True 
        return

    def C_isOpen(self, host, port):
        s=self.gettcpsock()
        s.set_timeout(self.timeout)
        try:
            self.log("Probing host %s:%s"%(host,port))
            s.connect( (host, port))
        except socket.error, msg:
            self.log("Error: %s"%msg)
            if str(msg).count("No route to host"):
                return -1
            return 0
        except timeoutsocket.Timeout:
            return -1
        s.close()
        return 1
    
    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """
        host=target.interface

        if self.state==self.HALT:
            return 
        
        if self.doscanrand:
            mysender=sender(target=host)
            
        for i in range(0,self.iterations):
            #test each port multiple times.
            numports=len(self.portlist)-len(self.closedports.keys())
            if numports==0:
                self.log("All ports were closed")
                break 
                
            self.log("Running iteration %d/%d on %d ports"%(i,self.iterations,numports))
            for port in self.portlist:
                if self.state==self.HALT:
                    return 

                if port%1000==0:
                    self.log("Testing port %d"%port)
                if port in self.closedports:
                    #no need to test this port, already know it's closed
                    continue
                if self.doscanrand:
                    
                    mpacker=packetConstructor()
                    #self.port is really self.fromport here
                    #print "source=%s dest=%s"%(source,dest)
                    mpacker.UDP(self.source,host,self.fromport,port,"")
                    mysender.sendto(mpacker.get(),"UDP",(host,0))
                    #if you don't sleep, you'll miss some ports. 
                    time.sleep(self.sleeptime)
                    
                else:
                    ret=self.C_isOpen(host, self.port)
                    if ret==1:
                        self.log("Found %s port %d open"%(host,self.port))
                        self.openhosts.append(host)
        
                    elif ret==0:
                        self.log("Found %s port %d closed"%(host,self.port))
                        self.closedhosts.append(host)      
                        
        if self.state!=self.HALT:
            #if we are not halted, let's wait for the rest of the packets just in case
            self.log("Sleeping for 5 seconds to recover all packets")
            time.sleep(5)
            
        return 
                
    def run_on_host_without_sniffer(self, target):
            """
            Rely only on socket errors messagse to determine ICMP message.
            This is a much more limited approach but at least it provides *something* that will work on non-sniffer hosts
            It assumes that if you don't receive an ICMP Type 3 Code 3 message back then the port is either open or filtered
            (or the UDP packet was dropped somewhere along the way - but UDP has a low self-esteem and is socially dysfunctional to the
            point where it will just straight-up ignore you)
            """
            host = target.interface
            
            for i in range(1,self.iterations+1):
                #test each port multiple times.
                numports=len(self.portlist)-len(self.closedports.keys())
                if numports==0:
                    self.log("All ports were closed")
                    break 
                
                self.log("Running iteration %d/%d on %d ports"%(i,self.iterations,numports))
                for port in self.portlist:
                    if self.state==self.HALT:
                        return 

                    if port%1000==0:
                        self.log("Testing port %d"%port)
                    if port in self.closedports:
                        #no need to test this port, already know it's closed
                        continue
                        
                    else:
                        s=self.getudpsock()
                        s.settimeout(self.timeout)
                        #print "connecting to %s:%d"%(host, port)
                        try:
                            s.connect((host, port))
                            s.send("a")
                            s.recv(1)
                            
                        except timeoutsocket.Timeout:
                            pass
                            
                        except socket.error, err:
                            ##(10054, 'Connection reset by peer') = Destination Unreachable = Type 3 Code 3
                            #print socket.error
                            #print err
                            if err[0] == 10054:
                                #print "%s:%d Destination Port Unreachable (Type 3 Code 3)"%(host, port)
                                self.closedports[port]=""
                                
                        s.close()
                        
            #if we are not halted, let's wait for the rest of the packets just in case
            self.log("Sleeping for 5 seconds to recover all packets")
            time.sleep(5)
            
            return 1
            
        

    def getargs(self):
        self.host=self.target.interface
        self.timeout=float(self.argsDict.get("timeout",self.timeout))
        self.source=self.argsDict.get("source",self.engine.get_callback_interface(self.host))
        self.netmask=self.argsDict.get("netmask",self.netmask)
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.fromport=int(self.argsDict.get("fromport",self.fromport))
        self.port=int(self.argsDict.get("port",self.port))
        self.portlist = self.argsDict.get("portlist",self.portlist)
        self.iterations = self.argsDict.get("iterations",self.iterations)
        self.getarg("startport")
        self.getarg("endport")
        self.sleeptime=float(self.argsDict.get("sleeptime", self.sleeptime))
        return 
    
    def run(self):        
        self.getargs()
        print self.portlist
        
        if isinstance(self.netmask, str):
            self.netmask=int(self.netmask.replace("/",""))
            
        self.setInfo("UDP Portscanning %s"%(self.host))
        self.node=self.argsDict["passednodes"][0]
        self.log("Timeout=%s"%self.timeout)
        self.doscanrand=0
        
        #don't do syn-scan if we're a SILICA        
        #if self.can_scanrand() and not self.argsDict.get("silica"):
        if self.can_scanrand(target = self.host):
            if not self.engine.sniffer_isactive():
                self.log("sniffer not active")
                self.setInfo("Portsweep: Not running as root - sniffer not active")
            else:
                self.doscanrand=1
                openfs="icmpsource(%s) icmpcode(3)"%(self.host)
                #print "self.port_callback=%s"%self.port_callback
                self.engine.register_sniffer_callback(self.port_callback,openfs)
        else:
            ##windows doesn't have sniffer support - so we are just going to rely on UDP socket errors 
            ##to determine what ICMP message we got back.
            #self.log("Currently this module only supports hosts with sniffer support")
            #self.setInfo("UDP Portscan failed (not on sniffer host)")
            #return 0
            self.log("Not a sniffer host - defaulting to socket errors to determine port status")
            print "running without sniffer"
            self.runwithoutsniffer = 1
            
        
        if not self.portlist:
            self.portlist=range(self.startport, self.endport)
        else:
            #convert from string
            #TODO: Not done yet
            #self.portlist=portlist_from_string(self.portlist)
            pass
        self.log("UDP Portscan running on %d ports"%len(self.portlist))
        
        if self.runwithoutsniffer:
            self.run_on_host_without_sniffer(self.target)
        else:
            self.run_on_host(self.target)
            
        
        #need to use Set module here for speed
        for i in self.portlist:
            if i not in self.closedports:
                self.openports+=[i]
                
        self.target.add_to_knowledge("CLOSEDUDPPORTS",self.closedports)

        self.log("Found following UDP ports open on host %s: %s"%(self.host, self.openports)) 
        self.result=self.openports
        if self.doscanrand:
            self.engine.unregister_sniffer_callback(self.port_callback)
        self.log("All done")            
        return 1

    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])


    #def usage(self):
    #    import sys
    #    #print "Usage: %s -t host -l localhost [-c covertness]"% sys.argv[0],
    #    self.displayVersions()

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    
