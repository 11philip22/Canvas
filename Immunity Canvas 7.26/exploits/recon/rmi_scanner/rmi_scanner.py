#!/usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

import sys

if "." not in sys.path:
    sys.path.append(".")

import socket, errno
import urllib
import random
import libs.spkproxy as spkproxy
import zipfile
import tempfile
import glob
import shutil
import csv
import pickle

import libs.java_deserialization_parser as javaparser

from exploitutils import *
from tcpexploit import *
from canvasexploit import *
from libs.apache_commons_deserialize import objectcreator

NAME                            = "RMI Scanner"
DESCRIPTION                     = "RMI Scanner"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Oracle"
DOCUMENTATION['Repeatability']  = "Infinite"
DOCUMENTATION['CVE Name']       = ""
DOCUMENTATION['CVE Url']        = ""
DOCUMENTATION['References']     = [
    "https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html",
    "https://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmi-protocol3.html",
    "https://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmiTOC.html",
]
DOCUMENTATION["Notes"]          = """

This is a scanning module that communicates
with a RMI port and enumerates all the exposed objects of the registry
"""

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Recon"
PROPERTY['SITE']                = "Remote"


CHANGELOG = """
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.port = 1099
        self.host = ""
        self.version = 0
        self.done = 0
        self.ssl = ""
        self.name = NAME
        self.path = os.path.dirname(__file__)


        # self.command            = None
        self.hostname = None
        self.content_type = ""
        self.file_name = randomstring(5)

        self.ua = None
        self.offset = 0

        self.socket = socket.socket(socket.AF_INET)
        self.java_parser = None

        self.bound_objects = []
        self.registry = []
        self.registry_idx = 0
        self.record_registry = False

    def getargs(self):
        """
        Get arguments for attack
        """
        self.host = self.target.interface
        self.getarg("hostname")
        if not self.hostname:
            self.hostname = self.host
        self.port = int(self.argsDict.get("port", self.port))

        return

    def init_connection(self):
        logging.info("Testing if RMI service is listening...")

        magic_number = "4a524d49"
        version = "0002"  # could be 0001 also (it's used?)
        protocol = "4b"  # 4b=StreamProtocol ; 4c=SingleOpProtocol ; 4d=MultiplexProtocol
        message = "000000000000"
        outputStream = magic_number + version + protocol + message

        try:
            self.socket.sendall(outputStream.decode('hex'))
            response = self.recv_timeout()
        except socket.error as e:
            logging.error("Coulnd't connect")
            return False

        if response[:1] == "\x4e":
            logging.info("StreamProtocol supported")
            return True
        elif response[:1] == "\x4f":
            logging.error("StreamProtocol NOT supported")
            ## Implement another way using a different protocol?
            return False
        else:
            logging.error("Unexpected ProtocolAck Returns")
            self.check_response(response)

        return False

    def check_response(self, response):
        if 'RMI class loader disabled' in response:
            logging.error('Exploit failed: RMI class loader disabled')
        elif 'java.lang.ClassNotFoundException' in response and 'java.rmi.UnmarshalException' in response:
            logging.error('Exploit failed: java.rmi.server.useCodebaseOnly may be set as true')
        elif 'java.rmi.NoSuchObjectException' in response:
            logging.error('Exploit failed: java.rmi.NoSuchObjectException')
        else:
            logging.info('Exploit failed: Unexpected error')

    def recv_timeout(self, timeout=2):
        tmp_socket = self.socket
        tmp_socket.setblocking(0)
        total_data = []
        data = ''

        begin = time.time()
        while True:

            if total_data and time.time() - begin > timeout:
                break
            elif time.time() - begin > timeout * 2:
                break

            try:
                data = tmp_socket.recv(8192)
                if data:
                    total_data.append(data)
                    begin = time.time()
                else:
                    time.sleep(0.1)
            except:
                pass

        return ''.join(total_data)

    def enum_bound_names(self):
        logging.info("Enumerating list of exposed object names...")

        self.java_parser = javaparser.Parser(self.host, self.port)
        outputStream = "50aced00057722000000000000000000000000000000000000000000000000000144154dc9d4e63bdf"

        ## Ask for bound objects
        self.socket.sendall(outputStream.decode('hex'))
        response = self.recv_timeout()

        if 'java.rmi.NoSuchObjectException' in response:
            logging.error('Exploit failed: java.rmi.NoSuchObjectException')
            return False

        ## Extracting bound objects
        self.bound_objects = self.java_parser.response_parser(response.encode('hex'))

        ## Getting info of every object if any
        if self.bound_objects[0].strings == []:
            return False
        else:
            outputStream = "50aced00057722000000000000000000000000000000000000000000000000000244154dc9d4e63bdf"
            logging.info("Getting info of each exposed object...")
            for idx,object in enumerate(self.bound_objects[0].strings):
                logging.info("Parsing object %s", object)
                self.socket.sendall((outputStream + "74{:04x}".format(len(object))).decode('hex') + object)
                response = self.recv_timeout()
                registry = self.java_parser.response_parser(response.encode('hex'), object)
                registry[0].index = idx
                self.registry += registry

        return True

    def print_registry_dump(self):
        logging.info("RMI-Registry Dump:")
        if self.bound_objects[0].strings != []:
            for object in self.registry:
                logging.info("\tObject %s: %s\t", object.index, object.object_name)
                logging.info("\t\tEndpoint:\t%s", object.endpoint)
                for interface in object.interfaces:
                    logging.info("\t\tInterfaces:\t%s", interface)
                for field in object.fields:
                    logging.info("\t\t\tField:\t%s", field)
                for id,classes in enumerate(object.classes):
                    logging.info("\t\t"+"\t\t" * id + "Extends:\t%s", classes)
                if object.annotations != []:
                    logging.info("\t\tAnnotations:")
                for annotation in object.annotations:
                    for line in annotation.split(" "):
                        logging.info("\t\t\t%s", line)
        else:
            logging.warning("No object found")

    def to_csv(self):
        with open((os.path.join(self.path, './exports/export.csv')), 'a') as file:  # .format(randomstring(4))
            fieldnames = ['index', 'registry', 'objectName', 'endpoint', 'classes', 'interfaces', 'fields', 'extensions', 'annotations']
            wr = csv.writer(file, delimiter=',')
            wr.writerow(fieldnames)
            for line in self.registry:
                wr.writerow(list(line))
            if self.registry == []:
                wr.writerow(['0', '{}:{}'.format(self.host, self.port), 'None or timeout'])

    def to_pickle(self):
        with open((os.path.join(self.path, './exports/export-{}-{}.pickle'.format(self.host.replace(".", "-"), time.time()))),
                  'w') as file:
            pickle.dump(self.registry, file, pickle.HIGHEST_PROTOCOL)

    def run(self):
        # Get arguments
        self.getargs()

        self.setProgress(0)
        self.setInfo("%s (in progress)" % (NAME))

        self.host = self.target.interface

        # Setting socket
        self.socket.settimeout(float(5))
        try:
            self.socket.connect((self.host, self.port))
        except socket.error as e:
            logging.critical("Error while connecting to %s:%s" % (self.host, self.port))
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return False

        # Test if RMI service is there
        if not self.init_connection():
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return False

        if not self.enum_bound_names():
            self.setInfo("%s attacking %s - done (failed)" % (NAME, self.host))
            return False

        self.print_registry_dump()
        self.setProgress(100)
        self.setInfo("%s - done (success)" % (NAME))

        #self.to_csv()
        #self.to_pickle()
        return True


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)