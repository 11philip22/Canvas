#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  shareenum_ng.py
## Description:
##            :
## Created_On :  Wed Mar 25 CET 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import socket
import os
import time
import select
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'shareenum_ng'
DESCRIPTION                     = 'Get a list of shares from a list of remote machines using srvsvc::NetrShareEnum'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Recon'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]

CHANGELOG = """
"""

NOTES = """

This module will attempt to enumerate the SMB shares open on a range of IP.
These will be stored into the knowledge tree, and you may want to follow this
up by using the smbclient built into CANVAS to attempt to access the files on
those file shares.

This module operates over the SMB ports (aka 139, 445).

"""

import sys
import getopt
import socket

if "." not in sys.path:
    sys.path.append(".")

from canvasexploit import canvasexploit
import libs.newsmb.libdcerpc as libdcerpc
import libs.newsmb.srvsvc as srvsvc
import libs.kerberos.ccache as cc
from exploitutils import *


class share:
    """
    Used for share enumeration.
    """
    def __init__(self, sharename="", comment="", sharetype=0, sharepath=None):
        self.sharename = sharename
        self.comment   = comment
        self.sharetype = sharetype
        self.sharepath = sharepath

    def __str__(self):
        name = self.sharename.encode('ASCII', 'replace')
        comment = self.comment.encode('ASCII', 'replace')
        return "%s:%s" %(name, comment)

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.systemname   = "\\\\127.0.0.1"
        self.user         = u''
        self.password     = u''
        self.domain       = u''
        self.ccache_file  = None
        self.use_kerberos = False
        self.netmask      = "32"

    def check_ccache_file(self):
        try:

            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def getargs(self):
        # need to revise to use get_knowledge/set_knowledge
        systemname=self.argsDict.get("systemname",self.systemname)
        self.host = self.target.interface
        self.user = self.argsDict.get('user', self.user)
        self.password = self.argsDict.get('password', self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)
        self.netmask=self.argsDict.get("netmask",self.netmask)

    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """

        logging.info("%s::Using srvsvc to enumerate shares" % target.interface)
        #connect to named pipe
        #bind to RPC server
        if not self.has_named_pipes(target):
            logging.info("%s::No SMB ports open..." % target.interface)
            return 0

        # Sanity check: the ccache credentials
        if self.ccache_file:
            if not self.check_ccache_file():
                logging.error('%s::%s doesn\'t seem to be a valid ccache file for user %s' % (target.interface, self.ccache_file, '@'.join([self.user,self.domain])))
                return 0
            else:
                self.use_kerberos = True
                logging.info("%s::Using kerberos authentication with credentials %s" % (target.interface, self.ccache_file))
        else:
            logging.info("%s::Using NTLM authentication" % target.interface)

        ret, shares=srvsvc.srvsvc_share_enum(target.interface,
                                             self.user,
                                             self.password,
                                             self.domain,
                                             kerberos_db=self.ccache_file,
                                             use_krb5=self.use_kerberos,
                                             with_comments=True)

        sharelist=[]
        if not ret:
            for elt in shares:
                newshare=share()
                newshare.sharename = elt['name']
                newshare.sharetype =elt['type']
                newshare.comment = elt['comment']
                sharelist+=[newshare]

        if sharelist:
            self.result[target.interface] = sharelist
            self.target.replace_knowledge("SMBShares", sharelist, 100)
            mysharelist = ["%s:%s" % (s.sharename, s.comment) for s in sharelist]
            self.new_event("shares", {
                "remote_ip": str(self.target.interface),
                "shares": mysharelist,
                })
        return

    def run(self):
        self.getargs()

        if isinstance(self.netmask, str):
            self.netmask=int(self.netmask.replace("/",""))

        self.result = {}
        self.setInfo("%s" % NAME)
        logging.info("Running shareenum_ng against %s/%s with user:pass = %s:%s"
                % (self.host, self.netmask, self.user, self.password))
        self.node=self.argsDict["passednodes"][0]
        dothreads = 'threads' in self.node.capabilities
        self.run_on_all_possible_hosts(threads=dothreads)
        if dothreads:
            logging.info("Recovering from threads")
            time.sleep(2)

        logging.info("All done")

        for ip in self.result:
            sharelist = self.result[ip]
            logging.info("%s::Total Shares: %s" % (ip, len(sharelist)))
            for u in sharelist:
                logging.info(u'%s::Share found: %s:%s' % (ip, u.sharename, u.comment))

        self.setInfo("%s - done (success: %s)" % (NAME, "%d hosts answered" % len(self.result)))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
