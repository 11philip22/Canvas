#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import os, socket, time, re

import timeoutsocket
from exploitutils import *
import canvasengine

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

NAME= "DNSFind"
DESCRIPTION= "Enumerate hosts in a domain based on a dictionary attack"
VERSION= "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']="None"
DOCUMENTATION["Date public"]="00/00/00"
DOCUMENTATION["CERT Advisory"]="None"
DOCUMENTATION["Repeatability"]="Infinite"
DOCUMENTATION["References"] = "None"
DOCUMENTATION["CVE Name"] = "None"
DOCUMENTATION["CVE Url"] = "None"
DOCUMENTATION["Notes"]="""
Very simple module, reads in a list and attempts to fetch the A records for
the host+domain combo. The results will appear in CANVAS.log and a file in
your session directory. Currently this module relies on Python to know your
DNS server (taken from resolv.conf or windows registry, etc).

Most people use Resources/dns.txt or Resources/dns-short.txt as their
dictionary.

Iterate appends 1-20, a-z to host names included in the dictionary (this will
be slower, but possibly more complete.

Throttle increases the delay between requests. This may prevent an anomoly
detection device from alerting on your traffic.

"""

PROPERTY = {}
PROPERTY["TYPE"]= "Recon"
PROPERTY["SITE"]=  "Remote"
PROPERTY["ARCH"]= [ ["All"] ]
PROPERTY["VERSION"]= []

targets = {}

def threadme(a_obj, ce):
    """
    Runs in a thread, takes in a canvasexploit instance and an object from our iterable
    
    returns a nonFalse tuple (for found a host) or False for did not find a host (which is then ignored)
    """
    host=a_obj+ce.domain 
    devlog("dnsfind","Looking up %s"%(host))
    if ce.throttle > 0:
        time.sleep(float(ce.throttle))
    try:
        ip = socket.gethostbyname(host )
    except socket.gaierror, error:
        devlog("dnsfind", "Error: %s"%error)
        return False  #did not find a host
    
    return (host, ip) #found a host

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name=NAME
        self.domain = ""
        self.hostfilename = ""
        self.debug = False
        self.wildcard = False
        self.iterate = False
        self.throttle = 0 # Delay time between requests
        self.do_threaded = True 

    def getargs(self):
        self.hostfilename =self.argsDict.get("source", os.path.join(self.engine.config["canvas_resources"], "dns.txt"))
        self.getarg("domain")
        self.getarg("iterate")
        self.getarg("throttle")
        self.getarg("do_threaded")
        
        self.node=self.argsDict["passednodes"][0]
        return 
    
    def usage(self):
        #
        # Standard options don't apply here
        print "="*10
        print "Tries to resolve a list of hosts for a given domain"
        print "Usage: dnsfind.py -O source:<file> -O domain:<domain> -O iterate:<True False> -O throttle:<seconds>"
        print "\tIterate appends 1-20, a-z to host names included in the dictionary"
        print "\tThrottle increases the delay between requests"
        print "ex: dnsfind.py -O source:Resources/dns.txt -O domain:example.com -O iterate:True -O throttle:.5"
        print "="*10
    
        
    def process_thread_results(self, status_q, end_of_run_marker):
        """
        process all results from our ThreadRunner2 - this method is automatically called
        by threads, so everything within must be threadsafe!
        """
        done_hosts=0
        self.foundHosts={} #our return value
        while 1:
            tr2_obj, status, data=status_q.get()
            #debug note
            devlog("dnsfind","RESULTS: %r, %r, %r"%(tr2_obj, status, data))
            
            if status == end_of_run_marker:
                ##ALL threads have completed so no more status/results to process
                tr2_obj.join()
                #we are done!
                return 
            
            if status == "newhost":
                #starting to scan a new host
                done_hosts+=1
                self.setProgress((float(done_hosts)/float(self.total_length)) * 100)
                if done_hosts % 10 == 0:
                    self.log("Doing host number %d/%d"%(done_hosts,self.total_length))
                    
            elif status=="success":
                #found a host!
                #data is a tuple of (host, ip)
                host, ip = data
                self.foundHosts[host] = ip
                                
                #Add all found hosts to our knowledgebase, makes them accessible as targets as
                # well as adding them to the map to see data centre clusters etc
                self.node.add_host(ip)
                
        #should never be reached, as we always return with an eof marker        
        return 

        
    def scan_non_threaded(self, hostList):
        """
        Takes in a list of hosts and the iterates through them to locate new hosts.
        """
        #
        # Run() run was getting cluttered
        foundHosts = {}
        
        #unfortunately, we can't use a generator easily here unless it supplies us with __len__.
        #which is a shame, because hostList can get quite memory-hungry
        total_length=len(hostList)
        done_hosts=0
        for host in hostList:
            #all long running loops must have this exit condition
            if self.state==self.HALT:
                self.log("Halted")
                return foundHosts
            done_hosts+=1
            self.setProgress((float(done_hosts)/float(total_length)) * 100)
            if done_hosts%10==0:
                self.log("Did %d hosts out of %d"%(done_hosts, total_length))
            try:
                devlog("dnsfind","Looking up %s"%(host+self.domain))
                if self.throttle > 0:
                    time.sleep(float(self.throttle))
                    ip = socket.gethostbyname(host + self.domain)
                else:
                    ip = socket.gethostbyname(host + self.domain)
                self.log("Found host %s at %s"%((host+self.domain), ip))
                foundHosts[(host+self.domain)] = ip
            except socket.gaierror, error:
                devlog("dnsfind", "Error: %s"%error)
        return foundHosts
    
    def iterator(self, hostList):
        #
        # Append 1-20, a-z, to hostList and return newList
        newList = []
        for host in hostList:
            newList.append(host)
            for num in xrange(0,21):
                newList.append(host+str(num))
            for alpha in map(chr, range(97, 123)):
                newList.append(host+alpha)
        
        return newList
    
    def outputFile(self, foundHosts):
        #        
        # Print out final status
        if len(foundHosts) > 0:
            for host in foundHosts.keys():
                self.log(("\t%s has IP %s")%(host, foundHosts[host]))
        else:
            self.log("Found no hosts for domain %s"%self.domain[1:len(self.domain)])
            return 0
        
    def checkWild(self):
        #
        # Check for domain wildcards
        try:
            ip = socket.gethostbyname("should-not-ever-exist" + self.domain)
        except Exception:
            return False
        else:
            self.log(("Was able to resolve should-not-ever-exist%s"%self.domain))
            self.log("!!!! target is likely using domain wildcards !!!!")
            return True
        
    def outputWildCard(self, foundHosts):
        #
        # If we found a wildcarded domain, show more useful output
        outputHosts = {}
        
        #
        # Re-key the directory by IP rather than hostname so we get {ip:[host1, host2, ...]}
        for host in foundHosts.keys():
            if not outputHosts.has_key(foundHosts[host]):
                outputHosts[foundHosts[host]] = [ host ]
            else:
                outputHosts[foundHosts[host]].append(host)
        
        self.log("Saving wildcard results")
        self.log("!!!! DNS Wildcard Results !!!!\n")
        self.log("Scan of Domain: %s\n\n"%self.domain)
        for ip in outputHosts:
            if len(outputHosts[ip]) > 1:
                self.log("%s \t\t %s\n"%(ip, outputHosts[ip][0]))
                for x in xrange(1,len(outputHosts[ip])):
                    self.log(" "*len(ip) + "\t\t %s\n"%(outputHosts[ip][x]))
            else:
                self.log("%s \t\t %s\n"%(ip, outputHosts[ip][0]))
            self.log("\n")
        return 0
    
    def run(self):
        self.getargs()
        
        #
        # User friendly
        if self.domain == "":
            self.log("Please specify a domain")
            return 0
        if self.hostfilename == "":
            self.log("Please specify a host file")
            return 0
        if float(self.throttle) < 0.00:
            self.log("Throttle is the delay between requests in seconds and must be positive")
            return 0
        try:
            file = open(self.hostfilename, 'r')
        except Exception:
            self.log("Couldn't open file at: %s"%self.hostfilename)
            return 0
        
        hostList = file.read().splitlines()
        file.close()
        # Remove all the line comments, blanks, bail if host has 0 lines
        tempList = []
        for host in hostList:
            if "#" in host or host == "":
                tempList.append(host)
        for host in tempList:
            hostList.remove(host)
        if len(hostList) == 0:
            self.log("Hostfile contained 0 lines")
            return 0
    
        #
        # Set up the scan then do it
        if self.domain[0] != ".":
            self.domain = "." + self.domain
        if self.iterate:
            hostList = self.iterator(hostList)
        self.log("Attempting to find %d hosts for domain %s"%(len(hostList), self.domain[1:len(self.domain)]))        
        self.log(("Throttle set to %.02f seconds between requests")%(float(self.throttle)))
        self.wildcard = self.checkWild()
        self.total_length = len(hostList)
        
        if not self.do_threaded:
            foundHosts = self.scan_non_threaded(hostList)
        else:
            self.run_threaded_scan(e_module=threadme, targets=hostList)
            foundHosts=self.foundHosts
        
        if self.wildcard:
            self.outputWildCard(foundHosts)
        else:
            self.outputFile(foundHosts)
            
        self.setInfo("%s Done"%self.name)
        self.log("DNSFind done")
        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
