#! /usr/bin/env python

"""
mssql_resolve.py

Version: 1.0


Contacts the resolver service on UDP port 1434 and finds the versions and
ports of TCP SQL Servers.

"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import socket
import getopt
import sys

if "." not in sys.path: sys.path.append(".")



from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine

#TODO: FIX THESE
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
#DOCUMENTATION["Date public"]="00/00/0000"
#DOCUMENTATION["CERT Advisory"]=""
#DOCUMENTATION["CVE Name"]=""
#DOCUMENTATION["References"]=""
DOCUMENTATION["Notes"]="""

This tool sends out a UDP packet query to the remote server. If the
server is running MS SQL it will reply with a response containing
all the instances of MS SQL running on that machine, their ports,
and their version numbers. It has been historically inaccurate about
the version numbers, so don't rely on those.

You'll want to follow this up by testing for ms_sql_hello or the 
mssql_auth (for null SA) on each of those ports.
"""

DESCRIPTION="MS SQL Resolver Ping"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = [ "All" ]

NAME="mssqlresolve"


#TODO:
#1. Add local port so we can spoof from port 53

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        
        self.endpoint_data=[]
        self.port=1434
        self.name=NAME
        self.result=None
        return
   
    def run(self):
        """
        runs the attempt to grab information
        """

        self.log("Microsoft SQL Server often lies about this information....")
        if self.target==None:
            self.log("Cannot attack nothing")
            return 0
        
        self.host=self.target.interface

        self.port=int(self.argsDict.get("port",self.port))
        #s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.setInfo("%s attacking %s:%s"%(self.name,self.host,self.port))
        s=self.getudpsock()
        self.log("Connecting to port %d"%self.port)
        try:
            s.connect((self.host, int(self.port)))
        except:
            self.log("Connection refused!")
            return 0
        self.log("Sending probe packet")
        s.send(chr(02))
        self.log("Recieving data")
        try:
            data = s.recv(1024)
        except:
            self.log("Connection refused!")
            self.setInfo("%s attacking %s:%s (done)"%(self.name,self.host,self.port))
            return 0
        s.close()
        data = data.split(";;")
        #ends with a blank line
        data = data[:-1]
        self.log("Data="+str(data))
        #Data=['\x05\x83\x00ServerName;EA6RJ4A0DZ10OJ5;InstanceName;MSSQLSERVER;IsClustered;No;
        #       Version;8.00.194;tcp;1433;np;\\\\EA6RJ4A0DZ10OJ5\\pipe\\\\sql\\query']
        #add each line to our internal database
        for line in data:
            self.endpoint_data.append(self.parse_line(line))
        self.setInfo("%s attacking %s:%s (done)"%(self.name,self.host,self.port))
        self.result=self.endpoint_data
        return 1

    def version(self,tcpport):
        """
        returns the version of the SQL Server on a particular TCP port
        """
        retstring="None found"
        self.log("tcpport="+str(tcpport))
        for dict in self.endpoint_data:
            if dict["tcp"]==str(tcpport):
                retstring=dict["Version"]

        if retstring=="8.00.194":
            retstring="SP0"
        if retstring.count("9.00"):
            self.log("MS SQL 2005 found")
        if retstring.count("8.00"):
            self.log("MS SQL 2000 found")
        return retstring

    def parse_line(self,line):
        """
        parses a single line from the resolver
        returns a dictionary full of the data we parsed out
        """

        #ignore bad data at the front (\x05\x83\x00)
        line = line[3:]
        #print "parsing: "+line
        items=line.split(";")
        retdict={}

        while len(items)>0:
            retdict[items[0]]=items[1]
            #print "len(items)=%d"%len(items)
            del items[0]
            del items[0]

        
        return retdict
            
    def printdata(self):
        for dict in self.endpoint_data:
            print dict
        
        return

    def prettyprintdata(self):
        """
        retrns a string with the information printed out nicely
        contains a small database of version identifiers
        """
        retstring=""
        for dict in self.endpoint_data:
            if dict["Version"]=="8.00.194":
                version="SP0"
            else:
                version=dict["Version"]              
            retstring+="Host ( "+self.host+" ) has a server on port "+dict["tcp"]+" that is version "+version
            retstring+="\n"
        return retstring

    def usage(self):
        print "Usage: "+sys.argv[0]+" -t targethost [-p targetport (default is 1434)]"
    
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
