import sys
if '.' not in sys.path: sys.path.append('.')

import socket
import timeoutsocket

from exploitutils import standard_callback_commandline
from libs.newsmb.libsmb import SMBException, SMBClient
from libs.newsmb import libdcerpc
from tcpexploit import tcpexploit


DESCRIPTION             = "SMB version detection"
VERSION                 = "1.0"
NAME                    = "smbversion"
PROPERTY                = {}
PROPERTY['TYPE']        = "Recon"
PROPERTY['SITE']        = "Remote"
DOCUMENTATION           = {}
DOCUMENTATION['Notes'] = """

Will scan target for SMB information.

"""

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name         = NAME
        self.username     = ''
        self.password     = ''
        self.host         = ''
        self.port         = 445
        self.dcebind      = False

    def getargs(self):
        self.getarg("username")
        self.getarg("password")
        self.getarg("port")
        self.getarg("dcebind")

    def test(self):
        self.getargs()
        self.host = self.target.interface

        s = self.gettcpsock()

        try:
            s.connect((self.host, self.port))
        except (socket.error, timeoutsocket.Timeout):
            return 0
        finally:
            s.close()

        self.target.add_knowledge("smbversion", self.port, 100)
        return 1

    def do_detect(self, unicode=True):
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            smbobj = SMBClient(s, username=self.username, password=self.password)
            smbobj.is_unicode = unicode
            smbobj.extended_security = True
            smbobj.negotiate()
            smbobj.session_setup()

            return smbobj.nativeos, smbobj.nativelanman
        finally:
            s.close()
                    
    def run(self):
        self.getargs()
        self.host = self.target.interface

        self.setInfo("%s running against %s:%d (in progress)" % (NAME, self.host, self.port))
        self.log('Running against %s:%d with username: %s and password: %s' % (self.host, self.port, self.username, self.password))
        
        nativeos = lanman = None

        if self.dcebind:
            auth_type  = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
            auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

            if self.covertness >= 2:
                self.log("DCERPC crypto enabled, set covertness to 1 and try again if module fails!")

            frag_level = None
            if self.covertness >= 5 and self.covertness < 11:
                self.log('Crypto + moderate SMB fragmentation')
                frag_level = 1
            elif self.covertness == 11:
                self.log('Crypto + MAX fragmentation')
                frag_level = 2
                
            self.log('Doing DCE BIND')

            try:
                dce = libdcerpc.DCERPC(u'ncacn_np:%s[\\lsarpc]' % self.host, getsock=self, username=self.username, password=self.password, frag_level=frag_level)
                
                if dce.bind(u'12345778-1234-abcd-ef00-0123456789ab', u'0.0', auth_type=auth_type, auth_level=auth_level):
                    nativeos = dce.dcerpc_connection.smb.nativeos
                    lanman   = dce.dcerpc_connection.smb.nativelanman
            except Exception, ex:
                self.log('Error: %s' % ex)
                
        else:
            try:
                nativeos, lanman = self.do_detect()
            except UnicodeDecodeError:
                try:
                    nativeos, lanman = self.do_detect(unicode=False)
                except Exception, ex:
                    self.log('Error: %s' % ex)
            except Exception, ex:
                self.log('Error: %s' % ex)
            
        self.setProgress(100)

        if not nativeos and not lanman:
            self.setInfo("%s running against %s:%d - done (failure)" % (NAME, self.host, self.port))
            return 0
        
        if nativeos:
            self.log('Found SMB native os: %s' % nativeos)
            self.target.add_knowledge("SMB NativeOS", nativeos, 100)
            
        if lanman:
            self.log('Found SMB lanman: %s' % lanman)
            self.target.add_knowledge("SMB Lanman", lanman, 100)

        self.setInfo("%s running against %s:%d - done (success!)" % (NAME, self.host, self.port))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
