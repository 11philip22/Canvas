#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2013
#http://www.immunityinc.com/CANVAS/ for more information
from __future__ import division
import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import socket
from exploitutils import *
from canvasexploit import canvasexploit

import urllib2
from urlparse import urlparse
import httplib
import re
import difflib
import random
import json
import string

from contextlib import contextmanager
from libs.spkproxy import *

NAME                            = "wp_themedetect"
DESCRIPTION                     = "Find all visible themes"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Wordpress"
DOCUMENTATION["References"]     = "http://www.wordpress.org/"
DOCUMENTATION["Repeatability"]  = "Infinite"

VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Recon"
PROPERTY['SITE']                = "Remote"

@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.found_plugins = []
        self.result = None
        self.name = NAME
        self.port = 80
        self.ssl = 0
        self.full_analysis = 0
        self.randomize = 0
        self.basepath = "/"
        self.cookies = ""
        self.timeout = 60
        self.page404 = []
        self.top_themes = {'Ultra': 'ultra',
                            'GeneratePress': 'generatepress',
                            'Enigma': 'enigma',
                            'Grow': 'grow',
                            'Bazaar Lite': 'bazaar-lite',
                            'MH TechMagazine': 'mh-techmagazine',
                            'MH TechMagazine Lite': 'mh-magazine-lite',
                            'Minamaze': 'minamaze',
                            'Business Elite': 'business-elite',
                            'Movers Packers': 'movers-packers',
                            'ResponsiveBoat': 'responsiveboat',
                            'Zerif Lite': 'zerif-lite',
                            'Virtue': 'virtue',
                            'Responsive': 'responsive',
                            'Islemag': 'islemag',
                            'Beetle': 'beetle',
                            'Sparkling': 'sparkling',
                            'Llorix One Lite': 'llorix-one-lite',
                            'Dyad': 'dyad',
                            'Hueman': 'hueman',
                            'Vantage': 'vantage',
                            'Education Hub': 'education-hub',
                            'EasyMag': 'easymag',
                            'Ribosome': 'ribosome',
                            'Revive': 'revive',
                            'Olsen Light': 'olsen-light',
                            'Optimizer': 'optimizer',
                            'OnePress': 'onepress',
                            'Customizr': 'customizr',
                            'Storefront': 'storefront',
                            'Evolve': 'evolve',
                            'Tortuga': 'tortuga',
                            'Relief': 'relief',
                            'Poseidon': 'poseidon',
                            'eStore': 'estore',
                            'Nisarg': 'nisarg',
                            'ColorMag': 'colormag',
                            'Spacious': 'spacious',
                            'Twenty Ten': 'twentyten',
                            'Athena': 'athena',
                            'Activello': 'activello',
                            'Twenty Eleven': 'twentyeleven',
                            'Twenty Thirteen': 'twentythirteen',
                            'Twenty Twelve': 'twentytwelve',
                            'Sydney': 'sydney',
                            'Twenty Sixteen': 'twentysixteen',
                            'Twenty Fifteen': 'twentyfifteen',
                            'Twenty Fourteen': 'twentyfourteen',
                            'Nirvana': 'nirvana'}
        return

    def getArgs(self):
        self.getarg("host")
        self.getarg("port")
        self.getarg("basepath")
        self.getarg("cookies")
        self.getarg("timeout")
        self.getarg("ssl")
        self.getarg("full_analysis")
        return

    def progress_bar(self, i):
        if i == 0:
            return "[          ] 0%"
        elif i == 10:
            self.setProgress(20)
            return "[==        ] 20%"
        elif i == 20:
            self.setProgress(40)
            return "[====      ] 40%"
        elif i == 25:
            self.setProgress(50)
            return "[=====     ] 50%"
        elif i == 35:
            self.setProgress(70)
            return "[=======   ] 70%"
        elif i == 45:
            self.setProgress(90)
            return "[========= ] 90%"
        return ""

    def createURL(self):
        """
        Logic to make a URL out of user input
        """
        if self.ssl:
            self.scheme = "https://"
        else:
            self.scheme = "http://"

        resolved_from = self.argsDict.get("resolved_from")
        if not resolved_from:
            resolved_from = self.host
        self.dif_port = ""
        if self.port == 80 or self.port == 443:
            dif_port = ":" + str(self.port)
        url = self.scheme + resolved_from + self.dif_port + self.basepath

        return url

    # Check custom 404 pages
    def check_404(self, urlBase, depth=0):
        invalid_url = urlBase
        if depth == 0:
            invalid_url += ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16)) + "/"
        elif depth > 2:
            self.page404 = []
            return
        req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36',
                   'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
        if self.cookies:
            headers['Cookie'] = self.cookies
        with no_timeout_socket():
            try:
                req.request("GET", invalid_url, headers=headers)
                url_404 = req.getresponse()
            except:
                return
            if url_404.status == 200:
                list_404 = []
                list_404.append(url_404.read())
                self.page404 += list_404
                return
            elif url_404.status in [301, 302, 305, 307]:
                try:
                    self.check_404(urlparse(url_404.getheader('location')).path, depth=depth+1)
                except:
                    return

    def test_wordpress(self, urlBase):
        """
        Check for the expected root directory structure in a Wordpress install
        This should be a reasonable test for the presence of Wordpress
        """
        with no_timeout_socket():
            logging.info("Checking if provided URL is available")
            # Perform a sanity check
            req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36',
                       'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
            if self.cookies:
                headers['Cookie'] = self.cookies
            try:
                req.request("GET", urlparse(urlBase).path, headers=headers)
                res = req.getresponse()
                url_available = res.read()

            except Exception as e:
                logging.error("Failed to fetch %s, check URL" % urlBase)
                return False
            logging.info("Got URL")

            self.check_404(urlBase)

            # Is Wordpress present?
            logging.info("Checking root directory structure")
            dirList = ["wp-admin", "wp-content", "wp-includes"]
            count = 0
            for d in dirList:
                url = urlBase + d + "/"
                try:
                    req.request("GET", urlparse(url).path, headers=headers)
                    res = req.getresponse()
                    resp = res.read()
                    count += 1

                except Exception as e:
                    logging.error("Didn't find %s" % d)
                if res.status != 200:
                    count -= 1
                    logging.error("Didn't find %s" % d)

            logging.info("Checking for admin-ajax.php")
            url = urlBase + "wp-admin/admin-ajax.php"
            admin_ajax = False
            try:
                req.request("GET", urlparse(url).path, headers=headers)
                res = req.getresponse()
                resp = res.read()
                admin_ajax = True
            except:
                logging.error("Didn't find admin-ajax.php")
            if res.status != 200:
                admin_ajax = False
                logging.error("Didn't find admin-ajax.php")

            if count / float(len(dirList)) > .6 or admin_ajax: # Allows for wp-includes or wp-content to be secured
                logging.info("Found Wordpress")
                return True
            else:
                logging.info("Performing last check")
                logging.info("Checking if wp-admin, wp-content or wp-includes are in another place")
                dirs = re.findall("(src=|http://|https://)([^\n]*?)(wp-admin|wp-content|wp-includes)", url_available)
                hostname = self.host[4:self.host.rfind(".")] if self.host.startswith("www.") else self.host[:self.host.rfind(".")]
                dirs = [(host, d) for _, host, d in dirs if hostname in host or re.match("['|\"](.|/)wp-content", host)]
                if len(dirs) > 0:
                    logging.info("Found Wordpress")
                    return True
                else:
                    logging.error("Did not find Wordpress. It is possible that wp-includes, wp-content, and wp-admin have been secured")
                    return False

    def find_plugins(self, url_base):
        logging.info("Searching themes")
        # TODO: Read wp-admin/admin-ajax.php
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36'}
        if self.cookies:
            headers['Cookie'] = self.cookies
        with no_timeout_socket():
            try:
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                req.request("GET", self.basepath, headers = headers)
                response = req.getresponse()
                code = response.status
                html = response.read()
            except:
                logging.error("Server error")
                return False

        self.redir = 0
        if code == 301 or code == 302:
            logging.error("The site is redirecting to another location, please try with the new location")
            logging.info("We will try to reach wordpress directories in this site")
            self.redir = 1

        curr_plugins = re.findall('(src=|http://|https://|href=)([^\n]*?)themes/(.+?)/', html)
        hostname = self.host[4:self.host.rfind(".")] if self.host.startswith("www.") else self.host[:self.host.rfind(".")]
        l = []
        l.append(self.scheme + self.host)
        curr_plugins = [plugins for _,host,plugins in curr_plugins if difflib.get_close_matches(host, l) or re.match("['|\"](.|/)wp-content", host) or hostname in host]
        curr_plugins = list(set(curr_plugins))

        self.found_plugins = self.found_plugins + curr_plugins

        for name, plugin in self.top_themes.iteritems():
            if plugin in curr_plugins:
                self.found_plugins.append(name)
                self.found_plugins.remove(plugin)

        logging.info("Searching themes directory")
        # Path where all plugins lies
        path = ""
        if len(self.found_plugins) >= 1:
            if self.found_plugins[0] in self.top_themes:
                pattern = re.compile(".*(src=|http://|https://|href=)([^\n]*?)/themes/" + self.top_themes[self.found_plugins[0]] + ".*", re.DOTALL)
            else:
                pattern = re.compile(".*(src=|http://|https://|href=)([^\n]*?)/themes/" + self.found_plugins[0] + ".*", re.DOTALL)
            path_groups = re.match(pattern, html)
            if path_groups:
                path = path_groups.group(2)
                if path[0] == "'" or path[0] == "\"":
                    path = path[1:]

        if not path:
            path = url_base + "wp-content"

        url_parse = urlparse(path)
        if not path.startswith("http"):
            scheme = path_groups.group(1)
            if not hostname in path:
                p = url_parse.path
                host_to = url_parse.netloc if url_parse.netloc else self.host
                if self.ssl:
                    path = "https://" + host_to + p
                else:
                    path = "http://" + host_to + p
            elif hostname in path:
                if self.ssl:
                    path = "https://" + url_parse.netloc + self.dif_port + url_parse.path
                else:
                    path = "http://" + url_parse.netloc + self.dif_port + url_parse.path
            else:
                path = scheme + url_parse.netloc + self.dif_port + url_parse.path

        logging.info("Searching for more themes")
        i = 0
        self.check_404(urlparse(path).path + '/themes/')
        with no_timeout_socket():

            for item,value in self.top_themes.items():
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                progress = self.progress_bar(i)
                if progress:
                    logging.info("%s" % progress)

                url = path + '/themes/' + value
                path2 = urlparse(path).path + '/themes/' + value + "/"

                response = self.send_req(req, path2, headers)
                if not response:
                    logging.error("Invalid code or server error from %s" % url)
                    continue
                html, code = response

                if not self.check_isvalid(html, code, item):
                    req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                    path2 = path2 + "readme.txt"
                    response = self.send_req(req, path2, headers)
                    if not response:
                        logging.error("Invalid code or server error from %s" % url)
                        continue
                    html, code = response
                    self.check_isvalid(html, code, item)
                i += 1
        if not self.full_analysis:
            return True
        else:
            return self.check_versions(urlparse(path).path, headers)

    def send_req(self, req, path, headers):
        try:
            req.request("GET", path, headers = headers)
            response = req.getresponse()
            code = response.status
            html = response.read()
        except:
            code = -1
            html = ""
            return None
        if code in [301, 302, 305, 307]:
            return self.resolve_redir(req, response, headers)
        return html, code

    def resolve_redir(self, req, response, headers, depth=0, netloc=None):
        if not netloc:
            netloc = self.host
        if depth <= 2:
            if req.host != netloc:
                req = httplib.HTTPSConnection(netloc) if self.ssl else httplib.HTTPConnection(netloc)
            try:
                req.request("GET", urlparse(response.getheader('location')).path, headers = headers)
                response = req.getresponse()
                code = response.status
                html = response.read()
                if code in [301, 302, 305, 307]:
                    self.resolve_redir(req, response, headers, depth+1, urlparse(response.getheader('location')).netloc)
                else:
                    return html, code
            except:
                code = -1
                html = ""
                return None
        return html, code

    def check_isvalid(self, html, code, item):
        aux_list = []
        aux_list.append(html)
        if self.redir and (code == 403 or code == 200) and not difflib.get_close_matches(aux_list[0], self.page404):
            logging.info("%s Found" % item)
            self.found_plugins.append(item)
            return True
        elif not self.redir and code not in [404,408,400,500,-1] and not difflib.get_close_matches(aux_list[0], self.page404):
            logging.info("%s Found" % item)
            self.found_plugins.append(item)
            return True
        return False

    def check_versions(self, path, headers):
        version_list = []
        with no_timeout_socket():
            for plugin in self.found_plugins:
                req = httplib.HTTPSConnection(self.host) if self.ssl else httplib.HTTPConnection(self.host)
                latest = self.get_latest(plugin)
                if plugin in self.top_themes:
                    path2 = path + '/themes/' + self.top_themes[plugin] + '/style.css'
                else:
                    path2 = path + '/themes/' + plugin + '/style.css'
                resp = self.send_req(req, path2, headers)
                if not resp:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                html, code = resp
                if not "Version" in html:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                pattern = re.compile(".*Version:(.+?)(\r|\n)", re.DOTALL)
                groups = re.match(pattern, html)
                if not groups:
                    version_list.append((plugin, "Unable to determine", latest))
                    continue
                version = groups.group(1).replace(" ", "")
                version_list.append((plugin, version, latest))
            self.found_plugins = version_list
            return True

    def get_latest(self, plugin):
        if plugin in self.top_themes:
            plugin = self.top_themes[plugin]
        req = httplib.HTTPConnection("api.wordpress.org")
        req.request("GET", "/themes/info/1.1/?action=theme_information&request[slug]=" + plugin)
        resp = req.getresponse()
        if not resp:
            return "Unable to determine"
        html = resp.read()
        if html == "null":
            return "Unable to determine"
        try:
            info = json.loads(html)
        except:
            return "Unable to determine"
        if info == False:
            return "Unable to determine"
        return info["version"]

    def prettyprint(self):
        self.found_plugins.insert(0, ("     Theme", "     Current version", "     Latest version"))
        remap = zip(*self.found_plugins)
        max_len = max(map(len,remap[0]))
        max_len2 = max(map(len,remap[1]))
        max_len3 = max(map(len,remap[2]))
        string = ""
        for (plugin, curr_version, latest_version) in self.found_plugins:
            string += ("%*s | %*s | %*s\n" % (-max_len, plugin, -max_len2, curr_version, -max_len3, latest_version))
        logging.info("\n%s" % string)

    def run(self):
        self.getArgs()
        url_base = self.createURL()

        if not self.test_wordpress(url_base):
            return False
        if not self.find_plugins(url_base):
            return False

        self.found_plugins = list(set(self.found_plugins))
        logging.info("The following %d themes were found:\n" % len(self.found_plugins))
        if self.full_analysis:
            self.prettyprint()
        else:
            logging.info(self.found_plugins)

        return True

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)