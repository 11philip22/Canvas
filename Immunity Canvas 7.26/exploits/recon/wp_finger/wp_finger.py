#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2013
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *
from canvasexploit import canvasexploit
import urllib2, hashlib
import random
import logging
from collections import Counter

from time import sleep
from contextlib import contextmanager

NAME                           = "wordpress_print"
DESCRIPTION                    = "Fingerprint WordPress based on .css and .js files"

DOCUMENTATION                  = {}
DOCUMENTATION["VENDOR"]        = "Wordpress"
DOCUMENTATION["References"]    = "http://www.wordpress.org/"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["Notes"]         = """
Arguments: Provide the directory you believe Wordpress
lives in (i.e. example.com/wp/)

Fingerprints Wordpress versions:
2.8-3.8 major versions
3.0-3.8 revisions

This tool attempts to determine what version of
Wordpress a site is running by examining the site's
responses to a number of HTTP queries. This module
does not attempt to exploit any vulnerabilities nor
does it perform any attacks.

This tool is not affected by the covertness bar. It
will send 2-8 requests to the server in quick succession.

It also forges requests to bypass certain antispam
and antibot plugins and addons. Tested against
Bad Behaviour 2.2.14, latest version at this time.
The fingerprinter relies on .css, .js, and .gz files
that are normally publicly available and come standard
in WordPress. If those files are modified, then the
fingerprinter will fail.

"""

VERSION          = "1.0"
PROPERTY         = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"


from libs.spkproxy import *
@contextmanager
def no_timeout_socket():
    old           = socket.socket
    socket.socket = socket._no_timeoutsocket
    try:
        yield
    finally:
        socket.socket = old

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result    = None
        self.name      = NAME
        self.port      = 80
        self.ssl       = 0
        self.basepath  = "/"
        self.timeout   = 60

    def getArgs(self):
        self.getarg("port")
        self.getarg("basepath")
        self.getarg("timeout")
        self.getarg("ssl")

    def usage(self):
        logging.info("Usage: %s -t target [-O ssl:0] [-O port:80] [-O basepath:/] [-O timeout:60]\n" % sys.argv[0])

    def make_request(self, urlBase):
        url = urlBase + "wp-login.php"
        version = None
        version_readme = None
        resp = None
        try:
            with no_timeout_socket():
                #urllib2 antispambot bypass
                request = urllib2.Request(url)
                request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                opener = urllib2.build_opener()
                resp = opener.open(request, timeout=self.timeout).read()
                # Could be many "ver=" on the html, not always is the wordpress version, sometimes is a lib version reference.
                # Is okay for now but could be a better way to determine the version.
                pattern = re.compile("[Vv]er(sion)?=([0-9].+?)('|\")", re.DOTALL)
                matches = re.findall(pattern, resp)
                if matches:
                    versions = [ver[1] for ver in matches if ver[1][0] > "1"]
                    version = Counter(versions).most_common(1)[0][0]

        except urllib2.URLError, e:
            self.log_error(e)

        try:
            with no_timeout_socket():
                url = urlBase + "readme.html"
                request = urllib2.Request(url)
                request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                opener = urllib2.build_opener()
                resp = opener.open(request, timeout=self.timeout).read()
                pattern = re.compile(".*[Vv]ersion ([0-9][^\s]+\.[^\s]+?)(\s|\n|\r)", re.DOTALL)
                groups = re.match(pattern, resp)
                if groups:
                    version_readme = groups.group(1)

        except urllib2.URLError, e:
            self.log_error(e)

        # Lame control but I don't know how to handle this in a better way
        def tryint(x):
            try:
                return int(x)
            except ValueError:
                return x

        def splittedname(s):
            return tuple(tryint(x) for x in re.split('([0-9]+)', s))

        if version and version_readme and (version != version_readme):
            l = [version, version_readme]
            return sorted(l, key=splittedname)[-1]
        ###

        if version_readme:
            return version_readme

        return version

    def test_finger(self, urlBase):
        """
        Check for the expected root directory structure in a Wordpress install
        This should be a reasonable test for the presence of Wordpress
        """

        """
        TODO: Because urllib2 uses a header "Connection: Close" as default sometimes this could return a false-positive.
        An example is www.nytco.com which return one HTML with Connection: Close and differente one without that header.
        It is important to note that there is no way to change this using urllib2 because the source code have a special
        comment about this header and why it is needed.
        Reference: https://hg.python.org/cpython/file/2.7/Lib/urllib2.py line 1174
        The best way to deal with this is change the use of urllib2 for Requests and include package Requests in the install
        package of Canvas.
        The second way to deal with this is change the use of urllib2 for httplib.
        """
        with no_timeout_socket():
            self.log_info("[+] Checking if provided URL is available")
            # Perform a sanity check
            try:
                request = urllib2.Request(urlBase)
                request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                opener = urllib2.build_opener()
                resp = urllib2.urlopen(request, timeout=self.timeout).read()
            except Exception as e:
                self.log_error(e)
                self.log_error("   [-] Failed to fetch %s, check URL"%urlBase)
                return False
            self.log_info("   [+] Got URL")

            # Is Wordpress present?
            self.log_info("[+] Checking root directory structure")
            dirList = ["wp-admin", "wp-content", "wp-includes"]
            count = 0
            for dir in dirList:
                url = urlBase+dir + "/"
                try:
                    request = urllib2.Request(url)
                    request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                    request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                    opener = urllib2.build_opener()
                    resp = opener.open(request, timeout=self.timeout).read()
                    count += 1

                except Exception as e:
                    self.log_error(e)
                    self.log_error("   [-] Didn't find %s"%dir)

            if count/float(len(dirList)) > .6: # Allows for wp-includes or wp-content to be secured
                self.log_info("   [+] Found Wordpress")
                return True
            else:
                self.log_info("Check for admin-ajax.php")
                url = urlBase + "wp-admin/admin-ajax.php"
                admin_ajax = False
                try:
                    request = urllib2.Request(url)
                    request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                    request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                    opener = urllib2.build_opener()
                    resp = opener.open(request, timeout=self.timeout)
                    admin_ajax = True
                except:
                    self.log_error("Didn't find admin-ajax.php")
                    resp = None

                if resp and resp.getcode() != 200:
                    admin_ajax = False
                    self.log_error("Didn't find admin-ajax.php")

                if admin_ajax == True:
                    return True

                self.log_info("Last check")
                self.log_info("Checking if wp-admin, wp-content or wp-includes are in another place")

                request = urllib2.Request(urlBase)
                request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36')
                request.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
                opener = urllib2.build_opener()
                resp = opener.open(request, timeout=self.timeout).read()

                dirs = re.findall("(src=|http://|https://)([^\n]*?)(wp-admin|wp-content|wp-includes)", resp)
                hostname = self.host[4:self.host.rfind(".")] if self.host.startswith("www.") else self.host[:self.host.rfind(".")]
                dirs = [(host, d) for _, host, d in dirs if hostname in host or re.match("['|\"](.|/)wp-content", host)]

                if len(dirs) > 0:
                    self.log_info("Found Wordpress")
                    return True
                else:
                    self.log_error("Did not find Wordpress. It is possible that wp-includes, wp-content, and wp-admin have been secured.")
                    return False

    def defaultFprint(self, urlBase):

        # A standardized function to make requests and match found responses with expected responses

        vers = self.make_request(urlBase)

        if vers == None:
            self.log_error("[-]No versions of WordPress matched. Please fingerprint manually")
            return False
        else:
            self.log_info("[+]Fingerprint found:")
            self.log_info("%s" % vers)
            return vers

    def createURL(self):
        """
        Logic to make a URL out of user input
        """
        if self.basepath[0] == "/": self.basepath = self.basepath[1:]

        if self.ssl:
            url = "https://" + self.host + ":" + str(self.port) + "/" + self.basepath
        else:
            url = "http://" + self.host + ":" + str(self.port) + "/" + self.basepath

        if url[-1] != "/": url = url + "/"

        return url

    def run(self):
        self.getArgs()
        self.host = self.getarg("host")
        #chris added the below line but it broke stuff, didn't wanna remove in case he needs it
        #self.host = self.target.resolved_from
        url = self.createURL()

        sites = [] # Done this way to allow for adding testing URLs, we can test multiple sites at once
        sites.append(url)

        for urlBase in sites:
            self.log_info("Examining URL: %s"%urlBase)
            if self.test_finger(urlBase):
                self.log_info("[+] Looking for major Wordpress version")
                version = self.defaultFprint(urlBase)
                self.log_info("Fingerprinter finished, site is %s" % version)
                return True
        return True


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
