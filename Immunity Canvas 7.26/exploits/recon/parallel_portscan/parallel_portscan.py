#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2012
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *

import weakref
import threading
import canvasengine
import timeoutsocket
import multiprocessing.dummy

from tcpexploit import tcpexploit

DESCRIPTION      = "Parallel TCP Portscanning using Python Threads"
VERSION          = "1.0"
NAME             = "parallel_portscan"
PROPERTY         = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name         = NAME
        self.ports        = ''
        self.tcp_timeout  = 5
        self.max_threads  = 66
        self.typed_result = {}

    def getargs(self):
        self.getarg("ports")
        self.getarg("tcp_timeout")
        self.getarg("max_threads")

    def run(self):
        self.getargs()
        self.host = self.target.interface

        ports = []

        # Parse the port specification
        try:
            for entry in self.ports.split(','):
                if "-" in entry:
                    start, end = map(int, entry.split("-"))
                    ports.extend(range(start, end+1))
                else:
                    ports.append(int(entry))
        except Exception, ex:
            self.log('Error parsing port specification: %s' % ex)
            return 0

        if not ports:
            self.log('Empty port specification, aborting.')
            return 0
        
        def scan_port(port):
            """
            This is the function that performs the actual connection.
            """
            try:
                s = self.gettcpsock()
                s.set_timeout(self.tcp_timeout)
                s.connect((self.host, port))
            except timeoutsocket.Timeout:
                return (False, False)
            except Exception:
                return (False, False)
            finally:
                s.close()
            
            return (True, port)
        
        self.setInfo("%s scanning %s (in progress)" % (NAME, self.host))
        self.log("Scanning ports %s, %s threads, timeout: %s seconds" % (self.ports, self.max_threads, self.tcp_timeout))

        # Workaround for instantiating Pool from a thread 
        threading.current_thread()._children = weakref.WeakKeyDictionary()
    
        self.log('Setting up thread pool with %s workers..' % self.max_threads)
        pool = multiprocessing.dummy.Pool(self.max_threads)

        self.log('Parallelizing scan..')

        open_ports = [x[1] for x in pool.map(scan_port, ports, chunksize=1) if x[0]]

        self.setInfo("%s scanning %s (done)"% (self.name, self.host))

        pool.close()
        pool.join()

        if open_ports:
            self.typed_result['ports'] = open_ports
            self.log('Found open ports: %s' % repr(open_ports))
            return 1

        self.log('No open ports')
        return 0


if __name__ == "__main__":
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

