#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  userenum.py
## Description:
##            :
## Created_On :  Wed Jul 30 CET 2015
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import sys
import os
import socket
import time

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'userenum'
DESCRIPTION                     = 'Get a list of users.'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Recon'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [['Windows']]

CHANGELOG = """
"""

NOTES = """
This is a quicky user enumeration tool. Remotely, it determines the logged in
users by bruteforcing the RID. Locally, it determines all the users connected.

Tested against:
    - Windows 7 (x86)
    - Windows Server 2003 R2 (x86)
    - Windows Server 2008 R2 (amd64)
    - Windows Server 2012 (amd64)
"""

from exploitutils import *
from tcpexploit import tcpexploit
import canvasengine
from engine import CanvasConfig
from engine.config import canvas_root_directory
from libs.canvasos import *
import libs.kerberos.ccache as cc
import libs.newsmb.lsarpc as lsa
from libs.newsmb.wkssvc import wkssvc_enum_user

class user:
    "Reintroduced to avoid breaking old modules compatibility"
    def __init__(self, username="", rid=None, user_type="user"):
        self.username = username.encode('UTF-8').split('\x00')[0].decode('UTF-8')
        self.rid = rid
        self.user_type = user_type

    def __str__(self):
        return self.username.encode('ASCII', 'replace')

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.result       = ""
        self.name         = NAME
        self.systemname   = "\\\\127.0.0.1"
        self.user         = u""
        self.password     = u""
        self.domain       = u""
        self.ccache_file  = None
        self.use_kerberos = False
        self.loggedinonly = False
        #we do a relatively small number by default
        #since most of the ones we are interested in are right there
        #and doing a lot of them makes our lives extremely slow!
        self.startrid     = None
        self.endrid       = None
        self.customport   = 0
        self.customports  = []

    def getargs(self):
        self.user = self.argsDict.get("user",self.user)
        self.password = self.argsDict.get("password",self.password)
        self.domain = self.argsDict.get('domain', self.domain)
        self.ccache_file = self.argsDict.get('krb5_ccache', self.ccache_file)
        self.loggedinonly = self.argsDict.get("loggedinonly",self.loggedinonly)
        if self.autohack_state == "silica" or self.argsDict.get("silica", False):
            self.loggedinonly=True
        try:
            self.startrid = int(self.argsDict.get("startrid", self.startrid))
        except Exception as e:
            self.startrid = None
        try:
            self.endrid = int(self.argsDict.get("endrid", self.endrid))
        except Exception as e:
            self.endrid = None
        self.customport = int(self.argsDict.get("customport", self.customport))


    def getLoggedInUsers(self, osstr):
        """
        Get the logged in users instead of all the users using wksvc
        """

        userlist = []

        if self.use_kerberos:
            if not self.domain or not (self.ccache_file or self.password):
                self.log("Not enough parameters to use Kerberos authentication.")
                return userlist

        if "Windows" in osstr:
            self.log("Windows found, using wksvc to enumerate users")
            ret, users = wkssvc_enum_user(self.target.interface,
                                             username=self.user,
                                             password=self.password,
                                             domain=self.domain,
                                             kerberos_db=self.ccache_file)
            if ret == -5:
                self.log_error("Access Denied for provided credentials")

        if users:
            userlist = [ user(u) for u in users ]
        return userlist

    def getAllUsers(self):
        """
        Get All Users using LSASRV
        """

        userlist = []
        lsaobj = lsa.LSAClient(self.target.interface)
        lsaobj.set_credentials(self.user, self.password, self.domain, self.ccache_file)
        if not lsaobj.bind():
            self.log_error("Connection to LSA pipe failed.")
            return userlist

        try:
            domains = lsaobj.lookup_domains()
        except lsa.LSALookUpNamesException as e:
            self.log_error('Couldn\'t find any suitable domain SID.')
            return userlist

        if domains == None or not len(domains):
            self.log_error('Couldn\'t find any suitable domain SID.')
            return userlist

        # At this point we may have found a server associated with one or maybe
        # several domains.
        for dom in domains:

                # At this point we can now start the bruteforce. Basically if the forged
                # SID doesn't belong to any user, STATUS_NONE_MAPPED (0xc0000073) is
                # returned by the API otherwise if the SID does indeed belong to a valid
                # user, its name is returned/leaked.
                self.log_info('Found the domain %s with SID %s' % (dom['Name'], dom['Sid']))

                # Credits go to
                # http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python
                def chunks(l, n):
                    """Yield successive n-sized chunks from l."""
                    for i in xrange(0, len(l), n):
                        yield l[i:i+n]

                # The user may have specified an alternate range of RID to bf.
                if self.startrid:
                    if not self.endrid or self.endrid < self.startrid:
                        self.log_error('Faulty or unspecified end of the RID range. Assuming a default value.')
                        self.endrid = self.startrid + 80
                    rid_lists = list(chunks(range(self.startrid, self.endrid), 80))
                else:
                    rid_lists = []
                    rid_lists.append([i for i in xrange(500, 580+1)])
                    rid_lists.append([i for i in xrange(1000, 1080+1)])
                    rid_lists.append([i for i in xrange(1100, 1180+1)])
                    rid_lists.append([i for i in xrange(1200, 1280+1)])
                    rid_lists.append([i for i in xrange(1300, 1380+1)])
                    rid_lists.append([i for i in xrange(1400, 1480+1)])

                for rid_list in rid_lists:
                    self.log_info('Bruteforcing on range [%d,%d]' % (rid_list[0], rid_list[-1]))
                    sid_list = [dom['Sid'] + '-' + str(i) for i in xrange(rid_list[0], rid_list[-1])]

                    try:
                        names = lsaobj.lookup_sids(sid_list)
                    except lsa.LSALookUpSidsException as e:
                        if e.status == 0xc0000073:
                            continue
                        else:
                            self.log_info('LSALookUpSids() failed with unknown error: %s' % str(e))
                    else:
                        for name in names:
                            rid = int(name['Sid'].split('-')[-1])
                            if name['Type'] == lsa.SIDTYPEUSER:
                                username = name['Name'].decode('UTF-16LE').encode('ascii')
                                userlist.append(user(username, rid, user_type="user"))
                            if name['Type'] == lsa.SIDTYPEGROUP:
                                groupname = name['Name'].decode('UTF-16LE').encode('ascii')
                                self.log_info('Found group: %s' % groupname)
                                userlist.append(user(groupname, rid, user_type="group"))
        return userlist

    def check_ccache_file(self):
        try:
            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def run(self):
        self.setInfo("%s" % NAME)
        self.getargs()
        self.result = []
        node = self.argsDict["passednodes"][0]
        #need to revise to use get_knowledge/set_knowledge
        systemname = self.argsDict.get("systemname", self.systemname)
        #to test from commandline
        #runmodule userenum -t 1
        userlist = []
        if node.islocal(self.target.interface) and "win32api" in node.capabilities:
            self.log("Target is localhost on this Node")
            if "win32api" in node.capabilities:
                shell = node.shell
                usernamelist = shell.NetUserEnum()
                #create a list of classes out of it
                for u in usernamelist:
                    userlist += [user(u)]
            else:
                self.log("%s node type not supported" % node.nodetype)
        else:
            #is a remote target to our node
            if self.version == 0:
                osd=self.engine.getModuleExploit("osdetect")
                osd.link(self)
                #if we do language detection, then we will also do userenum
                #which is a deadly circle
                osd.argsDict["nolanguagedetect"] = True
                osd.run()
                osstr = str(osd.result)
                self.log("OS Detected: %s" % osstr)
            elif self.version == 1:
                osstr = "Windows"
            else:
                self.log("No OS Detected and version not chosen - ignoring host")

            if self.customport:
                self.customports.append(self.customport)

            # Sanity check: the ccache credentials
            if self.ccache_file:
                if not self.check_ccache_file():
                    self.log_error('%s doesn\'t seem to be a valid ccache file for user %s' % (self.ccache_file, '@'.join([self.user,self.domain])))
                    return 0
                else:
                    self.use_kerberos = True
                    self.log_info("Using kerberos authentication with credentials %s" % self.ccache_file)
            else:
                self.log_info("Using NTLM authentication")

            if self.has_named_pipes(self.target):
                if self.loggedinonly:
                    self.log("Checking logged in users only")
                    userlist = self.getLoggedInUsers(osstr)
                else:
                    self.log("Checking all users")
                    userlist = self.getAllUsers()
                    if not userlist:
                        self.log("No users found, trying Workstation Service instead for logged in users")
                        userlist = self.getLoggedInUsers(osstr)

        #Here we store the results in self.result for easy access
        if not userlist:
            userlist = []
        self.result = userlist

        # We print the results
        self.nlog("Found %s user(s)/group(s)" % len(userlist))
        for name in userlist:
            if name.user_type == 'user':
                self.nlog("Found user: %s" % name)

        # We add the results to the DB
        self.target.replace_knowledge("Users", userlist, 100)
        self.new_event("users", {
            "remote_ip": str(self.target.interface),
            "users": userlist,
            })

        self.setInfo("%s - done (success: %s)" % (NAME, "%d users found" % len(userlist)))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
