#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  http_method_scanner.py
## Description:
##            :
## Created_On :  Tue Oct 17 2017
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
###############################################################################

import os
import re
import sys
import copy
import socket
import logging

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'HTTP method scanner - List all the method authorized for a given URI'
DESCRIPTION                     = 'Attempt to find all the possible methods allowed for all the URI of a given website.'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = ''
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['Repeatability']  = ''

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Recon'
PROPERTY['SITE']                = 'Remote'

CHANGELOG = """
"""

NOTES = """

How it works:
    - ....
    - ....
    - ....

Tested against immunityinc.com

To execute a command:
python ....................................................
"""


from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine
import libs.spkproxy as spkproxy

USUAL_BLACKLIST = ['.mov', '.js', '.pkg', '.jpg', '.png', '.pdf', '.zip']
USUAL_METHODS = [ "POST", "HEAD", "PUT", "CONNECT" ]
ALTERNATE_METHODS = [ "FOO" ]

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)

        self.name           = NAME
        self.port           = 80
        self.ssl            = False
        self.vhost          = ""
        self.discover       = False
        self.debug          = False

        # Globals
        self.uri_db         = {}
        self.webcrawler_app = None
        self.UA             = None

    def is_alive(self):
        """
        Detects if the connection can be established or not.
        """
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host,self.port))
            s.close()
            return True
        except Exception as e:
            return False

    def getArgs(self):
        """
        Get arguments for attack
        """
        self.host     = self.target.interface
        self.port     = int(self.argsDict.get("port", self.port))
        self.vhost    = self.argsDict.get("vhost", self.vhost)
        self.discover = self.argsDict.get("discover", self.discover)
        self.debug    = self.argsDict.get("debug", self.debug)
        self.ssl      = self.argsDict.get("ssl", self.ssl)

        # TODO: authentication
        return

    def get_public_vhosts(self):
        """
        This (sub)function calls the ip_to_vhosts (bing request) to build a list
        of vhosts corresponding to the IP of the target.
        """
        logging.info('Grabbing vhosts for %s' % self.host)
        app = self.engine.getModuleExploit("ip_to_vhosts")
        app.link(self)
        res = app.run()
        if not res:
            return []
        else:
            vh = self.target.get_knowledge('vhosts')
            if vh:
                return vh.known
            else:
                return []

    def build_vhost_list(self):
        """
        Build a list of vhosts candidates.
        Please note that the user is assisted as much as possible
        """
        vhost_list = []
        # vhost is set
        if self.vhost:
            if self.discover:
                vhost_list += self.get_public_vhosts()
            if self.vhost not in vhost_list:
                vhost_list += [self.vhost]
        # vhost is not set!
        else:
            if self.discover:
                vhost_list += self.get_public_vhosts()
            if not vhost_list:
                vhost_list += [self.host]
        return vhost_list

    def get_uri_list(self, vhost):
        """
        Calls the webcrawler module to fetch the URI corresponding to an IP.
        The caller may also specify the corresponding vhost.
        """
        self.argsDict['vhost'] = vhost
        self.argsDict['debug'] = self.debug
        logging.info('Grabbing URI for vhost %s' % vhost)
        if not self.webcrawler_app:
            self.webcrawler_app = self.engine.getModuleExploit("webcrawler")
        self.webcrawler_app.link(self)
        # For some reason, patching self.argsDict['port'] has no effect.
        self.webcrawler_app.port = self.port
        self.webcrawler_app.ssl = self.ssl
        ret = self.webcrawler_app.run()
        if not ret:
            logging.warning('Could not fetch any URI for this vhost')
            return None
        vh = self.target.get_knowledge('URI')
        if not vh:
            logging.warning('Could not fetch any URI for this vhost')
            return None
        return vh.known

    def is_blacklisted(self, path):
        """
        Returns True if the URL/URI targets a file whose extension is within 
        the BL.
        """
        current_blacklist = USUAL_BLACKLIST
        for extension in current_blacklist:
            if path.split('?')[0].endswith(extension):
                return True
        return False

    def get_url(self, vhost, path):
        """
        Creates an URL based on the vhost and the path (URI).
        """
        url = "https" if self.ssl else "http"
        url += "://%s:%s" % (vhost, self.port)
        url += path
        return url

    def send_http_request(self, current_vhost, uri, method):

        url = self.get_url(current_vhost, uri)
        entireresponse = True
        if self.is_blacklisted(uri):
            entireresponse=False

        logging.debug('%s %s' % (method, url))
        try:
            (payload, http_code) = spkproxy.urlopen(url,
                                                    exploit=None,
                                                    entireresponse=entireresponse,
                                                    return_response_code=True,
                                                    auth=None,
                                                    verb=method)
        except Exception as e:
            logging.error('Error: %s' % str(e))
            return None

        return (http_code, payload)


    def extract_allowed_methods(self, payload):
        """
        A classical answer when http code is 200 includes this:
        'Allow: GET,HEAD,POST,OPTIONS\r\n'
        """

        REGEXP_ALLOW = 'Allow:[\s]+(.*?)\r\n'
        patterns = re.findall(REGEXP_ALLOW, payload)
        if not patterns:
            return []
        L1 = patterns[0].split(',')
        # There might be a left space prefixing the method name
        L2 = map(lambda x: x.lstrip(' '), L1)
        L2.remove('GET')
        return L2

    def add_confirmation(self, path, method, confirmation='CRAWLER'):

        if not self.uri_db.has_key(path):
            self.uri_db[path] = {}
        self.uri_db[path][method] = confirmation

    def run(self):
        """
        runs the attempt to grab information
        """

        # TODO: update knowledge should allow to CACHE the URI things unless a force option is set
        # We need to see if the LIST is absolutely mandatory of if we could use a simple DIC['vhost']

        self.getArgs()
        self.setInfo("Running %s against %s [vhost:%s]" % (NAME, self.host, self.vhost))

        # We may need more debugging
        if self.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)

        if not self.is_alive():
            logging.error('The connection can not be established.')
            logging.error("%s - found no reachable host!" % self.name)
            self.setInfo("%s - found no reachable host!" % self.name)
            return 0

        # Throws a warning if it is likely that the user should have checked the SSL box
        if not self.ssl and self.port in [443, 8443]:
            logging.warning('You are running the webcrawler against port %d yet SSL/TLS is disabled' % self.port)
        if self.ssl and self.port in [80, 8080]:
            logging.warning('You are running the webcrawler against port %d yet SSL/TLS is enabled' % self.port)

        vhost_list = self.build_vhost_list()
        if not vhost_list:
            # Practically this should be impossible no matter the parameters.
            logging.error("%s - unexpected error occured while building the vhost list" % self.name)
            return 0

        logging.info('Performing the attack against %s different vhost(s)' % len(vhost_list))

        for current_vhost in vhost_list:

            uri_dic = self.get_uri_list(current_vhost)
            base_url = self.get_url(current_vhost, '/')
            # This should not happen unless there is a bug.
            if not uri_dic.has_key(base_url):
                logging.error('For some reason, the record < %s > could not be found in the URI knowledge' % base_url)
                continue

            uri_list = uri_dic[base_url]['uri']
            for http_code in uri_list:
                for uri in uri_list[http_code]:

                    # Temp
                    logging.info("Analyzing %s" % uri)

                    self.add_confirmation(uri, 'GET')

                    # First try the OPTIONS to see if we can build an alternate list of methods
                    ret = self.send_http_request(current_vhost, uri, 'OPTIONS')
                    if not ret:
                        continue
                    (http_code, payload) = ret
                    if http_code == 200:
                        logging.debug("OPTIONS returned an answer")
                        allowed_methods = self.extract_allowed_methods(payload.read())
                        for method in allowed_methods:
                            self.add_confirmation(uri, method, confirmation='OPTIONS')

                    # If this does not work, we have no other choice but to try one method after another.
                    # Note: For obvious reason, we do not attempt to use DELETE.
                    else:
                        logging.debug("OPTIONS failed [err:%s]" % http_code)
                        logging.debug("Bruteforcing method(s) %s" % ','.join(USUAL_METHODS))
                        for method in USUAL_METHODS:
                            ret = self.send_http_request(current_vhost, uri, method)
                            if not ret:
                                continue
                            http_code, payload = ret
                            if http_code not in [400, 405, 501]:
                                logging.debug("%s seems allowed [code:%s]" % (method, http_code))
                                self.add_confirmation(uri, method, confirmation='HTTP answer:%s' % http_code)

                    # If might also be useful to test alternate methods.
                    # In some cases this can be useful to bypass authentications.
                    logging.debug("Bruteforcing method(s) %s" % ','.join(ALTERNATE_METHODS))
                    for method in ALTERNATE_METHODS:
                        ret = self.send_http_request(current_vhost, uri, method)
                        if not ret:
                            continue
                        http_code, payload = ret
                        if http_code not in [400, 405, 501]:
                            logging.debug("%s seems allowed [code:%s]" % (method, http_code))
                            self.add_confirmation(uri, method, confirmation='HTTP answer:%s' % http_code)

        nbr_methods = 0
        for uri in self.uri_db:
            for method in self.uri_db[uri]:
                if method != 'GET':
                    nbr_methods += 1
                logging.info("%s %s [CONFIRMED: %s]" % (method, uri, self.uri_db[uri][method]))

        if nbr_methods:
            logging.info("%d new methods found for vhosts in list %s" % (nbr_methods, ','.join(vhost_list)))
            # TODO: Maybe add the methods found in the knowledge?
            self.setInfo("%s for %s - done (success)" % (NAME, self.host))
            return 1

        logging.error("%s - found no reachable URI!" % self.name)
        self.setInfo("%s - found no reachable URI!" % self.name)
        return 0


if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
