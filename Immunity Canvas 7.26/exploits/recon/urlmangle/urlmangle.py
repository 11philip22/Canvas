#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
import os, socket, time, re, httplib

import timeoutsocket
from exploitutils import *
import canvasengine

from ExploitTypes.utility import Utility

NAME                           = "urlmangle"
DESCRIPTION                    = "Create domains to check for phishing"
VERSION                        = "1.0"
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = "None"
DOCUMENTATION["Date public"]   = "00/00/00"
DOCUMENTATION["CERT Advisory"] = "None"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"]    = "Original idea from -> http://code.google.com/p/urlcrazy/"
DOCUMENTATION["CVE Name"]      = "None"
DOCUMENTATION["CVE Url"]       = "None"
DOCUMENTATION["Notes"]         = """

This module takes a domain name and generates a list of domain names that are similar
to the original in appearance, spelling, etc. It then checks if those domains have owners,
if so it retrieves their whois data and checks for HTTP 301s.

Use this to find domains that might be phishing your users

"""

PROPERTY                       = {}
PROPERTY["TYPE"]               = "Recon"
PROPERTY["SITE"]               = "Remote"
PROPERTY["ARCH"]               = [ ["All"] ]
PROPERTY["VERSION"]            = []

targets = {}

def threadme(a_obj, ce):
    """
    Runs in a thread, takes in a canvasexploit instance and an object from our iterable
    
    returns a nonFalse tuple (for found a host) or False for did not find a host (which is then ignored)
    """
    host=a_obj
    devlog("dnsfind","Looking up %s"%(host))
    if ce.throttle > 0:
        time.sleep(float(ce.throttle))
    try:
        ip = socket.gethostbyname(host )
    except socket.gaierror, error:
        devlog("dnsfind", "Error: %s"%error)
        return False  #did not find a host
    
    return (host, ip) #found a host

class infoClass():
    #
    # Store all the info about a domain
    def __init__(self):
        self.fqdn = "" # FQDN of host
        self.whois = "" # list of strings
        self.whoisLoc = "" #Location of whois file
        self.b301 = "" # Bool
        self.url301 = [] # list of urls found with 301
        self.location = "&nbsp" # country code
        self.ip = ""
        self.notes = [] # A list of notes to print maybe

class theexploit(Utility):
    def __init__(self):
        Utility.__init__(self)
        self.name=NAME
        self.savefile = ""
        self.savePath = None
        self.debug = False
        self.domain = ""
        self.hostname = ""
        self.host = ""
        self.tld = ""
        self.throttle = 0.00 # Delay time between requests
        self.whois = ""
        self.do_threaded = True
        self.tldDict = {} # {'domain': 'whois server fqdn'}

    def getargs(self):
        self.getarg("domain")
        self.getarg("whois")
        self.savepath = self.output(subdir="urlmangle")
        self.node=self.argsDict["passednodes"][0]
        return 
    
    def usage(self):
        #
        # Standard options don't apply here
        print "="*10
        print "Generate and check a list of domains based on a supplied domain"
        print "Output is in the form of a html report in your session/Reports/urlmangle directory"
        print "Usage: ./urlmangle.py -O domain:www.example.com"
        print "="*10
    
        
    def process_thread_results(self, status_q, end_of_run_marker):
        """
        process all results from our ThreadRunner2 - this method is automatically called
        by threads, so everything within must be threadsafe!
        """
        done_hosts=0
        self.foundHosts={} #our return value
        while 1:
            tr2_obj, status, data=status_q.get()
            #debug note
            devlog("dnsfind","RESULTS: %r, %r, %r"%(tr2_obj, status, data))
            
            if status == end_of_run_marker:
                ##ALL threads have completed so no more status/results to process
                tr2_obj.join()
                #we are done!
                return 
            
            if status == "newhost":
                #starting to scan a new host
                done_hosts+=1
                self.setProgress((float(done_hosts)/float(self.total_length)) * 100)
                if done_hosts % 10 == 0:
                    self.log("Doing host number %d/%d"%(done_hosts,self.total_length))
                    
            elif status=="success":
                #found a host!
                #data is a tuple of (host, ip)
                host, ip = data
                #self.foundHosts[host] = ip
                                
                #Add all found hosts to our knowledgebase, makes them accessible as targets as
                # well as adding them to the map to see data centre clusters etc
                #self.node.add_host(ip)
                
        #should never be reached, as we always return with an eof marker        
        return 

        
    def scan_non_threaded(self, hostList):
        """
        Takes in a list of hosts and the iterates through them to locate new hosts.
        """
        #
        # Run() run was getting cluttered
        foundHosts = {}
        
        #unfortunately, we can't use a generator easily here unless it supplies us with __len__.
        #which is a shame, because hostList can get quite memory-hungry
        total_length=len(hostList)
        done_hosts=0
        for host in hostList:
            #all long running loops must have this exit condition
            if self.state==self.HALT:
                self.log("Halted")
                return foundHosts
            done_hosts+=1
            self.setProgress((float(done_hosts)/float(total_length)) * 100)
            if done_hosts%10==0:
                self.log("Did %d hosts out of %d"%(done_hosts, total_length))
            try:
                devlog("dnsfind","Looking up %s"%(host+self.domain))
                if self.throttle > 0:
                    time.sleep(float(self.throttle))
                    ip = socket.gethostbyname(host + self.domain)
                else:
                    ip = socket.gethostbyname(host + self.domain)
                self.log("Found host %s at %s"%((host+self.domain), ip))
                foundHosts[(host+self.domain)] = ip
            except socket.gaierror, error:
                devlog("dnsfind", "Error: %s"%error)
        return foundHosts
    
    def miniStats(self, masterDict):
        #
        # Output file was getting cluttered
        ipDict = {} # Track IPs
        locDict = {} # Track Locations
        def compare(x,y):
            if x[1]<y[1]:
                return 1
            elif x[1] == y[1]:
                return 0
            else:
                return -1
        for key in masterDict.keys():
            if masterDict[key].ip not in ipDict.keys():
                if masterDict[key].ip != "No IP found":
                    ipDict[masterDict[key].ip] = 1
            else:
                ipDict[masterDict[key].ip] += 1
            if masterDict[key].location not in locDict.keys():
                if masterDict[key].location != "Unknown" and masterDict[key].location != "&nbsp":
                    locDict[masterDict[key].location] = 1
            else:
                locDict[masterDict[key].location] += 1
                
        ipList = ipDict.items()
        ipList.sort(compare)
        locList = locDict.items()
        locList.sort(compare)
        if len(ipList) < 5:
            temp = 5 - len(ipList)
            for x in xrange(0, temp):
                ipList.append(("&nbsp", "&nbsp"))
        
        if len(locList) < 5:
            temp = 5 - len(locList)
            for x in xrange(0, temp):
                locList.append(("&nbsp", "&nbsp"))
        return ipList, locList
    
    def generateHTMLHeader(self, masterDict):
        #
        # Create the header for our HTML file
        fqdn = self.hostname + "." + self.domain + "." + self.tld
        created = time.asctime(time.localtime())
        canvas = "v6.45"
        header = """
        <html>
                <!-- I come from generateHTMLHeader -->
                <head>
                <link rel="stylesheet" href="../../../../Resources/immunity.css">
                <title>CANVAS URLMangle Report for: %s</title>
                <meta content="text/html; charset=ISO-8859-1"
                http-equiv="content-type">
                <!-- top.html-->
                </head>
                <body  marginheight="0" marginwidth="0" topmargin="0" leftmargin="0">
                <table width=100%% border=0 cellspacing=0 cellpadding=0 bgcolor=#ffffffff>
                <tr>
                    <td width=185 height=67><img src="../../../../Resources/header.gif"></td>
                    <td><center><h1>CANVAS URLMangle Report for: %s</h1></center></td>
                    <td width=185 height=67><img src="../../../../Resources/header.gif"></td>
                </tr>
                <tr>
                    <td>&nbsp</td>
                    <td><center><font size=2>Generated with CANVAS %s on %s</font></center></td>
                    <td>&nbsp</td>
                </tr>
                </table>"""%(fqdn, fqdn, canvas, created)
        
        return header
    
    def generateHTMLStats(self, masterDict):
        #
        # Create the first table for our HTML file
        ipList, locList = self.miniStats(masterDict)
        stats = """
        <body>
        <!-- I come from generateHTMLStats -->
        <center>
        <table width=50% border = 1>
            <tr>
                <th colspan="2">Top IPs</th>
                <th></th>
                <th colspan="2">Top Countries</th>
            </tr>
        """
        temp = ""
        for x in xrange(0, 5):
            temp += """
            <tr>
                <td><center>%s</center></td>
                <td><center>%s</center></td>
                <td><center>&nbsp</center></td>
                <td><center>%s</center></td>
                <td><center>%s</center></td>
            </tr>
            """%(ipList[x][0], ipList[x][1], locList[x][0], locList[x][1])
        stats += temp
        stats += "</table></center>"
    
        return stats
    
    def generateHTMLBody(self, masterDict):
        #
        # Generate the meat of the HTML file
        body = [ """ 
        <!-- I come from generateHTMLBody -->
        <table width=100% border=1>
            <tr>
                <td width=15%><b><center>Domain</center></b></td>
                <td width=10%><b><center>IP Address</center></b></td>
                <td width=5%><b><center>301 Redirect?</center></b></td>
                <td width=15%><b><center>URLs in 301</center></b></td>
                <td width=5%><b><center>Whois</center></b></td>
                <td width=10%><b><center>Location</center></b></td>
                <td width=40%><b><center>Notes</center></b></td>
            </tr>
               """]
        
        for key in masterDict.keys():
            tempUrl = ""
            tempNotes = ""
            tempBody1 = """
            <!-- I am populated in generateHTMLBody -->
            <tr>
                <td><center>%s</center></td>
                <td><center>%s</center></td>
                """%(masterDict[key].fqdn, masterDict[key].ip)
            
            if masterDict[key].b301:
                b301 = "True"
            else:
                b301 = "False"
            tempBody1 +="<td><center>%s</center></td>"%b301
            
            if len(masterDict[key].url301) == 0:
                tempUrl = "&nbsp"
            else:
                for url in masterDict[key].url301:
                    tempUrl += url + "<br>\n" + " "*16                                    
            tempBody2 = """
                <td><center>%s</center></td>
                <td><center><a href="%s">Whois</a></center></td>
                <td><center>%s</center></td>
                """%(tempUrl, masterDict[key].whoisLoc, masterDict[key].location)
            
            if len(masterDict[key].notes) == 0:
                tempNotes = "&nbsp"
            else:
                for note in masterDict[key].notes:
                    tempNotes += note + "<br>\n"
            tempBody3 = """ 
                <td><center>%s</center></td>
            </tr>
            """%tempNotes
            
            body.append(tempBody1 + tempBody2 + tempBody3)

        bodyString = ""
        for x in body:
            bodyString += x
        
        return bodyString
    
    def outputFile(self, masterDict):
        #
        # Create & Populate HTML
        temp = os.path.join("urlmangle", (self.domain + self.genTime))
        self.savePath = self.output(subdir=temp)
        fqdn = self.hostname + "." + self.domain + "." + self.tld
        header = self.generateHTMLHeader(masterDict)
        miniStats = self.generateHTMLStats(masterDict)
        body = self.generateHTMLBody(masterDict)
        spacer = """
        <!-- Hello, I am the spacer variable in outputFile-->
        <p>
        <br>
        <hr>
        <br>
        </p>"""
        footer = """
        <!-- Hello, I'm the footer variable in outputFile -->
        </table>
        </body>
        </html>"""
        
        #
        # Write the file
        fileName = fqdn + "-" + self.genTime +".html"
        saveFile = os.path.join(self.savePath, fileName)
        file = open(saveFile, "w")
        file.write(header + miniStats + spacer + body + footer)
        file.close()
        
        return 0
    
    def sequentialDel(self, masterList):
        #
        # Generates sequenetial deletions ex: google, oogle, gogle, etc
        # Returns an updated masterList
        self.log("Generating sequential deletions")
        for x in xrange(0, len(self.domain)):
            if x == 0:
                temp = self.domain[x+1:len(self.domain)]
            elif x != len(self.domain)-1:
                temp = self.domain[0:x] + self.domain[x+1:len(self.domain)]
            else:
                temp = self.domain[0:-1]
            masterList.append(temp)
        return masterList
    
    def closeKeys(self, unique, masterList):
        #
        # For key 'f' find d,g then replace in the domain string
        # Returns an updated masterList
        self.log("Generating close keys")
        names2 = {}
        keyboard = ["qwertyuiop", "asdfghjkl", "zxcvbnm"]
        
        # For key 'f' add d,g
        for x in unique:
            for letters in keyboard:
                if x in names2.keys():
                    break
                if x in letters:
                    pos = letters.index(x)
                    if pos == 0:
                        names2[x] = [letters[pos+1]]
                    elif pos == len(letters)-1:
                        names2[x] = [letters[pos-1]]
                    else:
                        names2[x] = [letters[pos-1]]
                        names2[x].append(letters[pos+1])

        for x in unique:
            for letter in names2:
                for pos in xrange(0, len(self.domain)):
                    if pos != len(self.domain)-1:
                        if self.domain[pos] == x:
                            temp = self.domain[0:pos]+ letter + self.domain[pos+1:len(self.domain)]
                            masterList.append(temp)
                    else:
                        if self.domain[pos] == x:
                            temp = self.domain[0:-1] + letter
                            masterList.append(temp)
        return masterList
    
    def bookendDomain(self, masterList):
        #
        # Append/prepend 0-9 to the domain, return updated masterList
        # This is simple enough not to be a function but I can see us wanting to add
        # other chars to it, so I called it out
        self.log("Adding bookend characters")
        for x in xrange(0,10):
            masterList.append(str(x)+self.domain)
            masterList.append(self.domain+str(x))
        
        return masterList
    
    def charSubstitutions(self, unique, masterList):
        #
        # Which one of these things looks like the other?
        # Returns updated masterList
        self.log("Generating character substitutions")
        similar = {'1':['i', 'l'], '3':['e'], '5':['s'], '6':['g'], '7':['t'], '8':['B'],
                    '0':['o'], 'q': ['g'], 'e':['c', '3'], 'i':['1', 'l'], 'o':['0'],
                    's':['5'], 'd':['b'], 'g':['6'], 'j':['i'], 'l':['i', '1'],
                    'c':['e'], 'b':['d', '8'], 'n':['m', 'h'], 'm':['n', 'rn']}
        for x in unique:
            if x in similar.keys():
                temp = ""
                for letter in similar[x]:
                    temp = self.domain.replace(x, letter)
                    masterList.append(temp) # 1mmun1ty
                    for pos in xrange(0, len(self.domain)):
                        if pos != len(self.domain)-1:
                            if self.domain[pos] == x:
                                temp = self.domain[0:pos]+ letter + self.domain[pos+1:len(self.domain)]
                                masterList.append(temp) #1mmunity
                        else:
                            if self.domain[pos] == x:
                                temp = self.domain[0:-1] + letter
                                masterList.append(temp) #1mmunity
        return masterList
    
    def makePlurals(self, masterList):
        #
        # Make plurals/deplurals, return masterList 
        self.log("Creating plurals/deplurals")
        masterList.append(self.domain+'s')
        if self.domain[-1].lower() == 's':
            masterList.append(self.domain+'es')
            masterList.append(self.domain[0:-1])
        elif self.domain[-1].lower() == 'y':
            masterList.append(self.domain[0:-1]+'ies')
        if self.domain[len(self.domain)-2:len(self.domain)].lower() != 'es':
            masterList.append(self.domain+'es')
        return masterList
    
    def hyphenManipulate(self, masterList):
        #
        # For a domain containing a - or multiple -'s return all possible combos
        # This gives (2^x)-1 where x = total hyphens in string
        for x in xrange(0, len(self.domain)):
            if self.domain[x] == '-':
                hyphens.append(x)
        masterList.append(self.domain.replace("-", ""))
        for pos in hyphens:
            temp = self.domain[0:pos] + self.domain[pos+1:]
            for x in xrange(0, temp.count("-")):
                masterList.append(temp.replace("-", "", x)) # Props to rich for the 3rd arg
                
        return masterList
    
    def generateMangles(self):
        #
        # Call all the mangle functions, returns uniqued masterList
        
        # Find unique characters for the domain
        uniqueChars = ""
        for char in self.domain:
            if char not in uniqueChars:
                uniqueChars += char
        
        # Make go with the functions
        masterList = []
        masterList = self.sequentialDel(masterList)
        masterList = self.closeKeys(uniqueChars, masterList)
        masterList = self.bookendDomain(masterList)
        masterList = self.charSubstitutions(uniqueChars, masterList)
        masterList = self.makePlurals(masterList)
        if self.domain.find('-') != -1:
            masterList = self.hyphenManipulate(masterList)
        
        # Cull masterList for duplicates, props to Jtown for this
        uniqueDict = {}
        for item in masterList:
            uniqueDict[item] = 1
        
        temp = len(uniqueDict.keys())
        self.log("Found %s unique domains to try"%(temp))
        return uniqueDict.keys()
    
    def doWhois(self, domain):
        #
        # Returns whois info for a domain, returns a list
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.tldDict["."+self.tld], 43))
            s.send(domain + "." + self.tld + "\r\n")
            databuf = ""
            data = "start"
            while data != '':
                data = s.recv(1024)
                databuf += data
            s.close()
            data = databuf.splitlines()
            failed = False
        except:
            failed = True
            data = [""]
        return data, failed
    
    def writeWhois(self, masterDict):
        #
        # Write out our whois files to disk
        self.log("Writing out whois info")
        try:
            for key in masterDict.keys():
                fileName = key + self.tld + ".whois"
                saveFile = os.path.join(self.savePath, fileName)
                masterDict[key].whoisLoc = fileName
                file = open(saveFile, 'w')
                for line in masterDict[key].whois:
                    file.write(line + "\n")
                file.close()
        except:
            self.info(("Unable to write files to %s"%self.savePath))
        return 0
    
    def check301(self, domain):
        #
        # Checks for 301's and their urls
        url301 = []
        notes = []
        domain = self.hostname + "." + domain + "." + self.tld
        try:
            f = httplib.HTTPConnection(domain)
            f.request("GET", "/index.html")
            code = f.getresponse()
            f.close()
        except:
            notes.append("No HTTP Server here")
            url301.append("&nbsp")
            return False, url301, notes
        if code.status == '301':
            b301 = True
        else:
            b301 = False
        if b301:
            data = f.read()
            # Stubblebine's recipe for URL finding regex
            pattern = r'''
            \b ((https?) : [\w/#~:.?+=&%@!\-] +?)
            (?= [.:\-] * (?: [^\w/#~:.?+=&%@!\-] | $))'''
            searchy = re.compile(pattern, re.IGNORECASE + re.VERBOSE)
            urls = searchy.findall(data) # This returns a list of tuples
            if len(urls) > 1:
                for url in urls:
                    url301.append(url[0])
                notes.append("Found multiple URLS for 301 response")
            else:
                url301.append(url)
                notes.append("")
        else:
            url301.append(("Returned HTTP %s"%code.status))
            notes.append("")
        return b301, url301, notes
    
    def openTLD(self):
        #
        # Open and parse the tld.txt file from resources
        file = open(os.path.join(self.engine.config["canvas_resources"], "tld.txt"), 'r')
        data = file.read().splitlines()
        file.close()
        for line in data:
            if line[0] != "#":
                temp = line.split(" ")
                if len(temp) == 2:
                    self.tldDict[temp[0]] = temp[1]
                else:
                    self.tldDict[temp[0]] = None
        return 1
    
    def userFriendly(self):
        #
        # Parse a lot of user input for potential errors
        self.log("Checking input")
        bunkDomains = [".mil", ".gov", ".edu", ".arpa"] # If we find our domain in here, exit
        
        if self.domain == "":
            self.log("Please specify a domain")
            return 0
        
        if float(self.throttle) < 0.00:
            self.log("Throttle is the delay between requests in seconds and must be positive")
            return 0
        
        if self.tld in bunkDomains:
            self.log("Domains in this TLD are strictly controlled, one phishing another is very unlikely.")
            return 0
    
        if len(self.domain) > 40:
            self.log("This module only supports domains at a maximum of 20 characters in length")
            return 0
        
        if self.domain.count("-") >= 10:
            self.log("This module only supports domains with less than 10 hyphens")
            return 0
        
        domainSplit = self.domain.split(".")
        if len(domainSplit) > 4:
            self.log("A domain should have at max 4 dots")
            self.log("e.g. host.domain.stld.tld (test.example.co.uk)")
            return 0
        
        if "."+domainSplit[-1] not in self.tldDict.keys():
            self.log("Supplied TLD not in TLD file, check your domain")
            return 0
        else:
            if not self.parseDomain(domainSplit):
                return 0
        
        charCheck = self.domain.replace(".", "").lower()
        for char in charCheck:
            if char not in string.digits and char not in string.letters:
                self.log(("Invalid character %s found, aborting"%char))
                return 0
            
        if type(self.whois) != bool:
            if self.whois == "True":
                self.whois = True
            elif self.whois == "False":
                self.whois = False
            else:
                self.log("whois must be True or False")
                print self.whois
                return 0 
        
        return 1
    
    def parseDomain(self, domainSplit):
        #
        # Try to parse out the pieces of a domain.
        self.log("Parsing domain name")
        if "."+domainSplit[-2] in self.tldDict.keys():
            # Trying to account for domains like example.co.uk
            # Some corner cases (www.com.com) will bork this
            self.tld = domainSplit[-2] + "." + domainSplit[-1]
            try:
                self.domain = domainSplit[-3]
                if domainSplit[-3] == domainSplit[0]:
                    # We got a domain of example.co.uk, append www
                    self.hostname = "www"
                else:
                    # we got a domain of www.example.co.uk
                    self.hostname = domainSplit[0]
            except:
                self.log("Unable to parse domain %s"%self.domain)
                return 0
        else:
            # We got a standard www.example.com
            self.tld = domainSplit[-1]
            self.domain = domainSplit[-2]
            self.hostname = domainSplit[0]
        return 1
    
    def run(self):
        self.getargs()
        self.openTLD()
        self.genTime = str(int(time.time()))
        if not self.userFriendly():
            self.log("Exiting...")
            return 0
    
        masterDict = {} # {domain : infoClass()}
        #
        # Generate domains, prime the dict
        domainList = self.generateMangles()
        for domain in domainList:
            masterDict[domain] = infoClass()
        
        #
        # Populate Whois
        hostList = []
        count = 0
        failed = 0
        if self.whois and self.tldDict["."+self.tld] != None:
            self.setInfo("%s whois ETA: %d minutes"%(self.name, (len(masterDict.keys())*5/60)))
            self.log("Doing whois lookups for %d domains"%len(masterDict.keys()))
            self.log("whois ETA: %d minutes"%((len(masterDict.keys()) * 5)/60))
            for domain in masterDict.keys():
                failure = False
                temp, failure = self.doWhois(domain)
                if  "No match for" in temp:
                    masterDict[domain].whois  = "No whois"
                    count += 1
                elif failure:
                    self.log("Whois lookup for %s had a network failure"%domain)
                    failed += 1
                else:
                    hostList.append(self.hostname + "." + domain + "." + self.tld)
                    masterDict[domain].whois = temp
                    count += 1
                time.sleep(5) # whois servers have lockouts :(                
                if self.debug:
                    self.log(("Got %d whois, %d failed"%(count, failed)))
                else:
                    if (count+failed)%10 == 0:
                        self.log(("Got %d whois, %d failed"%(count, failed)))
            self.writeWhois(masterDict)
        else:
            for key in masterDict.keys():
                masterDict[key].whois = "No Whois"
                masterDict[key].whois = ""
            if self.whois:
                self.log("No whois server found for that TLD")
                self.log("Edit Resources/tld.txt to add")
            else:
                self.log("Whois turned to off, skipping")
        #
        # Populate IP for domains with a valid whois
        if self.whois == False:
            for key in masterDict.keys():
                hostList.append(self.hostname + "." + key + "." + self.tld)
        
        #
        # Populate fqdns
        for key in masterDict.keys():
            masterDict[key].fqdn = self.hostname + "." + key + "." + self.tld
            
        self.log("Trying to resolve domains")
        self.total_length = len(hostList)
        if not self.do_threaded:
            foundHosts = self.scan(hostList)
        else:
            self.run_threaded_scan(e_module=threadme, targets=hostList)
            foundHosts=self.foundHosts
        for key in foundHosts:
            temp = key.replace(self.hostname, "").replace(self.tld, "").replace(".", "")
            if foundHosts[key] == '':
                masterDict[temp].ip = "No IP found"
            else:
                masterDict[temp].ip = foundHosts[key]
        for key in masterDict.keys():
            if masterDict[key].ip == '':
                masterDict[key].ip = "No IP found"
        #
        # If I found an IP, ship it out for 301 detection
        self.log("Checking for HTTP 301s")
        for key in masterDict.keys():
            if masterDict[key].ip != "No IP found":
                temp = self.hostname + "." + self.domain + "." + self.tld
                masterDict[key].b301, masterDict[key].url301, masterDict[key].notes = self.check301(temp)
                                                                                                    
        
        #
        # Show me the country code
        for key in masterDict.keys():
            if masterDict[key].ip != "No IP found":
                gi = self.getGeoIPlist()
                if gi != None:
                    masterDict[key].location = gi.country_code_by_addr(masterDict[key].ip)
                    if masterDict[key].location == None:
                        masterDict[key].location = "Unknown"
                    if masterDict[key].ip == "127.0.0.1":
                        masterDict[key].location = "Localhost"
        self.outputFile(masterDict)
        self.log("Wrote report to: %s"%self.savePath)
        self.setInfo("%s Done"%self.name)
        self.log("urlmangle done")
        return 1

if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
