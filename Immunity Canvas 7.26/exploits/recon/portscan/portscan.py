#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information
# CANVAS Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path:
    sys.path.append(".")

import socket
import time

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor
import random
from msrpcexploit import allnamedpipes
from libs.newsmb.libsmb import assert_unicode
import timeoutsocket

# GUI info
NAME="Portscanner"
DESCRIPTION="Portscanner"
DOCUMENTATION={}
DOCUMENTATION["Notes"] = "This is a scanrand-like portscanning module\nthat uses a sniffer and raw socket sender\nto do extremely fast portscanning (1000 ports per minute)"
DOCUMENTATION["CLINotes"] = "exploits/portscan/portscan.py -O portlow:1 -O porthigh:200 -t 192.168.103.130"
DOCUMENTATION["Callback"]="Make sure you have the callback set to the right IP! Otherwise the TCP checksum will be incorrect and all the packets will be dropped..."
DOCUMENTATION["Windows"]="For XP, this link is helpful: http://support.microsoft.com/kb/314053"
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

For commandline, you'll want to use -O source:SOURCEIP to avoid bad checksums

"""

CHANGELOG="""
"""

#TCP ports we assume are never going to be MSRPC ports
noifidsports=[21, 22, 25, 53, 80, 25, 110, 111, 143, 443, 465, 515]

SYNSCAN = 1
FINSCAN = 2
XMASSCAN = 3
NULLSCAN = 4

class PortParseException(Exception):
    pass

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done            = 0
        self.port            = 53 #if fromport is 0 we randomize it
        self.closedPorts     = [] # This will be used by the FIN, XMAS and NULL scanners
        self.openports       = []
        self.ifids_did_check = {} #we do O(N) search through this per packet - very bad. Is there any easier way?
        #I guess we could make it a dictionary and do a get.(openport,0)...to investigate later
        self.name            = NAME
        self.covertness      = 0
        self.setVersions()
        self.timeout         = 2
        self.result          = self.openports
        #source              =self.engine.get_callback_interface().ip
        self.source          = "127.0.0.1"
        self.UUID            = None # the interface we're looking for if looking for an MSRPC interface
        self.UUIDfound       = None # the port we found the UUID on
        self.namedpipe       = None #pipe we found our UUID on
        self.scanType        = SYNSCAN
        self.typed_result    = {}
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("TCP Connect Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def opencallback(self,parser):
        openport=parser.attribs["tcpsport"]
        #we don't do this is we already know about that port
        if openport in self.openports:
            return 
        self.openports.append(openport)
        self.log("Found open port %s:%d"%(self.host,openport))
        #devlog('portscan::openports', "Found open port %s:%d" % (self.host, openport))
        #print "Found open port %s:%d" % (self.host, openport)
        #there's never an MSRPC endpoint on 21,25,111, etc so we ignore these for ifids checks
        if (openport not in noifidsports) and self.UUID and not self.ifids_did_check.get(openport,0):
            self.log("Scanning port %d for UUID %s"%(openport,self.UUID))
            self.ifids_did_check[openport]=1
            result=self.ifidscheck(openport)
        return
    
    def finXmasNullCallback(self, parser):
        closedPort = parser.attribs["tcpsport"]
        self.log("Found closed port %s:%d" % (self.host, closedPort))
        self.closedPorts.append(closedPort)
        
    def scanrand(self, allports, scanMode=SYNSCAN):
        # Fast CANVAS SCAN
        #first, we need to register as a callback with the sniffer
        #then we need to scan the ports      
        if self.UUID:
            self.log("Don't do scanrand when looking for UUID")
            return 0
        if not self.engine.sniffer_isactive():
            self.log("sniffer not active")
            self.setInfo("Portscan: sniffer not active - cannot do raw socket mode.")
            return 0
        if self.node.nodetype!="LocalNode":
            self.log("Cannot do a scanrand-style scan from a remote node.")
            #can't do scanrand from remote nodes
            return 0
        # scanrand not supported for IPv6 yet
        if ":" in self.host:
            self.log("[XXX] no IPv6 support for ScanRand yet !")
            return 0
        try:
            mysender=sender(target=self.host)
        except:
            self.log("Failed to open a raw socket...")
            return 0
        if scanMode == SYNSCAN:
            closedfs = "ipsource(%s) tcpflags(RST) tcpflags(ACK)" % self.host
            openfs = "ipsource(%s) tcpflags(SYN) tcpflags(ACK)" % self.host
            self.engine.register_sniffer_callback(self.opencallback, openfs)
        elif scanMode in [FINSCAN, XMASSCAN, NULLSCAN]:
            closedfs = "ipsource(%s) tcpflags(RST) tcpflags(ACK)" % self.host
            
            self.engine.register_sniffer_callback(self.finXmasNullCallback,
                                                  closedfs)        
        top=2
        source=self.source
        self.log("Source IP=%s"%source)
        mpacker=packetConstructor()
        dest=self.host

        for tries in range(1,top):
            self.log("Try %d/%d"%(tries,top-1))
            #have to do retries to make sure things work - well, no we don't
            #but we'll leave the possibility in regardless
            totallength=len(allports)
            current=0
            for port in allports:
                if self.done:
                    self.engine.unregister_sniffer_callback(self.opencallback)
                    return 0
                if self.state==self.HALT:
                    self.log("Ending portscan on port %d"%port)
                    self.setInfo("%s stopped on port %d"%(NAME,port))
                    self.log("Open ports found so far: %s"%self.openports)
                    self.target.replace_knowledge("TCPPORTS",self.openports,100)
                    self.engine.unregister_sniffer_callback(self.opencallback)
                    return 0

                mpacker.clear()
                
                if scanMode == SYNSCAN:
                    mpacker.TCP(source, dest,["SYN"], self.port, port, "")
                elif scanMode == FINSCAN:
                    mpacker.TCP(source,dest, ["FIN"], self.port, port, "")
                elif scanMode == XMASSCAN:
                    mpacker.TCP(source,dest,["PSH", "FIN", "URG"], self.port, 
                                port, "")
                elif scanMode == NULLSCAN:
                    mpacker.TCP(source, dest, [], self.port, port, "")
                    
                mysender.sendto(mpacker.get(), "TCP", (dest,0))
                
                current += 1
                if current % 100 == 0:
                    self.log("%d ports scanned"%current)
                    self.setProgress(((current*1.0)/(totallength*1.0))*100)
                    
                #if you don't sleep, you'll miss some ports. 
                time.sleep(0.01)

        mysender.close() #close all raw sockets for sending
        self.log("Sleeping to recover any lost packets...")
        time.sleep(2)
        
        if scanMode == SYNSCAN:
            self.engine.unregister_sniffer_callback(self.opencallback)
        elif scanMode in [FINSCAN, XMASSCAN, NULLSCAN]:
            self.engine.unregister_sniffer_callback(self.finXmasNullCallback)

        return 1

    def ifidscheck(self,port):
        """
        Looks to see what ifids are available on that port
        saves the results in self.UUIDfound and self.namedpipe
        returns a list of the ifids possible to find on this port
        
        can be called in any of the thousands of threads we start up
        returns False when we did not find it
        """
        if self.done:
            #no need to check this port 
            self.log("Not checking port %d since we're already done"%port)
            return False 
        ifidsscan=self.engine.getModuleExploit("ifids")
        ifidsscan.link(self)
        ifidsscan.port=port
        done=False
        if port in [139, 445]:
            #run a loop
            self.log("Running ifids on all named pipes")
            for pipe in allnamedpipes:
                #can't do this because other threads are setting self.done!
                #if self.done:
                #    self.log("Found our UUID on named pipe %s"%pipe)
                #    return ifidsscan.result
                ifidsscan.namedpipe=pipe
                ifidsscan.run()
                result=ifidsscan.result
                if result and self.UUID:
                    for interface in result:
                        if unicode(interface[2]) == assert_unicode(self.UUID):
                            #we don't check the IFID's version
                            #we found it!
                            self.UUIDfound=port
                            self.namedpipe=pipe
                            self.done=1
                            return result
        else:
            #just run once
            ifidsscan.run()
        result=ifidsscan.result
        
        if result and self.UUID:
            for interface in result:
                if unicode(interface[2]) == assert_unicode(self.UUID):
                    #we don't check the IFID's version
                    self.UUIDfound=port
                    self.done=1
                    return result
                    #we found it!

            self.log("Did not find UUID %s in that ifids list"%self.UUID)
        return False 

    def getargs(self):
        self.host = self.target.interface
        self.timeout = float(self.argsDict.get("timeout", self.timeout))
        self.UUID= self.argsDict.get("UUID",self.UUID)
        #annoyingly, more args below in run()
        return 
        
    def parsePortList(self, portRanges):
        """
        portRanges is  port range specifier which may contain ranges like
        1-1024 or individual port numbers
        
        Returns a list of integer ports
        """
        if type(portRanges) != type('sillyuser'):
            self.log("No custom port range specified, using 1-1024")
            portRanges = '1-1024'
        ranges = portRanges.split(',')
        portList = []
        
        for portRange in ranges:
            if portRange.find('-') != -1:
                tmp = portRange.split('-')
                try:
                    startPort = int(tmp[0])
                    endPort = int(tmp[1])
                except ValueError:
                    self.log("Invalid port range %s" % portRange)
                    self.log("Port ranges must be of the form StartPort-EndPort")
                    
                    raise PortParseException()
                else:
                    portList.extend(range(startPort, endPort + 1))
            else:
                # If there is no dash it should just be a number
                try:
                    port = int(portRange)
                except ValueError:
                    self.log("Invalid port specifier %s" % portRange)
                    self.log("Port specifiers can be ranges of the form \
                    StartPort-EndPort or numeric port values")
                    
                    raise PortParseException()
                else:
                    portList.append(port)
            
        return portList
    
    def run(self):
        allports = startport = endport = None
        self.getargs()
        if self.host in [ "0.0.0.0" ] :
            self.log("Portscan of host %s is insane. Select a target."%self.host)
            return 0 
        if self.UUID:
            self.log("Portscan is looking for UUID %s"%self.UUID)
                    
        scanmode = self.argsDict.get('portrange_mode_value', "Port Range")

        portrange_mode = False 
        customrange_mode = False
        
        self.log("Portscan Scanmode=%s"%scanmode)
        self.port = int(self.argsDict.get("port", self.port))
        
        if scanmode == "Port Range":
            portrange_mode = True
            
            try:
                allports = self.parsePortList(self.argsDict.get('defaultRanges',"1-1000"))
            except PortParseException:
                return 0
            
            self.log("Using a default port range")
        elif scanmode == "Custom Range":
            self.log("Using a custom port range")
            customrange_mode = True
            
            #this is used by ms06_040 and similar exploits based on msrpcexploit.py superclass
            #they pass in a list here of all the ports
            if self.argsDict.get("allports"):
                allports = self.argsDict.get("allports")
                    
            else:
                try:
                    allports = self.parsePortList(
                        self.argsDict.get('customRange',""))
                except PortParseException:
                    return 0
        else:
            self.log("Could not figure out what mode you want to operate in!")
            return 0
                    
        if self.UUID:
            for port in [135, 139, 445]:
                if port not in allports:
                    allports.append(port)
                    
        allports = uniquelist(allports)

        #self.log("Scanning ports %s" % allports)
        
        scanTypeStr = self.argsDict.get('scanType', "SYN")
        if scanTypeStr == "SYN":
            self.scanType = SYNSCAN
        elif scanTypeStr == "FIN":
            self.scanType = FINSCAN
        elif scanTypeStr == "XMAS":
            self.scanType = XMASSCAN
        elif scanTypeStr == "NULL":
            self.scanType = NULLSCAN
        
        self.log("Scan type is %s (code: %d)" % (scanTypeStr, self.scanType))
                 
        postscan_ifids = self.argsDict.get("postscan_ifids", False)
        postscan_http = self.argsDict.get("postscan_http", False)
        
        if postscan_ifids and postscan_http:
            self.postscan = "all"
        elif postscan_ifids:
            self.postscan = "ifids" #ifids for ifidsscan
        elif postscan_http:
            self.postscan = "http"
        else:
            self.postscan = self.argsDict.get("postscan", "")
            
        self.postscan=self.postscan.lower() #lowercase it
        self.source=self.argsDict.get("source",self.engine.get_callback_interface(self.host))
        self.log("Portscan Timeout=%f"%self.timeout)
        self.setInfo("%s scanning %s (in progress)"% (self.name, self.host))
        self.log("%s scanning %s (in progress)"% (self.name, self.host))
        self.log("Postscan=%s"%self.postscan)
        
        self.node=self.argsDict["passednodes"][0]
        if not ":" in self.host: # XXX: ipv6
            self.host=socket.gethostbyname(self.host)
        
        now=time.localtime(time.time())
        strtime=time.strftime("%y/%m/%d %H:%M", now)
        self.log("Start time: %s"%strtime)
        tc0=time.time()

        #check for host unreachable, and if so, don't continue onwards
        self.log("Checking for host unreachable")
        self.ranportscan = self.target.get_knowledge("RanPortscan")
        
        
        # This will allow us to only scan new ports
        portInfo = self.target.get_knowledge("PortsScanned")
        if portInfo is None:
            prevPorts = []
        else:
            prevPorts = portInfo.known

        allports = filter(lambda x: x not in prevPorts, 
                                        allports)
                            
        if len(allports) > 0:
            randomport=random.randint(1,65534)
            ret=self.C_isOpen(self.host, randomport,timeout=self.timeout)
            self.log("Scan of port %s:%s returned %s"%(self.host,randomport,ret))
            if ret=="Host Unreachable":
                self.log("Host %s is unreachable - not port scanning"%self.host)
                self.setInfo("Portscan of %s failed (Host Unreachable)"%self.host)
                return 0
        
        if self.ranportscan and self.UUID:
            self.log("Looking for our UUID on all known open ports")
            ports = self.target.get_knowledge("TCPPORTS")
            if not ports:
                ports = []
            for port in ports:
                port = int(port)
                result = self.ifidscheck(port)
                if result:
                    self.log("Found the ifid on port %d" % port)
                    return 1
                
            self.log("Did not find the IFID we were looking for")
            
            return 0 

        if len(allports) > 0:
            ret=self.scanrand(allports, self.scanType)
            if ret:
                self.log("Sleeping for 2 seconds to recover packets")
                time.sleep(2)
            
            # The SYN scanner builds the open port list in its callback
            if self.scanType in [XMASSCAN, FINSCAN, NULLSCAN]:
                self.openports = filter(lambda x: x not in self.closedPorts, 
                                        allports)
                # With these scans we can differentiate open from filtered
                # so chances are if all ports are 'open' then they're actually
                # filtered. It might be an idea to give the user a say in how 
                # this case is dealth with
                if len(self.openports) == len(allports):
                    self.openports = []
                
        if self.done:
            #normally we would return 0... but if we have a UUID and a UUIDfound, then we're good to go
            if self.UUID and self.UUIDfound:
                return 1
            return 0
        
        if len(allports) > 0 and ret == 0 :
            #scanrand failed....do TCP scan
            self.setInfo("Portscan: Doing TCP Connect Scan")
            self.log("Doing TCP connect scan")
            self.log("Node capabilities: %s" % self.node.capabilities)
            
            totallength = len(allports)
            current = 0
            for port in allports:
                #run our connect-scan against the target
                if self.UUID and self.UUIDfound:
                    return 1
                if self.done:
                    return 0
                if self.getState()==self.HALT:
                    self.log("Ending portscan on port %d"%port)
                    self.setInfo("%s stopped on port %d"%(NAME,port))
                    self.log("Open ports found so far: %s"%self.openports)
                    self.target.replace_knowledge("TCPPORTS",self.openports,100)
                    return 0
                
                self.setProgress(((current*1.0)/(totallength*1.0))*100)
                current+=1
                
                # C_isOpen uses gettcpsock and so should work on remote nodes
                isopen=self.C_isOpen(self.host, port, timeout=self.timeout)
                if isopen=="Open":
                    self.log("TCP Handshake found %d open"%port)
                    self.openports.append(port)
                    if self.UUID and (port not in noifidsports):
                        result=self.ifidscheck(port)
                if isopen=="Host Unreachable":
                    self.log("Host %s unreachable"%self.host)
                    self.log("Stopping scan...")
                    break
                    
        now=time.localtime(time.time())
        strtime=time.strftime("%y/%m/%d %H:%M", now)
        self.log("Stop time: %s"%strtime)

        tc1=time.time()
        self.log("Seconds used: %s"%(tc1-tc0))
        self.openports=uniquelist(self.openports)
        #print "Closed: %s"%self.closedports
        self.openports.sort() # Make this look a bit better
        self.log("Open ports found on %s: %s"%(self.host,self.openports))
        self.log("All done")            
        self.openports=uniquelist(self.openports)
        self.target.replace_knowledge("TCPPORTS",self.openports,100)
        
        self.target.add_knowledge("RanPortscan", True, 100)        
            
        prevPorts.extend(allports)
        portsScanned = uniquelist(prevPorts)
        
        self.target.replace_knowledge("PortsScanned", portsScanned, 100)
        
        #self.log("Full list of scanned ports on target : %s" % 
        #         self.target.get_knowledge("PortsScanned").known)
        
        self.log("postscan=%s"%self.postscan)
        self.setInfo("%s scanning %s (Postscan: %s)"% (self.name, self.host,self.postscan))
        postscan=self.postscan
        doneports=[]

        if self.UUID:
            self.log("Not doing postscan %s because we are looking for a single UUID"%postscan)
        else:
            if postscan not in ["None",None,""]:
                self.log("Doing %s scan"%postscan)
                for port in self.openports:
                    if self.done:
                        return 0
                    port=int(port)
                    self.log("Postscan %s:%d"%(postscan,port))
                    if (port not in noifidsports) and (postscan_ifids or postscan in ["ifids","all"]):
                        result=self.ifidscheck(port)
                        if result:
                            doneports.append(port)
                            continue #no need to further check this - it's MSRPC
                    #we only get here if it's not MSRPC
                    if postscan_http or postscan in ["http","all"]:
                        httpscan=self.engine.getModuleExploit("httpfingerprint")
                        httpscan.link(self)
                        httpscan.port=port
                        self.log("Running httpscan")
                        httpscan.run()
                        if httpscan.result!=None:
                            doneports.append(port)
                            continue
        
        self.setInfo("%s scanning %s (done)"% (self.name, self.host))
        
        if self.openports:
            self.typed_result['ports'] = self.openports
            self.log("Portscanner finished with open ports: %s"%self.openports)
            return 1
        
        return 0
    
    def shutdown(self):
        self.done=1
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])
    
    def usage(self):
        import sys
        print "Usage: %s -t <host> -C <covertness> [ -O options:value ... ]\n" % sys.argv[0]
        print "   options:"
        print "        mode:               allports/portrange"
        print "        timeout:            time to sleep between each packet sent in second"
        print "        portlow,porthigh:   port range (imply mode:portrange)"
        print "        postscan:           ifids,http,all"
        print "        source:             ip source"

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
