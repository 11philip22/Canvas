#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
ifids.py

dumps the data from the dce-rpc portmapper and returns the results
"""

import sys

if "." not in sys.path:
    sys.path.append(".")

import os
import canvasengine
import uuid
import libs.newsmb.libdcerpc as libdcerpc
from msrpcexploit import msrpcexploit
from exploitutils import *

NAME = "ifids"
DOCUMENTATION = {}
DOCUMENTATION["Notes"] = ["If a port or named pipe is running DCE-RPC, then you can send a query to it asking it which endpoints it supports. This tool sends that query and returns the results. It also will brute force an endpoint that appears to be a DCE-RPC endpoint, but does not respond directly to the query by trying to bind to a list of interfaces. This list is stored in a text file in the CANVAS Resources directory"]
DOCUMENTATION["XP Note"] = "On XP SP2, ifids will fail on port 135, etc. This is due to changes in the operating system, not a failure of the module"
DESCRIPTION = "DCE Interface ID's Query Tool"
VERSION = "1.0"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"
NOTES = """

"""
CHANGELOG = """

"""

# Usage from another exploit:
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getEndpointbyUUID(self.UUID)
#
# For an protocol specific endpoint (You can, brute force if the UUID is not found with dcedump)
#
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getHTTPEndpoint()


class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.setPort(135)
        self.setHost("")
        self.name             = NAME
        self.version          = 0
        #MGMT UUID
        self.UUID             = u"afa8bd80-7d8a-11c9-bef4-08002b102989"
        self.uuidversion      = u"1.0"
        self.targetfunction   = 0
        self.response         = True
        self.needsNoShellcode = 1 #We don't need shellcode here
        self.autoversion      = 1
        self.namedpipe        = "\\browser"
        self.loadDocumentationFile()
        self.sleeptime        = 0
        self.ccache_file      = None
        self.use_kerberos     = False

    def neededListenerTypes(self):
        return []

    def testOS(self):
        self.log("Autoversioning, based on port")
        if self.port in [139, 445]:
            self.version = 2  #Named pipe
        else:
            #TCP
            self.version = 1
        return 1

    def buildConnectionList(self):
        self.namedpipe = self.argsDict.get("namedpipe", self.namedpipe)
        host = self.host

        self.target.add_to_knowledge("ifids", [])
        #initialize this if necessary
        #otherwise it continues to try ifids over and over on a port 22
        #if no other ifid port is available

        #print "type: %s value: %s"%(type(self.port),self.port)

        if self.version == 0:
            self.log("Autodetect (based on port)")
            self.testOS()

        self.log("Version: %s" % self.version)

        if self.version==1:
            #TCP
            connectionList = ["ncacn_ip_tcp:%s[%d]" % (host, self.port)]
        elif self.version==2:
            #named pipe
            connectionList = ["ncacn_np:%s[%s]" % (host, self.namedpipe)]
        elif self.version==3:
            #http
            connectionList = ["ncacn_http:%s[%d]" % (host, self.port)]

        self.connectionList = connectionList
        self.log("Connectionlist: %s" % connectionList)
        return self.connectionList

    def parseException(self, msg):
        self.log("Parsing exception: %s" % msg)
        foundlist=[]

        if msg.count("1c010014") and self.version == 1:
            #msrpc server too busy and we are tcp
            self.log("MSRPC reported server too busy...trying all known endpoints")
            print "Self.ifidsdata: %s" % self.ifidsdata
            auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
            auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
            frag_level = None

            if self.covertness >= 5 and self.covertness < 11:
                frag_level = 1
            elif self.covertness == 11:
                frag_level = 2

            for interface in self.ifidsdata.keys():
                self.log("Trying interface: %s" % interface)
                documentation=self.ifidsdata.get(interface, "")
                for versionmajor in range(0, 3):
                    for versionminor in range(0, 3):
                        version="%s.%s" % (versionmajor, versionminor)
                        binding = "ncacn_ip_tcp:%s[%d]" % (self.host, self.port)
                        myDCE = None
                        try:

                            # Sanity check: the ccache credentials
                            if self.ccache_file:
                                if not self.check_ccache_file():
                                    self.log_error('%s::%s doesn\'t seem to be a valid ccache file for user %s' % (target.interface, self.ccache_file, '@'.join([self.user,self.domain])))
                                    return 0
                                else:
                                    self.use_kerberos = True
                                    self.log_info("%s::Using kerberos authentication with credentials %s" % (target.interface, self.ccache_file))
                            else:
                                self.log_info("%s::Using NTLM authentication" % target.interface)

                            if self.use_kerberos:
                                myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, domain=self.domain, kerberos_db=self.ccache_file, use_krb5=True, frag_level=frag_level)
                            else:
                                myDCE = libdcerpc.DCERPC(binding, getsock=self, username=self.user, password=self.password, domain=self.domain, frag_level=frag_level)

                            res = myDCE.bind(interface, version, auth_type=auth_type, auth_level=auth_level)
                            if res:
                                self.log("Found: %s v%s %s" % (interface, version, documentation))
                                value=[(self.port, [binding], interface, version)]
                                foundlist += value
                                self.target.add_to_knowledge("ifids", value)
                                break
                        except Exception, msg:
                            pass

        self.result = foundlist
        if self.result != []:
            self.log("Found interfaces on %s:%d" % (self.host, self.port))
            for item in self.result:
                interface = item[2]
                version = item[3]
                self.log("%s %s %s" % (interface, version,
                                       self.ifidsdata[interface]))
            return 1
        return 0

    def loadDocumentationFile(self, filename=None):
        "Load IFIDS data from our little file"
        if not filename:
            filename = "ifids.txt"

        #load from resources directory
        filename = os.path.join(canvasengine.canvas_resources_directory,
                                filename)
        fd = file(filename, "r")
        data = fd.readlines()

        self.ifidsdata = {}
        for line in data:
            if line[0] == "#":
                continue

            linelist=line.split(" ")
            self.ifidsdata[linelist[0]] = " ".join(linelist[1:]).strip()
        return

    def parseResponse(self, pkt):
        """Parse DCERPC response buffer.

        Adds any ifids found to our ifids knowledge on that host.
        pkt is really a list of DCE responses.
        """
        if pkt == "":
            self.log("No response found!")
            return 0

        buf = pkt
        self.result = []
        _, buf = getint(buf) # ignored
        nument, buf = getint(buf)
        _, buf = getint(buf)
        buf = buf[4*nument:] # skip over this number of pointers in the array

        self.log("Number of entities in the array=%d" % nument)
        self.log("Using connectionList: %s" % self.connectionList)

        for _ in range(0, nument):
            u, buf = uuid.UUID(bytes_le=buf[:16]), buf[16:]
            versionmajor, buf = getshort(buf)
            versionminor, buf = getshort(buf)
            version = "%s.%s" % (versionmajor, versionminor)
            documentation = self.ifidsdata.get(uuid, "")
            self.log("%s v%s %s" % (u, version, documentation))
            value = [(self.port, self.connectionList, u, version)]
            self.result += value
            self.target.add_to_knowledge("ifids", value)

        self.success = 1
        return 1

if __name__ == '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)