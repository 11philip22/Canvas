#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
import select
import random
import canvasengine
from exploitutils import *

import time
import struct
import thread
import threading

##Static data
#TODO: Move to libs because will not get distro'd
from libs.x11_blobs import *
from ExploitTypes.localcommand import LocalCommand

NAME="X11 Server"
DESCRIPTION="X11 server for local vulnerabilities"
DOCUMENTATION={}
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Servers"

#SOME GLOBAL CONSTANTS
##Packet type
REPLY                         = 1
ERROR                         = 0
EVENT                         = 2 #anything > 1

# Check out http://www.rahul.net/kenton/xproto/xrequests.html/Wireshark for 
# opcode to name mappings. If a client is failing to process some of the
# responses from this server a good place to start looking for issues is 
# probably the opcodes marked as 'Not fully implemented'. For these opcodes 
# we have a syntacticaly correct responses but the data served back isn't
# related to what the client asked for and is probably just a byte sequence
# sniffed from a valid Xvfb interaction for that opcode.

##X11 Opcodes that we know how to do something about
OPCODE_CreateWindow           = 0x01
OPCODE_ChangeWindowAttributes = 0x02
OPCODE_MapWindow              = 0x08
OPCODE_MapSubwindows          = 0x09
OPCODE_UnmapWindow            = 0xa
OPCODE_ConfigureWindow        = 0x0c
OPCODE_GetGeometry           = 0x0e
OPCODE_InternAtom             = 0x10
OPCODE_ChangeProperty         = 0x12
OPCODE_DeleteProperty         = 0x13
OPCODE_GetProperty            = 0x14
OPCODE_GetSelectionOwner      = 0x17
OPCODE_ConvertSelection       = 0x18
OPCODE_GrabServer             = 0x24
OPCODE_UngrabServer           = 0x25
OPCODE_GetInputFocus          = 0x2b
OPCODE_OpenFont               = 0x2d
OPCODE_QueryFont              = 0x2f
OPCODE_GrabKey                = 0x21 # This needs investigation. Does it need a response?
OPCODE_CreatePixmap           = 0x35
OPCODE_FreePixmap             = 0x36
OPCODE_CreateGC               = 0x37
OPCODE_ChangeGC               = 0x38
OPCODE_FreeGC                 = 0x3c
OPCODE_ClearArea              = 0x3d
OPCODE_CopyArea               = 0x3e # Not sure if this requires a response 
OPCODE_PolySegment            = 0x42
OPCODE_PolyFillRectangle      = 0x46
OPCODE_PutImage               = 0x48
OPCODE_PolyText8              = 0x4a
OPCODE_AllocColor             = 0x54 # Not fully implemented
OPCODE_QueryColors            = 0x5b # Not fully implemented
OPCODE_LookupColor            = 0x5c 
OPCODE_CreateCursor           = 0x5d
OPCODE_CreateCursorGlyph      = 0x5e
OPCODE_QueryBestSize          = 0x61
OPCODE_QueryExtension         = 0x62
OPCODE_GetKeyboardMapping     = 0x65
OPCODE_SetCloseDownMode       = 0x70 # Not sure if this requires a response
OPCODE_GetPointerMapping      = 0x75 # Not fully implemented
OPCODE_GetModifierMapping     = 0x77

# These opcodes are queried for by the client and we respond with a mapping
# of extension name to opcode. Not sure if they can be any arbitrary number
# but these have been seen in xvfb interactions
EXTENSION_BIG_REQUESTS       = 0x85
EXTENSION_XKEYBOARD          = 0x8a

##Subset of Opcodes that we don't need to give a response to,
## just increment the sequence ID
NO_REPLY_NEEDED = [OPCODE_FreeGC, OPCODE_CreatePixmap, OPCODE_UnmapWindow,
                   OPCODE_PutImage,OPCODE_CreateCursorGlyph, OPCODE_PolyText8,
                   OPCODE_OpenFont, OPCODE_ClearArea, OPCODE_FreePixmap,
                   OPCODE_ConvertSelection, OPCODE_ChangeWindowAttributes,
                   OPCODE_PolySegment, OPCODE_PolyFillRectangle, 
                   OPCODE_SetCloseDownMode, OPCODE_ChangeGC, OPCODE_GrabServer, 
                   OPCODE_UngrabServer, OPCODE_GrabKey, OPCODE_CreateCursor,                   
                   ]

ATOMS = {
    # Standard X atoms from XAtom.h
    # http://cgit.freedesktop.org/xorg/proto/xproto/tag/?id=xproto-7.0.16
    'PRIMARY' : 1, 'WM_NORMAL_HINTS' : 40, 'SECONDARY' : 2, 
    'WM_SIZE_HINTS' : 41, 'ARC' : 3, 'WM_ZOOM_HINTS' : 42, 'ATOM' : 4, 
    'MIN_SPACE' : 43, 'BITMAP' : 5, 'NORM_SPACE' : 44, 'CARDINAL' : 6, 
    'MAX_SPACE' : 45, 'COLORMAP' : 7, 'END_SPACE' : 46, 'CURSOR' : 8, 
    'SUPERSCRIPT_X' : 47, 'CUT_BUFFER0' : 9, 'SUPERSCRIPT_Y' : 48, 
    'CUT_BUFFER1' : 10, 'SUBSCRIPT_X' : 49, 'CUT_BUFFER2' : 11, 
    'SUBSCRIPT_Y' : 50, 'CUT_BUFFER3' : 12, 'UNDERLINE_POSITION' : 51, 
    'CUT_BUFFER4' : 13, 'UNDERLINE_THICKNESS' : 52, 'CUT_BUFFER5' : 14, 
    'STRIKEOUT_ASCENT' : 53, 'CUT_BUFFER6' : 15, 'STRIKEOUT_DESCENT' : 54,
    'CUT_BUFFER7' : 16, 'ITALIC_ANGLE' : 55, 'DRAWABLE' : 17, 
    'X_HEIGHT' : 56, 'FONT' : 18, 'QUAD_WIDTH' : 57, 'INTEGER' : 19, 
    'WEIGHT' : 58, 'PIXMAP' : 20, 'POINT_SIZE' : 59, 'POINT' : 21, 
    'RESOLUTION' : 60, 'RECTANGLE' : 22, 'COPYRIGHT' : 61, 
    'RESOURCE_MANAGER' : 23, 'NOTICE' : 62, 'RGB_COLOR_MAP' : 24, 
    'FONT_NAME' : 63, 'RGB_BEST_MAP' : 25, 'FAMILY_NAME' : 64, 
    'RGB_BLUE_MAP' : 26, 'FULL_NAME' : 65, 'RGB_DEFAULT_MAP' : 27, 
    'CAP_HEIGHT' : 66, 'RGB_GRAY_MAP' : 28, 'WM_CLASS' : 67, 
    'RGB_GREEN_MAP' : 29, 'WM_TRANSIENT_FOR' : 68, 'RGB_RED_MAP' : 30, 
    'STRING' : 31, 'VISUALID' : 32, 'WINDOW' : 33, 'WM_COMMAND' : 34, 
    'WM_HINTS' : 35, 'WM_CLIENT_MACHINE' : 36, 'WM_ICON_NAME' : 37, 
    'WM_ICON_SIZE' : 38, 'WM_NAME' : 39,
    
    # Non standard atoms encountered during client interactions with Xvfb
    'PIXEL_SIZE' : 190, 'RESOLUTION_Y' : 192, 'AVERAGE_WIDTH' : 194, 
    
    'COMPOSE' : 220, 'CUSTOM INIT' : 221, 'CUSTOM DATA' : 222, 
    '_MOTIF_DRAG_WINDOW' : 223, '_MOTIF_BINDINGS' : 224, 
    '_MOTIF_DEFAULT_BINDINGS' : 225, 'CUSTOMIZE DATA:0' : 226, 
    'WM_LOCALE_NAME' : 227, 'WM_CLIENT_LEADER' : 228, 
    '_MOTIF_WM_INFO' : 229, '_MOTIF_WM_OFFSET' : 230, 
    '_MOTIF_WM_MESSAGES' : 231, 'WM_DELETE_WINDOW' : 232, 
    'WM_PROTOCOLS' : 233, 'WM_SAVE_YOURSELF' : 234, 
    '_MOTIF_DRAG_ATOMS' : 235, '_MOTIF_ATOM_0' : 236, 
    '_MOTIF_DRAG_TARGETS' : 237, '_MOTIF_DRAG_RECEIVER_INFO' : 238,
    'TT_SESSION' : 239, '_SUN_TT_SESSION' : 240,

    # Non standard atoms that were reported as not being available by Xvfb
    'SCREEN RESOURCES' : 0, 'PIXEL SETS' : 0, 
    'XDCCC_LINEAR_RGB_CORRECTION' : 0, 'XDCC_LINEAR_RGB_MATRICES' : 0
    }

#END GLOBAL CONSTANTS

ENDIAN = "<"

def pad_to_32(buffer):
    """
    Pads our buffer to 32 bytes - most replies use this.
    """
    padlen=32-len(buffer)%32
    if padlen!=0:
        buffer=buffer+"\xcc"*padlen
    return buffer 

def Card32(ENDIAN, value):
    """
    A long integer by any other name smells as sweet.
    """
    return struct.pack(ENDIAN+"L",value)

def Card8(value):
    "A byte value"
    return struct.pack("B",value)
 
class PropertyStore:
    """
    This is a simple class to map properties (identified by the keys of the
    ATOMS map) to the values they are assiged during an interaction with a 
    client. These properties are per window therefore each window requires its
    own PropertyStore object (as far as I can tell). I'm using a new class 
    instead of a simple dict in case things get more complicated down the road.
    """
    
    def __init__(self, init_defaults=True):        
        self.properties = {}
        if init_defaults:
            self.init_default_properties()
            
    def init_default_properties(self):
        """
        For certain properties the clients don't set a default value and then
        make repeated blocking requests for that value at a later stage. To 
        avoid this delay set some default values here.
        """
        
        self.properties[ATOMS['TT_SESSION']] = (0x41, 0x42, 0x43, 0x44)
        self.properties[ATOMS['_SUN_TT_SESSION']] = (0x41, 0x42, 0x43, 0x44)
    
    def __str__(self):
        return str(self.properties)
        
    def get_property(self, atom_id):
        if atom_id in self.properties:
            return self.properties[atom_id]
        
        return None
    
    def set_property(self, atom_id, new_val):
        """
        new_val should be a tuple of ints (0-255). Don't fuck it up and hand in 
        something else :P
        """
        self.properties[atom_id] = new_val
        
    def delete_property(self, atom):
        if atom in self.properties:
            del self.properties[atom]

class XWindow:
        
    # Event mask flags
    EVT_EXPOSURE = 2**15
    
    def __init__(self, window_id, x, y, width, height, border_width, event_mask):
        """
        Created due to a call to CreateWindow
        """
        
        self.window_id = window_id
        self.properties = PropertyStore()
        self.above_sibling = 0x0            
        self.border_width = border_width
        self.x = x
        self.y = y
        self.height = height
        self.width = width
        self.event_mask = event_mask
        
class XWindowGC:
    
    def __init__(self, window_id):
        """
        Created due to a call to CreateGC
        """
    
        self.window_id = window_id
        self.properties = PropertyStore()
                
class theexploit(LocalCommand):
    def __init__(self):    
        LocalCommand.__init__(self)

        ##What DISPLAY are we listning on - :0 will normally be taken
        self.port              = 6000
        self.screen            = ":1"
        ##IP to listen on
        self.bind_ip           = "0.0.0.0"
        self.fds               = {}
        self.listen_socks      = []
        self.data_stub_to_recv = 0
        
        # OPCODE_AllocColor and OPCODE_QueryColors be needing this. It stores
        # RGB values requested by AllocColor requests and sends the index at 
        # which they are stored back to the client. This index will then be sent
        # in QueryColor requests. Obviously this can result in multiple mappings
        # for the same RGB set but it'll do for now.
        self.color_map = []             
        
        # Map names to RGB values for OPCODE_LookupColor. No idea why they're 
        # two bytes in size
        self.color_name_map = {
            'white'  : (0xffff, 0xffff, 0xffff),
            'black'  : (0x0, 0x0, 0x0),
            'yellow' : (0xffff, 0xffff, 0x0),
            }
        
        # Some magic values embeddedin XKEYBOARD extension requests
        self.keyboard_magic_one = 0xec9e0100
        self.keyboard_magic_two = 0x028cea50
        self.x_windows = {} 
    
    def STRING8(self, ENDIAN, data):
        """
        LISTofCARD8 - second 16 bits are unused.
        """
        #second 16 bits are unused
        size, _ = struct.unpack(ENDIAN+"HH",data[:4])
        ret=data[4:4+size] #read the actual string (no null terminator)
        return ret, data[4+size:]
    
    def LONG(self, ENDIAN, data):
        """
        32 bit data
        """
        ret=struct.unpack(ENDIAN+"L",data[:4])
        data=data[4:]
        return ret, data 
    
    def do_handshake(self, infd):
        """
        First X11 handshake
        """
        
        try:
            data=infd.recv(12)
        except:
            self.log("Did not get initial request from X client")
            return False 
        if len(data)!=12:
            self.log("Did not get 12 bytes for initial handshake!")
            return False 
        ##big ENDIAN or little ENDIAN
        if data[0]=="\x6c":
            ##little
            endian="<"
        else:
            ##big
            endian=">"
        self.fds[infd]["endian"]=endian
        self.fds[infd]["sequence"]=1
        fmt=ENDIAN+"BBHHHHH"
        
        byte_order, _, protocol_major, protocol_minor, auth_protocol_name_length, auth_protocol_data_length, _ = struct.unpack(fmt, data)
        #XXX: do something about auth here
        #XXX: Solaris's client xlib doesn't bother with them, but we will need them eventually
        
        ##ok, now do reply
        success = 1
        ##release number, resource-id-base, resource-id-mask, length of vendor, max request size, screen number, pixmap formats, image byte order, bitmap format order, bitmap scanline unit, bitmap scanline pad, min key, max key, 0x349e1f08, 
        motion_buffer_size=256
        vendor="The X.Org Foundation"
        fmt=ENDIAN+"LLLLHHBBBBBBBBL"
        data_to_pack=(10503000, 0x03e00000, 0x1fffff, motion_buffer_size, 
                      len(vendor), 0xffff, 1, 7, 0, 0, 32, 32,  8 , 255, 
                      0x349e1f08)
        body=struct.pack(fmt, *data_to_pack)
        body+=vendor 
        
        ##blob from real server
        if ENDIAN == "<":
            ##little
            body+=binstring(le_init_string)
        else:
            ##big
            body+=binstring(be_init_string)
                        
        ##replylength is a DWORD COUNT (i.e. bytes*4) of data to follow
        replylength = len(body)/4
        data_to_pack=(success,0,protocol_major, protocol_minor,replylength)
        fmt=ENDIAN+"BBHHH"
        packet=struct.pack(fmt,*data_to_pack)
        #self.log("fmt=%s data=%s"%(fmt,prettyprint(packet)))
        packet+=body
        self.log("Sending handshake reply of length %s"%len(packet))
        infd.sendall(packet)
        self.log("Sent X server handshake reply")
        return True 
    
    def do_null_reply(self, infd):
        """
        Send back a reply that has no data in it
        """
        endian=self.fds[infd]["endian"]
        fmt=endian+"BBHL"
        reply_length=0 #in dwords
        ##reply, pad, sequence_number, reply_length
        sequence_number=self.fds[infd]["sequence"]
        self.fds[infd]["sequence"]+=1
        reply_length=0
        data_to_pack=(REPLY,0,sequence_number,reply_length)
        packet=struct.pack(fmt, *data_to_pack)
        packet=pad_to_32(packet)
        infd.sendall(packet)
        return 
    
    def extract_data(self, data, start, end, fmt):        
        tmp = struct.unpack(ENDIAN + fmt, data[start:end])        
        if len(tmp) == 1:
            val = tmp[0]
        else:
            self.log("Error extracting bytes %d to %d from data [%s] using "
                     "format [%s]" % (start, end, repr(data), fmt))
            return None
        return val

    # Hardcoding long/short lengths will eventually cause us great pain.
    def extract_long(self, data, start):
        return self.extract_data(data, start, start + 4, "L")
    
    def extract_short(self, data, start):
        return self.extract_data(data, start, start + 2, "H")
    
    def do_packet(self, infd):
        """
        Reads from the remote X client and handles it
        """
        
        try:
            data=infd.recv(4)                       
        except Exception, msg:
            self.log("Error while reading data in X server's do_packet(): %s" % msg)
            return False
        
        if len(data) == 0:
            self.log("Peer %s has closed the connection "
                     "(recv returned an empty string)" % str(infd.getpeername()))            
            return False
        
        if self.data_stub_to_recv > 0:
            while 1:
                try:
                    self.data_stub += infd.recv(4)
                    self.data_stub_to_recv -= 4
                except socket.error:
                    return True
                opcode_major = self.data_stub_opcode_major
                opcode_minor = self.data_stube_opcode_minor
                data = self.data_stub
                self.log("Finished recv'ing data for stub")
                self.log("Opcode major : 0x%x, opcode_minor 0x%x, len(data) : %d" % \
                         (opcode_major, opcode_minor, len(data)))
        else:                        
            ENDIAN=self.fds[infd]["endian"]
            fmt="BBH"
            
            try:           
                opcode_major, opcode_minor, request_length= struct.unpack(ENDIAN+fmt,data)
            except struct.error, err:
                self.log("Could not unpack received data to expected format ? '%s'"%(err))                        
                return False    
            
            self.log("0x%x, 0x%x, %d" % (opcode_major, opcode_minor, request_length))
            ##request_length is in DWORDS and includes our header
            recv_len = request_length
            recv_len -= 1 #for the header, which is 4 bytes
            self.log("Recv len is %d" % recv_len)
            to_recv = recv_len * 4
            self.log("to_recv %d" % to_recv)
            if recv_len > 0:
                try:                    
                    data = ""                
                    while to_recv > 0:                    
                        data += infd.recv(to_recv)                          
                        to_recv = recv_len * 4 - len(data) 
                        self.log("to_recv %d" % to_recv)
                except socket.error:
                    self.log("Exception while recving data in do_packet()")
                    data=""
            else:
                data = ""            
            
            self.log("to_recv %d" % to_recv)
            if len(data) != recv_len*4:
                self.log("Did not get entire request")            
                self.log("Got %d bytes out of %d" % (len(data), recv_len * 4))
                self.log("Setting data_stub_to_recv to %d " % to_recv)
                self.data_stub = data
                self.data_stub_to_recv = to_recv
                self.data_stub_opcode_major = opcode_major
                self.data_stube_opcode_minor = opcode_minor
                return True
        
        self.log("Got opcode %x:%x"%(opcode_major, opcode_minor))
        self.log("Got data: %s"%prettyprint(data))        

        # This bool is just used to decide what log message to show at the end
        reply_needed = True
        
        if opcode_major == OPCODE_MapSubwindows:
            self.log("Got MapSubwindows")
                                
            event_code = 0x13
            unused = 0x0
            override_redirect = 0x0
            
            # In real client interactions the window ID specified by the client
            # is off by one (+ or -) from the reply. Not sure why this is and
            # this opcode isn't documented very well.
            window = self.extract_long(data, 0)            
            if window is None:
                return False
                            
            event_window = window 
            
            #format and send reply            
            fmt=ENDIAN+"2BH2LB"      
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(event_code, unused, sequence_number, event_window, 
                          window, override_redirect)
                 
            packet=struct.pack(fmt, *data_to_pack)                                            
            packet=pad_to_32(packet)
            infd.sendall(packet)                
        elif opcode_major == OPCODE_MapWindow:
            self.log("Got MapWindow")
                                
            event_code = 0x13
            unused = 0x0
            override_redirect = 0x0
            
            # In real client interactions the window ID specified by the client
            # is off by one (+ or -) from the reply. Not sure why this is and
            # this opcode isn't documented very well.
            window = self.extract_long(data, 0)            
            if window is None:
                return False
                            
            event_window = window 
            
            #format and send reply            
            fmt=ENDIAN+"2BH2LB"      
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(event_code, unused, sequence_number, event_window, 
                          window, override_redirect)
                 
            packet=struct.pack(fmt, *data_to_pack)                                            
            packet=pad_to_32(packet)
            infd.sendall(packet)                
            
            # I've commented out the following jazz because I don't really 
            # know when we should send back an EXPOSE event. They get triggered
            # on some MapWindow calls but not others and not for all windows.
            # Apparently whether a client should get sent such an event for a 
            # given window depends on the flags set when the window is created
            # but I've no idea what flag/combination of flags are actually 
            # taken into account. I presumed the EXPOSURE flag but empirically
            # some windows that set this on creation don't get EXPOSE events.
            # It probably has to do with the relationship between the window ID
            # passed to MapWindow and it's child windows.
            
            # Send expose events for every window with the Exposure event
            # flag set. We only do this for XWindow classes, not XWindowGC            
            #f = lambda x : isinstance(x[1], XWindow)
            #for window_id, x_window in filter(f, self.x_windows.items()):
                #if x_window.event_mask & XWindow.EVT_EXPOSURE:
                    #self.log("Sending EXPOSE event for window 0x%x" % 
                             #x_window.window_id)
                    ##format and send reply
                    #fmt=ENDIAN+"BBHL5H"
                    ## For an explanation of the count variable see this:
                    ## http://tronche.com/gui/x/xlib/events/exposure/expose.html
                    ## Hopefully we can get by simply by setting it to 0
                    #count = unused = 0
                    #event_code = 0xc
                    #data_to_pack=(event_code, unused, sequence_number, 
                                  #x_window.window_id, x_window.x,
                                  #x_window.y, x_window.width, 
                                  #x_window.height, count)
                    #packet=struct.pack(fmt, *data_to_pack)                        
                    #packet=pad_to_32(packet)            
                    #infd.sendall(packet)   
        elif opcode_major == OPCODE_CreateWindow:
            # Create a new window for this class. No response is required. 
            self.log("Got CreateWindow")                
                
            window_id = self.extract_long(data, 0)            
            if window_id is None:                
                return False
            
            x_pos = self.extract_short(data, 8)
            if x_pos is None:
                return False
            
            y_pos = self.extract_short(data, 10)
            if y_pos is None:
                return False
            
            width = self.extract_short(data, 12)
            if width is None:
                return False
            
            height = self.extract_short(data, 14)
            if height is None:
                return False
                        
            border_width = self.extract_short(data, 16)
            if border_width is None:
                return False
            
            # Now things get annoying. The window-value-mask field tells us 
            # what properties are set in the rest of the request. For now all
            # we care about is the event-mask so we just cycle through the mask
            # in order to find what fields exist before it.
            window_value_mask = self.extract_long(data, 24)
            # event-mask is the 12th bit
            cnt = 0
            for idx in range(12):
                if window_value_mask & 2**idx:                    
                    cnt += 1
            
            base = 24
            # Each previous field is 4 bytes
            event_mask = self.extract_long(data, base + cnt*4)
            if event_mask is None:
                return False            
        
            if window_id in self.x_windows:
                self.log("Client attempted to create window 0x%x but it "
                         "already exists. This is probably a new connection."
                         "Should we maintain windows per connection?" %
                         window_id)                
            
            x_window = XWindow(window_id, x_pos, y_pos, width, height, 
                               border_width, event_mask)            
            self.x_windows[window_id] = x_window
            
            self.log("Created window with id : 0x%x" % window_id)
            self.log("Maintaining %d windows" % len(self.x_windows))
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1 
        elif opcode_major == OPCODE_CreateGC:                                    
            self.log("Got CreateGC")                
                
            window_id = self.extract_long(data, 4)            
            if window_id is None:
                return False
            
            x_window = XWindowGC(window_id)
            self.x_windows[window_id] = x_window
            
            self.log("Created window with id : 0x%x" % window_id)
            self.log("Maintaining %d windows" % len(self.x_windows))
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1                          
        elif opcode_major == OPCODE_ChangeProperty or \
           opcode_major == OPCODE_DeleteProperty:
            # All ChangeProperty requests get a PropertyNotify response 
            # property-state: 0 (NewValue)                  
            # All DeleteProperty requests get a PropertyNotify response with 
            # property-state: 1 (Deleted) 
            if opcode_major == OPCODE_ChangeProperty:
                self.log("Got ChangeProperty")            
                property_state = 0
            else: 
                self.log("Got DeleteProperty")
                property_state = 1
                
            event_code = 0x1c
            unused = 0x0

            window_id = self.extract_long(data, 0)            
            if window_id is None:
                return False
            
            atom = self.extract_long(data, 4)            
            if atom is None:
                return False
            
            if window_id in self.x_windows:
                x_window = self.x_windows[window_id]
            else:
                self.log("Attempting to change or delete a property on a " 
                         "non-existent window: 0x%x" % window_id)
                return False
            
            if property_state == 0:
                # Property change
                data_len = self.extract_long(data, 0x10)
                tmp = struct.unpack(ENDIAN + ('B' * data_len), 
                                    data[0x14:0x14 + data_len])            
                if tmp is not None:
                    property_data = tmp                
                else:
                    self.log("Error extracting data from PropertyChange")
                    return False
                x_window.properties.set_property(atom, property_data)                
            elif property_state == 1:
                # Delete property
                if x_window.properties.get_property(atom) is not None:
                    self.log("Deleting property %d on window 0x%x" % 
                             (atom, window_id))
                    x_window.properties.delete_property(atom)
                else:
                    self.log("Attempting to delete non-existant property %d "
                             "on window 0x%d" % (atom, window_id))
                    self.log("This window has the following properties: %s" % 
                             (str(x_window.properties)))
                    return False
            
            time = 357160202                    
            
            #format and send reply            
            fmt=ENDIAN+"2BH3LB"      
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(event_code, unused, sequence_number, window_id, 
                          atom, time, property_state)
                                    
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)               
        elif opcode_major == OPCODE_ConfigureWindow:
            # ConfigureWindow get a ConfigureNotify response                        
            self.log("Got ConfigureWindow")
            
            event_code = 0x16
            unused = 0x0
            override_redirect = 0x0
            
            window = self.extract_long(data, 0)            
            if window is None:
                return False
            event_window = window
            
            if window in self.x_windows:
                x_window = self.x_windows[window]        
            else:
                raise Exception("Client attempted to configure a non-existant "
                                "window (0x%x). Currently managing the following "
                                "windows: %s" % (window, str(self.x_windows)))
            
            above_sibling = 0x0            
            border_width = 0x0
            x = 0x0
            y = 0x0
            height = 0x0
            width = 0x0
            
            # The configure-window-mask specifies what attributes the request
            # wants to set. 
            
            configure_mask = self.extract_short(data, 4)                
            config_offset = 8
            
            if configure_mask & 1:                
                x = self.extract_short(data, config_offset)                 
                if x is None:
                    return False
                x_window.x = x
                config_offset += 2

            if configure_mask & 2:
                y = self.extract_short(data, config_offset)            
                if y is None:
                    return False
                x_window.y = y
                config_offset += 2
            
            if configure_mask & 4:
                width = self.extract_short(data, config_offset)            
                if width is None:
                    return False
                x_window.width = width
                config_offset += 2
                
            if configure_mask & 8:
                height = self.extract_short(data, config_offset)            
                if height is None:
                    return False
                x_window.height = height
                config_offset += 2
                
            if configure_mask & 16:
                border_width = self.extract_short(data, config_offset)            
                if border_width is None:
                    return False
                x_window.border_width = border_width
                config_offset += 2

            if configure_mask & 32:                
                sibling = self.extract_short(data, config_offset)            
                if sibling is None:
                    return False
                x_window.above_sibling = sibling
                config_offset += 2
                
            if configure_mask & 64:                
                stack_mode = self.extract_short(data, config_offset)            
                if stack_mode is None:
                    return False
                # I don't know what variable this sets in the X window. Is there
                # a stack_mode variable?
                config_offset += 2         
                
            #format and send reply            
            fmt=ENDIAN+"2BH3L5HB"      
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(event_code, unused, sequence_number, event_window, 
                          window, above_sibling, x, y, width, height,
                          border_width, override_redirect)
                                    
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)                           
        elif opcode_major == OPCODE_CopyArea:
            # All CopyArea requests get a NoExpose response 
            self.log("Got CopyArea")
            
            event_code = 0x0e
            unused = 0x0
            dst_drawable = self.extract_long(data, 4)            
            if dst_drawable is None:
                return False
            
            minor_code = 0x0
            major_code = 0x3e
            
            #format and send reply            
            fmt=ENDIAN+"2BHLHB"      
                        
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(event_code, unused, sequence_number, dst_drawable, 
                          minor_code, major_code)
                                    
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet) 
        elif opcode_major == OPCODE_GetGeometry:
            self.log("Got GetGeometry (Not fully implemented)")
                                
            reply_length = 0
            # The following were copied directly from an xvfb interaction. I've
            # no idea what their relation to the request is
            depth = 8
            root_window = 0x84
            x = y = 0
            width = 32
            height = 32
            border_width = 0
            
            #format and send reply            
            fmt=ENDIAN+"2BH2L5H"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(REPLY,depth,sequence_number,reply_length, root_window,
                          x, y, width, height, border_width)
            
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)                
        elif opcode_major == OPCODE_AllocColor:
            self.log("Got AllocColor (Not fully implemented)")
                                
            reply_length = 0
            unused = 0x0                    
            r, g, b = struct.unpack(ENDIAN + "HHH", data[4:10])

            # The var pixel is what future requests for QueryColor will use
            # to retrieve this RGB value
            pixel = len(self.color_map)
            self.color_map.append((r, g, b))
            
            #format and send reply            
            fmt=ENDIAN+"2BHL4HL"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(REPLY,unused,sequence_number,reply_length, r, g, b,
                          unused, pixel)
            
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)    
        elif opcode_major == OPCODE_QueryColors:
            self.log("Got QueryColors (Not fully implemented)")                        
            num_pixels = request_length - 2         
            self.log("Requested colors for %d pixels" % num_pixels)
            reply_length = num_pixels * 2
            magic = 0xfd
            
            pix_rgb_list = []
            # Pixel IDs start at offset 4
            base = 4
            for pix_idx in range(num_pixels):                
                query_pixel = self.extract_long(data, base + pix_idx)            
                if query_pixel is None:
                    return False
                    
                if query_pixel < len(self.color_map):
                    r, g, b = self.color_map[query_pixel]
                else:
                    r = g = b = 0xffff
                    
                # RGB values padded up to dword size
                pix_rgb_list.extend([r, g, b, 0])
            
            # format and send reply            
            # each pixel adds four shorts (RG B0x00)
            fmt=ENDIAN+"2BHL24B" + ("H" * num_pixels * 4)
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            
            data_to_pack=(REPLY,magic,sequence_number,reply_length,
                          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                          0xe0, 0x83, 0x92, 0x01, 0x00, 0x00, 0x00, 0x00, 
                          0xbf, 0x12, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00) + \
                        tuple(pix_rgb_list)        
            packet=struct.pack(fmt, *data_to_pack)                                            
            infd.sendall(packet)    
        elif opcode_major == OPCODE_LookupColor:
            self.log("Got LookupColor")
                                
            reply_length = 0
            unused = 0x0          
            
            # Extract the color name length and name
            name_len = self.extract_short(data, 4)            
            if name_len is None:
                return False
            
            tmp = struct.unpack(ENDIAN + ('c' * name_len), data[8:8 + name_len])            
            if tmp is not None:
                name = (''.join(tmp)).lower()                
            else:
                self.log("Error extracting the color name from the data")
                return False
                                
            if name in self.color_name_map:
                r, g, b = self.color_name_map[name]
            else:
                self.log("Color name '%s' not found in RGB map. Please add it." 
                         % name)
                return False
                
            # format and send reply            
            fmt=ENDIAN+"2BHL6H"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(REPLY,unused,sequence_number,reply_length, 
                          r, g, b, # Exact 
                          r, g, b  # Visual 
                          )
            
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)    
        elif opcode_major == OPCODE_GetInputFocus:
            self.log("Got GetInputFocus (Not fully implemented)")
                                
            reply_length = 0
            # The following were copied directly from an xvfb interaction. I've
            # no idea what their relation to the request is
            revert_to = 0
            focus = 1
            #format and send reply            
            fmt=ENDIAN+"2BH2L"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(REPLY,revert_to,sequence_number,reply_length, focus)
            
            packet=struct.pack(fmt, *data_to_pack)                                
            packet=pad_to_32(packet)
            infd.sendall(packet)                            
        elif opcode_major==OPCODE_QueryExtension:
            #QueryExtension
            name, data=self.STRING8(ENDIAN, data)
            #format and send reply
            self.log("Got QueryExtension of %s"%prettyprint(name))
            #format and send reply
            fmt=ENDIAN+"BBHL"
            reply_length=0 #in dwords but we count header
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            data_to_pack=(REPLY,0,sequence_number,reply_length)
            packet=struct.pack(fmt, *data_to_pack)
            
            if name=="XKEYBOARD":
                #supported
                self.log("%s is supported"%name)
                packet+=Card8(1) #present
                #packet+=Card8(148) #major opcode 
                packet+=Card8(0x8a) #major opcode 
                packet+=Card8(94) #first event
                packet+=Card8(160) #first error
            elif name=="BIG-REQUESTS":
                self.log("%s is supported"%name)
                packet+=Card8(1) #present
                packet+=Card8(0x85) #major opcode 
                packet+=Card8(0) #first event
                packet+=Card8(0) #first error
            elif name=="SHAPE":
                self.log("%s is supported"%name)
                packet+=Card8(0) #present
                packet+=Card8(129) #major opcode 
                packet+=Card8(64) #first event
                packet+=Card8(0) #first error
            else:
                self.log("%s is not supported"%name)
                #default to not supported
                packet+=Card8(0) #Present (default is off)
                packet+=Card8(0) #Major Opcode
                packet+=Card8(0) #First event
                packet+=Card8(0) #First error
            
            packet=pad_to_32(packet)            
            infd.sendall(packet)
            
        elif opcode_major==OPCODE_GetProperty:
            self.log("Got GetProperty")
            
            window_id = self.extract_long(data, 0)            
            if window_id is None:
                return False
            
            atom = self.extract_long(data, 4)            
            if atom is None:
                return False
            
            get_property_type = self.extract_long(data, 8)
            if get_property_type is None:
                return False
            
            if window_id in self.x_windows:
                x_window = self.x_windows[window_id]
            else:
                self.log("Attempting to change or delete a property on a " 
                         "non-existent window: 0x%x" % window_id)
                return False
            
            bytes_after = 0x0
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            
            prop = x_window.properties.get_property(atom)
            if prop is None:
                reply_length = 0x0
                format = 0x0
                get_property_type = 0x0                
                value_length = 0x0
                
                fmt=ENDIAN+"BBH7L"                
                data_to_pack=(REPLY,format,sequence_number,reply_length,
                          get_property_type, bytes_after, value_length, 0,
                          0x01cd9cc0, 0)
            else:
                # Does format ever change?
                format = 0x8
                
                # The property length has to be a multiple of 4
                padding = ()
                value_length = len(prop)
                if len(prop) % 4 == 0:                    
                    reply_length = value_length / 4
                else:                    
                    reply_length = (value_length / 4) + 1                    
                    tmp = []
                    [tmp.append(x) for x in range(0, len(prop) % 4)]
                    padding += tuple(tmp)
                                                        
                fmt=ENDIAN+"BBH7L" + "B" * value_length   + "B" * len(padding)              
                data_to_pack=(REPLY,format,sequence_number,reply_length,
                          get_property_type, bytes_after, value_length, 0,
                          0x01cd9cc0, 0) + prop + padding
                
            packet=struct.pack(fmt, *data_to_pack)                        
            
            infd.sendall(packet)            
        elif opcode_major==OPCODE_InternAtom:
            self.log("Got InternAtom")
                                
            reply_length = 0
            unused = 0x0          
            
            # Extract the atom name length and name
            name_len = self.extract_short(data, 0)            
            if name_len is None:
                return False
            
            tmp = struct.unpack(ENDIAN + ('c' * name_len), data[4:4 + name_len])            
            if tmp is not None:
                name = (''.join(tmp)).upper()                
            else:
                self.log("Error extracting the atom name from the data")
                return False
                                                
            if name in ATOMS:
                atom_num = ATOMS[name]
            else:            
                atom_num = 0
                
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1                
            
            self.log("InternAtom: Atom '%s' (%d)" % (name, atom_num))
            #format and send reply
            fmt=ENDIAN+"BBH7L"
            reply_length=0 #in dwords but we count header                
            data_to_pack=(REPLY,0,sequence_number,reply_length, atom_num, 
                          0, 0, 0, 0x01cd9cc0, 0)
            packet=struct.pack(fmt, *data_to_pack)                
            infd.sendall(packet)            
        elif opcode_major==OPCODE_GetKeyboardMapping:
            self.log("Got GetKeyboardMapping")
            #format and send reply
            if ENDIAN == "<":
                ##little
                new_keyboard_string=binstring(le_keyboard_string)
            else:
                ##big
                new_keyboard_string=binstring(be_keyboard_string)
            
            fmt=ENDIAN+"BBH2L4BL12B"
            reply_length=len(new_keyboard_string)/4 #in dwords
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            keysims_per_keycode=6
            data_to_pack=(REPLY,keysims_per_keycode,sequence_number,reply_length,
                          # I have no idea what keyboard_magic_one is dependent
                          # on or where it comes from
                          self.keyboard_magic_one, 0x00, 0x00, 0x00, 0x00, 
                          # keyboard_magic_two seems to be copied from our 
                          # reply to the initial EXTENSION_XKEYBOARD request
                          self.keyboard_magic_two, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
            packet=struct.pack(fmt, *data_to_pack)            
            packet+=new_keyboard_string

            self.log("Length of keyboard mapping reply: %d"%len(packet))
            self.log("Header: %s"%prettyprint(packet[:50]))
            infd.sendall(packet)
        
        elif opcode_major==OPCODE_GetPointerMapping:
            self.log("Got GetPointerMapping (Not fully implemented)")
            
            magic_one = 0x20
            reply_length = 8
            
            #format and send reply            
            fmt=ENDIAN+"BBHL56B"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            
            data_to_pack=(REPLY,magic_one,sequence_number,reply_length, 
                          0x00, 0x00, # copy/paste from an Xvfb interaction
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xdc, 
                          0x61, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 
                          0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 
                          0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 
                          0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 
                          0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20)
            
            packet=struct.pack(fmt, *data_to_pack)                    
            
            #self.log("Length of modifier mapping reply: %d"%len(packet))
            #self.log("Header: %s"%prettyprint(packet[:50]))
            infd.sendall(packet)    
        elif opcode_major==OPCODE_GetModifierMapping:
            self.log("Got GetModifierMapping")
            
            #format and send reply
            keysims_per_keycode=3
            num_keysims = 8
            new_modifier_string="\x00\x00\x00"*num_keysims            
            fmt=ENDIAN+"BBHL"
            reply_length=num_keysims-2
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            
            data_to_pack=(REPLY,keysims_per_keycode,sequence_number,reply_length)
            packet=struct.pack(fmt, *data_to_pack)
            packet=pad_to_32(packet)

            packet+=new_modifier_string
            
            #self.log("Length of modifier mapping reply: %d"%len(packet))
            #self.log("Header: %s"%prettyprint(packet[:50]))
            infd.sendall(packet)

        elif opcode_major==OPCODE_GetSelectionOwner:
            self.log("GetSelectionOwner packet came in")
            fmt=ENDIAN+"BBHL"
            reply_length=0
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            data_to_pack=(REPLY,0,sequence_number,reply_length)
            packet=struct.pack(fmt, *data_to_pack)
            packet+="\x00"*8
            packet=pad_to_32(packet)
            infd.sendall(packet)

        elif opcode_major==OPCODE_QueryFont:
            self.log("GetQueryFont packet came in")
            
            if ENDIAN == "<":
                ##little
                new_font_string=binstring(le_font_string)
            else:
                ##big
                new_font_string=binstring(be_font_string)
            
            fmt=ENDIAN+"BBHL"
            reply_length=819
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            
            data_to_pack=(REPLY,0,sequence_number,reply_length)
            packet=struct.pack(fmt, *data_to_pack)

            packet+=new_font_string
            
            self.log("Length of queryfont reply: %d"%len(packet))
            self.log("Header: %s"%prettyprint(packet[:50]))
            infd.sendall(packet)                        
        elif opcode_major==OPCODE_QueryBestSize:
            self.log("QueryBestSize packet came in")
            fmt=ENDIAN+"BBHL"
            width = struct.pack(ENDIAN+"H",64)
            height= struct.pack(ENDIAN+"H",64)
            reply_length=0 #in dwords
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
            data_to_pack=(REPLY,0,sequence_number,reply_length)
            packet=struct.pack(fmt, *data_to_pack)
            packet+=width
            packet+=height
            packet=pad_to_32(packet)
            self.log("BESTSIZE: %s"%prettyprint(packet[:50]))
            infd.sendall(packet)            
        elif opcode_major == EXTENSION_BIG_REQUESTS:
            self.log("Got EXTENSION_BIG_REQUESTS")
            
            reply_length = 0
            magic = 0xaa
            #format and send reply            
            fmt=ENDIAN+"2BHL24B"      
            
            self.log("Reply Length: %d"%reply_length)
            sequence_number=self.fds[infd]["sequence"]
            self.fds[infd]["sequence"]+=1
                                    
            data_to_pack=(REPLY,magic,sequence_number,reply_length, 
                          0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                          0xa0, 0xaa, 0x7e, 0x02, 0x00, 0x00, 0x00, 0x00)
            
            packet=struct.pack(fmt, *data_to_pack)                                
            infd.sendall(packet)                         
        elif opcode_major == EXTENSION_XKEYBOARD:
            self.log("Got EXTENSION_XKEYBOARD")
            if opcode_minor == 0x0:
                reply_length = 0
                magic = 0x01
                #format and send reply            
                fmt=ENDIAN+"2BHL8BL12B"      
                
                self.log("Reply Length: %d"%reply_length)
                sequence_number=self.fds[infd]["sequence"]
                self.fds[infd]["sequence"]+=1
                                        
                data_to_pack=(REPLY,magic,sequence_number,reply_length, 
                              0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                              self.keyboard_magic_two, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
                packet=struct.pack(fmt, *data_to_pack)                
                infd.sendall(packet)             
            elif opcode_minor == 0x8:
                # respond with some sort of keyboard map thing
                reply_length = 1014
                magic = 0x01
                #format and send reply            
                fmt=ENDIAN+"2BHL"      
                
                self.log("Reply Length: %d"%reply_length)
                sequence_number=self.fds[infd]["sequence"]
                self.fds[infd]["sequence"]+=1
                                        
                data_to_pack=(REPLY,magic,sequence_number,reply_length)            
                packet=struct.pack(fmt, *data_to_pack)
        
                fmt = ENDIAN + "4080B"                
                data_to_pack = xkeyboard_request_map
                keyboard_map = struct.pack(fmt, *data_to_pack)
                packet += keyboard_map
                infd.sendall(packet)             
            elif opcode_minor == 0x1:
                self.log("EXTENSION XKEYBOARD minor opcode 0x1."
                         "No response required")
                sequence_number=self.fds[infd]["sequence"]
                self.fds[infd]["sequence"]+=1                
            else:
                self.log("Unknown minor opcode (0x%x) for XKEYBOARD request" %
                         opcode_minor)
                return False                                            
        elif opcode_major in NO_REPLY_NEEDED:
            ##We don't need to reply to these just increment our seqnum
            self.log("No reply needed, just incrementing SEQNUM to %d" %
                     (self.fds[infd]["sequence"]-1))
            self.fds[infd]["sequence"]+=1        
            reply_needed = False        
        else:
            self.log("OPCODE %x not handled. Dying. " % opcode_major)
            # If we don't return False here then we should at least increment 
            # the sequence number so that we stay in sync with the client
            # self.fds[infd]["sequence"]+=1
            return False
           
        if reply_needed:
            self.log("Replying with Sequence Number %d" % 
                     (self.fds[infd]["sequence"]-1))
        
        return True 
    
    def close(self, infd):
        """
        Remove a fd from our dictionary and then close the socket
        """
        del self.fds[infd]
        infd.close()
        return 
    
    def getargs(self):
        
        self.screen   = int(self.argsDict.get("screen", self.screen).replace(":",""))
        self.bind_ip   = self.argsDict.get("bind_ip", self.bind_ip)
        return

    def listen(self):
        """
        Set up our 'server' to listen on the specified DISPLAY port
        """
        self.log("XServer listening on %s + %s"%(self.port, self.screen))
        self.port = self.port + int(self.screen)
        s=self.gettcplistener(self.port, self.bind_ip)

        if not s:
            if self.port < 1024:
                self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
                         "you can try to bind to a higher port" % self.port)
            else:
                self.log("Cannot listen on port %d - perhaps that port is already bound?" % self.port)
            return 0
        
        s.set_timeout(5)
        self.s=s
        self.listen_socks.append(s)
        return s 

    def accept(self, s=None ):
        """
        Try to accept one connection
        returns true if we found one
        """

        #we loop on this ,so no annoying printouts here
        self.log("Accepting connection")
        if s==None:
            s=self.s 

        # If this is a remote server that is used as a bounce,
        # then we make sure that the socket is non-blocking
        if self.argsDict.get("passednodes")[0].nodetype != "LocalNode":
            blocking = 0
        else:
            blocking = 1
      
        try:
            # If this is a MOSDEFSock we pass in a blocking parameter
            infd,addr=s.accept(blocking=blocking) 
        except TypeError:
            # If it was a regular socket, then a TypeError would be raised
            # and we don't pass in a blocking parameter, we just do a regular accept()

            try:
                infd,addr=s.accept()        
            except timeoutsocket.Timeout:
                return

        except timeoutsocket.Timeout:
            return 

        if infd==-1:
            return None, None
        
        return infd, addr

    def handle(self):
        """
        Do one "event" loop iteration
        """
        node = self.argsDict['passednodes'][0]
        if node.nodetype=="LocalNode":
            input_s, output_s, except_s = select.select(self.listen_socks,[],[])
        else:
            input_s=[]
            for i in self.listen_socks:
                if i.isactive():
                    input_s+=[i]
        
        for i_sock in input_s:
            if i_sock == self.s:
                # Server socket
                infd, addr = self.accept(i_sock) 
                if infd is not None:                        
                    self.log("New X server connection from %s" % str(addr))
                    self.fds[infd] = {}
                    ret = self.do_handshake(infd)
                    if not ret:
                        self.log("Handshake failed with %s" % str(addr))
                        self.close(infd)                        
                    else:
                        self.log("Handshake succeeded with %s" % str(addr))
                        self.listen_socks.append(infd)
            else:
                if self.do_packet(i_sock):
                    self.log("Handled packet from %s" % 
                             str(i_sock.getpeername()))
                else:
                    self.log("Done with connection from %s" % 
                             str(i_sock.getpeername()))
                    self.listen_socks.remove(i_sock)
                    self.close(i_sock)  
                    
        if len(self.listen_socks) == 1:
            self.log("No active connections in the Xserver")
            return False
        return True
    
    def run(self):

        ## check if we're a node type that supports the module
        #TODO AIX? BSD? OSX ?
        node = self.argsDict['passednodes'][0]
        
        #TODO: Fix: just check for MOSDEFSocket availability
        if node.nodetype not in ['LocalNode', 'win32Node',"solarisNode", "linuxNode"]:
            self.log('Sorry, you can not start an X Server on that nodeType')
            self.setInfo("%s on %s:%d - done (failed)"%(NAME, self.bind_ip, self.port))
            return 0

        self.getargs()
        s=self.listen()
            
        while 1:
            # Uncomment this line for testomatic testing
            #self.log("Response count: %d" % self.response_count)
            if self.state==self.HALT:
                #devlog("xserver","stopping")
                self.s.close()
                break
                                    
        ## reached when user chooses to halt webserver
        self.setInfo("%s on %s:%d - done (success!)"%(NAME,self.bind_ip,self.port))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

