import sys
import datetime
import collections

if '.' not in sys.path:
    sys.path.insert(0, '.')
from libs.ua_parser import user_agent_parser
from libs.reports import document, collector, utils
from exploitutils import devlog

from libs import odf
from libs.py3o.template import Template

TEMPLATE_FILE = utils.get_template_path(__file__)

def parse_agent(agent):
    data = user_agent_parser.Parse(agent)
    order = ['family', 'major', 'minor', 'patch']
    
    os_vals = filter(None, (data['os'][key] for key in order))
    os = ([os_vals[0], '.'.join(os_vals[1:])])
    
    agent_vals = filter(None, (data['user_agent'][key] for key in order))
    agent = ([agent_vals[0].replace('IE', 'Internet Explorer'),
        '.'.join(agent_vals[1:])])
    
    return os, agent

class Collector(collector.PickleCollector):
    """Collects ClientD data and stats from a reporting pickle."""
    
    def collect(self, data_file):
        data = self.data
        
        # set up the data structure
        data.sessions = {}
        data.clients = {}
        data.attacks = {}
        data.exploits = {}
        
        data.stats = stats = utils.Data()
        stats.session_count = 0
        stats.recon_sessions = collections.defaultdict(int)
        stats.attack_sessions = collections.defaultdict(int)
        
        stats.exploited_clients = collections.defaultdict(int)
        
        stats.attacks = collections.defaultdict(int)
        stats.successful_attacks = collections.defaultdict(int)
        
        # process the pickle file
        self.process_report_pickle(data_file)
        
        # calc some stats
        stats.client_count = len(data.clients)
        stats.recon_session_count = len(stats.recon_sessions)
        stats.attack_session_count = len(stats.attack_sessions)
        stats.exploited_client_count = len(stats.exploited_clients)
        
        # plugins
        plugins = stats.plugins = collections.defaultdict(int)
        for client in data.clients.itervalues():
            for agent in client.agents.itervalues():
                for name, version in agent.plugins.iteritems():
                    plugins[(name, version)] += 1
        
        return self.data
    
    def process_event(self, event):
        if event.module != 'clientd':
            return
        
        self.add_client(event)
        
        ename = event.name
        if 'attack' in ename:
            successful = 'successful' in ename
            self.add_attacks(event, successful)
        
        if ename == 'clientd new session':
            self.add_session(event)
        
        elif ename == 'clientd attack':
            edata = event.data
            sid = edata['sid']
            atype = edata['attack type']
            
            stats = self.data.stats
            if atype == 'recon':
                stats.recon_sessions[sid] += 1
            elif atype == 'attack':
                stats.attack_sessions[sid] += 1
    
    def add_client(self, event):
        edata = event.data
        
        ip = edata.get('ip')
        
        client = self.data.clients.get(ip)
        if not client:
            client = utils.Data()
            client.ip = ip
            client.ip_country = self.geoip_country(ip)
            client.agents = {}
            client.session_count = 0
            client.environment = {}
            self.data.clients[ip] = client
        
        client.email = edata.get('email')
        
        env = edata.get('environment')
        if env:
            client.environment.update(env)
        
        user_agent = self.get_user_agent(edata)
        if not user_agent:
            return
        
        os, browser = parse_agent(user_agent)
        
        agent = client.agents.get(user_agent)
        if not agent:
            agent = utils.Data()
            agent.name = user_agent
            agent._browser = browser
            agent.browser = ' '.join(browser)
            agent._os = os
            agent.os = ' '.join(os)
            agent.plugins = {}
            client.agents[user_agent] = agent
        
        recon = edata.get('recon')
        if not recon:
            return
        
        plugins = recon.get('plugins')
        if plugins:
            plugins.pop('AGENT', None)
            agent.language = plugins.pop('language', None)
            agent.cpu = plugins.pop('CPU', None)
            agent.platform = plugins.pop('platform', None)
            
            plugins = utils.dict_fix_unicode(plugins)
            agent.plugins.update(plugins)
    
    def add_attacks(self, event, successful=False):
        edata = event.data
        
        names = edata.get('attacks')
        if not names:
            name = edata.get('attack')
            if name:
                names = [name]
        sid = edata.get('sid')
        if not (names and sid):
            return
        
        data = self.data
        session = data.sessions[sid]
        
        for name in names:
            attack = data.attacks.get((name, sid))
            if not attack:
                attack = utils.Data()
                data.attacks[(name, sid)] = attack
            
            attack.name = name
            attack.sid = sid
            attack.successful = successful
            
            exploit = self.add_exploit_to_data(name)
            attack.exploit = exploit
            
            attack.agent = session.agent
            attack.time = utils.format_datetime(event.time)
            # raw time for sorting
            attack._time = event.time
            attack.ip = edata.get('ip')
            attack.email = edata.get('email')
            
            stats = data.stats
            stats.attacks[name] += 1
            if successful:
                stats.exploited_clients[(attack.ip, attack.agent)] += 1
                stats.successful_attacks[name] += 1
    
    def add_session(self, event):
        edata = event.data
        
        sid = edata.get('sid')
        if not sid:
            return
        
        session = self.data.sessions.get(sid)
        if session:
            return
        
        session = utils.Data()
        session.sid = sid
        self.data.sessions[sid] = session
        
        session.email = edata.get('email')
        session.ip = edata.get('ip')
        session.time = utils.format_datetime(event.time)
        session.agent = edata.get('user agent')
        
        ip = edata.get('ip')
        client = self.data.clients.get(ip)
        client.session_count += 1
        
        stats = self.data.stats
        stats.session_count += 1
    
    def get_user_agent(self, edata):
        """Pull the User-Agent out of one of the thousand places clientd
        hides it.
        """
        agent = edata.get('user agent')
        if agent:
            return agent
        recon = edata.get('recon', {})
        if recon:
            agent = recon.get('user_agent')
            if agent:
                return agent
            plugins = recon.get('plugins', {})
            if plugins:
                agent = plugins.get('AGENT')
                if agent:
                    return agent

class Document(document.ReportDocument):
    def edit(self, data):
        self.updateCoverDate()
        
        # fill in charts
        chart_doc = self.getObjectByName('exploited_clients_chart')
        self.fill_successful_sessions_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('timeline_chart')
        self.fill_timeline_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('attack_distribution_chart')
        self.fill_attack_distribution_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('platform_distribution_chart')
        self.fill_platform_distribution_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('os_distribution_chart')
        self.fill_os_distribution_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('browser_type_distribution_chart')
        self.fill_browser_type_distribution_chart(chart_doc, data)
        
        chart_doc = self.getObjectByName('browser_distribution_chart')
        self.fill_browser_distribution_chart(chart_doc, data)
    
    def fill_successful_sessions_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        not_exploited = data.stats.client_count - data.stats.exploited_client_count
        self.addRowToTableRows(rows, ['Not exploited (%s)' % not_exploited, not_exploited])
        
        key = lambda x: (x[1], x[0])
        for name, count in sorted(data.stats.successful_attacks.items(), key=key):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])
    
    def fill_timeline_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        if not data.attacks:
            return
        
        times = []
        success_times = []
        for attack in data.attacks.itervalues():
            t = attack._time
            if not t:
                continue
            times.append(t)
            if attack.successful:
                success_times.append(t)
        times.sort()
        
        lo = datetime.datetime.fromtimestamp(times[0])
        hi = datetime.datetime.fromtimestamp(times[-1])
        diff = utils.total_seconds(hi - lo)
        res = utils.time_resolution(diff / 100.0)
        
        timeline = collections.defaultdict(lambda: [0, 0])
        for t in times:
            rt = utils.round_int(t, res)
            if t in success_times:
                timeline[rt][1] += 1
            else:
                timeline[rt][0] += 1
        
        lo = utils.round_int(times[0], res)
        hi = utils.round_int(times[-1], res) + res
        blank_check = False
        for i in range(lo, hi, res):
            t = datetime.datetime.fromtimestamp(i).strftime('%a %b %d @ %H:%M')
            if i not in timeline:
                if blank_check:
                    continue
                else:
                    blank_check = True
                    t = '...'
                    values = [0, 0]
            else:
                values = timeline[i]
                blank_check = False
            self.addRowToTableRows(rows, [t] + values)
    
    def fill_attack_distribution_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        attack_count = collections.defaultdict(int)
        for attack in data.attacks.itervalues():
            attack_count[attack.name] += 1
        
        for name, count in sorted(attack_count.items()):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])
    
    def fill_platform_distribution_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        platform_count = collections.defaultdict(int)
        for client in data.clients.itervalues():
            for agent in client.agents.itervalues():
                platform = agent.platform
                if platform == '<unknown>':
                    platform = 'Unknown Platform'
                platform_count[platform] += 1
        
        for name, count in sorted(platform_count.items()):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])
    
    def fill_os_distribution_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        os_count = collections.defaultdict(int)
        for client in data.clients.itervalues():
            for agent in client.agents.itervalues():
                os_count[agent.os] += 1
        
        for name, count in sorted(os_count.items()):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])
    
    def fill_browser_type_distribution_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        browser_count = collections.defaultdict(int)
        for client in data.clients.itervalues():
            for agent in client.agents.itervalues():
                browser = agent._browser[0].title()
                browser_count[browser] += 1
        
        for name, count in sorted(browser_count.items()):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])
    
    def fill_browser_distribution_chart(self, doc, data):
        rows = doc.body.getElementsByType(odf.table.TableRows)[0]
        # clear any existing rows
        del rows.childNodes[:]
        
        browser_count = collections.defaultdict(int)
        for client in data.clients.itervalues():
            for agent in client.agents.itervalues():
                browser_count[agent.browser] += 1
        
        for name, count in sorted(browser_count.items()):
            self.addRowToTableRows(rows, ['%s (%s)' % (name, count), count])

def generate(data_file, template_file, output_file):
    template_file = template_file or TEMPLATE_FILE
    
    data = Collector().collect(data_file)
    
    Template(template_file, output_file).render(
        {'data': data, 'stats': data.stats})
    devlog('reports', 'template saved to: %s' % output_file)
    
    doc = Document(output_file)
    doc.edit(data)
    doc.save()
    devlog('reports', 'document saved to: %s' % output_file)

if __name__ == '__main__':
    generate()
