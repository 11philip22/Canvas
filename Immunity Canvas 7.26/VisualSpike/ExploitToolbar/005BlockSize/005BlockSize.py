#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


import sys
import gtk
if "." not in sys.path: sys.path.append(".")
from toolbar import VisualToolbar
from gettext import gettext as N_

class Toolobject(VisualToolbar):
    NAME = "BlockSize"
    GLADE_DIALOG = "dialog.glade2"
    filexpm = "blocksize.ico"
    button_label = "Add sizeof block field"
    button_tooltip = "Add a sizeof block field to the fuzzer"
    button_private_tooltip = "Private"
    button_signal = None
    color = "#f7de00"
    size = 55
    NumberofXp =1
    objsize = 0
    objectcomments = None  
    inttype = 1
    boxargs={}

    
    
    link=False
    inttypes = ["BINARYBIGENDIAN", "ASCII", "ONEBYTE", "BINARYLITTLEENDIANHALFWORD", "BINARYBIGENDIAN", "ZEROASCIIHEX", "ASCIIHEX", "ASCIIUNSIGNED", "INTELENDIANWORD"]
    inttypessize = [ 4,             len,     1,         2,                             4,                len,            len,       len,              4               ]
    def __init__(self):
        VisualToolbar.__init__(self)


    def setSize(self, size):
        self.size =size

    def setArg(self,args):
        if args.has_key('checkbadchar'):
            self.string = args['checkbadchar']
            try:
                tmp=self.string.decode('string_escape')
            except ValueError:
                tmp="Error parsing string!"
        if args.has_key("inttype"):
            try:
                self.inttype = args["inttype"]
            except KeyError:
                tmp = "Wrong integer type"
            
            if type(self.inttypessize[self.inttype]) == type(1):
                self.objsize = self.inttypessize[self.inttype]
            else:
                self.objsize = self.inttypessize[self.inttype]( tmp )
            
        if args.has_key('preparexpacket' ):
            self.xpacket2send = args['preparexpacket']

            
        #self.fuzzeable = args['checkfuzzeable']
            
    def setDialog(self,dialog,xpacket,badchars,arch):
        # The self.xpacketlist is set on the setEssential function
        
        hboxpreparexpacket = dialog.get_widget("hbox4")    
        
        preparexpacket = gtk.combo_box_new_text()
        hboxpreparexpacket.pack_start(preparexpacket,expand=True, padding=0)        
        
        preparexpacket.show()
        
        if len(self.xpacketlist) == 0:
            preparexpacket.append_text(N_('No Buffer to send yet'))
        else:
            preparexpacket.append_text(N_('Select Buffer to send'))
        
        for a in self.xpacketlist:
            preparexpacket.append_text(str(self.xpacketlist.index(a) + 1))
           
        try:
            preparexpacket.set_active(int(self.boxargs['preparexpacket']))
        except:
            preparexpacket.set_active(0)
        
        
        
        preparexpacket.connect('changed', self.changedp)

        string = dialog.get_widget('checkbadchar')
        string.set_text( self.string )
        inttype = dialog.get_widget('inttype')
        inttype.set_active( self.inttype )
        

    def changedp(self, combobox):
        model = combobox.get_model()
        index = combobox.get_active()
        
        self.boxargs['preparexpacket'] = model[index][0]
        self.setArg(self.boxargs)
        return      


    def createPython(self):
        return ["spk.s_block_size(Buffer_%d, %r, %d)\n" % (int(self.xpacket2send), self.inttypes[ self.inttype].decode('string_escape'), int(self.string) )]  

    def Show(self):
        try:
            buf = "Sizeof Block: %s\nLength: %d bytes" % (self.string, int(self.objsize))
        except:
            buf = "Sizeof Block: None Length: None"
 
        return buf


    def preparedialog(self,dialog, argb,argc,badchars,arch):
        #def preparedialog(self,widget,xpacketlist,fdlist):
        print "-" * 10
        print self.xpacketlist

        self.xpacketlist = self.xpacketlist
        #sendstring=widget.get_widget('sendstring')
        #sendstring.set_text(self.sendstring)
        hboxpreparexpacket = dialog.get_widget("hbox4")    
        #hboxpreparefd = widget.get_widget("hbox5") 
        
        preparexpacket = gtk.combo_box_new_text()
        hboxpreparexpacket.pack_start(preparexpacket,expand=True, padding=0)
        #preparefd = gtk.combo_box_new_text()
        #hboxpreparefd.pack_start(preparefd,expand=True, padding=0)
        
        preparexpacket.show()
        #basic edition == silent sockets
        #preparefd.show()
        
        if len(self.xpacketlist) == 0:
            preparexpacket.append_text('No Buffer to send yet')
        else:
            preparexpacket.append_text('Select Buffer to send')
        
        for a in self.xpacketlist:
            preparexpacket.append_text(str(self.xpacketlist.index(a) + 1))
            
        #if len(fdlist) == 0:
        #  preparefd.append_text('No FD to use yet')
        #else:
        #  preparefd.append_text('Select FD to use')
        #for a in fdlist:
        #    preparefd.append_text(str(fdlist.index(a) + 1))
        
        preparexpacket.set_active(0)
        #preparefd.set_active(0)
        
        preparexpacket.connect('changed', self.changedp)
        #preparefd.connect('changed', self.changedf)
        



    def Help(self):
        return "The string buffer option allows you to place a string into your exploit \n\
buffer. The most common use for the string object is when you have to \n\
deal with certain protocol elements.\n\
\n\
e.g. to exploit a HTTP Content-Length parsing overflow we would create \n\
an evil request buffer like so:\n\
\n\
1. string \"GET / HTTP/1.0\r\nContent-Length: \"\n\
2. place other data (nops, payload, etc.)\n\
3. string \"\\r\\n\\r\\n\""


    def getSize(self):
        try:
            tmp=self.string.decode('string_escape')
        except ValueError:
            tmp="Error parsing string!"
        
        if type(self.inttypessize[self.inttype]) == type(1):
            self.objsize = self.inttypessize[self.inttype]
        else:
            self.objsize = self.inttypessize[self.inttype]( tmp )
        
        #self.objsize = len(self.string.decode('string_escape'))
        return int(self.objsize)

    def save(self):
        savedic = {}
        savedic['string'] = self.string
        savedic['objsize'] = str(self.getSize())
        if self.objectcomments:
            savedic['comment'] = self.objectcomments.replace("\n","\\n")
        #savedic['checkfuzzeable'] = self.fuzzeable
        savedic['inttype'] = self.inttype
        if self.xpacket2send:
            savedic['xpacket2send']=self.xpacket2send

        
        return savedic

    def load(self,args):
        if args.has_key('string'):
            self.string = args['string']
            
        if args.has_key('inttype'):
            self.inttype = args['inttype']

        if args.has_key('objsize'):
            self.objsize = args['objsize']

        #if args.has_key('checkfuzzeable'):
        #    self.fuzzeable = args['checkfuzzeable'] 

        if args.has_key('comment'):
            tmp = args['comment']
            self.objectcomments=tmp.replace("\\n","\n")
            
        if args.has_key('xpacket2send'):
            self.xpacket2send = args['xpacket2send']      
