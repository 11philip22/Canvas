#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


import sys
import gtk
if "." not in sys.path: sys.path.append(".")
from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
    NAME = "integer"
    GLADE_DIALOG = "dialog.glade2"
    filexpm = "integer.ico"
    button_label = "Add Integer"
    button_tooltip = "Add a Integer to the fuzzer"
    button_private_tooltip = "Private"
    button_signal = None
    color = "#00ba3c"
    size = 55
    NumberofXp =1
    objsize = 0
    objectcomments = None  
    inttype = 1
    fuzzeable = False
    
    link=False
    inttypes = ["BINARYBIGENDIAN", "ASCII", "ONEBYTE", "BINARYLITTLEENDIANHALFWORD", "BINARYBIGENDIAN", "ZEROASCIIHEX", "ASCIIHEX", "ASCIIUNSIGNED", "INTELENDIANWORD"]
    inttypessize = [ 4,             len,     1,         2,                             4,                len,            len,       len,              4               ]
    def __init__(self):
        VisualToolbar.__init__(self)


    def setSize(self, size):
        self.size = size

    def setArg(self,args):
        self.string = args['checkbadchar']
        try:
            tmp=self.string.decode('string_escape')
        except ValueError:
            tmp="Error parsing string!"
                    
        self.inttype = args['inttype']
        
        if type(self.inttypessize[self.inttype]) == type(1):
            self.objsize = self.inttypessize[self.inttype]
        else:
            self.objsize = self.inttypessize[self.inttype]( tmp )
            
        self.fuzzeable = args['checkfuzzeable']
            
    def setDialog(self,dialog,xpacket,badchars,arch):
        string = dialog.get_widget('checkbadchar')
        string.set_text( self.string )
        inttype = dialog.get_widget('inttype')
        inttype.set_active( self.inttype )
        
        fuzzeable = dialog.get_widget('checkfuzzeable')
        if self.fuzzeable == True:
            fuzzeable.set_active(True)
        else:
            fuzzeable.set_active(False)

        #checkrepeat.connect('toggled', self.changes,box,repeat)

    def changes(self,checkrepeat,box,repeat):
        return 


    def createPython(self):
        if self.fuzzeable:
            return ["spk.s_int_variable(%d, %r)\n" % (int(self.string), self.inttypes[ self.inttype].decode('string_escape') )]  
        else:
            return ["spk.s_int(%d, %r)\n" % (int(self.string), self.inttypes[ self.inttype].decode('string_escape') )]  

    def Show(self):
        try:
            buf = "Int: %s\nLength: %d bytes Fuzzable: %s" % (self.string, int(self.objsize), str(self.fuzzeable))
        except:
            buf = "Int: None Length: None"
 
        return buf


    def preparedialog(self,dialog,argb,argc,badchars,arch):
        checkfuzzeable = dialog.get_widget('checkfuzzeable')
        
        if self.fuzzeable == True:
            checkfuzzeable.set_active(True)
        else:
            checkfuzzeable.set_active(False)
        #checkrepeat.connect('toggled', self.changes,box,repeat)



    def Help(self):
        return "The string buffer option allows you to place a string into your exploit \n\
buffer. The most common use for the string object is when you have to \n\
deal with certain protocol elements.\n\
\n\
e.g. to exploit a HTTP Content-Length parsing overflow we would create \n\
an evil request buffer like so:\n\
\n\
1. string \"GET / HTTP/1.0\r\nContent-Length: \"\n\
2. place other data (nops, payload, etc.)\n\
3. string \"\\r\\n\\r\\n\""


    def getSize(self):
        self.objsize = self.inttypessize[self.inttype]
        return int(self.objsize)

    def save(self):
        savedic = {}
        savedic['string'] = self.string
        savedic['objsize'] = str(self.getSize())
        if self.objectcomments:
            savedic['comment'] = self.objectcomments.replace("\n","\\n")
        savedic['checkfuzzeable'] = self.fuzzeable
        savedic['inttype'] = self.inttype
        
        return savedic

    def load(self,args):
        if args.has_key('string'):
            self.string = args['string']
            
        if args.has_key('inttype'):
            self.inttype = args['inttype']

        if args.has_key('objsize'):
            self.objsize = args['objsize']

        if args.has_key('checkfuzzeable'):
            self.fuzzeable = args['checkfuzzeable'] 

        if args.has_key('comment'):
            tmp = args['comment']
            self.objectcomments=tmp.replace("\\n","\n")
