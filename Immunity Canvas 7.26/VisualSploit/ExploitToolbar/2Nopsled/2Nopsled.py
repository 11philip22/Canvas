#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


import sys
import random
import gtk
sys.path.append(".")
sys.path.append("../")
sys.path.append("../../")
from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
  NAME = "Nopsled"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "nops.ico"
  button_label = "Add nopsled"
  button_tooltip = "Add a nopsled to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#b89afe"
  size = 35
  type = "random"
  NumberofXp = 1
  objsize = 0
  randnopsled = chr(0x90) + "ABCD"
  objectcomments = None
  occurences=None
  link=False

  
  def __init__(self):
    VisualToolbar.__init__(self)


  def setSize(self, size):
    self.size =size
    
  def setArg(self,args):
    self.size = 35
    self.string = args['checkbadchar']
    tmp=args['checkbadchar'].decode('string_escape')
    try:    
      self.objsize   =  int(args['size']) * len(tmp)
      self.occurences = str(args['size'])
    except:
      pass
    self.code = args['code']
    if args['random'] == True:
      self.type = "random"
      self.string=""
      for a in range(0,int(args['size'])):
        self.string+=random.choice(self.randnopsled)
      tmp=self.string.decode('string_escape')
      self.objsize   =  int(args['size']) * len(tmp)
      self.occurences = str(args['size'])
    elif args['given'] ==True:
      self.type = "given"
    else:
      self.type = "debug"
      self.string ="\\xcc"
      self.objsize = 1 * int(self.occurences)
      
    
  def Show(self):
    if self.type=="random":
      buf = "Size: %s\nOccurences: %s Value: Random" %(self.getSize(),self.occurences)
    elif self.type == "debug":
      buf = "Size: %s\nOccurences: %s Value: Debug" % (self.objsize,self.occurences)
    elif self.type == "given":
      buf = "Size: %s\nOccurences: %s Value: %s" % (self.objsize, self.occurences, self.string)
    else:
      buf = "Size: 0\nOccurences: 0 Value: None"
    return buf
  
  def Help(self):
    return "The NOP option allows to set a so-called nopsled for your payload.\n\
NOP stands for \'No Operation\'. When you can not exactly calculate where \n\
your payload will live, often you will have to pad your payload with NOP \n\
instructions. There are two approaches for this: you can set the actual \n\
NOP instruction for the architecture (nop on x86, which translates to a \n\
\\x90 byte value) or you can use \'harmless\' instructions like \'incl %reg\'. \n\
A very common nop option is to use 'incl %ecx' which translates \n\
to a \\x41 byte value, or 'A'). It is wise to use alternative nop options \n\
because most Intrusion Detection Systems will catch actual nop \n\
instructions (i.e. \\x90 bytes) as malicious data."


  def setDialog(self,dialog,xpacket,badchars,arch):
    size=dialog.get_widget('size')
    string=dialog.get_widget('checkbadchar')
    code=dialog.get_widget('code')
    random=dialog.get_widget('random')
    given=dialog.get_widget('given')
    given.connect('toggled', self.changes,string)  
    debug=dialog.get_widget('debug')
    size.set_text(str(self.occurences))
    string.set_text(self.string)
    code.set_text(self.code)
    if self.type == "random":
      random.set_active(True)
      string.set_text("")
    elif self.type == "given":
      given.set_active(True)
    else:
      debug.set_active(True)
      string.set_text("")
      
    
    
    
  
  def getSize(self):
    if self.type == "random":
      try:
        tmp=self.string.decode('string_escape')
        self.objsize   =  len(tmp)
        return int(self.objsize)
      except:
        return 0
    try:
      tmp=self.string.decode('string_escape')
      self.objsize   =  int(self.occurences) * len(tmp)
      return int(self.objsize)
    except:
      return 0
  
  def changes(self, given,string):
    string.set_sensitive(given.get_active())
    return
      
  
  def createPython(self):
    return  ["buf+= %r * %s\n" % (self.string.decode('string_escape'), self.occurences)]
  
  def preparedialog(self,dialog,argb,argc,badchars,arch):
    given=dialog.get_widget('given')
    string=dialog.get_widget('checkbadchar')
    given.connect('toggled', self.changes,string)
    
    
    
  def save(self):
    savedic={}
    savedic['string']=self.string
    savedic['code']=self.code
    savedic['occurences']=self.occurences
    savedic['type']=self.type
    savedic['objsize']=self.objsize
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    return savedic

  
  def load(self,args):
    if args.has_key('string'):
      self.string = args['string']
      
    if args.has_key('code'):
      self.code = args['code']
      
    if args.has_key('occurences'):
      self.occurences = args['occurences']
    
    if args.has_key('type'):
      self.type = args['type']
    
    if args.has_key('objsize'):
      self.objsize = args['objsize']
    
    if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
      

  
