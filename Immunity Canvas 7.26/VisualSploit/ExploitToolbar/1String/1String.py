#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


import sys
import gtk
if "." not in sys.path: sys.path.append(".")
from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
    NAME = "String"
    GLADE_DIALOG = "dialog.glade2"
    filexpm = "string.ico"
    button_label = "Add String"
    button_tooltip = "Add a String to exploit packet"
    button_private_tooltip = "Private"
    button_signal = None
    color = "#8dc7bb"
    size = 55
    NumberofXp =1
    objsize = 0
    objectcomments = None  
    repeat = 1
    checkrepeat = False
    link=False




    def __init__(self):
        VisualToolbar.__init__(self)


    def setSize(self, size):
        self.size =size

    def setArg(self,args):
        self.string = args['checkbadchar']
        try:
            tmp=self.string.decode('string_escape')
        except ValueError:
            tmp="Error parsing string!"
        self.objsize = len(tmp)
        self.repeat = args['repeat']
        if args['checkrepeat'] == True:
            self.checkrepeat = True
        else:
            self.checkrepeat = False




    def setDialog(self,dialog,xpacket,badchars,arch):
        string=dialog.get_widget('checkbadchar')
        string.set_text(self.string)
        repeat=dialog.get_widget('repeat')
        repeat.set_value(int(self.repeat))
        box=dialog.get_widget('hbox4')
        repeat.set_value(int(self.repeat))
        checkrepeat = dialog.get_widget('checkrepeat')
        if self.checkrepeat == True:
            checkrepeat.set_active(True)
            box.show()
        else:
            checkrepeat.set_active(False)
            box.hide()

        checkrepeat.connect('toggled', self.changes,box,repeat)

    def changes(self,checkrepeat,box,repeat):
        if checkrepeat.get_active() == True:
            box.show()
        else:
            self.repeat="1"
            repeat.set_value(int(self.repeat))
            box.hide()
        return


    def createPython(self):
        if self.repeat == 1:
            return ["buf+=%r\n" % self.string.decode('string_escape')]  
        elif self.repeat > 1:
            return ["buf+= %r * %s\n" % (self.string.decode('string_escape'), self.repeat)]
        else:
            print "You must repeat the string at least one time, if repeat value is < 1 then nothing will be written"


    def Show(self):
        if self.repeat == 1:
            try:
                buf = "String: %s\nLength: %d bytes" % (self.string, int(self.objsize))
            except:
                buf = "String: None Length: None"
        elif self.repeat > 1:
            try:
                tmp=self.string.decode('string_escape')
                tmp = len(tmp)
                buf = "String: %s\nLength: %d bytes - Repeat String %s times\nTotal Size: %s" % (self.string, tmp,str(self.repeat),str(self.getSize()))
            except:
                buf = "String: None Length: None"
        else:
            buf = "String: None Length: None"
            print "Repeat value must be > 1"

        return buf


    def preparedialog(self,dialog,argb,argc,badchars,arch):
        box=dialog.get_widget('hbox4')
        checkrepeat=dialog.get_widget('checkrepeat')
        repeat=dialog.get_widget('repeat')
        if self.checkrepeat == True:
            checkrepeat.set_active(True)
            box.show()
        else:
            checkrepeat.set_active(False)
            box.hide()
        checkrepeat.connect('toggled', self.changes,box,repeat)



    def Help(self):
        return "The string buffer option allows you to place a string into your exploit \n\
buffer. The most common use for the string object is when you have to \n\
deal with certain protocol elements.\n\
\n\
e.g. to exploit a HTTP Conetent-Length parsing overflow we would create \n\
an evil request buffer like so:\n\
\n\
1. string \"GET / HTTP/1.0\r\nContent-Length: \"\n\
2. place other data (nops, payload, etc.)\n\
3. string \"\\r\\n\\r\\n\""


    def getSize(self):
        if self.repeat == 1:
            tmp=self.string.decode('string_escape')
            self.objsize = len(tmp)
        elif self.repeat > 1:
            tmp=self.string.decode('string_escape')
            self.objsize = len(tmp) * self.repeat
        else:
            print "Can not set Object Size if repeat value is < 0"
        return int(self.objsize)

    def save(self):
        savedic={}
        savedic['string']=self.string
        savedic['objsize']=str(self.getSize())
        if self.objectcomments:
            savedic['comment']=self.objectcomments.replace("\n","\\n")
        savedic['repeat']=self.repeat
        savedic['checkrepeat']=self.checkrepeat
        return savedic
        #f.write("+++"+self.NAME+"\n")
        #f.write("**string="+"\""+str(self.string)+"\""+"\n")
        #f.write("**objsize="+"\""+str(self.objsize)+"\""+"\n")

    def load(self,args):
        if args.has_key('string'):
            self.string = args['string']

        if args.has_key('objsize'):
            self.objsize = args['objsize']

        if args.has_key('repeat'):
            self.repeat = int(args['repeat'])

        if args.has_key('checkrepeat'):
            if args['checkrepeat'] == "True":
                self.checkrepeat = True
            else:
                self.checkrepeat = False


        if args.has_key('comment'):
            tmp = args['comment']
            self.objectcomments=tmp.replace("\\n","\n")



