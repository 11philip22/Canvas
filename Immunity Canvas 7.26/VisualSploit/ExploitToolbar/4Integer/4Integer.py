#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


from toolbar import VisualToolbar


class Toolobject(VisualToolbar):
  NAME = "Integer"
  GLADE_DIALOG = "dialog.glade2"
  filexpm = "Integer.ico"
  button_label = "Add Integer"
  button_tooltip = "Add a Integer to exploit packet"
  button_private_tooltip = "Private"
  button_signal = None
  color = "#00ba3c"
  size = 45
  type = "random"
  NumberofXp =1
  objsize = 4
  objectcomments = None
  link=False

  
  def __init__(self):
    VisualToolbar.__init__(self)


  def setSize(self, size):
    self.size =size
        
  def setArg(self,args):
    self.value = args['value']
    self.objsize=4
    if args['littleendian'] == True:
      self.type = "Little Endian"
    else:
      self.type = "Big Endian"
  
  def setDialog(self,dialog,xpacket,badchars,arch):
    value=dialog.get_widget('value')
    littleendian=dialog.get_widget('littleendian')
    bigendian=dialog.get_widget('bigendian')
    try:
      v=int(self.value,16)
    except ValueError:
      print "Incorrect value in Integer Object"
    value.set_text(self.value)
    if self.type == "Little Endian":
      littleendian.set_active(True)
      bigendian.set_active(False)
    else:
      bigendian.set_active(True)
      littleendian.set_active(False)
      
  def Show(self):
    return "Value: %s\ntype: %s" % (self.value, self.type)
  
  def Help(self):
    return "The integer buffer option allows you to set a integer value in either \n\
little endian or big endian byte ordering."
  
  def createPython(self):
    #strip off the leading 0x - numbers are always hex!
    if self.value[:2]=="0x":
      self.value=self.value[2:]
    if self.type == "Big Endian":
            return ["buf+= big_order(0x%s)\n" % self.value]
    else:
            return ["buf+= intel_order(0x%s)\n" % self.value]
  
  def preparedialog(self,arga,argb,argc,badchars,arch):
    pass
  
  
  def save(self):
    savedic={}
    savedic['value']=self.value
    savedic['objsize']=self.objsize
    savedic['type']=self.type
    if self.objectcomments:
      savedic['comment']=self.objectcomments.replace("\n","\\n")
    return savedic
    #f.write("+++"+self.NAME+"\n")
    #f.write("**value="+"\""+str(self.value)+"\""+"\n")
    #f.write("**objsize="+"\""+str(self.objsize)+"\""+"\n")
    #f.write("**type="+"\""+self.type+"\""+"\n")
  
  def load(self,args):
    if args.has_key('value'):
      self.value = args['value']
      
    if args.has_key('type'):
      self.type = args['type']
      
    if args.has_key('objsize'):
      self.objsize = args['objsize']
    
    if args.has_key('comment'):
      tmp = args['comment']
      self.objectcomments=tmp.replace("\\n","\n")
  
  def getTarget(self):
    return self.value
